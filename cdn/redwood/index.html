<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c5f2ff1475719b40df09e9d75de7c4bfc3e2b3f37f5a48811489822178ba8a2013a33ded765fa0849635f9524d4114e889e2614bde996012492c69d7caac43ad0ed9107604f869f5cfe68ffda7708d1e022c06d5a2a301b9923ed4e6001ddc982395e877e83e8f7261be05e16574e5519351f0f7ffc51e04201a1dc58789ab399e3d7c34f97c8eb9a8b999d0422fb4035caa3971ec6273b4b3bf655c8a234bdceed60186b4eee1040c066a7c243e99512a11b22d59a732f590db87e4c1203a1e9310ebb988740cad11b28cd0e1eaf21cf4c013ff736f4dcac91eb8266c9bdd30b5a9c5d25346c21f944ccb24213a521fb8da2796b0d629023bc655bdb7be2c114b9624c533cc04b1bd11a5520e52f1880c3aa36173433031ff2dbd098b6bfd16f08b457b6b699729970b93c46d12f0ac645fd8d8b95250bb69b214f6a76e8ae1adcf4b742753e1b24931fce9718fd0bdce5a3d4ae58046a25dc74a64fbe69c77da64a07fb6037e62f6322782bddf12e08f9fffc01c81fd8c62cb48f418081a60f8e98ee6f8f22ee4c554854dd6488a258091dbc8695612834d68100534847fdf887a57980bb2e8deda76713141733b9a36afa67586db591151ca9251e3df3bf7adb95009af3dee40307ec6c2b99fd4a583d6ec98731ac7071e121e191a4b12d340f8c42cb9516c8bd37a9c823b87120c3a94295d1a145839ee6402040058da361f0bc3b2a896a67d8e284d1b4059b13de6e8c06a497014da223e3f82ce55474734f3e5f27c4567e42a0e794edbb6acfae762315c5a15a70bfebd620cbeab9055f81c313df4e7bb90f9ec8b3219d6091a42a7f27e64b827b84ab83fe1b7ef494caabfedf575ae6bdf7fc3e1938d2eeb46d911e363e99ad7e498ce224090a0f01248e1b38f87ec5b5773cec7ee6e24dd4bc7030c7675970a46c995f059ade9a9f2034346188c060edb43469bcaed18112ffdfeaa75cfbcc80a5a2a4fc88e13b40c63c1a83de5604fab5415140b1002b55dbc056b49eceea82370b6cd96a4809c6cfabda4a172e4e9f70943bd4c9e0edaf900d963ebea6db2dac750dbcdd20d44d93105e0731d146ade593cb7ad692f49811e246cbc3b1e21cb996e33d7c7bed99bbbed913d4dce3fc6fc3274e55c986b3d9d2d30963ab53bf77d008f80898d5f5ab9ccdd75e1bd6f6e5bf1d6955464b5f00059195d643db058a921c9cc5c0fc015f5841600937dff933238da12a1bbf15b65f221a1e11c39a0ec1d2d2cea64e5584abf83b480255f29c33b534ca7eacf80814d2a6c37c614bc30926051d68fc022a305d1ed7d0e9f0dda23673c06a9b13bcdf69416e84e0989f747a21037dfa83a3aeac633db3a23db92f0df9abc32833e94ed0bc4bb185de65a89585261a92e82eeaa1045cefd230a513867fe6a8c2704a5c454382aca5601c72cbcb17baa23e3fe4e063300ba42962e58275e43c2531532b7849f3a18344fd4ded76403f18ae54e41d79ca1e7c16519b4c2deebc40481a3f66763e4687033bdf08b43671113ec2c14d685a559745c805fb31bc11c9cfa13d90ff1ff08299049167f973b6e8fc0d55d0ed48cc05630ad11932861f809bb6decaf0716e33587f55725269c6b82049be6cdecc806d663298ee0cfc3dbbc1aa6b6dd81308bccdf84bed25f5041391c75b014028f350ac7c2a4e5b7c15882525f8f3d39cc95b7aefe8ee0b54c19c9766a9d6f6fe6d1a1cf88db7759e3696c3410056d0e3214464e6c52320f0a5f84e117fa87a46bc4159600c3e3f823cfdede8799cacb329cd5663061ba0d1299035f448c1ca04d23d3e53dbaf668704274ebdd002425749e17aa78d41aa34d6bc2b4156cc8a0c00b2335dea90327df945cd8796e553d0e219c64173ae29cc1bc998e2492ed2844a1a9ece3d89cf3b83e8312c2d2aa2647c540c98b3320acd4bffe8064f72e89d5f84bf42be29f5f0301f61f068cad8903caa6d53f2f9cb9e6cf928798ecbb9340dd8b0c30fb7e62251d92f30e6931d1c6f8c67a354139257e5428766aef24c446649b8ca14d440c1974def46e6e9513ab4e722576a25ddc413759709dee0405e04526c616fd22c86a8efdf6fad3b740f63d295043c92911f3d323f6b76f3de907d29864824f88098998a21a4d6f81472ee572f6c51735804afa6d0922c0b5db903132276cd20c43e5300ad366ac5a19e2de1917fb15140760d84533082be6b2b014e1397b271054036a031664bd19c1c17f6c0f02d10a5dd258a489ff56efff8da0fc0b31c873a657e8db922ecddddda740895208fa1fdab8e9d1c93022bf4b4824f18352ea4e62dee760a685d3f6d5b746d280e3152ff9571a5eaa0b71775e58dc25c2bf9586c316ea2a47dcc9ad667886a416adc186db22d4b99f9b9acc7f38feaca1915a4c931c643ace75a4e54dc9749c63235bbb282ea2323a085f53271b04c384ae57b78fa4abe206fe23048967f3826bbfbfdb3035c6fea8cefb8484897e44085a175628dafd25809c5d7b05c55f81c70825680edae728212d8538699d358a10863e80fc637d3da4f38ade58e2df846ac41dd22468260c1c3ddc70cda63d8be605c25cef0627b41a7572269f3b0eac6ced53b67c1c4601a7b002494eaa07942cba2b2652dd8c0804584b5aee3662fa83851a05f755070d72b57641fe178bbdee25da44c726839c7f1a9fe4784be51012652edfb7ad5636aa008c4135e5908af82d23d0c9358cd43f8f494f53530f726a9db1a153fd2d98821f97d06cf235087078e6ede500655173230b2636a1af8d572e0371fafb98d60c49981bedd2230b79e7613a3bdefb42dc53214bb1c22e03c7fb4a9d1204cb96c9907b9dbf468ed83b7584eec4af34aa19d0d51bdc931a98611733474e54eb1e22cdac5ea3bc2411c688ff4bf06d2b5484e867da4ffd86c5d7ca864ae35902d3a325a19dc0ba582853c85cfd11a9f1d060ecb729c8fac6d5fd76b51f9347cf9a5e2414e792763af87b8527e83513e2d3653745fe2a506973959b670c995a0453aa3f53567f4699bbf563d6a8f9ab54202125d85ba47c02e08232ed5d9d63869667053b3b2079661d460f0880ab10a4f40be80424f3013b1e8d607a160e75d393ca7aee231dbb7d095cb3f1281b44868b072d91173d04c89a43d5294aa8226ee53c0f51b8e2d508192b024946fafe65bf434f948a3001918fe35b13680524f7dd1c944612d990b5da5c7b10a30d289d85607790f9d714c51e0dc3c89f6fa4a5b036a8a062b09bff090ea9616a75a41657b85853b212c54c84d2f6b888d6d10f46924feed08faf40eadd2c597325e14d1a83dc86b463e4ed2af760a8f852747136249955df0007798ad9f20208dbccb10d3e797b4def6cf15c31d95ed02b263a2ca075f55c5cf50e4ac8ee9edf913cd3293f3998a24a1dd48f20ce71045d20469658dfd6250667ff5febb02e14cee013c2f7afd2237a6f02293961c17c1a9aec7f8e4712639fcc7c13f9396940e2d09b953ceb60809dcc2e2b4ded01cc290ef596af1135f833722486dc2bd50dbcfe0d7b983bd33b496d0f8287624b121fa8e947d2fc2a47f50d9f80ef7140843ee68f9774c334de7a9ba2ee8dbe5b9829a72d84b38663709d6c896c5d1b0baf9a40e7a12d51f4ec639f35163d1deb4cce51ff490dadbb628659056f266d55a700eec1921eb067bde9aa2323c003aa7529ea2754f83427976911ca514475a46ab8db597a690d985067aa28ceb20da346909c8eb395b5357f337c378ab74643e300ea7dc84d0fefeb30387793f5a827d4c849d2038429b1c78d12d5f5aecc6352cdcae43b74f9c34b175bda3b2e1292c9e0c24c3da1c1767d53eb6afeaa2c57a1032700e65efb579e53455fbb58db7ac514693aa4f86542ab06e78fb2ec1a982d7e74742a18d01b3205b9dc31a61d5b1b1a959577087a8b8d826edaec17a7ed7d9756550dae84f575b06dad59a8a5261fecbd54c6773301013b7c4dab4d519a2545adb00aef562afb1083145f68bdb19fc1d15f076c740a9f57b254b85da16df2bf8bbaafd6b6fc7a2f3fb17f1ec85c9781601a7637e454408230792464b54c3d901440e67b90f68fa5a30d2d434dfe57bea05ca7e03f8120d6403f6d5ad49489507dd0a7d99c79c0d92f87ec43925a7922c638be01f3b54212ba267637f5a8652b9b4605e843f8fb29c007381fc9f3a2280a49037b436b6f367eb414cdd5eb58e0fd3ba998b9405d87f7f0fa7ee0039b7cad682707ddb74285fa5750d56168029543732f2995c2bf375dc87a8c74dabedd695650dbd861b51c533a122e34babfb06786a4580c15e6047a66dec3418f4e081c1d8b79d302f23b75b534233e06d1dc478e788305640cbb329f4dcc7d32dc73032939d03a450c325ab325a3e8da13e03017778a68dbe35dd83c463939e65d576fad9fb9bef917fd4b23a3042a2765fb84ccb88bd6e94784a7a0600dfec7b89ad6c313c62512964e7fda1d2ed03481fdf0a8083289c387c17721efd46e9dc2ef39569b552b208404a9478dd5a6533da860c4cf6a7948bcc3a644c6af3ba0cf8c34d8a15c9d64bbc641f72add52ead1cf4d508c79e2b4a5371b17924ea91c6909e458de9520003bb085583bec0807deaa0a901f4eafc2f41c35228784910406579a7563b5a85a5b94a9a32b85970597fdb4981c09d90cb7bb8e5857c7f15226a968ce67720d45a72b46608561772e7e16e4c93a149030ab3c395daa05e47509e55ddbb60b05e12fe21109e015bc5f9086909edb472434a867343d7657161090206a27aa1d62ac38b9197ea90e0aeacbfb61ec0717891c8e97b4adc3d1af3cd06512df43f87447cbde617cc9f181eeb8ea88f998fcfa3d847c0bbf3171d37fa21af308ecb404001e262855a40166ed90abf744419da5d1b73114314534e3c4c11c9ecda80e4832dcb96b352a5abd10d1640c8c0f4ae7bb088cca49a29669f2b370fb7489c586d1f02a786539f420324505d7f8271aa9a497158b43a1ea9530a25331f1db1c566d61cc34643b9ed98ca0509efbda9a2dca9602b5713b52da4eb7770884e3fcb65a2171fd13568c83692288b50698d3c1e4b6cde08b25a8b02badd7a650d0b3f6eef69de526bc4860eb08d134633f4fe670690a2f3b85e487d82257da437d3999be6fd4a316ee008d515b1d406afa65ddd7287cc1eff8ee3a04570e83b51f1362468012e7f044793170738399cddf8a6bcf93141d06d44de1a6bfa3caa14a5d70c28223004385f9f8fa3dcce01eef5c7a8126f453f6d61929e8e0799fe3c1ebc91f9608b9b515ffcbfe061b6f82e1ef0168aadcf1b65922b9da50d3117f8bdfa0c2db9ce5f57da718fe3aa58310fe1cad06a30dc1a8425d3aa1f7ac5eefa717efb25c5b9a7f98bed25d59e085918c7f91a860808daa17b0af5e05f5d4587d6974917d061e95759ea7bdcd9b676dbf5d0c348f3744339d0ccab191126281e922cc85cff4b67b6b266d91f4e419516659709e92aae2eb4fc7e40bfa2969a943958dc1637c073eb6399a90c503e0bc9f6fb38229f96b3b14c94ee8f3ef48634e7a7e46424d4bdd44e3c697c0d5eb1af5422dd2ba8896f0f9ed32071376837c65c3cf90adea34e70f59561986fe71da706993f6b1e34d04bff82e7735770d5f8365c3c735be5ff840d9e3d4a0aa7596381588ed61e57d9565659613da2eaad0f54a6d05a6e3970f6c36cd836e714e9f5f0e8aecd5f9fb204a4b8af7b15641bdbcfa3438931b5100d2cbe45a32829e46615a90f4c821db9e6262af9cb0c1b1051de3f0eb83f0f65a3072b9673f820507cab91dff8de583a51735ae5d243ff181f6dfa42b2b2ddd036b0dda03861f90f615cd6645db699f7fa9f54a712e3f0288f717bbbb99e49691f8954cb8d7352c01bdc93d27f2a71035712f0f66295f96d62acec8fbea92ac56cb190bd6cb6370cbbb5ce5ddd633d3d3b4b0cb386df278d0614731eafdc4637c6572fc490290a019e93e9da24d006e5ec9b7957bc08fdf062821ecfa87fcb7386dcf6333942902fac0a380bab82c3be3ba39fe2667db8f4f0146812b216fe315a7e9f57510f2d360cf609dfdaa3e9fd1890e76b00fd03bfd54453f63b5748497528f6b9d4efb287db51852f44ea0dd1eb063318ce2ea39d38982ba79dd601b6044a54c1a0f915425973459fc36be61d5a934d2e515a92e0f7e030a0fa577c57bcc2ecb0f3cb9b608486fe86d827405f9a56f871d97e0351349f330795fc1bc6d50d030117310f2335b3bcc1022dadc01de697ac3122c63edf66e6ded2af4e5b64c7ece37f5f3bcb905d25b7a73a7aff63161d423b4cf2e09b9a46d8f4fd4773bc1e43e8a65db9b35e4ea3dc567a9df9228593ff9a62da22c4c7e40a043261ca290ee2343bc465e7f5c653524dc9aa9245f0e8ea38dca89c7c1fa02667fe57f4b479d5575319f6e738140c2f3c2203071614b9a58332ba7ac13374be9994323186f485fe4ba37694df227f21a28b8e3d8aa4295f11de38fd58f3d59128d1d3a8bfe13127918182c97adaf43545af4712918df6c9f304994d042c7fd93816c8dbaf2d0085157029cb838942bcde0020a7089c461bce05a9599a2ff75e45e736be2115dc795107225bbc4968af8880dce2458aa00ca01aa795dc7e80faf108078870d81fb8b2c0503c18a045f85986328454a803af0f9df86f017c1e9f788500faa6a52eb440fbad26490be5b7aa239eb90ba4221d97a07dd0c02a44c34a90be8f41c61a907f6b7be979daf38caab6ab9a24199bac8837eb82aabbb0665366f34a70bc44e74ac3fbf3c448a98e0204a1a1be6352e88bee81b51991f66defc7f22ba50dade1f9b4b0a5abb911d446786485054bb955510ae972240ffe53d1e1b6baf9b2c16e6c854c8c985b31b9b280ccacd34c366f429f7d4f9f31fd29b21cb637e2061a91b10391c1beec14f912fab5f47a825b48a0e86faabb62bd1f4560de0d860e159a137575cabcf611522d03b900b9fe6941dec8a190084fdfed2033b5c42fac0746a40ea64848e1e3423bd48f83acd6fed68bc7a1f2c673c96744198a67e98cbb67be81c8be793d3afbd885ca9f413293b63246e40e122d33513b2af0824096cc579a19bbcc3ab0a0ca0ddedc538da4cc08c6d7f73900627fead04c44be9a75a6b1449c9be9f50427312b669ceea1c70e12d4e3cb05910abc0d350fc8908305b158ec7b933f486966311af59967064f989851691eed0e8b71d60363152df31cd4c9755a4e85c34deb64eb2e55450de29dddff7fd5b720fd1324131c983045be5383daa82227acb1a748fa5c7124314ba1ed78b2b76969a6bda2a50dd8d57d120383c87a2634c53f4a2d538397b45107290cb8974e87d4d746787eb5621278f9122d78c83413790a2d9f171d7f2730a80330ce315ea6823a3f8a8b694d4454b7ef6821157fb2ea0a906b2ac53f697bb0c86b6b770c350d11cb83a44b66904fc756380ab25e13c27d26b1df71db5c1b452659e72217be79739e1e4976591021511659795dd44ba17dee874d9922006b49a86a623aa7fe13ac019678bab58e413314cb131a8f805333ba35497445ca3987efb2db07bd480623054c2e2b9245950a0320a427f1ea1445ab6abea3ac74ab3ef94cb8511f934ff4d4cf434752f34b48fe632e913374d70b705066cccbe361ff7e56a10b53d542c50e8b9c54185f6bcc070f16189b41a1421981ef21ca0537577109fe205bb69fed40a2384c2efc72f6623838c7380fd6908da49fb6165415a3ad64f92797611dca3381ff5528da88b281c9185352b8daddf760ff6176d4e51463b5326f2d63f65eb468daa62209eaa76e4e0bb4aec5a2e52580bed6c8b00163ce4b833eaa999e13c37a5433215f0947333f15e17ca8722dec45c6fc23e207e5b6dd73c357d38d9e29fca63bbe7e7c32e2ae0eda2b58a1f723c9a09cd1947c0860bce66245526073ec5a45083511f83649cbe35683ea6e8a9654ec8e23e54324b0412aee514fd215a8ba76c9ac25ceef1a95369dca4be05243e3e6527f31935ea71036be2ad4b3e6e12de64d4c5dbca94149f3ed804d2d771ccd7f31dff64e697f19e6e068b7ae42d1368aea7d2576bd67ec190517641b3876fb07e6273624b856bdaea591606e31ec8d1921ce2f2692416463f4852908bcedacd582e8474572646a39b5df65e93f5733289145c21ff9419c2e3e6290f9f779a409bd63d2ca091cafe12fd1a78b49f712ce44613fe9b15c5907dd19bf46996a8ba9e0c43f70dd4c4ffc553ec28a383dd5832ee2c0cd26a6fe048d8b7128c898f25ac7095c21a6b69bc09f0249bfeb589ebba0a8d21df8ff6cc9a26b9a889508fb2b3b5883dfce5def543ab3eb0e2cde8056a57a8b058d8fdf8a99b458c0a221f2203b7da5435c5532b5e937edc82fa77665efa77ded5d3a7cf8d9c1b9ceb225615b5a6155e01ca99ca1a8b1e55b001cb712bb7740c6b00a852123f8b3eadf98d331c5b8a076435550061847c6ea27fcb5b326aae42c217db247e21c1f34a7690da099da4b44aa3401556de9aa9bf9b1bd9f5cf68e0ff0c2cc82e9b53518a72033427bcdec43e450ab4c7faf786a764e279e5f3e98b3564a18b137b328160a37cbabcb00e1e43b725ef173d6980c322220a00f772428c9639bc7d16953255f793828d3bb65506f957bfabc09a8d23d05e3644a4f2cee7cae513713027fb28011df4cc9bdfcdcebee7c4f513c1dd5bad7e72b49046234c45c3f104270d3a4c7e66038f1c9975da88d96c3f9d828c76a9cb9db8716db20a415a3ec95aaf5ed9351f169deb4ca4f3d80dc7fcaf028ee0d87c5db7a7344ab48e618f05d38bddfbdd1144f83b6dc0e2277cff6d1f573f0e31df5cc1580ea1aaaf6f6d81174b0103e4e290d6a1b260e84df803b74a035905a6ac0fc51b50b01dfd3cce48240e8d1099315d3aba63cd5e8437955424267ba2c854b6f66a0b3d4f94cc88daaeb2dce7c8e1a8a14fc99a0f8cb7697163f6647f518c5aaf517c41f40f249a8b9e0b8ded3cd4e2ca75fb3c371a38fd4c953c71c5f37f5c4ae2869b0207f63dbe0244821ddbea3a718cca116e4d56c3da0d8cebf887abe7646584cab62c1185880d1cc8528c5919e210b2e7740714d4e14114668e5a1adae2ab5887844bd2900a382c4c4fa33640f9360d5dc4d6db13315a229c9835d7f33b4fc067341f1fc35f7aa2b73b6c46b9fa02964ccd3727677e38931765ce727894f82a817d4e261566471a17703100e6e7af331272f9a49a202de2155fd84a7e4e852becf56c89e3c79a2432aeafcbc8043faf1fd4182466caa56dd4c82571552bd0d73fe1d97efd18894f8cdf8585ca917d08fd371cec69c85f9d324093c8daed535a337b713d1d33db279558d14fee80a0fa3f93a598c3bdbfb1e8d1c41e0f1155c2b7b25928a5183dd2687c6c54978b20731f8917fc8d9a07b32aab2cb07291b4eecde71f0e696a224d43b9bdd6f17200aaf716695a55a99bcf9863687a4ed4143681de47150cf42d0adbc8ec428791f7e91f9e4e8eade9c2b48a4f0a1690b633ba850ed9f5353345a5b3ba977e65507db277e5726f95f71c02fd827abf1329177beab92e82ad1e1ee37d27ff2e52dbcc501a339ebc8c169a7654f8c6d59d041156b89b670c770131c541094902ec772aa44cfcf6863413dfa5a10495438e709e25986255625e28cc01cd5e37934d94b2ba5f0a160d8225b3ec64dc0126d8c7acda41a3c321d3b9233d16c6620782b89dfc1bc8f0062863aaca9c226efd8ed81424a24ecc5523046bb85dcdd083d200980d822cfa15050530799e75ae3b4ca133b82595301270d171d850a86da52c3866a2fdad793f8de4bb50bce2915832144287e0d16e1537987f34d234161f7120286ecbcd062ccff0b3c9c357171a8a123cb98d0ca378a91ca2fbe6d85f69907921204dfbbb888e09f04c83da80e570382ae338be6d6ce6798c7bb0ef6dcb681c8b646e104c5e7f9baed7fdeeb89d6c9f0d0a4632788d3c14c0619b2260bd04392c0bbc32cc1322bc272ce637e053edc80b126fcbcddc6012bc904507ba656f65f2e0b9a3b1c01b997fcf670869de0aed8ba4000e2e75d18a281b340891c1edb5cc30b85a4f6664645642c511e97d7263fd6cbdebe2035a58b63a6216a810d683ac7ec0096ffdd00fccbadf73c05ef9d1e4d959c7cc9dd9d319a30a72232df735269ff57728f08c851e749156c2d40a13aaaad8f3f34a34e5e382a098ea6e6a2d5031451192dddb58adb9675433af5a98d5d4954204573c475ae36fd43091ce0d1aafb23330dad97d7b3bb19d826036895eaf5fccfb5fdac8153e5567a56111f187150850067d79bd893ce754bf8be0d68eecfe60f5a89e2654cb742ddce1573b90ce2bcff355585ff1afded564555445ba0b49a113a4812b0361a514cb1deb74c18d2d147ca42481b6bbc08557051d22cbf88881f05f8cddaa78b68ce6bff52bdee0b0af1691669c7be9a0e878c7db0a4fb8225fe0a40ec310833048876828688a6e93468ea2e1094e05fa86a78ebcecd2dd66630a68ff2796596080a44e7c8806f3f1a3b3707c4da31cacd3cd49456b9a8cbc84a0ad909333a4841013844094f5550a960c49dc80a6dbfc1790da26a8b1e38e46bfc705ebe77f2c83c607025236f3fb5d9ee2fbc5f733bb40682d5e900f4861559f2098d3867bfeae903178f61833d48550998839224fa3c354f812b628187a5832e136a96070f490ac41f2be63d05f161e88c89c745ff6c99490d0a892b9be2f40d2361d92f267c97fa6dec2fb915d057cb838e2f62fda349469d4bce017426e68b17aac22a6b794b1bd3a84d05e589beb7de91b18d848127eff145b3cb24a769ec19bb42c70cf6ebf1215817d78b0a2ec0f9bc0490c27229a5c6cfc6cfe75bcb5b5b786519a417226f3544fc9ff1c5925ef45d867e5f45a164c63b21c8e1222696574fa7c2f66958635f8d9587e1f8351101c154d497a6131d8204c0b6d8b4a9c91854676d733a01ad1f83d479dc82c8d1acee8dcb208497ef3882cb33f904eed558eb45a93ebc34c02f8f8f19627da1c4393734fb3b598b3c02b5cc147535c8e93b990e2a80c259d1d6aa78a3599d86ec7e4e98a707a0d17597b5728c9ea72b5e4afd86b4b76c2cd59820ce1a49c404d1e82f26946b2d7169de95942c84ce548b0de1500461efcace00c40c7c91438e1295d378143f32381db992c0df35136187685aa5ce931bae38a42f762d0fdfcaef3e70dfbd7eaa65b91418171be36a6eb1bcaa87f6c4ffc66dbb90b6730adccf6e29fb41807b4023d79dd1ada98e47e636a943d1c63c0f8ea29ede280fde7aa60858edde5c0750583b5f53410dbd49d5294305e3cc6b2d05b340cc87d4870b04b607a7d91f5e4e48f86064e97cc9acf59eae13716bb5051e13c61e13ac89978cb1baebed6a16845a352a5dfc1c9a75094d90e9b48b87ae03c5a0abc3c60aaeaf9848e3bf305da3c77d801ce272959863096fbfa1e88f04b024b15733e50750de127b9f3ce264f9a837a563d724d2f335b2acb104f24cf143e8141c33fc87b98febc0ba7c69e816396e3ee3f8978d26a3f359451906b00dea5856457883bc981de777aa2632aa0a2c3802236ad5ae09f6fa531c4e4abe1f90b4a7d7d874ffac1d2d7d42c70b64c5e3fa8d0eb662c125b6d3235d16352b303c71a91bb2d7123402ccc6ba734427196aafc22b96b23b52fa9a9a8a3f041b233db771cd3f069b351be4165b1a8ac4bcb3f716f39e4c359075f83a5177a6f6b39d67ecc9f7ba0bfe1c8153541056ef3f14f7520a7f2ae6b21344fab633d128ea01c43eedbf07a4a94e56fb2446869f049e9a48949c90d694281ffcc285eb30310ad92d7ceab91e5199fb3686f6b3e6509d6ee85f3352bf91d0dd4243a6235b18c2b7129a5dcf3fca4f40ad323d1754f72c17b97eb64d006579df80d503df637335dd2da9d618a6d0fa214c6f3c7e4e786b2fe0eb8e670ffcdffdb75b0866a1dd3257339c3cef23f936d5925484f46f81fff8f6188be88182094e345fb1b1b384c8c8da0dbef59e0854cdaa5557f7586a30497a2c561f18165b8d923d59b6cc1cc3a992973a354c496048a94da31ba84b714e5fd0ca1d0ee1282bdf24b16d9c33c449b21449cad6e556c82124070daa50a981bd1ded7e5fe377bb98c98db45a7abe9c86d36404372689279eb2006de5c165fab061cbb618f23d04b232c706ffe5aa55ec6a43b4a660196b7d03ea0138473fb4273a0e235a7ee98548bbdf2eff84ad77c82f469a150947d8619e7d73df0e7c8d8a62f55e1726cb709fdbb09caefbe3135971b459ee5721c809f20c108012c2cdabe60917427fb4edd4b2e74da89f4132bc6fac33b8e4f7830c8973bc4853f4a4e4592ecfbf6cd033014dcba828cf56fe4637e90a96bdfb7f8e151f0ba034aa1a3f485cce27c745e3c5dde2ca4f456e6dde08e5caf07fb20a94bd0b86c1df319f7e5e3cd47fe94e3ecc416142d5e2145a4a2ce46fb48926dfd0155ecbc4c7fb2edf594b7faac62055e584a161c9a8b6b9a40a337ef95b7e44529287801f5ee6d577b71bc017059788681096677b63908b8bed62c5f74b66a823a138291a1fc588cda2ad6daa9b0ec1a7f8430d9b3c43c655128e2b6c194503b92de0508ba928baa4ace3252b6b584e11f0826f1f571e7ef393b0044d3807c5bdfe660489588a57322d20ba938baffee4273dcacee0ac4bedfaa813a59fd005b7ad38c4230144ad39859ee4e47ac1be2048b73af7d5c015dc7b346f91afc8cebc456ef0673542bcd108f2cdb63fe329b2b426829a259ba8a858921a2dcfbe6f821c4e0c13499e023988f55de03c8d5c31dd60fae884cdcee27a6ac1d68772afa8139db07f675429ca1a7f8fc68fbd7277695cec5f0818c9f80706685b02c92d0fefc3cf6043a9831cf0e4e996095988ac90672dc30573eeb23f2abbed8e7c1e46cccf3a3a11e10a3e793af47147e39fdd66efca81ee2fb12365332726ea4018d32eb54ba3df087b6dd0898bc3efd16088f5a8df2e0739fa2247dfcd14716ec0163306b73c8bd7a4c146fa8d842b329ce9f472a574258a3d55c99effd5991ded70941a4cd45a117f45f0b12d8bec77ef751083ddcce44af6496bdd7a281850a20de25abf901432821b398a11e6d34e71bf9e3f680e47f8dfaccf8ec7ffff2bc2d78232265961a980350a2e16159e4e7e68786eba70258073e9966265ddbf4f9aee76614cd3544b690e8f573f283651a5a52d9aefcc8599164e98aaf756b4f519fb2fde67e96bc5b933c750be21f54ae83b5b28c857e408785416100ba744b99b3bad6f91580cb9716bbf950e6569e46a88a05460ca5501805f23fc30b5575955a3e292dbdbf9fa69a7bfab2bd9ffbbf8393cfb2cd9ce7dce921d470cc5bddf29743b8249ef79907d62bc91a8549c9aebe4386147df809ba1e9b9933affad4d6cd52e6feca590db6712d4d619480135c1f9d8e534894a332e349ab2070b170a86a77b65a269c9a2accb4cb12bbe4f7388ae0d28c0db61d3f9c4cbcdaf6d8a6548982b6c339b73cb56f53929527bb09bbe56feb023f8d3de4e4ce22d25e8b8596fc14764a9d6431456cefaee405b417d4de21347182a34e0f602092ad9d5399b2f9564c38ad9925b63192cb0f483de20045776b10123e7c122112a9dfcacfcb582e0610d49d319b1555e25a20bb644f85bd90b3689d8919dfe5af2019b75230d25d6ddf0e28dfe7f3e2684fb87aab771a1e342c8167a5a0e4a72817acc6801b09666cfd18c4f5bbd2cb2ab6ca9ad1249d6c1e76ecc95f67ee0c69a96fe8bf57df8f332258862799b3ab4919e919227d21e4467622d4379c54c295fa6d7efbf0dcc71b36f537e5efbe040a5d154bcd8327e79bea8fdd29b9c176a4e6c8e5870fdf17763bec3125d66f2d471498fba2b1f92ac122f7631972c22e3ca88651f149dfeb82b3410c01a4c91c776ce839f0bcdce13ecf192f713058dbbd5e830f9950c8937e3ec795b160cc60caba67526658a9aa74397bc38840ee9cc09b2eb65115ac6c48d6142ab7c9841ce9a60dbc0925bceead3384b31a1233bc0c7f2f8b629d46dcd7f9a3e7263a1aed308a766646717f39e5d8974954e766853bc1d63522c03b7e63f697de84542ac720c48fb31bbf3867b8c7c53ac9ea0a8169fbbfc5b973d79371eb95d1438f01d1c6a8b4d15025aba9da1fcf3a8519af7a98b1199c8eab8d64c783ad03cb430f3dfef5e5ed12c2d84dbe8ca2b3e91dbcf54ae71a21eaec56c18ab8a91d65de8bfa32afd5e7956c281868bc4ee5c7fc08d40acd3b604b400d96cdea90fae0fdce76cdd1dfb43b1acd794efcf4b13cf35c1f5d40c88e027df0dac9e4829c7245bd70a77bd784f80d8000b66aa4d9d05d0c07c212fcd468fecfa03cf3b325f70e24c52a7cbc08d15ab800f407a1de2ce5be6cb065584d707aa0ce880e1819be5f1ab908a50bdeaca71c9d806ca4d9fc996cd0a1d45a87a293f08dce10629e89ef3c3dfa2e0438ae27ab592996072a8faa350f568675942df41da4ffb5cd691d7787ca0abc84b6c8e3006e1a551814a1cf38080ea2e8af5681f7fdbde8361200e72a591267a5299c027b824e8b50cbd51a40d503067c9bdb718e3e8842c02a4f0769bf593ce3b90c2832ac7d8389e5b8d61d209fa7bb6ec138f06302f41784fd97c21f5546db01a7df0d23bc9f6a451c536e04ecaf6cdbaab5baf169e8ebcd61265ad4c1a8315252be512b447f4a987f886ea26c2af55cf2e9a4a29fd8f5d41fdb062af071c940da0c5070b66b1c6a3fc6816c201c5aaaaa2fe11c3b20d093198550c5a0247d5940f9b534ad1921c740d69b71dd1ebcbad625215c73e4eceed9fa1397bedd378478ed129376cfa080a858d65b1202ca1c694b877b71671626c1a5fe1427b8bea3f88b0f50d48ea0c7f076ed416e5d1bc7fcabac78b751eda59fb1fe7ae4723354c60ebb7d39e508ce89d0e04aa6a1d81054ae268bbba8be06b616ee175055d3ada106a8d2700e78ec81cfcc0995a3a929ccb9b9455bdcefdb6b6489eda80f9381d7867264e1f926d0b60abf7157563b2abf675a9752aa89107d42c1c7085bab9b87adf92eb5f729408d22cfbd341b7af5ef3441f2e3cc7247c53867caf73b438ce1478b528c6415ced35b7c83fd3b9b4e49c61f617fc713c784668992152c71fd2fa7c2131a52f962d2b910b0d3d595f043fccbf9cbdbe9712d3fc5b1240e2114dd0f9d5e40ce23d2ef301fa5150df80c8cc34d27b031659cb9f91a5ee78839de23b257bcc244d7eb6cecabfd30a29b0437a3b3533dc54d7db4795ff524be6a995b379a582d542a18c4dbbd2ecd56f5120edb6a2169e019b34f8f0f54d9e8593124381a922f19e9d6d1cac3f53dea87e26d8cf0d01017a332caae42168b51792ef848d4ba2fd0472e8d174d46a124c9b837e3429da27dd0de231bcef577c84291f4be9ce1917845e82baff485150641f278d702559cf09c5e9a089d643a4e6a334bb2310673f1dcc90d5bd7694512e855bf10039143bba2220116adc09634f5060ca975a3ba9252ab2c322866b2cc2bcae2f138202152e92f59caf56fd1341b0ff9069f1b4a2685f8c420400bf61880d27e304451eec62e086611e8ec4df5ec1f725c065d781ce8eebf8cec477a5fa2fd8e4138a7ed9f358912e5b5a38eb8c3075ee18e176e32b6cd63aecb68674c0bb1304b20428191277f51a6c97a0b252300fa442e3369867b3a0bb554fe7f60551a8045bf95bc1d1bcf5a9e222031e1f22dab9fd2cab8bf078bf917cb43742193b5dd4605f121b646097bf58b864ff117260daa581155a047862e794e9654a1d7a0c8a9fb06becb70ec41d09bbe7d452d3e10623dacb329feddad0a6057b7594e9b07ebad2781ddf97f651f4582ba41ce46a53627aff171c5a8f4da467c4d027c8b7b41d0f69193b65a85abed9b59b7128f6a5d38746cff31cc7ee55ce063c72adf83513ea28d75feb9f7157870e2521714dcae0465cc821ad025d3aaae7909bc63f24e273e55bd0136c7351176d55c9d27d4e9baa24400a22c661ab7f2f4f3dc473888b1fb52842b8730f28333f2ac5b55840605e9dcc13b6d165b6d155221a47f81af8d7874923259b85f9f9edb49e10657b21bf5f8b1b7f7ec6bdc509d91b7ac7d2be2304de61833f72228d8c1ffd57079ead300a0d3baa2d3d100e40c93212d53b7ce2307f302ab5916a239744fcc8759cae7cd3c7ee7dbd6a548de0463187afe0a164b6149009d25b474aff12f39cd0cd980d2f526231bf49df1f8d570254ae959464a2dcb045345c9df8c35e4d1f91dc1d658b9325f2964293e0d945dcd0413c3fe4e97ba91a27154089dc0fbafed5c51eb91057944b9746c4cf64c8cfa90fefe02ced39f1098df7528f06a23e1ee05b85f994acf18fb5413f0f61e192f318a5b4d22bed960f29c3306b11c8ef612bee11003637584487a76e085d462e32c5daa3955893b246eb04615d4a4afd76aedac778dd8532ff2b111b0bf5b5706f39e0f08496132ac0a153cd784b1fae1ec30f44e506abe272458d7aa1edc301edf9d262a148f87e991e669df0c80a83289225f971dc604432a5e9b6f5de90d7ebff0032f3c1817c6df40e02136d6f3b9b796c36f8f4dfd250dd2af465f1bc6203e70ed4bd58ad7b343a71abdbcfaefc55bcb7812cf58ad7008d7f7690c3450d9ef9b4e047d36b1c3372c528ab6118e0b5f60ca51b9853a2d39a77b6947d7d0995561b11092ac1990a99e339c77d8342611f540e85f6b579ef01942c05e3d546312eba6f7a22774614d2ce6909098b4ec7fb15b7f6ff476afe3e667ad8c13f85d4f7e6be9e13018111994d8ddbac4eb88520142418776f03c386b5a6078cbb05f4c96e98a51b101f684b7f545011fb8d9678367d4b59e2afb4442686d0812b4b4d44d367f531f96fe9b0681f894f2d9a3c4fbe2fe9c422a869fdfbc9287b07f75ab5ada9e0e723f948299cebe4d8ba372e0869484f825d7509b0d63185ce7ffa077674b2686b079eb653d5dd1e94d4b99cb3b4e39ac19a365784eacec14d5867831e5493c3a20bdc32ed13ca30f29fea3d752fb0013ba9e57a9b9db69cc5176bc644a959839ded3246f33df0857aed9a47875f0984d1a595b80461abd1baedfbe0414ad4ce1109a1577bae794590d076f3df7449dc9305fe8f8b5bea0993ffbda45bfe10fc58e3aa46a3f8479106112e95e2836a029afad1b8c97bb7744b4299a5df66eb9efbfae0058d09a40711e05d870ce61a71a368aed56dd8e738d8a6c6a6a582efab5f3a85ebfd8078ec9aa5d54e075bc1e55c8e04be71092092e91bcb5a9c903cb184bf4189c9394db0283f39f4bc636c16f93a349be3d9c128427336aff200bf674341f3ce3ddbacf465ad9e0a374580eab271dd82988dba95f2c9637e7b811ecc6e3835f499e74b172427f09b3c4db0a63e96b28ba752eda1ad58712af82c9cd84c39602ca7d02e18e30ca1b2a2ab5743ea256eb9cff71e9cf85f45918c66f7998f974a13fa4f73f727d3d8e4eb4dffefd4646a8bdba352280a6501caf6b356f091e19b2d1677bd074ca15f539f2a362034df9711888bf4627af960088a8704ad59dd46266fb2256dbd5afd0b62f0856ababa7c42d2e27ea0ac6e7d02f712828aed5c5f07fc95935c9e65ccd91eb951956affbc8b59e9faa1349ea60ac3c0b59903c6008331f70cfd1aad8e30ffa710323878954644036e31861fd10c46e889d19de9e4dda5eebddfcd7054dd46739967b925c5867787a52051624cecacf62e1b246cc1b0bb380d46d98e336b3b968f2ae0ce934b0c082bf5cbe14b87b73294834bd72a791494abcaab1b0b7c8f7ee1b505cd7f8c093de9baed33675efb0bf10fcc789ceebf151b0440ee73dcaf708bcfbf69e005539d67afffb5e2cb67351a19fbc4e35a4018e7f62225ec26098e36067544bbcf8ba4da05432ce9c0105623bd8d821ebee5b17e7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
