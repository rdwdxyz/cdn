<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ae4c1c712bb1c1f714cbd6c502c1de2fe817fdaf4687fa021bf21dec8388e1bb5f970716625c664dcf9821a0000384b98daaa30ee05907557cc8e745ca9498e49ab50dd68d56366682b9db30580c159753cf649b55989bb7f3e0566d978306eea1d2581211ae628769360c58dba0fa40730410f55719c64956a67273a3cf7ae7142fc19c41d5c3ab497d1f8f8c113bebc2bb03cb149b65af20df399999e61a98ec80e300181aeaa89e1b016b5d65cf2deab703de658b649d6e21f6a39c36b901905e3b396d511f61870e5dcba2355362aadad919149e15dbb3399917f82c710598b40511a87758673403725a1cd86fc424c79428683862b44cbe6d47a0d065990e910a04b08161c4a06a34035133f9c5cc19ff5e85a421050402e70b23bbb3c55f56506940197d25f0ef87f900d61354dc3b9a8cd74d6d275f3a0ca6ad6ce6202117c3ac7aa788fd2419a6f8df066b15927c5017f4187f8870aa3fa6a08c248abfa9a8b190d1cc6ed8597b3939ef60133bbcc8d86fc4f4ade33b361bc2b7de0a014c3f346c33e15531c86efe2b0b73bf80ce1859b1cc554ada0f662739f4f19cdb21aa5a4cbf6e5b6a0aee0ad82fd789d7db9707c367dece412683a62a6f4dc0e15f08f927e9a8817d939eae8798d63ff811081b6b5541f74a3c5a28851aaff7fd3a7ac9d9caf49c4aea37b657fa408cf642a9a84c1327f9dcc685f1495437d594d0e624ad6e81dded714b0c0d137a0b76c082ff8bf641e725bcec058c1dabae7e083b3aed15932cebc93ccd10c5f4af532781f00f32ebd8fc1e30ce818f48eaf0f5d4a624db7daa763c6fce7e8b30e8506fcde310c6dfda55a6cff502016c38064d11298cc839d09b29d735f746e6be323570c609195f9011f72d63dd787c483b1bb819b3ae460e517a5ecfd6e4bc783f816da8017ad9e83903e96d0eaa486d8b87d27473dcc9e14b57abf531c64fb6f7003c87275943e97d339dab029827966ceb4d7b4f5ef80f13dd489c8157d993dc26913fba2e5dcd280c61d3a3ee794de9125cfe45136603bc2b21c2e3382fa858f5509fedb7a02096f9fa94b06daabbddda8e53d3ed11582ad76ec1603bca881af8a7c340bfac8f2bfcdd7228c3033873404185c3748f3f8739f8ccb99c435594294bb41d1c1576a20fdd2608d485d8f7dcfb5f1edeb46e1fd5ee51b561c5881903108d0d2b08ddc5e1728a3edf16952bbd361662a2dcbce8a480725246bb2e7e7929a148c8d57dc4ac2fb560119820119477b8a1597e2e3e8f06be832804ac022b8441398498205b222a5a59cc23d5193b0aed2130f1152d3cf2d3da77686f5088e93f1d4f71e4d591f1a20fa9e877cfa218bf0f8c60e52690e24ef66cce8d42dc65496dc819aa6c25f0c711252f61432133b3aea0c98390e06090f5a71827cdf2d1634cedf56ee6e6ffd02645e0a254ea0a45e216f6389b34b08ab346fb493bb6e51c30c8c417a2f9dcb1791757ed9c4ace07b768222a7ae136cc2bb3214aa5b195d01629676949122e74f5047c7657ba4c40da1b4f7ba660b60986be8ca499d058ebc6433400444a418d7afdd06bd699418df8ce8c986e6f6262b028fcb593c4a8db16724dad1a0c125dca2fc98e04c88d100d898e3ba78d5ffb87a5cf1daf65738b76b9a52f756bc5a6cfc38d1ae2a121839477da77ff4953170065c8c87023373f0c0a60a0ce44f6ddfd87bdf790e3e2b6441be96acc816620ed60162161228732a79a6d59f1ebeb2a98e848bb5b65a77c6b527ba43820669e1914adb50ef03f0ae1dd1533ee163d0cc91958859cb3dad2a0322a54b9e17a11129f84657ad01f5faaf9fc7db349ec98839112d5454ca16582f8fd31165a0377058f95f0d9e09258646bf8b2af928071a3b904efda5fd2511c31fcb893adf3d24785be778c342d53caf8ed67fefc29272a25661f8c382574efa2d99dd3704e8de3a362facd07d06e303124a8e46c4130ea3f2d3e5a70b829aff2f903ae12c7329f63ae939d0f49ed60c53fa7e0cf9bf602938ea44657fcc9c5a82701cb3fbccf6be83a04442902aed3dbb340d6591c31954c026eea37738983c7704bbf11eda2b65abe6811dccf53b56d6b09a087d03dd0f076d302a5893b51b55670e0a3132846a6e6b29b4193e5b170f1ca6e5cf61dd149bb55e41d85ce5fb78d02e21abe8591e5895f339955a57318daea363d35a6bfd3045abaead7461d36b8cab5c2fdb35515003c9eeb416b3b1ade8b77a4d8ce8ddacf69250767fb56b817f1b79eb17e212b7b07c1d48afc594f8e12016fcc33a037e59c13ad1a2686fd403b73052e0049e797ea2ef59714dc399ca1c5b4256e39d42e74e8750e7bfdf6f3d48678f2faa54cfd2e45cc09b38e0136100228f3ca30afa27241599c63f5c25cf0757c6e58e41d3d35e5f7c151d26b1ae086a48604179e805f21f449da85049748b4e28ae87d0e39c76155660c4a948493867c5053ffb58bb0e1c1d2011f95f0b7571ea3cad2e8dab0852d7c8b04034eea4bb38dddf79e0862732ab70f42d91b0386ebfdfaf0b2a99ec7e74e2b4eb0464bc6296bb6eda92721785a2b2ed24cceeb8c9124719c782a0d8495d5d4b04058b6126750766dd747fc824a1e05ba99aa8caff4f73ba3936e9d622cc346725e552fd11d670e820b55c2af3eb8086de5cc5fee609a0026dd789e9b31de78e2244d7a508c5815967ce9d82bd26b58f023c8e21d7e1879dcba579073509aae50ab2098f833b8c7429fb17617aa1ab80c3506a17313a465884d1141e5e201c1eb862753e1ed1275fb072cd0855d9635c738d738c04c85af86202a931cce90f25b1fd7a8d1169937ce3213d01b8b30e8a47c0587ef2c0d7b7f8c084cbdc4a1cde35474d0d849e3f20cb8bd9e640c046edb92567bd88eb73259fcf7e9f18b147e2e6e30723e72a1a08a1c14b9ac856555faaeb752f62b30328818d3784e0e2815afe7782d26e449d58c68db40585a8fa658a21d30d3fabe6be7f5ac6319646666f52b512bdd8be6f9eac542c02b7f38243a4b3cfa7f370e9073e597b2951b258e6ddf77555d5cea34123718954e9ddb83c864b3acd30a8320fdcffeb155a122dc9cd1cf5f57b05b24b4485ed0625b588c22c45a4caf517238787543bdcd15ea636a81e44337c8384d3760990876054aa0d16e37cc129c4de971c8bd3b1dead73ab395dfc0d4ec952ae24f10b3fd390a59c5b3c61796fa68f7b97956720ea76edb56909d9367bfb4962688f1b0702fcc23becabea281a96c76ae0eabc057838f34bbb512f2c640df3ca5e87ac1f1d63208e6ba137c5cc90aef92b9baab1dd8eca14b2e2c7a108bd3cb9646cf4a4623cc5b79d905d4c2dfde9505762c6264f7a5b2de2ad9e9cd3622fdc3ee67cfda90dbbf4745b633b2f74a7f3a10209a78d4c7eaf35fcaa92aa4dedabb7b0350f04eed2fe9a7882bd4a27af4180d536bed834999c77b7879c2cb6d12fad8c410a79152527fdaf2a2b512e0d047e1b1e5168af5f22ecb3ebe95b4c90f86b2a7a2c9138ea355b199d436cf2f62964061a042a51f0aacccda0ef7b33f14fc31ca9ce1e1a3941207e797315dfb2e2f2bf5dae6d052bd0b08ba664769f67997b74760b2f0baccfef3019c8582a7a6b813cdf0aaf7a12d31e51ff0ef443caef70a6557c66168c7d63e83fa4d5f6cf5aa7459b096b3526ea97eae28865412e2ef4000f4f0a89cb8f5d6b1ab792418df4ac3d24f031959a2423022664371901d58e0cbeb2a810dca3b3b7283ed8c78949f97c7bd72c8f088a853c509a40f049544f85a70059d737bc2080807c8fb416ca42997734ec29267c1e5794e1b1fe477dbd4b09aa10916073d137ea46755c0649127073e4d185b8f2060ccf9f2d28f7a31810f8f624f6526e6eaa78c3cb96ed541c283740cce5c1d7652fd13ff342d750363b93e98324d385a11bafafd366d8ab6487b6a82c9e0a1f958c5e175ca3105156c0d3f8f5723552f6c0d07ac24be438670330e48429a59e5c045a81950cf6a165be718159d7135f0560b14763f5eac29e88a62bb832486031f7fa569a42bb54b51c892a0db27fa71f08483d525020a79b2955c2522c33be4d24dff4e682d9171acf7cef0e27dc3fbe018abd304e38beeda73920f2a19aaeb3a3eb206086642f405aa41d182db2431b300aeafc874d1e9460350125a32e021389a15240c01f5138c834ffd8ad7ffb01aab85e5d41ee8b7f9ae77baf61fa4414e43176ca08a9ebfe8e4e9fc2e986442a2ace9c26e4ec1c7a7a2ff2334b9014ae7d41b6fb5045d4706401c32ea59bee0a8a361855f839bc679eb793cc8a88ef00e8e152ca423996b7c4113f478bc7d73337d66780359d5e0ebf47dcbe7673ba5932c0ad6a4e3c3fb45303f59ef8d58d6dc0e9d9b4f456205a5479adb4cc2e31fa0ac1068ad611c6d5d0f04efe2ec0f405724ff2cfc2e630768bc3a5f350c4e7759ad650721e38b790b9433f19b6fe569b71b1fa903a40159e9e89170afb936dae488239a2cb433d32947675e4b56c851553010d48bab157c43ff985c24b4a40ed5de6d0c2c25f84d65d5b55b604a41053e408115164a1a8a0332673124724f8c8bcd904c9ecbc4095a0c51533c6c8878bab241465d115b232b7a218020bae03cd8946c393b121cb23751dfe350876ba4fe7acc316172a20784fc34b3e2234e35f76b01ab9a620a59daba3ff1469181b0730fb77ba656f4b15e935c8708c99cad8fe7f55f6dfa445d62bd81312b6b9ca34479a8f06caf998a8bd0f21e0092cead057eeaf007ea23c57e8cf5c596a9db9d7f64194683181c46467aa647fcfa2786c485edec9c67455f198dd92fdad8c1f7893512bfda7ec74ee1513690114b8f7cf88df343b233ad8f162c0f7e3b30cbb1a176c08cc1b766572f70b6488d5ec0de1679bacee81b12d59cd662e96b4847af99ce7aeba306a0c17fcdcef54e6cb430945ba9f19dea0a23e57b05954c6186d57d778ec7148b770f8c9edace82aaf9acd623e38283f32c44b8ced85491592ba2758621bbfc6a48f560a4d94966bcfbd27fac7bc7d5f9fab6893ae00c807fc628fb4b14e656ab24a041cbd8972d69b901e11f02884d22a7ad9997ed792901269bcbf33b80641629237fd5d14b5e19ea35ae7d7322771beb4b55ccfcdce9276441d648aacbba80c468f11858dcfe162e8b88e2c1ae503166c4093c5ef0aee2c3bd0f9bd3a5c1de3a8ffd270057a2b7db54c4dfea13ba21d9f7d232750d0938024525e2db923e4eda49e421dd4e84296546715f66bea9d8fd2816a3bb3e0a374b3f146bf4877be88685224737e01e8042b899afbaf270e10033f99c1cbbfe51b431a744170fd6d433cee75c9b793bb688ee42baeaef323e6b24b513c4194ed91767fa3adcbbc48c597c56bf6017db4ba348c309439a385659883432356768f948509c81e142dac317f008b923961914a3ae3c47d4eff56829bc8e82b55de8a2d8c0dc7696d0e880d4ece0491830bfd97e715e4e3ce1aafd94b80e74fa5ca59e3006641f95c1ce6880e386835a3acd9edb456005f4cda482e6f5a85c187ee11a3067d15262ab344a3744c51ec50c2dbbd503dd15652fcb99f90aa9e93a2de97d2d1d4536bd5496af27709fac608da4f2eedd25d163a7fe918c1104f493930792490eeb4d24d5d7e7ae222bd7271fe3a173b389d8ad98f2c005c32f77bdbfcb7d5610b0dc3c022db525dcc3b69706164bfda855d688f2886f11f04e19d8e0e2d230ef1e3bc35e8e36c2fc95182b06844dbf8cba0930af6c2fe232373a8777755e56aed684db1665ee9c480d529ed2caa9caa4fea1e400acab9e39dd5882955b3aa2364aab234eb368f4933d59a16d28b2b9e65e12316faed9da40cbfbd7ca9bd604423c85ce0eb536903446a61fa622de5fc05c19844541e8ab79c57ee21d20f6d12202f1b2946e506ae8318b3d2197e22f763e046a5c84dd0b142badb44c7bf05ef2ed25c9723166ff24eff78b679972e892d9f1701ebc23f50cec78bdc14bfa5629d489af7e91764c63608a80618d45156bc1592db4b24c0ed4db845c27191db332a250094e80dc9a12dd4ba4ff53433e94645b51a91b7fc50e83a8021943504573c2f577a5d7d3ffc9278116a4af84a4c3bbd70a64620be9314ab7f8c15fc1ff4fccb9ef99055bb803b2404707f8b841fdc3ec2f4ffc24f8ca3a448d05180e6ea56529626af519b023a34a7ca3b2e412a9106f49618f76515d5a0130417d93a00b9b78ad917f946e1e82d27f16418d14892544d51037820acd098eda5f482c889cc9b60d2cb92f46b820e02eecd1e708c340b2ee465fa8d2d03fd5dfc089e21f21000ee7eff3b1ed97160f82ca03269a8b923c96385ac480139ef3fb0af56b4ef9a51a159dc9b8cf31860ef77a45b7fcac240b6d30b1fa983a65e22858500151a86a9097ab200e1b81c60630487147b20fcd4c2aa3d2c502548154061f4f46c9f08bcd5fe81f2f4fddc03b16bec722df684c0eb704aa1abb6e1714092a51198710eee78d137fee7d28d59909b15e55b5ee0532db21c84798e3351a2cfa7127dd2a9af9786906546820e7509592eb1a944b801668383092c6cddc578f61465946d635a2c7b163e51fb977bec7d4260c0d31a253f862d04baed576aa4875f36e796588756a0ceff0c27f83f6d098190a2cf7197cc07e3436787dd30dce57bc7ff73442f40978aa0b4e0d34a5bcf93ed5b8326832711e025f6c333374911c38edfd2ad5ec5414a82b0f7a8c01c03e08646a2f38f4249e25a6657c19888f54b84f402de2cb7f06561b94b59fb8c8f3c386264231565f1346b9f0c8e7d35826b1fca4e42f4c1acc94a351e4458dc517a987600811bd80cb23a7e61fa2b486bf65c1852cfbad53a4ed8cc91542733d6be1f26e8a1a88dfb61611f15bde129c692b91adf9d3920e0a786594241dd82027afa3f48924760435c27b3f2aa3c34bdd517e37ab38a7fcadb32aafe03ce9ee77f2a6ed60a0531edbf0c6aa4858f6ed72759f78ba493d19a8f8fd92c19481e3b79150403a171aa1ab924bd1a4bc565a7fbd46b8d205586f31ca9e52bfdcc53484320d4cd60e3c096c1abb89f06cfba80f80322eb0eb4e14430b771c2f2d1a177f9a8ea83ad49e31fa317b48b28f55e4527533381b09b6f11fb20d47b8484496a164709f1f693d614999d28d9f4e2cc92e5f6e7d4b32e37671a230de06019692324ee497773923b0e9a3b73d17c91a48d3c23198e4f8c5fcd01d2c7f7a13fd34f6780325f03017b78d15eaf2004c7927dec36d2b676cb6d56d739478159303a67d79bb056e7c88933887a0469fc25d350811f2bdc4a5dea2a65396076f89b2efde3d8f738a041ee76d1e9b581b7202a7196b2410c853dfd46db1c6d2aba64efc159d0895d910a54655b5c6ba7240f96b7e008bc8dbc747fb7526d7b1947b11994223d1eea9376e9d32636e942a060b14b196a8aa1e13b916efc142a8de2c2c1b005400de72181bb612c34cadf5ac2be68a9a89be3ffb5e84d1e18c6db1bb37fd94aa3770437360d0a8301fca301180a4f36eeb7c84955b902db6cf15f36f1cdd6cc8aee5cdeae6c853b2c73c1383695a8ae7142fece4d9d07370d43c3f551c4e7a19365059180b24451c648c5f7760ecfce051c39d5fb95707fafae83d701e8885403959625523519842bcf394561b3bff40b4bf1dae4ffe12bc5d5d00c518ea16a2278c45bd642920f2fbae699f94011a2d24fb4bcbf008698bb742c2c834f1bd01f7eadfd8b1905ac8afaedf20b8aa49d6cc99b468efd01d5e43efa3919f16c1f74b4a1421fe4925046665bd4f9d50a5efbff17d6e7091241ad2b434dfcd9c804d26c9978f9e667625eb633dd6632831fdddb6daa9ef98f0b031320e15f3b5408099d4ed1e35cb618b4c0a3adce89c6cd010564f59c5a26cccde54ebc92f133993b83df4a5c144df25584508fd7d47e92abd72516072901f6d5da7b76dca639523cd27f76616ea88348fcba546cacfc6ca7c189fe05232a470402d785856c2caeec54f7e8adbb2fea22a788d7446e632b949c6d48884c2008534d012defd215ebd312238ce216972bb10623f59b03da5c5cabbfac3d11c8ee69c54f446c46ebcac9b0ec8c94e9a5c03b933e2b9a3368ff7d6a40c3ecdaf22db0dfda3dbacb9c1a1b83e3df2fa7016bcd009df4af49bf160e8db4097f38d3666475f2b042cd5cc88cba32993fc7f6357b17dd76e91149c8e6593ffe40cc5cdd4622b651a0e6727915ef53ebabcd584ac6adeca05a53e48241d65224053850c30603d459b0b89dfbdeddef50ea1500792a243396b590724668eb7ce3087dd6758bff417a209fea8604d9c110d3fc47c59579e6623bc08a2ea01cfc55a7f28eb2f8fd01669c61f501aeaf459a9fbd42ea8d9080ceaac9c268f5e89281da23b6699fdc89c62b7bb9ada70917a3038ae3acb1501a65322be84c71283e0ffbaed11bff31c28a20817a0c2767ab560b8768322967bf8a5a584a12de223cefe5272d4cf4bb628785619141ad6c5b9ff033830af8f5d0231050a821d45009a08427f3842b28ba9ba8c83305a794d9d17dd3213972ed86b51026ecc67d27a42bca4639fa79fbc99a29b27bf11cbfae06ba8e7fd364cc19cc7e928d054cf7a25ab8eb342ceb8b068185962013833d5ecc2ad525586f6e42bb778447824b2b6dbb1c14efcd5c6ce670f6cd0ef7c3f2abdd026278c272d4b3ce944ebf7fade594185d82dc3c33fe18ad5307df6ddeaf44843e8b4a8abb966c3b97e34306145ba876f356b62c9e232cbcfd1612f7ae1c0a749a651b0c6e009b43b4aed25d33ae52e1cdf8d644fb580914450f8b774067066b33206ba35239f27b24ba1c869cdd129c6139f6118ff4b068635cd83d2732021a14e7288367a7341c32ee7b3c5fbf524d5be8e7360622278d9bd6f0f9be129b06da22c698e29666e2ceca72ce34aa522007cabad80a345283e00b1f643704b23e4f8071d34795b2bc2118af05f078346d81b09f198f23bdf4b33c0c04826e0060f2a56c4433637bb73c091fa7621df7d61ea0d332cebe32d89b31bfac142b5db727d43c89655214273292a6cf89ce7008a47034212a328b084597228fb34989fa6544e7ee3190df6a28adf17f05d5ea05b1bc74964edbbe4962cb7037b1a8663da322c6f86729e8f513f22baa1eece4c8b1433a72345a0995ba02c302acef951dd6426c45cccfff79df7aaf5abbe1f4ba54f85d98bef6a493756f0a0077b771bf9cb76df5c77a9a67f5e4b0081611687873aed53ba8f3f067e25aaec0392c01e48a54c6d69c48ce00cdcea556b94449508fdebbfebe38ecc223c785b6136982c2a288b2705abea2b7fa2c143090cfd3984e2b82196de1a3b4b50a326f20c198f1c12786024eba310c50c346c11f22a6980ae9c336509b5651712622d8e23819f76669192a1f969623d76ab7e1636ba6c07642984ae83dcd122567b270c775e03c23dea66dc307e99ae07d566e9a666d1af96d868e702fec5d27d7548682eccc073349be7ac81dc3b170a87978dabdf1bfe6232700dd91938593c263e06d0d9fa3e755831937576984de1a9a38da72046876dbae2dfe48ebee5ef2351ecd59186afd351574ebe9cd0effe92ae3bc6a0104892609bc5415a3a04074f4a2c3d5d5c0ee65c4f08469822f7cf081107dcf26892c3af68f8af67c473f0c6b7e71d47365ab96acf5f4cf91abe6910264f8463b4832458bcba07e7fa1fe52cd678f5697ec261464d1245162f6b814d5aba40d18aef08f9022f9c936e158eb99d280698bc69b62401a2b3ca75975d56525b3037d8849edc9e4eee383af8d5d34abadb84299c2310bcd4940be55f7eae072126481960211eca78d7db9d5e6f4dcad39fd0c275eff91dab4dda438656b262599feb4850956fdca68670192761573868f4bcb7c5c7fe058ea16beac01455b66319e0529b2b82ed3afdbbadbb6f565f8b4cf6d69f9f0679b81d72f69b89cf3388ebfd446f0af93e4cade768cdc515131aa4211e00aa2d5b467ee4a6b842ec274068e472f47789903a0aaa6f5cae6d90631ebc1377abe346e28219f889b9896ee3b0cbe3bb91ef5fce6fe081c2e77fed4d6e3912915ff845a701ce44e7c88584486419368799dae8356e66662a8c83cad1b554e9ef42c1fa11a5280e3f80f82b7863a41a917c249c560a7039a2f9b6bd08c9359c2435f80542978f48e100afa038df651a3ddaa79dbc3e678961e26b6ef94b71630dbb218a2774f8704093a1423ae78d663da3b44898d0ca6aeec33ceab7591d7721c236e99bf045eae935243410cfb11bac12bad2aad734b849499f683a8632c589d44787144772976170e0537451e555a4bd9ebcff98067f4cdd5e658976b842ed5c1b72f580806d3383633630c0b0d4ee24be8aeb13a74fba61922973fef256b15b8b6d5816435a8b0c96df867f833397f90530a4479089373a5c8509a27f2043ec0b0be7e90e8fc90c5e5c3b8765228e9751779393eb63a79745fc463fdbfef5b9b8d902bd95a4e2451e2528b36dc4ab17d052538016838740c49cb520f75680475d1ef61065a3fc77482f2b993c6020e07a6f05d09649cf7f2db5199b02e29a0b675c8415d6cb541da4c69f195d148d272c6b66d17e48c7d3ac4d0ab3142112167b6aafd74a08ec65f75c8cfd4e1524b127366ea056470b314d1cbe778fa7f5bbf415a2cb29c20fe3c9826e102b46523bb52908847fd07a749161a0b1df9ac16c76ed44b53ec124ccc05ce2d08a6192d8842c30970cab43d45bb63a0d9cbe0ca68e53db630e2e0888759ec7b223f592333913bf390cb50024f4f04426b34ee7ad7d655ac5102f6d4d9a8d96ba43103125dbd2e3b166ad76f112312fa751b418d8b3e1d5f8c6e15acaefb8f2bdf9f8bb267cda5d83ae6a4d6a1a63ef15a5ed43cd16f593419702a94b77280b5c12f45d50ad5807970c7c0597e2b966bb6fe54ab85c67257c14df6fb35948e49e5c5bd85fd790f4236342cdbdb0e1334fb9f0ec4a8a7dc5079ea0f948039af0b3cb24efab30b8b5e133d4b080a125bfdd1227bebd03bbaef8cb48491f9acb6c57afd6edf56db1c6ce0249de51b574258558b783b82406cc09e198742a6848d55d95256f6341c05b041a8e7fd1daacac823cadabc7c2b1694d82b8743cc3149a9010b3bce5ae83053a226b451776171cd79dafcd45c9c86adcc1df67000351970ae1e6552aa5b60bb3e805a4e42d480a2946651736cc683b93fb31b500e96bb2905fba42bbb7d854ecc2107fb05e5fb256ce40bbe742bb84ad3a8604956462a573d9dd2855010eaaca42f6da04de2d137db71ae8b8f33764eaaaff238a85e4931608177f954938fe281066b0c56da6d44b17660434e7bb253c1d69ede4e12a6a63c5ed81ae13e759bea91e5661a646ce8cb0fed484ac532c412b53bf925684ea90b54ca0f9ede369b36de49bd3a0bb64be1954e6aad2b9ede6c41b0bc5db078668f0bf4264b3425c1dee7a1e341522b827b9471d33a7b52ab95a4f5be5a41ddebf2ee8d5ece9db1239adb08e8cd24c94df7b3a04867d51447435fa90bfd1127b6a281b3a94c28675875a7e8a053d96668dfbecf98d0bb46d512ac5939eb1e139e9c4cfa095ae7a1f86e11c80b57568c06c32fab9550e04d7d4799360adc33715a8eb25ee343272022237632409b681383e4987e244ee8a757cef1b783fca889e183408d103ca89d7c20bd808f7835138ba2dea794bfb055550442186b91e5545cacabe2f4b89d21154b8a920525602b41318b6aa86f18db72b9370a6a9037483d30f4780be3c0e377e0f6c62e24b945651af6efd92d6b1b4b1b8da51ad1b92275da0f4a1b50ac60c9313605f4ed077c0e2454afa470ed95c9bc52ebd6723d2b998b4b3edfc7bee02bf370728763f5d948b40c6009b1b7f4a57f6ece95922610cb64b226299b84af21a4f41b408b1cf14c37346a2b52eb50aa35614689a8f8dd9024a239639b17dea38739cabcd38d9c64d39ae5c606d7805848b62f4f6cabbfd20a30eb9a583fb23aab2b6e8bbb25ed786ff3965fa1c5ca80600c29af559e951e1f899ada1bbf18bfd29c61ab2e6a7c075f2622275ee06123f1250f8a43a21cc4e6fe88fb446d52edb5c937ef4d216f30513fcf3f7fc8971378749c872528cfabf8c593fd7701e26dc1db45f1053f347d6236d7c1152a80372b85e86ebf363dc6879e20d491ea838e2c9351468663c9a6c81fd04902d5187ab0732e346c216af5a114337f2201d421a9dc111cfe926461c8f90c9b15da0e9dcf1a73184cf752c2678e6f73e06b00b45b57d06b7ce5d4cdd1527e72c7cb5c9a2a6678f681b09930177e790dc44ce9c6e7c6a8cd1f6f94017c4ddf9846f44f2f86ce83711d970fe55391685c41d5a7dd09a04fc60dac9b57dde04a5a37cf97e2317637ffcc235fdcd6825a6fbc1894d3fcfd9a0fd361a427a12ae0f6a31767c3ffe623a657f41e7134e91403d2ad6a4bd0f24a3a192791f3b38b86edd3125d5190122206283ee942b85ebf4d072bcec6f8fb32497c281bc33a0bb50d70dda2e29181b75e1ef3b284442dfcdb07878a77781ca67cdaf9adfc84f8447d401c69eec485dd0cdde2ccfa47800ff3e30fe571703c1bcd5b375ee8dfcf0a96aee226ddb6a28b0384194682fe067d5cede8d914391c3812c52a855b94b734aa7807bdb9db4008c2d5475695ade88b738d9ac74acf45b65b1f6daacb2cf19d00a0d988bafc76361f25a1c81f11dbd5fcbc0f85db23c5519371bbf31df2b7fca05dd4a5eeaf51eb8b9125e1c4cbf0918474ea129d33f14209ae99eb545e84f1189eb1b5eb09f1df67c1f342623df035ac688271526fa6ff231a03b7b3fb66d8c0428dc1a85b3bf1e836cc69bed95106f8b62767f566700921109a444339e993a77a0f45ba9444f57aa114149a62079eac842f16b3e402327eec45e554a512cdc1234a593d63bfcfaa8d5e9065f5ddf06555c36adcb221d7d679ba012d71c5880e932e6a8abacfaa4a6763baf7603dce70a64b8dbc111a82376758a6f1fe607c062491cc12203307b84ff280d162bfb2ea052cc534d3854acef8bb2d9a6c990c94826c2ccc65a58a826bbcf1132ae8bbdb32805374689ec4744ee3f4e6a801239a29dfbb8f6f85c0a742ee2552f187aac16630d0ec6b6585a072299b36c2a1ba1b0ff7eb01777b4f41c23c65dc4a5e3359b7898f902880707406dfa0c178c2fc3bdb050232fee8922faeee3e316059555402ad0ffbf916c96d7ce423277daa6d898ca0de71d841e03e7cdaae79de378fffb94416de3cc3a736f17b3d1bb58b52241fcf825943c9bac48b35289a5f54be47885a8a814ace6b9c68c7988ba3425f5a1bd400992f8dccf247394d384912161557d762b44f9bdcb953340f75ed34424648d02820c2b6a7f9b205e556b59b705ebbdbfb86ce723b4aad6406b917a691599eb8b94b5b692ba0abae5aa1e6d173d3cab36bb112dcaca8950db97b1d24f4732f17386a8cc153f7efb3b471c8a66fa310dabebe97794f104f7960c60dc3be75e32722d2d45e4f77ceedc9dc56a4ad8411f225c544c19ce42b003337558425db59d7ba609f6d27e622a0e62ef551a3e7c856f3e6a7241e435000fada3974c9d4e4bfb7df5d5ed99ed152949838e6792534573af5a77024f3ab6d4f3c2807990da13fbeb4a2e7c5389c0827fe51fe5516b4d9fbfe0ea6320e05489a0605f188fa3d9ff0bcd5db04d43ca72933122f75cbf13af39c646ecf10ed0c2eab8d0e54d940fb5821d53f5df632191ca70eba438900c6450a04b637f6351c42847ce23c21e259f73ab39f3f3a2ef9253bb4240ab91aae0b6a0db337a3a5df3f0338311222f3033a62554369365ccb1ac47ed9b2e5dcd6f9961055778df35fe01fb745e00896e88ca15d80801da248f909f628812d4de450ed0482402804f0e11196695041a0ec9f576652a63079ef4e4a2bb6e65ddbdfdb2f0d89d8f322964d1d2460701e87a8e16a3d18b6cd3be30c95f48dd6b7f1bf6d833be4c76c4f42579820cf85f341dc7bd061aee4c6cdb76e2a8a01cfd422839529bcc37bc259f54b2bf95109035846f362a3ace1280d9b9cb263aadcfbfefccc65d88d10b814c29f758817e0f4f886a55f8ef10f0539a623bc802e75432d2b81d0dff717cb443886f4facfda540b38a8b2729296d10a844c8004df83bd056e0b91a8ab598e93feaddd5f94f19b3a35a693dd13c3fc5d309479c63357df614423a8f4c4bfd4a31064dd170a341f16e3477b92a76db90068b7069b14873540bf05d9af3a65afb6f1fe3dc81d985633355b873431290835a00fad694c51a8dc4be7fd65437069a22672b5221562969d25c3398c8cf2be94543a27f2854269ec118599c65649d4374132cff2f16fafdc626c7380ea46a0f98d719766f331c2692021415f661e4e57672591331e96a146e966aaa9e2c97954938d19d1940a3dde27ffcb5745e97acea50634e0ccdbacba672f34248fa5ca92f339e655af5bff5c8c897c8db9cc90f900cae0cc6c3eb8afb1c78f35877d0e6c8e9378afbb757d466426bc5e55d94932c6a073521757f8cfb353bd7f1d88b40d480e499030b52722a56056d31676b787547a684350aba18c8398cc2a179c20e01fa5c2eee01e5e45a3ab3a1eef2e6bb2318280b771757bffa00bc52c81f26e0ee60d4cbb836924bc68c017e4dd589f3facbeead722ca8d0571539b71d9d0e8cd647dd7a9cfba0925877681f9aab4c3a1d62295cdce01abfbe5e4dd849358e5e76bf07dff033498b9c77eb4eabd5103fdadaf89d2f01cd8ceb27c7a31680ad524eef781cbd5597cd2c6f1e915ecf631f7037bf23ed0f571c3f5812709f666eb06030abae4bdd505c1f17ecb3ea3bc65d5b9e91957ddbe817fe3c1f0ba014a19a3a68d7fdf7a7b3810748c98aa2f8dc4f477f6d697de1fb42c67a50151414a3277ccbaa8a81f8458fff2e43c06190a060ebf4408076639fc5c84c02ef2dad12558c7b898409debaaa5d17f65392ef7d631acb4e7e65df3d316b11ff14967c1127f2a464f274885b08d4a177f173154cc0a7a22fecaa70a028cf4cc0740b414e140b497e42dab4fac3c2641c1cf125b8af7c3d68d97a7fabe46a43bf2eaf0fb762450e292bc6bbc3457c62e1d118527ded721ecde0589fc4d1399d0e6e8a63d75013ebfc4b487fe2694df20134dbae1505da6ee4325ebd4af789238fec0d0b0b9eec6d7c44e7366242374ba55ca223aebfb2fe0c04a2b89fd609e993055dff0f22ac05c1ebe5297a023678a00a8ca04e4ccbc9e4f7329ebdde7503b5dff167196f5ed504478812dee72eadf73d9a3525d01292039960e063b22efd2428f361440e772c19873cce7d07ca302b1735b64daa89cfed2f29db9ef872464fa5ab74ffac259bd31f48b61502894757dcf4ff4b20478b73a84747b3f91e5119f5c1c0d3bb13ed9fbd98001ecb2b0d6578ccc4edcc3a290dfae5ce138152341dcf31581a7ca9b2e29c40947b5e6abb66e5c896f4646c47ae96cbba6fb83aea27f9dfa48b86ff0047bd6a22710293d4985da17ebbec4546e7ea7d2dfe174f4c63cd6d3a191603147a3f258764fb665e0a8fef9467e0fbbd1c8761fa5c4a5b7fd7dd0e3a4617bac41ac1df205127eb6cdd60729c339fb7e173df92bf02c8d813721ea0010bf4dcdcc858a48b437dede71eb2e320c102b34273087a7dd82b1e21b5ccedd179aaeb0ad10ca935697f560d1cf3be8244abbcd7e16a0f6a6fa9b7c29695703564d666877c196ee2ecf275192f89decdab5e85db1369ed995c00ad439a37b74068cf9c5e8d613d197e8695c5362849995704b392e87e2b83f6b9a0b5080ec03bb7b17d848da4a3416c2f500c263ff7c8e5da98d2f8e9b8b1a808f06d1246de5602f27278c3c490b5a04eb9d9e19faf5939ea22024f45eb77a4a445f3ee18020310a5ebf33c17cd0deeb184af91089994d781d96058e3ff5a0f9f05d8b9336df3fe93dfbabec4b2b11ee05f512da079d8f2fc1373f247a6a4be7bd9317a9d25473b6769a13400f717a5498c1c6fcacb41bb9be86317539d9db321e73d5c02f050e66f69856f99b4e8ac43f6e2afc3ea09f8efc7fe9e9433d689c4477b69542414c17d5bd42d1c358a4fd2298938d0dc7b19907279bb12bd6a4f742b08a1acea4e7302d0a72215827217022ca3eca2626f3cdf90d3aff9d331f160700ab40222b23bcc502bb08d54066fe6c864006ae14bc23c6acab3f578dbf0485cdd1a40589327b7e4cc0416a4856d32bdc774838096c31b56f17542285f1010145fd436eb0ae745711293dc6e370bfa14ce845e8c65ebab62a57a4507cd09bac45f205279a0bf71dffe8672e1e14d24b17953de1b911875ac44741a7e7f29589f27034f52c3e47f0266fe9f6683e69cc31416ca5ef270b799e593bcaa8c8fdda32205ca1715ff60b86170a1cc6e445226f37631926b28942f3dba09476662a2c091923034f2f89923814272dc417f2fc91256b3f6960cc8dee9325d8647b5a8bfd184ba4a7a7399b154004d5d17c1b7914b792ebd2c5b8e31d636c0a7027c7a4c1b281b890240ab2d0b823b438e369fafc71b2c69f9faf1a96c826d6f69ca062f7fb27f1040b9eba7332b669e14943876f550faea430fec5e9e0399ec5825dda835f0dd5ac6b99f2e53c40d698534162dc569de1681634e2f5b44f103bc4483c6f8cc748730491dbf2f74e02498f5f7b8963890e2ca3f21c0b38d3253e3769415e7ee325abccd08e96d2160c21885c528ddef553ff4b32d68cba2ef88055bdb2180fabfab94ac688b8de0e28b6a8e6a5a38001cb8c3adbf9fa26fbbe01a80b7c426647061a9bab3e8af741a1e35b18dab32f90104686f3aecaf6c1032864f567b209d5cce91c1bdeadfb7d888cac04f0acfb0602e4aff25a08fb2d7d7a646b1a15972be58abcf2cb7d6f3069084a3d4a95a046526326cb74e6be99cfef60e79489898a7e7396507304cce8fb49c044c2b40b2f6dec2e67460e0d390fedf25c3f527492ec2f20bc3bc80a74da25de8a659181676acacdca09977c434fb95a4f8f89bf0b03aecbe41cd7d931341553746bb2785fc94ea3253c330192b832aa9444c86797c63c2c67f33b6659cfd6f9326654f2fdfdf3042b7c0d680b7d29881fb852e1ae38d8788e5415cb6022e1c0d194041faae6782edfc47a367d60c9ec610ee74a9e9b75bd306fad34701c8abe4aea95a129081c33c411fd0ce7276768afc9fb68aa5fceb7ecc351f087350fdf4b94e606d540c2f8ecc14dca18c369296ad13d3d0295d163c1a5c54bae372373a57f2db0665bce7560fd103bec669a263a53eb146c98cbfaade2a1167d5e668ef26c8c3f2713f5ccde074983d5ee28da30bbcfce383f17d3244e37db457821c29492f8736c3c0ac961552fab97bcf3c69f703cc3a054c009949b7a8cb329ffe2c0352043805940c5a9ec2de707baa26400946709df3d5ad69be3bee1488bfbbe0f0ceedb9db0af4b0957eae43d64d10ef79bf138ac9ee7e85b85c506fe89aa2901ff681c43938d16ad1e0bc66cf9cb1d23dbf69ecc822c3eaa5fa58fba0f20850be1f360a238dfff00be2e5fffc247070f942753dcf9e50ef5856cba39e2fded37d389b4080dd3ac68d5899eac327f8b17b9375720e99ecbfda3f330b93fe3f343d18421bc073a4d8ff1630948f1db593a883221729ee26576672910a324e329ed0591c02a7e60b1b5be6a0c774c656b596fcee8fcdd4234adbd1d4701013dce23bf1744246a18d64eb717f81e509fe44ed0d6cd51d187af0f5ae91406bceb4a09a092b160d3c346df10c49a1328f7b950c1ccafc86b2fa2e5cd859541addcdd72bd879cf68cc83921bc9c5877b343fd53dcd031322896a8bae1dc76e46433ef0d3431d7dd6cced959507f765049b8198409229119602a2bd55edb522047da656e622abf6d3bbce4446856807df97b993ca504310000a08503b3f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
