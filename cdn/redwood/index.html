<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd9e36346c833ca6e2f981f60cff486a7bc1d0106fb437c12c2d8434586f5b71c541e8a0ce1e292b44c7c649699f30e22cdcec1735224c71787d31167e400bbbcb9e9199e5fee07a2c4003a1993dab92dc5bd11786ff875be57404f9b1c64a9e638a771d013de1c658f65ee3f324347b26d17c037da4a910edfb618f2bc03f83f1338d0e30eac74f8943efb9f0005b121a0f2299acc0e84e766b76a5643f24ac36d7276d481cd0df20fa135464d4e686eed69b35a12a62dc1945516b631b3fdd213bb4341329b5ec997ec12393666ac71a7ea716c70c5649ebfae98085fe642f7158782d08ade90c1d4f5a4057fa3d7bd6fed27dfe0ac40bd09624993640a4db3d95e3f4279c38bc76478a772327b483562a24a713f8ea78a19cad8081159a7501ee3a5ad85a5099415d6a5a2ca5b2c4ec5d905bec0b989dc4ad350e0a7ff8e96f4ad545bc8f02a86e97741c44ad9365e0ff069cc3b18ade0f8dd88fd4b61f38e2d4266265dfc6680783a659dd70fe1fc27c5471879d61ca4912cc5e0f71309008985e3f1477ee425d661ced788c237b8dbeda6fa1b7fe3034b6823355d55102970f1213419293e9a323357cc2eb11c1be4729791721e433111c65f194bab678d1fa1f6803722478ed2110fb41f4915002fbb515167ccb1d9a596e035e44006611fc29db3c78cb7e4b62b1aa31201e41d9709777f5b565fbf448f524181837988a75b2a6471dcdb1c9dd8f8bb40622582f9117486a9ec5d8b5ea083d03a53e5a6dc42fd085f1daa9f259618d666e16e80701dcadb2566349034856bc0692945220a5bed9615f6f0189dc3c7d151ce50de57d6efcd33165cc196d2671ae0d35668fa011013f2a386e04e40974b41da3d428537df637c93d9db2222950f2ab3c2a515162e8ce56473023a5ea5a40f4410cf1f04e73c9def2bedb812e54f538e4f8c943619e57f562c9c7eb58e72a8e89e66380a4663d3aa7c8c58233e15f2ae0e877daf5554a529ca01169349088c34abe7181557d45aa60c9919e2f4f073968c61f1d6bb8d3d8fd6e054782b7b4ed98e48ec1689b65b95f9433ce2c42932ee0ab200be92ceb61ed77495165f68ab757940886c69302abfce9bcdcd0ad764627dbab0519314e00d89b8f580a293bfac428895b8a5f6db37d364557534213d5e0f3397171b1f28cdad0a8fe6d8fe56f02e3c21662b665c67a021a3fec4cdc91f4d3aec86af08cce5bcce43eb3efd90014cddf54364ac24c8872825f81b88cee29a79600ae426feb602f65d6038cfbe90b38813ecb92d73b2dd27be78a5d95516faf8fa0642fa0006b3422d94188b7ee15344736578143d6f01a3aa8aa8d36596c4d55db6ad555c261314862f853235c999b846bb37b1570866aa5f26d5edf48afc048d6cfcde54d543e45c70f568d68755f965b4bab2d2f9727bb062fde1797435d3f45e28367496d7aefc179b2c3a44ee5286728f61638113166b0d3dff1a2e6828d18df788044c757537daa6e76e43f1ef7c4331f9113bdfd0d5c497a8502238f4147ef21a90f70c6bb2af610fcaf66f37c7dc6db643df948def10ec7c4ae6b157179ec8cc87e3c03caef3ef33f85c16fbfec6d66bbeed66da532def4a4bea9c1dcb6f8ec63334595cf36538be52c50c577c2a9745a6c8b98dabca5a45c171f000c429960e7211a3615b81cc1b4f5701ce1f633241e34b1dbe92efa356162bd74becfb17b82e188c4c7714b47ad58a3822f9cecd438272a9bbb57e0b48bc9d98e69b3fd755c31ed74ec287a8394e5d3ad03f84b243b077befa6dd8d0c8c77b0c7a831a9a63e48c333137dfe4f9082f7ec41688b67ee9f8f688b1d1fb0c5577440a65686cfff7689a7e09816863d4c7094b8388f977519e16e37371ca12214f96404c2614444f71b9f610a2375d4ff4fa73f48b23b15fd581ffffa316a8a108a0baaa3d2822c9f06434dd834a4219358a92ebc5e9021288ba8fbd85cadff262a8e2d76b8aafdeb6339a8f78e4c4a94f731c0165fb0b036570aee17902cd47c37ba657dfe3b18b11747220e39794adc147d6906a0bb4d7161076f27ec21169185482b00ea763167ac12d0590e26ea0d1527ccfb5ff05a42c5d61e700f4b9689c661b08dc8317d5e79ced51a4c3f96cde7c9be445c2a8b06c5ceb78dae06507a23560a2856704020f825d0071aec21fd409998dcedb0314bca8cfd4e13f73202d28891e777a18ddb21d3b1556bbbb5cd0da8a9e164c26778825d4aa2bda45c01506a89d69eb32f3099a0d62fc87e657498cea01e9c71df25fca326e75a7eb06e2ddcdb58b771d44110680bd04ba16f1ec2ddb6e1b1e80282eb95de9738bc941311d2fc960ca625ff8d7fccf7536319066536d726b1f1ea7625506edf626fb036d6786638aa94e8352cb84d7a2f3003f7da4bd1962b4095a375c5ef0a95c704fb0a772862a68b5b5f033a0b6840a38ba5a39eb93b968a92120197e7389bc342eeeafe9f4ae92e7a99a18ab5f817ccb14378c5b8b303b47388f5c2d15d6c5ec6c7cc34e5deaeceeee575e5a6779802293480e6fe7811c8285664872a2df72239c689c8856a1e6c06e35076b30701b3599ff899b9c1ab4ba26aaae52844f56976e74ce4be9a0e5fa604263ca06f7263c9dcb8ae2950e506b5ea979fdc3cb7b1c835079f881084ba7b6f27741236ba03a54e2fcfd6a152e3de198776abfe5a585ed5f96ee26bb284af5510d7d26d6004ff3a89185753f2c0500427b4575b439de6a4310d4d2360982565e19e46399ce4bd78da45760da7366085b7d331d4fc12071f6a62d2e1b4a12bbeb9a2f57e259fb2e5f403e41ad24d97c069caea72a5314ec14c22c6654d172fa26a3ee78e3837a5ae37b8db11c1ca5937fb12d37540247dee2a64d18a5f4b4fe7661d62b910bfa0ffec4af16cdf245ce078af57e98f73bd31f5c373bd9378bbf17ca2c7f9f1da1eb256396b8eb094a441a5b7a11781300b2fe18339ba10287788edc0dc22951cf00aaf747c1f55dbbc258877477a9eff77d83f7caa2d0e091ac28068d48765d2014bb6a20d6d0a73188b16b94aa1800fb1213848060c27f10249bc765652edb257cb00b8267f59ab707c8230c5732ad9b98adb922390bc7ae56f15e36fd5cf6fbbe60eb069cee62df71c789a6bb40777a1589fa16028126f4704b1e99daac505c86d3964b0de3557f19ab7f361d753c90b7189de500936473df383c100ada44d645f734515b416ccb80b3accbe09c0c1e31c1e0290c4b59be16c099bbd96c948db138a2014d653b7dd8106273ce47a2541760018d63ba6fa12a83d072a8bdea820439b7407c1498721c3a5f88f06d548111e39484e38387a0f3723568e76dafa550ed10988ded1190ae17aae262e4fbe73c5fa009b7a69c4df48c84e2760bfe9734418166d36bcf405481089f977d45f807e94d53bedddb162a3cc3abbf6a549574155f1eca5aba60f631f8ddf67b0ea3c5d284f9ac07d594019b6193c2fa63c372db9e0933fd23c917ef28c1be68b5287104a33a5e49bb955d64000286bfb0c3193a0c26f96b030878dd2aea752e85207895f8ad64fc6b480c1ad2382ed205cadd7728c0c809fdab5c40f2987d2918208d3b1e0837c37324c7328d1e0a004f7fd80f2844bd5b1cd10b4c37781145f5fe707a31055010821915556ce3b856c6d6f8436f3482626d2193f0d3a9fa31657a1d027ca98e58b837bb82f564915d905ce1ab0b37e5d3b1ee8314242252b49f4102934c5aa8aaac72f4065b84ee22b7472940a7d79545e4331a84f4eeb9eb5bcaf068a3077618cf04cb219ab12a935ad6032f63daf1328f49eb5ead3e99c06ca1da2aad864114afe36cea98e844bfc9c1d9ac3aa1bcfb69131cfbccb61135f92b81b5d14f25ca771f4d0a324e8a31538b59bba29cbcc4573fb397fe2210dfcc296433690b1c644132ac6169e86ac826dfd30aa63cbf7cb20431746925f2f69ef478f427f2923ea8fd3ae9971ece532659a02e8c2480b589230618ef35bf6b25bc1d5cdc10fb8d67de924962e44fe7ea37e70650e24889fd4d1ea51546097fa7b7a6bd01a3e8a869e52db73cbce053d18fc933a15f966f9cddeaf2f70b5a6c7900e00821377608307df46dc09a50ef94cf9d3be41507cb9942fe21a1e33316214dd8bb7460301c0b2bba3e707c89c892a035d8d1f18ea8826c7110758199d6f0c022528102d0b230aca3b7340ba6351f1a2f9348ead77ea94006f77cfd4e3e47bb20fed6026610b7f2115c6ea48ddc97eee1e7cea3424a3cf82fb7624030399f30c0995335c07603d2ad02d628956723b138c7bc8efb53cd5bb943e75483cef7336a8c4ee2462eb162497d65ec6ddd0d1976a001c408b679214365bc53f94863c9cd8dc22a7f4193b0e9b2231f030f33b57914b640356422a97d086cdfcba5da84a244ebf05cc1d172d14d86390f1705717221cbab8fe56b44b152f1d6e8c4dab2634158c555eaf1416056ae83b9b1fceb2a333c6ce6d45ad9cf0eeb74c339bf485d8fb6a35f1b99c1f7f634ec5617cc1df2f4c39d906cc4a4f080cf62dd21d08aeeff3b53d5595b479f72e6c2f249dc7c2dac032ce7641704db7b8e6a5c9e07b149b584a0a7398db8a4d2fb9998461b3059385d70e9dda1435d0362200e63bc11f37d37c427802f4c7758b575fae12c2b7809ff7b62313ba8e15e03a478ad462670c424a139f25494043b0ebffb826460a450e7012fcf6d6e76a9a39947f5739724ae1831b0c64cb8e44889e64ea00fc7a79be5fe67109983a2cc8b37c1af2f8f932d140f35ccc3e4b9ae57270335a029cde75f435874aec0e45064c6bd5c23caed229a7f6fbc6a7de97767f9be78b91d2d03b096e003723022f2c3c72c0e30721a81418e6cfbea755ccd70bebce855ea8cea01ff863c577af76e00a475c07742e28b316348acf3d06f7c43f7601c2c0e0da3d0e941c11ee64d6f189fcc501a314b922c0add33fe126e8fc602fa219e25faa7feb3ca6dc66072b03ece03530614e7942f1ee466a71a7928904c532902cbfcc636e5da9d97fb527d0cfbe59a0515795b6dc4530e126f37e02e37bd22d546ce73150b4854b0f61e5be9204d7613d7171b3bc32d3a9539c0d166cda7dccbef81bb33f6ffc63dc38f97c4e753750b681bea7b443b7f1b1a3877217766d042fd8ca5ab2a607b2c136072970c146104830086241a38389154d51685c9d5d7c5372b95f4f4bea66562dd7a986ebae7f29dd3bb7fb3f41607e19ad5cb7cc928708b9e17c2ebd27d91b17d9717abf956d47fc0fb22e4174ba962471c62b28eaefd90496b9ef8e9a5e82b0a579d044e31c4e005e02a37c279fa228341ee776b3c1e1324c573e6fbba7ed2826761afed51a2c7dd5610d118f08d49fe59f02581e0ad16ff070848907487174c38c8db24ba6d6293fdf4e2cbb7830ce293077fb512c35d2661b377f8f50abb3720728c9e19124c3616dbdabe7e762985a7cea329c03d2f3910df6785763ead169cf06307b96fea6e728327ce7f95b95d3be9bc3070a0402063b0512c1b5443fbdf94e072077913d447632cab8abaf66102f04cd518a0dc662ca0c2403d5ec6b5b13fde5bee28c26e454c6f789a3034049604935b3d453bff73dd9f706becfe86ed942fb3c8d07f39157d69549b475dc7d98e78e1d8b4ae39c0bc61203563da6edcc7bae5292fa286a4383c24474a65ed4d9c872b788e355627a22a42312a76234f3691d05590c5c9c26863fbc5866c2b523f937901e7dd73dd743aa579ea05492a1448a1ffa4775ffa34e2adf7927d9e162078afc13a7327b4b7fe1d45466db50aea655daa7b5820e8dae170ec65a901efdf394afedef7983c31dd81a5269c03eb0c338ef0dac2f81c429d6e119c54920a59fbc7c95e80517ddae01fc2a361c8c2c7745553874afa784ecb0339b958cd9fc9a30ba6893744f2b2dc1a742866bddcc18bc75e0fe79f943d1ec58b994797890f90552a86ad0b8d625d6d804eddaf9274eb183bb881de681db68dc1040956891910e6c78068625da5672bafa2110e976913d5d124c22d9848150b9169bd46a2ef063338bb50fc39a0e13c9cc76afb9a246f0dfb3048008779e77bf23e7af8a3826add1c4b56445a762fc48bb600a31a9dec6cf733de7c4c3bc6db8261e8a06fbf83b404c9058eec05fefc9770be549ec34073ec36cc8b753174e8623fbefc002a328453c7e39ce3214abb233c2e069a898fd42f21ef2c40b60d70da29aa14901e59f9ab441356509de99efdb27e95c4337114ba673813b1d9de7f621907fa093ef1a7960fd49fecbafe6ebe97ab88dceb5ae0fc9eae679e9ab86435241d915a6d83ca46cfbcc2d24e3766f281d1c106198464e28b66b8f704fd7adf38ea44fb322d9f7dffcebfb0ae65128c64dbd82d9165e18e93bf8a06bd55474d778dba3ca79f56a9dec83ed1074df56dae569d0a2056d0d3f108ca09bd22d6846723347cb9cee2d9afafc195b39196f9e1ad5b4266de7debd544eb93de55d5aa5cfa3393950ab240fbef3ab7182d24f65841bdc69816d894d1276db65ac2fd3be65816efaba0dcdae87f06fd9346508a96e6152612edee7f8955275eb978104e266ae31f36425504f9af3b62db950f48b5c4fe965c41e1f2f5bfa12269bf6f396e9a3cb6a0d2410b03612ee27525dfb687774170634884bca3c673ff19733d83226484c98d61c05d12362fc762befe755027ee92ff80977e921b12af2c7d3c14447bc7a7ee0434c1fd6e7c98fdcae3a1a6680fe7f018eda4fc75dd8b46496cd2bb8ca5854be23cffabc24d4ec5dc3d3d0bada3a1a399f7e1b4949bef6999b49d96b7aa629422e150cda5d0b37a155075c3a542c6d6f184f8a7bcbea54238328a4fccabf7ab418db2231254a5a899473bdb218fc802c85dd84a792ca061446fe1feae8051fcb0538d7ec71ce8d81b98f4d2e032338de98a5553cb1556ac5d8dbefe6b493352d86c304fac20d49392c677e05557ce752dfd06cd591cfde9333562c73d32fa4fc5ccdaad1074761a2e3cfb15916543adadc586daa4642318b0b4fba3ec528f8591284fc715bb3d76bebddaf0a1d61af8ad52a5f8d6e42e944748426c71ba71c8249ff6ff5a8b30f73316620193eb6d89e83e0bc68b66f5c8772ad83af51632c03416825305dc1aa05f6a70ebe014ff239786ed28bd7d3b66715969f825b6ca8e7332cb8eb0e6c770a96410e5879165a0b6befc400d4e2adfde570152526e04be5de0789dfa3bb122af298e2e5d298c248898370db79a457e1b860bbc3c07bdf66ce06526087258cc015a2be87e72759fce0b6f067a393a1565de0bbb8d35e6292f0fab562b71dcb0e199a692c7a78a58de071e63acf1e7e19a2bcd7c0e777178936e69df99363ee71dc4777179985a27f07bdcc6d4aefbe831ad401c48b80b6150a16ea04a3cdb25693c746f63ead1a99eddc1a6612d6888c39308ff9ce44ebd6f5db79f8d66d790eac33897194d7648987f3636f01d13cfafaf73aca84b379d99171218d27c112c2fa7c2f9bfedd94a5b39d013a95ea99484d1707ce219f3dc6e5402184f4e51fe55dea2ed4ade12d48f2591764b1b6e050e96fb47dbc4cb8159940955d02c9037bcbfd40a9a93adad01222ce60f4f13a1901cecd0ef7485a175e4dce23ec86f471499959ba07cacaa43e0384008425cbb4022f6680fb98ca748103b46f75d8a06bdb5fa0cd4074f3f8aa48586a5a9e408afeaa60f78eab8473e8132149611b2a2652d1ec9301cfe671b4b32bec46ba1d55dbebc8ce1fddddb30771ab71e3b3fcfd2c202783f76ebffd1eafbcdbf90c038eec783084d5166d1ba6c389f520128169d5226a4ff598b9a6c4593f29dd6223cde8958501c5c73c14557ae07f96adbca6e98c848f7693c37c1d8521745df20aea56ca3d50e1090d0f33878dd82afd66dbb9206b296ab57d9045c17c3148aaef73d6099e2ace07e36e54319cdfa44fa681b34f84d5d75a1901b944539c4ae8faa1d547057845493abe56b3762e19a80da56fec1ae69f8f452b097bdc145e2ebf6627252b72a2a2ba8f2adf6235a310fd5ce16a782ed8d86e5970101bdf5282cda711811e610bb8bd3c1b3ba0f847c477c41fd59f00be7200458c27199c7239bb800768c219c19d4fb4b323d56f4c13dcc314fa59c8914f8fd7c67ed1de0be7f900aaf4506cb71790c9c5eb4f3b9c5b200a3d43751f0c1caf81c6d993491456df24b41ec524bf6e971c2506ae3a491e74f6506fbefb7e34281a594314c39b5e411321bd6bcf6d19d8b4192d66757be2f67ee87204eafe14adb2ee7e4a4ccb62970f79747dc7a70e6206d2f1100d4f90c8c74aab5d14a1c476508775a3a2ce4301816f03acbe39268e6f23cba1db8af216c4cfeaeaa0382e0ddcff3a325e416841bb3502224213d110af1736c280aab7f1223ae6766a2a0881e58ebe27530ac0b6e105604a774c16cac70e146e7e921aabcd39ac6671548757f00fa382c3323a5a799bdacee5f631e0bb255d47dd24e5e9dba57d64354c123cdaa717282448ad7fc42115a0bacefb1211738699eeeedc62ca45b9cf639751f9ed83c48ccefed69ac4247b442fe07760ad769d1ed22b34cd1a2936ba09750a6fc1da7321227acebedb94164843306cbc2144d814e702f2c1acbd6d4d6e0ef103b1879cbb975429642c37823c3d43266bfc5c299d71cb6bc3a05fef96976317fcccd7a7d470e4e0a533aabb3ff85374be73e2e239d94ad28f4b81713f8935ab21dbec677f693e397f53ec95cc7469bcd9fe6f2b14b09955605b8cffb9ce56815fad1ed84b88697fd451e38a8811618448e03dcaddf1fd504fa938b95733f8ced3b35b6e5b7f3638eb22ca8b7607b235d52a496d6f797f63b118dac3ebb423687388d4d1ed12bb56460f24d0b566c2d49fd7aa879e616776710c794d357645c3b2e52ff92d667db40bfd9dc057113cac03e708958cf2dbac2ccbfd6e6e1255307b33d7b85a4198f38c8b64e3264a5b6f6aa1acda34b90a13b961ba9e1e22fd10b3e88e19e3e6a7700b5a83111d0f59bd382f54d9b2a1a774e710cc8a25f3c83d24c730221eb676d289597bea7e47f568cefc447128d31d66e2b251863ec014d28f9a92f9f094e97427b20f599e620011fb00d99b1d42422f3d5d1ed06a53bff266fa5304772fb22598bc1a26dc309b264e63aeeb7f27e548b4fae15e27ed6c23232e1a753faabf22ce0267f7a291a447e2fa81cd7c920d8caba837dc100d82be37c60eb51593be251c6cbb09d9a3daf1610f44e3b218bb53cb5773082b1840a86ba1bb37d5cb1393242047c755415c21bfc0cc3e89796df4e1fa7baefa787da8a037c87a66910143aa623685dd818682882286d5774063678e625cc43bb0cf64a17b6bb1bf9127898a31aad8e23eb5350c9ab4df23ea79e5aa4f596fe706505d3c46b243baf4a604fcb289b9bdf838e7977b17443de1a25bae8cef908d330ffc168d4a803cd0b3d54bfe58db6fd80b440a41d3baaf4fa16efebae3e7513d8df6375fade5285f6c61a893fd5c64d16e2eda283aa736005f107ede594fa73e902abb5b5fa4848a1f53d237ce94ab5b9e6698506bb4a20f5581d167dba1d9325cce186b7385b60a814df7608a255ce21c1f77214d0e552035aa0a63f50b858b7586f5e877ae3e30e75e0b1d00e51abfc2ed3d3dc7e649ccc3046880ca71fa6e221448ab7c4e74021e35208ea5c41ca035c27b9c670808687d04551f7ea0608633e4266ee9bdc5b4c86b28ab67aba51c12e8d907312c837eee8a886ad4672ed848922909e43fcdaec236311a2f8d4637c1bc0e30bc6edf0f765ad32d02c8f0cd81c730a836d8409f03e01e691ced70d50d5381e4e55860aa05c1ac07dfa46f19c18b50fcf7e1180cec701109659a122c84f2e2acafec70606e7b31a7b7ba0d2c76df07ff3efcd4bd56b0352b4da0bdba780a32721ac0f76f100e316343df79cad56b300c46778bd5dee37212212e4e49b2c044ddde84a8a6dc0b9d6f3c3a5cb8a660e9bcd7d733c6c5f996154615bccfad2d32801582afa353b8cffeeccb55ef3b2269072933bb382a65f4cc10a932ee14cb387eea31e0ab8d541cf9474963b80b48a233dd467a40c4f5234505b6fed391576db6da783b8f0d1e6f3f0d6a40330d2ffa6157390091b4f57e10a3e04a8684c498317834ec8e830aa63455335c00e5ca5925a6ac3098c67ffb87bcc799fa6d3f9bf189fdf164d1bb5f8f6516d301eba03d8709acfc6157fdfde118b7658d0ee6db2f79946ab0dff5b3b026386a30c91174d016cfd6b1b73ea710555c9c2c77a234b30f9bdffcf933405c0c9e85661873bb0eb31fb7ba5567de7a2144a885a5a673bebb62a676c163a13df413b51fe8bcc85642c3b1e7174af81be7fdd558ef26f1cda249a0b52844c9d1af1540841f7db9980487790b6e07be6ff6ae85b8f7c025c494bf9d5726dda9c3017466e453a1054418ac4acb2f5fb619fc785e68d8829ceb877d466562428b06c39fa481053468f560a4603f8306a8fb49fe231a9925e6c8e112ef309ee64e8e87ed199c3af8d73589ecc788d73a11de3a0c66fc222fc0b076c6aa39b8980a35c9dab082d4ac979595b41e51d90f645f1ad7ecfd0767f38ab04dba17f99b1839716fb6df7d4b6f5b8ef5b6043184fe038f1af67f17ff01b6597cc41d5fbb9d84283d4c2261a26f3b96edd4912307c77d3c0b81d379ab306dcce915aeb043e74e6f72a8495995359587e205eabcddb384282992d55295ed5fc87114bfaa4dfa628e7b9ad4a7b9fa1ae76c76463b0ebb5c0722d99b9b7ba2eb41175a217a3efc2813146581dd1638c7a4748bc7896560d4c36b861485e5e402eb25c51c8c65bf7457a24a3b0c2e3ec82e0331e45e157407f475dbc22f6d5e616fbe3c74fe98faaf7c5a37ce5bc3a3499b5b62ea0be80e7d958f96369122f4e29fd64ce38222d972243790b0aa3ef0d5a100984e4b97af6bb233adb04c368daf93df48b5d54f31dfd9e45642157bbfa3206ba1dde79f7210284516bda95b5b77323e58299b86558dba288db69774beafb295ec1ae8128ce302420d2a1c1562e598f8915d924b8ace8bfe57aed88e9374e6e98b165a749bd98f0c704b5b7746825d944cd5996d5a0c1ca30e79e837c39cdb85726f9214f5ac51ed80fef629c8b521b85feab6f6af49b7810726d8d9ec8bdf786572f636c305a2318764b735fb1e47a90961439c634a2e948923cde05e3f4576329f7e31396d08df6c13254bdd2f6dc9654fb888904fd7ffc0746a31b31c293367a743acf4344a376e19ec86962996f48c3f5ceb898eedd54ad8f3cd43367d1292fede2f8543466e9c00dfb90e26c4c683d7360ad6bcd1eba2740eb1b255b97c96df840a9b03e8f49d3bac1da13bcf76827d176891dc9bd10dc15fdcaef4332c030f4276429893a5b5904918c0e5fe9ae53ff845ba289478d10d6ddeca345f7ed54329702413db1bf1428b6734560e8183b4cc095ca1e1c3b066e9f7794bf29c32eda783a087b1adef5f3f2f78619adace84850dc9741bab8aaf076f469a4ac154e49781dd21b45ae045e7863498be5fe4f8697fd329a5adfae9a56209144ffa67690b991fbcb03afce12e98c3f8e48060e56e2bdab0104481f5e6b10c14ee83259052fab6b182cd27d1bf858be0346d47c084281a1def7765a21c1eb7e66419fa9b395e0e6b13d2fb2c502c383f53b5fe36972af3563b408381f59b8c6586539dc1c728f6316016eac4887071e96d32baf40c5808a424678186b688080b3850c4e9fee1fa7088421eabed99632fcde965d2a37cf9b37e87402819f972e02407a2c4bf26b3760855dbda453eff2435d6f90567bdb951faa35e29b5a10ad015bca2b3645facd7fc99d2063fc4529a244244a48473fe185018c6d98a5b040702e7b394071bbd099663969a2317384a73715562ee027d377cacb20dcce92e6ec8c9f0dc67e0ab8fc10044cae6f8bba675ba6979db54ecbeaa1838842e55f70518cb264cf7a39f5aea143e53c008788ff16ac640d25ddeb9329d50f83eb6c9d77290094547f464e76ba86d17f60475fef04c87acd4fc5a3a0e1e86938e521571a0c95f46a64e3f9cc9f34516756e3b0cf95843450c53d24d04f406469613f4315b78baf4a7d04b58cba3705583c40b9f51953fb092c684ae52d3c418612001605f6ec608a8116304a788cfd87d97f06e4dd85f2a2f6b3c79b8b0e25fdd787ea0ef4e88859c7aae1df19b73baa211ebbb7a59c7864ddf3b43736c7d73c71b3eede6bf040b01a7e5714fadf318436ce732a3d07a85626c93ecbd40cb70d73b636266c3a9c3a4dad01dbaaa591aceeef636a8f94ff75ccf1f4076a8d9b272433e585ab3e296ba363f11aa909b75c7c0cb98b874d97b1e310a85996e6a35565661ff3f46404cf20fa9d948fee260059b7189bff28c785ba3f2da3499c92395cf18fa980191ceaad7effa549ced0d662db3f1805f773b0ab08a48ddf8e2115dd148c688dd56d59ccf828f18181ed72ec9560450f6bb23c448633b498ff3accf5bda8b610e7f0045411d808a23cb401d09a9e32c509cded94d8cab3eb991389955737808a1fa5682e20b81bdb7d16aaf89d03535fced33b02a511e9d4b3f1d78ab47044cdaed17ea6d071c7f3787191e84d4d7ba02a7e8268f7eed426bdd997e59c58047cff4ed904644e2a4165ad837f48a03b97e7485defa397d55414d3a75177ca30a265ba4c8056d866ea1d6d46e21b1a6ed519f79f82cff6e844324e057d65fbf1144a603e60893fb35fe8e45193913f66145c06f84bc191837d8bfd74ecd1383cf207d73747765768cac8da053790a316686d777503fb5c85e5d221730190fd8bd6d366e52b1a3fa2ec747767af6a7cdc8dab9eb5d7b168c61444ca1460d03d83b981282e466f23f804ab00a95f0bcb047e30920b0dd08bdd30ef94fe3acbaa04eb4d7aaddd9036b844c68b61af64261805b7b9b3aca1c8ffd60fe094119926bca1cbee4f4ccd7439d97a81976f10ca43449b78d165dd5999fc075d4e26a85de276f2e6592f9ed3a1915f8cc5c8808d3e32a5c6f48b2ef82cd79aaec7e9f4f01aa56ac0d93c19aff75c1869fb6756010188473dae7e823bee7f73a32d18ef144b1f547d9c3439bcde4804a10e63176fd428f8d92c7eff6fbd84d6473eb4ff7882b1f78d5b26ecc9d7bb567a3ccde317ef87387d4b990c78137c2e9d173bfffae4ef86e4b966a3e2eaaed9a43b9b2a0653a85e3e650fc14f380a414b04f745095306746e4854bb821b56e680e4dc834567ae5c3dcb5147c73592b42e95794e70a0e951187af42987623a219b06653f8ca6f28ed6c859da68daadfcd83a72c97acb587a030c7c1baeac9f280e96efdf3ff22a5d596ba514b5745bcdc8ebff1af8bc6b0c6745e12305cd489daf7ce04c9a6719425ffe88e7cd36dff022f3f744a5e897a4876d32a007e797ced6264526262961222fb8bcf4d964554731dc9945145dac19a850b70bfa0cd575b697cd60699f53bd25905e5c0a4554dd6955c98b9604500e37088c42f2e206d75e9a8c13c0cef264fa246369f4f6808c0112a86cd0c721a7d5361dbcf1d6435024e6e796e61d2f7e1ffa944cc198887ad6ce39cb060bc2783dfaa206c803871c836ea7cc87de5c154ece78a3c76cac5ac46f07b931297b9f038f6e1428b6b9dd533160eac0759775bf54d7270ec2b330222f1c2467419142c01b057e06b3626d75dfb37336d272dd64a1bc4e16af4327df7f8e70279e63115801a5021940d84c38e5382ac594d3de77126a6e9790aa3655d5d820589e8a1937bee134363cb01535d2bf103393bcea46a274b2adc37cc92ea39565e0eaaa63cbc3e07a5250621ff2a7a0e49857cfd8d81e418dcedb5ea2a8d20635aec4f22edf1084d6379212383499975b578ff51fdd27b1ccb33a06227cc5a4aa38e08bfdddf805c1fa943085e016f4abed9a99ec91396d3a5fe1522d244a556f1d61ced10eb17835c7893bf3625682beb97443bdcfbfe98bb3364ebbb6bc3c1ffe7d15b4b88f02d0f8c43521940f87bb52a344c0ccb493b6f9843d825f13db3d5d3cf1018c883e97e494d15f2ec12b03abf959dfabe6eb767f1d0db4d2c62d99b7eb66c288d21e9ef177d0552f9fae51b42ca97d0880f6fadb262ac42bb31fbcfd38268b5ad25808643e528272b76b2cc4651a83b28e233e3178bcf7fa6aa2be753f0f3fe4ae284f75117a494d53f15d710b9ee6dfe5beead5ffec1df1b95bd0db56878710a81bb150deeaf80ab6d1429505aca8f0f100286e3cd9849b13ba415e0d501256f07eb9f31d7172ef1262b41ea4d8d59dd37ae80751b27c54070b3ffd97b5d96939d927c640746392d0dbf68ec4b881107d187513bad2e1742d857b3bff248a04bef68a2d4d2fd9422ce54a05a8bfd63a57decf34438b5376698aaa501a6ce283520fe93cbd500350704e8c3ad8268147764fd72f48e757985a3a38154bf8ef076b08b69b502023d5d9c11e75a30a77539505a988feeed064276e5e4c97603869c4a5069a49ac7baa175c421d11aa819b730acb17384c20c23dd6b96a414dd5aa60e05d227dbcda8a8d3cd83b3eb35dcfa9bc95650aa1aaaaedf8a31807746c2df707eb10274bee0104a5f8802fd46aea145173e4853e87ced94f6cd61374b64346af66cdadda0ec9f3269b3aed197fe5c9f228127f7bfea836634d5370db75f833c7f83a90475e2b4aa53ff2ce3a8369e5b9e59da2e1b76f8ccbc543e3966c3ddfdbe113d04af6bfdb6d317b50f44c0a4026d5b858509ce5bcbc3d47f4667433930e193eeff139feedcac124bd1cb81302c56334c798fed7a14db1e980e5b5964270e49458fb788b331f88c1ce915d6d23abd110079bccf95a62d40f10144df9357f0660c31c250125a8dfdc820d35bc6383d57fcdabf698674241a873888598f1156490b56b953be86e977691cdae097512d287747a177a944a74296c74fea8f21a22f76efbeb87d1c7bbd4cb3b41eb13dc4742fcd57c92b16ef39c0cbc47e9bbbefb346d8a90982ec39e6d2e72cf9ad2eff6aa3f62b6b16bb1bc0b09fdd9797ae945f2a113b226649485277c8de5eb85a1507aac63fa67e6c29f6bdad2777e2e783067a509be73719c5a38b1ec97c82a2688a26acc2e72011449c00f3fb961952ed6e6dff83cd07bd82a368811a4ab1563f96c9b3512e4bb77e72b9fc703e275a4d09f0c478b3c906130c655a144bcb506ce102cc15c3e316ce2ef79266335e7fa4cb9e200c01dad5753699bb5089596c3947d1915e8fe8d3cdccb8a74de3970d6fa5ec47025c90df92558ba7a679b19292c5a4d91bf1855dd41971c7b60d91a26d15464e6565e12e8cfc04898af9af58bb2df937e72fd9c4bd013bba00adb68eadf6263fc613bf13b4bbfbfecf4b8bb6b00d606b438c4cf5e3b37558ea88fffb265f118875a944c513af3fad60ed98be368f62ef2adcbccda10e540fa722bc787b39225b7d90cab7f0d80cdcbd4619778c07bbe4a1a49df201a13877f2759976a06d432ab28297d100b1bdaab74a06a2dcf64e780f1d3150cad45d4ce6aa0f33b1a8ebc748aaee23e3d5bd493e3dfa0dc66b639870b3640cff544f13416ae05221ed18adc6d3c42dc27e96b6966d3fbf5f5b9a7e644977ea718a77102514256502966ac8e9a5a7e0a5f2b434fbc11e616afce81beffddc3fd47f347b480a15ce64586c3c5faea3656d6be33405d2f0a67eb09189846ca38eeec4b62a515d0c049b37c090c94c64fb74d7da1474a50c4c22b39fa45e7c14eacd2b1147917925aa270cadf34624118a2407a24c02f6dc5b08e2faf2ae456ead26866d1ce4f54c643582d9e4697880137479e64506a00a9956845e9c6972de5cedcb15b71d3d607754a3132bdc0fe5410f958d9b8c25c772cf31445cef4d8c4036f806ff7be44025020a79f72e42903285b709e955a8049c96ad5a4c130a4d44bd48a3e3e4f5efd9d21aaa5b4e24355fdfc978b80b7eda206d7a2a366f1619d331471a0f9d2710db84aba900cc4aa914b537ee8d20f7598ba1646f91828a756a998d244915554a1d2df56e536b30a5f9b6bd47395f99e347bbc23d897eabdaeebe8e9d46b93141f97d9b519d4003c9ba645c5228cb6149b4fe67463c21f37d96d75461102de737c104829fb683a633de9785cc99340846294b5372b2aa91c9c59eb36438b610fafc72314a7f231fd86cb8e3b10234e8b6d7ef4b417bda726c16fee70fd25b1647ac7ec13fb8d88f13c62b3c9af334d6896d4b1ef02c08bd08484d6bf178c90ab8f2a09a857f860a40e43d872b0b265e2028c0c2c5d6b989942cabbfa38de13d62d4d9ae7470a12e4dee345409f03098660e8d2247c1deedfdfa5110b8b0b11b93ee0557b32789b0a6bb85a4d67600da91658d92a15bc5307733e750030670053f8e536fe792064ad4b912bbb34efc553c34e207191308b3c1af86d078d7b6a3644045e1dcc0ee228efb7f8fc67f6607df9fa7eeaf6540ba18d7fd00d54ad52cfffd12a29d70b4131e118d5f4e1d739e3590a3d9e5fb7343b322c855119655ed8aaa9f565ab1cc0961d93e098ff7a52f63aee28236f098cb4c24837910fdd3596d694f57a0d21b62d1916683ca35e5a9ecfaf968bd9253790caa410492145f960626e2c81592c569020f861c0076f691498ad3119257b5e78fa2e6dfbfe2c710e4703fc281adc3643f53cd06e87053809cac6f35377a04860aab36ef6156f44946d6306dc88cd8fb655709bb0d2afaa13aa7e00392e3ad5ae96769dca39216814bc8b70650b149bffd0f4db4ed64434aecf76d30fd2aba0994fbed06d4d0ee41ace3c4d0fe2a7dca4ecc0ea8d133bff8e80c800bfbaa6c11c1f6a2cab1e4febf074a5d9c8e42e0a59f38af78b4217050d6ddf8cdee5019e53fc8b8595776cafcb7b3b238d52c4d98dedff1115b16d5cd908f8b0ed35d8ea711151e1e1a60d0d743ac9831e512b4d8dddec497db3aa232d6748e55d8d448538df4c37fe994ae11bbf757771398ff62a0b2279957c001aa3c28ae11321540c9ea1fc42320d5d8faa3abb19e0e1d1bce391197737151c45657387afdf0e0b04ba336fb4740941e6d080e2c4beae2d44ebbb626fbd97a3e87881ed1a8ffca15b2e7183af180d82ca79aa9ce3ef637a4cc849463b8a7d8d579fe9c520d0971e81b8bbbaff0e5574b531dc87654ff9cda7660ca0e22cb67f6d3af042b7f677d680285af8db1455ee78889f237894cb23b7ff51140a4f0be785a35ca54452080da22219fe5dc19f13c12ebfe7f2b6eeff32be57024e48b108e5e4b515d682d8d958d54f44c033be3a219c306c10c14efb46d3ac7c30a246bcc1c04d2a7295b248aadfe6a0430531c24e9be6a0b74ab20ab9a4c820bddfcfe8810a5fe305859a76e88a95bb339722571e0ff3f14d298ffa790d0aaf275f145c88ba923232026f897f68b6c1c64e2cc6cb093579c11e2c37cb89a99bd1a2332995d8f1d44ed47f80374c7d315834bad1b446dd2fd4b5a55b7ff6c578c32cf0303c23235eba0c7f133360e3b03828c7b009230064eb04c126c31b92f66880eea8476ed299fed3447b80a48378f46aff96962d7de0df690d4212482966c49407cba2c9969aa904d872abdeb8029e0fc8e178fe697d93f5c56c09cb769ec5ee1b1d3708345b3776f1743b5bcf7cb6c12bc460df38d93aa848fd5a2bb3cf842e932a0f10080d5a0b6e9c67c17c332ba8899ab010f0f1ff9bc0c71014406f298963c4c29ce76fbf1b373808859d1c46c405e004e5da087ef57d23736589c5bdd25dc5a9f1b590e2fa9c97c99d5b42cbe2d690d0e17fe9bfef5b7973a4faa48262fe5ab4cfd33bf6c0816130e5d1cfde9115dfe6152c5f3bf218d2422fe226b97d1a7934969e988b1b1ad28286d144de3319cbb9f65c12fbe7fa0b334bae1083176d0526a8efa75475f463c91cd814e6ba5590a8a4125e53d13","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
