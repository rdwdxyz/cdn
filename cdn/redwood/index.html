<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"31c53d5d2d486bdbc242501077a5c473e201824976f34ee33c73bba6867f8ca4f0d7f298364d324e0f96f0dcf4499491ace81ded579d3d47815aa30dd5283643bf9d025e9e2ab2fe0161466dac7c3f32cb7ea4c4b7516a2b9957d66a8e5725623191e4348135227e010513d7bab62e6d6b1793abb7974be3d94927fe1b737028aed14a4edd843fc0abd1b86dbbd0e4ff925be4c5ced7726d3e4078da067e56c4d997b33441cb95eb0276fcc9357ca2c629dbd2a6aedf00613b95f409c306f69b2472807dcecbd6d94c7de36b38537c8103515a5db9a35a138841f596a89c3dc85fcb08445960127fa122e250a33867ed8a258689995a6375cf04bcb9676a13fec270786d5ece6253655e64f635276b469ae69a83f36e752aad4b8f75196eff139328bf1df38270dc56b953ef7d00aefd63bb2200cbf85dd04e1bfdcded0e5fdcf262236ef9643bc85032a5041ddd5b724c5376cb8e1287616739a8f25d52c991be152d63cb90b6b96ef1a4b4db778c729131bdcc927f0e705441a55e129678a8dd910ecc523d4596e8696d0c55aa311749c0dddc0f5f335eab46afbc0d9fb090180a19a96782f6baa39b16cb583270fa58615e1b9920437bf0c49565ee92ef0425991fc6de3ccd10bdcb0f37ae78010a5a78cd01c511d7219fa045f7622e4dfc4c76af52b00f4824db07406a98e77f89319d2fa342ec41a62ea5c54374dd3674393c55275f44085a0271070acc32ade64c6fba3af960f4faca76baa44689ed8e410e29cc7e23f8b26bf54a48428f1c5626ea9d4d00ad1c5a4a67a4aa2d239fd9ea1d4848a68ae3f8bd343457be8acbc96fb10c753385b7758eb9aa623db7a18e5bfe384a622149054eee064f4267d6d36da0e8980d780aec9dd23fadcce2f15c84cf00f040c688ff99a534f83e1d836c9a3c5f7d26107e808abbe0bf2f2686bac1a98de87be39e1b82e4b5d9a73c6f5eb6500893ff600638b8e6ea08aaeef5acf8e75e31bc80074a8ed15126f4a37a1a790f9a1bb6d006558333a9dec5100b57f92d8675937081e0d3c280a134c57606f99606db9aa0b85b1f9f49a7af63cbc5cdb0a52b80d8cd1597bfc7502c871df9ce204466b95b289a9e85a0d85a7af85007d937d123589cd2f5278b97279fa7c31bbb954fd66a739861ad31a8364da8edd58b6f78df5027abd0d50307625449e043ddf75ce1568be829e64fab12823e923cbcc31a1ed1e7fc8a89cd418ae480728800893baf9e6f28927218be1b5d7ad4542189517d94a6b4a329be03cc4e53b51e239322f90d5a9485aa14a971f4ca52a290a7a68b11538bc2451872e3686e4208817f8c8ee165ef3fb865f9d77a3278d521a2ce30b1ef36d12e7347f9960983bdc06fe84ca4681dea5430d8ed51e1f6320a83fced7f0aa9e1e08307c90844e6f6ecd19317b52347b79760290ce238867faca0f7f007c044a904651ae2315b6091d54b6362fe578468406f9d61a80d3b4f749dbf12fcf6ec2779618318fb754e61629810f92e0bdf622262f69a887d56bddfb4666f7c73c457599b4837798eb9e1a931d164de4ba4a3e21ebeb73d908abefffadef04c49926ebd9ff4b8dc0bd211a144a311a878bf6d88759abfe33035f59cc142b3d2091c7511ecfceb1e82db9fee9611dd38207e4e1ea477967241a5fab71d50382b9ad9053c40e26d4b63f248bb3396d2de39b2d2d17d12830cb391e0f950ddc5955996589a0079c348f979a5f8d7d3cd91490efa331ebcd2b265e5f1fccdff2f5a91a65229afb9440fbf23e14b0338167693cf6974326913198a5a57a2cb45c042fee4bcdf1b092bc2c7ca9c8e51618685410409eafb170c094cb44770d47abfaeadfb0f4566874be430cf4644d4b6f9078f2b0e85653551c0b4cb72697299e831f2892b3fd0baad41744f75e84a2fa1466a880f042a9128fd4b32124012a0054b000acc027fb37a5358df438819d5a104c3c89955275947aeaa8c32f1b4bff35364901aa927703a0b709b450815670bf6afb9e1069362c4cfa696c52ea243ae8f9f963359c8efad872e738af45bbff0706d1a7030214a2c8d21f3389b8760a740c864e779b489b5e202e1571eea7fcfb7bbca99593bfa89c4d076331b22c17aedcea2b5a19d5787d0b8e0ef54e72d5ec82fe48855ff69c0c575b8ae054c102a50f2b580439c7fb380f1a6064e427c9fb026e67c501f0aafd3852e76bbeb25036ab9f8d2a68aadd4277cb84458b687f6859e496fe73802f17589029abc937366e06a20c75f94f88f908e70d4e5dd4aedde1af1898060f19e20a7c6f29d27e0e0d0f1e094818c68b5b93e051949a5764e51048bd8341cc7401919d5848bda6fe209b2d097f3e95898dda31d99fd2c58b2c52257048a026941759f81aa71eaaf5b7c6a0b86928106b0b1e4158db72c0f2233bae07d707efc50fdb2f56cdf9116664f176a9fbedc3ca65321b34ac7698138385b56ae71ed790243ad945ebbf34b79d53f62a20d25ee942b3cb3e369bc13f31c12c4790a7fd10ebc1c80592564a6dabc2f5b18c5384e1b37817bb11c4e2db2477688b939bf5129bbc408480e26878841f2ac071af47feb75b0dfa56e71e98912e9e29c8ffd84afe6e5a4f49f5f86c7de5098dcd00a7059d238dac10fe0ac659e493edc34450085ad01e11aefa85b3d36962213cf0f28fd8cc21728c3b9b0481c4846847676129dfab83605ad960bf5bbef993af871204cc272e26cc45dc7748f3f983b1402a9df69a83a7a1a8bcd9a52e41d8ede5ab5a2914cefe0b437757e5bb2a23a19e70bd0aae6383152b439162ca9f5fd96f671bedcfab04911f68014c8d6f84b8f839719142497e91649d64f42caefcdcf159f786e87e58035bb4b252667d1b951acc9791a311cebbc5df56de67ec9a1d477ae4a8b9a22cda8fd296989641bb0a32ea15bba6e3427163fe188325f4743f147475dea1670e67853d869d671de07ea7958be55395e03cba7a9e1e37dd0748ec261ce51786839c694d0ede5b9e958a3573c1a3c846d8fa6a2968315b3effdf86b97aa2fde61756a8e2addabbdb5a69423a6d5b361fd76003cc1bd3c9084e7a563adc1e2f06053616d68097bdea71a1a89fd3cd7cb0f373f4938446e6aa3476218884604725af1668d941b96f117819a0610c7fdc2a99f057f57b874c24483ead5d01a3f1cb51414b1baacd84209902da85b39c03541039106362a7b1fb590793813dda5f0a489df85b0b7e7bc6f98fa9d3a0421e5785a9e841a856bdd5f0942543aaa1a9588ace08c6fe1e7bd6663c9c6778789d66452b59b454f0e8695109456190edd030829c423955c690a9ba7243f77353857f76f0026be9296fe6fd0aada7187669a5f4b81f05dc599eebc880653eb9d57f9dc3a0feeef83f952fc9c4bc60300018ead0d486c9b56aaa07ec577c562478c5c862df0e503a41b5cd2217a0e567924e2c9adb290aded6a9023d9725a1564e9035ffe22ae8487a48265061fc0e2b9cc3581c5d5e0332daa267132af7247a9199059144de3b246e7482d1ca6bfe3c0113dcbb7fd82c33cf1419fb5ea19f009e156ce165f7d63a76f5bd25709f7c2515842eefa841e9e61c528ca86c78270ae96c5c6f15f6e438ec53b27d6c0ac1d69f49104387856fdf30d79cc0c359177b0ee2a7c0dd255c32496425bc423e933723ad7f8c518a4258fca801c55ac94a188d2d103bce4fed7d9fa785771b68817fcef2fd11450d00fb4d9eb0669d92601a338f2a2e68c1acb80ae46c19bd93141fe5250f269950a97b448d9ad8ea27f6c5ce8b8d98005630e01979547ace99c4f59fb6758c862f8758134189d677b3b4eb9c3298bb7871f2936406a774aa57bfb101cc20e9e80d51bf955105c72b0defecea67a242a94fc7f6e11e209c19da5aa4728ecd5b813899af53981dac357280d89775ac41bd8d74809937a5a12f24acccc3a048080584072ca238a5fff3b4f38bc0240cf5f0f20cba35569401b4e79a74e144c5c1618118d4772fea10f5342312b3c0feb0ef90dab04be68d13f8804eb8007b77de96644bf0f0ea90261fd9c1a7f993870c5de4c5e352969fd3652eda400b91c8951255ffdff4cfeeec3b228c224d3aa076d4434d0dcbc815a6a4ee8fb88e04ee49a52742d80bd77ede9a3f77100cac6f30a63ba9e2443cb61ee57a65e6f2cfc1599c5013e915dc8c0c5663bcd456c0c06dc216e0de6bf1c566180098f210576a3922a67b5824d09f6a92bd251417caedc0246f21cd92e3903a06bcd6602c6722efa0e6a4ba488af70fb766fef45ae5fae9d7bcdab67cdd7b99c566e5f95f6b789a7d5a7803c735e970a16b2e13cfa6dc61bbd04aa14f7cd66264311626bb3a0d09634d966d37212112b5bff19b09e960d1d08271df6de809e8d7a202209389969711a60c8f4d832e5dad42f165c5a844a315c0b5eedb6bbf8b4d7030265ec13b87ce5ee5281264565a22d5711c042037a0ef17eb47677ef46fd6a4eaa00bc06f0ea8f37ba808a7de7e00d251c9dd2bd5ae1708cd44254bbcc55dd5535382ed5fa03a4bdb5e9a585d5afa86160fff2b49640ed28ef097260eddd35a5b3432729f96c9ebe349c893514720353e2e2ebfaf10b8aae4d534363629abb7da223d24e72385d4a06727736d65c94adb2455d8785c55f6bc9decb098f729e16a479ba969fc029b3ee8391aa6a3b84cb8d2d6e2a5a6f0a8e94dff34328bc010c406564bc65b32756b1236f331137c3e045fe0e4e6db18c2c0f390e025a07e4d2fbd4a10fcb2427124ccc4bb949e4832aa6da444053f87ea57bdfa867fc93795f848495f3395d269715c15e6cec4b4b7e2baf489649f637c59a4eaaf249f93c193e853823be6ef46c3e6334b65cf78af42e33525374fa7b013651e8574dd5aa7d9467a6b86d862f670360e8ef408201bb397dd45346583a13546240e70062e0922964de10a785246f759bc80803e54752adbc0c8e3d591213c8176a77a4fbbdae482c9857da51b87bc88402d89b1134dc417d0e616c02e06aebfe14ebe341fd74d455b06a61035a1b019bbc5fa155359f86b2086f3f3d973545e0997796667eaf7cf5334167006c9f49c9f3e85df99bb0d5a1b37dd77a28c407e408df86a5b17856c6ffd9e120dfeacff84ce47fd2121bf912d8b854c310f4648d70806c40702cef8fd9856bf60a7a55bcf0008ca69477af8cafc59c32c972e36d7b90d2575a8d78d5cfd9abb08f9ce341f4fa6c8ab3c9527121024e40385ca4fb577f4431743e457b7fab61941af013d956f1ee95f7274714bf85b0c5d175435743b9b34c624249365fbe89697b5c428308c5c00a6e277008b72f3c2764d813ce1b88e77d74bf1d895fae2e16811129b1ebea14c883922904f4da6c2a565b9935880c50e97e0b77a1ffacb44ab2f4e254d59035589a0c41ae0ca81b7f383f1ab1dad5504203c67c19f1ba6b26f2d675f2adee99ca74ed22acbb92768ed93084049d9f42c2b428e3dcded35aea5f7e7e9e885760e5fcbc248356f9ec2906671528129a4bdb747cda383315edf3c8e1dc3920417f483438975b715df446f0f0ebbccc11351727af74f2865fb78a3f5d9071398d5572817cc664668e34483ed19eda022d99638db92b2e0aee38aeba777053d58db6582264eac35b92306bb2c7dcadc2ea530d9f4c3b41de29fd8392ba676b5727e8a6080df48bc87d798c4e045ef935602881067eaece37cf61674ae29c3dfda4d8a197df1d9c7198d879a39ba127585adeefda91f5dea1fff94bbf666d332e7958a47d283e2d90262027e6afd62dae9ace6e47181779509801f30280bb26b506f1559f690fd19e04fe33b50b9ae4010e02a90bc4a5d592d2a4b612c57c857e273a43935eee92bc89f0fb62aa7ad61fcbeef79698769216d581109877ad0f9f4f8951c3f4c86a0381f40604291c198c2e0c5a61c352e8e594d46bd36e6e4d7638b04b74ffee001bfefe7f0ed13d4795ae9a60eb23687f04bb7ce5f35d37fd5cf766a8de154594f215dcb429eb4f0ae7661c564b851d78c7cf9870a79a1898bd476a41fe16fa098652416f6a5ea3fa08e8747e6285fe1ea739a3b9957043f1753d11c41d8bef27ae932f968019ddab8959416b24eef8affa511ce9b68de094e1e6d29804eccfa81fb942090093da67f8a6b1faeabcf43bfde66d0bcd4ba1dc3f13f3b0d74c70a4963218f918d05272a2d25d5e0b5136d38f4d034d460763f2d561ebbff1cb37dd64c15ebd60c92febef2ff89962e424d81f3beb0723b3a6abf00f5a7032556de53fe9032b191ed8e56c8212f5ee3e730af6c7d9faaf61fe07eba879352cdb7ec3b499a272fe99a3b11f735994c5da258e30f50c283d317eb4a78c5bed076357cc98e22a8f22148aa98100ee120d552aeac916c4f444eb968887bf766caac30743450a6a70ae061499fb11c917dab8f18a09c94e50c720377072772f94608f1d2f2e15dfd916e7c1c88c151109988501cbb43b2b262baf8f067622a4ed8b5ecb3d1066baf6eed78e9a10d4f9303204188e6046405eb8d35337637675fc6fba939e8a6dcf55167553e3eaf240a117b4eb73f05ce6409ac38c5bf36507cbe28426650bf7bd9f673f54d3ca0a8fcb6fd192f13c99cf3cd743776d610a8b16ed5f7f03def735bc40c331ec89fb8cd35d06778827829ca4751b45e445a84598afbbadef62d4a073cbeed2e0d8afb50d92a14f6861330a5384d43751eda7bb769b640b651fe6f63b9d2a655b59fa2790dc57922ac3b99b06b8decce5dfef9669cb76153c895be46ba872ce629d9f22e4bd317f0bedd6e8da3b9cd9c85f8722b63f114b392a77650d10eacea73a7227f2bf3f26f1db9c8a2105377689ebbe159863ee6afde0380fcaa7c0a958ce9d6a9ec9ae394ccdfb799e84798a3e5bf7519babfc8852db9d590e05141879b0654ad71b1ecd13dc066245454d6941b2b3fefaa6c5cdca93e064f389e221e1466cc5ccfa1611c17df7ba2c237cabd7ca876d70142c495e97942456dda08c3ada42b7be201181c7b518f253f1c7d6e1c6b689a326627b0d0954517c95dc2fac8a697b4c94e770b4b954895d56351117058780a66b002893f01fc48a35faacaa9b38602810c3511e40bc4f109d759efc386ad62598fa3c6b2784e6f4aba20424cec3277a71e3f7d20b773536e83f4321ad5ed0b7d88707406c1acc70f5c757ccfc25f5b598bbde6194bd79ed01488d1b48115e3ffbcbd9d6def961a629c84a63aaff0bb17fda4c061ef6e2d7501c0f9614522d15c9d1b52f96346597709bacec669899b22be48f9bfb56136293d3c915fc562406dab074b648b2bdb45fe7c16b3936f5c15c3668912c94aa09a493332b3eb86c257e4a6d2903f7e7692cca3591831403c563f50ab652577b8b5914f927f2e3d5f53a5dd6fb2d3f73466d73188846d14670ad26bf0c149f98301ecb6ae93236b956a42390653ce96e5e8f46f4a61f25f2826aca19dab7b4f00d2c4859d6c6f5eb81bb8d4a6829b9cd8b7f8cdf54e1838206f4070201460b8de0011fced31bca9ae57cb75d71622b25ae9a89e2a13a51d88c7ff1dd8df06e8e1a5e779a0675effe0658b97ead052d71b22c4a1b223dbb9a5d9ee1275be2fb687792bdc0bc719ecebb3462c10d95b5166cb951e145fab80cccfaa807ef5aacbfafc3ba96e8d2d58bd6fc77d481f04fbc8c26fba44a6d374e73f076ffc48da528ae588f896c4ae2a8dc01bdde4c3a07184a634943b001931a59107e57533d72b06fe628ba1c64e53517afd22e63fe95288e2794998ee1ef74ac4c74d9ec89fd2838dd50b023243e89f885eb874879be795bd8b72d381cbde9be5c124edd0be47cbd43408816dc7f5dcb837c6c4be17303cc76e567fbd2be7c278f26a051742e16d8e8f9b607e6e9eb269873a4ee92325bbd9db880e82a61f274a7692d8f59d192fa467fcbe6d1d1cb9b382772989e8578fb7795187759b13de21bd41038474cd0d7d1653716c600acca6f7a78d2955e70c4cc9e0674ffecf1b996eb2b9dc8813371380cd74e5b278a15631be084d8f4692496b2ed4a2e3bf2e7c17489dd5194e6d81668526a8b1f6e5cd053ad67235cb84499f57a791b303b10c33b3b4c4a303b922145881c7400f9535534f6fabdb3c58947246cd2486332cb19d125fbdbd5e5995dc30f1132bae3207fc62b672eaddccea3a5c00d8ca8f2a48737c97384a66ff7dc9489c6bc6af467a98152c139534ceb52f8c1220835a47341893e257f6d478b67ef8b310f7db0ba5e2e26f5495283f2c778f46a1babcc4b22eab50ba03e2a1be38224545a5d6cd9ee318b1dcbce8d53202f6b6e718fe8578dd9d0d30c59863bad722ae07484334b534524a1d298e8a8f5277d050e29d4d1eab9a76aab627f30200a40cc9630ee28d531ba0740270ee7d9e284487c26a63fae026e958608c59700b28a2f296b0f395258b0bba7a78f9417f615182c21c6c0416c9696e4a8badd045d7906fea27a333b83d6b8808482ba92cd5fd250d65b97359f10b4bb8d9530c3db53a8a83b9482d6ca5347f71df4fb8dd1d9a2ce8d6cf062c111b5999d149606161374510bffe1a1e32ea5aa613f932230e22e0c3f78e4c114b2f7377f7b729f992a9752f48b8220a73dea61190a84e3d24d4c62e1c6f214951858a9f522e6d8f00c83244d36de59dc2c73c0a46cf3403f9a3998aa627c685b8aed910c9476f69b3527896cf1d3350b7dbf59bb42020ffb026a567803a1c6904304f7476952dc1e6b38d92ad977b5d4444a6fe4161839ec1f528cdc647131a44c3a5923fff1df4a81bd030b7cbfcbfcd77ba3d03caceb8bbf0c02a74dde6bde972b10935e235e66d262d1feadb3111eb2a461aefbd9350464824cd305f18b6054aa40952ab799672bac3f2ecf5a4b0cfe6f07b2373e7df4f925cddc11e34d9a9af2f2692b4d8ab2f3615b6ed4254a4b7ebaeb9bb835ce04d28df08a2a8bdf3a0666ab24ed797a374329fca427c7a3d7a53bbfb91be3ba6962a0fb55ce7aa9b0ba160365ace3d24156fda9a76845d6e0d185438baf56ed9003c1b101290b4d2c8cb814320c3bb943ed8a5ed835bed103946f5b0e2817c3570b16028c7d66041abe7267ee01218f45390a004bba82d8adbbfd3aab0068dfd3140364c156ee48fb8e59d18f9281b17501a22eaefda6954e3e87b01a0ab107dc288a5bb07baf38e3eacf00e2593ca3f673c0ffa38c79d55406a70df31e285f376d191307c2baf53f3df6fc5f62fd1745ef05c9ab678f0ab210b21949ef83e70c1c4f5ec706086940a5623b769c662022b6288a84c5d483657a1c23ccdeb2060bd404a9b6320b5e2290377a5b85ffe6db5c6da3b74f2c5530ac318670a26fcfbaca525fea1a732602db52fa974e9cbcb8ffc37d9475a12242f487c8c2b76ee2f2a6bb1abc0ed64e5bd9040b7389b43357cda27c3d48f313f463ff393346efc7cdd302d1f84c5a2e980cbaf613ade7469d9c9b759fb171b010bc57dd7b6f1f84a21021187092731e4681c92cd1d94b8f5d6b08084a5ff7cd6696b33ed77225687f32967fccf6e97504a96b31b30a6928ca6f9fe801ea1de35af23032a1a32b3738c2d7cd8e86414819539ffc382944f2605479812067fc4727d6f93ceda18e7c4fb59077901d4b101adec60ed08be588fa386045705edd4479152de3ab83babd1a0a82e99b9d8105822ecb6b76e7d048bb853ab079f2f1f8b44b55c1bc68d9a716fefd00ca8f3397417826a17a802263a5633cbafd9e1c83008115f00b95396259a42ece71503f9accc9cc80e85c55145656ad935890e2760079993b4b462bdc0657a96921f8013e60e1a9b586b0b05fabd5fdfdc7d2d19178d986ab0693986caf50eb73c97360b8a44e15756774bf8e6ea8fe400d97518d9c86c9616a4b00469b582750dce46e8dc477d602bac73131194b8be962991c6dee68e1e7543e926e5e2b29c7f0baf39d337817d4c4fdf354fb913c396106ee765b9e3a82f8cab6e363256d2f4fb59b23fe7f5377fce045d7baf68bcd5508c01d15b5cc2a4ef88ffd07d06bba1b7d3c0164401c7df7fd30e9088032e57f4e7a8ce1533e3625b149703b6b53089a9fbf6620197c254b2373b2c76f260fe807ca26349f79eec5199a07295be61be1cd3934774160603d94f43b2b5b2f223dcefb5e23b291b268cfc90a05f540829aa9d362447a718e550d47fc1eaf310eec94e2baa1f6e3b792496ce0dd5c2addae8658a9a7d863e357e38720fa1d782fbf8228b86ed232a2583757d6de3b0e71d2ce737286d3c21c1c08770eec2b973367b4ecc9d69d1771b18be191fe3a5841f8959a7e1d7759904c3edfd28614b50af47f64aa4788423d947ad1a2f484b43601af6fc5b1f96c3dc872cb127ff6bc80641762c9df8c8d82f8a78e7ca646fb3e5b66fa5d4b9ec3617e89ada65e2cc63bf5fd7e54b89b33d2122afe908240ac3e2369b4a5104207eb5e640e5e11b8fa9237e79e1b7958d73db90d5286f74bbfba875dabff149af455c69b476841726ff099731c58058576ca1f12dcd35a2d3694f778e4759a8bb4121c702da8dbe2f025ba38ae6e3af8f9ea799e85f2b0a0ce197d73613abaca2c058dc3e64cbd1063a694847404c48223de10ca2a06e47f8b5615ecc382b5a65e92a7c9ec0989a28db109c7f7e1d6be9df9954d24f763dcd52d6a61f0aae6a10ad6afd8d15e65bcb5c1e559b17353fb6ea6e4ea5c7f23d43fa65693091b5b39cc2559566c9b0ab4a9a9d54ee0d77fa3ed3e70f58e9a0f897b52b30be07327066ebacd271eeee7afba8011216821196bee659b1d46a014d7d5b9459baee23188f11e8e980cc230afdf09b0895f00d1ac317f925c04e0eaddc85e99e1670ab4e7756b6e36723701167c9b3a5bed7a6911118f54c32ff74431491da36271f7dd2f1de1b986261c65d28521eefd95cd7419424e264b94fa84b4a3835e9fdf44f1e27da61033ade98a4a02d8dd4ff3d22850e1126353b3a7c0a6929ce9ff8582d8da5a50a00b34d9fb3013963ac3eb85eadda30fd33f2cdd4244c7d0c3733dd026c6ba082acf76b712014674b1b6bc974298091a8171d7ef3fe88ed447bf002acdcb2916b106b84e96332a95d9cf858b67006630d9c5459abdb252cf54579ed036a778bd88de4d8c97c2685330ba0b54c0078bcc9576d763dded875c321acdfcc5f723b0553e903097d5ca35901eecd644d5683e5d3c957354cc94e52b255167f5de43fb256b5b5c8b104740ac676478f82fbf0125a489d0a19d8860df72d9297fac15723d5122913a48689e58c13f74879d5bb1f9ccdf47ecd6954cad61ffba650f08f41cfbde4ae15940aa9984d713fa342b08b350421e62f9e8d7b50468d3767a0e3503a04a3609d7c220e1b557cacaf93796c750626b25a2cbdffadda167344576088dd22d07ff571514cf1a6ab190847833ca7a06fece2cad479f17393fce12ec59b50f9c1a297968f9b41748326c29b37214a87f3a610f466304119c6b518ff3a2b821ab62065533bed052876765249c38d15c97c6ccd102649b8739f354f4d285980bb51fe90c3755ad3fad9f9d95be158ae4ee9ee3ca571b5ae38faf8e05cb32e51ad786a1403ce0ab1011f2198f4eaabb169adfe1a8b942f74ae14fa04f3b5aa0ed9bd1405c238bc2c39bf55713cada1c698661687ae7369638ce19372d67a42097805d0d779b13a10b020a58904f5828b5de6cee698c4cc8768c8cd44c14ace919f95ce3bd66066543206aff1e1f88565ee0455fe51e5c0865d659203fb871a269297b7fd7226f5628da7319379d5f723738fa55dca88ad2c614ca15f894a4e9d822b9e71f96137156279a3d420469e40b4d2f7b82b6c44917feb4de33335ee12cce3a0e1e0c4dca84aeefa31fe3c19cf4828fee2faa05c629340ad00312db91ef0eb46902d03fc01e845983c9effcc330ed434401cbb885fc726644486641090ad3bd694c2309598050efd3b058fd171d5f446c3c9dd47ca4b3626689feaaf6d2eb0ff62672c24a1d14731ff375b41399538d62961e0f314a01bfef0a0760cd29e9becb5cf93ec0d8f363ee47b103da9696180990d61c563894c4018433195f259533a6207f3cbb61340c5ae1cb8ffbc6e8edc617f054e6a3ef6625df26defbffabe55f7eaf5b8123d3f81ce8a32abfdc32c864508db6491a9b69a806e11b28ad6cb7fd7f9106735f6f8f87f5fa336382110a059b50889fdc03873e320d9659e0e6c7d948e0a3151a65956ca6b6bb49693132916d79e7137fb24bf699d801a25c13dd8bb30a08f6a86251e2345135698b82af2d39df0314ea50d498f835f6bece1651bf23192056a6ea38025ee33db1bcb1bd6e8a31503cb3376ddd5d2a966f14b1d7910d2e38c032ece4f86238ae1ed2b7911f1d68ba9774fb2a369d5cd21412398ec7d527f9689bc2fc87b9df7736ac7cf48cac979579a3c66e40e30bbdd94c11f428fcb2e64b74130f426a12275d9486f524d73dc493358263e24e1932c66f4b31776c0f6a595cfa2df9f2451d89013df9ba20243a4c8f03e71c1078bdbfb478ad58f36545100e47be5b24344cf9865ed7db96ce14ad4dc23c7863298bcde4c8e36cb18ae6c16c2549537dd398e6c8fcf52f01b3f3e783045adfc73773c49588f3605cae4ca91f306e0eb927fd9f2e038386f316b04afba617517288db6ac2bc07766b17a995424850ae3010ec6dcb0373b3357d4f712a67bf04c9c13184f482b07c372a01967d1046b6263553ee33a883a459ff287a505ff08438c458e80f244d38d6605127e6c6f1ee4f225d6bedf8eda2ce0d74d9a07a8572227714259dc090c1ca457c411496d3ec94e664acb844d84a6d5508f75e5e585c6a53590addb7d5c74bd6dcfe7668001a313d842c7af03d7f5358e645a2a10f46a22799250c3bdc061477129ea28a66d5c8cfc13313a640e12c8ca2a224187b70eee219b44f495e54897109253be1aa964238fe2f0a42bdc34e4fb257e6def1216f1caab46e5e4493daaf35d10fec252946d8befe5f5fa1738115b8a06271038f3d107a33ef3e4b6935a8388fddf1227720ef4bb88626f86d74e997dc81283bccb41977e1b5ef270253f4c6294e91e442a5e4bd3c5d4653596a78ccf3d8fb1283edec3e350a6c31f360b16951e12563665b0d4bbc2dae468715de4b90cc3a15b950ea967fd23c93e707cec19a8b29fd49a631ec2ab48e55f92a4a9fc6afb89cb36ad31f0ee4f3cb500dbd5230e552951a6aa800f57a600d3a4468983d57e214c239d4e5bfff664a0d2da1168c8c0cb5499e9a37e740e679f5828b90f015da0072637a0a37a7a8035cc89888de0d5ee988ae24f63c647d8ba42e7ca4dbffea4a59a6e55ffb306963045e0079cfcc47553b056005825e8e14885d70ff70f047c3b5d8702fa23688d052453cedcfc1d5daeeed2a47acc9fad2c33b7f1df15cea018dc7bcb6e53bef113d5532af79afd740df58320d4e1aa0d733f6d8ab714aa459ae44827a8227998977d8d7409c5e8fbf4e4199ef050c1368103d4020a36c5dfc0cdb6f06c8d2cefc6024060b25998f4b807c23e5ba9ea6ae0aa08bc86fa4e9e543da9e22af8c090c434c6b80e8d33b93983f1972723baccf9f0aaae5e4b3c909b0d3098ac501baf9d2283cace75b6facf7f8cfe5254cb5fbfce20c2bc2314be0d13ddffb93d5a4896a0cc42c9af2981c32c5698af6dcd0c15f0a1f8db999fed9ef264aaa16d52630e3cc916206b1f182745375283a8e7a036e9d7ada93ff1e3aaeab21af225272a462aaf67f7a55c306613e4e51eeee6e15de508ee1a7835abd7d33601170c2c4343bed23e80ca8cb6fbb01b05940951388b092a66cb1b8ab5d612abf8d7509687f241c87274f2a256d741eb34f881a7dd991f3d25060b7bfd1ff6dcdd217db51f8d72b0b559e86ce094deff061acb919f29f7f0937afa563d9ca67cc9a65aa7fe98edb518ba49434637057ecd7fe6d415cffca3518416115b8b67d6a8c86c6eb6b73619717d5a2c1b07e81ccef91c951cea5a9b3705d0392dbb06223d654fc0b7e3c41410ddcc2ceb9ab696ead5f62ddc18a051679c23fc4ce921e23a4ded7cd76cede03be30891e17c0bdcab3ba06ef28cead9d349615f21893f73c291ee39e7bfed156f95a7f45f8944600af987db92fae205d578e1d9ef7161cad2fcc94a7ba5baa60fc1dba6b46c66f34795c1fd375eed29e30b0b96458c91ea1543dd643f5aa8779cb754732312d145828ea7009917f30d7865de9419586063a494af350e35531a2a52a6c9b7c6691f8a8c43c64385a9af2e08368f276d97497dab28bbe5bd1587f9fb80d5d1e0c971c3b318b479facac683609a4e31439ef689c92292bf6448cbaf33498f234d44c2dda8745be9cad8bfa26e542a738861c64216d74d1db936207a8fbfd0c6247ea8d91c688bd0547f3aabc0dd026d86db22ea7f0473ca0d9609e253d43ae0da5acc9b33af5cf641a0cfa4ef51e6462de8bda8c0a1bed0055e6b0ffdb137c780353c95ecbf09bc74aac476cd098eb0116598609a48aeca99ada133d4dbfab9676a79c950fe72ea27d7b5b1c5f8e1bda661f70a0884d84a63dba242fb3305935b6e1cc283445809fc35c63188911dbbea8dff21c3882691532536e41e45e3ed3b823e4846d9574a42db83395dec8972785d2f930dc9264e54b3bd91cf5ba264e5963ece5a64268bd1eb040ca08764a0441880f918a9047db785fd07b05ad27dd55054d407eda3f79d1e50703cc74ab6444eed6b03f91b437db6afe1dc9c926e3baaf626ac44f85879c5acaf6271a65076c348d86cf30a448efded7db9bacf8e17e149a91cbc804c7893bbf72ed4aa4b3e7b5804604e61f42600f75fd5ed5cab9f63779b73ee512cdc0d368f1fa40f0d4cfef82c7197014a552fa3ea1b9fb02621dbaa46021547e4064dd6aff83b55ad4a5b3fab8526b2191ef6915c415c31c8353cf1d900eae3be0760abebc269f09fd9d48d82ecc46f75c17cd27258e67428284a52f20fef9d182dd63369b35f53c3764538925456c44b587e3a3b6ceebf9ec279fac76ed03b64a64eb9f66d68f5e27908d78066d924c9007cb491f59c63b353e7f4ca42b81e02d28af4c29f409be704ccc4b39570c426e7c5e031510fc2225b30c55634e49e2a3ec1ee5edcf857f0977d615f7cbe24a6fe2672a4bbf81efa9be1fe92e53ef501fbd2828d8dac361283d31c14ba0493a5f2b7044260cbea7bbf6d9347fb9404db3792a5a98b0503a7fe20d2ee831953c95e971f58fa8981467282e2fc7c5a4a1b94cbed8fcea463704e197da577f39c675e896077c3b94fed533a90162f2b2412645bb3f52bb3032b12efc9db7aee892bd867f6ccc119d2b22da9388fe8428e0903d2ffa0e1f9743042c57ad98a8d5ef8d06a4dc078ffea110aa41ed4be1574a48fe185fdc3aa4d4d7215c686ab620855859b2351100fe52227aef82946010035bc87070874641e8f8437be7c23263cbadf2a6cf793587c58a442db71e8022b8cd37061b19f68cbb065bb886563f35eaf952e44eceec6a331b2e340f1929b35b12a8e2978f3dff38ba649f7bcf3af9d7d89c0d53101840f1113ecba6a5c7ca412a17b58cfa237a4faf7355c3b4939464bc10829c29721dd1ab34b7e067c0d5ee7ba3eecd030344fdad04e0363824603bbf8513cfba648534bb89702a6efd728339bd66b70a35cd457c81b0fc0e972987f27b2fdd8b5f638de7cc5b7ce55b34944373868e1c17b5f92bf8c5f94a83c35ec2d06d81f2a5ddbaf7af5e77c18351073d35cc4ce153309ddd82d348a14aaa9499d5ac6197cb43c731368ef5c68353a3faa4856a5e467c082d154e18eb039386175bb271f5f474f9e758972ecf50855afaf9e861598ede23137d0afab38fb6bdb4d612b2b868731e8592fff1c5f94abfe817e86b87eb4e48ec1eea4a8186b703e433930610bb0273635a3844446a2df8b2153435521b9243afb498900e70096320c8527543883a9e897a2f3556ad4a3a543bf363cbc969710a0ba89654c156a46c22b6d7c7093f3caefa12be93d37b34aabc59f0c2b6c7508b6b497685cf891ad2c780135db93fb2a0c49a3b7361c26b2a2972de96740b1b24959ef5d4940f895b6b59ea8ba4513eae2d593731ef5a3878e94187fe65324fa1fc121efd3b6177750ca341b7bbcab9bccde6ed630a50c1d441547ee7a8b20727b9827cdf70669cba16c09f98a93a45ec3b515ed586a82272e6082be2bb10a5080a9650d8b535e676af97128f2030d0b332aa450c56d386a1b6a264914f85b119fb2b1ed84c284ca28fbe80fb2d2d0c669480268f312b920548be5f0f5ec892ff17be50b9b5adf79bb98bd1f7a701733fe4ec598d4afee09851d367ce6487c189ecd56a1722a682159d865380f892c0b2befa4e7aab6edb1656ed27e2960501577b6a34a38d8a1393338673d45ffd62b54dfb7b6a351ead6a408bc4cfdf3fa29e67e200b9b2c0fcd3609d0205a317b10c8ace167ced4839062be82fe755b88b4f13bf61f50df0f36a7c75d1b098ec1e777083e307d66aaf33b1a2f9121304d8f415914a686bace2f73312f56cb28701ec10c717334d21e19cb742d34eae49a5bda69a3a331841a13730c7369f8a6a3d1dd544291e6cb682030a19908869a2acd704680004dd280fdcdbeb86df95802bbacd088fced0bc787266d4f9d70e9e331af9595101c5e902e28c8230e056d36bffec6b59579ecf94db234c3aa613c287f0d8e61183b86a9442b46d566a2961f559420f316d9ea0c794e40cba591a163cee7e8433d093ab6379842bd4037333dd130e27fb149d28da96a3221f99397e11941ac1707b3dd8f25d8cbe681f33f71e0ad5d3ca80274c94362c04f0fca2158e7be1e855941c2e52d26aeeeb29bf41a97516ca41b73c56a98b5c506bd35e0506865648ace089e118bf6d102948d2cbdd3924e98e6288ceacaefa0471692b1078d254fd088d5bdc678828cab09162d08fede2373786c96cab42b309aa5e77bdf88e53a84f56eebf2a17a02385ee0d8c9ba6d290d0701a5a62c88c6dab3a6884f9241a1834dd99ffa976c3ef21775578fdc2aea8bbc1daf316149d765ca7c896a601105688f0997b29fbe672320d843fb16e7da77cb45ff460b68796ba1983a4b9fbaf3a801116e77c651bfbac36f2cd17c9afad8675e8eeeab083d9f4a7be6047329f81e02ea2c02710c44e7d8b37592612c85e1d9adb0ea8a0c2aa4a7a715114f3b8d06bb60fd64396bcd3aafa121c90577893b74986fcaf2ffed5d46f6f8c623e5e705719ba3b47c09833152748ece9b7d56718bca086bcbcc3b626c8bc620e60ce4ea46ebc895e40cd7a24b8790a317cbfa42c62b8f811b4f6bee63a03cdb2bf31acf02cd29d955c09c38c88cf62029a2761467c8165777306b17deee6dabb1d9e0d8a2ffbbdac318db57257e836b94d431c3b9010a66cf997b5607c8512aa5455d4b75196ec27802a5a6cbb3d65e6a0a591c2fa3d28ada1a8f38e0ee747f0c4fb45fab3ec24410adbcd8e60a343f0cb15e8c29f42ae384695dfb41209ed129d317f8a8cd306d54e00798c63537b0c129abca5584a342569776ce9a894cab82cfaa1e1ec3728881891fdc107ab16f8933ae5c8e1ad2ceb0163a336f74a0985545763728743108f8e80d567c4ce248e413c859e5e5700c32d170322ddecca166af3ed474e92675ea4b32be43843ffaa08f51d394338e9eaaa2c45fcf3d530e2957944f561f6ab6467b2a2c0681be44eb0a28d5f2cad02f6d470682d7d7039e73f81bc4e77f479cba3667c5fe5c36c6d6d572816edbb2b2f1ed8243dec596d9d2cc4e88668d1a30a6d306d75b9f668bf6159209271ef1a3e4223d2cd565d607c4eb4c0f2bf3e8bf1390da11ee91bc46de07414544020959d18dd3b1b9c45f0fadf86031be3609c68a85ccd6a68fcfb8cbaf2a347d9c4f00e57ec679aaef25b6978a2c6c896041e600fd85a6d6386cd1750ddc4421c0e74","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
