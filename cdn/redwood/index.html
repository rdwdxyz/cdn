<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3e68dd28f61b05f3aaa41cb786d9772d8f6f9d270e4a624f6c7c6e3570cb26912f5be68274296d867e6525a4dee1b9067ec67c56c51b9a0631a380bb5fba7b084e3945995e97de57bf002fb7dc3d08471ff08981471926dd56ac19569feb3e065d9cb2c73ea61098c872358ed6ec02e366d505183d3a4336022fe362fd0cb0bd4150d712e63a1cf8085519934dedbb72ec90c7a879656871137ab3dd0157de9a439bcc5d31d7ea3abdb815bc407332cfb43ab161b2ac8c3f6152317ab44f929d7a7a79b46ba790ba01ed6b9ec3e128c3813de89d7892880644dc45035e58d3a1f2ce8f782fd3559d8edf0e3a16267969097b14f9d799e658da1b600ebed34c88c9c767e97e8df0ff679255367bd6de5b16f61dc8cc0a87cc34c5e567f98e2808f8b0658d7a87c281dd463e36a5438250837ed6f2455606f7e84312ff988fdcb19696510a277870b245d7bb454e5dd97c838f1c37eee1f4b7d679de6430d4753a5a8f00bc0a8d083d872d60eef5164546e9adac95c4abb2bd755b04b2636a142785465ee2b4a585db0ad8660c22cbdea0ba85f4b35df4c5cb4d352bcadddefb879db4b296cb19f7eda050a34ebbc42ab7c1a1fddfeddd47ca34344fafeb8b4a263cc0080c6fca10131b37bbb2adefdfe83a3bcb08d4e24f6adddc994a259a0b44f5d613e33548fa817400558798bbd887545971dbbfcaa08ee7c5c28a18630798a9f34c40424984dc3d500f3ca84460084186a7945c0d720c6745489bd691e25dda5a5adcf06d93e991b114c1126bb68aa216cd30748f0185a12e4a8bdc7aa1b0c31241c454e21ce0aa3cdb92a042463820f4e112c194c5e6d6e7f6786afde3a1770add68150884574905fef0634431b1e14d8f73a139f5e5eb3ca0dd8eb17b0c17bdd829060d572ad787e63e254ad5bc4f9b1fe45fda205ff7162b6d3e94a63365f0b9a60b0e98078dcd1b20175126ddcd5d4c489540c6fa7e9e515a32669856ff0a32870a5d0cfa718bc6d172e4494fffaf84a08020f9b7d2ccec563a12d6b34f5e8a8537da7eeff77d53b7a29db5e4622ab762c7a2bb47f306edc0ecbbe01e9d20b657ddf079ea7eaf07ff8cabdfb6078adca6afff1b255c9a0856acecd6a6a13327b3b5a8778e6665f3f9562e8fac80c707d5b37577284bdfa57c4eabe17bcee8fa71783fefe499edf71eca6273818c516d1878d72b6a14edeb3282e7997ee8f60e899e8443ca0f353cbd50fcb7cb3b73b5683b9bacff71eaf8818761a9aa2253abb974f48340701ac63930074475d2fa798ccc2255fd9fff36487b16bd78c0fd000a4d306fabd7a9953fdbc4adc464a77fde43c0b1d1fe68e134e1d757ae3f10590bd077c171c24043dcaf40f16f7dabb8121a43bba71f835718cafddd5c85a44c6643178611b36f7716049d97dcd2edfc2d8db762349d098aa2f89d6e1f1859bdcba28e15483f61a7975f7046946d4cadb784a1d831c2f432be813ffffd13aa3b6f1378eadd06a34a3eb37e00aad44825b8ef2ea5e70fecbbdf83084ff25d400f7aa194b043fb8da9e7c2f6d35f478456fb3a72299ca0077d8f80f58a1d2f853624cb4c1b104629cf94b553ae1ed09d7100af9521027d931e8d2a5286791013a6e5bee539b73736ca42348a62553295d92d9cd0390f8c8df33ffc4e8fbbbfe796386845d53c44947c376d3bcf561a148267c09659b5d449142c8f53de98a37295f573daf09fcf675ea2cf45142b94b5072692246a932e3d39da1e469bec5597e2c19a2ade6d41bdf1d5bf9d2d9b7ba0f9d5b57b2b9b39caa6e860134e0bdf24a03bcb502203dc2619af398f95c366e4ef19c3dee70e0e339f09edc9142a1ff397518b0b2177d8baaf64db2bab77cb968a1458ca0558bc96f9016a6387f98297ec48885c11beca379a4a19832ae0b3bb32dae4c78f5ac14d22568dd72273d6d5c8557c94374c7b52992e2fe364fd0cc0a6cc31982ea08b748a3383e91691ccf38bff71da81d1b7d5f3755f978d732f5904c27cfadcb275e9001e6fb7e6280dae3df9e1ddaa04e0c4880b0f3d12d01953f51e24094695d4f8bd50d47739efcd85a4ce6a1d9f444234c07cded292d1640d0524e1b02a63c41c046e0b9cf61a5d3fdce99d4cc1e1266fb4ce9bb2186e2177f04c220525a4881bf1e5d4d80a36673cfe9c9922627e5b57025f47d5d22a7ed7aebc8cc9e24e9ba46ddb8d60a370d0ea5f32cae678ed2abea4be07c0c4f3357b9497c2ac679e850c5537a5fca6c1c2785f9168a733c3b6c3f2b868b6df6af1c215a62bc42f4d9e5d7790d9d6398f2447d0c59d5ee5d98cc2f5a605e4eaeafefa598ef0816cb42f030dd40e9b2c6dc4f55382d22c3d12d1ea4af65f860503b62fdb8669b32e7bbcf67dcd3e576b32577b9e034de8434225b435885cb798979f3d519be8036521020b0d9fb2c4e86cb5ce0b47b033d34d1a33023cbac4d62c99aaef5150b0046ddc02117a43e1244ac38263f305bcf50b4a664b33e5b5a6d36e8cfbe6afe36f89fc8f0342eb9957ff3c211aeda5bc7c3dce3b185ef67474586f2a8b941df0b9d35e20e3cb0c6b2314832d51314996ff40a3e908ed27e297cebcb2d3e93ba81286d4feecc1f66c8ecd94b11137c70ea92b08253009aefe9a83b4ee2c03cd3cdba83f5c72a26d3e11dd53698f56811579bef4f34b9fa21493fcefc989be58523141fb7e1bc9a1a3fca3be49a26cae8e008fd9c6944a96226d59338efffc42e91762cd97ff5d8ea41d9940fdf54b1ab7aa0c72421f40c131e1416341e61fcda9fbea156efb977fd4945f7f00334e02bf31599a911a21c2fb89e9ebf5101609ee841bdb575db15fc2530c0dd9a8f3f3ddb2555f09ac03b11a4bb73df95933290fa7ebb8d4bc0bec41d7e2bd96ff0f23c7aff1a0487079597e60dcb48e4a7fbcd01fef3895d2c76cda89f3d9eaedd23dfb07bb40a5eb8ba6c9babbe8c77f97d5d01641470552ee5a6d2b56894052fb2b36237ee357c20e86d996fb8689fb3a787d01b61c18ffbf1ca37491e0409549573dcb847d8111c04e11bab17c5914759fa4a8a8e6634abc664e26ba3aa47d371f72665eb09ce7d7520eeaa5c2d694c3606b17ac5b2d3c352d070f4efc33c0128657c697b1207336ed3d245222bc917fc7c06dc33cf75e53cbfc43544848ec7351aafd975d7139d0883cf2de280e469ab1a7eea0d89018edde2f83d31f4df1e442cbfa71b06b1c5ac12db33fa07fca7730496b7d64f38b9e6fa8291a70ca9f96f09623d70aaef926d3b5d0f5faa085da3d061ba1a5c6c41971c1f545037d8553ecff9efeae72f45cb3ced30fc5541778623d2e6b1717b40e44b820c2bf5e0f44e7ce7615b2616b0c7852610a3be09d970fe46252bee3e6f7dbbd17009479606f389efb3a240e65d920b5fb7bff6745ac72920a2bb403890477b17374bab51bec7e692079138561653d08299989fc5c08c58e7d03fa286a1c104bdbf1e18ffa9b2fc7e9ae77ca2e5b40fe0342587a8f183ae2c1cc6b8b20b6ad6a5b3a13ab903fa43ddca953135e0610a2fcd137568a77f21956e6af2e718537900a6e83f3de393a3cc9851d46aff2ab407217aa0fd16f57ceccbaa604301f246e4407027ed5870437c651f0bec21cf20ede5228592ba5da6b46818357b5dd83a27b635091cd417cb5f70515c63ec0b88175c93c950cf66141282199ba228314a6f8e0d60d567107e350f5cca7316a6a7d874940207ad33cc66b6b9c1facae3db13f1e88746dd7e62dec0b236597d78b24efbe23e2fae17a0f19852ddfdd66d3ffc02b41f2670b16efe3a8faab0be81a1ca71704c3d818a1a3a6550133ea2c7c58d9b1b9f5b2e55c8b7810446be5fcd2ce088d467ceca8f25675d0f728729fa3ad9469c18289d9be714cd570edafd6bd2474bdcbbcbdc26cdfbec8c7bfbc921a03197373d46531c3ac5140c5b582b68a9546d8e4386dd36e03330c76b1bf1e4e848cfcbc6fbdda0701a2202d6852db183daa70afc289718185973518b18c02f174f04db546e389332881bf8af58da5819a02716231d75efc54ce19244b61163e698980d987d3a872ec1758f445000a2c9be735413f8faf4401df89fbb5a4f600bea72cac2ff99bd190b27936d6d439a5e89a1a6363857985de6b1c53c4c34d1ed270b323683f4aaef06c0c970bb964912a3cbb68c3d9e47b43235bdd6a3681422cf0b368ccc8d87c9c9c64307d437db8ddf2a855ca35f8128127aac8a6749e14f2bac4387759d38b50b0ef956c9a2d5f76e2f3fda046f33f114c198a40ae6a1100b770e2003584b1191964d6d3d705ecf2c582615b616dc9819c49500a8cd2bc3d0dcf4343f7f4f4e6744c4f5aab7b4431d7be76691bdac5e76750af6cf2b8db968d1fd4963fddef8dc33200d9c12ac693b903ce8b8f1d37f4f30b9803b0331a2b229ee785a78b2503ba565fc2a5f70d4de0d083eb134e93eb2de1d60c910d64c7b432cdfd589faa3504be670e6cde4185ba6281f70fe290565eb788bef5ab66d845800f5d2befe7d89eb2d8d394ea731333f09a32a015f8c9eca9ef65007a9c061a54aed4f0933cfd110deceb99c304ef4c9fc18429bcad5d70a53e3f188a1c9eccb0c325d69646d71f84c646ce803e8096c0adc49c25937cddeb63fd2f723bd411728cb325158ac21bd450c1cae56bc0368b650e40f35f76f587f1f6c18d62b1fa8acee703fee0feaff1319467fed99ee14f90cdf5d1ab9d3604375687dc54ffc49a402bf8243ddb98dd109a036a5f20f7dc43a2170784ba2b5ddd7dbaeead04f473759a45a163df36c28e26347e790eee9899c24d8416815b704f3516b8aa956a17de4cddd541b3990020bac8486e3219bea68d73c3310885e2c1c73d31d5b39b911aa10fda81e310ae5656b7ec33d4d0d56684f1c1cd6af06f5387362ba49d378f2bfe594f128a1950b4e24ff01341e91d0d38565450b466090a485eb3b61412f20c62200dd866f51ea63b49874cece64c56a7d673f3868c2a56e18f0992b76b3a3dbc0af2840db32d21b69ac3ddfebf6340b769d6cb447016112f0952425cb911639e8ab774fb9d6849aaae9458d5485d7a0ead753af1eaa2dacf84ee46dfd1a41d25f738ee0ba59550dabd1c047201bb7d3b6572d759ac6ac45e79d8ba45a76824764d40a5c16c883ceabd8e74cf736dcbfdccb0e3b754de6333071987f959f35227b25cde60c5a6bc055dba3456b491afd7c300006e26b2655b027de355df23929187ddf048a4eace0f03736f5f0cacb64b90ff9b86c0aa6559766ac540ab4b4ea9573ff35c72f5e06c23c56c750c92d5c72e439cc1306b1415967d7d9a5d7eff2bbbec451763eb0a5733fd1349709f9298c2dea726d2352f86875ba54daf2ab6ae26941ab3776a86882ed6954f5649c9cfa88d0d7923c06c4bdb530302897fc3d195a074d634588ed1f2a29305bba3bcd5e3bbe98285694469968da7281295a6ac62b6b15e48e72d4cee133219cd67717b604244cebe6d4e20a0dfc99fcc429edc2046301c16ba158a90a7a6ff5e9d0e8f851ce54019ccdcd7fc5195c2442eb3893703ed077f4111e71b4d2d58c1cd41f34d253cdadb1de0e8a0c1ddca966910b98b8dbd05f5c00bcd85cb6fe30c7ecda34b5d48685906f423ffa9e86b2eafecfcf74c2194873586e6d4daa6bcde6ec475d3cbb79c48d94282eb3171ab25cd17b76f4208edea08e8e7663f572e22ea567255b83cc21cc04434bfca6a481628391fcff70a96278f0f22c3d4cbace26c9de2e57f6c945480d929c43609227f6ec6e7c4a6785641249e88615ae8860ed4b4ab948cc9fe3bd2fb6c9810a9c5bd0dd849273a2355c956fd7348891f035d22af43ec4fb72e28917655d339d0cdc7938dd08766a62042bef3db23f4dd53006873c3cdd5f8e7b9e374c2146493ede82b6654eb44381f4b776c356e25009181d246aca449989be1a650b41c90592f596d4e5fe1b4796ec5964f19633a9c192bcc79de0185894d2c30bbf5421248068f36d88145058a60e9118c8d1cff47ea4c1cbd197311f05e24f2c44e5b1e3055d7515ca97b61e9440e1a6384c55d848fd8cd694b451e5a180b9253f85ad91fbda1eef80d838cde4b3e542020d1be633e82d28838388c6d3092a2da4d4ca426a22a774e2c0bd8b0dc948482e2c41dcf4f4362751295323945050ee7fe53fdd7d23e202d4c005cad0c64b9bb2e5b02de47de867174a605a013788bf04d428be966f10181c8a08dcf9242ff21459870205d9d5441e670a138051646a15f62142786c0c5dcbdcfb5e2b7ad64ac09f1fc6f1da9a3313a018c2ea0568ddba260d5b362f0fa3dbacb54d2a8f2725d0c181a5d07fa7fd69a166412786f05de4bfe8bab2c0cc630a2ca936168d7c4f70170f1c13450e761a1fdd09330f4040b9d56e35c1d2ab00a1ce5143a3ed37950bd960aa72bb07cca667aab1fd1c3a13ba1da0e34f67f7c9de775a6baf41c08a3baa6f16b64e0a56bd50b4cf80f0976c1a88443bd202098c7a740dd5573fd3c69ab9845e81a8afd3a7814192296726f54c9d08139181d8b5b49115b889cd7657ebc94c5990b335c6be2f966b478a63f2c0884a787bfc21647d7e949b9258bd9477cc92de13aff2890273fb76908830deee64ed7ef8835b5ca9f778d156d453eb24d8b427ebc97653f516682f6e5a586ff9dc0f26626411f455ebb91211debbf9209cbd2fa7c9b09aff7a7b461f7925ba7d5e157e1b0ae0cf3392f1fcc30a77cfc80d82a1527cb1407b626a1e1c6121192363f2954e90c6e438ea96c4d233cab37c893d98c837735d687dad794631205738c430ab50606c72d6cf5e6236fddb6eca7038d5b0f69224e17ff5c98233105b4a07e2125a4002102890e20f67f205bdc9a595d51f9c6e8899ffd9ae418f5fc6e27513f7a80b4b3060f50b35636da1404103c818bdf6366fd7ad25c120f0da202193f882c86dec9121b581adb9964fc2ffbdaa32419ad7a1a0e82500a6fbe75cd2716488c18324d7b50a37b270cbe996905dda78625bc2faf9ffea050a96654fd78e6854d96ffdeecdd77d3929a9af2092207f6f2f80892323d31ee32eab4e689cef325cffb9ffd06f329776549cfe6910bffb8f292394ca0699ac8c8fb887baaf0fb2ee20cea7e234ae18b90a6cb3b90a6db6bead906d088f6555aaaa43d8f00d4fff9706deb34b1368c4c0519453edc19398cba8e32ac3a562a9f8e367084d45828feee76bec94a9f09b2abb2430522e1fe15e8b80f020172b11ea3142bb3ef5158e16aa1dc7222f46edfb33164eead8a4fb23cb642615464790fb3f72d98247b614dd1b94ff320c45144bf7caba5cd541fcde514761cad1498c457753af0e1a2973d7539d6d82370920ff2b956d70fa8c0aa7c402d5552f2f4da9f2eea318e19b062991b99a26e171fe809833c2eb5ae96483b95e24c711a6ea43d424d0c774ff33353ea32c77546dc177d63452b8f1854237b72010c14a90dc29c477f37bc24499991d1faf465f21be2bf4055892119d364df0db04dd52205691795db699f5876619d8c73a375db1b83a15db8ef856f159eabc2a6c15c12bd3e0c3e475fee5c483940f2c53d6dcd77daf869937992dd84bbd27c81e3def2ac21a1a2c4a540ebf6dd625430482e7f7bb10ab7da751b031e6d4e5e17a02ae0f383107761e8094016e3e9cb251b3ad6a49bc5ff571e360b5ca94e4efeb247a582b210f7551ab4713884aee49217b1439ae6fd47cee093bcb71375b17ad6ebe9fe55da23e6d50b73b5b96df193a9754a80b7a356bd4a07f3bf781033e14cc14d4f7635fc14e707a837fa249580db08a77a98ea62743a21a7b314a3bca76cd25459ccd978b11486887c47636fff882df2a20f169fd56ac0591db0dc1263a0e6783d1f766f366dc539a5fa4cabe753f697a91127dbb217ff4062370bab8e4c6a6ce484a592bab7ebe7a2625496c48e2c9437f0a48a997c2a01a27d717077ef81ad6181bdc35b58b229ee51ea314dd1a3c506765097bab16176081ac8f7955adba59e4ca8909b755f47a5d42fccd5dc1b80efbbefccb79e3865cace33c8619b54e6bcc18d0f04a9b5f37241d8570d46778a35a00db48f5f5f6a5dcc8e8c9c0e90fc4193000a11e476f6893354b0da8c063d3b81d121c0921b49627724daa03d5d69ad557f863d2a17775c81772d7ecbd3d48e939100c40776d9f48dd7cccdd2dd75ce1ccb98d21a7660ec20a2d8b9851e3ee068b96215279a789bac299ab82f7259c5022052cd708f393f212382de820abaa87900a60471d495a5a2126471e8a4cfd1145b44a0671789a9605191e9fdb8bd09d2968382050830f7b6f8aa70f51853f3786d169763039537c370b6e596a68af58752c0c5809e6ce8fd952ca60e170180f05899588e92628860b7444c05a30df6b60d24d2f86901314a65b1d8d54be1c2eb71304e51a0891cc1856409402451f44d236c54bf9befce237b7dc9ca8cc30ff3b536b6f02a2221eaf8063d3087fba194923715293d1fedd975ff3936e8d5e0dd6262e8f836e915d6070ecbdbc533f7517259e359f92c9dae8620f0ff307ebc2dd3c3bef97916c7ed3419ba1ca2566b3a76b670913ce62eb5eed571e698e446720f16bd5bbc3d6e360754bc0d5f44d38b2bc0bc3ca9106bcd65255ce2c4b9942eda03bcb7a62c18f70a9a35ee0b61352b3aea5ed58460bd31a7df66a8f39096b138a08a117d3d83f26969976318a0e373fa430f82c589a0ad17d8308e4b115230f4ada06e454dccd2a2fe644ff4aeb2cfb5e76d870ff59a29e6d58faeb7f51eae99fc925cb47e02624fa2c45c9da1cbd97141aefd81c253472f600769e71108b61ceb86d9dabf1b63bb5d5636a5bb8d31b283bea08b8c873ac1f30814156f4baa027872aa27e51231d0f25545b610645275f21ccf0ccedac0dfe9cd14feb139aa5217845e98444bd09a87bd2644bf7f318a80bc87c634519c2ee03b2a8a561a77bef0be4eee9a08d94f9ef56d047d9b26d560397280aac8bd784c4babf9a615ba037263f39919188ea76914f86172b466adec2e5bbd7c0861e35e98559895b9b5cc8e889cc8390cbcba93c0bdf75fc4e034aa8b46478f5c9af3dc1b94b8d3aa8779e9e97d320bd7b2df3549ea6390364361da68e5d6b48611ba001181431b9571819f1ff446bd2007d930513f0d5218683c701ce0c5b8783261414880628c6d1e96cababac4a003ae53849a0e4e694c11ae090806da42bbac66595c80fa8dbad966e4f13582919d5d7834e25bfa6e4f25f9bc55c8faafecd3853cf76c8b70b5df2c285add5359a8265f45cdce1c34b4518e63e9b171f70341abc4a8b0852c0d83a08b07cdb82374d15dc7374951fe7e0c45c20e04d6107aaaa2dea4e171de9d3bffcd9a89fa28e805f20fc7ce5012325fbfbb62be267f418bcef5186a91e07f5e2213ad16676b45ec4c0529d394c809be07e46718a07b29d703a52380116b785524edf392d1c9aa114c14be8204193a4a0f3a00da640012cf19c6d4c23359650e904e00f141bfc759ae84f7da0a7522604ad0c08f06470b24ea282ca707f0b4c2dd0041f32ced911a1e5c49318545c57d6bfb15d6dec1dbb94711fce5628cdc18f7117c7b01ad62b7471fa3762ea49d8d92a12039e675ea7acc317dc7a1ad1f435d5a4237736197d65388594f6a6f4f3b816f44ca3ad559e65267e69c056018a81e6c88cff34f26eb05da2a9e9d96195dc2f6130e6f5a46fa3f7543b5f9420e1a6ce49c6db29d86911ed4988bc9689be6a49bd59abcdb5f2136349b7e0cc753a8c288a4a938843d154746316a8950013643516c507782c4fac6d78009fc71687a6288aabdc03c62f07fb99bcbb0bae58b5cb4d5cb9912288f691f0b9599f6297265b3f92892f68eea41cdbcb9c941421946e9188a953e563a5c975ca3f3499d99656f4dd1e7eb28f1b150676031cf2536801dda091147c5695012a23e38de43d804f7ba1e3cd75dcc97a799ff2729485e5e36483ddc61caee7d6758be25dbed92eb6f785e8cff0b55f9727497795c976a68fa95075bccdf0057b3d27e41944420818548811cf0ebb49090c9dfe184bfa06b6d986b10b42b28c64eef151c6abd816edb6eabbbceba9092571b70a0bff35d9b13607d94dbb74124d5efabcf292839577e7ddc72b4250cd7e3e5e48caa225a2b2abe6b6dd221214ab2349e36cc4102ef45aa2262837df5796a646f76aada759c076da7174d962b7becb9858a688a9f8685ee6fb604f598bb8425e791954330f4b00f2a7c3929ca5dacfd5eca918e727de6fc9eeb99c6e599d6ffa1aa99a9b51f46025935b18c341e04d80d44f963aa973baffa5b57b240c34c507ea13ce6ac2d6d9838153a3a4bb564154704e97c752debfd49410724c0d43ca26bb414159f83e11b4f9afd5485c8fd7d7bef3e70ffbd340f5792373b4104ba5ff342b52208f36b16b22dc5d0bf7f3b713edef51fcc3ba8a72fe593bea13ddd4a1a9e9e5ff2b2c5bf72b82bcfdccf4dd29f218672a672c98416994bb902c4f9ff40bf5a9b7f798fc7a05876eae3377edac2626d6599078eecf23d51a6161e3cec804e638d4a703e4c6fec5ee709330a6f92b2171d8bb507f4ee2de081e56f38f3f5d7c772aaa0658cf1e3d685ebdee827b32ee4d51cae7dc9c465da0715099db380bc8feb84bd8ad23b041fcc024ef6927a6d662fab4440f27b819a09f5787cdc187503ff33334406dbefa6948a5d477971f198ac1bcf57569d38b0ef29145529195ce199bb78c1190ca02ac0524af35c14342fdd9a166339ad76abbf1f40c1b2cb9d4aa1d90b55368ad3301cda53c6646869c1ccee4d048dfd54bb1e04f7d44d3a21df7d9a67b1c436de40ad7670dfd3f8a36c4d96e962d14d289fe05f5a5b4406f19595e9d0989712da33b85aad3582944e92fe175352517f2cfa621c3b5d600a3fa2a85d57ca8e947b2c49e468ebef8dd4e858b87241edc35bc5b72a7c27928698521dcf6aa7b3880c96c437f076bd753d651f7205cd9a320bf98485a5636c0665c55942fb78ef580295675ca5df9598ad117956b156e9cad42773dc27f9ed03e94fc4f78daed7f78f2d8e6cfe380e2fe27aee3261009f2b61c56941a92a2bb4646ed54bccedb409bad6d78891f513d937112ddd3f38cf285dc29d6505049d0028af2f8b74f544cc58735128155ac082c5d59e8998e16d10b5cb4389a162262aaabd5423edf36fb64758cd4f97a1d3f3e1484a212f88ac781ebb42968887aa422410ad5738b8bc5824d714fb169e9ba828aa5c7e88651f0dfc62095def6dfd58c027a97d897d7cdd646c57fdaf21e0f436d0b3e79d23cdcdf361437c41c01d193e44898240db8d48d6d8c216ceb782c91bd5394bfa4299d27b0ee73ae08e1a70224bb50c893d959ceae02233637cd9a9882830ca2284eb3282a6d04cdbce0efbd85382d88d94715a0e29212571aa4b2587f2011265acb4534374c037e8f868d8d5674fff4d3cbbd9ca5c8e04c62c361b7a5e3f344fa3f85e0e4a7190c68eba407149ed6cc4c77dc38e54ea7ba0143714230fdb8db5d347f6aa96c9ff52dcf184b58031d5bb2d05a78896ded6e6d8c1a3dfed4e4a35ee7ee8b5c341daa74342d231dc2c7e30157b9e0325208fd7df89fe438fda317c4d2f839e6ace09d45abc0e7df7ed4edc3d791457e2cd43298f725de0b8e391d0cca75faf03fe7313977bea6c7fede33b5b4add1f9ced5c589cae6ee5b29db39bfbbf59b19cfaa14f9c28251d22730e048b1213ffe9493c14caad540648e0b90c593455c6c7e61cab4ecc145c28e19cb777cb81c8cfd2b1af46961d547504a22ecfb781e7652ba3172c64f488a7d470780a21aeef4c5fdac13e25091403c73fab28a3d0d236bd0d747c122a7395955694928d6ad2ae12ed68ba8075e42d484a2ceb458c582da2fa86940de625d8244c9f2e291c63b599416c713afe16c24907d2e7ff5dd94f92e950893e1976b2e9b06e5526afa444df90abcfe9e4abdcfd3df47a467836ba1ddec677aff8fcf94c43b82e5a609863bfb3fcae9a5f050c6fc99e2cf2cead048d026110eb5453278cf4e1a1d7d822ef444cf0d17f2427b173d883ec73b055bd1a0a6cce6b250234b603f169c5ebe91deae662c7a48a4ef743ebbb5acfcd3a2f98c1bbe5ab20efbace60d5691889f76126d2a1e3c73ba14f0f684f75e8f85c62a7de17946755344021debde053936410693d9c455af4ad6937dde478606464ca93ff3ddc7d1473d6c4273533a5b607b7fa58986267cd5ea8b96a139c7a3b32a1df3748727f81902ff3be0eb1914c460f72e4d4a42dbdd46adf11477e34c1bcbf2dc7995caa09b3dfb68cb0770ee2b2a1fd7097ac1dfacb42716f1de9787f5f0b0da221a0a70cfc2bb2a9960afa3e914e8682a32882d2f29daf4bf05dda85a7eac1aac5d99b54024e3e4e1fc3ee20707915d35aa7b4d2d6929ab199d2044f7352f671d58de678949945f35580a463dffba30dcc03c441e81889fb0d6304e2e97daf8f4cc0589bf582bad30441228057105bc93ab349779cfc3ae8fc899fb6f2e4dea4387113ed7ff2aeddf62a4e6ec2707385f2fe85a2883bf42fc7a4c725c51935a0e8c533617bbd9372fdbbea1b7ca5f75498f9a5cfa47358eac1a29fd278757c249dc602c0859001d69e71760737b6afc178eb337757bd252379404a993e719a0dfad13fc32e51a139479158163747c72044c41d41aa2a52e2fd2bee88a0f5c574ee741c4f827ef77685a1f0f7602ac0b624a3e51095142dd044e4cc2309f05f96980da9e6066a42774f100b0785fe13e2b326588298e9285587f0fcbeba85f5cf96bafe23b2df9fcaa980a0f754d8d804328ec768f15413976a4430607e7eda72e8c1485b4dafda1ea0fca69aa9ef35654c8be43fddb5ccea4bcb866ed95122c391f338ff64c7c3bc39c8aba81c5c4c00dc8990c9688b7de41d1cdf32516969780e55b77b0dce533bf25ee5f32022b0a6ca788c5071f7ae7eb5d247c0f57e89b56fd836b0f5f2dfe33faab7a37b131f7954fa709bd49b1dc1f59e27f50f95a4fd39e95e30696d6b45436c226d959ae36e62104260d073e5160dcd9274d6d63e8d7b6a9503f7a322eb34a020981bcb243354566dff990a7e994c87695a56716475ca69143a9a5e26295c0c809ccd1f8897273064f02cfe917cc735ff7dea9d06539a3a54656c42303e80c25fdfa4dc11afe74b505671d2675e675f34fef8b926dfef740edae52e117f2decb8a4eebefd393cf6583dd3c5cda3f62cde466677bc4f14504012738d57980ee8396fb5d9d9213c09aef2b1172ff965061b733edd28431df83ec898b8f996ded7d22e4aaa0adb7a4e5eb8616bdb6f6ee763fc0ecbc9c43faa762d212c3fd7e560e44eff10c8e824fda349bbddb65323deddea297eeeb9c2eda9d501e50aacc43ae7e705d04d7d264e2b0d7fddd1b5a5078ea804dc70121b74da52ad44b7fa3e587f220d7f3548286372606cbba52d2e9a359f16c77eeda10e8d85f5741fa415733f1747f4c8e0c393e52fa4db81da5610fde487d97ac4c38a1b090e5f240cf424500adfadd60279fd3e3c6f015d763f3d75fcdf3dccc32d80add3da6bcd01c8d5ce09d035627ce55fae78aa307da93ce10fbfd4b800cbc822f19d6d3ad8b9cdaa3541bff666d23624a9845b784cd99ce024321ba686cdbd99bce63718cd85e77fbd15a772fd67bdbcb2e206774b6e9691f138383ddfe7f93f1d05687b76bf7eef346dce2c1c791ad1704af8d23ed343ef84a67ea6d981d50fb09c59e61b25f08bd7661e0a16072fbe4b02aba03444512d91590a1ad66bd8fca4bfb967ca05ad0776bc5cf1a6c4a9e72e3923770ff4508e251820e6e540976eacadfc298fb8c3a7a4ab8cd83ace3462655fccb4ae8f83845d1d8eb7e99a74502d0a614bd39a257b7c7d637f2b11803507ddaa76f41f9b83d56fbba75c34c7fdccf34d0124d34e9847a24b077be0890c43cd96b9245fcd40a6fe75055fc6bb466b222bba95b6cfbb87d12ad9213902a24930a5f43400f71987cf7b2ff25bc6b21be57b919050ee26f5ad1c501f71cd4a6f8bb2c603e57df5bddb01813669a6f569d82f60fa38be5bcc267fd8d18ee520ec380763c8856920042613dfd3a1da2da807cc134907a840231ad284fece18495d1f7c2050cd98b17a4fc97ab6fac28a8b747b0223ed548c842c7d4f627c2c8585c6c11e24a4e013e9632f98ff3dd30343feab8e58c7db1260edf19c6380d8a0159e52ae703d1b557a4cd5c28971db3f9a9ddaa0f0f32a3a79a637b8c9d3e79e781ef22d65f89def3492d386e6a167e000e11b4c49ba582de8f3a4ff88dd1212cfb67dd3d4b1ddf7a5fb4c8449944e2b630ae504cac01a5cb807bcf4bd880d9cb429994c0f8b45127e4bba9bc943dc81bcfa899629283c979deec16572a0162e4b2080d745e1f85677ed2710c8276721c41bf7666fd307cd5fe523c4683222db108052ba15c24dbd2bdcdf57b89cad114a02e2b56e3d8267eaedab5756fe2b21a9c8dc351a34816fe80cf2b5a84e658eeaa6527f1defc81735d593fd5709db37e989eee3c3505e91b5a0596004ba3442423b5ade962c6d0092c07a2b32eedc910ce277e784d4bca66f02ae26abc21f7e353f4e8d8c862c7261bd442f1b0538b194eb7cad8b43d8d467b392f867e10b09eb5ca8ffa653d881d22c89d4fcd5f38771fc789412e72089ab09a903f7d6be4832ab5253c6521dfe43143c0fec9569f092bf0b861c140711a08b7b8f16cad2e57dc0b701d9df73016e52faba0e8ac3344ee6d470944d41560edda9bca9ea808c7fdfeb006ef58a108d567a02955e0dd2e821d7f287c7cb808c04338cc78e44ddeb62a2baef51871d8ea3c44cbbbc5596ef8b213401e7db41f060e0c2bff1cb062d6eea2b13f06a7d4db1278d4aadf68a2e6bc0445f09085bdecc3655f5a948de6927583fb246a0df765a5099d542d39f066d7ceb3b66a2ca1fbd6198293b52be49b61e5efaddcc5584a3e64d526b6d135affa1f2703a235a6d25e454b6737acee688c6a4caef68d57664eddcc3b8388809341e5a165f0bb889f7940c095dafc86ad30e83d3758fbd3f68a78da1089305db247b2d31634dc502f5f600bc5f9a267f064f6a381aa38956e10fa659a8f0d67551ad914639142eda3b5e568ee19bbf41f0e962b9997cc5114eaa75f9e0ef5618ccbfb4c7f0d0283ba9f7d047da4307ee245d791db92451577a3625d7ff7ef8914a8fcca2dafbee707a51bceae0119b80e6a4ad4676df9d0aa5c0b07d54aa339209dbd2d5e387bfac4d098bff3f31dc32a72dbd8df04ca5175a3409f6cd3ab840a0d645cef9788f6cd36673bd5934516847d384fa5505416d5d1cd555c4b4cf905328ec52cb8f8a19e21b02425aaaf810cf8b7c74b671a9ad396c112fd01de364adce639d619dcce2af57c7c8722c1dea67817522a9ae2eb3e664a53d6df52dde1a9015e7053bf752b6d5f5a268c64ed4e1ee4720de2188065863fe8c32d33b5fc341b94b84b8b382035ddf3b30dab539ee573e7caad02ae69a66df9c2985c82a47d956658ba06df2936ca139404cf6f9280b3e9bcab553494870e6ab01e5035b4bbf902ed72277bb3f627855be8473c655a531e80a9aaa826c94bf247fd8d8c6802efe7a52fd6b9da2d8b64a23c00fbf4a2392d2e350e41988e2ca21a247f3938d88f7d44401bb4744fc11e79117eac8211beb64a6bb1abe43b579d4285edd7453b9518cd345f9d5bb667e0a21e7f0c0136ebd0b2b4edc5191ee92fa2e41fd5c367648db063ce92a6396fef431c09cf4d21fb60e157871b4ba6903b2c99b3deba548733aaa25a60faf16a686644fd1dab03f7fc68742988eb7caab67a426f4140f13f03813df0dd06ac740db95da2a97dda2179f8fbbe6bb3a568a2c455731a771e1a4b34de7c9d5676534e225c55aaba55f925741135daa217ef20c88beead033c4ff4c3cbba6899f0882e21e3934f754c0478225264b25156ff39c5e78299da73eb848a84bb153a5741a2a0fb8e51ff76dc6c2822fe059745e659e6de79340c99f9f445af1ea4e21eb74cab7bb781f9d9ecb1f2e2267e2c7d2ee8dac5bcac152976252886dec5e8d97b6dd2b85d491e06d5b4406720e7bbc913bcfdddea7137f1652a2120943a7f98c6643347c8b2c045b1bdd5e561f47ef86074c91e25e29aca80129d77f1bc329993af014417ceb99ba6ddeceabfe4e139fc0e5e50b070ab854ea146b95cdc565242a14242125c27c85e3cc0a28c3f3db4df9ede77cd0a2726f88268956608ab7d086ce813d7cc69649bdff5fd1a00cdf39c95f2aad13d1d58044cb7bb6cae3e832953d35fd5708df1151363794a784a658f4dee42361fa1b78075a5223d56e64cbbc812754f126bf65db9b5079008b0f93062be4b69bbbb9bc2ce4e33cf6462b7582027869837676212047d48310e70913f2f502a90c35d6e96df18bacd5ce3c01988b454c61d24b28f30f0bed97a5828e60d7d0108f925b1d2a9fc4760d579e4019a3008a4cfc30d5e31d2a99b0cc673b1a22b530faa28fea6eae99114b170ee23f915632dc5048531a7e5b49ac1fbcc2e0844177f7021d6e3ebce698c0295e78bdd335c13ad8b1314a1ebf7d52e5580829cc8fad7bbca3898924b1240c7f228ccf18105f02547203d6e03b3f49dcc79e3d9828af68f76d26094158ece58e170fceebdf278da0e4320575ecab1078885c8bc6cfea837f797a98aece08a19170ffade8477728af5ee70cc861960abe08049cbb8ddbf309f9f36772dbdb3f9ab0a696109b7b0071e780851fa0db10a88a42ed35fbf198d3dd0a6135b075b2077c46da3dc1ad45dd1e5742e2d0e46f5f16b298b21ac36831b576b00766e8fdcabe76894536b2f1caa708ebc27d62ca2632f74529e45e7a40a983e97a81f97e8cec80ee0ac3e5106dd67b16102979d3c3ab764079a2a575327984efcfccdfdb8e71eb2213ac09192cffa7ad64f5d72bc91930b05319fec9880a37b0977b5d0e5d10c52c339621e0d77e6243fea44fd1c6ff84f2a414eee8842abecae0c677909f8288b3cb00b6b11a8df5a8ad7cd2029d45d104fc64ba8990adbaa19d30495967fbb6dd32a41d1b404e75b1e27950d642b2eda58d3a5405b5c23ee19edf285fc816c4719f755877a0c9bb5ac1a9a29c5fcad9b419a485f4bbb9b2962c00ace870c7711c0153d3fdd32ddf582d66a06ca4951f2d9b3691d163249bc39fa157780b1f166f704718b65465c4ec09fe8c74b55633c7c371ea8b5249a3224c173e755a6194e68452456d531e209a70675629ac160d83a986aaf41e3815fb3104c3f14e01549b1c7a682d68b59b57b8c98c06ea10e806ee9d3f953a8f27f2d99483fcd7794f101460364a5564043419541660418df8922945c075b16321af5ba187e81bf3cb017c4efb943997fe996fe50f6fb7d5b8dc556c63d7e41be4f514fe7b42ff09551cb01344e2c0289fa6e4b1534daaed93e15b3a5504b5902823add1eb5e7d2ebc24d3060bdb6c9ceccacdb3a9cf0c719e0136958ad723a59c844df3c1759142feea72d56fbe1e5ff2ce22e92bf7066e2335b64541e2bd075b63406458a40dd94788a8f1f618460504e2fda739dd2e22566c89abeddb34786248158da50641a89aa5d7e75e658315c5c871e749b33d1f8ade72ede6b0c6dcda1dc9fb8145b4ea3efb509c4c265e9ffc4f4b58c137dbe081ac05ab02168fdbfba335dd83a829c9ca3d73e353e5d6163a4fe8eabacb8b45ad046ac1e12882ab9952681eda218798e8434244459263fce7859d57de56c73176f2afef4207242383a3b45ae2448bea853a9f94b1f29ffafc89e129f6f9084f1818de6a514180be2ddf5db8b161ff0ce5c96575714058889807c486489d55f8bf1120fbe50b2243c1f317b0c70879887fd7f2e112aa65cc235f2e2230fb2e8e2f80d2e0fb062c490b5963427be173607eefa1b72de176a6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
