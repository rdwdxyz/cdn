<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"08c02782919de4bb94d285b2bf350672844b77435c667772bd7b305d5c37100d5779f85db1adf4e4384497a04aade551e4c440a924f17e74de0ad337dab7798f25ee7f115bd695b87c13a467212a57901d997cded057517d69a07679bb5995cc2c3528b43ab9ecc8579681751974ef0f3ba571efb1e242b1d56c8d91abff4c079cc1d587116a776e05cb8780771f0b4cd9806fa9e190bb1571dc8097c84deba59217dada8dbe04cdfd450adec210e5501f0d5696e2af9f8db1b42437ef4455105a8311bcf4f67dbc1566fcc42cfb342655f3cecea4ca4fc646a7e614b5bef71c51fc77b1436948052a7d0bc91b127b842cccade8704f2ed2c0aa1a9692d08fc836ade061e8de98e3f83898417af26b8898b6f28ccac4ddf82ea669c4d02792f7bdf900c1f395885a11caa380a21e0f12121f81bf54fa05f3d62f8a4a56f54770f8f12e2c009bff577bc7d6dbe9267f1f9dfb361f0d117186d4b21c027cd879f25da584aca83dd28839d2b1308506d428c346760b42b0e9cef592e2f9ee97b58d7b29c2fd1ee768385c13c19a30a826ccd36723329bc3bf4e06fbecc703d9ef163c678f822785d682d6ea5fc43cc125755d744b2156119ffc2dde164e3e6dba79422366879f6c173a9eefe337dfdb42096e9f09a539a639eb149f2a91b2846831b95f347e281688d52f731eeef8134d8589eb6ecbf6913a015fede50ff77cd4bbb58b18f41a83c60fd8366edde4216fc98908bd9eb7604b198f6dc4b5619cc750486c0d260971388ccba92b5ae78c34fb5f71dc385547c0656c279a1784eeda86da4191eaa274df255d30b6ff0b02732c497c411fe154924376a955f38569b521490d216f8b7571bf79e67ccc1cb7ec6b65e525ac36e9af56e8d12ad35b37f1e58405760f323027b3e471b4d2d6e7c814451f0ba4d42acca336365b1d611e2ed7201532d523685381f0a34930afea107f9b1a0787479663de6a9685716718fe134e200db62e1252014ea254e2789fa805247975a2bd5e3a2c27ae3d4c7dc51832bd9e10cd6ec24d5561fc8fd05d2c28105e02da94d8c99a94c177121167df4d5f44ac4043164767052e832ef6ee87ae63bf56a9b07b5d025088591518dd322404cacea935e254074e9bcbc1dbcb6a8bc18d6d868fe31a0d7abaf1b790967e9bb0aa00dc4824228202de3f3db2f73f15adbb81a7f6cb8cfdab79d2bd9963bec760ed5eb0a02d65b86f55dc332923adfe8b0af22930589ef917ecb96d0d5d8a4918d42838447d01112dd65509910b6ba0af170cde5ebb1563515607510c47d96012392459a6f6649715880c20ec9a2ce55a61b4d9432ce1cb89bdcb34cd9458b5de41fadf9287744820571fdf730b15abc522eb016dd25a4abfb18db63e134a44623d0daeb5d47dfae5f2f4b2be29658e3ce67a2fe92784d09b2d5b625db456ce0d24df705e4070645eba298e42cb15c4ae488eddbf8f881e9c4af1213864a5b95833c13d99a436692ea2f8c46d268da85d46b2d5dfa63cd94dbff29312999e0bee3b59879b8df0b8128379ad81c94e150d03e1bf4ef3bc78ccbe9dd2e29cbbe288f79d0935ce370e2b23d7c79b544dbbb729124bd9a28b036c22b9ced7049cd280c6f19afc979423080d48d3f03e24bd1e341023ef7f2c0b840d9450c5323e8a29a29defe520ea5585e41e42a76d3decec63dcbf8e8ed04aa58f9834f43c1e8a0c70e67f91285dd92ed774e4682597088bbdf0f73a67460448dcaefab082ba5a832dbef6615b51619fbc29f8c41a27f0838e1b7782cd7a47e70b890a5609611e39fa8bf9188ad273565e1081c739daa1ad797e302ca55b19787f4b7584ddc41187777f60732aed1d7102bba9c7bcc2cf6ced443b27eef6b3947c7ad77dc75e32c18f9723d78451cfd8f0971ce990687131243d820bff4617545f7ce9f622c450bd1d4b637374e3fa447da606235f423cbd2ef7297ba5a86ad36a33288f75e01cfb9de991c2e64d31e8c3e0013ff8b06d37ed30510b94d1ec4f9f525bc2343d09ef077f4f8fc7adbd51a6054b4a9e221d88b7ec5aab3580d3d55b4b5374fdc3d14edeef19c43bde31a669ffb0953d4d5f786b732f2161047726cd2a540df597f8a28a64d63922eca2d1f64ee938531ddf8a628300e6e8353311deafb1b980d83205506380e565dfbfa6e8b5e6e50f8b23d10f8df4db4f9ff8fc5f5df6a70ec34ced54ccc16fb7414fa03f5ef8c8af567f5b3c2bb765275e1fc4e45c8624c9dff54188b458bccc8b48f46d60fded4698b18f6d2f30aab94bcb61cfee9f39fe4b1f550aaf6ff72c0df2db7570dd2d4d30314c67dfa032d61a3f64fa9bc0db258bd97f8aa066147b426433536bec50510a61d47da0828b088d7c00d53f3086922778ce405ebe20a79d996f99e484ac1c781cba7e560496c8eb321b4d426a4a6b75135a5b54e75ac9d569cfd3ac747dd2d6b246311a6ff9833a4eb732508ae9e448116266dea159d90240c2e2e0d6c859e6491b9135d43103cb72e1265c19bd01300c50d8209142fa7b41d230f7c85158d3b546773d7aed7381d6e2283408fd58f9cae490f7fbce7758835db08278b4b7e0ee96cb4e6b980aecc01c6b6b88a31fcaabe8f451a3b3540f35e436b497ab794df325584eb0b706af72d92b4a35096054860fcb2916108272272b98f3d73a9265325bafaec70790415cda2585a95e7c8ea038b0929ebb8800ec194d9e2e54b797511a562d3b412157baa8391a5979bf37b327bd4f1c7fca93ecbdb8fc15065991da4958f46c340f5750d4341bcaf4606a50b095f5beaf67ea91b958e33dfe6d9e2df7e83c0702b9a17ea676e9cd1d283754c24956d3c6130bb525b9811b1741b7cbf18f96019cfd18a0ad812d1de14a3700127df772a1c43991b055d59cf98a015319f666a126625c5b63537cd797f3831c63dcafae16e3b5a2ebf688243752f61dc2f640e61dc0b59babb847d853c917b90af3e6b347172e3da5c5cbb266f749b7a9962006755a07f8f63720e898b9de5a09521e772cd9b119e2086813d61ab537ef4baf280162cac74a806f3ba1e61bcd5332254b0e3eac2e61355fc9dc091a3483fa006b238df0d629d8fe70c03b940d1a1c92d8497812acd4073513c81219ef7b1fee82fab7384ad147241db3bc5d5b005639555a39ccff136ceaecd59c66df477144ab85f5d1c9ade54949823cc413f1791846116ce0996b5f8363afc2f6320210103b8370953a70bd110211969d0886043334cceb1dff5194abcd9b20994e87d4bffa9857b2abc45fd6acd52f2d9bde1ce1bd760331e5630fb15c139e033a9ae1480b0a71b904b4667f26d705d6a73fd195d88f12834a7e082a7812260443925e7d090ada52a7a51aa5c53f11010edd94c73f3e0fd1d0c5d95b012c71df4e612b058aceb527bf12df3f87a549e01e6a0bfa5f63f9a60b723477d9e0b122b7e51794a07104742d75e9bcab80f4346544f80c5e3bf3ea02cd03b02393a622b27b27c5dda70bec51c54d80b1ad26f1830cd7cde1a34e0800ff5b76176edae083b6b00fb31adf3e2b0d9737b38fd148abc7f558789499313ad15725de615f633bf2b24c20eac7d44116f5883caaf82a02d49a71affcace2c5a190ef5efdf86b9a4634834205011886ff73334eb8b628245d2a7e9be8560ec000ebc3625725465ef99238d673a55b27669b1f1675c5ce7ffb4f661f310278dde7b6caf1d3dd148608a8ea071e22370281d9cb622d5972788fa2733bd00d7808e2d86fb010575a18995149c5236ab88c5205aa79a0814ec471955575bc4d83db5c62a9898a617428f9fbd6cbceb71cb55486280ddccb1d5c5660b7d44eb526da61465e834207add9e171e602d9d9a5a12e32513b81ef9f76824b8abb6ea2b5e515dbbaf5d2165c18e414ba20a8947a70d5c86dd2d2aff380c9faafc91944ba83e3f1165cecee2fb0d43ede4bcdfb0d092665a95ee42409f25f7913ea1a606f7c12fa1836a21d7eef5ae4339bb739e0d50361dad900d0ca2496b596df77234e5c18f30818a402b81ec5dd8a16a283c26699b64ac565890dfafd27f71a29dd38e5d711c597a77df7e318c71e182a445dcf242af2a781db70a34a48295db1699d9f7e907a7a6bbae95cd04257fa92c900cf884b2625d19ecf565a1740237eb11f9067ed6485c85ace97645b139e8c654b6717a12a94389068da07aea402a5b8fad7f84d862b7c08484b87cc710eebbb307725cac28dfade3d13de9580fac470eb6c7a0a01b0442b264d3b5434c79be96b9620ee2593f71c2213f38a22263c05d787f217a5cbeec4ff50b73f30b240008d940b0cfa2e1263c485d2fecf3b7a5ae9ca04f2784edf51e9a847649d19624c3b3390e4c60844af72333905f407589805cd4833a7c0d96a15e9ef5e7acf872a6ff392369981561104fe53e7cfed91fd4e8a2a9b3068bedee59885ae8a5ba1a000442ff6e811f9988df3e14dfccbe155b88845dae57d121890162e2a9ff17a908555fa1e0c607573f9a9bf55c53c760e86b4bb139ba223c7d0921f3f50741e5ea49f7503cc978bf7214a07668a12d9d8be737ddf56e510fd14f9e8a826691351cff8d7f8d70b282c886e2df526cf1a3d2764d0c03bd8ba7e954f646a745bf13ad62967576d603f7f5d82f43c6724c2cdb86f2217d64ea1a5d5b74a5e483353117f542e9992926bd1b639c82deea659aeb4c97f633be97ef7be0959d827f3fb9a9f48264e02869a819c726f0aeb27d319285c0738bbad3e5e77d9274356b94d722be8cb90aa692a1e2caa070da304fbca4f6030478a3ea1b5e697e27db9f44ac47784acc4f7c081639b82686c7ef7d2409645e06e6f74ba16e666394429f24cd3bf0184e0fe77d83716f1ec17a283c05820d8c436968ecd00bf33b94bf47422fbe4e72197bc8e945bcccc4d89c1620dc33c556989dbed6807fa3081a6b243e1d654c645e437ce7b35d2bb9740233ed98dd5b7e02b41429e1ee934c108b4c00b0276c2fbff510af8bbcc72a2152865054a04ec6037152a93c3a2adab95184dd3e0710d406d61a8c2023075d7c461910dd31311bcbb46aacdd283240913738892563866c691d01e3c9b2d8dbdfd8dc1a186fa215f7c1ead0cfb18fc22397341781124fb42e36c25623500aa6ea0f9f5fb50c8b6b5636935f15bdaf8963dfa2f24132b40ddc861d363cf0320fbd09904e322b186a4bb71dc2cb8c499be61ab5c9f39b810eb42f85973f2232c3ff4172155d73bc95e2540839de3e0ce275bc79636a4fadf5c22cfbffb9649919b72a753a61bf734eabeac655adeafe640e16485f848caa474b513ddb6e487a9267fb388673a7a186136c6fbeb52d38ea9061bc67f839cc5dc2a6b83952e962fdfcf29ceb1594337e8edef6daee9632a552f1670286378709faf307c117bfa6fcbf9c26308f18447aebc5b926c456dcf9a3d837d686cc1ae430453ea6e4b570772a2d9dd7ff51fa04e8e2a07d237b64a48a3d1926023ada7520428ebde7f8c88d1e2781c3ea5d38645ae79f810e0497f1d420d9e918fa9e3d6802897aa05153730272e9ff2b6eb8148c774a6250000c57bba30f35f1a5bf1d4ae2d97c83f8023fdee6f88368b068183e02c91c9cea7100215a56333d530a0ae3f94da2ecb779e765dd6918042eb1c762c2cd1f6bbdd458e2c10026d8aaa2e60510e893d08dd41a2e28fe1f6d96e42ab5cd3c976b17d0d2960c4fe3f9536e3ba5138df692d06d1f41d63bbd823745d02161cd70e2786e0c6c843273d7ae7398b3cee0123c001e9271b4e0dcc2c488c47c3b89eda900227dec35dbc7c4a0150b45783520771f704cbcbe5bb2d08130adaf68dc82e5a37c4f489d389ceed9593abd238aec9717e236f94cd12b2bb6e4fb9b40bdb37fa9f07c5d631da493e8a2a7f979ecf5b0273a88c1814e33404639787cf3637eee67ed7e6e73f64f5b9a08d888b282cc34092de6e430c2fab954fd2e4e5d73ef9952e1deb38a04c009705a8c5b89d7c3a255fccf020ca0b18dd97adedcfc78828b8c487f7ae309027fa9202bd114e1ffcf754ba469016225f7c8d645ea92381692ede57d828318226e098a7c5f7512e8db759a3f02759becc0ea1ecf163e3ec4e157d9b18abfdcf56e28f918c28f4799de9fe8a19f84d3ee1415386e3c67a06ee946baf1d6dba04f37a58c6dc0c096eaed05871a8f843eed522c2c9681ebb3c7d7b3ff8d08e62907f3409719490540eeb916e47f7015f71eb7ac534a2594956ca5633eb411af0a90b5df5ebb3d54923b190e786f30fa1c06a7be262fc19314cac2ee8b1d006ff68a5d7e368e0407dc2214d499a77e7148c5774bfa75b113e7d4480282b95538377a9e3412b1df5213423de5e2ab6bdbb9b841b6156f15979d2324a17b8a90a0be8e371e5cd966b6b8804547c0482886cde6dfcb3cdb78501dbf65ae4501d6743ec810e1b64c1ef28f40b29a78acbc2d76d6a15c4ff6b6e5fb5ba155247bab827269efb11f29a71ef78db71662dbf74bab081d2a9291316fc8da99136b4aca351fd50f4348410ef2c43ab11a36e0d40109c33c950d6d4db5efb89565a57ec6070ed9374f4d0f5e179481aebae9e151deee206ae193037c784793ee79f0c08d8bd241ac98bcf4ad08f5ae3c5926833bfba2feeb319475fa72e20488577b741b085e059287bf07d87745875304a9d499d0d2948823f8b398400c65593d2c0758b105fde2c6ee0933893e561430132baed29128b5a94ce01e4e7cdfaaed46c82d04a5455ce21188daef2e78ab0c543b02d4c8ef7ff4c094420f8be412d93f45eba986e62ccf62b641f6d23d598e3d3779d35b203e59bcabb9530be6d83d542467086d4c116e4f022d55a861de05df995e79d22d66b2ea561ebcc0809f5502d433b424d17f2afa7dd14a3322fd729169640d33db4195595c3d8b9c9d00facbea6c879ec454bc34e6cfd1aacca769fedcf6177dc82baed7506ece4a733fd7d29370b89d068da8f469288f65c2124928aac762060627e8c7fd9dc24dfa7b1e0df804f277a1831e1cd626a19673006a4af59e09499829e5a7d6e38dce40ec01f4ef2d7e44dccc137b5a283e2e900c1d144d5625174437176b3dae3779aed44b054314a6de6ccadabe573eddfcf3e008b79320ea874874bbe5ede53e9c6ed85ffd97b15eae6df04b926e37dce5933ff0604063359ed888f45dc0e99c4303ca5f76d17a47341c23c139dae23b1bd1c7c3cc0d86c1ad6f6e1a7fa0ef871a5ca6562da115e88b389d444579b21342861b3cac3c1952b8551bdf4bc2249d0adcfcf4a65e2eeccd47255d1b89ef934f5aea83cf04b1c42eaff5295285dfa4293c3cd4525cccf24debfa09e2f3379187f40729527e11bed08a08f9396e97c93653250e8cb132ae221a52d6164657d71590fea107d83bcdf995e20f9a0328ea22dc0cb30734a6934b21deb162082a58f249ae1c9948ff7deab1cb7a5a12e26ccad33d23ae208ebce02b0cfea7b10814922c7da87da043d9047a33cc2b1710bd97e23077530a3611b9f2ba348afdc9fe78574be5cd5c222c6b2b007bbfb771405194501568b3a1a7fae7d69dc00182b56da6e14699080d7c0c53f71fea8db5016022d2d49b47ab931e11faf97b70c37e9a10700488b36e502e2b23a8619133675a3e9f2045fa274291c677de16e7f74e7c801dcd73e342b2e4be23619803f1ddbac15ea4ff91b7f1159200ea7661fb5bc36db2e719a33e9a12a5171e91a44479a718b81faf24014aeb957b55ae554688aa1b1f64f3e6aa26a70e4eec8d84bfe0b63559536265b3f503682c8e6ae529170931bd0d49f7f1c4ce000685954bb6b0eed719d74b94d4b8ab43db785f13a793a6280e8eec5b66daa253c895f49055fa4640504fd739476a66fe49715d6cf60b3d2560085adb772cd9342c00d06eb8fc958aacdd686cfaffefc85324ee556621c28283323e405b6ef4c25356890341f79df7c2d1a8113324f219495c942b2a928b9dd7658d34fe178c2e5b60228fb113b8334d1cbe6418a4a34f49a8c4de0918295d7bb4f105812842226e1190869a31676533b8b717d8f0bbc17fea1471a06fe46a5eb163febf11f2ba8c332f1be6d1faf46b9fdde5c189b20db114a0c0b07ea1235438a83f82e96e4f91baf00203943c02561f72f61d99e5a31cb25bbe46380e6ae999ae549fac5ce3d57911730eed0c9cf2f1503ebfe31eec98a1c09729e7933cd63c220bc16036a5ed4435d767d0b95603a21d4d20177d1a36b3d0427b331d0f411a4af130237aafc5f541c2122c14529df3837735ce1a24136354c58b0aae3862d22a6cca6b81138e82bc338290549637b6d29161f043662e78627d60e323530783441a0d8de01373eb151f828dccf654e4f597e53052ab3d89da0860aada9495cd6898391f42cdc233b5e1942514c37f86c710403bfae77ab64ff9ded51cbdc17489ff951679a0a89fbd68581afd49aa7fea612b71fa02cf584250218cb119aafc9d8985419a15af3b5be4a6760fa488889faa856ecc4a9d8f1012434e32207e74922f1fcb349db9051d97b9c84d87abc012ef393732f2b35158e110a78f3e931013db4b2daf49dd5605540d60167d6cc3bc661696204761cf15f041d5fb8c654d23c0d35bebc6351fae0086437d4028efcb1c864c89acc867d3996da89d6ff4cd96065b0f0f2fbd2678cf2afdc1d61cef4bcf0a28b1d0c8ce38ae08dbceeb0fd1d1145353b0c8e6b1af4b682c1fdeec443612ad062a0280f576fb964c5706aed5b0b42d8f1e0c4737e6c9ad59521fe57418a840c5d30570cf1efe3bff72ed1552d98195e01be85063636c2a9d2b289c81041c17bdb5b467ce3e07d959eacaeac753710f55b05dad943bbd9e285b61b65f66f9c52120283c469e525202af09d9ac3fc20554510418042544a1638b834d6794036f18624fd69a6c64213117c30532035d79264a1cd663725dc6e0bf33db978298c51f8c372bb6382c19314689cdecd93f7eeec383d129f8d72415a071132648c82be7dcf4d8540a249bc746038961e4a93f7e02a80c5c8ff6c2286762e37aed11ee12147698b58af535766dfc91a27a349191c9ccbc3cc60060b15a3d133d214324f58c3955585baf5aa760409b3b3bf1770ef95d610f8de27636b75eb459a216f872495fcd29d495d5981fa415ed58ab33388d6f1b5cb2222911e0779af583e9a31b82e6c129f39eb68171528b02596c25e96d8a5291a48863815a9998b523a51693780ea16e45b6db83b3333a2852cd81e67f8b4b0e3e429c38ddba654ef5c2bd6d80a92f00b3dd30198518af071da0edb12fec3aa24e121794afcb245bc6b8dc2e3896d4c5d6e5d6a75d40d5825eddf32881af3476d330b1eae04daf8c0b13ec7a8411c1b057f026ef18a68b021d2ce582a309607b46ae024617fdb29c1f2e682d14a185ce0805166fbb72a15e646bc5f1aa3c42355046c870c2d8bc12bfac03f5506905d1418e70a91d83b276d8fadbce162d24fb5594dc2e119c9e77b31be253a6c5ccc64f67b62bae3df9806ef3e039c6a7e7cf72877ef7537a790645af8ca4568420c2e668cc132388d53cae38e62c02404348fd53ed2ac946aa01f825538873ada59da19a5e32cd92c647dc46287e7805926e44dbd171cc42f428d52a31d8be29430b99c4e2bc4e3c198fa5bdedec1a5947eb13c763e4ccf20e4825b03709f2d9a5deafe9a8e1cdd0d5b3c42f237a21ad1061063f8404e7b3f5c02ce48f66ccdfc5bf7371a387ced1a018a3d58ca0b43962f1ca0cd9c6b12a6b7f5abc6311aff24acfd377355ba57a1892727603a24bdc2f4a4abd2ebc7293eb241414468a7be1ea0ec550e6be8f98e3c5666b4c1f81318f90295173f1f2e9c75de3136d46665d244c169ae5467f7d6fc9b15d8db0e5598f62d14299f6672d14ca51913425e832e63539d431ea71b68d818e3c49cc7caea396e69f2c5ce1a176547e55eb2ae259b0df6022a2606ad80096ae02f9d6c74b6882083bc9c0d4723ac5c029a4e593e46a2bc8fef4600b06aa896227979a10b9de0d780738333112c05aa7bc6d6263c4d525fa54a3f30dc3c4e9256985873155e102ff882f30743fbd96bc840f12a8da3e9b53a16be47b4d36938fa98bdfc07f1946dfe958e8bd0f1ebf6d16c67270aa81950f9bccd712f1b31ca3b6c6f04b9d23c5d5486762cccb20ac0b846fe0d4f4a84881b7715fc586e88f4f68f730c4faf808f8797b840c2e08cc03d7e2718c777425d41b1c667d185053557ae583ae12d2df0aa643d818a07ad89b86c2727f66fbff7fd23a4899810e2a2be0e769b306aaff79dcc6d65301e25e343078e6ca4fe39c892dbb3686c7d71878d405c8fec0631ea775003e470d1d3b09641170fd9e0de12c10b4fafb62542a288a8cf4e77c70f828a8c9c1a5c1772520b3bac93f50dafafdfb92ca552e8e42e8b4e352ed693343b5d22927a99cd41b427db8f40cc65c77887641afb8ef22cafe025ecd28736dc36a570f284c54605cbea8035e97c32d5e501d1ca917687759b808acfa8063225088a23c5e01932f598927b7522f38aa35d5555d0eb19ebd4e3a4ee5805495aae7920425ebea74db1aacefb261cdad77b2c2e47d365d699a2829a50a6f98593dbc3db49d1edf9472fce6274604aa40ed1b36d28915611f14b665a3eaacab94f575fe98699e8f44a0c671c1907f77f1e901dc7a61119f6d50e455cc7f36e4c33105f38f6283d09a10f2e7cb29f04e9976e0bb96453dffb134102b5c7afab6128a442df7af913c9b23ff00d9b47047f78cf6766cf8eca993de805476986e8e4d9ccba0b0dac4bac2f214276a96e84425211ed7082483a5e37d5204506b43dcc31e002b6efb7007166fcf1511a8ab6b30a78eb0319839ae10d22e32524ecef313f32c42dc3f53036de3e6f095ddc63a70bb7822fa4380c4137aa75afbba7f6816789a0db5448a50d4e2d3b90fa4854f84bedc5f948ecb235f3c8e0bb98f816869b44aa55a85fe2a21327d5cfa5a34fc93537a284227dc1b58e309c2b0ce1a8862e04b72fe0a55a432ae0c166cf6960a8fd5f2500522056499f2408eb5ed905a7e3713531718718a66de1bbd70b27966ed330024bbdf31f93903b4569e770d56bc6676c8be0d14ca142aad7f21215ad9d847692bf3f32f17376a7170c9b35476f61f54d91c3aa9f021168bf5f448e3131008cb2f4d6364cb91a71a411ce3862b26f7f1e2a7fa44774daac21b5fcde8a9e5488fd11d61e05ffaedd9c120bc4c30f46724945fa15e8370a6409ab83598068c423554081cc5e963f19641f4486c705ffb70ecb63542ed191df30b3bf18735d030dcec56da8c1f03ae00e50818c615ae75f09583de9d8ee3e0f8dd86da6fcaa5bad04e7240612d060d2ca749a5f65997ec32df15a79872c035ac45c9040f9de6e6259838fb6c1bab82ea2bddafbaf3a88583b8c5d4eb1787c329492de36dae00bbb4c002639698dba852b2f3dd9e8854d8cfc80479ddbcf3b8c545081fedea05710a1b519d1220fcd70f4f3aa36d4225f7e2593e36711db689753f6d62082a6c10d159165042b3f827c11f52849f6e46a8870e7d2391045f1b48161cf5eddb59bc92c6948d7b1c232211a9b3a81efeb7846f39ae439436b749d9d2a1b0b4ae2ed88244dab756c42f4e42fc792870ee0b730f38222af3402eae415d8bd4b26a6b5e05ef14763f14dc4f0918ca90e4c3453b8ae579dedc6227ffbc302f4e50aea9d207d29a478c967b809172bcdf0f4138ec3cb1d719703ecd1b0b2faccebe5514858dbf6c5ae207dd3181ab0c0395a26ca5b00e49a2a42a6e785a0bc001b324a9aaa04d184ac91c50547f590c1b7b4d7df82adeba060322227580d7bcb3190f5ef810a6c43006606baaf5e96b56179af43a10306a50ca1253d6cddbc3e88c52b8eb3d10adebd6d584bc73f894b7fb343c38b30be4f9555b9ef70630e0cad6850fd11e6bc7a285c2181b15928bb966a52944880f92d66c55e18ecba98b4218e80d40be327bcee0f7654dfabf59d9b82f91929cbc21f6fc1c0bfd87c812c68ba3dab901d2fee1f605cdd87525801061a6e7cf0a496e4e3ecdc4e4bb3876dd1f0c4c5ab91777bd12f89506b711ba68bca9f92a770db35610c741455fbeb8a2bdb8497dfc845808e836c772dea9d257b7f959e30fc8981c32ac12be2ca4fe11fbcf4828a47e3a03e8abd5308bbba6106a3e965584978801cf937c2b085a75f79a6c42eb6cea1cdc80d7140b19ccaeb745ef6ba5c1725ea73cc0f292b97430d6e41b6c5f7e14745778a4673499c80a6549b9c1c064ee3af38957a4595863fe69a7ff0a3dd5e2e4c085ac1a68ba1f5de8521108f4f1c033479f6f3069f8b61acba1417f5be8f02c58b964541d1a848c967e8e6ed30c6b683ee25772b48d54aa6368bfc465192109e2ac5ae1589e1776bbd4c24d85197853dc1a16a8cf72ad53caf28d33e0c0561e49466eac175b51ae160fdd38da0732f33b845803d8caa9c320dd7d473a5732218d1b80cc38412629196c278407b5f71c329657c81851693bc1b13b2d5f3135d7a26cb8a02f74bef45c56fbeb1140adc76b9860b0266ec5fcc1317b3457c28450349a702457dc5a7e051659ad3c9911a61abacefd75af958a1c3568be1cc669c1bf96965a1a5bf59aafe2ac77c6f4c7ec42e1f674c1049cccd735a429e0acecec256ab6671def425ae4d85a89de9a20df4cadc79fd3dbd4ab92b456de97940820e85764cab9c05c499b218eaf936ebe61291279944ccc1392ec923a45d3893cfe53f9ec58c317419ae49d1214fd921f2f85cb24d1744a99f27f012497abb0a5a8ad7be651e285159c522e6fd6d218d045e6449f5fad491eebd7d520fc82abc719d2637ccd2cad97d47b0f64911b93ca3c78a1fa50e1c77dcad519e12353e32920648bab10b588577bce5b21c9853a13b4340f4ce862e418bb4a48b6614422527dd8bc863058a78e0d8a83dc34604991df6b82da350bd1fc1b7c1cb4f5f4a4b8190911503294eb2fc03614c238c25297938b05748aba9b17838ed896396aec909340b98de33cfe35d2c92b292d163193e939c74a4829c735a5a2eff7ad9502998b79ab841e945d73abfc06b21cc0a8849b453f214e7001ef95efc0bb4aa2725d499f97337cc9e90c97c04aadb9a4915017db9d1a5f8df41f6dd1ce0a944b42e4c2413720c3a6bbd24eae1818384d3432914a6c55bec79b50928e69f55869f918dd90082cab9fbd913eac0adfbe8d07bdd11f7dee71612f41eaf0d330ac2f6c7418e3aa281b78f69ffe43d09a5ea50511e3534411b7110c1502c5fece85fd7efbf708de3a43a71048fd5140ab2a0ea858a658392afcbaeec8d342354e47034d77e5b7fa311607f69c5e72230eef12af70a693a33c061c6daf67868f4c5f0c3c052d25491f6c35621db1334898f8c70af871341916d31fc7a9819b39379e70c509208893e1f11097629609bed1b9327cc1539652228a85f334e7f59c3d6515f9ce1f326b4a6b7293d7b174ec9d9e183665c4cbc5c832e5d86e62c0783e63586124cf8210c7a91a7457356bdd23a11bf6d45c6e1cd8168c77924fa827b8430eba5cd9b5cf0dddfc04e1d436a57e14b0e0cb3180ed2639b1286df73399ba09c062f7fa6c4f7f6bdbd1788e898bfe0e3fa9a343e7e7268cf98fed708e549911019ffb4cdd35f4777e344a3bb2231cf8ef79e99fe006379d276dc3499c15079091c4f58747ebaa8e567c4d6899ba77b47075d26c154834eb0037a4c771bf70fa0b6244b027e679b8e93bdb7c83b9c572f14b829409acbd81eb960fa65d3b7dfbb3b4df677bf27869d00560602ed8dcb7553a5a54d17c0660bc11a2f75da07066a0ef22278f20d6db939dd28ecdb0c41a63046330d1dc40e5ea29cfb69edb657a85449b23517e10a4d354e6dcce29eb62460698e122093d8bcef717d6a849968f6cc1cb48a75ba5e8cabb4945088ab66eff7090a2f54d6e7609c8a5faec2cde877193855b1718ca141610723d52f76c75711c23601946921bbdb1e6a83434c6b0b5bf312d394342267f0e17371cd3e38ca695f35693d522b6e975daee5ab441ef21b735c9dda0a8ddfbe951e05537de891f0130898cbe22e81b913c01af7ca9713650a81f4e6813446f11b30bbff4c9bb47a85a8ab2defca4f58d9956716ffde4524188e7c5ade889020bc987a80f9e6854e4444651583e4c1613881073a44d987f62cec0d7060a6f84ae0381adfb68f4f3b1c3ececcc15ea8dedbf3c6dfded82f70e1cd599c3f69909ca45060f00cada382000e2f93fea6528981eb9e09b4c9d7f2306400f3d9c412ff1a1cb7ffde80cc42832ff735e38ce00144d3140447067184361c749ea5142f8e7ad05bd2baf9b12100863aa298db4fa78b10e1bc1ddf6b83d2dac89ff5363874e45906d94dff252ab301a4eef19c1655d18f06d0a70bfc4465f57cd092ee5fc81103e314bb937746c9cb24c9d0f93a3a2735ccf050a2ddd00ee98553e41418392088a31644e7b272466830acfdcc28b025eed861872c92d1fabcf97f0ba20d19496b7d743b6fb41992ad9b72efb8ba5a14acf25d9ae560bb7ceff5ecaba68307d78eb425a3df330f694a5221684a3b8baa4e47cb4e230606f050182abddeb21a0eb4b93bbaa051e15415cd6009df5142c0c1a5217908125fddf422771b3ab1f0a9a7f436d2645befdb976214ce2c30715661c984e77a0b434f3d92ef3d64388f4743944417a0d0d0593c01de13c5c0f33e8a81e8f09b94f761c7d8104220d08a2839098fdd2c8873a81906bf1c9da066d5ab921e4b8c2a499f3cda82b2f1cdace221d3baf4c8eabb9365d569a89c7cd8ac48d0422e40ebe5b10f89e6f5dfacab9457180cc14ea27e606e14aff2a3d913fc573f85612906046e32d4da40c8402c7051a9812dad554a1feebfdf9db7bc2da3234b187fcac8b7b2de47e9aaae76fb7a0e3fa71ff5b5cd78cf60e694ffdae3ab98a1f5eda681b8c28ba6ee74793b300c5f36261e8d4f0035e396f8e9d80fdf9eb1c16d924f61797813739f397cdbb60058c1ff30f4c25e19bd07736546ae37c45125a2228930c89f986b4f9df30cc14a121f41f7246b76af9893b7ccb5c11326be6b66f4cc785f9ea55619ea825bc9da56a909c3b84e99356fa27756690a925cc67d60ab474be26f4063150c9dc69597b019afa49eab2758c95c3c38db41fdb701e4643e510e0656942c21879d058a1cc1d79e3f32d661ca238a06eb35136bb538ae0332e2e64d0a4bc3335570f66bf67e0488e4aa60cc4b60fff32a4f00f5aed00fc247248d5e2dd73047f59ddb0c4860bd75725d1640dda4e6f034185e8fc711f7cc6015bd5d198f904b9fc9e81e578179bae381e8970470b7c4069435c76c29683f25eef41836c3120b54df78ba5b7129b7f3f2454f65c9779c59ddeafac4020ecd964a6f8c91ff129af4f9c6b4ea15ad9b732cee9bc5cd67b0f02fc7d373741a0e4cde0e9f46c79b825b117a315ee4c8eb08dce6d153330eb6221a7bbe23b35958290aa18118423ded325a9fea92716a0089b78ef69d2851f5cb4da5882c809b0e58d4d01f8e04ee1b59218e71774efaedc0b130819486e4405713ea328292edcd6ed7707a30950cf4f19d3328683914d834092faac23d9644f361bf1c79df2a04af368e1f61385abfb2b8731236bfa55957da8516b7c6eb3b0cbec2e9863fd20a600174ff595fde69a4381b5784e740c48533d155e3bd348bd1288309b806bef48bb4d8f16832736d7531d828fb4518b7a4b426233abd4b16e547c61a5e034fcf9c19fca47c90dbb48d044755dfc15c79a10847af313e961cfc2252cd19af8dbd9899e073ea0ddfe75ef02b2c7c2f22968f9a3de64cdced29408b65f3da8368979994154966e4f3e1c9c59af2610f17ef48e7c65b21bb0107a166c13e20d2ba87536e21cf6ffc0966f132207ec593617e533b4019a67a8196c40c1192f052247c2919d1c7c6dbba7b0e4e476f31702273b124fafbe7c6927d7800d3e77b053e7781e05d294381bbd1306a18cc3588eca623464f3a6d3bf1ca1ebeeb06923216bdd459d115f1c043d6f512d28a4b45b43ba6ed8be5d0703f23454b65df001cbfe41f8f6cab2deae177523ed33f35aa3c89081b469c3dca90cb3a8afe1b4720d1cbc7c63156aedfe31315d0cb6030fb305df0464322eadb46e1fbffb404a3c437245e3d0bd279dba6e8436e62389798b8c635ba1c5161ebdb1d75ab943c922d1a8b1cc4d287dc69d9d2b589e01900ab2911910b6153ff4e791ce4ee55e2ecb30f02927b24f6f0ddde1850a4410584e655df145e4f09d664a2f1e4255cebcae52b84d17d0d66c81169f3379cd23b0b670ab15dedc14f69bf77f6b4f210b2a488e2ac6aa504f0c1113fe9daffa6960fa51c0ffe285343af7cf685777055e14cd7f923259b1f68cbe4795755ab858b047b8b6e88cef87e669f9443783a88bf31230325c22ed8750ef4084456f1c681e773803821e22d3d81b63bd29f383268e6646b797da507110f7ad7b0cdf5e2ecda7b575cf6abed271b22cebd4320127e5621a97bb1ffd94affaeb3632c6bc599d7bff6d6123c5c350e9c08bb019ae7ad9a6767254d7f4d9ac7cb6d1337772ba6e3350a067a3c6004b3fafa0f67f793e9aef5754c7bbf0091f023d3c5710890fd84c0289a01245a650798352ce8a23a26e7bf47dbc352d3158b5cdd1949458bfdf2afd50a2d7f0d577501e8d37f6302b9f06dfb9a2e969fd55cc0f99ee4b8b4e3e9c5434b285122794cbab84e9a665e006aad01bfaf701a316194521fd0dd14b13082314abea7f745bac7fd0406b88f36438ab65ccee573d562a988c49f305b64442e7fe0a8e69abbca00ba55db028ff22bb4bc8a1531baa4cce313b661368f1cd13e55d81b26cc53efc6721e97ebe04dd51a0dba0fe0c0efe869b03d606c5a0b601d214f9646dc7b3c7849a5295c53144b1fe714632fc404abca1381a2eca8f667f381b66f14e1cd86cfe378767cc9819ab3dc27362ed59f9cda3588907632748d3fd5592c68f2c2d0548e9c79da6e44ac335dfd00ad7ed62aa0ed9995eddc25c6962f868b9f562354980bab9624469b86d017506d5e611a2c17007db16a584b7549b26e2ab26d021a6bbc72f40afed70eeabb202c867c50a7b7a707bdab76a05b0848633df9acd61f91007dcb0280dc19c9cf81a40cdf31acae232e6edddda1e96b2bdd77bcfd74ec67b8ae60c607691120e18b9c8edf5e50eb90f78f6a554409b4b2221cb1eda235ec069490f17a22968ce4586871c741545f2813aed4d3237cc20d35da863f2509f815249c777f9696658fea50e0fbb972ec72ae3fb16798667d9a4284eb24a1a3b9c48323dc215a27a555651a021edd5f3e8bfe09931e03266e48ff92ae2f5a4c68cb03d221b4aad87a094f9fec1bd0bc7298df897218dae4171c80a3e2297d038989cc8145fbce6f15a4ede357d849386a353c10de788af7da09183db743ceca041bf60c1fc850fdf492a2e709dd5d49da200432fd66f2c6aa3cf72916af8a98e7270db2ca89892bbbd0153f21f79f55dc80d96b65d239ca3d8f444b775df72bad428f615424f4bcedfce1f436c5eb3643bec52c6e717b5057a181e6ddb047a39a5101cd27d983bf76bcedd1d5e471eb71caf3af8fe5314820f215cd24f8861d7806ae3a127701c15ac9cc6a7208b794df4d37a607dde1a81f98ac1199ae3911e643e1fc3aeea0cba1c9130cfdd77666e695f48ac7d156095d27b4df1e06ff3dbc562b19898751473f8663a432baa0739deb7a2ef3993553913d815b724db4a83b26673b5e611fb49eec2ad4fadf180296b27b7db169d95fe7ad04acee8caf2b26f728f631668f72909c791f3cab66e43fb41aa9d51ad18f5627070ea58e911e003299ff31914a27f9790da2dc83c2aa49c3d574e306c6dafe5a10d8b0f9ff546f09059157d32937d76669d4bf77d96e7a6742ab243eafd90304","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
