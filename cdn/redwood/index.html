<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a2e064438ea3a4d52f7e9ab1d6f796a92068c952e760d48dbe88b0998042ddc6ce33a3a0a1cf1a3c8aa2055e87caa3ab4ebd9ad79be18dab83df6c47148bf74bbc9165f7512ae9613684def1d2a780d678c8339a6730b9f37a7f2d75ebf29a2dbb78508ad296c4c1c6c1e73134b6158ffb90a119833e40bf6806d16ca47995343bd7a3adf489d1bc1937af1b581d1374614b7b761755be36d114729e615bb454ea7ed759e0eb2c27143f42a4305595053562d95cd854ea29794822f667917b45929dbed2b40ff6832bc7ba9b7d2eaad4e620c3d62218829b0f2bc41d32a62f98b4141c520097034555fa616a58a8abcbfe889bf03ac1de209410019429a412528ec2907696249ec138e85ad05cbcd3ee1b3533ca5e9c06fa678f3b942628191805d12a8745c7f3c5fe50faedc3cb11b65755298c77149c5c5858e72a2865cccc561b1787009d9aaaaf4279b9f47479d8ebef90a4ef8ae262cd3ad695c55daee9a3fbd44566c00ac4cd6148bb8e3d9ff12342a7ed41a2d9fa217f0da9ad8ec9e1d02a1a52c199adf110d9f6a07184fbe7c3e2fbcc389070eea9e82dc677e44731a35edd46a528c4adea26b39e700ddf13ca4132f21a369727c8d07133eeba7a72a0eee9a3e933dfee41a32c0811deb7f02e7858ff3e188a5d71882802fbe4986e3e0f3ca9e5e44719e3239a5cdfac2ac9491055492e3b630d39f1d2e7baf141f2827b3f5d83016a2e7e13558eb26470245eb6f874f5f0e28719d4c0d9f85d9ffc24a00434a74400320c57599f3f57fb33c2481fed4ac4818265ecae03b3a4802342edf3ecb9ed0e2f72bd6de85470a53441aac1163faa3b8ad662ae70d7303072c45b8d3a038e6e3aa0977ac2869ff2e1b07d452ffd02d2d37276787bdc4fff7b5605e59125aaabafb8824a6c0bd2c0ca8ff0da1f8ca931d6105d77a00bc9e30dcc4870d72cd355eda5f8c618adfab1f36d211e2d214306e41416ddcc1bfb1b9095943bdd695d7ef803bafd9fd74bb4ce09b24094bef3a3c8f0917ec7083581368ad7b816995420b5943a2258a80d11243421db8be1fa6a11a75ff3f2dd227529baeca3810ada225ea4c27b63e4d5ab95e2f03e1349059bafabb5d6f152e553b3a051b2cddeccf7b9dcd2de8740c673784d8f1781bbbf4f3a5a37b494d79c0e5b07421f39d094aab2319bf74ed3dec94bb4580817606b56e124ff44612c238f6b0158e5fa7996b89866cfb36b7ef189d68eb7d7a2bde2bed97f3fe8d50822603afc1e3142538e89b3eac2ddbf933958280f951b7a3377aedb664a3db180bae5dade3e6c8c6eab6256a8c39aae702a957d1ef5bed9900c690bc4677b6b8ef8403f0ff0bf201e172475060612de2580bd6623e0ca1d866e19cf721bd474e43586e3c7355c562dace513bf252386560584fc9534e73ca34623458d581dcb5825e129fe41aafa3e726559160257f0c40c5e80cdec75ee7431fe4571363066e3722c2019d9c8119e30f5ab81f3238a037614c77bca08817104c13163a1f37c919c4de277d28cc7d6a039a974e160f6f92ee7811413ef38607af3c0ab3b470afcf15aed2ca8cd0a47fddac6a6e9929c5f372cf06bc777f3085782e28a4f001678bc84f8972ebb537efe2cf95439cdacc9e0626fcd269696266e9f03e96f17dc434dfb828a84588d2c2b88eacb18ea03b924083c6d3b9f9702a215cecef439a1994b03461958a129bd330f98912bfcf15fee16390824b4ac3c76e81392213ba807152d7a2021425ea5d1ea54ca3ed7a71664d3b8ee0d784627c1a8f5b504d3e4fbbc0a3147072734af023f46ba17ce0bec15b0086f3daf2366d28c3e4f8482deaf7b4c3831294e0c46e152d328d72f975726294fe9703ca7327597e845e0a382ed5c05ba4652701ec7b8c5164afba1d35cfb2c08f6c425571d5e8397761b9cc487ceba3d07bc43d5270efba88d008a52663350f6aa6250102ff3e7e2a9e9010b047c532266fa49ff9b3db8c2a4cd6977340ecc2477e8aabf1b328ce7df0bb5d58bf7f8805aaaabf46ec8d60612680e9ad68aecf718b3d6e5d95a96900fc968136103a5e93c29656bb3f3510ce36d73905d2e693189c53c3f608797e07a26d318f77cd1f18d411c3cd89b16b0dff9b87a2b4ee80fe25e1b5e08b03ff3a8a4a61799675e95f7117121e4e2024dd54573d08383bedb9aa50899f39838bee74ff671c8b7a6a59c0a486ea636a4ab5eb04cfc18cf409f19ef7bd0a0c73b55ba68e4a952dfaadc85f6a7161be329233ee60fc8c7e8c13206967eeb70099d97500a51aeed258c2d639dadb9328b2c07c16ba4347ef1b49807d9a7bed32d4e27fd5f65d0751be8d1ba2494f3c4071b7eeaad9d6e557cbd90c3194aa25000829dd4cb243a542650e782f1b3689d4d43ff259ff7fea0407b64d5625711d724461c19d940662ea45ae35f2f5467db784596673f42ea72c586877d21b52224d5a2b20602ec8ef3b4afdf24832ca16ddb3dc8524c633f06b569af146941ae806ae4850a005432f4fc171c6c27745e6891e5ecc7b93414fc02b09b652d43466744a3a86713642b7b8aca9412103e22073b9d5806b4644eba83fe1309294f1161136b5ec5e6042c1c1abb25f0215b28b02f168a27b632c5af1c7ba0a91971c8d0c67b890feb089225dd7e1bf7e00f641bc1964923383051862147df3b00fa34c95397bd1582fd4ca5e60965721d6e214d35e4f1e93436825b064908dd46b85e89557cfa218d8b6bd0bf17d9e0de99617136192b597444bf0cad146042be7d161ce8fd382251795ea20ab931d1be0bf27391ac6729cf1820c236eb9a56eb4d4f0f6825674c21fa5da01fd7f6ec3c258915d6b36597fa5e5339f7895d75b40b2a37c0ec576f845123295a6752048584f84a44bda1f966da9317b5bbe3b24de282fee8d3c21374920f60ce42cd96539ce7faba43ae0d28fa3840ef33794eacd61329dfe9f32cf18d71b95dda3b98b79cf6c25bb4fa5242fbf4d7e347a805ed10a472ccd1dd7c8e6aa85c0952acbba9d5f0a155c7d0c7d46c4562be85d50388adc41bd1d26964f884d48d0a16fdd0aa136b39ad07455588ee2dea4bdeb545926972fcd10e3b501fbabe2fe8ca50cadbeb617a2a379e21711bb14039e0a218639f5998415b233e951a80a35f04dc7d9964c902e599486ccac099a884e69a63c1278dd54291c917e0aad9ab18511b5211e23d6dcabab48b8f57c74d451000946bf55b59d70411a802e18e9bda2950ff0dfdaf7bb260c2ee6b3a0f468f9c4e962ad25a4cb2773ff33c3c455445243f95db3e5f42ec07436c9c1f09a5e83430fe21bea8c2088d5b2c645a156d67f7a0846fe19a2891492c1c7778c42fa24953631ed410287bf275de56352641403fc90ce5562062d3ecb63bf638a68aee12cadd8d53e1a71f0cb273c445015d68ac7f885b28156bfe1442ac6d20f50337cbd68868537c5fddc7a596aa85d33949f6301bd91e958f576f0e11e3dfbb03abaa2ebb8549994935448737851871c9c02104f5fe8c7be682f014993719ee7b9efce7c301fe3ff5ec8931d49918b05d738c7cb65cb1536ab0e844c94f1b45fa7eda037e047fd48fec6248d8f7871f9cab1d1f57de10daf05147dae4fd011435fb0acce4e7f7fd20df7b158907f5475ed0d1a355c2d753b98e5b776da2ab4cdd789543b2c5ef9e6965db8bafbb5cbc9cf4f87ed08f83bee05e600e5a4b543968b55e8cc52dadf618159b44785e5c5d86ce45f207855909ace2c8b5d9c177260628e547d692a98880514f60b453894f311c4999c405737faa90f29b99c9aa94e9d4f21ff70f83fb94cbfcfa72ca47a7ce27c442fbfee0ca64539766de214682d5a51415a3961d2dce60bc62e5eb2fe741a5d986059074f5c21356e3fdf4edcd78af39879895496411e959484744fdc5021f2d1dfb62586d1ea6142698220302749a628bfdf397c7aaaa386c8b9aff707a991b9d9515c5a14a1949ee643c76d2604f932d9e9b56a31183c42e448a0e9d85bb914e2c6b79a50ba6e54d2dc91e579696f4d5335b4be83914de7dd76f0b236cba75940434bb203098619e7256e8a0f0a0d32e42d7c327b1c1a1b4e3dcaa7f178e80902c01e05d9c2dc2dee9ad2130f5d47d4cd70ea37b6f008cc57e32bb023381d8ea50fdd7be00bb8aaf88c90adaaac3088c3ba45a6a5345d0494b9faac127c4e60922ed02f8189995a8605d4b4f708c07fefb8627e8d6fec8a931f2639c1432553c1af598bd120ee8131ea9e7674f5452ef269ee5a6c42a0abde613d509ed75c3679a17c5a4ab73f56c0b5554882397bfaf859896e4dec66c575b7d2b8be2d5c33dd709dc8051c337ef21a20be26bd5b04a434d48ec9700385b3a4c33252fe94af1d41accc63ea392c7554d154cbf4df8bff5d60a0f2b4163e6f89803da50438700fb74ae410c5a9c2f0999a4b3b631546cc4370930296d3c3a1761e0abb2adc5f06bda246ca08bad5ec43d74ae276a57b7d3c77d099c9c3ce38de177213f64b178772dc676432d2fd76a50cbf0a7d5fafde82cef2760a6296cc2af6900069bd299af5461d5d9f76fac24fb9673f421435bcd6ebf8b6e2f5ef3813818599b81a4c0ff8b2e73a3801de778854f92567f3ada70fe455f8bca12423b7f6b4513526c9bc1f81b937bc0957f1bd8bbaaa393fb73a8260350d3fe8b3970be93838394c22824e0f12d6c1d0e7fefa45ba6e4db16e70ba9d831db50a7f1d395f7a3a482c6cde7f21f52c9b0f69d21e5c0043af45ebb36a4e1486f6e477c7ee9d7eba8a720c7f01df7a3594e8eb9eaec1dfef96f83760999611dab72d5742c61173952031852662e409f8918b437a899c9611e42ccf3a7ffd1f94f0a99771a16bdc8ed252233e6ce6cec54e2a504033f8de93bc634a203438bdb01c727d75ed81f38a196a3845996f9f403249edc8a8d37b08147ddb298bf4d2dae8dcc63f0b0b030b07e05cde6386aac4c73e6acad9850082e8f83a10000e39fff59df2ebfb81d03013a1e3c1a230e47760b4f2e1dfe24c37fd884d92c3a8d373f0ccd96a96576f3aa153e330298e1c7673664992db19f61a7dc2d200a6cde9c4e9a57a4b94188cd98c39f684289be76e300b42e74ddc75fe6148072a2395a66c42943fdbfb970726aa934ff9d66132e7b72f91eea285991b02c4a8a6f53854ca1f613019cac354b656f1befe5a9ada3d25f9c8c8cfd37c078620cc445911a25f4dc3d55da00350b305bc3dd87c4e41480404cc873b5b351cabd5cb0ac06914f1ef64892ab484c49db8de1517e6be3a1b5a32832bf28ae2a3930bea8a454aaec636b34a4d60c621a4c6f20ecce6d2bbeea4cba73f519c9eb9ba7c810710a67031ce35d09e38b40da955fe0a2becc7cbf4cdf8b38837677a2119f2b41d981608cb595bf1f47eeb3d6acb7eb162584390a8b3caf33025a2d88c19473a7ef4f6f395a5bfd4bcc20d441c3f84eb339ecf88a8ed744af1e0c0ac34d510c40e273c596136acd734d741febc8474800b4263d056da4eba86f8864f0c20c71c192fa55dd5686ca7cb429f2a339c3655ad01ee177b89b2d8209d31ef32515412caaf677fe1acc734dbb3115444a7988b0ae02c6d81f9198b9612e4a7046772a3e581abd687f7e1e89febdccffe12791c827a15090b78b24d1404dd19a12cfabb19a60eea0da1037aaedba184429109a16e923a09a80a660feae6276cb23bdeb23aeb330beec75600e7436daff3bd3f7f7cbf003edd4561a1bd9e6ea41c021a1050fa73648289941ef4a9e621f9fb4e2f817cc8d06d260f3da745c40244a87020058a040b86ab7502021028d91b4f156d492dd568bb0867fcd7e5967e33bcb96adc6f6a682b6c433c336cf5e94630f9c609409c1070a5e962072f71d5f3b04d01aef2b0ff30e39f3e0995d08115adda0f12016ba1e4971606e9daacc0f63bd1953b54bf79b78e87b1018b2c140aa0844c41dd4130474da0416f886bc921f1d7e92a03f346c480b65fabd32136204c1ab496fadc7977351962254e2c154dcc2268ab5e8cb8e18b94ccb7a99c8d7ea63cf91027f2feb675958b69ddb11458d816fb2678b6c3e9d83a1bde63ab68e6e14a578f0b3d227a758b0c176c9df854f1cd195dcd752409c872619be99f73bc5d43b8ef4c57f716ff20daf44167797fc13259f769f3e03ab0aff3172fd0f8abf0dae012d7a8fc8f53b1b358dbb8241fe7bc0fc6c20adb84af61ea23d025949a7f348f8109f33ee748bc930901fee84d8a595c52f0358538801db6c383c3c3f9931b2fb7762da6935f90894293c7f49501b72750934ed00c1160e92df493617ca06e6165aa4ca711e39ffae1ca37ba60cf93f262fe79a86fb6c1d4e9fe63de6a9ae0f4b6790d38821dd0a7507e2893c7dfef82106fd6a12363205ba9dd64c0397a25d01ab3b45fd7aadde00c777662c3deaa2a39a5ed06ca5dfe941fb9eb15efd3f5a4eacab09a5cfc1433e28e84708156a2805d9e703977e29768f86025d2e4f2a7e8aa416a55a35690aa8b45845a6028c350e66c47008dce82c68716ed0228a674eddd9bcea43a8dcfa3007ce7df287e34544913fd38eea6780ce35eb5451cdce76ac566b06bf52014cc88688efde563b5b97ce9ae7feb4986b0df6d6800df3b2b0a33c6b4db39a5ee176b5146af9f5931caa4ac649f9a47a87e46210f86fb90573d8fd7203568363a0a078ef1579233a47fcf9b5a225c06bd8b5ebb40b82cce4841e08c63203a8aa0ca11cc8c9c64e4b9ba40853915937daa8b6364f8b5d53d9916a351cf499a91ce239c33f5e2109befb6fbfa1b35c59bc15467fd1c0b7a9d8dae4932766e8396ee69d7e9ed39b29e5366a5aa3998247300084573908fbf523d845bee52ae62be670aedd7fd4c525165f0368a6330b15ae66c806cbad40636078937459fa1d9692dfcdcd98ba28f55b30dfeae6a8d02f7eff446ec51316a52f9251d523302467251d36b5da54164d72df02f5fd31ca0602d4290a1910357a5317c76bb9a88b436538a1ae4f53e8e7c64ade2e85bc4c53afdb819b0b3496926c2f594143e0352161d561e737862044639e70eecdc9cc7139acc7dc49606082308efb9153ab719a8b786e6a8c68d4c953568544f526ece7c0f40ccb00bdf9b18563ad6b8420b77d86c3f7fd5bbcd648cd41e1651d122c23f6d63dbea9726a79b4aa68b2a54c4e935b4f38d1cfd1103b767276cd1f8a6d7724f19f9aa52cdaf3cab61c2e540e2d423ed7abe7c16e3b39b4ee8247dd6fcbafe94b3ed335faf43a169b47335f65c91d01fdf3c953aa897c6130698e8fefa3c311c13a967ae6da23b21ed8f05b8ce86efb634de2b6d2fd2ae6502e5adaab61d8137efad50af782edf613c48ee2306a5297e84a2a2dcb52b1ecfac4bd38260b7a3b99a6c9fdb55f2b910623438be190e8eb1b45742a89cc919e0181620398db82e39a479a7b8e7e51efe1999648a88e2462f2a535b39188e3d53aefda89593295fc5997ea19a5a0ba732f932a7e27fb45d65b8fefc7690453c0d10575d30547426f660cc394804230cb9569f697d9c5a34e593be9f8d50272cd954267dc15b27a5e6abed5c71ffc8db1439e3a77ebda8c157482553bd011b857173f4c80c81e04818a49a107d7f1f70700016d5f28d5b053663e3546db2c52b98f8cec51fa8596e306935abd3061ed239e733c81f156df7ba70cf8aa181cad7958663e7fe6bf0c0bcc64364a179889af0bbe999819eab138a66e9703d280f7cb676558208623defe6955c5b5242a4e5aac0ddaf5108ba6bfa3eb83198dbc7cd472f74b4c972b05a3b54afd04527315e9c1e14eaf51697a6ce3169957ab93e15adf682546ac4e03cacf8102c0b12c5299b46d3cd758b88469cd64ef2e7318d2b86d6fd1f461a5cad0f21dda5e1d6c3b37f6d1a59dc8b4f8495ea3cbe31823ca8dd4c97b9b1bca93a38d530109658edfca85ae3da946caa86791f0b2a8a16482059f8ff39b3977c985a3cefc6e35addbfebbef6c6947fa626877ea3c4ad47921df01fc5dbf9b68d77946fd059764ca6a9665625d9f173ce4b128ac3336baa2d7a391f4bb8b82f8ee2090637ac5e127f121f18dcc72db1cf0fd0a5e8fae009daea35e9f72aebc9ae985476c7739a980c83b878b89478445a9e54563f7f7f710e8747ccc424694592058c2637ec1c1a95dff3b8e0a252736feb69ae57f6ceb7a8d3b7e739025b9af88f90117e7182bb3337310501290a59141796abbb33e6d959dd6e77fb121262917b6eecdf3330fa1b4999445930ac1fade3fe4df9ab20e21b57e545c8fcd9caaeed9a36fcf2ccbac76cd37812b341a30e199012549a3c82e590a6abe48ecee17da980ce2cb40dae4b6be158b1e598785267a7da7422b485e85d5d7b4633c8535c7763a6bd5f15dcda529e1c78279a5f75e37f7db5c83d4dc592a9d69d2598489f1922120c58ca1ae632f0494915d6f4c26d19b924152aab4d18923f17d9dc43023b8aa144146fa4aab85d789101d9107db11375812ad3af3b27fce15700962c2d7404a5b0b8e577ced9367a470c3ac3fc2867225a094cbcd6166513350cc0ccc154cfca5b01bf8def6a0358f684e56f464531e51d9d8df66c85c76e09a0d242528665196bcda7a7dce6827b2810af005ce094c1c23baa55abaed9c13e21e3813bfe6037a77bb2827786123ebbfa1e96af9a160b894a9e64efe54089f3da47f91def5e01efda749fe1d29e003d2fcae6fbdab370743adda9210d1019736c68d56a67897572dc2757df230bc8125e462d739f32d464c09216d5b922ecb3cb26333853783db426176c8b7d601bccea5caf0c59773b80646c200b0eb446578b0e71791d43cd70bc388e64e2f7e9f0d0edc5e2439db95b09ad1a5f67e30f4f0399a60b59d08be89996050f210a4cab10c38be6873e07acde85536b466e656fa13076a25837bed56ba064dc80809dd91bae190f13226731590ca432abf9458ba8d6ca06fdd0b3af935a8e09afe778060702031952e1f76b7166611f40647e7376e32f97e335641e3fa64ed82f89ca23e0480dd00e48b65f71137036e8bbce40684723454ccd8dd80a128c093e337124f2500f4048680654cbdeda41ecddeeae4401688b4f7ab0a93729c145645b4da0cd63d857292b449a8fccdd51415bae41a5bfedd808e5830d40ade8b31f9a43879dc7f1558288076250a9af95bd58988c92a33b68835bbdd6b45f7f95c4d5347ed34cc417a9e27fa4eb2e838421bf149d3e5e4ee3417be3b8b93b750b6d43edc9515eca6b33a20af19bdf2614ab8137ce2ca27b5a822f32786f1f5f2f68ce44efed1758790c84bd4cfa03a3edbb53580213e5362e97bb0e049bd6b0485934fa7ddad53a561001b3f8280c78b18ea3eb1e1f0c78e4a0aa3eec2f635ee67f939b9191a3b6105a6204498838e9e64c6e9283e8762d0688daee9ebf527a65959b1b0f6457800d56e37607a554d79fb6695d39a4baf3a48d686853ea0abf3b81525ec28cc5cc88fbe668dac97886d5b39b37131d1431545eed7682210bdd88ecb309e27e31ba30e907120d67b6a4298891d8028b37215a0e82ba452521b670c933608ddfd302e1670eaa5ba9dabb809a0bf304b3da4bc1a20008fe54d0596a382cdd9182e891bc4e1d54c939cfc004ff718abcbcf3e16451ab038c0f503b662bca135c6718371e5391bbc7b7bdca7c5abdd8be6a19d661ffb87f8a403a6e221de1d080ebc1bd9ab2fcf3aca1e3ef8175d1fd105442f0737b690469b60e613cb2ce0d87e3cd8fa8d4f9ca275a9e9a56f82d873a6a7c0c9d9e55d0e265320e6356295f3c879ad6469db6260fe2af3062d05caec95de2b7a6a9bf966c7ae71c50f5d52848d926ce49372638cd4ca2ba87f80d69b006825e01ec1e73d102dfb8d651208e7d80db915c6523f359281ae3bbd63a718ef3db0e80ee267f5b5cbc0f3ae5c2f4ea234ac591c7e87d304074160e667821338a457b19966385f40872b8b0a7ea0996423c840a984f5ffc6fd867c0437671e039e8f184cbe4f47e99e9cbf7d5d4c62b2884d2b3f6383278390e53dfe406dcd68dfa965830524f773a3aef8485f4f93af9ddedcafc8acae3ab0fb371827f9493cacbc0063b43584a81e4906768a4d3b537c767f74d51f3e730d6e7021d2c6ef179c8237932975b6b8ad03a8a89c967ba7fc1ae844e4edd8a1eac9ff396f46a65132683004373744087ed34ee9c898c3dfb8326bbf152b2386e6da14ab895d5c3f7aef85a5ee94bcaf3ff19e23a7439f0fecc8013390787d444de958d6170ba93a2bcf2ecc04d75819fd8f2e9c44cca256b712b305a65b33bab2ab95dbaa7eff5b8b3e9a98389e945154e9b4408a0c64","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
