<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"17a96792d91fce522e05509bcc3dc7f6533f5855dc4d7671a6d9ef49dce0ab1aed4ea72d1e54300ef7d9bf7de8d8eabf6cb2bd020f0858554453308c53925207a270482569cddcc2a0d420ed838b329d23e974a4d9c4e69f3c3ad93d85b0201dfae4a0d6a3bd1b748cc716cda7efab6f040c987cd8c823b7f358d704e3f14c8b253e9fa8fd8fd8dac9366ad44b093e7924d37fa84976bfb20c269274941add0862f0a3c56e6f630468ca05409107941a1541d8e6c81aa29d3c7301259353dc6b565b4c33141554750eb6c47d9a885194341a8b6ec9622d01c87d0ba46d46fbbe26b9e18c329b10f89dc069ab36d76890ad3886988114320fb8fb96443e09a9d91d9b8d89affa372cf5130561e8e218549341e5a4155d661e86896c3e7c87a785b3c5fa933c454f7de776142730b55a0bcd0d321c763f35e4f4955a6929608e48af2251a84c46295a8f1da246b2f0506f3382901ac75b366dafc75676bd5f4f7dd7b2dc0172d46a4135bd55c831e7bd5607bfdbffdbd5bb49fc6cc260f311fc6b9dbabed952cec5349d7da20f961b73edf62041ba4ca8e664bb57d01d14a9079e4ab2a2a33b462e181539e9844d33c0fac8451c1b04733b1ea0b3de4d1151a7d0d566f90eea4a966cbf120bf5167cb9681fdd3abe571309e79aeabe602e0305c620aa09d560ff9577d166afb7f3fa25222a17ca5402554b8aa8b1988f88a6cb1b03290a42fce9113bfa61d872a445fce52179540eddd107f0fcb2d7409b85ae7198ad6139aee1864902b05d19120543789bd1c9dc1301a0b03d98e83e66b8d6cdc6ce289847d3ec96900487c59dfc329406a816637c5884c22490597b9d2f2f81529d96aae57b4efc649faa263642ce9d8fbdaa3dbc82cd0c8714f40648048e1b647c8dbe3bc2c92cbff41b1c6c5f3199d470eceadbb0821fba843c03854b6284449182353ee434d75ec0baf034e62aa881b2bf46c1a75a404fae4e9dc2ac02649b1bf55b5880dbf130641c9353c0f21590da944f7ccffba9e796cb2522201603dfa654e3ad642fd7f67d559597a2ea80b5bdb87245df28e75118fd72bddd962799ccddba9acaca52b53518b50d5e9230b51d6033b74f81d66a261e7b393e3562e68122ee9866035bad25317931d43b58daa7e36c834a032aa517ba475f8595f3ca3214e39cb5e720aa78af014521de03878e99f6943f9baebd156ec12f718b6541b20bb14c568831c4045d4a4c8cb87c62e4032e9ac50eeaa2b49278616affe64d4f1d8bb5033704dc6f222190e4bc9c2d7c2a4883550704deadccc84b63e3e9c405979916ba7f848610d8e68cd958a8b0b55673df194829c52e0eb583e87db22ab682ac5220ad08b978f23939aaaca06cfa59bdb2cffffb6386f1332fdb322a5450867f9702a5c7301783242d710eb647c40150015838a465424142932f345cfe1449b69805c883e4bfeea54081da57737655f77612d4fe2a6dac24876b8041f6603227fd069a93b9e9035ae94528d524c1f81237997c156ab6a177d7d5be80666b5d6e3d8c6a4d6980470e3dac70966ad33c5a3a1ce4f40bf8ba326c4418a7b82475f012c404209d8e2004d8a990384dcb5025db8bba389dcebe5b571909cfc37b282c3002da562c4b7d106731bbe92ea2e6b8144139a9c03617ad2906d69d1aeba4d3dd26c0cb35b0a1a6693bfd9fca18ce583b6e6723eed8417d7b13675d1a45937a0fe33afbd3d660ab98b207f1e88e21e9087789de7ed93ced433daf0e9843576c8f7064d0cd93015d0c85d28fc7b38844ec17e1da1097c272083ad48ad25fa355804f0bf48cf19824a78dadfea21ebf677fc45459fd3ba1e7433f17c6500f2452526f2f2bb229859f9ee741539c2ec279a16bb25bb800e38cce8e084c6480e08178230c63ada1b4d13cfe38994df6b537b5f407eec9d5c1f2b0b792c8b56e34f18468cf32789e300b187c8de759c65d3d609c040f8304a29a2b5863d1a8bd2b9ca46ff834f1c2ee6864bdc6f24c90959c97b0581046ea131a117d11072e2a7ff323a352be0f3d51e5cd5cf32d7dc2d51efd79d85a1f559a7801c14a0a5c8a9d84f248435ad9ba31b0b061b0c13a5b4a09337c02fec742878c7d0df30f93b1b2ecf677925f2d25735f8a32ea2b51b3b698efe9ee9388ef611f5a539c622f0cf1e41f6103c18877012e503c762bd851def1df4803a343918e568a60097f05f89b29df0fc70b3f69ea8042d2cba9bcd504febffd4a0608a479ab6bd4870afa291efc8c85f2cee7b37b90dc8c5a493304114094019fa2ffb72a1e92d9ba555d67fc3b7f838a88a83eed7347984d4b62f35a49aacb07defbed9c3892f9d8bb4d51e46f8ef20c75369e086d427ff12a40554ac1cb15f0ae8c29e7732fe2d86a57208bed51920bf8ca5772ed5eed495057831de56d9ca2fe9431c2d063d8eb11e5fb1cb45f5c428eadd6db0f79045e85d0ec7b8008b13978a3763e57c938e075f089b7c40ddebeefd1b9b03f857fcd6230973486739e02b95fb4d8448f67700b2fd669d799eb9b224506897dcd7db435c20778ba1b0a39deb73bdb591d04d067e06e646db4192f438399562822bb616d25e6e9fc69a094d3caf573b80bb587f56dac940df2c38b1d0b670ecf4d2cc034933412f3b0e5970a1dcbe29c98acacab4b81e6446ce14252435c878678690f22501579d5fe1a1cc63c4a705dd807965694e8ee82cabde824039d7769c565bc2ef6194500c195865b2582035810e300f54161ac84881f610938f6a2c7f1cf8994cb750a161511b8d0bd849b23e78a10fa06803867eed36af56c10979348480f26ff1e877bbbee9f85c2c2b723ef061d666092fc3ad1bddb31b7b987fb8259fb98c4f86ad861f4df1a45606c0bd1be31c59b4e8ea63a9b416c81bf18a1ebf4a91d5c61710cbcc685663c90266db6d67faa54eed09fdb00762a1da0292a29cf34de997161c4557c3fb2e0b344bd082bde791e220f17f7155e7beb96f3483a625bd37349760b394a588f04752ce34b9978d7d744aa440b549418d8a63b5ae17fafc9bf5f3b091854639b31682e4b92853be1275080115dd836c853194993296aecf57224f0569cc6ad4ecc48a34a7e74ba232d623052042cf89ef2dfd4716c5fc41d4998a92f78d715841ceeff5e222c523235f240aae100f37205d26b00b6a85426693aba586768ab7db3bcfdc5fac1bae9d44019b56a3041f1b1704d465016159c4448e21a2ce55ef8dcae577ce5943233f6a891bef357f15b236581534999b8d44b1e864c0b59ffb84a3b8190af1ba36d137de1fe0d04dfcfe5626841704fa1905d035e0ad61a889e08820b48fbba1af5465e52b6bb1eac6c32211c9be5259b4f84334ff0a4e33ec38b1ed0449fc909810f55f41beaae3cf25cc810a503d52c5310afa4d70a81491628be8f0281d9813fdf751ad01c4c23b526f8b13195a74ae17fb62df8f2e2a91c7507b941a3e53752b7e04ce1788d15be01612902f58b42ee2858bf509ef1bf8fc3390329260b3ecaecc828294f784eb9a9f3e322d41abbb817d66cf422c0c56185658c2048519b8633e87f1decb408f7ceddcc4732f8533550fc33e6071c8ea01ab613fcaec73eed875e6a3456e64445888cfd002f42713a31a9ef1b954eea7de3fae650c38ffd72e119be3b2be50808b7bdc0ad5fb0cc38779b3d6fd42a17a8431fb0951f2c4b43382ceb553643b716e04de17dc225409ae3991834453676912b61dddf7c89bd59bb4c85c93ca6ba13debcf9a26b53750d9edf00583fe0f2e5e0f79543e26badc5f8d8dc230e4361dc5ebac936525153656fc8ec2caf2ab441e0f3c2c250af1754735139352895f746f6e87c1d3dfe373177b2cfae319f50081b3ae40d98e7f3f6df1424c34059f4761f3eac6b0bbce72c30dc771ea0e48ad424b754a8a3d8b314364d54ebc6ab1972401c889578cc06d0270cdef93d6d934a22e6c121be287782a0d36d8fd13c6d7523ef6697089cd32c715d191011a643aa2e41d35c0953d2ce642329e71a580f2b8eca920d9acaaa2587775b6ab95f68727802e0127240d640c04d6970bd955f5f848d21ecee09305998076dbbef403ec0fb4ad6b1643366acc3061773203427cb53a603e1e47ff571f154ce3bf0f70e205d1703bd8e4fa55d192eb3b8c051722ddac47b561ae0aafeb036b7892d3f2a95db64f0481d20a738a782564a7da139e29afd8674e6cb2685f2164948f1b3096e544907a954d07d790a490a23e667d2f1bd46254770d94a906cb678f023faa2c3e1e533755a15023ef27b7b8e411ccca711ba6b21d17add3ef787a5a0389fb190a5f861ed0351741071990e0553bdfe3f578e222823296f5516ab0516d00b1fd5be3f9c2521499f857fb7bcef6cdf0516559bdcf06439f73ae2403e7bb3b7b21f66256e4ef0e5016a85edf09bf24f3700e03541523706d2de75657600005ee0b39960c5b70ced1f724ece550e2993305f5b18756ab20e00451eb29d6a2bcd45ab88960a13f7568479b8a230150720c4a109bfdbfe5075b084b5b6e83346a30f32e3c824fd187c96f6c0e3dbce0d94b3c8375bf648ab821ce138a9c872f081b0b4c993840c1fc2e884d837f7aebc8745ddfdd70115e6f36ca7078862db769ece098c8cb287ff92fa421975e58f844792f8fe2f9833e6d2c702b6e60f0b67fb61ebf1206ffc68c285c96e923095a943109c619cc60cc8cc20792307f88d97c50d1430f8bb260b46c33c7dc16914b5aafcc58593da54474b1fda6bd3a60187460a9fce83f443777f03618c88627846b7aa2e350494893f752406090096ad87e61d9b62bd6d6455bc5e7fc3005c5b018c07695b4fc6113222693832b123a9f90b117822d1d1493aa9a2e7394453492552248330d8d07b0132a970be14c69ad6d27037d56fc9a8ba0a1653e2eda06746a7c5d9c6cb3632b58273ac17cc57d7e1a7d7df2507ae83a5eb9e95b72eaf0a343d30b57306483d948400f75583736ee9840fdb4f8d2c519ae68e5c655934ff30909f60a86e591e2d22d80e15c44b6f2331f915db7c18ababa9425cad1021bee87e22f48edee8f5fae430b7b110cac823a50ec65599677f099f3ee73d2bac2c7b39816493622e6e26c1afeeb80319d9f77e9abaf1e21909a21515b7d858eb9960f78e8cf51918f6b3f663dbfe40bf74807070488c8dfcdd0dc5ef61ad35b65fde519adf3e04a32f3572730ac19dcb893a9a94a989b23cf38ec69c46e0004010fd19c9d4da8d4f824adafe357489558687957046bb24d168842e413b109c317c82c22e534df9acaed27a78877bd9dba4d9f6054ed404d8573bd9b0bb440423ab8216b8d9928a0e3b05920836511714e4f7ff53e13dd2db8c75a7786c968539b8ff209551f778cbae88fb044efabcbc1b2d39991840b8edde408716042e5f87611cfbff84fdb1273c36593319c5707ed948f95249e3e79c66ca088f21b759c3018283834beae0ef7db720f8c314336d8b6d54e5b82f5d10a756188929df7e8aa928de0a13dafe95e5305ab8dd07431bd2d311824e1485264862cafd00c0fa2b6743364792f5e6a723c0d34a0e4b9feeda3bedc402b7333dd537d924fc5f67cff34950c01ef2ea2dcbd9bb5945f739339aaaea7c11d7458bb070f58c0e65ef3c240b1f39e9e6126560e410b32c5b3909ecc82d993bc563ffdb8b77b702a0bce3d27b25638f76f406d90a7415825e4276b5e569eb700e6ca070b33f217c4679f032a127e9c3a29f239d38fc7339e838ea8e6f5f178709682e8bc565835164c602c8a1c99efaaac46b1c7015235648e501489f5c62ba4dec5ac75b77e9e97a3bb1206f9a19bfed08bac0deab3f7fa025818efa0bbc5752115615ced69f3774caaed3184064a5559d9c3ed89e9635dbb779a5740227b5ace22b9f54e29a7cc8debb05a466d4681012fbeef2536b4b3222bff3ebc792a361f174203f8825352960775941a0a0e7d1df736752f8a6e7b8161addbf74b55ce91e3dd1f687ccdaee92401a44ab7b62265dcf2b2428b4126cbf8fd3682543ef6f1a088bf46a8b6e0edc97a6f2cc22aaf4c7fca4a528fb96d29cd4397846807a5ad6c1e79849bac42167f10dc21b7bff674aa00771349ec6eeaf1821fb2b7462f8e60d6c862e1c1fa0e2d80f54173c1932cb1e9ab1451248b84bcbbac88227b11147498ebff37a635dfe6f22d0fe630ac7d68516041c2a1ea2ebb43c368c651f3f146c9a37e72f0beb203c36624eecd0bf5cc8ee2cd4df25ada2405fc2a808d209e6c81e230da93db654b4dfaa7384a738db127629087e7652bdf1bc1066e6bd91b5631ba693f133e9e36cd0c0269b0e19bb7bf31538d66c1d9fd39fa89e7e7b6ca680e978a004842f667ba3fe25655082b9bbd0a4ef109ab03748b2d20d8e711d1853fd437de3fc3b66def367561a79c2e042c51517551e454a51ce31726581821a227993ee65fb3d92bf55a50f991d194161b6cfc3de06af02720ca024da07df5ab5cd920577a12c90e473cf00c17206bc124ffa18184d87f580f9a985dd99903c7d3cacf6408791d631fa821807fe9a2b32f80dabac54e6157178e40ca9782adecb431298edc1b41614e4ac1e4bf03973bd249b18f834cb306bc57f65f89326181c3cfd9261d75ee8bbef4ab6149ac68a5d9dc0ae4d0c282d324588fd778610727c80532e54ebb5afd3534802d6a76b532e8b6726e49aa7a6548d36702d29af2366db3ea8aa6e769cde1a006b0faf743eb26493bb15fea6f8ae0cbba7332f022d593cb2ca14af8537410392b31e0a85fdd27a01faaa378d7912511815559b4a9270c110dcb898b8cd7909b1fb2fec3eed690ce18726fde5918b332ed553fe3b0a23eecff3e0e9897e8ba382e2fbbfb376191df98595eb2f4eee6489a39ec0c3c43837e81d98e2987164bb7b5c8a8348967b18962b4d7c3045aec1df5e87e08ca58b90788471a22768ce9ecbae141ba054e8bb568a4badf8721134bf9b48153f2aae521c481d9a3fe10e721861317f217fd2e4cb879957959980201f44839b0bf195b0efc10acfab022310e3bee665f1e626161c5dbfd0f051e794b18c291877f8b371a553520722f6d767c25d48f7237714f4a31e51079ccb09cddb1f3892e73b2f691d5ea168449a87b609714455f442c6b17408e16e144c39557fe6d1404171e67d39c8adb2c511f7d14849f50286f1be39b09cdb892dead6a61ba43ebcc81c71cfe7f72b17719a1c8bc3357fa12240e55ff76e750337a9c173c825e243069201183de7446cd32324009c7443cb080b5623041182cc40d0673e41488a8133d6c4c7720c803f37ae77508b959162bb30cb2c1c50396658e7386e2e58ed9951d485e49a3be916e0db510e2c2419d2c743b8667470c2fc955e220879ecd6b1bc8a5d57d64d7ba9b6123be173f2838deae1f80ffdcae6e529685d029eb8bf36a5c055c82fcca9116e58b23839889325fe87b284b0cde4bcf5fcefdf7e38bf7846ae5f2be8bd213394b24f62d0d1c2671a0dcb0b1067133930ffb9b78d8c7e86cbbb658c204a52e37986fa2642b04cdad8fcf208bb81c2c62a39f8b1a71afd9b3d10a3715d2332ff43c7107db891d5c42cc0fd6a98a2d513057bb40758ea8108c3acf567ad09df94dd7141f941ba608566276ebdf23b31df5df40b214ee8c4bea72b9d2aeac26995e268547b26a4b15b4033be6fc5f141ab3846aa681cb2409cfb7a38160d6101798922a418d8388b7bd9ebe823ceea6c643c1f6585817a5f95214e06815f2532e58e39c8d231712c60a2e6f785bcf12ee2be215a914915456c386da2b9712db559eda05a2c17603444b2e76cee53d655c858a4fe9d353e8699520ebff434497cfe18035a72269a547692ed31f416bfb5a2f5ea4d1f3ee1bc3184b0c96eabf01a642b51f7ba63094b7be04831dbbcfdd79b575418f73e2f742a8c33cecbffc485f584af9ff45e1b2865fa6f892dc6b9dd3e1e8fb1b9717bd8c9d4f9ee7a36c373b6879287c64c7981778a3d0c68fdcc46aba4de76414561436550127bd84cbb3f8eff014ac42fff57353d3f265d5240b3f3302ac473112feb308c2d69bd73976369207f29ec1e1dcee1a482c32308cf32d016958752c065b9aa7cec472ab76adb7a749ecdc868edcdf41f13bbd281ca2873fc2bfca4883b29eb3b17c2163e8a31ff359df8638ad6bbc83be2a55cc77f14fbcf9a960a9038305dbc7a96dc9c0af7c32082af473b061bbff625b5e88ca5ee251c7134eb726719b73235308b5d19a9b0d6ebed972973451bcd15814058953ba91313c5f057bcfd9f76c8ab0e1c258f3ffc08bfea0961e830b3f4aba7517798b1837f1b1697e1f5675d93f954231a7eb4b4e47d16f4fa1c536705182ddbe065591f9188dab697d2a16e2962c20ff23e365d67b8315b5f21b27640d3bebefd98da0d40966e3d5a220776bfb5e2ca2a86b8c3c342054779c28ac0765ec4f791c4bea2523418cd4ec4bc580934914702996dad49ae9441697352ca3704fbd8c1a0644e61010aedea60b3b94db41a592837f7a7d9dcfed666507572e08e13834e435360a763bbfdedd2742da3d1114d4e08423f6516f23a43bac811a5b22158130d689fb4144dd600cd627657ec71af07a7f357af3bdd732cbbc6c867b32d75bc5df4d7c00b1c117fc8d3d01e271d62eb0bc5b99e19e06d1da9b1ba46cc7cd2442add638d37072bb100a03021b2350526d0a822b36437669b0ddc1ec903f6213d428056e79052a78567ad71503522d6c2547bf25dbfd40fbb55193e0fa249a6ca21a8e7a2381a0cab443e2408ae4c4a54ac37f41a06a112504b2b5ae7c7ee48d62b18f5ecb19eb706b7ab545dabbc3c9f614f8b3936f1728f493569191fa1f8166b930601403ae527d838460910475af7361f5819c37b39fd6ab8432a46b248d3ff2ae691bdc6925b6b5e8ed5ad8d8d402b2fa3ea1d12471e174497fa4fd400f3d767699ab8753c1ed80f3845fa118275871c5566f3ca7b5378ab5e7dec41324386e855c0fa45c40661a633f905fb78dfc086b163b2ad75332f6985026105c11ab87785f4a1ed3c12c872e3ba5ba0ace19503cc8e81389d0063c0f9478791b9daab4a3228c64f7c04835685c1f5332a4735b4cafee56d3b664ba0eaa9d06a46fd01234d8762a014bddff16f681a9c115297b5aa5fc41dce1b1161b837b85e60d0928798dc4bce4ecda7def8b66568fd4e8d7a4fb5e68c65915dc89ea00f926fc30cb72116eb615b428db096ff2863d6f12ad8929da97ac4005db5886010c5047e312fddce309d8d7331f5763ac475d9b731d153972e5acc6babe912cb54d78bdef6ba295c3bb2b214fe727062d61441df4e9dee78a04a921f461b7bef4abd324cbfbdeb878012aefd1fa7513fa86c265df7d45a5edadd563a65da60514cf1530550ea86fda926a4a1c826f613cc1380ab5e79584f6e54d7ab97af6e6434de55ed0d3502ff832a8ef7708c79fd9db400e4f23c887ebbd4ccfc23d4c4b7578fb0447434d5c8a3be8ef5b9a16cccd78dca876489b4ba7c75c42e7546e1956df3e7f1e0feb4f6eaeee5606b8e612d9177ca5db3022bac01ec963c9e89b95a226f238a6e6f9746831e792b361f2c979a3533bdb6a87cc0747b41f1da178b9d53f8ba417d825d552788a0b365b9ccf1218b4360d3687260592b369ad0fd7ec6813d9eee4b44af6e04068c2e60be9ed3fd4f0f39ce923bb4e539a58ea5105947b38422bcf733d944640668f439c360e7a81266dc096d16bf01ec87f7ab9a4a1f7174983fa617469918ee2cd22dd82bdfce0942e2557fdb78f4f518ff6f55eeb8f998767caad33183343ac5ccf271f7ef0bb769bf810da82fcfe410878f9d70fb64492a85cd2d4a1936e68a40c646c0eb152149ca2fa5a1bf9ad9426be7fad798906d6bdc860f6d1ad82381329e10b376fb32be0b4c9305537929fedbea87f5f82794111323d2b249b27e173e763699058a8fc41a5d7e8707cb1cbbd78e3aef67e6b8ac96c1776faa4cabe2447c16b15aa237ae29f9ad2af7427e68458be6c64e2295149cc67d02ee945a7fb82bdd2521c4260befc4c2dac16c0bfe96e966f9fc9166b9af90275673e1bc6b1b8dce784d35d3713de89316815c3c4384e94ff0c50ff173202528fda594034ae50b75352c68090170dd9157f9ecc9935910b4e2e2cccf4833694c13c2fc0275146dcd5671e29e55191cdfa2044fb813f4f6d935c7fe716047493958241549b1b9826ae882af9c0667ae41ddd21561ed831cefa8b1262b43afad1d63dda389954ba7560152cbb73dbea4e1f81a25db5df69e4e1e23fe2a5bd3b9be6660081884cabaeedf063f5fa6b661c8052b471563f75632a117d629b09f92a58531a81d2c6424195d426236b7daffba2e858f2c095c76d8a5acee0a775cd61826556f3a4d049be31ed28367109d1abc8ae34a20608012c397ce49b8a921df48aa887f83871f8880bd424c1b3634b7b94eb4da313f47ad91d82244c17688b6f01735c52ea8ff775d86385d06029380e6c895d6e6407c2bc8d6f5888451155c7050f7ab72f92aaa4db8e94216d44b29c223b97588b03b30274a7f24cc9d6d1eb3fb82fc6b1f5a84a08cbe2171190e52bada218920b1a6283a19214d59a9acefd80e6efbbe7cb9421e08d3879f87685cf1c6e583c455d150e89f2d63cef4452f8bb1af938dcee5f83eecf4d34777960f4787b3b097f71fec14b3e106b6ba1bdc66f88b87c2d02b78d2e71a1710fcc49f6b0c682f8ed547f9ef29d0fefa96de88064cc0970ce0dbed566569d8b6d7628850f2a35f3fdc35e8b6a9f927bbcc663cdf6013454d49d71412f663dc81363d40166f5616d3ec41f70fd2cd1e9f90a6d18c4d927dad0e43fc06dd77341f4e7e53b639346133bb90e950e4aa0773674b8821489f98ac5cfeb2a398bbaba71a5663b5ed001a103df72c9167ef89958e29dfbe4c69e61e702190954764aa83a6a6a7541b271d35005d23e885988ba416f0009b1b473c59ddf1c58d6c988c7ecc5444ca1b956b18064b312fea352b14c70225fc388a2420bff5b2d65b8818a27814d4a3d075ce68ccfe6971dfba2560931e930e6b27dee9bb0b883a4f8ea29b053681f3962674ed3557cbc4b1119ed4d50c7446bfe0da975d399862dab972857f547b24200391ab9012de4c3b9af723d8f69d5e43463d458690307ee3bc4c6fb29b7663a4b85f19beff7255ac510e6e8e0d781bcbbb744b3bddd46d5bc6e5141a9461e85d92d3ec0a298761ab93f5192eaa4e38ca4e3e21ab741199e118bf31263960187e83866cc35866a4e8673e5a0152d875dc84c9e2bf4d6d6c8be68e87f42309416449d5758d2aef28e2cf6149b76d9ed17366f9acc045ef640f407902f5be24c61c296f9c349521aead8a737e36cc0e0633efc61ba7972a2a9f64909c78ae28046ee70a7335afe5edb1f7e33c9290ab130999993ca09b891cd1f695cd4071ff347a047c610c5274f9c037ca48a11072fed078ca55aaf8d4e2a92c828422d288012991569c7b401521dafbcca4244be3ad128bdc0222389b3f3464c269f42559109241d148e66532a50eed553af80f3309c890bb161922ef9e0790fd609d818de1d38963dae5cba0805cac580949474656c8bb20dcbd9a95931866f77ee480509d7c74cac209cb138665a79733a348ee01e0a24e172c477194d8b1e5cdadc7e853feb8c582be27d7eec348c10f3026cf2bf438d5583184e52c876fd1387a7c027641d9895da7439eedb0ccec6f0c651c0965ebe13b6edb302b72869283607ad9b987ac204fc5496a6b5038d0cb4eba6f192dda9afa4e6f8c6c1d8c9953f981be8c95ac91676fd424bc3f61529019e8ad2e859f8e5d85127169026a8244ae2e4713861e321657c6202cc89d5a0d5695d9bad8ec52b4bd92a503401656fb26dc2f991bfc36803ce2f86e725231788a2f9512111b88e71798b8123017b68563229a3a8cdb9e532aff9a522225f1e002f9f9b87aab7c0a1afc6a547a4f447e6a34b2709e64a284fd67d5362c1887515765c45e4d5218dba63e6041ad33a8a4be938e5662ccc2a8a40fc22cb5deb3fdbfd3e3bc3352e4feac0c890e67f41275e354afdf303fdb0ecc32cd10d5d937c29c9f0915382b8c8217d6917c37588a859584b0da344bc8b2c514140280a90f4ef9b8ceaa238c0df77aa1c38efd03f4218c65d57384eb23a6f5e74aa6df3b82b34f7a614b0968eb1c2260da8278f8c760a055d7142bf95fc81ad0b01e5e296c288b8c12ad193493a0e5bb12475d58b6b8757fd302fead506ade949c285f451a7bbd2e40ef33e415dcb1641eeb071502325a66a6396c62061032a3802efe1f4218c06aad582dfa8af262aaac036fd12f519f7694d71bed340886ef657f65e4266ca1fa841842adde4a865dd61c863cf2dc02595adbb59e31938a2375165c454c583f46c32e3d49afe7179785f3338b4d8cfbf2f27a208f96b8090f8acfa5697a2d78b05342084f0f17376db23fe9bdaf891e46dbfd5fa0cdd3ecee1e22f2e76ce87f461805cac5c1560d17fecb5f28cdf76f0d526cfd00cb20bd4dbcbaf09321a6a0ffc484454056c73503e778c535a4c913f5e6e1cc6cdcd9403d71d984adf931ecd2c37ce4ba832a430adcb570530b2e0f0c853eede8b4cb5bde84b6774ed2357162c83538076b9a7e8f814578b064fc0470e01ed7019558ee1904910a358a2f28a9aff396151ecfc8d140bb534c2f15dd0233d7123053c1b00bcf38444af4af7ad850e763f2817d9d3ed3a3ddf3916a354c6154ba42dc406697c3ab13ee80d9be80a0afdcdadae7210a99df0c92a864c28a1979f71ca05edb09f95cf25a3401eb0dc462bc878152d265e9d620f144cbd6bec60bb76fec5a22cbd495985595b3a8b2fa7e93e31deb551395f87321b4bf4d87da2e92fb6485af7139ec70d07b622070e1e8a11f6f93fccf44abd1ce8b5a1187539e94be5182d0ea0242f65610145a70ea7ccb7de798e1caa66164e8a7c38700ec30fe4dc99cf791dcd0580bc0f459ff2e1cd40aef58ec529fb0d9b1f3bd353ffdf37d77edc3c5ab3ba4a0a3039abf81c2446a9b9a554a0bfc086fd2d0a1beb5dd7412669f06d624849d9ee9f29981140745692dcc53ea7c48d367f766ea96b9b763822fabce7b78a50f461f148f53738dd3eab05f0432d6747aa799a349fe54dfa7c22d74b2c0b1e602fe4bf9282ee49f9a320257b5580564d3afc6fece314f6a969981ed787cad48e4dda4f22cb29ceffa4c36443a463d96d73845d32b5b478d6eb8894fc5301846312561c30552d6b7b44d40ca926a813b0720201ff07af899285f3e5cbdfc4b921704ae8419453f32ba45e511dcdb41e5fdeaf2610abd701515fb772dd4ec9759e0094065db170f3a204a5e5412aeec089271e2389a827e0eccf139d085fb20efe35ff551919f766ec74576b3591e2e79e9532a6e93a6a0473fdc75d4b910208534af52e5f1461248c11e7b042223aee335a089dbcdb4c14b5bc199104a8e5d21e03f0bb184e167411c8beb141bc5fdde16bd6daf9da5e068224b6d26be6055d9f942b7da3ed941da5d89b147595ad95027ccc093351054978103b89e3703bfbe76546c82d8d77c7215541102ed9ee28ab05a2f179f51bf3c9349e785e230fbff732a1d50b44fe04aaa7a5361158fd9adcc922c369059cf3c96eb5734bf4d166fe5a29db0bc59efbd21c9cd5e8ce06d74ead0ac1984f6e7191aeee710fd0eff5de2fa3d8d3036081dd9bbd8364b8e3d4ea5de0d199045a4f78843136d0d74016ec8990b2832c7fbb866f82522feba8c47b67af064d527ce542e102a404c3585fb7fbec7c0dfc369f6f3acb5e058f2689f7e852216be83efc3e0aca7a3fedf831d60a7c43efce1905f15d0f211264709163428dd77ac427daea49d2d87a235a73f077c237645007514f3a8d03066fdb24eae6634019092c327f8d0b6ed84e312efe9b0eb37c1b83452635bcee1d8b11c0a3f69d45636b5095aa555084272fdc34eb44830b972cbb3bc375ab1e8af147dd738da47038e688f2bbf1be5a7c57968479468bfe79397fc1aedf4666a44f859692727fd5661e41013121d9f0ad30c5dbf048fd4dc584323dd55188292e5a49b8585b973432e1959edb0595b1a069d2fd305b8931170e26fea309e67ecca21c24fce9f783c0bd3e92b98480c15f0ecd44ae49c448851596af9e9f370cf64abadae93c8ad82068939a35dd6213ad0676b1a7650ecf68ab81a84fe6dc5d9757a4014ee1175d5d0ab6d92af648bf3382f5382e732af57edc4117f51412d01bf5dca89e74984b0f0b080085b9aaba08cb5b27f391a20b31cd5cff8380a9d8c84a319f7a2e5898eb3e7ac3bd0b622b1b9ca64e066f3053e17c02a440eb95fc6e0fe450fcf9a2447402b40881a58ba6712ae13df3527c90b0bb070b6265468d09cbc657299ffd429d42034b8ebb654917de0c2103af8e6d32908a734f81a7aa453d692396af2c5a1e50e2aec8ac6490aad63f43de107053a5fa7b0ce04c5f2bd700f336a7c209e147769018bdb70c40241a4d7ad2452ad079bc75da33d7df394674db2a14f8bf2fc2fed2ac0d6a0d1edcefb81130e56741824d57114e7cb0eedf74729fb0be4bce6a54a276c7e0d3603d9fe226433b763713ba8381cd33be48ef64e3062fd28d4bf16b6e5ad52f6edfd4e9ac17a8d8677e6a6b687d3d6365a5e3d49b32ceed21ec1e7ec6186811b53e2724777fd8bda0c5a5bb8f65382716380be47f94ee61b4df9934aa719c5a8ee79b8d2a6e8606cf2c378a4a8661cf932d4bc0ec0d37cbf0852962ace3e147c0ce39429088f538d29e9597d7828abc5cea8cd672c0a4deeba8db077f0f1235ab23b4585ce110b929328a18432b12a7e6d11bedae304321453ac00944ed79eeaee3e5c155d27e38f482ef655972c5e7371e90449847542727fd04f1ba0467eb22aaa1b622f2cc33ec64f78ebf9c8f3d333f1f98118a9366978caf2cf1f7f6fd8bb563189391b2dcac4aaec457c9fb755100c8c1102dc640378fdedfe5b486290241e50dfa8c5b88bcc0b1451f9c9adf7aa1fde457ed2a17035a57f00c6ea8f7cb663cbb12ffbdd387a6e04134bbdedcabeaaf9e6cb1a02d73f57eea8c3bdafcf01d09604964b2460146e5c1c5ae9a61696af300560b380203f44961c6963052ac05e1395369492a353b40d2da758633f2a48d75d3cfbc9a67b754becca138f8b8307e7a17705c999a01f25fed915fd27827c3275267e0743c055bfd0b1e0deb5f6662803f69c1748ef8491a8f4d00b1cfb5466ccee19d26723cf3996cf0ce42cc2eade26dbe11089944e053dccaf9326a33d8ca8da1764fa32cc166309cf1fb9dd1b3e1e0114967ed8444031bbf132b7d49d9726b1cd97c3c55aec6f547c06fdc9f574589e5a2ac66d4cbbe1d3300449f34bab9ef4b28065cced4d2219cc6ce90c9d6eef75254fa61fc1275585fcac53b4de5453d1d4f0e9cb3b4a10959c112e1c78d189f355f05ea6f4650f8f5c711fa57b67c16e72a9f05a135278c4c7bbfdd57912ba99a14f3cf25803bb3dcb11a8037e1502d2770f898824deb6ff2d10330ddf07b4e3e2bf1ccfc68d9b2207ada82c6f9257c802209c8ab015f2730214aa680b3201681ec6e83893a0909a765611f2feaee54973a7522c19abb3428bb6d8b4825ab10b8be1defacc8180e906ffb69289b4a6fbec9539695b33051d02533258f357532ed3402d867d9645dd6072600a29d2838bfdb7803632e9d92bf9895c629ff0c0138f2f6021d504e4e7c8eb41c0abe4eb2c76606f499ee8e8275a3f34283860950dbd4ead3b09469f35b054e01a8036fa93115dab278f2e3a7fc4cbf1295592d08401c4dfe42295c33cbbbdaad65413f5b1e76efdff9b260044bbdeeeb9d92f87b4a67ab480dfd98063ac73f9a501d844f0c3fd45b2616de2d07852b195ae6e8ee4f0e39506a6f14950e22a30b7c796a560138578a62d9413142af2dc095ead6877151715a74afb339eb1ce293262de349ee6b2c58d4a70027f5cdef12cc97b062d5ff6e51d637e3195797d5eee3f723c785cb18bd3453b81cf2d531162f73ef1751ad1e30d81b7680ee738b4e3fe806e8af0c67ad0c312c0c566e63f13a0c76ea8d78ccdd3ab5cdce0ab9d485c6a9499cde418696b4d730622dc24868e8c2b58cf2ded7a8768494613826d54989710fae9aaa531cdb870e3b7386cfcf7e574ef9d081543350d73055ed1d8eb0740ba73422f6d31d74f23536b8c542aff52137c4dfb35b8b7bb8fa71e0d31330b5e3d63acd94bb2f09dca291fa6454f8141e7fd2da8b3a74f6aa337e8325ccc9032a8d365a1abd6745e0751787876854c389ff4167a5dbce5337ca3fb0f06142f6aeba7ee3a1433013ecce16debda73b02a258e0dc3bc683d77f6f4dcb21f7a17d4f943583db6b614254332cc92027826fde39b27e143a87ae1eeaf37d97a546fe5bb54820e549c2874195544a3bb71a69ea275a448c3908a7db6afff22b60c976b23108d3f1e980a1058ccec3d5b70813b9da47a06b8390cdd510739aaffd079b27eab05e97589211ce0b1717f98a300fe9c9ac3015d734ff0ce0edcf31cfe471f33abd50e48f227550700a88fe082d69437151764ae519fd7a2417bfaf0abc6cb1a88a6d2d716ab0aa1d3a6998571ff485d3133babaa051fd1899a845860e25c6d7d963b1d3ee82b5df59b3f7230481e112de02f9e6266b42db28c7bb8d048bebaa715882d21e9e1bbb01bad9a962f957e54c6f4872f3614e6036a18e93372e09a681a7e9e7f638ecbc331278b190fd91686b21b69af31901887fc6db575340fd1ae382fa2c2658721c13cbaced71c6970510df33f872e186e70ea985003ded291238472ce91b0ad7c717f25edc9cb0952f53299123355ab4ac4c027dab4f75bef1a2ecb1f098b23fc72a654b645ca893b1a2722feddf05115d4dd8c93032c73175b647bd2d900baa784a95fb7fd96ac6db90c2364cd1a17d29495c4b8af0522a7042fd5a839077473d66a761d63b4b2858ed7188cc6a5d3f974ee59b7b4db69fc4a4a723f631eb4f23e97b9d40380afa9670bcfd7a1887a05109e823946695c13d0c134a03a666f54206f3e2a6fbfe5992e41bf9b2ff270cbba7ca3d6a9d9c110cefa245a665b6bb062c4db7ca30447a19e7fa67d25eb6804ffb97bf93e704c655cb06335810cdc8138b4abf13a780737828fcd44470c3ab40325f3ce01b646b5b9ebb5f161f2d778755146fad14c7288e697b9beff50f6937a42e477236592c819ac5c9587a7027e4ce487867c3973b6a9edceb010386228072a8683136e994ea3ff85ec73d9054c35c4e3041f33a25078b4890f9d7c12032e7276d37fc9a2dcb738d65b1349006d3453ee5a4bba7721ddd2c8fe8192715b024963d1685b4c90ca0a75de1be5c3b5bdd688e5e909ddbbc449e0f1fdeef14dc2b56aabc6c403fde140ffb884cde78c8f33575181127b62727dd8836d0553e786bef3f635dc690decebc1b94fad07a1fff3377d49c474e497a50d43e1fd189a2d6fbeb07f23f399bf96a783aeea53a758d6bfc02826c762ce1901cd4bdc8a4704d7f67359714bad8677211183d7d64d30a391b8e39af5b51ede765cfcb8f5d31495a4cf50f4161287d409b2c0ca00c014b3de53a0fc2d3529f1e33db361c6160fdd0dcb077e3ab22eded64f07811d278efa5e99f8e6b4e26a5c8c36d023c7711f56035664135b32593d8cb5cfd119e50c251bbf58ff4eed1d98000a57759e2a9b9570a261580607f4d4882dac77d8e97286fd2bb3fc7c5259160f77e7571ade6f926f0786d5f6e4b4f09849546f7e0f9ca3054abf8e66feb64806145652815384dda4e5927f35c9f00c60806004db93e97e7283458548ee702cffc2dd3e635738e4ab859b65e8756d4574e3d34573d4ec8e0d7c2a62d0ab88074bd70be70a001306a2f4d47dcc6e6c154c19e1a9311672256d2d4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
