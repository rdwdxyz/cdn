<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8c0d076906cbe1cb83ddac94ef8b51c8fdf97066522ca9cae7da55f304dbe4cbb926ba431befa80d7b5862b2c53436c2b73d6028dfd84d93b730fa5f27eb39d8f45275df01e175c7839eac89be7db22f0849e2b55438101fb3c9b5a8a0d9d67f3c29d29d4db37c9980b1de3480508b83b969774b0a85cafc2bc55768289e330721addc28ebdd211743306ec944ccea5b55130eed47711e448d183346c63477235cfffc4113646f4b9e42840d8f47c83deffbab0f8dc8b68c9c8d1bc2789b54adccb129cf306b09d00ad91f8b99dc9591877d0220512535a6e0509271f69deb05d7f5bfa724d0d9e076f80d6d2c59e8be82965fc4a9b1316d23f9ca1c13410200816de2ea14c903b110f7f2aaf2c1f6d16963cb5823e6bf01666e962845d3050c6a1ace0e360eacfa0184aeb993348d4019370123edf1c1a11fb60ab6d7e364534860a690cba0ad02bf1b45b359e6a3bbaf48f862fe97657291338410674096f4f675d14ba1d732c7ef524b11e5af796716a3e943bfc7da03ddc7bbcb9c1092652b6ae73ecbe66ef850ee90cb041829d654cea68fda344c637a87941a178f2eff3384c8ef4b9405d9a8b2a56ea02da9c3d5cde78f49710c70312514d47069ce9858ba0b470511f7ce9c839aed7f93e0e97897607fbe00e064417b747b96e7144b03a68daf57a606f3d59e9757c9dfb3a0246ae9a504cb02710add7312dbd4a466b9fbd1edaba9471c46add01d375c11dc3293afcb1d32164f1fd53f2c76ba79c49648eb5556e641c23bb7c5ebf61de8a8c3d46cf2ab59f14ce8d1cb16bea4ab30c850b12b9b73105ff7891a72f05efb8d211103cfa9c9841404affa5afbb19d3b44b8ff023a2b9321b82f9c49e675a6109aa61726216d66bad8d662a1c2c7f13ae6b8dc712d059f71d43d486f8b97c5919be25a5b986c5333f5424952f8e65f1f062b1b7317fe11b37d36664a93a8e358738b7575eb5d5b34656b57ac47ed0593e189f6851063165176bbc8e89bc222b4afdda32edd63ca73c2a5b23450c69a2c6ecda5057459fe83c4ec5d04eb61069ed0c5c402b939319e4285e2c0016a6a5245760bbe4118a16abba699e6ff28f8f26325f915893e9fe100e6a00cd16bc2e94c0dc90f361284641b932cc667cb63a8f5fbd4b748e3b70d6f754709395bcad7e6aef550213213f38f0569a4739e8dbaaaa5e72fd95b5d2f56f6645a837500ec26f71961319edb69ff46a7b24afa00bc1299e34cf198072ecd71f1d032c0ca2109127ceeb111737487ac9b003b9b20496b2aa7f2b286a59fcaa7a977bee9188d321fac2faa8b0238ad2aa62eb165611104a18b024d2b15ba741cec6747ef4e75f69a46e2c4cc00af22e19988b8a01b7908f4e81b5cc32d79e80c0950577008847953fd9d9b27e47166e2421ad01fd000785dc5cdc86f8289435eb260bba56ff531a5ddc8cf03a3332b1c363a90c79fb4f2a063285a04633d8e2a0f756754c1712587ebc24c1127d554a22caf66151f1a77299da9f5ec4c55bdb1a9211ba893f95d996ec2a67cc72943f4095bcc39b8b6bf8a035c4a42d75e5bf6ab132962001dd7990f27ad221bfbe7c6421e0447bed4b8dab7105c4965a3b9ee9004d905051f6f42f62dcc675a532703ae42f179c6259b927f1bd89d2b114ee8304afbba03ffe38192678ba0ca34c497b59b0dab29ed698c906a34eb1a2d7984f72799c988aa1c3020ae4376b0aaaf6d73ddb6d23b7785fb0b5814772f48545874dd1d0769d631afd69a97fac212774b70b24860553b23c77c018fc53bdd47fbb1dee71b02d48609917fad416016c6e29820ef15e21c367f3da72cd78d53c06c9076b76f6342d2beab5a52e1a5abd88cdcf8fc74f6f44965725f8326ce8841cf7db7ed87c7f2fa009b10ac46400002bf18cdd997f740f76df6a01121fcf2d1d3a82be7a38bccdea124dafe355060e2f57fc30e271d22e5b5f05b51d78a36b3633a18ae294c966a5f20e745d01229bb8d1a36b14c7c7bc296a1979b9a97080f10a5803552e8e56c878f4cc26ad389af6d30228aa9f9071e6765f4527460bbc010568b6c0eafd177561baee345466ac8528aee2af616e34c620b92544981642dbb1c72d9b983c0c5332f0cf3e3a6c4217e97070ccfd6191805a911f1f3409632703daa863572aa2bc19076349baad666158c7a9caa6cb982226342866b94228d485b97a5d04c1633e0b5691e1e3d804683e90b26bdde502d36b07bbab68431d0b485dbbb633b36ec84f8b67ba2bf1bda05b4d222fa9bd76dceffe94027b18e488d666e6685c1b598157cf5a2e9cebd311b1e66256651c8bf3af06ca02d64094a5804d6bc28c5021188c3a9ab78153c7f1b522434b742778d012a78dfc2e2a8f3d8360deacc163a40deb72eb21351fdb468e0e83ad720709625af7ff50788efda4fefcaa09db2a1e94ba85ecee1d2b0fd06064e4f0e2eb052cd015dfd38458fd3a2300abfe830544531a9a0efe3803df22ed6dea6c636144192a70cff099d90093f1241dc2cda3f995694ea00382c7879ea00a56c6f6c37c40ca36fdefb131bf451650acb7d8384a5b13af597876f05719b0193c865034b55c791faac45ac3f37c46dbbd3f90768f6db5a90f5d7fe61d067bc649329dd4280554e210dfcd79c2399c4c0d483ad7e43f61ed5248191fd61b576d589077b6ffdf93f8b965bb1b6e2d9465edd78ade87702376fbcaf22602c6ff7687e589cff432e730e25eabd73dec39205fce634ef8ea10b5c30de50d1e3ca514e4510d690f15382c9907c2b88ec5b14af4773e8bdb6ec2751018678f51f4d0f61a3befd00d1fb3a17154a8efa69c64c5a126921f68473ff8acd8d5f2aaf745443f9d0d1d756e153532b4aa2d4aea79eb6f928c3cf5e803799476ec5a05637b9ef0938e8341739768801ac77e5c5c1c79334b8cc152736c052a6fb538f939ddd426a418e5ced4465ba4945efad2b85e4da8fa414339abfd124413418bef254aba8e1b60d670303de22b39d793d95eb3a8c5e6c69dc26e141b088aa13c0ea6caebad2300fb4a6d92a87f95f06005b158761d118227e5d172fafc6613ac8f892601cb8f12646f57193ad7fe888295a393bcf627648d71981752d03091761e2f5f626d6d90842f9a2ca17e1a267e99174883bb0aa5590168d0c29e906a58afe74ffde36e7c12c7e6d552dff8e103993af332ad4457452d8ffcfc533c1aea607afe84a7947149fd2fbf32534aa6113ba65475f2853f8a1d68cb5bf9cbf1a576560f0776ca1cee34c7aec1b277cb6fc24bc97db7e1ea4417130678d1337caf59e8dd23ef803698a36fd5f5d5ffa9aa4a3275c93b69118b18da9f10b1bb1475294c4b2d8da4097702dd63fdfb6a86b4beaa64ea7bb85cadb15f44b0601f85b619c2f17a4001dcb483a3c8ee2ccf7c817d949f197d834838a6ce28db1759a3932a67353e94a0780940d6a8ecfdf5c46227ac5df64bd6d12d2a0f3cac879cb9d7b4d7bef58b886785fc3c492feaa5aec8c7e59c5fd3204f33acc34513aa334ec5b2f88736227fd88b0b5580d918604d1e468eb06c4a3374274fc7c135371473cad65c25cc980070dbe2a6e884a4b83124592a0a4fe4f966a2038b74dbc9989a05873b007e502f62b8b05613d1c63289fb475403e4fdd768d63f608f46eda09d365b9910938c0bd6fc94bad8b4f570204efe7c7c543e3c87dfa0832d8084708967d915f1e814ffc55b83e5f3c983f48d215d6cd1e393de6871f13c57b8aefa9f423408861e69ab6b3c86e36244c0e47c195c3aa74c19a15f903887624c69789ac2125093ec3dfa77fefff52121e31dffe957bbde622891bf5880d76493f498bcd062cdb1490b4a138429da47d9c9cd83790b7916c515df85a649951c41b637ddce5060ced350aa4ddc7f3a9e5e00f9442b720a29c926df311c1345f9668aa70b77449c351190d4ace2d8c1558ae088280509485f3c860b0cded6ec333b9f2ee06614e374f99285d769cc43a1ea4ce58baaa2635968660fe2fce3a980ae310b26af12ef93d1ce91144201edc6bd9cf64d57e64110c4517dffd25b89aff3dc31af9f2d4db3e799144a3734d4735234be53952dfd2de9f84c637055d3697faeaf40167f7d5f50872d762a72e47734659df2725877143ea8fa91624b22bbaf4f753f0ac9481d6da3b78182d800bec90de06641d4038f0aaf1b7c4b788fa79ebf357c08ba66a737cadde86781eb582d1fe373254223af172afa13d6a61a14637808f2d484b47700a99a3035e9da3f157f26d6cd17f0d8c6cb0f844154ab6c7c5d2542439365d38af20d7670f7820c1317bb0b0108a8d38a841a08279107f660ecf33d37a91e7c87b5ff39b003cfa53749c2db53c604b1a5f6ebfcbb0920e2475c39c210756ae18dbd7ebffc0d996de4266e7f00662fc045a68c92aeb2d5f471a7a9da543a902585c2563f520823826d3149dd1dd24ee9572b18d7f6f7ac18b9048af902238ba19ef94ef5515a6f2f1e3321c0a2eee9496a6f387c4c9c3f7906ff7ece91a4fc9ec9b70672019679dc56bf8a3aeb30eb6d4b262d1a5a8cd14590f463949fd216ab040e36c4fe4966e2f26276c0dde77842ade0c46d72d20133724da26d80c3ac83a89c88f3fdb42687803f30d495dcdfcdde91170a743e88e6ebc79bc67268f21de84a9bc5baa88e5f5a926f3cd609fd85d277dd852bfe5f1b7b196b216e1b31370f2a1d6e480daaf1702e45d4d3b2be2c65320413e8ee81a651b5fdc2c842b7ef54c36697447f135faa8aec6a026c024d21eea7c2bf571160c54fe755eed42eb18f9db8e9c460ddf1ba3dafa4e43f547ccbb36343044eb3c79c825f14370433d7eaf56c0e0a24e20f28e7c511ea1bf7d1c8c3599c09fca493a190b60b669cd28c6214205abf536dfe15f927fd0029101104e0f592bc1fa81fd60606063939cbdd8b72ff7a7dfcc4af3e7ab993f091ca2d88120a688975ec859890f7a1ddf5fcdaf711ed65de9f3f5bf3f2132355a2ff47ccb2f5cc686031fb361ec99718168bfc3cf7b5867655036a76af41d2777bbc0c4f0e6abbea06a9ad78d03a1326d24ffc5832eff7980d97b84c34f0a8dd2d2adebbbe9d48d78a7d6489b961d0874d14284463f088169122a051225fe7a38136ea431b79887ed05f08fde3872084b4b3b558dc6c1c57a504c5ba293b42542fe1acb565ea030a97e17997447b4c1e261a9ea409a020c9b3393f156a1ab1e7ba31a7f4d2613378530c35c43e49477957188694c18b759513e493f33cec8d4a34b7de02f89e6033caa786c6d8f37ea228770bece4beffb3fb38051c63a76c88a7a7624ec69d1f967fa068f29ac3941e787485898ffcee6bb69db210bb533446c3f9d12f06a5cf8b0b6df1a983577baeb24c6d3e089ee0536861ba061c367c6780bd261551287617037498fb2bdc8133032051bf68da26bac43969b72db6b473dc408feb406cff7693c10916bd64e6b25f272aa345d4ff4e068d163cf549420b42a09aa5a2652862e07ba3138d690ab53d7122b2331e5b9d5014d0510202e9631b99a7d27bce52edf9ab146e6e375b1ec2d8a1ca52e7089c74aced9fde22f89d4f080e48e0217a4a5713aa627b5fd4624a7d19a48a7b383565a7c5dd26e55931d60212d3649abe39e2492bd3f3a544f1a9c0501220dd3ede57311d4cca0f4e0e56cb7394a746700c210b9bf4d2de7b51514eda388083c1e43fd3d8c8a748a852c87a8d257f96e3e176e9e588685b9182acbbf421c19a489912991ca398e690fe75220a700f26d1d42eff446eefb53ba0abf6ebd0e7e3ed0bedddee54f1a3c810eb4007f68d0891f2cf7350df2e1c4437df5330669e27bcd56f802148432557fdb4420e567361ef8ca67d92776b80d3bf8ada99356f82ace546ff19400bbb1a106ec2d1364b6cee460c87378ce448061bc987fb82ce2236e7153857fbcf438b594a8d955e7ea0467949bd7c2576c94c586c4fe79e18cf5dca35ec91e377afaa1d9bd2f87693910c0210479c8131ef7918a1692a4f8fa16ac78bbf2e3dee4a047f43810b847b7b2c80523460853b989e31d0710c972fbd0bcdd903d9ded81c22b0d57ca1d8007adaec91f9786070bc60479d0912dfcff3487dc66c28b6418ff0fb143fcbfb8cbeeebe8dc4f1af98b8f1b22649c4bfcf0907cd27aa876c25a8313729686072596557fc1a628be670cdb75ae82ee7dc828ffe90bba700e2b74d2e10a5ba866204a00a287ba7ac0f4622e06c4d57cbd0ae32ed3f2ac17631f18cdb044964a3c507b6840d3e9899fe7cfa6ab99cbc0b8940d5896077ae3211cc532186dbd59f4819fbfac19e5cd71116bbf2bf682c883c3a8b6782f879201d41e14a437abdf7e84d5f6262c5ca9e09c7c92ced29eff6df24c179e8338b7f0666dc127be44c8258d93213308ec555c27e146738adf1fcc04b674bc9e36207bba131a1cd6db36999d22f812e494e3093df685907bb66f842491f296c3b25d3822b3acc8dbd550de735868723b6acdd47b136e798f9bf13f9c23390152e7eea187a3371495023ab28725874590697fb38f0992c7b7549ffc3f3117062d7387f39b096fa54ce6521cdefb1bc66445b4ea6ff44d93e5916cd1f096ae575fd68d717b827460c013dc9792958774d8410fc7e9f73384753f97d2d4a0a4a968283633f586d22cf4cf4021dd77c38d533698eae5806793a40019b9b403883e925918c9c4ba1291bb8e5353cad9c5be1f3d5807a37b3a4dc2b158d32f2c19c7bd0529c96de23672388b1fee90ba244031974d3cff8c4c5b61afd0a8c0013718c47edcb3dd4c1bb9a7ed631c9c75b19aedebe4b87fdf72faee679128479076121563dab1016f8f1bacb59f2c36433bb197e822e215b799157d48644f32fa0caccc841366ed30555ed55d4f04d748732e7cc12e25619d19671005a890818d1013144a7f7c366068788224973cec6806efc345df579aa26d3c2de5b7df8b0e1c6a5afa780bacff298a2b0d0cdfa9c6ae6ffefd3e158b4d93d6702bf40a86adca51b4e9cc7e7c30f2a71490528cdb3db0b563a2a12b4f84fda8dcc173453c650d7a90ed863c1ab4837fbe038de1b3cbe6f9591b35f3c3f1369eb27091aae7dc9540474a05ff4c3c03a8fc3154d4e8f5c0e46f49c2020a9ead44bb98a6cb3e2e9fd726f6d4631b113e670038556eddc2ea568bb9e804c2df4564458d41a7245a8f91f2177495b8c9643f42a26f9fac712e7a6c97a72831d21b29f99185e1198e6bfabe8969a13486ed2326e234707b6ec99309b26df5e85313ae84a986da284930c2da8fbed109fffade89b0a7e1d438831d59e4b00e572ec10a4c300793e57bf8b638ef41506e1f726fda7a6d094d117d2aad9f9dc336678dd3ef56ecafd20d134aabb4f3243a7cee6e83cd5f10c6f4a94647f3079be455ecd53098757463d3925ea52c41151e5cc98c3a3297fb40d0027932350fbfbc9a1698a1c8e657ea9200fffa3bade08a3ecd47dff394d6e1d478496cf3edacfd4d5eb54ef7a9227484de02eca503e0f13268f1008d851b60ea91a5998e466b7560ef5b59f58d4ec5cc515ba955e1d5ca0c26c1c8ea3f2e81a6bcdbf5a24a88af3eed80f461d67f8105b0cc1516d1dbf28571a50091d28ef0fd1614bee3a8fe52ae6cd0d134b49ca5bb110d5180aec5c17048accdc0662a8830258bc12355eea9d07bf74170696d25bd4fd678d6adf4fe67af4b45744d5425966d9af89b936084ea1b42a91e72b8b92c15f87a55d05ede46fc76485fad7acbecb19f81bae2db33a554dbc4f763bc9ce2bcbb8033158de1492e5300d822ecbf3a7ccbd10b24925eec9dac5ab9164b3a7f3642479b652ebe3ecd612e5a2a19335090ce4fabbbefbbdd2506f5bbfd657502e3a31c56300b7b24acb7a851ee20ffa7a1e2c396d28930af612f8f8293b0839a7dd253b2a2db952912cb64f0426e876041593c4aea36b66f5a62d146526c2cff8488957051270c871faf71311999bb3944d3cbbd4cb02cf5850bbdec55877345315cf7fc3f898d1e741ac3e548363f679b70532f339fa4a0c78074f69518e3d72be42187be2fe9ada82c8cfa9391dce576552e560341e0f4a919dbe8f221214f737d5f4429a75330b8e251204ec008b00d8ecfbaedfad3b2033363ac70fdc6eac4b5332001bad89f6354c1f6d7ee50b44c0e5a572d0b9d71b6732ac0055752284fe023f644695519f9df8a4fa26ab6e1c518981a90fb855a166c30d1721a18665eab905ea7522976f6ed1f2dc7256b6ddb955deb13899fef7399fc8833a3e6d1ce0a4c91af3d75fa6f384c1d5714026c9d3c2c329aa15c461a5403f06bbe435c580024d3d3ab108fa2f5286a8e945e6877fb241b132742a041a24c79cba663bf4f8f5fd247c5409c6767f8182b7f134382f142060d7b404529d4ac4a497ceceb979d2668c89dd90636cc6fda150bc61faeea03e1929e2b30914ed3c5a15a10cb4759c82972015585a8ca4b8881b0f00c1d17cb16b2ca3190e10e0482fcdf317fedc45346a0f6c7b846046ea46f09665cd7a24a4ebcdca1f577a97a353311fe7cbe016abe196205cccba04c8bcb3de4aa8c371e140b5a39f7879187315ce38fe861fa618226838956bdb01cc6234428640de6c4e48375c4b6405a3183cce8aae695506688ee2ec880c1004d8d579c8e0540f3e8e81aed708e713bef32428f96091e96a504dc7496f53a38178ee60f4004f25d36f37cb2fa8a98cefa13d0a509e94cf2e22c601e0acccb3c1a5b8825ff948b2e2c43bc01f25310f930132f2208f6c1f86bbf959fafab66f535508f2935455be088b6d8b6002933ae8a36d0440f91139bdc10ce7183e3b69dc1f2ad44f2f145b84a302b2eeb2c070b5b205c27e543f3d2ee6a01360b82d189ba48960c9d3d1ef893e4d8c96a83ce01ceb37f0dbe1cd4c2a5b2ee5224a4a34ef5d83a7c872f246ff252c2179cec95c740b4d168c8965cbd473e9b163398a9a8db3f2b749bcdd7ab76878c31cdd3e328e6982e6f2d769a1b589701f32fa0fa83a1698cc155ddc2104e275b0b2c50a9b5ccc032d2cd9f6028c3d68a363b2f7ff1979d7cf4646c30b9f61f84a5f8e9fc8546247685e73e666267299d1a56c8d488a24d74a33b4c800f3f2612b2b7fd8d939da1b5cabb348e04fd64c8ae153a61034b6f660c81973870368528edc8b266619524223fc80cee81a85ada1d7b80fd913a348ad03f07fae75f357c8a6d6256038e2cb04bc0c7c6cbd2c98be5634aa701a0b6237f717ba1c2d1072f814b869cd071a2806edef0f539ef182c34504966b302a78dc8cff07dee05e66695956463b791662169f31e46bb12a6d9937f67f05b0b67827361390a2cab07e605683525267d395d6345c8770a00d5365bbee7a93c759b43fcd9787e1fb81681fd41676c64c9070aeaa6f9bd96a7ae9d602abaccb0b822728a55aa4df34378c73492274edc4b57301a2ebc05d34077c81a55ce38b8bed3b1948f7e89c84c999b836be2f4a49bb81ecfbf2ca6cbbed394f5e923ecdf33226b1501dea54ac85ba635580dbdec1649cdbd6e68135bb5b7db574494652acaa4f70a66b03701af38c49f2cf53244d6be6edfbd7c991bdeafe154ae9e701220abaea9cf76d140981dd9b12cd8d182d26109dc1e9611b8af574df43a00040934293a31195c5de2b9c614e47b67327bb6b0ac077091b35602c469109bf5e315e285089f330db98d6c9b8c366e0507447567c9f6507a7a6096d6a4b2f4d0a5b2df624c51c6e806f8a64b7186c9db21be956f7105c770b9e3c98c2dec0713263a67a610237289c662619b934dcf0c440110ec510a77ad9718644bcea6b02498966072d4e28e28f9b4b6f3fddc7f218d1982b3c257000b14164e9887ef57d655737dbad1427412e3bcb30769e54bb587cb084ab16f95376a0d6b0b3e19575ba4dacc03ee4b45f474e5d619f8828b68e5bed6a4ec9cdbbd0104a1a0971c29d176e5a155bc5c5275be83fa0dfc644d58e5f44c9b927c546eb837251acfe1202205d02579b6045d5b310a35ced7ab9df87aff2a5a6e358b6213c3aea95ad0072d3f090c33af5026e84870cddd8808c2fd9beab9f418dd6a9463055da99e8797be7bd206b29bb3e0dedf1a689a9ffa19ed20fef5cafb646b61eb3d679926abe80e2b0f7600b6002d2e6eb710ffdcacf50003b62d0f15640ea46bcba6b36ab236da09095af7e59f19635acb73494a5861e9ecdcaf4065c6806d662332ed7b5a500470e2403393cde4a517e686efb696daf6c0a5af20d79b98446498868c161b88b8ec49daf2de562f1ceea4a7cc9bb0db575eea7f185b1e6ffc25170b388ed15b3ccd5f080d4d0fbb51381116407283b8ca55dbce2ec95b900ee3886907bacd9bef6f29634037b000658bf5b277587729515abf80bacb2bc5cca85fd6af9c7bd7dfa1454efefad8c07ebbd44fe3fcdb130a298fa43bfdef16a1d27f8aff57102987056920ac0035d17d91ad9115d8f64a85f7286dd1efbbed0e22c7afbef230c5b6c64abb5b3f9cbd8b136e4c3a19df1752f3c694a857823fa8dad42f86af631fc692f7dcdebc5622f90e2dd1410cbee3434cc94570ebe380126c26db5860513f796705c1dc09f3c0b4c3bcd28e441bf277ff26950691b7559e2cc433daf7bf98a0d31cfe1a4d44d485bb8d0bb3f2b0231302496ea1545858622888ff90a336c0463780394f9ae6fef9861651dce456b79ca9df12af5cb9092ecf1c52bef90c9b5ad41e5d428d31304d33cd6f4ee8e56b5201805c9c14c0c95d56768d898d1456437b996a5e6ab4c55d860b8fc87c878631c6f33d95d9e9a861ea68ea5b1bd6afb15e83a4d90124f102014fbab6504f9a62ffbc986a33014247614d4a4b74a7ac553667c9f70790d5e2bf280ee6a5df0fb88477598fd8c9bf132651e3c771fda79d529567698f29e8e989a4af1e4f3393e1614a299a66d54993e4e40e23376356e855a8460037f5332cd76c46fa52d0a8bd41f82d6bd8d33cbdacc855a8ee0e13a31140e127347e813d30913454a17312ba40087ad467f44c2c410c646200597731421aa58565e74e04d616d0a77d040b3ac6a27dd341d131777fcc9cb67572b9b0399708b2a434a9ed06750f48bf2c9c107d299d33451c9a16842f3dda61202615d72872f3bcecbea81c4b9bcca5fbed96d7557b59c01bfbec8df361f7facd9eda7d09e13a85052fd34e2abd0d94980b896af818ed37750526ab1aa6b7a2ff4a1bf1cc575867fff5924ec3a92f002644d279073a4b8f76c83192dba487573fe1071ce328a1aa1f1ba0bae24fca8a41fac9113681d0470974183d473afdd1bdf7d179c83388eabc5262f985a6491ee9c162164640f953aa6d80ce9f085a1d1e3dabb5e5167e7bfd081b9b4e8495d845731bdb10a3bea35bb288494a1e3abb7fac79fd38a81104c4203cbb3a0bf8198bab05fee24642d271e391d4609a52417739b72d36570868bb5b6af969bd342e0a61c683641210b040c42ea205e6d6b5ff174a0494ae64a8a76d12dbd5b91fa344d3ac016991fb176242e4cd8b6cdaf999b3705659f8c954ce42cf79e7757dc6be614b591ee94c7c83ab410ef9c486df99848b3d71586b65791e614058d693ae2684eb3d1b27a4d85773c33f2ff3f1c60b3d43ebe99b6698c4119d5751d727384c81a29536d61514f5fd27aa4749e8355be2e7b9381aefda51bb81b7cb2169615e5b546f1df4aeb44b8d850c77ffd25a955c1e0e2ff8f6c0f8a74f2e859f7ad71618db671ef4aed076faf5f6bb08c8291353e48abbd2ed056f9ab159541beb349e3996215b707d521be968883bedd68d4c353c4a001ab1948a4ad174f5bdbdea5dc383e26800f7788586d760cbfb84aed714df2501fff679063bc1ab4872577fec9a5d688fe773a79e6edee08014793a72536feae18e96473af1bebdd9f3a1eba3922d495c3ae8e26fc807057c75a4c7082cfe4f969c9da0ccb8497074cf782065f9f7dc4f80bff9cf4ccc60d8e4e99935160e6b7d70f2a6f1a77957c16ceaa6e5d0445fad2901e38a97eb974f834d6f10c7eb56720a6d825519d78b51a065c5e09aa46003bcadec9f868b887818fadfb323467ecdc50b8fcb0b1de8fc22979518cb0e1351f1a8c203b5e926ba8d886c304b36b972811c1f6db4cd6628e0046f48eaf3f0fe306e8dfc9d9904e2a6e01d5da3edf958bebdd9acbfcecf5299450aab5a5842142f863ba626ff4f5a4290dfa02cea8168acb50bbc69b729ed6c236335fe02d5b219f22da8f4b989d4b78bc6e9828990566fd85f32f24d281d28075e8b3daca997b145e8241c661750fab99d5adda7de77d87e1d722d4f42ffd9ab9f808505bc7b72894c57b5c90e1180ed1e3066b103adf9736ee9e61e4b8b9777b542c5e25182908eadedd29ad9c27a610f37f4a1a1d162e286aeb84b9491407c78980333acdc6a808714acea15764ce5228c8aec5973a1bdc89437149c9cb392d93fe040ec010b9ab7fb82650924cfc47c5d442d8e8ac59894fe06d611a7924df4bdc4af12a2755f087767e0fab0084980e672f9e24a80a82335afc48b81cd6a98dfde1682606577e40911b4a259d264f7d5fb3b52132f01bbc5d92eb4f0f47cd2ea46ba4ad129f42a40b539f734597ce0d53f5f743073bd01375f2fab097bf122b3bcb0a1d163c1d8edddc08e47ca02ce9e1b5cc4bb4b4fb45606f31efac022e457c6b80f59b76c794022578f01f2df31a43061996cb76d5683f9df280ca4e271301ef9f2d4aee4f04b1dbed57880fb5b302791c897561a97a3cba421a26c95e350ba5c207f13c658044299171d005d9fc5337adee074ddb6744d4c3bc1ae3bf68d2c2af8dec698858e8993ee1f542e9be8ba16f5aff21b8100ad0577b574db4a3d2d8d5e10b4b503c55d976d184b2d3328be1276959deeb6aca6b0a6ce5de1307750798728eb098a581177f74337eb1d92e6fbbea2e6eb5d50fc97e8058b53f5a1b1ba4582e403e9508d39bb6b042b06d98cfd544b7d7c1e9239bf9935b832f549e9b6e1d73161228a4e4a169ce2e8f453e5668c1cc66a851020cfa0ff82d9b14e0498d61ccccad44273b05b711304d6dbab4212b7aadaa6c9728d2e96e104a17e6997f64f94ab075861f8d97ffe4cffb3215730fcbe0c38ca1e19be01e4feb949e3db50ec48092525e9c609f40cf26361896c04ecc69a6ea92fd642c1fed74dbfe0f520201e8c9b0883360a46dc9b44904ce0c456f922a90e96999e48311bdca5f362c73e654b019f07b0e7fec027e714a87f6f2c52f3520f20334e1f39b617c98e441fd2f99b6668f69a7060f70f9312926dd4c61ffa1e8c088cca6b0d95b8e78484ecdf90251dd4b0ec632f22f95c87fe80cbe14e2ecb11c7e090f06283f603b2509c72cf981e27ed2fe914913f8555656704d664e875c92a6d317a3030a080731d8eedb6a3d0bd4d0bce6955172a9a5dda998da1c3630fc5dd9d03a4ffb5438a83996648616461d03e5dd6ff048a4805b0d0afbfac6b61ca96fa7259519528650774bd29751efeac22b79fe97db191e96f05ba27d0b06d80c966586d4281168c793a87a0b921395bec993d9c0a78a965a7d6aef9009643b0c35c452bcc88c2aaab92f1b8681473c8914ccb68642c85f1235ec2e0859bdf746071c6ed6c278c5f5199a221bb56455e5a83cdf58d5cdd886861937704caa46f057448a30e90952a7993dd7a1c811e4d2a035abd6a7a309993bd51623649070400f13c895f8e4aacf69f81ac90d5ea65daba7786736e7620ad99c0066f129d1187d8014f09a9fc13b6f63b266d7905ef844ed9ac67edfae091e0763861f64b1ae715ba1ce1c59dc6e9a3f61a169ac84bcdafd11a4b1010211842c2056b3277bd682a0734a32113ef324ca349c018ac1773366d2d0f616c0f867843bceea430fbbd21b251c93764342a5182b9877fc30b4b5c84421d438ee631374c84c6a48343a0c198a2434665772cb6b205cb15af5bb90bf0985deb2c9187720d39042c7ee3c920d6104012dd6df9322308e6a466aa6824b0a4a589eba2c8cb1f9f608a1319d529bcab6a840743c74e60703483792bea5e7e79d0d4d4300f90ff91d7b368223c6415c9579de3978cf200f0ef4fc73808f27c74feb4dfa25dd08a95b8844bb6afe9d46ad8b623aeafb9c1a210616945b16cbd556e37819083486028a0cc2d6c24b7bdb6c403418f05713e4d36ffcf960c6c33e3ebfdbd7008754ef1bd30c1cba03f44f8e4df2954528125d1d928d202ad0954a028ebfcc0f2f5e16f3a492239772cc6fc7b2ef7502e7733a91f3d910fe3e975110162ebbd19c049bcafda3115c6bedfaf479ff440a5ebccbeed8c8c29e22d2500d7f12b70aa0aa253514cff87f8f7cfc1ccaec2156bdd2fea507774a829dbbf54b78dace0c27fedc48581e7281ee79c516c686c927c53390973578a41fee154ad0c6beafcc88eab714d9a3f760bdbf55000c4f85a7722f14d44a3ee95d16b6723dc9cf6ace7fce35773e7980fd87ce6ff40766861a3ff5dc8a76987b1abdef2fe725ae2e7a22fdfd736c89536dc1a12329e8870d904ec62d07a231a4641aff968bc8b986bdf23043b522b7e0cafce147c2d7ac37b352b7ba51bf8ea8493e9cedc2c3588c42bfc87659de2b94f130833ade7d0b3b30f3d7e6c6839ae2c1106890cfbaa9dc7a9251253a9257bdcd8a8dfab062c6db1f642579522119465329fd08767b3398ee44320097fe37a8688d3a1f5b1256784e943468514b275a03f18d897da982e81de12d89657f6a1ea255f3261467e7d413cb81a3d4fedfa08aa8e973c4dfa2876e40fcf01aaff42bcdbb2a2e38c536e9a4cd6a11e26b89f6d0c7e93d67a9c9421f10bf887cba6310f2de7bc7c4a4c01188431e6307ee8f8c8334e9b5b4f94c34c5d496a96d129613d5c8165f52f55b387931b0fbceca4dcc67c87855a0b10d31b19eb3760c27b395355c1328b2b83e6c6aaf9f577a20e9eaf4f5ac96e2f8086a0de8c551eb03c2faae033bda2ebba28408f029653108e40ed77e5c0cd16f916442cab7477414e4b3fb0e52ba211837badd7b6acd11c1d0b4c4d52bd49aa99385a15e8b232083ddeba815fdc4a43bdcdea1be24eff46f7efe343a4443946459eedeb177dd717c8b3fdeb28b38d4105ce15c65465fa00b78da64f51673a60eaf6e25d40329b2ee80ba5df67e483d0f9e8916fd266807e09fb58b23d010c3376367b7d6af90693bafbeef56a7f6fb2f6e49e45b2e08b941e6a9f946f38f989c633deeafff779b5d066824aa12aeb94d56c30dd59d3ceb6397054f6f6e0447e399b1c7d81d521fbfe42b319556e3edb318bb021a0e8597e8b0a103dd1891df1d20333372257aa91c374de0d434a6409a1441458136fef9e5f8a65915273da66309259006764310f665be9299eb81d42e116488f4e7e18a487b6ad9fb5d967a2a8eba572d1f42b342521e1ca6bdac43e35d8ce0b371ce7da3cb6153e3ddb76e73f04bde9519ea92598e0d4075d880f9a3b4331d23acd4a2a64581bb3b20bedcc865ee0e6d5f95c766cc806915ce5a757c8a86d581e6f5678fd737cd6c0d9bf38854af9e2845bb7c5cdd0952f9d36b7380fcca4eb165b7b6a6d61beb8cb9486495d8e03bd8d5e47ab15dfa003ef6672c516a93ef807baaf78dba4e7f24544688b1646a38f0ff943109ff4ea2b6e5e553547088abd05a511475a8113033d0a2eba517fd693def83d909d2021dafdd7c3822d8bb6d879a4275be6dfa62873bec0baea8933bb29d4c58b58bf2815571e15422881c87297ddc29a1366d9cbfab0b2aed36067dbed5ab975e952af3f5d125b313ca2e6ca23e125cef20e87ffeb8606c5b2fd226c5a72df4d423a9a524237e6ffea06fba0af2718b03e20961585e0b79e446a321460a3d80267399a514f97492238de456ccf007644f67959e364ffbc6c9fc1fc32310caf0fa68c416d4bac40f5c00c40f7d6d9c71a2ceba582d78fbf0f46ee0a7f3887c28b653f56989b43f0a89be0effd72b75fca98ef9f39dad33831d6966207ef13b0b7325edabb38cab56d48134261fee0e7a1e483aabc1f6d1631df4ac3d45a00329debcb0c34791874b6bb31e7e58929db4cb8b9a62ba7b29b825ea0ecd8ae1f29553ff70b4eb9d63d745c0e1d8b49906616e886dcae423eca9877a5e89eb8c1e8b2b1eb5e3eccd12e175a122f5318a8ad5ed5f60a6a4f4d7bcfa2912d2c54b74d87b8c6a85272a56a3d52c9adece288952dc60c38521ca3f9341657e2edf959f0f54d1c492b1d74b062c5f9ac1bc338c6c502f33c0798512ecb9732156fd7cad3faab7c08ff5e84a896e2bc76364816b165b6861405ae90bc845b6a484970f2a48ac5cf90b7b74f55a81bf2147c597cf5817c0e3e31d4546af39120d6505cfdbf1dbddcc18dd607c98f5fe750f898f7ee7b8e0928ca714227309b625b028f0fc9a3712130b7511b604be1709d4808e4d5bd97f996dfcf399d1371362d1863ecd61700408ea2b0c3a2d8ffdd821c296b87e1514614fb12f07ff8535f01d7e5972ba7abfdf878eaa6a9d221f635a350dd2a941d688608cdc4990eb4361e38b94b1a30afa3fec0014452d6b72e6cff48ca2faa59d92b7618a1d441f8efc5c3f97e492b12b2ce310e20bacb02e0e1657f648ed85e0d9f331ea57e0b35a259f5abdf32c63d9ed9ec299dcdb0f508728118a9dde99615011caa568558f2d5a5ca52fffbe2074e6ddb6aac7cab466372b60207e97d9ab29c5cf10a6d55c97957d30c9b1ad88e7267c42060603d613db48f7d5c2e0749853edf7618e1a4d550a013c10369afe629082c05ffcaa36a9a033b89f6c2c3a9d69a5bbdc9a1a6eb3604b6ebca1d348d532ccbef6e23af95a5ead90129aa503fc2dbe60c1e2b86eadabc257d2472665d2cd098162062a96b8bf8b05b91e78bb5eeff170f38e292e0340423f38930a4a6703b9d90faf479717404397a36b663e0315cc29f5de05fff51063303fc27818f9879539e6d5deb1ea17071a2ef27a735d31e344a4d97d7e326737a88bf1c772df707fb489edcaed8e84ce8f23162a15341bec25646800f139fe0a7393a79159baafb48b0932eb02143e355ff801d354e2159bf28f4aefd73babe589d2e3b6d4ee56f1867b01361aa75e91acd1562ef0daa9bdd80fbd9cff584c6488b305a7b0038f0672619a1d5223d81b6998e9c99575e0e14ac7fbeaac11b7e933e6d50f61ad1bb6f4b2e72b87c111af47dedf424283607b2fc6a7e4455a02f8b89da6d70d492f900df2896de44a4cde5d8e6b36777c8881feaa187fa0c3f1f84bcd3a1ffd5efe29d4e66d50013f1c8df40733cf36e46261c5b423b98300ab5b806423b597c9dd9aedbe5f1c3b5837643329bd60c8a7a96f9f7d4d4ee8895ae8f0d1bcc384632b916a15a046b1fd32a6dedcc5a4c3fe18de6528724b1a4bf08f61adbf1f95fc4c7a85f401cfc2c8efe0e56faf58cdf755d41de9af0e3c46c71f08991f5209e37fedc97f76c9af2df2b7762610335e27d282606e22dd7ad0e507219bb02469de877f33e1e0e1c6501b9df05d60851f614b96fda038659f5e1d74b9f786fa9e27de3d5d619bf43127caf88e524702eea760afe98c05f712b96cccbba6edf4249601a9dc061c323246635e4d8343d301878b8f4299ef032a39baa9ad97f502daf6508687c46d5c1c1f3a645f9d50579cdfa0cb6acc9c049cbfd20d75bc713a80a58ca147f40e4adba35951c7360336bf2c402055fcb34af9dafdac3678fabf2d9d0b856fbca990b453ddb81764d4a6bb253ad97079251dd50710b83aaab2b3259ff6a019b703105c965e08a1a529f16f7a85de4c9a92654b39b07fec744f008a1476907ad195fbd40c4f5abd2ceccb9096854d7f9d07fe93d72ceb120fb1081c3382d66b1c4ae413fe7e22449c8d45015c4a6b90aee1c47ffa20ccbd76ef9fe87c51b3fbc4d5fc08c5595b1df6781f56cb83126fc2cdf1c6e8051cc74aa9f98e7d5b6e3a7e176","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
