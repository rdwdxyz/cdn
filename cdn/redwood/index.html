<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bf604509f092039518c483ae0b346cdd79123a8d703623fa4ffd361929e3ef88b0628b8bb1e1010f64ac4f64c20f605a4726450469bc2a777b80384dd87345d5b5ad0afc2bf0f06b4795a76a01d5602023b05c346506ce9c0f84050444f2e080d6a04e1b3ed90c1ac55debc52088cc1d27fe455d7ed1b192b66c491ec3e83de25b83dcc39099da7c5a9a013e6f6eeabf71870ce1b66a5a81935d6166748a23852b3772d6ef20febaa88ab1f963d44c6205602a53f7770ae4037b543ba2b5e618a9935e12127f6c6b0f7de87e06dd87028c98b97960ef39c5d03af7d6020b139fcd6c38d2a96cafd965c7345763a990477b43c8facede921c112dc726eabc53d8c844909ecbdbb24216fbb7f49badcf0fa051c32c5c25376efa0d6feb2ca536732a75da302d8ef356fafd8860e091d3c1bb7b8b6ff94bbb8a4407bbb92338b92e8ad788dab4f50c9cb93ab498c65bce3532653d230a9d1a5f1e99f7f870796eede750528492fa7c94e4007085b978268ffefbf3b98aca2a1a96e098e3f8c1d9d90773bf01f9bfce4121841e4cb92a5ef3672b3e028fbe7369c73cc1319c1b82b3cdbcc61ac637f8653259471194acbba688d9c92af0e13503aa27becec3a6bc681d66b10d9d2a7ff65e8ce97fb7db3c7f21d1e58b84dc2b695d0ec40bde1020f8ebcd3e57dbad938d30a8efc6ba1ab3d736b6817c567816986e87856534f3f8c063e872b7253a41d41171e9b94998c552e74f3d7a5966a2dda15bd4c44f48ed634b4072894bad0d6568193fe16b61b0bc5399a0b94b542f3e6cb1752bb0b2fdd07c842cf8fc6175576ed00701fa5183d5c503cbf35d51c37d1d9ee25371ee9d5898565aa00172a7988229107bd9e041f779689cd352d7f0ed813e0b57867eec09cc8e9b78b019db86f69536e9b37d2a62476a609056c17016d6ebb0e57c2e87e599f5483b1f3e7cfc40aaa5baee3333199453715478058ad4a77733d8d41b694409fac896b54ad72f35a8baf58d6fafda0a04c9cac5f683477cbee46e5c809566f7155a87cf836763b044112e05b99abd2bbe04d564d597655e75329236f9edfcc62b37cab93c98858bcec949da8b98228cd793cc64b1b4c16d9d9ae82c56e2803499c9c2542e3e2d2460304ac832f83bae7a2cfb6858456b04cf160e512378b66c6033beb05577e0c1d5685b11bb1a5f90a76f6801f4e35569fbcad0971268be0a783c18d64293c4962822042e64097c1bec3a847838ed2474a8c8a2f4144d03c7f03d92d78457c1f268b04311114f0905c8aa3cc1ecb6bb89bc3fbd1596ed747cb8a70c238d0383923d9b97dbc0e4f1d174eafdfac2d3275129553651a9fdff5ddd5083a2bdf80c1f52836905b0c426276e09debf94f7151f8ed346f3447bd644bcc479c437edad38910e2ae30d52f3cab5c5e7a7c0e8ba05ab77550bab660ec6fb1ce627f13517118c0ec6bab5bd6c1b63699c1f9081a3f7e032b79b77ca5d10732b31d7189725fb4094e7f9918256f4f425d9712d2e923dc71a8195ce20f4dfd000046c3b48d1e886fad650fcbe1ec8c779d843e72f6473a5638c973c140be763abce869a5696ac063b5364946fd31b3bf69cfcc7fe9fd1fb1342771b18d1db0356fa0d4919e6b873914e239e3070dd9453230ed3b1f04aa37b36dd228414b2e2553b4d3da4c3a7c949eb54fa0e435e1ea06a035d17adaea675a4e0f0acd2845757d2aac7c814eb28e6af8e6e31558f8e41ae32b7e9b26fb14c40880c29ade258fb1d79a26b6a6757d8227a3db94ce6800a5566c01eb124b10cf32a5f026bfc80b36862de302cebdd9f4e91e1dd2f25d5e7c3aef38698630b3d8374eb8c510db0b6704abf97637e1890620e3049df90e4b666210cc3915246772bfa30fed0f8b986e1bdef5615f2585b88e67e1d63c2cca58e965812b48412210633ed7fee6ade59be973e9790ea6c2917b8022eaa7944c0efae7bf16f4e97ca19885633586889029218c1f3fabd6de2aedf17f83f446e4ce2e14a6cc19210e600b88e218ec06959737a88a15bb5df0c92330d10926a0cf60c7025fdd9520994fe946a9c7622578d68e06df41b468ee25891971049d044545008ad5999ddb4b6c02bfb9abf0ecf427eb7485fad577b15b803b9e19347b92ec06403f6d70bac58829a17405c121daea64df2879495efef79aa5d6c16aab18ccacbebb55f4c09d3705dc3abc564e1408e33379092f6fa9a4adc40fdb2bc2e41b526e0241cbe268f3992d6791f2d29a3834f349282fdaf0fd6ca9f07634c90048ad96bbe563b182a31433f6557d57de2f8fa4cd710ee04c3e45d26077b79d9736218e38e07ba868c329c24bed11efa63a83a730b7d6229d2fdbcdf2db97b4315058226f1fa626ec12c257b5b793378a51649f8cfc8fcbeb1725fee97d40528519a6221ef9909af2c0c4d95cc40a39d0fd66bbcd12e4b77f367248165e75cae05356682bab8444ea288ee4c0263af91f359e04cb6a2d304fb3bd0228b3f0d4fca5d39158a803f3bb2868a458498fb48d1690bcac4d85fd6fa2dde250613b30d9eb8b1a3e25a2de00951bdea8f4b4a95aa05a1cde1fe5ed4098902bd30059a80887f9514f2df2064913cbba214fcee82a8b2289590032620199cc4e98349c696015a15206a0a352829b7df93d049c856f5f466ef6df938cbae297a0772cc61005d0f92949af8269f25ebf60826135531dc94819fb1475ae4c4f7c0054e23bb9c12a98f3c14550f5f492fdb333cfed137d91b74b19b935ec68d58d06478c9b5c7cc4af2f42e78885de9dd42a1e1ae8a5f438e95be10b5c9191ae4a99d01ae579b85eb8f221eba968573653a2ac025239aea7d84554ab3fd7c56975a20139eb894338eb3aa87a32268e73260a48fc947f22ac5594e214931a9c0a329fcb0f098f4b4c9304e9739202b116aba1f85212dc0082ff754cbadeb31c634d846c473997b7792df1a4208867de1a3328bce38c55573bee2337059fb7297fec6a7fe8a14168b218340d6919870af0c609b94a8b7704fdafce2f9c644940f28a072063e25ebb1528bd3a61420f06f122fb1365edca6632cb00eeffc9b99363739c92245b2760f5bcb214beee95d8eaf2397c8470f954350cdde96627833fc50d9a3dcc4fababd21d52a4099d3119397ff54664ce85cd7d473eafc1daf3beba9efb9d987a94601829e5de00f67b3ae9fa81dca800665ee53d0db795e728280c5f779227260f0925364edac9ad5355c6cb75415462c2a4ecedb09d018b09b8abc02740f29923a73b6455ae3074d00eb3f8a383fb13048e9d47a826e0efb3f046ca4829ab6b2383eb15fee716e4eac6d6790b75a9813a981c2b6a7e8d0500eb4d1385adf358043a1eafdb88403c804e13fa69c42f00122ce4e5d01508ac2010828cfc5f57811139cbacaf5b6c717634cf1537ec577cac24cf9f98145709aff920b529b3dbb2f05113442191963a17e6beb0601fb590cf94c10d9624d44e38ed64415b362fe01602ba964b52f89be465f03b880d147419562f597266eeccb51db03e530ba269e2001fc62022cb9cc0a4979615fa4d0a55f315319fbbf1853cd1cf1b79757a8ada30f99db4b9035fda0734fa5746f54040c6ebcb5f6a7079463db8da5a16b0a334b10e68aef86d319fd9864af5acbbf320b8a8c6fe40587f40d42cca7b8105275e62d4d4f2781212600ad4a938cc8af1dc28e23bb9c630ecabb6b55d29c841a2efdd47348ab304377263a7f2c541943c7e845c5fcf15d606affc4b2e36ce6cd7a4faab39195701605a6168a36646fedcba16fb6aa194190b991da780c57e38f278bf9a7d64019446efd878524caa989cead65680739f1bf7d8a603305501709115a84a4d1775e99eb76faa42c3adfd113b4af5e648c11d2b6ef1d064489b4b9820833303c56c3d31770f435ffd0b49b159a842e23cbfd0e6792cc6b5ef28abe0b6a4208fdcbe15a5baa8bd3c78450cf6b77eb5e11d88b80c8bca9df51119bdb78c7ce94832461f0b7bf37a913f137674752c4884e31d7c98d167bde605c9f334cc8e21a6ff4d575fa58d0c5a2763cf4936d21c7a822bc7cf5a5cbac765b7746a5f185453f639713115a1f0b0be4887627025fc3d0119a17d1748d5f115931f9aaa2ee93860aa7377593902768b58dc661df934792f848b0de5c0e46905ed9f695425caa45439c5540d9349f1dfb653bf22ce6fda3589ad85e46668885ae0d5ad23ea999e9c0e14a05bc9d32c635b02587736a480fcfa6ef7a1f12529e273ba99b1cb8e4ddb714e5371a3187b4d0a95c61a97d3111ddd65f64cade48af4327ff3335da4092898b7e19fca68c16c1195281f69c90dfb9809a525aba5a90e7444aab1b8c4beffa983a4b381985d190c4e46ccefe8d8fb3538c8e69723a32d12089baffe38cece87ca38600a53dd8eddc9a6a036174df130916b7472be230130a2af64a5af67982900189692595a423ca7f98ffb78eb1f816725b581284114e7f08017d9acad6df6f81273ca4a5aa0fdf9f37be79b3424da7fa2935c17e2fc9c24330ec5aee4de2c8a779d49401da4026edb6804b2443952da0f766cc35411b6f82561d31fcf549dfd0b1d7fe1db01263068e678e4956b16dc523d93aa505985552f2c0f337926ce434622677ab585c9cf1ff9e84ea628ab203463c27e952150c370fe7984b683d8a8eff857ba1686c36b04f07d6f575bbc747664ea113c36099c86be1ba65974e5bf04fc59eeb1613bcd863dc2de92c35aaa029cdbd69a01c601a05ef15bfaafb77cec1e327daec6e0d49faf7683cb3fd2819d1dc26856d9e8b0756b0aefa4c15c229152c028ee849522ff7b28322552f86b01524dc229361181b60063c093a711310687000f176f66073a8f593859660ba8c728fbd79b49c9e7574e4c9f18cac3f76952d273044801030bcf95961b2be1d51c1344af916c8fb4e48342ed2161da02080d58dad7806772ae8cb954f71cf4b1dacfddab10eb3abe75ca9725819074e825b07d7fc367f6e0854d28c8a6312cc7079a6c6db4fb0e9416cfb47d1f7f026ce050f7946dc6027895253f2c6f86bafc1e0c6f15696dec7895c911c6b12801cc42b93d3100877dfe08c4c9c874e0248f815433eb7a63a288bdc3fffcdca91eaa17608357d8678fa8f4e4fd19e80564ce31c3718f0105309832d449a0d3c10c10f42a498a50d1ddbe700130115ec1f0735f00673822d589c37f796f5e354923dc455e0c1d51d92c324357a258bee139b6e0cf25f4df0b16f7dde50a617fb14f3d1eea36db6206f719e70b54f88db2e438902d9f70667e48882bf26a29a4abf813de92dfd06a1084eeda9845f38c911331a20a8e072802f0aecb85a965993eba07993390189a12ed9535e23c7bd8c7711433e35c9911d774ec44db84a2afc186aaa8d007e524421dd7b2623789b1a71a3f13185bc158c8b50521ec3a216e7d4dea70fa6786768b5bee39627b957e934d270f1b6e771b28b3363968305597bd733b2d6569675447730ce302fe89486cc7a30e7d4e16b0eb170834fd22e2b32aa1c0f7208eb73390eec732855d61afcea1801a141cd0ba43d53f3b82e0f5882891196500a1062f75de0005875455d265d002d73a5ceca8ceebab9b7dce58218aaca91aebc53196b367d68336ecec20d0fc2b3b8ad22c94a1a671ba86c1f6812e26930ad79c832ab688ba53843311ff2695527c09ed8a3c03df6a26a08c95e2142164efbcc6d2ef9e029285b85980ca878d981bbd804e914c98fa507230c040a64ceab974e1c8a0ef9dbb188b609915e74cc9b2214a5c5f94489b3947b987de6c205b069d24872d6174802ab38140caedddc12f387afef71f6b1a013e18b9a0ba39fd6cb67358890d00a093013c8fba9b444a8fa6c2b9801fbc45fa056a42238f0b799e70e35c807da5f966131f0a97a8b36954c0af01634b5cceaa2b86ea1af389c6a4d9a2075d15539a6f7cd9924151815dbd09473d9199125dc574ec2b8db217d1ffc7ce924accbf5206f2518106c30e1552781e9bab15992a675d133f71e159cfcbf0ffd67b45a51fc053c14f0d07bc1db59837e894660f4abd68e29570920ea88a0cde6111a61dd089b051b351362a84508c931662cac51a4ca70c65cd94de232f1501969e1a26a9c925e2efa39dec473d8c6a8e84c3d7db31ff5f80b77f69eee937a2442dfa27b9e5e3cef99f6651b18bd8b4f6975cb724853aca5e519c68f5fd466b55de7548ba0b8b510e9fede871e622087abbcfa1decbc775b176d009c02220f765c4ec21a85ec826ffb5080ba8ac07a43bf44f6391ba90be0b142a8d88c59fcedf855d8805c0c8533381ced60ebd48f706d9d514f7c4f17590799fbd4a8525371106edc77613de09ae869f02d870e091059af798989473e1100cd24a2403fc09992781806c3536ac38aa4fb59a672ac7951de511f55492cb0f970587cd016f3a6f23860390c5b7bfa41ff5b56fd5e69f8bb943ee927cb2ff0ac92eb83d0435b880e139ea5373f7077114b1ee758ac8f23ab3e6cceaeb6fdfd88dd78dbccf76aa989abd379326b607a398723452c6061474c7bcf860494cfd44d44a1e67f2cac93c7f2faeb2e1e757444b781be4d36c0dd8980d1bd69c79b1820b7218e6b9e9cc0bd571d5ad5aba1c4e0cb2ad225444bd435d3219b1ae43721efae366d4b98d95d3efa8c460f2369be7324f001cc9b6b79aa71e29682e2711617effd293962e25d55afc4107511de2327e57f76cd7d461d54bccac65d7ec13ce23d98115b1e7449799b55aaed88bee0e98e9aeb71702eaff39120c3452304b51523881f51008490d48710c458a01f0ebad2739d23bacfcfbd7034157ac3394e8a1bc61d520fb8141bb36f09d1f65eb3e80d75d362ec69f8f8d045fec1cf2dd5dbce6d7618bd1f4b53eeeadd3103b23eb1d01b46febdbbd9109fa55eb0b2cf3b1651b10ae64760780fd8b897e3d5cabadb362c0d9509be8a2ab347ab3f70850d96c8255cd800190c186b7cfda6667eed71803861ee9b84bf83c6f34081529ccbbf60b368ddec577f749f070f6fe50bc40df784a99ff63e9dd6783b6b86cfd63830be9b47f77bfb853d0a37782c778b823a61c699ffb1e66c9fdcd71f09c88235355fe6e8e5d9e735fff16338e8ec1e9b556093f45676de6a8e62526d47f50dfb19a18c03c168164fd7e3dae6a3a530da1209e60a10530e1de9c6c88c23b5bbf3ada475b77302e4b75561785789294352e6a35f64e1a90ae4bbd348a8139851dd9c0ea5e55e3b4df6893910751144420a6de49ded90a8e4781d638abcc2b7297051166ee295a033a574fb2342a107b188d1c05eae3c38bddedb3b4b8cd87fd7b31e4733581b202f61949754fca6d8a79e51c1794e4099c4aac7924b1d0cc2a7880d80dc263fb9e75ff9f071b8e02eb6abd9ec72d18a5053b5e3918c94be2fc8fb3240aa7aaefeaa1892288e26e216bcd799ccc85a82c123cebc0f5c05bbae4f9f59691b3f2160269240011fdd66c233c1cba52e41caa44700e71cc8c9d05bc189952c5dd5caa5287895dee06c80404d5158b02f2165cb5aed771fb0d783310e15194dc2efcd4e539fb3875d1a00696ce89649bbec6af3cef3dd3a3c613490e1d0375d98856c033b518515d3c47c54cfc04b4e599c39c8ecad0d554d724f0fdabf430e32f50cfaf189965d3fb9da2f7405f64c137d5fe14ff989de9fac9195e60576769bc8ec8388cd71b348ee8a8e20dd75bdfcce09a76f13ce40c3f380a58f3a74a614295c597a0ef37fc92f3ff45b781f04dde4ca283bc94b7f874cb2bba03a3b59320bc114c4a5c78d2ef9685bcd827c9aa17027c108923db6c2705641a5cc7d9187c25ad4b5ca7db9507118aa3b8dca003bef5b8908136cfeed69f274524e72dc0193d125cd9307fcbbf29fbfe8d8502ebb98cde7c90cf8cead6aac096439d792873ad5ef1192c9de4baee33942e1c48b5ff034520e74ebeb1a12f961c783f720ffbe31d2b7449c46741f302a51941cb9d34d2ab0cd56b024cf84ab15bdb3f21488ff083e28647a5831e4c2e29b6a2b2b339aaa83584672b13ec7f137a7a61f8adcddcb937db07317843c4e25bf14f5d5a9399a424607c8f3476e33ab0ddc4f1cf0f70c9c404a2ea3f5027627caf450bae2ea0b38004618800c00201aed958890d9a3d097b6399fb37685dea2766eba6ebaf2648b35cbc3eb0a072b3909cd67d3811ae849c51a1110066dff6199ba06afa7a3ba67f0eff95de50a8fd5358d3f0516949beb5d6bde25d6e7f1a74d668b4745451a14b755d04c77cd8d36a4d6cff083a13a98db03a14a4537394e1d5385c873d4f6c7fea93269e7a82d1223c28bde7a3230b9c7fa096e8d79a5a8de112e6ea6d4034731157d7f52473215e93eb642a89ae4b47dbd10cc9def97a84aab53cd92765c17ec05f166f759d05bea152cbb598ff74f73130314ed2380312bccca8ec34b332984e0119a11cdd6a6d3a1092fcb1ebeb5b40f3094afed694d706847d40cabec8b5dde78426196d5f621500794beb85221f074a382ee8145585bcbc5a79095bb0b099abe617ac4e3aae5c07c320a04daa226bae3eb41d0e4dcb102a93a04c5b545f953656979399a92ee5cfce9484684cb1fe4f3b994c12e7f8c5c3cb0345cacb83a6f5b5162e9eaa0bfb608539b9699524c39717d07c22a832d98e652b8a97af5246ad33168fce8a0e9419cfb251503fc18713c75bfb0bed23c501583b275e79ad294411de8d31fc92d0cb8b4f958845427023709851fdf540d9982f09128784eae6447aed008de9a875eab95a864f47878c5e4e15c464b0ace952e1ef421db8d2ec41f5eff279d73e936623148dddc456270139053a6b9c828222268ae867f21feb8e74894947750e008e67512644808cfdd2e46167ab8f7731c1f5e12065fd0dc560e00f356d5f900b2076afcc3d59d3e4947a3910776004e056e3598b00c3a72473b7aa7bdb062b5e418d1ec1d535f678cfed6c5c7ec7e185f7ad940aad49f2f32843c036a27387d5218ebd861bbfd9630e3f45cede11b281130433bae41475ed6fe78c735e7b2f346486643c9695a905470c2d1df875a0a518a86c5b8d215e303b68ce77f0bd964c98733452ee8da02d628b27d24e9ec2d12bd99f16c28861a339e7032cb78dde34f948a71115aba5e6b12eee1e8a42ebe5394124f910216b02c0e974d176da97b0a74bf0fb163ec434927347f69ec93675bd4ffa20e91f51e478c5503db9c9964126ef370636ed117b7b0debf4d0cf8436992fbeb4de0aa499e001ecf38fdeaba7d34255ca615ccc0870690468314406305154d559aaee8e325e1d2f0ad7513bbc6de05e875f1174a500d8fc862fb553d990736e7c4b6d3ef72ded3393281fe663c41c757698c165ef5caa8b22a26419a8e8c5b1b1bb4945aa841727dab6a656ef0b3314e2bf9d403b1377c1cc1f7a1bffd454b6ad5f6beca10244a3e2f0f07196be39803b6b7607ef71969d2530d35541617917eb750c1950c3affb2836528ee73bdcdb72d2969fe21ca200b0b3078b107c1737f2556d61904e2ae6da382c56e72721a2f8218c8e5989d48e4a36f51867d8dfb4d3f5a2eb9ab60c668d577364dd5a65b528c012d517e9a3bf8278015f1d036e47d7bd1e972197dc782825114cd02ad9064cf420ce366802278a368f41f800de292b24f6309094d903a04d8e49b0d8a6dfd53d81c6ec7e8af3ed892f2f77d5ae7d3d8f50fe5abeb7c0d560fb63b3da271ad9ceeb666e447634337abcac7173655a30a2cdbf9825cfa281aeeda91d4b3dc3908a97b9da00348d19fb6d1952421570e9f89c8bc1261fa3d1702d9bd30c3c422831a70cef08fea82fd4e1621684cf9e56c178f2b3d6bc08c9400643cb0ea9e656fed575f199830c55e193703e99994f3990cde9e97350463278ccd20b8ab3db69d6512337c21f129fd3ff92a5cf362f423c4ea4e5e2e62b981d13205b8099b64d912d01c9528a2760d953e48ee8045c883d76b3dd0e011dc318895e490f2f11a9cf38a031b32d9b9d0cc51d5e8187058e054e331674309d2f2df1c5103c011ba982a919046fc3060ddbcc78d9f3bea4d16ef584f0cc4d04bf1d769892912ce8660240aae835b84e152ab8f1191c845fd3bdbdddc70714751ed1c08d08f56e90486bdc6c21e811e539c6e113b18c4bb736405822e5b459af8fec1f21e3f6545d91456b70ee1cdf3e76a9fb090e7a9ec7c7ad5ca8013ce96f4f6c9a5042214c0917eeebc22604dbb3143a65fad7cadc7b2d1bb21b4e6f0ded8dd3cf5870d56a7ed0debd719769e96c67fb03548aa43987431fa288d0dd290c0ffca06b33fa30346bc7fedc2f3ec7cee32538301bc3e993b659c18f2f8ef38707870bbec13d591956642d6b5264ce5e9d29edc8b2e7514b62f19029e3ec8ede7253d3f244694478b3bc88a00f59f5797d05494d2e35ac2595ef748616df29b475b7557888c50049768b996c06c9054e5c6dda3d386d0e488795c78709ebd9cc41a52a9f6e4e9df7f3ecdcb8f5e61fcedc36bef65bbedb530a7c19fcc86fa4e40615fa9c05c7d9b167f232118017db9f789cbcb118fde89a01dc0af10e7ef23b3ff9b940303c2bb72100cb568e36ddece5189473f51d15e27cdd4753b21fb7123ee19a338b1065ae0abccf647b916ff78bb9f33515fdc6d5ee505ef5c2b38b970f158052bc79c52317c99edea05a290988da5630a3c1e0d5464fc15f99200b5a397e83aa822972ef75e23078a6335ac88eda6bfbe722fecca153750fd25f0d22e4a4318fba2e83c51819350a08b57e0cfe4a7e0a61ee12b92e3f0af83e5bbedf9e341c55a579632c60e5bcb3d3b4533291740373f0e9f129d2c157e64dc4122ae927c0d251bbe1140d026bc148a00a078ccad068c7033161621edacb71c64b199bde228931566769a76386325858c89f3be98d220b2e6ace6695970340ed94e3ca7801ba9d1416d095ccbf1fc2a0f5c76e0925a60e08d7fa2d200050feca0541ffe9fa0d78bbfe708752533cb889cee1b2d52efe6e7d1dfedb9691f79cf56cc312bca84a4b08140e277ce05edda6acf7b7e331814bf39999a06e6be5e1b8778f1fad033e6bbcd66043d57e476d7a5e4917e61944467d37f0d76f473a2164b93e8230a51fccf18e11bdc2231160daa325cdfc4d20a1f1d1f86038c76acd5bf9c920ad59790e47af2fbd86a9bf0f45de53557d4475bd2e13dc3cf82d337b3e5d874260a139af894898d0ac498e90ba730b1c0cad54f319b9f70ae645c718d5c9cfd7c2d2c6ec1b738d6f4cf0a2d043f3900e1054bd2343f93a7e5af292073432dc5337d25b9e6c293f594e9feed299fe6d51804df9d5395e47eb6a1de569488de9d5f3dcc25cd721dc82ab206455e3eb115316f342dd2d568a9a4180906a665b4f9557aaa57a1556176d9ee2a50029f965c3e1e05bb256007b6de9a35df9c5e9b675dce56ba059c4e5ef1894e09ca202897a6a959c27c1de3941f9541645a7eb7553a30dffb981d9a8f84a54018fe2b222b9a66d5648533bfd0360e7ab40b96354fd4d90603dc73971147808dd2c51bc27df30849c548bbb3393032b529afd340a3df4762e9dcf778b74674522cd01aebfdb17b5b7c8358eb717ec078be5f7df8467dd29f74254e531ceb42b3b12498a037ce9881b8862db137456343385287d50a0e075b804d7a5224df171d373d9a0c88dd0db67a5a556b26783703440dd0448c5d9c4d3c3f1b0d59498c2ce770f41ca670c19fc52ac79470087623e2f10e761820f237765176b226b9fb484139a0a1f67fee4d0bf1539d5b2ddfe2a352d1ee128a8e7f09dab55d1e413d3b932e955e9ffbcb255969ce11185f779e4b0b0d69e58f826fd43b8e520ce338bb0af9bf771b2897bf09fa5cc716368ff3b5b2729030e9ae5d0ef07eef815aaa0bb1ad3e2b8bb93ecdd87bee2608a5f98da6891ef61d7055a0116a8730db1054475c6c66bd68d0e36b0870d08297db9511a370ddfc7a38b37b89ee1a00b2bf9829d62168ce3941fdd6d977214791fb9cf797c1aac058b14366c163c77295d6601c47e8273bc081468f95c402c2e34a8dbe8b1ceb93b69de5a0cdea32294000535f7b61dc9d15993c4082e4eeb5f03af9bacffc60435f7f81ba9fedca75cf16b8fb753114f6626286458e9a5a64cd54e081b4fdad1c6b0e0a0531aa4f1416e615306656c0f07d9ac51d78737ddcc626e9ae2857a419d3c1307fe599ab7494dfae34b17dafea55c9e2f84c875191627a9dbb7f53f5ef6384a249474a30980b29aee1110f542e5c671dde28dee0041c734cb8cb212cd582370dc26818d25953c5f258bfb737962743cb830fbc84d9ecc8e2e9aecefd5b6881e412a97f5abb577a7bba063223c1d2025bd17fbbb6c76ab69bc96b2cb28933e3f4e607e9e36e6641372f4c901b1b842a59a08484d1473b7e23185b01e4f38d9bbb625f0e6164ae0f0fbbd58bc8857d69ac97554b6d6a9dc713ad21dd7788594e2094ce973904ed7d30f5ad002e46853513475a0c09940381669866b5067b9173307e76be5e5e35549cb31723dc67610c7e258a44c14bf6518047b4f439a34cb7e4f46088b4fe75bc0d33243d36d4bd13d98811fc424e66d3acdb09db84a2fcabfcf911aa58166f62cc16a7afd824aae0c11a477c73cc47098deebf6be7308ecef0bf99141f99f2d2f55b2e6a1c2499c5918dc9de4388dc77db938074c5fe3d7cd1af09d0ac6adb5254c9c693b45502633b16bca97930e7f539625255a22282a8bbba0ba0fbbbc43dad48aed39a3d4e281a079487ebd0248f5e762724bee1c7b2d5289d1749f41dcd85de6a735e494d7e86e2e10b89181931c140ac0b39fee84b48fcfe6c6a88921b8d602db1a9fbb92fba0863ab5750676406b6e044963747724c43a1dd168510ef08d0fa6280bae82615c76b41bb757a5197e9ffdb265087c1f0cff3f378d89b8c0d942a02efa0a71f65effede9659f6a8281a3dec707b9d8c19a7419da759cb93e5be43f762082549ed95f9184077c1912b3b9233a096259e6d14cea0b3332160c7b24600ab1938bcbdad145c4cd91a15458c44620a1677ec8838086eda5d29ae10c6d36291213fec7bc2ca83fabaca5e38da2fbcb2bbdad6e4de654687764b505b19ed94d90e0c27fb904e1a65a2fd1e4ffd2b7032d52a66cc90f502168fad0b1b3e5e4b068d68bbf608feb7da5c9fe7a1f51fdc4a7d96dfe75eb99b74348415fccf89e5ae748c35dea13db856251af9879cd30ed1b347092358b7d65834df8b221012536dfa3d2f8ee3e1cd866b8fa3d1b9b7fd8c8b1cf94d204b0a54bc0ed5b1c2db2d29a535935172611841c10983ee3db3ea13e41b519512688d934dcfda11520607bae8e3f846b343bcc4f5c0b3ea740fbb766e18282ffc0e48a656f0144ca7a8242b9ba4b4a2604209e0368b12bae786e35610443385f870d05a3df1f7877c9b660f49123a43ea6416f6d621d75c56a5d77bfffbf3a28eeacb008d736f6d463da85cd59f79331633cc11f7a657661b0ce3b7853fee46084ca1463f30cdf579e0b9e40197c66f852809f4cb822013d7780f71987c14240fab45215ef1bac1628227b137fdfe62415107c98d55153989e05380b026b78f65896a55a8710c7fae88ed9a90bf3f44ed0a80a0e2fc1c9aefb76dc10db7a3bb61ff5ecf5a52cfe27418772b00847a1bed84645445f582f46e602f9cce519c771333ae649879f02edc5c910f51a8314c58372e9409c96f2fbb0fbeabb62314fddeb07385543637cc04cfe33d34d27a32fd3815b75ead5ed90211f3abec14be60be17445a0a9bb8cade06ec7a4900ee98bad6ca9923fd9d7b284d9795a19478d892d4a3009d7da6ff4f386032c50726bb1fadaf050e4691ba1430c649d12edf20fa2331e0127cae340e037fe5b6f354954b3c8bcbca3079d61bd84a48c2ce07761dd79499530a93b8aa65a14954700fbd33afb40fb893a8e226ea268e155dd6297b95fe1dd5f6949df0c54980b8c4974a8a0c6bb66d30c6210e01a9d0f9b54bf8f6c9fcf6cc8d34975ebbaa5a0029e7ee7e78f46c58a797ca3b82ebba5a5ab700bde41ea281eb56a31f764bd9b98795deac9359ebdb2e92fd50bb23eab2f090ad437514772ba8f452179ef8c3f8acbb16a1e85ecd0f8b607c9613204de6036b472f9388900a41651467a76f609ac9b7bfa3dc40fc82410ef8877982ec5ecc9daf03b6631a6b4d36ec27ca4658eeb3c4f128001591f7186d32862ed735731c326dc14df0c74ae6f87c1d3ad4be3b163009842c8b2848cf51729775790410d9b12ff5b97842b46862c61944f849ccc6b98c8e2d0d01951c5e57b5fb17caea75e6ca34ad64f971eb3b59e9dad070dff2a2730fe10d406c129f5bbb99a2678d9dc8239a3d42e56a889672bad51341a7c8a69e9c154a1bbf6f33d455557e8c13e703c730eb3e36df6714a80dc9f2c850d8c76be5289594e0adaa61588af0e6ca9ec05023937da89af09845171dfb14bb5906c3486026f7d2e53dc1745500dd39a35c9214c7a0c541711595187f54f70b9fdacbe869f2d76540632ab389f55b4ab17bb24e17b6911394bd2e6686d8a9600783dc442ef83ba7bbbeaaab173780f67bdea82ba024b4c3db8c00f706a228bc1eea0a06e00e160fe1fef800c26faa383167f0be8d209ecc4dfb1a0e7f63aa4f81f1aee0cb09de7c6281207365b84e3eef5b5438f344750e5edae08946a60a69ac4702e55c97c5994116acd5ddfd0ba7435902287f8a9f5ae099eb0230548ffec9841fc61b1dd30c3e4c2e806756c4a9eeaa003eb86f4ddfb8aa13f0f8795a43b49e416d699601e11729962b09e09e1db4f83ec9fee7921c9b853b7551d6cbf9d66d419a1592905fd2ba132ac2d29db2ec884774d49384e1c7c1c10feaf49e601596a5a2ce42bdb04ef5f7dd53d1394d5bd1b82493de7bec34e5f57797741fe699bb99f3c7ae75e2327d84ce601fcd98aba4b9510bae658d7b848b47c62bb50e3ae8c0da43dadb0fcd616b6a009a0787965d39e56a09e45d73253c4702d4a0707684dcb51cc16699ddeca668a2f8307552e7d641bcead6a3c86ca5d305e43b6221d07aff6df1bbf78d9476901d913769274dc9cd7e9721b25581d5fb720e802dd26fa9f530d0cd24132818c9ec9bcce1d2281422f99896650940f7c0c7cbf7f677aae01db9389b4f8af96b77148628c1ca08f8a64242a6146ff7f052cff707474e14333f81de9a7b2dab43f7c6a0c4bf97375dac877c474e6f4a48f18209d1bd401426fd0f1aa0ff4fd467a9b3d2cbeeab5f1313e049e99da284557b3b88c0aba47b3700fc230bf03758db0693f5f0176b0389a7d428ee9eec55cbcb0e8fee814391403620b73fa8ed6119df47a813b0f1246beba1b923d785895c7319750c57efe7022c64f7437943e8d851cd7e32e81fb16728c6a4c347d578b56d9d56aa3dc42fbd5c97a7eeac1e02dada73f69566a01c48df1999650bf6b7df67274e160be4fc612aebc070e729f6bcb014f8c8aea2a0b0e99fc30f436e627141e310b7ce610101bfc9f6b5dbfbfac855af38873539c7f187670c50cdd0ae390780724204b03aad5607e4e018598cb732a3dba75e3ebf59ca16b1d845246b2e66e5de6645458cf403240d4e2a93afa260aeccbcd8907be79d5341208e63433fc7d0f43ffd86aa7281dbbe22ba82268e8b0787287a05827d855c353b4c757d3d3f6306ae5d8fbe2019006bbe02159c6688955f20c303810f88d7e78a906aa9bf50c139c9384b1071e23718c3618b342a190a6ad509f992a6c4a1b7de47ba373ee18fe5c179ff1022539ca7901a6f261aa0173595592f0b2f8440931b5966ac55e67bcd078fbf38aec89b1dc7bf3f0e1bb86616c33c28fb84b0e556ab6936ea7d7f1bc5abf9311d45cd63a16ac510b6fb171384d70ffbdd34e9be715f053f28ac237a9b4ef66632a0db7f1abffac41ccce31156e005e16ac1e5fc1294ce2dba7ad33b7a759f07ef471fa0360e4cafb4a55ff94bbd6f1ec2e4679e9e73dd7ce60b6bf57f0a03d0f48370e6125c59ebcdd5addc2004b249db13d18713e6d08ecfd27200552e5013e06b6906869cbfb9b14e411ff3816868eb80e9a9cad744bc6f5e9cd5e8bdbdaef283fcd3b350c40ab7fc09082103857ce970cbbcda8c26e6211370f5ce1c7a98bc0b7a88e5ae351e2913a3ec12e59c92e330672a9f330af7fc7f1f02f96758abcf8ffecb4b92715b4f588ac1e7ca52e6e05baa394c951d12ff92f097e78fc35bb235627526f4aa2d0c7b55e1e412d09829bfadf92cc9cd988ae1208bf57d93a942881c03c81ef962de9a36dc9f9d63f919e1ff11c7c9adb44ed2ed8d7300679121e0003ee7c139e7cf689a6a4ca346ff7e742f38531b35f64c31ac72ca4ebdb9b5b284c430fc7ba8350eef93e717666423294b692e68027751b58d083dc0e2dfaad879665d07b02bc355e0a2a900018afc16160c4049a52c007416467eb7dc119a71c8969ec44e76f2e2eed6d6f1ff1403ea48d248a11213377a85cd906ac53defe511ee0e73dbf51f86e9d39d0ef6cf9a52412e220cac33bf0babc427223bfc4f44de482e50eb113050819e3bb20c17dae3ba5d5d86359c01e63aad5b892ae818ef2b22a8b1e40120ba9cedbb4c9515d2ac38701b0f7e1a6064c7a796d44e434c2bca89b3984884ab17663cf1bf2bd78db08cb47329eda16852af0e2ce1e46a65674280ddfd1212c25f173f9bee91ea376f402b9dcb23ca78aa08ff275c71cf50cd7e91f9b8f0206a675dbe27639c85bacd1a43bca292ad616e43bc2d9213731326897bca662d34a929c112c649b13a241bd0571f77094bbd4571fd50b8c03b4f60f00210b1647733b9065abab6729b9cb97b73f7c1d2bb86d1ece602ee46be0f70a9cac4effcf916309c6bdb7eeaf0f1e18ebe9e1c8cd420ed3d952206fba93ae1598ce0e816877980cae3cf3e049033f9cc709e32da45e9195da3786f89ccea8410a5de3a9c27121ecb3bdca4b3777098b921e10427610fadb0ad5dcc3a276f31250ab94a4b48803d469b8c8184672cac31c42857741bd27fef20fbcb60be9d1bd25d8668070fc2d6ab576d74d4c43db041ee4f93ef57904114de39ea1480ff5e1549af5cd135ba9010b8f177c626fe1a14f0955f497ad42376561647963ec85b9e4f71408a5943f56b8ea0d0758c35279b21b43f3396c88e0045cafa1821aa568cc1e4bc95ae1bb8e62996b2de163c2dac70d7c2879720fcf3b2ec5b5d1e82ea28d589b4da60dd6a39fd0850cc548b2f2f1621b1d7bf8ec72c59101e91bb1fee48bcd69e0e15998f14cf3e0a8b36abfd9c6e4a692acd7663bd92edc36a70ebc236848ca1fbeb5bc978d794dc97596eb7c46a7e0578300406e1517e27f3586cfe8897425419063beb7831059d57108e3af2747ea0b814f50c229492ff6d066cbf1b3682498f3c3db9e8fa7b2b78087faa70c03dd3111df434a51d05662e0b85daa84c8d11b88f51ae5f73362aaf94a3fc705718277821a780b3524f775e36ec527f76bdeb750fe73e91ff1ec0d52dfc306d4d2b1f856d2b615d97b81154c9dfb53c2cf45042ee1c5f65d46fbed44827752e728b381dba785c189b8b294542903539324e02c203510a300fa7e2551178013d00c82462d5dccff6b6b0d77f498bf9499735757c896a26bc8c2480b36ac2ab3c137205204e731d41354dd9f4446883e3df443757378007d27d64a75f380a6c9a9362d7d32b078c2a6eb9994ab8461be20f2ad57d15a9f2f6d2815f824f699e581b65b856138ffb5d21cbd0e364e96158a3aecc6a1dfb06918d65321fe600afcde980a8a3bdcdc24e99bd92915c3f5892997b0504a81653618856339a22d9d0a7259ca7cfb71d68d3393fab5afa645568928073a06734baa4cc5a0ea009b72efbc67b5ed61b6dbcb3eeeab0058b7c5102740d6244137bcfaceb5686cd7a62fbd25fbe48f43c775f3ec430e5714fddd6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
