<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7a50ee461c81a523519e5ca38722977f3e5e2121337a3d63a423f3adb6fbf5e71f8f628a5986d68be881f0d9f56b1cabed453ad11798b0e2ee5c6b63f11951accd01e2ead73ac872f9349da56eed6722ae5c26d54c7490f5003d7cd32c5337fb1793d8feb2d7f5ec13bbeb70c7c86e5dd15445ea58e818c0909e237f48721eb233ce833593de37aef4507e815db8461b8a29662e02037700378e98294e21dae8401728db927eaa20354cb3b7afde42d68380f4e22ff15c20ef1b714bd5cc584a74137251e83ab9bf99c4e01dca431011779a08f4d5572aa65af39084281ba6dad2773fba04acf54cc2ec98d549cf10156b86e263e2dd41f83dd674d2e9911d4eacecf859005adf6f63ee3f07d6062c3c05312182c1472c7025a01835cc36a9ccb1a4f367b89bd40c856722b8518f23f7bd0354aeaf9e0aa862e7d3d2dcafd058e18c45d0f9a54215c78462dc093cd685c38aeff413347d7e0fffe528ae3976e7d91ccb0e32cad4289871e9b161e3a273ef4ae1c7c0cfbb3cdc7aa2e724b6db92623f6817a121f87641ddc9ff1e26ba7fc4dfff3e51bb5a9db5242291209a9043f9069c5a0b2db2e1a088984674bebeae325bedfe489be77ec59c0b63939d0bd6f0665a76307ab17214534e2b0b805f4a7112c964a4d15a1b99d1ab8f6000e3a92e9318e5586e0d21189bf23e8ef7825598852197bda8480851497dd1a8f5239b1569b146608961a30a9ade1451c1533260bc6eb779c31462c743b249c3bfc1e6a86a410d14afca4aeec8a08412923e12a197bf3e4a4acf336a83da3ecbd5abb98f1eb493f053fe76ca460355e7155edc96ed1cf71ca7eb8d6f181e4b20b4eca457b7abf7943694f4ce4d1fb8255f0067f5787afd2b5585f3115d6b9283837e0f8c63c0a5dbc0463a8a0f4780566ab797db01ffc6d5deeac3e3df8d816f264666198023dc08b570af58379f2b612cff5194749e662ed530e70d34d802f3a77dccae97d4ffa236212a43d35f621dfc5cbcb51858f8365fb133192cb64635c6ae3cb580bd900582e5545c1ed2a147b4816178611dc4b8ee5e26a5d18044b55ca7ab2e45f9269e3036cd50e2dfffa7b95a241af0c5b13fab5bbb2e081a8d67b25bf95e5f7a08efde7ea6cf43a63735a90467b4cdc0282bab7ce2d0c1c24e79bb045777bc3dd1013573252d92e5d19c97d49c72565866f02aa78df6f0c66c97d78ee2af960a3f753f2230da1c553da037bba9b164aef5e259d033d8a4175250e02a617bd22d1642dcd558b8f0b08839eac88e7fa0be7f34098cecf1e7ea7ab43bdf20ada7656b6ca1fe80810a1db5bdbfe1a878f834b0bb8b2744f0f8200fecadc12c5208f97cc766b617cbb2f381cc0947ca154757ee40121c269b85c65c6c22b690f8021150ab515aa549a6794460b44252b04709f55b6c3b8cb271f2879088c43cb0f8cee747f435b63ce77340b0ceef0c1114dcd0ef88c5f767034fa372d9b28e67119bbd6b5dcd2beee785aed192c934d718b70788fc095be30a0fbc5b0666c260d07a6ca1ef2c39c7c419dd98c80d47cc5d65d3aa90ee364ffa88a82e5f0ae46e286af981f1f90fdb01e658fc1f8cc37b71f015382348d66580fe2b06cd37688694a9ac212d608dd82367b2cb51939540d9a0eccf817a12770d606bb779036cfcfd4c01d2f9d8df21b0ed281fcc4c7957bdfbdaba0a3dd6f94ff42321520f75ffb5079f2f4c8a71eb31c137fd721468e0eaa244461ccec64ab4ae34b8f959c22f281b465b5b30b4966236fa0e348edd9c6e70f3167ac4e547be94d1afcf8e1f72c2effb0ee77899376285cd790e157aa0f437f114642a8d93571929fe590d64edb2ef4d2225bc3db373bc5fa2dcaec8ea079119373021439dca28c2b9d690d3adb6425022f77159e0de87ba6c6bd39393820a1c1e10a2d08b5533e9373cbfb3702dbe9d8b9c1eadbfb4a4ce6aa0917abe1c0ce3de64db3c29c6c7ad9e3962e34423643c34c5c2438ec98a08114d4f761ad2109b60ff37eb4e6e1b3fef4492aaaca11af752b9c24faf257ec2827c077cf34a2a6ea6c02c1f712924aa97d3bc7c6427c1be19fa2db9501ed893d30071c7a944cf8277893475f8c94c1f04407839a826f5b60274412c4a9f34ca56b80f29f73085e3357f7c695921c29035ec88eb1674b8317c1290efd930ed1843567b4e0498a856d05337e838446944c3f515dffef0fd0c9a6fbc75d4e37737a96e51e1c27a3a98e82359a2b4761aae2d5be514fa7ea0c8ec1051c52c2175bf569c20d62af51aa7d28fd40b824688de1f60c33eb9ee2a10e8b75aae92721616df935281ab53a6f62e52fa78462dfdef0df772e5ba25daec480fb1955d0de4493177fc76ae31075f150bfc9335be3654f44cc2d2b3134711c084a633256f383d2398e2e5a7f2935cc435000eb51d1fbb42daa49a1c273c780f24a4e09cc66e506e716296b961f4cf00a076f11f923790cfc126b8899b2427e187d23e9830fbf3091d3e1d72cab9ee6d09c87ba993c222ba2dd33e049688143cafb3c71d10e7344fb3e73e063696cdc90685672ed727c08ca676acd50e5b30144eb9aaddaeabb8abc5356f6ae1370cb374b39925f8b03139a3a11301706327970f6751b392f4b4f27c1024b3401bf4605f57504f3b99caedeacf441bf62af72f6c61e43048e2556818b0ff195f7f2e1ca1a9a3f114780efe9afcdb94ffe26915cd2a12bd63ce725ef4b90ccc5e18081c09de0222f7ec216185a033e6ebec41c3b18a99500df19b392b980b27a8fbb4cec6622731eaf615d453a594d57375bf16085bbfe74ceec1a64762137e907a6615da47766aa8c4fae7a650143edce67b3daf9f5701c1f3df506eb79afa7b93d0b15fcc83d1a6b39162e18301b6de6442860f8708fc6442c7d70de8880dfbe6683b6cceec1ec0f84dac1eda630465a2f54a12c062f9a666014894a5268b690f74893a1d983a977871524615cbb398bfb888875697d232d11ca7e57d206663f86518deca4889b5c7a7bbaa4ba37fe375c5dd16dc3803b22ee54fba081c0e6362597cda6755bc36754072e7a78e08e5400b0b3941e60a642e3475128b4bcf81b0ccba951188c77b0fae4652497789a40ab0d397169301072346e5e543225976f5c651f3ba86edaa66597547964d53323c8d4aab989f0b81692fc6aa28ed33aa9ca819f8d604fcadcac87e52d492d7aeb1774194fed32fd18037757dd40cf2f44b57f75a58c76bed21818a2276f660097fb69f4ea543388d4695e8d8af998900a3d66ba160d3a0ffa530e49b54d03c70071b4ed572a8f667de8a9f5fbe28bc1a02c3225c023206bba10033297d0035e5b01e57253c0188f344a7721e9153ec46ef1578f8bc917751456d1042714879f40e307295f964a68527f08e31a36ca419c574ca3412718e04a4f3537b6da67fb77255d7f4e5bb1887f5d83377e03abcb8253a16c16a792e3e0dd1f19316ffd44721bad6df76f28f9a7a53b168451e30d300c9edd7af2b9763a1a2240968d863fb493cff64332f5f572899db458a797d1223b42e6a81117fed81d3682e54c3378efdff7d1b0b7b80eb0c44cb056402b3b30f8bf7c96035e76d21b1f6709d34fcb85e188362d2a41f25ad4b462ca714959d7747612d518db1468513339767f2da7bd43c519e59d8f7da2d2bc3a7d011011808ab840ea61d6d0e2d35f172819abe07041421e501a6c43edd614b947ba624bc0eccea5cb6a4a3976825213f68dbc2681362ece489260082f1d8d26677ad290bdcc4c99efe9d17b0212814c26c759be92981f9768f2f8419c77c2a1f16c8827f84e6ddf27a517e2ea39564eac948b122f8806449669612cb8b4537549816e4b2cb6527977b76c76ca653f76078c1758f7247bd3feba7082c7233c0e298793c3aed659d886fa515b23747c7fb026dd8bf43c9b35b3ce60598f2f157dee63d4b71e4272f9cca84fd1484f0a2fbe2e357880207b4ccc643217c8ca84fdcf2089432c94436bfd41bb035c4b95797ac145af04e46d87d99abd0b7cca1f41012beb36b83a0a2405926568a916da6e82edda2b57a0443df386b98ff7dcad1e73d6ef2758c22eb0d271bf9d8d4e213502c33f16888de0635268116d97d22254745d0e7518701596d505453d6cbf042887d52195a9ed61cf81a8f7ec153612c05d6c0531639a0c4a3f6dd0a68df778543987de81bc0ad682ca43e192c09f3739a9a50b55a67b446305fc615363cd2bbd1515dfa7584196404d7bb509976c53d0d496f09fe141ede61d2ea3e0b9ce7575462e39cff11df5107a9e95ece503d79b3b76be465ba69e678f2f60ed2729f9aaf5eff00040c7ed3a13efc2f6bac984c6698b1a9d88edc8ce0d59cdd586bb81076b452f2249be7903b83db94360f2328b95cf2fe4b132a0bf6441c799eef97a295dcc6863ae0c8f519ea05c8831ca5dfd5fa134bb73709717f88c1a16457133c2abd16fdc0925b613d88af3962d9ddbb494766f369a05e457320430e79caa94f411f814c590f901138e433e24d745a2227107fa9225deeef7975ef9a4c1633498a8624a4e2566f251a2f56292b4b701c474ab729689f51232304673839a990a705fccd5abc4713a26f3e0c5222c48b4ffc75aad558704479e2f159a6ab1e921e3ecc06964afe0852d7ef91941d91500d3b7705f7938b20121bfe72b50276845930a7892c301a221165df5be7f2e05ab5baa228c8299d579c650e52c4b4f5936d308c7f08236c8cedf6fbf9bed01a5d20b641680ed54841af3bfc3bce856ce20888482d30b4bb50811361818b9c6fdfad41e7458ced8a8215a8b656fcb3a5abf2126f72dded8160cfb136f0524ff84119e0b902cfbe9ede984164bc9a2326330acd7bf888acaeec4a64899ae6bcd78b8f99dc89ccf3657aff78d351c55b9793c1c0c1d95acdb780c3b5b4e0a35070590ffa8267430fee9cc5fdd321dd9ae32f9abad38f05a397653153b873000eb8f1af3d535bfd50233869c1807fdac1699771220b8fe2132049e25927b061c2faba5c11a60acc80ad3900ec5fa11226af1e9ab41989e113cbfc274c86d26971a126e55f974a2e04eaafa601cd6b4768971637180f96e50286a841db2d5153754400152396483201cff86fa709e3661e970dc3656d5adbe0012473a1dbf6d0ea41edeb8a2678f9cb2e818d02ef21db55757dd305fe1b1d66eec2577cd92eb4991ea2d14712ffbffb5c96a887d36242c775c22ab76210616648ec1917c2fbe8ebb922af17cb1c0d7a4ef4f75b00d8917b79343e9e9625eb2dc0168236d4ded903b037e7958fa4f4d1978fa882e932d59cbb40718e2851afe0b36ba8b79cfc49e1cc3287a8ba571410a07883f583b70525829abad59744f98c9a6fa788964a9ba1d9bd76e0e20c5fc82a8fd7f023fc1dc5417faf067de637b10cc491c5d0e2fec6d98bd9c5008f8f3ebaa1b557dc441a806496bf17d90ca06c03429f0ba75c9850f2028c329d09f909bf2a54bc39bc11acfc6ef1def03d2f58312cff114cb737d1db743d8a2fc43ba339d029d88360dd862e521c341d42277d12590dabbfdc65b072040a4dd181d219c9536237b5147c993c2cfa8d2c1d2f0e3605410aa93b991250e00eec2905a7ae0df81eb85380e539ec2fa02559f0c998b9982d40c7a7c45e1fb012873d5f5846f5bda124ce2bc823c37640b75788e8e29c5061707a872c6828a61cc75f416b17b8cfe5627b3b30af4bfde4bc31e3f03d95bda861b4177b24438dea96fd1f07e611f892b340850c63d5786273b8bf72354aad69a94cb59ce835eafad61350505731210eb6ac93cdeec6781874e58f31c50ba609ef24077e94d260cfc7a7a5d50ff768219c2e4f65dda52c21e51545349296c1c13be79528bd743902745d23317f1d6cd4135ab55ec4bd264e2aff1f90666396fb2132ff35962e00c2ec18e0487f499fd44f0d2aaef49ac979605f1c7ad785254de7a07c22bbdaf4048201a435fc07a42c411d4e8d20ab676620ef8dd994c01c521c25ddedc51067316e3060fa019730c9f29ad4deb91957d8aa2c70aefe786947d17c8bc2839a6dfb9cc39d30f2fa8187d7fd776423753c9eccc1989d89497608bce3cf2fe5ce21f36bbd804ea301ac4d33b3b8a9e65151eb6c2a995406e6658bd498dcc8aff14e31ea271394142918cbc66510216be55ba026dc4cfa421da21b0597bef8286f736b61d0907a2d0ce91b8eba2dcd85bb85bfc63727da8418b975cdeb4d77b789aa14a1081da8da34f3f63c9c3eed50774d8031294cbbe39128b7f3cc2e0013a5fa9fba4257eb2f2180e3982fe46bfab1ebdc7179a09c1a3328c2362ac1aab05d29cb9f3ba0cab7f664a0d991f1094c08f47e68999f6d4ec25de780540e81beff095c4ae705c6c08dd6d6393eacd1dbf0cab76c671906aa3a59b6cba033f9fee697ab76c7cf46e4cb2a074eb98c323de105b2ce5cb73eb0931922c68ad6d84e5a23027ad36ea0ffad049b9eb0884f28b8c14384bb28885e77a6bee9143c80b4d0756d2104606aba842f58c8099be7b9ae48b582895196a718523ba5de88fd02da0997c75867b4f65590bf19b72b55bd8738a96724d77bc5fe16746993e068a9fe59ecebd3d56ee90117cfa6fd2d2dc2526105adcfe579a7bd5943110dbe0d61791671305ea9beef9c0c0ddf66c3c3bab4dd03819bc1c1acba9b87d37fd217f050b054c4b05f6f41f4d8f9a16320b521b3ec31846c3b4ecc9e3c1c7dd78b1f8f5dfe1bae9f8469810d5e84de36ecf675dd42ebab09cf1e678e61885a4461a7b9c5dcdf8333d5f60e68aaecb5680ae0c06976c7fb86a786b0471c76e680978498f2806b5ccd2fd9e4c6155a8322cf88a0bed94797788b2ae8e44c82383e20855e64346d38f56ff27740d25cfc16befe37deb2460c333248199f9945e771354b39df46214faf7fdb6ee75bad3c3bfed0075ec847b73bf0259f479c17600429238d89115462d842f181d138ff142c08b111836eb8bdba0602e7adff49c6aff2bf87a9c61fd2d2f0a56baa470935503f98cec07d9e19d3fd6d41461b0dbc2599df9ea1384d5a3477acd9e37a06f05d1203305c2636afe57c8ecac516f05fadd4b551792c2a5299a9deacc525c4c8eda5c52f9760e0146ec0b751d1f9090dc632291b97f7e5315eb7400933ff8dcbe362dd978e4bc77abc2c0e9f03f381f770dc4668f0910d5b9aefb50d11f193bd093f1482b5280a0c246076603732de9eed89dfac69d15fe5ec96932276032c6c1176d2dab3c7867777e573ea50a877b2bdb1902cef00eab1d8607391708fd774f61a6e50553fea325f626f575176882c4f5c09656f21736c853f9bd8baa68780855f84839d073038e3c9279053e3719e2c5edba20fc264e828e3ecc491ed651fe62c2743c4e1a9951638635512cad6d6e55c601f7f25e30ebcfbf09dbece09686a6cc42988c20520481f1cd76c8c66d13db6436d68e8c346c662a1436e1f73a1872554b264528cc3ee6f5f1e71b602d13bc9078b61d2aaf7b7defef63db8d5c00c1b48dde340c2ce6ea636dc4a8c1ee0b7f95f04d4fb75c2afb839fac63091f3762fb81492e5cabaf5bdf693c1fa422b18179819b3afffd5cf93d4892e943976ca52f9e53a3f1731a9fbca9846dccb0dcfd648efe6db198974fb36214c340a45ca63cf9f31ce60bdc4393c46c197ca3c7559e9c65d974502788136947ce2e4e3936a169556373dca33e1baee69df6c715607b428563b9e32710a878b84dbbb0fb05a83bd3ebd8bed1395c82ed8879813fa327b585b31776e639fb8b4b4798c95eaf6ed6171f4ee5894591fdf23e75666838361286b648e35c224e486cde36cbae927849f1e33591560a32d1b5f022c9c0fd51e04505f752d444eac47dc71e498bf8c257e1eef9d5325f9091a0286a66280244faa717feb8609a4af14f086a13f3262781fac4907bc864ebbfffb3104a7023a3ed9936ef8b16755900027234a7d791a9c2d0773b6129bf0e515f8331964f6ea5efb6c5a9e57e2e90b8c92ebb4b137ed87715f436562c33034c517f0af3b9484c1a0acc362f35ae0eff5caa0d698d0e4473fd8ccc53ce58b912345adfcbd8f152e33490407089851055ef494cee0fea7f7da2ecf0dd172d9154d351e49faef475d4bc445bd3402169c834f1e52f9042c8b03dbe8033b9164df29ea3609368ef781f346b6d6e7e801d56b273fe84f6ff4fcd48f6d57602453c0564bed19abbbe6c957da35a39e57eda05ed7015640b28d77a7b51cb1c12d265521a5ba7698afe352b990905ea5653ee1a3a9057e6f67a44b9dfed0be4e10f002a2bfcdfe4ced82a1118657a08b099ed1053076e3da2c08adeea6a4c2f8ab4bb2e99ad5ec36816129a5271e419cb66919e38c0a98947244acfc92a1d35e9394cfdbf36ea4fac93e06d620a67b466c4332b12436f73869258eef55617f88ffca09765da3bc16ceec97310174b8a883863f76ba3845db000c8dc8e823b220573501527a0f75a30055b30fcec5604640e110a51b2e65a34de791921496a026fd748b6f341aaf25b08f1913d5c9502c84dfeb9fbda420ced608b61c79d59bdc6b9987a6f6836fe28e68ecd8d17867e4e6de64b9e6702e0fd27a2cffd4078411b9b786c84850b391a3644d8e7380e38b7351c3a299e4abd806c13349c07f1d5be40e3b5e76e5da1138a138bead558ddaf00f0d24cf8db28b5bcb21b1a77eea01d97511f9f441c25edb2959df500bd59a36a6e7c47225ac7ed3065a7a82114957e9c75388070980061b629d7869bcb2ce06726eb3ad9ffa43385d3b5adf8b603928f0ffefc459b55d00d379ef1bf2d69d829a17b1a5e2b1a5dcd1a9c926f45c794b3f301049639671fce2555e654c2c9f1ab1f89a7ff2329f1b81b44fb1ac0636c3f29403e062c9c0e3d33ff9d3903d351c38482c6da49ba7afecf1700ac9c0b3358a2949c39cf89c8b6e702ae2fc568f908223bb94ac0f9d5161a1837a1bc71d7c9b52f7e530f0424c160edb8f9e75a3aaa15afdf38755c6fe06673a2899762dedd8b1033b79331107c1d4c4d89cd34e4a669d5466db5473e6c79d81f555d2d82f6ea7b538e24730c753d2aedaa55a5996e005c754c61d60134fe8cdec94d8d890e7b155b7534779f83b0aaced9834ec93ee9958cc9d5cade49f76949425363128e0baeb119a19df47c0aa7f91637c1550ea81ca349de89a4263c25bfda67d1dd5901e176cfe9e5d5b6a6ebf8538d133e7ace28a7f8c0b2dce8573398382ac9972c42f631b95eec6c8e77ff332f616681eee774358ddc4bcde9ebc0bd999d4dd6da68c6c1c5da75507a4d6370652c67e671678c55b9559fa6eb8592d1872907f72411ea3254c3af1408a13e72f9de0b58d24ff40b452728415351fd831de3cdddfec422d6b21e36b07297a5fc3101ba3b3a00596257c0ea9cfda68118f6c32a0b3ae411d304abaf30418d6b0b8d81cf9ff39ac720cd64bd79e2b5e5fa21c3f4c44e479fd49ec73883134267dd21e1ff6b22c8e76b41d16da9652d3503f493497982bcf8de87ed70c919282c0ed4e4b4f66674e98a84b285fc2906d4a7c30aac32613a22ff12ef7bc57903b356dd910c8aba8cd07f2bf35cf154227a03e5bd487ac83e158421158097e5bd04dfd3da36e1cc149bec43bc0421b9b9a2a8122c8021ae7d1bde245384913d8860803526ba4a53c24ff5a7eacd09db7892914fae73718be997655cbb58dce2c27062528466ed83df9488faf06bfcb7c96094adeef49cf5df01fbf70df21f595655bdf106776d34b9eecb5105175407af198b7e00ea7da0f2248ce4c59a0888e0b702f868d272f55568a5a6c021c43751e0bf0ced494a803daf76f853e443bd772029915833d574930ef42671225f5199965b2b0b557b84119443f6f03adf33a0875051eecf33bba151610fab8c5fb787769a33f4736510e29f4643cadd3193b9299cdf8b8ff83fdda07a75bea43091df6f2e066f9b6f54c216cc32e97b6b64e6e98c2952ff858e34993bd14097ae1aabf7aa3274728211f4a72982a72abdff70a88daf4bf1d0b89982177abb6e9092339bfbd1082ea5246ecf5cf7cdccff58388145af59b0a263d044ebd135937314233300767a9c75da44cc9c1b7885eb1548fae27dab73efc8264c771b08157295f3fe5cb6f0e33db6521bdd8b5b9c449bfe0474f60f25d205465b843a2660b29a19842e7cbb2688589566ebc316822f0021e7419e0cf525a95d6b534cdb6f88f359bc610eaf2e199d3d15866b11d1cc55723624f0112277557c780e1ed74cd67d47914fde36dc8628ef401a5583755feb9ffe1cf1a2d469b8b963f9e5128e98e9e43be8b67e483bc309a44851958f78db9353885a160ed2a07313415100abd5cabfb777dbb58f2ad12d984be00bb6f8bb367f2888015ded0bca911cb838f36532160839196a07e05adcc422ef9b0208bf6a6b51b9e51e2c87332f7eb724f7d751b8a56feea77f747f1a7c7ae9b4f737566e43ad90134c7f0a49bcf1005c212bf540716fde4f94ee7eee104a8f8fd0a2e118df14370cfff099cacfdb8c05f7cee2c096c46d34b703dd2c95f5dd931db22965455bf9c9994cb0fa6849ff0b9f7634640f4af9f9140fc4207e813f4fa4b147425e522747d3a5d20171ba1738f6b7f9a7713b2d4e02ac78c8f1afaf8e86bb67fb50c2f1b0c22b410ec250d3d0d8c5bb92bfcaccc79fc8691d38a5e7f068ee5dd9e4c0e498d2e3fffc694e5fbb8b0d50d1ab0ca6c5b9bffdf73de9b37ffbf520330c431dcfcbd2a99fa29095b33469576bce47cf3abdbe03865ac6789e60d02d30b684c5472bc035667da18a28dee3abcc2a40b0e7d0b522d974da807ad92b658fa6e3874075f960aff8a7e26b3232f25355b4c50f8b37c2f07470dfbde51caa9c33aa51d592800c9ab12947338a69365ca3db2b4080ea298556e44580b45aa6b5a3e2f89965eed0177f328e064ec11b455c90873e5042876b74e7ec20ea7bd73d5ffb905bbec15df25d61af65b715d02cdbe6229583608e567799e4bcf485138a4fd2e51aacbb4099e984b556c8b7a1c4577c66550785556a9143d17f05ddff81def78b8f7edcfb12173ead74d0c7a4f426be33c8b8230b5c1de0fe9f472e432232939a4f91b1653829d82553b8c7f1bae841a4a81d260578632376c1fc26f2a375859efa9879e6f762b33f66ad62d1f89637e38da5e5c3cd612e0675870464e664fbb9960cd096b294989ec69cd6d145b880ea5ff47ab4ba52d98d5848462c12d4060c2e463f02cf3ca6cea3320d7b84c2e17e5c3093300e563aafb24ceb6c31a99372b1ed5b05b5fe44235dc998ba664355ec3d67b1089fe6b151a2c0f20d3e1f24590e0e644cd0bbef0794f3f63bae51a6d513f9925e2d4a57d2dac0d3b42f38c3be0e2fa9c8fb25e683cda4dda837cbd8330d581a0609c6865da1f71c83ce6ac5e84d75be3b4f9178ee5c1e7669f4ff3e38a6c409990d4eb0eeed3c0355498749280963cebf5dc6fbfcf87536559cbff17725a360a910a4d17340fd1a7496d2ff0ca6bbcacde338a6414a1f8571697b82b5aea3a17c5e21c0a4873f29c8d755049b9b85824844219b1829c6a418c5bdccc179d2596c7ae6538fa8e135d9ec3425948e0c91e3729de1b269018bcb4fa91480cd9e8be6dcb546d6f1e2f25962187e7ae62a149a13b06f5f1b6cf528e044636dad91c5d5c3f657c5e41c27bac5a3e831fc63d1af31d215478a211740572edb50232fd85e0812804d02fc1a0cae8ee6ffb3101723be1bdb5e7e03264ce656d4a3a524c2847f6b291e2a5add930db823690f65aa50c335f84f4021b0aa32b5dd92d18684daebf8f4e57ac68ade604bfe170a018e5dac246c1246a69396e2302988ae54ee345fa9aa44732e377bca65cce2917c4e877dffd7308a72d96b27540cb1a35e8573ba36aab51626fa5058ff801325c0ed566974690fc3952ce4637b66756b2f0960d1736c4231844898faf8afad2646b7d98973725f538bbf875cb5f5ae4d9c1ade812e5c847569dab311dfa13f3dd0e2cfa70b369f0e44cf7658cbe874687692c2e02d91ed82862e3bc284cf2881154bf1ddf615d8fc31af0023b07169670e30cdec5d643f4b3a57d2bb6c3168083493d10bc9b31db3014208cf345c7edf439658d9907a3476e0bed957e5f83ebc765e5d2f56afd92ffc046424ae1cb460a594dca0e3a29b657c471efe6708a2c45a58c7f6f67829819d5b25247cb4d394ec421681ae9637c6422a4bde5ab64bb10a3caaee11341f710435cc2525c7c00259c092d9ded89009185e74dc5df395100cb3b1fbf20116e5b0c11633994989978032ae5def49799d08aef8a657b620f6d9729394d0ef29cf829029bd1be9aa87254ac4e6325683b381dc1f422fd0d4b4062f140a52c910a6a2a4d400282f990465f8d61773902d6041438070cba574dc9617669adb9f3e206859d007f4d0c943d9e548d8f7caa899feb6f60a093f85736243c56578de6f8c31a3cb797682069785f8173232ebcd3a8ed78b8c8f1912949f480372ce4b69afe23dcf0eabff482903de968f4f8f3be0b3c4c1bd2b2b11c1064d31a9003c53973ffcce51d03b8ba9096cfa809828b38637cad47fa05e62cd6ada1ee471906726aef35c26d7f9b63dd76372855c8c3008112b3d29eb188e1022035edf8e3337ed9fb359c1385eb1433b114364cc03857edc0b2897dbf7f43da7b3692c327db964365c88d621b872c6a8ad74ed8497938cb113544bd86a837f80095a03f46127e112e4956ee6c115c84fc414e8d8d5d851015607d968f047cf06c15705195b60b9a4309aa48166eeb5db6a995d4509afaca8314b0b4498ec0c3a0bee92ca457131c65379949e4c3473f8d28233d42abe35685b574b42bb3c0f896b6c624835c60365cc32a762f5b0239794a00e887764bc432a4060d6c59079dc87e67044baf239de46a54e5915bd7c239b9a57876bc939e505dbf86aa333ce0b6a3c964cbf1b921aed83416e7ce9d0eee35171e5cd7cf0d8243e73ec98f2993868b29686f4d19170574ab67bdc445f85e941564a2f752bff8fefddf54bcb02aef5ed45b799a92b1f9063595f05cd2d520c79a9e046f63d552bae54cfb745cd2ec9d88bc4408a9d35d2e6a509076bd0839e1ef6db3a6c8820529041e2574109f34eac9b6c49668af9b950c0be52318af9171557ef2e153e31689747aeac4fc34b791e8d06f6b4d6a903780074db0b87835e807961fa6bb4ca3e3e39635e3eb7c3ab29c8144393181524a2a402d6e0d3854e6dae991045bb7c10632c947844b6b119428e113e8129c6a720d208b873d51b1f942bd6d1ef2ee5618fe8dcd1f19949f14b91753ca927cbc3b5ffc5d559dc5f83e6ffea95cacd6ca12ad37d8cdf8590150d284f28ecb0307220a5874b94bfc8d9820857897f480cbe542266fe28178cbd8f2fc7510d3daf4d015bff4b4f6fd200dea51adf5619d6ff01ffb0e606bd2e0e713207eb0b24d4cc750c6de7854c9fad4f8b3ed14faddbca6c4a21339f343984518b925c228964b7fa5aaa2c8da15be845dbfc42cca7013e431592dcb6c3025d9b407c3f761f705fe901ac63c9956259063dbe039a9e76a4c8f6ebfdcd4da926dceff920601749789e1caaacd26db1f2e11b0b01a92c3f6246914bf3fdfc85d019540f86116acbc5ecc3f5b3547cb3f03f3b3e89c5a9e43d161a467a2d3b8a0f721d8f8276ca276d4ce02dbadc11a3c9ee79bfc0d7ced69f1e373dff646a497268458fecaa9df01fa12ed6461626e6964dbff9b52cae209712e7d601aec16c6dd47fab19c50e4cff12b1f5136cfee5d24dd8d1e5fd9bacdfc61488665e373366c8dce45d0da48f7303a2493f66e33bafae7350d3008163a2336f4082dd1349b6b2d64e2ffbedd16f72b109f7030e43cc85877ca61cc0a05545445bda81dd4e2d9d39ca387e242296e718b92686113e491685db70d64dea7ea0d4ea0da5983f81ab45002aa0fa333b853d8787c7180fa0f12ef38088b18bc336bb4412169323b6d47cdac39248497b7ce9fd436be0c858e11c6a73478240e01b7f68021311ef9154dc3686b16d990f46e5b056174176640ab1a54fe6062f9a3fae4cc3c7dd4d35c90e19b78ffafeb2ac427a0376cdb752b98c99ffbcb9a79b6ab8e27466d88fe8c15189001d8f44cbe645514e22c6429a2ec70f509c79d5e22bd573c7966d2c60a6bdd363e19b556c19580693491f1001f9abca14f3bcf42bae3d9cd219ff464ebe09f9d186bf2fa396b4218ba47651a5e502ea081d67170effab563ac824a3427f0adcc03b41d08d9316c143032d2489fb184198c0429dbaaae8e5743e25b4e5fd14b544f78f1c6af10e2cf396fc24c87b77e0a2682f99a7051a7ad9774cad8493e8b745879e218d7f0745dd54d96bc19d49e6fc518f331b6fac48c6ba91793a22b09504dd5f111c73a885cd187b06c69e1d8030402f1f163a7329c424af3a52d9705cd319410ebc6280045b98887fb4d8c2e2c43aa0f32c86e3a3b1db9993b4668221a4e05b23893bab2a3f126b565aec5249eb24af2c5fb9482cda50f72a5ce847037a71fd22694592f02ee0c9e891a82a542621acfc4554db20fcdf93e809663bbd748dca05ab00427102f5eae21ae79b1e66da2bc8bd8c05858c223616b6192eaa5c38bc854d58da3cc967b20807296008e1657fe70bb701dcbafbf926aa8f5665f545680bdf892a18f0095708d49aa285b24d6896a60c87a88088b88d4ecde4992b35b3bf6f7456388dde6f64cda5b76bd419f4ee22690864ca70baca8404203c4827ae7f86b74ad23dd17b06bc1646937cbc6062c104fc2e0137b44562f6a893eb9b33f0ebfb2d4b4b2b42a525132d6075a0062bf36d5d7abdcccabc0a448644b22e4785c52956a962e4a35fb5546180c48a6ea70e31911eeefe7f2472d89f461c3d0d5cc0f6e1996711b16b2a4d11d67598bb5ab2578fc8b72f8a1886a097d44cf96b3a68248ae6c8699320a054018846864955a6143c319a7cd740abd4c97db6b394ba24297aeb1404a7cf9b6d790b89549c325b0670160658305a4b3cb45663a4431708d5dfeb67950c1017542720f606d180a512e901fe16a3b2f398438c466c9a1e321f50aaafcadef241a52b27b5341ec7099bcafd96dc6ddb7b7c077186b2fd08ee8834c827da257fc22dd43a10affb8030f4479c04f85d7e959153281e937d2dc04cdcd5094ae82fbd6dbb1313a33467e2b3daa023a1be7b26e76ddbc0e8987c698cb752a9da359649b63b20eb2512b156e8e3ca55a24ad58de7dc3348f8f905d2f51ffccc52aedef5aa52babbfc456af0c8707225cdef5fb0764df0f34d808a07078dcee95065e6f8957582e204b16489b832698ba955a3ef077738a13156699e5b4ec49ec0d7071c8c2a7973b42f112f42e521c4d4ce20764249abb92ed56e7fd31c3ae8d59505cf812d49e7d5a65b8777c22fed73e872691a714910b2a7e5d365825fddb8f7d97ae209f885766a9d3805f00cc47b482cf2ebeca260e92955adf732570c08b70a9a874e970be47fe4d2f0c3002388299df160fb8dd454c5e67b67d0a6b8d9f9b41dc887f3de931813fabc6120f36046ddf040c277ebf6faf3cceabdd0cc25ad0a0f0b22406d7d3a75c742bbed5c22aa1a9f77a59ecfce66d473b10165e1a6bb8c371845546fd05421e20d328ce10fd31b6d1b805e95c91cad1303cd13a2b4ea0fce9bb0e949a5a9151997bcfc0ac2f423aa3a485ec956ef8a4818e156d684fca918d5b1210b730caf8f0658236f07cfbf92701932a52adc2fd67e1092d4088dbfe52bca803f188e24d31041c4b2cc9839f4dacf1a14f0a51e1f13e10be962b9be2081b04fa01da735afd7468f614c12a2b6912bd194d3470bee2719d0b98ca88164ae00d8cd27174091f60755dc1ce328bb56e1483e284f4bba0f2e1cd1970309a5a6a5a776e7035bc55e05d058de95c6b8e73b97ebd9cdb0a0d77d50df339e85f15c62ef5f015b338d07adbea2aeb5072239f561e54184e4af3dc767e829b96e915e6f45e4def6f0165a09f9ebff8754a506c119075db183496205f26fa424f1e23f031ddd3922bdde1659cb852c2b6acc19e6960e8f024675bd07c7f684a574918b3154d4ddae073326703941c7582ad6a2358a89878f49715002c8cbf1a2c097a92d74243a89df663e5e18e411ef9f935ac9e4db0f48a339e2152588c0c8e51c27818805fb13bd8e6e79185ebd58a023888381d0157190b74bee52ee6ea8643e8c802f9654495e942cf8efca925465adc0b52bd34b05d190f16bdeaf14b05895ed3b553fdf606b1d507397d9915499539cc0c08a705e26e25cb25d3d7670b8934bfe8b63f012148b236fe2a0066362c04dd24dabc9e30a062a0769049f1e401e9268aabdff9beb3fe8bcd34e1761e3ba457bee2d79665af796b8c237a26e3d8aa9e3f750c3aea14587b7ce4c3f6262032f4084a0dd8b07b4534cd55db9c02ddb8b26946b630cd018f1dddb5e743d80650aa1856b78f4e5cadcd1900e3becf04f5eb03745a2c0b89e22799787215f4c15fc87a3fe9eb96035a4b227e5339fd4eeea015a0c20713d70a9e495ed41e62d16ff23df99e93185db5a350a79ca27d6369c38d867a60fc0fbc374fe8a3575b8c8a22fd3b011ae8ef96a6c88094d6d904357db652fa50d1c67d0f12e5fd00a5162285067e3df5b251bf7b89068fae314ea31ff6aad9cc7aaa211ce78fc950fc8f6836f2953bf3da2553aa4abd6f404fb841a59554599d340a73810e51f3b92e26e9580c27bfc43f504b11a32d4332bb4272acb1270346372da14298f360e5a39431ebdb0d1b839e95b6771d3c6d2f85be36f762911ba25bb0db8e8d76af60a6d14198372ef19523774c9fbc456a220d648d9feca9936a3b9036eb395aa450216e2f47babd4335cb20ca75e3f180ddf170602bb87d0e8296afb4c047b089c3539ee85a679854e4059419e0bd8e0ad7abd96ac58c244a51d587515e8d6d01535d4398ffac3f0ffa160c0b995c6e471b5392c6ec23213c79b379eaf2284ff933477ce8930679aacf1cb32a311a526aa4c1a2fcbcae60fe2434a3cbf1629d8ab671a4db9eda47f356ba25d4b160ab81ae2659f67ea644cfdebe3fbd04ca08e3b5a078ce6d08b69dc772ad86ab777d2918beb6b1d8d7d21457afd77e1cd4343e8b9f22af11c3a6b81482f931da634dd5f83e23afd2b63b81439ae126e614e1d4ef1e4ce0f8dceccf8c593266277870dd6921d257948d2e42e40949f89d3271a34eeb7e40e1faed8b1093cb2ee0f0f830d75896a2ad0eb8b19e604aea80dfeb3e1c1a869fcdc20dd39774a2744d3b25af517653bafa3afd0804790a2e363a511a8c98d9df7bd1bb8279538fff6dc0f8ba562d066185aadc6182b1faf6d29d9c0a0fdb07b08b8702742885b0f34f0d3ba57175295ce2baac7692eb50a18a093514b6c9076daf03be026a49790ee319c6b815857bc592d67e3fc74386b742e7d0a5fe5fe5f69c1a4e3b911ccbaef97a1def8609286001412b95d372bf01f4675eb6a1294b5934b68b664e1b556445f0520b558de254082ad9148084321e5a0ab85988778dae2eacd346d3a2b29db3e5e2290ce9986c9815d7c3a60c9c4fc753fb6cc15ba72b631d7dadfe37574d443b52fda93371ba8f149b03ce21ba8e42f59a9389d3e7a28d9faa9699d3b981a146051bf6f27768c93083bc880123e54c890ea348b96c626c8d10ebd95fbe5a9770955becf137a3f6bcccb134db6ba82f78df0514f87563edd0ee8f048b54bf4318ddd2847eadd537b4847ab038f4124f5f6a76e83e1dc07b522771c00f5c32c3e64d88624f5f0445c43f041619cfa6e841ea8fd1fa7859c424cdbd8440940330a41b2348be00e23e4605aaec0f46348483e0a3b18d8ee0eaff395d3abd1b1dd498a1682bf216830b98faa29b899ea848687ee576803bca07eb200c8a9429cb03bcbed8d847fb434d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
