<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9100fa6324b88f3ee968edbc4b98c14478e62da4c18cb5fb30a340442cd0aa0bd2094b987d3d77e5acc92e3018923bb5ab036382b796255d3f06c80be2a1aa94b2a635d9f1a48754e5c14a3888a4bb640512fe2fdeb904895d063dc11f15c21a137a8d72c6b25d9fd2c6e3ec7a92fc04b89b8979ee89011de4c7be5031f606af1625a85c7064bdfc661cdf2eede68aa4045c819a06528fca247e48e2532d43997fc61cece540ec0122b2b85c767dced4dbb9f3186c4f75cff87b2501445f25ff829f78c45875eea2872bc2599fd62accfacc79cfb1edf64fc877a23da47363971b2debb485576480b8bc13b6a8ee8c964fdf8d8b2a1ca4f5c2448d7bc8c7be14c46c7382fe9eb6e3352e0e50cfeff7bb27d60237587124baa9fe65f709027c85cb57e94a5ff913d9a119a8f2baf3eb8579fae0fdb330b6e0207ac694263f56c5dfce3f389e68b28ef14c9f42111ee4cf603390725eca78bf6663f7d91d772f17773312c7cddf823e4009f40bd5e7cccd062aeb4705be09eebe304782ae5f925b627f43ca893c8f9ae2b84ea603c57c06162f7a23494496704aa13b90bcf37e3e5b7f49db2959df533f4161e6730301de631b83d0ff78ed20e3b56e671f8efd9864ad1ee964b22ba4eb224bcd7d336fd3c291e34307188adfa6f4a0076db77ce229c1425138c9827313cb9fb737ea8ffbd015cb99630c7e52e0224bc21c91e563280cb193c6a76ec540621a82ea8299975ec8aec7b999335ebdc25ea291b008a358d939eec3ae66490277e5a433d80d4a555674de2d0f42beddda6449e4bdd342d607d0226c0bce447ef81c155dfa2718d494be274c9a2c0d240bb5f1da6a3d459a098c0852ee12ec69343eafeb2b8047d5131cc2a7909266016d387b5d00a4333bd81bb42bdad1a99b0faa851c6cf2b386335dfeb0159f38140427568f6c434a1c1703954a77de0c71a1fc43ae9ec3110565ff3c7e6b136c8c8c3687db5c0085f3c07377f0361236c787707cea99d49880de6da2b507a61cd2ef9a23f5a7d605194d22aafedb1a0406185514760fb1100dee1998500445b0176bef825e0064c2023e173b2c17d600cf6c8ec4a95f22189b71340f44de4c6055e2b6a8e509056a8408422c9f1071b3c75f9b686706009d90ea8dbf06836b22b6c7fc3e02a8772370d583c88af79b46f34c58e084672464fd6c04417f33c12434ed7abc267c8346c0426e65aff61ab5f76a3fad89ac7ef780e3f6bbdb3b71f840fe11d1eb48e3e64f4158504f72a0bf2b310fe493aa4994d6c58b412ff05e59b276369533a642cbfdc664bc92ede82573d4350ed9667c22a746bb37f7ee5537002e50cee37bf3cf2dd7d8cb4938c4549a88c9d804bc42c47da78e3ed9db8411439e2cb1a4e9979e1439d175a5ea3f4763c29088a112d0c540c3866a9b8da338482341bbb03bf15fcefdc27990d714e15c60751710f96d2cb318e299d51ace7c15d0010b6f56b452c3f11f6a72b7ffd9212a92a123096a14cf9a9c107b1189ffc2d36b51e8a8cf2391ec7726110bec9f48164c568183038bc83ce95a10d5ce685ce25fa163542f0913045cb7a6dac82a54cea4c5398132ca149e2e05b3d0a0eb8082fa267a23ab28e7928490d639d0687c522f637f745b6a31cf05036927db95f0ecf5da85995a95d58f5159b7eae3fbd92ab5881116f993197f93b3e3371fc61b70983b3e87a26032c44f1c4885b0b00ed3de24b4b1046367aec699b4c31499fda592be8f2a0d8515cb0d7b02b5b541ceb236720c35adbca5f2eb0e14be25fc668048b560f5fa6a94f39f3f298c69f3e0e49bc8099f4e1efb5ee32377305a6ef2eeb5811767c65500c40819b70e45c6c00610baeada823342829060bbb0272ca147fdfd6137d750297adee6894b074c6af50e24a20cfe89ea83b1808c2f6f8a45155c7bd67ef568d3c3f33c45b4565a5ceee3f3aa4f277761c11442ce0a8c68f55ffcc9f2ffc2dce71fb88fd4d90dd6236fd5855032a9aa353d0a0f2cafa6bff4fa4c71c6d1ea4232dbee39e6fdbf72f4fd5d1f8bbdc1ba260825ca1f60c99d15270a453b5298af93ae672130f649297f8ac25891282f3bc20c2c28e098e0f33de884acd9054e851a844abc90e0f2ab1109cfe7481e845efd8ccb352be907779ebeeced183070f2c1908b0b515fd18b74a5c4457bd0cddb26ec3c8e78f0854f2101b7367c8715e748c43d459c28b4c45312d6002bd52bab8ca73ae4fa607bd0ce8fb69ffabdbecdffe6f7827a267c7071eb097431613d5c536bb6ecb8d9a2c0cf9d23987a100fcc3e886e2f6b78cb827f68ab66470370450c7d7dfc614a059742f481f3f2e3a40e9af3caddfd10d392fbec3e57b6ae650a9a0daccc835f2f343a66e517acc040a40543a44ec1ee115664e3d0954f5373be3efbb9c1d617e822ec26066c0639cdd47f67a1cbbf98673610880eace3581082802677e4971dd0c034d9d6e76ddbe1e970db85f338a7a8d09e448d514467995a2345c69c905ab4b93b22e0e9a33937e175010e192a04ebb784dd030e56b7e92e1ff742e4c541eb329731bff9c709cfad7a9836e9abce3363c2c02f0e77217101da4e357e7f767981ef58a3b8a1cbc9173a637c723021646a1fa627c7388a2cc90bfb9996f11e5f332f50d0c33891882835f98ffbc05ee409fe6ba3e1493c40c4761e46c4c998294c39c37edc54db80400118728ad0cef2cb6d90479574c2c9d853992dda4e68e865d8c1501d0f4fc3b8d2776ab50d872f60e59c7017ec06f835ce68ec2333a6aa02159515a6099aaced078c02d7650203c5aa8c3c47928c094da7eef3f70bdde6ad2b9cc26eaa54b1c831f0a3a57b13ae13aad78c79f251fc30843ebf1e6729849d3526fc4ffcbfeac34e383fafb4cac0d64c14755786d03837bb1253506e9ca846db3748de2111e51d9bff679576e2408b343894d6f05fd743810677bd6a548209112bda9a897eeee0229df116bb1ff0e1299a4f4783e7ca20f4ba2154e48a7f92ccde177abacf709d99c61f2404353c820286d2442d488dd71200057855b443747b84dd35b0770ecd054f95043fe23735628fb2dd649a545da6008235a0b02f1dd46716c0baaa79c76951f2ee0394a06548297083135fa5752330e1147b4b9fc18fd70d0617cf130a5342a8e79599bfb70ad79388dde6979da69247ea13b718a647b34ae6bef9cd75c0d0d8a1a562fb444789e1d1d92aa7b1d1b72c3a43bdaedcb7595e997059d58a31b580dfc575af3d33a6fd0853945e91f431b78860645fa994bbd20fc1c93b92e3844e15a03f82a90aaee494dc4d44447d47ce47e2f6728f790b9aff1b43aebdfc30705c1ae60c3db4f40285ee3542b3bbdcce3280c603d77e21b860d1bba3380558bb85b20567d8570e61435ca8c90f3aed7347de0634e3be7d9972d49b554d417e5c953c89a12c3ec2b5fac14d276366c3055371d25ef21783f07efd839b56487fb81847318acee99e514fead019a28e37d0072160148d27ab3400c4de245b7118dc6b97ccf5c0918b901e8c050925c1b304087bbcdc340b8386e9d3b09d9b2c7017169c414d05c285ae26f5e23c11ce827fd6ef73030da8fc618207a9f0e3b5803b7c2161194636bba3733f7e8dadbace7276fdd8ce8ecd70dc9a924782ca7f31c9c729d81b0d819c0e2c2a4ef59f5d39b8345b3deea8caf6b9675e8d381f9295020c32ba799896f70d3daf6d0ed1e14a1526dc2df730162dd784a70699e4f8079aab5a3d1eca72e1f2567b0741e3239e3f25ecbfdfb959306ad80d9671e74622ef893bc0bc2d9e909572e3d4efa672464dac90bc53562147cf9642c8eaf8dbb18c6b09c7ae478df68dc350b71c1672e8e4ff867cbea20336ca72b0f26fb19ad7b0df0558b4cffdb1f326a9fa338140753402ea4b9bd4ea3e65bf362e81671bfd20e267c4282a96d06aa2d5363eb5f53116fc33d4622199c651beab9d548490357974cb1c20054572f753d32dde67c3fb28d0b6c8469266145075996d38a800f1629f5b1650f94ef3db44fe88b9a13405f1039a54392147f4dd7533abfb277a0e8cc40ac5d71e04bbd1c8346960e25e079bddee87c33141974fb491f76578ea65ee05a247ee97c62ec6a0a061efe848527327edcb5e2eb0052a59864550ff3f7aa92bf3ba2d20f6d20da5f5919f9280056464e374d430abfbc7112ae771478fefeada6e53b3c3e61188633e49131968f4a2fc6e200497f9116bf02491b774accb2501179f3ffb1dca269f60c799e8120c8cbaf24d18387fbf2674c20a1aae706d7892441e0851c9e5f4510afe78a0c6eae9f4b3699092fdcf5af33827d35e66f5269ae5062bf2d09bf16a735b29e4616201107ce681323f49564b3e2569cc4cf20236f6661c1fd510a1d709d80d33b0954866d04c84749340bac0ab16d7c4aac777a72b139b0dd111850485381e6e18fb1005a0b6d5c01c96d537e2f85ece30ab33db1f1dc001d951011c56177ab1e797171aae9a4e01a0e5b9db18674d86483b4fed01811258792bab0108eb222e28c864fd0096bc3b9e2c09bec9553cf19441391ee145764460f265e2b3d12fe861c2c354773c98d2333cec87069cca345f930762e67709830d092ec8d0dca05ca8b637f97736d3c24905122ed79f4ad6080d7eca77ff4182f94d99318418fa9331fd1675aab54f86f6d2a65598eb0db3324504155ce56fa472d454edb1cd3b1c075b17e31ade45388f1f990cb590ab8303d981773860a50f49ce027a092c733068f433700d696a7370dd47fb1e3eb1683dd4c16b3ce8a94f3bf101bc43d009829c9e0e9fc4f01b564313fef21f9bdc3ccebb40b26fd4e05f006522d8f5b0f6e1fe8663afca2966f9c75df705145282023cd9c2d1901c5ec3d52c551ecaeeec9a719a39ca1926652abd098a2701158cbf1d7897d61ae0b8d01ae58f901907fc341418ca19503d31771f5aa66ce418ed34c367ab3f3820b14cbba82ee6982dc5619a52d873e4adc77e1118b92fb3575fae1ccc43d3bf23a686768c364a489b454848b3ff8f369770d221b34140930e1d976873a565b2e43381e6fbe1cf80925a5d53662b64113677a7acc7e3a5a8e7831168d8eaa7290182883763493eb3d7c0e4079dbf760a274c44f8c22039021821092403bee0e43baa77eeafee012c6b748e353377bc7c56b3628bddc41a96566391ee736703ff6dd11fc8d7139e99680be8a3c656799f80ef6fd29565e00f2ff235de372774cf8f03766791f639e6b095c47bab0d2e177ea6758669e56c6a4bee9d9888b493e91ed8e1518dad7fd272b447f81f51daa0581567f1fc1b8fa898fff8c9cbdc6e43353613959165bfef2269e9271232245b825aacf8fb3eefcfa3dd1ccd8e5ee66b8f4e4a2e506674d9240f945a7444e71b0521d8fdb10f2f1e7d7f3f6c26fabf749588cf0d120a0c0b6787950580f6f5400dce4053a0e256f321b9cf4ffde49d33f0a2327499b03c66faaf0d5aa0074382d4d09042673b42465a27b31e072903dc9ea36a559117497e995aacab29c9a19c5420dead2cdd563460c52cc35c85dd8e831b3c9d42e7a4754a7e65fd0b9a31faed930d4892de1d2053601ec94a22f3bbf8f76997ad84148496e620a6c0e836d07d104cf20e6a6cb02c214b0a9dccf495e67ed1cbfea5f601828d52419977db80cc15284584176d27f7466e28cca002e41ba57a74ec10891a9e85e822d0425d0a588731a6b00ccd70907cf2b80899de0d568759e17e814e847fe4899a66182c8a0d206e792a672d9dc5e641851e9aae2bfb59f5c68b884783559c14e29210e1c6ccc26f5cdc94ed80b748d16ad57177bb329b3b3db77bee4dfe4b9a4ebd8f99bda13e7e09dc41ea1d875d0a69c74e55ab8545c187ccc212f5b97d0568b3977def0a7b87a411bdb5d6bdb98162ba40e1391909034ee2665c3911cafeeb90ca45bea278e046ae7f9223e69bf4b14f6822a6ca6b8269f43218ab1c77155a6b7324bf3dcc18acfbf028166395f81c3d3c0993a5a5f9d6fb7c08d40b5500b3ccd0197e89ec48b7f86f1633c004201914a61934814734eadc6ab7c063ad3518e6dfee6029637fa3b03e1f62458043752d1c029f3da35a407796893af756706aae0ef791263e7e997c6deb3b1246a7bcd3fd2c573900547450093c4d108b5febe6c84672e7d84e5496c64bc8482f9fe4a0e20aaa4495dd13e59eb299d8ac81f7587aaad00c94dc755ce06adf7af2af6f96b8c3fa8666aae6cc61bc70139563b5843f088abd057f5029ae737fc8a2e19987c1217a5cd2b501287c8dadaf138f0473784ca54f56f06c33721f33b63e2a217814f20256675cd189effa5e1af2b49ecf9f5356139ff863cb46103fc566aacecab6b6ef865ee8d3ab847aab069a5d8b30482f7eb903584f2b0845691c466dfd91c8e37a70e4b37a0bfaeb0aad47dab66a2b16d586cdaf21619a9422356b8bc4c7c6e36c2cd71fdc9bd3f3632b808d3cb67e6d250f252936d123f69a097aa4aef597a0586deff79c4946c68904f20ab388757ab46a209583d3661f29e830c32e60f0ef4394a181c8d7ef694e143564cb343c69ccfc9006d53ae11f8296af31cc1c6f6dd8cfc989e1aadd3fa33954e26aebcf3a9511b468745522dd5138187cd216b30dddf5e9a489ef3adafe4d61cc89624ae8822b926a1e6269e5be3bf1b798c0efc1a16e7a1fca71a5e2263e1918565508fa350c137a744d58e0f24a04eac10a5760212796534913c4c23e3faf34989297ae4fb56cc4ea80a536d33da5e0695d0865b0528988065480d0f56defede7702c30c57976879fd0f3586e497a44932de9363d8468a6496f1ef5b2cce65512a99e196fa20149cf5c7bf45e685fb99fa5e40e51fbf17cf52e379ef237819fecde954f4cfa589aa69e2140411bc3a4e6d3ff4cd7e34bbb5858844a1e0338ffef7e33ad488388e0b2b13ef2ed948f5efb74dec65c0e832bdc8fb5a514c04dfb1cb9cfd93892c593d6f3b1dcf098547f5bcb373cd78cd54ec2af0497aa07b1cfd24b352f98f92eab5d8afd2512b077adb98dd1a5e52a82be1dc7a2d3ba25e0e33c5449f87920156da584c43bb063aad9b19526fb838acbaa3bbacb3a14707e4c8f20f0b3eca004e6f46285c55e7964a93140f8989288062992215154894df7c35f2da78f1ae121ba23d648968b03d51590e8b545054652514dce0458b3064f3ae9e3ca5220854473e7e1e935d954187b49099b9c5293c6abddf47219b7de5cdf75288c176514178cbaab6db409610f5998d0b78bc4a4e998fc2d41caf7720492b67baaa9a801708624b3878d18cce1e02c8241663c249a799639b86b5f355d884a0308cb13c917acf3694858a5641dabeeb40caf5235ef864cb0dc6c2646141043709a99e61cd495a835b6faabb72ece6c7d9c6ed204fbfae3d9a5f97d1dc8851b32c3b4109d3bc7df2a73433e739074edcc3b70fceff51ffc3d96978eeb4acb6773454c5d66d2f0059e903f2c24a53980e727d79181dfecf4dde3b19d8770255bbf679d506c0d8bc8a09dee72d153e2e533317ef8da2fa8876dd783a06b38a231921689d784d6f1ca0df93e985a4cf9241567e0d3607a5e9b5f4ed52b6caea96d55228f21d43d2ad8f7313f0764c86729a3cc59881d025457c250b3750a94869214e4e66bf027543d75cc0290e1fd585ae55121bb48c9345d6347ff67bf9f7f6fdc239d48726454e245b3f565baa1d9b39a0cdb88ad17d86759fb3de534f1da5cf19b646c41b4cc98a7c3241660f82ff594cef70f3594cafc9820495108b91c45188768b571a55a1a14de52b32312799945d3a11db9ca192fd77a6ec9d51b94114b1ba7764a28e3a32ee044bf9b23f973fce7755b527757087d38f8e650ac02a51d1503d8dbb556d5479e87544cfc42abaaf551bb0aec62e322e9b442839ba9d04b623485dcd105f5838b2c2d046daf35f29dd8f0ba89ee2143a285cb6733c2deacc82e0649e4dd415bc0cd616f16f1d25ba68c98617fb1a6d9e0acc68c2a9b8a238f8022ef0326725eec6298a087bd2c70cb127ad6c8fe75dae71c4ff77540016c613367ce875c602fd4d58299482bc258478b0c0ea42e5749a7872155fd9e212b66131c217fa5bda8a5d7be87f34a130bcacfc14b6d7327790c99c5eeda918bf0a09d479ccfc5daa241409e7f61779fe45dd20aaf64e0df1dd61f2b89cc9a321bdbb9fa3de19ee9bf4a19fc1ff65916d6f52f2e904ceac1c904f04b45ae256e0418c896fe28c4787111d83cc5b9e8b4de54150b92bf40f63a4271d0b81c26710ab3607af7ef27f4ba95f56f7a6cc5eb02cd1c16fcd4e7f13256a28de733c8d74aadae0e955e324a5efb7b2f417936515f1273f783a992f7312eb87f1938f2f1cf4b552a91a61555825580192ed0261e404134e5f40d37dac9d5fba7c1caaf696188d5db68f9e5ef38c592395ec3e13b26f8243e4586971d5abeefa4ef544baea8e323bede1c3aad2a47833ecff4391fc14205c7a279bf7967b574ed714c2df20cfd41fb94b48d16afa851054b3251a8f5fd911cacf3fe3f959a0d7eaa2eeab0926c8162efe5c4b8210c922f50dc8195d25d056710af0488c2f9ce9416c1fb137e8c3511e4c201fc8b82108db352009f4131fac0ec6816119e7dc9b5d6ac1edf7d21a07dcf852147209f453c688b7eb1b63ac7423fcaf1b3aa23c9cc8a826bfca73e68d4ef602f7f2f6a236c4c4742a84a16051bee0dd6703898ff26a535f1987ee66f5376eefc09856e84e25bd5747160bfae3e88de5cabb9678208f450b04b8707d6b17b0f6db5d81041846b6fa5bc5818f65506465b77c5c92064db8d46c6d77e005b4cd5dee0ac4ee2f8794f209c8b333457258e74ab52affa10bfee02ac880e7c2f3f393cbd5eb31784d193d1cf76df2825a7001405a8d5ee2dd747ed6770dee800ce21852be6dcfd246ca25dee100bdb6f375295f1dce6e03aef86d9103330c6c1fe0c2d37360a341e19de0962bffc1cf0500b1960de83b823bfeb04efa3d24f9bf4e0c716ead7dc4dcbb05ff9e08557873b78086a5cd6e3dc3cc7a5d57681d4a5318e2895f87161608c67f0ac31c11ad786b9c50735807fac573f274c4f8b02821107368b1dccefd287bbf7545d4f4d9709b775f2c40ab08b431aba760996496602906e7b255539d71248cbecdbae506b71b456ad7bc46c41cf6128ac2a095480c244ad040510f5bb7c1493eb6e18ebf5713719cacc4c123a66b82daaa807a6c81157b7eca6a070d39fdb888971975535ae220f731bbc1445c1f82beed45a7d24fbd68130923612a26a594d82eb196ff387614d8c22ee69685ecfcc73c75369337e35eaddb6ffbb89ed3e307fcdd6e8c91aeee45efa11f1eeffb5f17aa7a1bd0529ed22672d642638779877f8738de2942f3e1a5cfb003d725732f090f11c7234aed7fb791234fa08c7a6a11962c0f98df0ad9fc43210cfe713b8289290061437b571595f2f038f56562a6c227b450b5e40696065e8c6e879357265eb03db2f6734afa330190667ecaa6d09a0424d3af47917a48a18d54c2e3edb77479abaf204ba38ad529924ea35dfba43f6d57c21e638321857e27b7737c38626f684a39e35a90240a6f0c913e20ab186be12933cedb25bcab5645c1267057a5e13e719cb83082a83988ec6591a1409c0292c0909eacb9c1793c2c235fa7c8436b036c18e0f1168d2baa3cf871534f0173c7f625cb571c2918b973bdacc163336bb839860c7da17753de874d90777b54e5741286b536f518ec96a0ca908c167a69144d4584070aa994edc8843c4b105b74805cd73277c86529279a95ae71ba3e4e754406755b767ddabc0979f46f9f77599d56105c38d4008430233719f52bd61b1d85cf2a01e43a69b06a71d619822490914e7ad21bca6466196162042e5be3a18fa6e5ae7d20a29c6ffc570e1214254816b12060c0a24537f96b9379691f4a324961f83ef18ef61028354b1e8de15de3ee08d79fd5fd9ca00a35fbda8a5578a5fa01d2f9c3ebfcf1fa4c1c1a31427ed23908daaeb26e98fbdcd219a6d2645724aa24481e49338eae632368f924acd538ddcc7aa65f77eeaa6d7953b03fe194e62b6c0859e2d1011a6004b9bc73954843cbf388a90fef4d7f2595f13b6f6f2bcc4060e7a7ad11135e726eada5134f1d69d8526ddc9cb53a5fd45c45f1bb792f9e82b44cd28d96a39a781a0d24c370d973086a2cb1d05148b48a8c35215c269f6fba5c41bf2b85bbf0301b01a075d7da0d213b849f9c2568909b7572e20c3d6ec2fdf67f03829deaf750543aea4a5ec932af26b1e64a1d129981d05028a35d49e41d52600e21c51cb860c6dc22dc8d791c38a36fc537df1a8f4eef5d40199b2daa94ec9f5b784efce7691f6887fca6421bb8489b2f0c28577691ec2a8172196c1300a42e54cb84914c46bcdc790d176eff64bf486ebab08dd404de25120597e414f4406cfd771dbb477ea7b65782129caf9311ad43c8794d54d810db9bc94aaa6495484992105e2da8cc5b29496f384248e6ece3ebe86bfe3e9f778eb65caf4bf1fc70ed7d099941c7c0c599ffbebf52bbf4854124c9950198076107722363262a34c845b2f73a14ca3cf849e1e5c24c085a993c7508379e84d244706cd1d9eebfa16b521360e118815fa3fced1f4642dfbcf5e1e8a7239730c9a4f5205a6fb41e16ff03568d66dac631eeca01b52beb09337d2914d7dad4bf9b0ce1a8a9b36f4297c9e1928e2053055b2678da79d6084e23c4e979ef7d4afb43329fca3a8ba92ecff77bb20c1066b523e6170520052bcde82e18f2d195652d93575a06c6f7ced81992eb362c49b2cac84416f16ef374686e60112e068b76ad7bf677b5c3a0850a7f7ca163d9188575a38a038d7e8aa6a03d3fbc7e20a9b74a40d52082c70e167ce16f65424912c3099718f053b2229d9adbbbe9c09215e8c127ecd844d7aa1efcf16061dd946b1dfd28a7acbd6914d38719ea2c154e3b65548b4d9a8d3d0b9ed58a07fe58c0759f3c4a2fcd86033d708f481b293a47b7810d4632142ef599539d1116e6d811eee9d28d6e66dd49fa2deccf14aa39501028876f5e6d77f4e8a88aabe127131a91de685b084dc81118ed0a7b25195e3babe2a03a50765e76f44bd91c05f56402652f095965bbc55165bf798565ce147c5d49ce8aa93e4d6a827590929378c8cacf454b4c71812667abad710c874c5209665fabb59f3544ad46bd41fd40f68ff92693fba4bc7b372c2324ae7d929a80a39dcc8d83da5387a95ee8a4b18d0fffa877d317cf6cdbd0d7c014a063fbe31d2efadf7561073eb23ef5bf7612142f5e085af5f5fe4ebebd50480dd007753ab05b4b31544bd20568029f22901b8efc9a3d2a841eb47d9c1ec2c14edf540caa1cb68d09315cf63a6550de0d4b77be7956d89a7a4241943ca7d7bfa0438df3af98d4d95c440c60e5d53b6cf6b7c105ba900cdc92333374feb88d15805a3c2376264fba494543716ad05a1bde9bf314964216f9ba47157e7f43c51ba802047e17aee98f46515bc6035ed80bbaf9c9ce266fe69afed918a76877681f473a9d1f3dc9355335b1fb06a6bc81f4d783841b5a273d9a207a68a502e372f0c6e5f4f88577f1a939e84109979977f9acbdbb25899781aa09ace0dd3ac9bcfb8f1431bd5493cc7e5580a54b17ba43a5461c791e047b905e6eafa92ccc636cf0e1de5c2affa4a79c852f3218e1fb882945dbc892f1a64069cef60acd7a95c522526027d2d9e6803e168cd36daa77c07762e0c8ccc6e8308f28eb32645299aff0d91b4a07101b8ad2010fed6bc1fd304adfae81fbf9e536b17f914ca5588331e84b55475a7221dc78d65a407572bf2df08281421537f5be9fe9fc9c5cd1e2bbcc2c9492252c721fcc05c1aa749aba27227d414fa4b2356b74dda7666d68afac8874742d541836c639dbb2a169164e8b54236606bb79f9da8f9a38bab4120dd8c667dc03388345accc5f4b9284d931c524a2034a94efb84231b8203c522107760030260e687132739ea83eb79a73d7f487b9b73e1695870ab681688ac04d33a0f6290a3ff7ac14d92ee9bc2de36c74d4350d7d1f1261c2d9f8b7f58a1e3f1fb91e4b5b974acec1adf84a012760bec2aeeeccdbe89c242c4db5d0404f6dc0efc301db1acffb230e1610839c155b6c6cab863c4b8bae47ac42f6e6d5327bc76e3c39371d2e9a321167c6aeb01deeb606900510e84631891e2deaf40a3bc668a6837cc159733bbad086eb7964604f5f9d7882ea531c340248748222ba694285bf4068590aeb3429744121b0793e3790a821eb2c4ecffec6b87244ca901efe5c7b6e42733faf79231aeb935ece23cabd890ef09f269b28624605ef02d6376cace894449e17596e7997c2018e9c2614bc7c7c133e3d5badc5c1a1dc2a292e5ffeb970c73973f71a9cbbb1dd9deba353485acb11d8218ce1d53482f22d6bfa7474dc5930414a175461ac3cad0d7c606026dd5a42ab54252cf4dbc09972d330c92c7e94eeeb9c2628f067ee667330bf318f638329aabe358fbd4a7ba43417fe0d6d4d1d402e0bf4287c053566c8d62cb6a35ba9c5d2f010281bfe3ff92b54e92a533048a21b95ef84a3bacb3606dec4c6f080f92b6fdc6d726e362adcd854f4313f87c433e752370f99359a6dd3f3559781d862455c5ae172c9323c2b4729f0f14d0958c0acc7926de2173b17bd2d613020df7f3d7d4f7ee3d9d3d1c1f30fc0dcebca61205f77352af5dc00733f9208ec228954d7913209be14d195199c403446b86dc42cdfe18b7adc4a8b832ca111fd6b81491258974c5646a6bd39e8db8cd28d5c2637a01e307c0591d9cdee3bdfe67f29261ca5b9f6099fe1efe9742016b3800ed404fce1d07ed7fa5a13382cdd8cd4b64459cb1a5aab45738b34e99da9878fa1082164c56bd1e70dcd48a516fc46572e6ce2fa9e330483f7d3bb4025421f0d2455ed8899667e94cc63bcfbb70265ed7d4854dde9ad18f0c041785a19a3ee29ed8a000a6008b640da8b9adc4fc73299fbe36af557406234e9b7c7f9ac4b63cc7bca435aa6628dd0513fac5b423ac43dd722429b445190868ce0c70adc47cc9ad0f50b16afbc4d87673dd281f573ce002534cb8b9d834b4f1aa48490071656674f237e61ec4ed84a00b81e7b5228b2fe4a51c020311df5fe9498b8716ba161d01909dca362d175b47f0b6a59e1e2bd01a4a26ed74fba832589c0335c4cdfe681480215927a7da9262b3c9c42ea9bd7e4602470d17141ddd584f43165d0b78568b3c6c26c7cc7108ca2a4965d895e321d1372c61fda45b2baf02f100cfaa65d88605538512cac662336a17b347c08fa3a2d6517371e1e1a01ccf69b0d579fea4db5159cdc22a02c6a12cf8861da5b916a395af0bbe6061d42ffd93bd1d2f3f247ce4a31608af80f8213049b545bd560d962e1d5991730e621e3d54835dc8f136d3cf317a899751b9439a392ead5d8e5e8202488bb7d45a746a09815f0a4b323a869aa4bc261834344873f55c38c90070fdbff41a945b115ff1e83715cd61d8001c2b2afce3b6eb63bd59b571049594338c0802e39bda0c9c4adcf07a9459edbe7d34bc4cb733a5bed9f94e2d2ae8cdc8db723e04f9587f3be086fef648dd1313c4c066fdf40bb52a9dc803af67a172dab0ab5751f582945aa990de4141957c3cb253af7adced865c238c44d05f34e5aff27178e75803d7bfb322fea4a7101d04a9b97fc0514b2b396463053de834a79f5741b629978ca9601e3b817404919b0c5579ce195d08cb2df57d5c07a357c995d1efd56b9398e6febbdbd82d03ad7624f2abf542aaaf33c49b1acd4f164fd74f064df77111a105d86eecb3aaa7b46c9dbe86f5db66462105a1d774b4cb7690e98e547e6a8f98cb61749f3be0ff9e28ec9a5675a6aab930b0be8e1d5d8461b037b9e8c569495605ce4db5d5399a4cbe16542755e0b1824e1a8c4fd0a5e2a7e4bdaef7dc8ea0f8b82989470acb42557ceba6790ddb7522e153d568260b99066d48a3cc4787a5a32a33d16c1b8b48e8e2fa99e7493604d69b168704d2f6f56e992f4d7eefbaedffd5aeff1ac0f3142da08974259875b007b174f71019a6ace7dc80a333526b0da83e46d5244f000adcf2d61ee1993621dd1b90289ca564e4d3c9efdceb89c051899a6eea9515b6b76c297e5e27ef490eec6d97a91ccc3f3220b38ddce15b3f14f06a1518e8032af886dec78ff5bdddbf0c8d836f301bf90ade6fc62b041faa30d70aafcfcf86b3206a32b207a1da9f12d057eaf08ce38470f0928306661268c55ebefd1d00cd8c4fa890dacd60681fe89b8f614e1eb620fc85693204b24067eefc42ad4edb66795aa638b9240fc94fd420738ffdf31cb6192d0ef54476b7005e06087c8869740d02676ab4e49e788c124501b9369c4dabfa65484edf5b5cc923e5a10fe58bcca7fd79792b48a38b440208c4fff6784a4b51b8e15ab4ddbb1a2e584c96c47842dd46d62687463fa3215dc0bf05f905138765871e286c5522558c9a75ba09bb4e52ddbd58cec8d7e183d7cb12da6784fc9ec7f5d781007933b1c1acc5903e7b9ecd7c3d0ad11641b8b0ba377a0cc125b8b8c774e551eef8996872ae91419c3a3cab264083cbf6d495ae82a8f76b8fb21e441edacf8eaa1f4c1d5598187c4dbf0c0396551a136a3579e24a9f57bdb816d5c6f6ff89e63799e3b291c8b22729621a0126859e5c861da35d9dd69218893999cf5d71cef8e84fe91c186de769fa9754babb1fd04cc017b6bdc5c9d6dac89b41574eb41b8c541b88439f30161c7eac867ce1e23180d9103a843b4ecacd026a6257a0b575200367d75913cf3dd50106ca75584c1a0d58cc63798c845dba1dc2d249b04cc1a4ad9840a774a10f711fe19815d1a238609cc74cf9330b4f677d71908d382f0a9171b742d4e604fc1d1226b7716a8400f34b78723a25861c07d58957f989557af837a0851605d2cb855f5fa0759aaabb0a57a1b4dcdc88d0a5c73d71d5098adef40aafd1630707e21a02ab816083a9b176035744fc127cb8db612a0a65b53624231db101b1d29d9a304e2fa76e150b66b1f4d2e898fb20e258c56ed53a1be10f8fa0521becfa0855941c07e0cc161986273169c26bbd6c36d9ecde121a52e5ad3345c6a299bfc2c2213cded4b275cd5e78629a2b252d207c254310a2bad1f968b0d1f96760a625480b20f10b20ff77b6dcfde430ea780f50df3f8b84c4075f4d8f2828dc8816198ac1fee30380c8a54386560fc92b1975e1ca5479b9c38fda88d4cd5e109805e35e0133e6185ff9818b6c128b00150555c0d20fd087b5a2ced9acf2a8c21a0f9b8f8afa31925ad572801db4019b3f2f6e6e6f1c2b2a4adefc12577bc92e44dd832a59d01c71f6cc21859de0cb5ed4ad140498806a081879fc65afb4f0737d88184a8693b7a381c011d585bc64b722944280fce202ee66979262a09a902ff9e63fc75cf82747b3ee1c40e058ed5637a74b51f08102df49ef3c5cfec46f3dfbbeb5188cd8397b1972e917229caf153e3560e7674a16588290d7619956fd7ea4b8d2fec42f99c7616abf31247509647def4b2f257bedde8954d868c1a434bb29ca86fe99418d36ac3c58baecef130422f7acb7a77a07d50087776247932209471cc28971d08eabdd483f3d9345fb4aa652e563f179e5ca551b19425ba45a1293c5c2a16ade0592c4278fbe80460f7096aa5e315bd58e374d5e36254e842223d6446088d85e3e2fd6d0c5102a8516d7e57b503277f63cf0726a9ef247743bfeefdac3bf71151b779c27b17aa403a360bfa77a0398b4d520f8d2503c630ee053de79b0c333614c403f8c038ead969c22b9ee90b71c262f300cd14c34300ca0b8ade1bfbd8553bb355b7aa9bc27747c7ac06b927107f75675e360ca102cf6f0268de024063016e47ec91397cf54aa89b09257fb13cec89f99d86f2687e4b9bb09641e413caea8060303101b03069466b065aae258ac3a8a7e1d66f0c863c07183c6ea9019226a56b3cd8b1203a89f94b91e2c655daa5109cd147b982d1663018b0d3d7d6bd7707b87c49f7329040cebbbf167729868ebf14547149e12fb692f8894446d9e5c9cc5d41b508ed32ba9ee3f9e9c624bf0578ea8e12396408b23626650b5cd4d1327f3b145bea0b5d2041fd88e7061a4017e8292c3fea5e5b85d8941a65aeddd79732d7f274d1cee8653094de2530e9cf83023353e6b44b880fb807e76475e78ac891a78600b678e5a36e091dba5481ebf52ff4674d63a279e82196935d02a00c6e2b718a80319c77b4d58c7c14e11f341c6a7e600701fb65360b974a2d20c84c9955dc97f2c8429758b109d97ec8b75a33e52d0a9102299c01753437e6b1cfd8788de9a23a0183f71374967793548922b8823a9ef08f717346e4726a595fecb2b46db3ce9c2eeac8778dc88e7d9b40c9a6f6a889b3bf41767fb1e8e5f135514b91fa3ad3715307b54deaa1d03a9961c9340fc5f6f34bbb4ec7b741d9c2bd618b10b5759a2053d0751f554d979904e2320f2e232312ee0c5aeb8726387ad24b47fee2f746896e59992fef98b177779b79633243753de013d8c0efb317b7175560238e83ee667e9f301379b0907ae24abf559cb91fd5074c79ce86969f63b13b7e99480fd5da0f0bb7af27ea0e5219ea8273b909f7fef7b73d4cae5187de6782d68b42a768ab0e9b26646a6a334c561fcbeb82fe3d152979c7a4898d53d5721f8e92b50cdb6ad49513216fcc6e1aab431872d9b24a0fd04b800a50976d8223f76ede3bb1d5ca65568c5835f62003a52c51779c86713d140b49acd1831746bc483b1c1f9d124227ce909fe41a4583053233a3ba971fd51cbb8162b4060bc909b37129bcb4b1b6ee846430ea6ab2ed052ed836a50ee45a27963a9441a74318d39455f668a788cbeb78c4acf9ed1df611905bb156ee8ad8b4cb69f8d68458d5cfe38f1c597fa31ec23626b6f93f0319b128e8776f15e6fe743ac60d6528836052d45f456b86c684a608e0379a68a29da3a42d2a7b9218d44b86921ed36262baaee9d7edf7c5d3c6e12020ce77b4ed1abb3505e6a08f185a53cf5d107e102be633b614a8a653836012fe3892549294509083b91ff658d157b04d3959c9e38c0fb1494fa1d19dd838af885cbc46f264cb8bb1e1ab3fd2e8447f2bbad32619f9703811dd73902d69db089c377ffd018c062cff67b4de73a2919f277aee57ca62cd720d0d98d0d0fb9d22169dca51af1b9380339eae79aee3346a48f01d9b87d5298d7bce82b3cec0b528c523f0d7192c35b947eeaa67258fed9238ec374f7682f44648ef03b5a2a8b5d97f2e6f1f9db9b12ff7c686d950d1b1b78c29a3949d4b02c24b28ef1ed286712eff395431841e6aebd3bb3afd9b353de6edb158d83caa9d41c94dd1dee4c4e2c522dc1cf60193a3231a89ca42a75d173d791f81bce0ab1f1680298ac593adb53a4864f2ca38c1242f56158e14bc5f010781f1f080bd7b4c4186a5e879b843d71dbea14c6d2efe5114fb64c010b648993110a86f0185e319baa08f1c5431b87ef025214111a9a84e15097c0ede876d2ef95f2a2ff15599b4ae8d10af6304cfe039ffec46e014e743709915b7b029a807845578782f063b47fd3b94c4fb52ba79dcf06563dd1dfa4fcf98e17c86471380df95ed55a4cf928daf9f61dcf3a1f82dcef2b5133249ca9074e740363dcab08eacafc3c9278bb6e7a7469767b5af2a120da2f52406ef1c9c91cbe965788d74079a4c64e132dab949ea24de3faaf61108788fe7ed90b6d95b2306679c7c27eb69692efd543858a1c250d5dfc8f449a5c7a409c262f95714ba3e05ce5414a191318363f907d971cb3cb88e7fae5456728a81ee603ebafe356034e088ef43b1749758186b9c5e5a714f4e57371a14072d0c29fe843c73517e76ed02af13cf33ca06f61b9c4d9ffe17cea67d4da872c109d3eb4785ce0f2ebac5f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
