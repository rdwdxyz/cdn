<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8a7b8c960a86889e11fe8658608a415b5567f5800182e5638417d37b5e9c7ba3ea081113256a79988e3cf2b0f9613fa0bd2d8756451c9f5c5b727569a65d0a5c3fb2ddbd8d161d89ec45f396dafe46fb8f51e101707de8a3b71bf7f3260411d0932513cfb1d02b26c9223d6df8a202c49e96e7bb32232124ab87da55284e54fc7b461fddb9a9c1e27c17b01ab9da082f5061a1ea003b28e3751afb1b72461508e0850ba5261046a38b336d85e53c638d72e625f5197f10646a8843f2259ed1e769bda302d8a34cfad9d670b00ed9738a3ee6d3ba81e43ff5492cf4edb852adc3ed9171092685fbc6e9d81e55dbcbcc56acf4142e78e36a423bb318e0622b2c603fb8839ec95315052740d929058fadd125fa956c737f53d676d7ef198d1d2115466237d8c7ed17dae2a3155bfb2528d2e425aed98f6874305ceb0f51d09159b58e0bc3e87008957199593e196b5ff6289fb713eb75ae50f1faf65a75fa0720d7c3939b89f71173d1ede7a5055e15c0ec2b8b6677685e27b28e345146a8d16a317ea0fcab0c044b3d6837749f7ffc3a880443f7374e428f66f06c1e60166d1db956770fae815df331ff1e300b0a86081944338d1b3acb603ae78dc0ee1a85c366eef78df8979b46a8cd0416af2941e89fb19f13f5e9df2801b7cd37d39be7f8e36ced04fb899915347008a686ccf133d48e7bca160e927ab03523ccc481b06d79c4715041a86b273bf1e21f1ebc0b900babc56d954db314de60f53f88c6db4e4759e8969bd57950f7b6ad93fd94605cd9db26a97bfde6251d1ef6dd0e3f730050534a229ee8a6e420538d0d543620a46c7a60ea79f0c72cc02a8390e6bfea1a67bc3d39243e13bd58fbcab6db6b7105dd84dfd6a1bf40b7c5c51f575a7135f6e518b672f3293d6d39898f8e09ddaf3d9a9c3305d3de2f131d390e18aef58bf47a597969531043b7843757352bd2dc02c578a0764b50932e985b0eb2cf488f314844b826d3509d78aa82f8d543187a439a024f49603130eb14e925466935a56564ae925d8c940cc74c19651f2dd58fd3738034d056aed992bd1b4ad6504094f0f163fdd72d3c214b4caf90899c8d7eb33f5f7fc5bf68ceb8e5cd50a24bd99f9f5f114a322a37d4721c70cedc5556f9fa0d35876522950a7e675202fa83929124b34d5dd446f8c4c9a84a6add4941c304ac19a6c7281ac933a3a5918587f4bcbd881e43cae1d581ef9094c8252552f5e1d19134eed7be50b90b4265fa68ebda5ff68c32611a3d345bc03c0f15d3f1f7500305425026458d2eea83c8520b92def2116d30663c207026d9b685a250fd15e5a9b7f1dfc51753caa6e856966af34b8be1e6cbe9066d10db675acbbaeec6c917a800c1338180f94e1d8980d7d23f52ebe631a184ea12c7e5c78fc85a4f71ebc0f8b03cfe5bebfe81abe3c6c5ee97d8a5b2ce79f47ccd565336b0a6c0564d4fcd9f3438b07ae7eb56adc6ae7a9ed019e05ca71272df2b38552ed1580ce7e2c42a51729fa7d68d71f9164fe1cb624cedc56226de55a5df14412711c841b718a60a0291b9d57be28c4bde245661827098416c689c2b0c797fa73549a64418a690a45e688aecc5822ba308a28660e56eadd4862478b72ccd7e14b2d1c1a261337c4c9224ecc742f7ecbabee014614bff3def7780ab3d9df75fb3af2a9068d6db0f7b8582fb4e4767b8f1d9237ba206413e74962cff3287683fc11ac68a93a4e980726d964c4d4d4a49ed56791a2092b70b35b5298a9f5223561dd8259a5bf6ac2bedccf319a822c5424be1b161e16d4982a0b4896e08daad46e3ab3b73198e0d86fe4c48fae77403c022362fb2525ce1bc784c36c75ee19e57487124e00fdc9f8f4270504335ef113fe152afbcfffb3a3fcb98f8660f5289826105738571844f47b75aae1fd0e9b1999e1b5c3f6348893f8a2c26783586f8d1cff2d5b4c7c9608a862248ac887fdc1de54c7fcd03cfb6fef5f2d71b2f3cfab6089ef94df81aebbf262239e261094438c19f5abee80c1e24bc1ce5e947537fc533b3748c9d7241acb32be970e0a5cdf8ad583abfdfdd1698c15380d044920d95b4073d7e648b1a038b2da6667ab3c6cfcef14ec21af97d99b843bbb10e48308500dcb22815ba3fb95fd756f9c164965315335369f91c7eac0715c25f78815e8b874c73f51e9a29397784fa3711dd2e3451030b09e410f3168cf97da923d59f30ec01c8ce4dd9e02ac4284cec05c2b5cbf458e8c4daff9f8d2a534afeed6c4404a16d44b3605f80b47067cc2913171bbd09737620d9cea0bbacad83536c533a6b380ec272c18d21faf5e33762b3fbb2f051ce43045f7a89c633f38417c8abf87442b36558ab76c897e1c90412619e7f25f22e0be5c166361c45881271b30b6d8a0db371cdadd6ec0e88e83cdd86a6160b164629b9b99237240cc721f5b9da1660c681e4035effad26877198aec9a3c748121c7222ee747550e669525ec18508fc174f51440e1b4b06025ae03dd7b08f04f76090b343dcb1a9d7d82ce1ca2e3da5eff30807a790e41ec178cf9144e9e1f7353756a06b5714ddd8044687376b7d8ca7cb3ee45e51ab6542a19269b0ec4f6d31ff9497ad25111b3b74e7f03cc90eddddca3fcaa2f0f5c571a5610e335529ee3dcf4f76bf2d300512d3bce17016206590605605be7c1e33a4f7d5d064ff3ba5f62cbb512d4b8f037cdd639f22b2f6e8464ed10d811e491fba17e7d37e481785e97dba4926a62a07e62f5768bee981cde13ce26cc22fca30eece19082c8ac92fe672c9a8c3b47384f8ec6ba51c9fdc2cdf5c56c9d6b1c179a02eefbbc083cb9ab6fcaefcd067efea34cb39add357e5bcbb628138e841b3b24969269b421095e94f17b0d9ee9a87b4828387e09c99842c8a2812f0bb15a13cd338a51eeac85bc340a7add8dca48cc20339ba463953a5c099070e16a92864775212da238b3971c8c9cacd9a1306b2cad6cfeb6749772572a9493750e0118a3433cc1c5d6177d0334a37cb3ccb03ee1733608fdfbf0d9c2c2c6281d950408e81c832c6ad48f83ae5d9098b5fe402df449a1a8dad4ab8cd192c12c98af89660139ceb5a17872ef518812286abba72704ea4fb33f4262df063ea397a17ca09363f7eca4566a3762e898acfae6c08226e0f9c165c73c24915c466517d09ba9bed4178d77a7cc97f67a0b3c4ae0ed38d6037014ed00a623bf84338f351e144ab0e43c03949f0972e6b87c666e95dca031c9c8bf0664ba02ffea7730f2d514873a24f2dd157ac87e6a19ce202698ca901b76d2c227bf5bf89dfec5b3b422cad0929b0e4c90112e3eecbcd7f6b12166c8216d787f1bd5fed6119228e5fb2ca7c8e10ca73e451fff2df32360daa0bd6e066d413ebf9dd080aacf965973d54a5269e8e6570bff02cf5ebd5fc9673d1ca14abd1a551ff5b82d6048cb2c002bb3153a805b203ce9158b18ea9e1d1c1046ebdaa36201be352f134dbdc77865fa271c32585086be4e124da1d37f49eaafbe144dd46af14e7527941b9c78d46e20248c78dc73ab3d715462de6d11bfceacc994881d16a1d8c6e25036aee7eede2afe0849a2bd89b5004b93c0b0ed905831a3d3f7b010f48f9f01eae1a3009b846f18571cde3c69692e24f6f58dc34e2b338370d4e24d32c7fc922c406b22de9d41b716c58296afdf9947518f7a781d99b704817491a8567d7a8c13f4c9e8d8ccbd1745db53ec5d3dbd986d7a99fe18c4836e77c6d935a9de51a0c671a4d5f2eb44389a0e9aa7e32f5fb0f06a3767c4c4e9bdb604d215ded5c82c21253dd126b1d726c6f9643d851de6fd38d8aa5c5b38ea54202d6756add42cc05e0cc0586e723305ef978eeebfc8b06de326dcb779344b9a76bd0789b1969965e7195882a536b697a2e9ea6927427f91f2ae7dc2c1260df5412b6785ea3a8b7a33fba089befa893da03c7a577f3866124aedeae548528c153409296d9e69ae6635978ffb4001ebf44382d0e10e2893926be04743ada135cedcee6a451e2a39d20f6689e243fe49e8a86c2adfc4c0785f1979dbd535f674cfe4497f799398ded81519d7fa51ce0fd411de39edfd70a12673f5c183a76ed0a7867fd506b5734cfee5919c656ebd8ef2a9da9d6a22a5c40f7e48127f0e06360f78487a121e0c756148e397742dd84850cbbca0116376396aef477b68a46eb61f3344b36f6e8173d972581948eff641c3ef4162d4885f206cd7ccb82974bc1a7b1c2e85929dd64d21b3e8831db57ce57af0d0e8e7e8120add69c124c40a2c68768bd485789658c3859b3f4afdf788aff0c2793156a4f405a680cdd48f1746408b1eb8de4c094d1523e03fda104212dd167d4d86525ffa2bf49c2ffd8fb871efc3fe02d8139c6fd6b7d7240d4dfcfab06ed69cda974d02d31badcc95c927e6f56367124e5ebd227e920967f6bd2f544be6c3fff3c1b055918d9cf03e42ef35b63aeb084d07486b24c946da5b649634209acac4eef3db2f41a5fb225d0930257f47d6bf60c4f16d7661777c7e3db21a619f8c6632e870f48157d124de3c002d4da2db987c897a24a68104ce669d2f29db2c3763f9b6b4894e67bd468e57ba63a12ff898d0cc658f8e8db23bb93e9953cb5612bc6b367161e682038e68a3b564aa8da2235590dbd9783d48f9c40b782b588568caac7f26bc945a1e6647aee55d3a6665e0e527922f577971118d9ec941aafaa86e7dd9ceae346d0a192997d28d364aabfa906b039c1ccead88b605683bd3a85df5788d359cbcafb2ee5258d78fcfa3607a46079c9d828f6b5797a42e4a94c5ec1080b367c7a988743991be4163e7adbfbe485d2d08a9c0054c8b7de7e64e26794ff8198543fa3b852820c90d6047b6798f13afe85154ae73544b30b8a7e015c9733d72a9eb4555b431aca411b51f567f764f57f41f75365d2ad2c53996312403a21f5f90a72488ac1ac8848f30a97d1208cc3163e72658e5f4d48e1a6582c4c5441976bffc3cb7e25a05c93f1f76c6168c81f7e5c597ecef085aba7c0a048b62e41f5e63784580a0b9a00dea815468b4daf318bf66e3001bffc1836110e72776d1998ed0f501841359586cfdb762d81ed008e08d5e6cb7b875f992a9fbdaf66549e2c0f8e0cb1811cd2f1f63b687acd2f899661893a288637c1c032cb2020bf7b285fdcb55da757675456883cd584b7aad680853bd21f2fb8c0d4bdca0a813b5a2cf6375a6a0300eeb5246716a7c98628d547d5ac7f42d6f389bf0bff203dca59fcef80cf96eb754a3ed319eecd87a21e7c96037146d6c59a2cbcf5bb6ce2f848a3bc11b559eaab1c2ff0aafba5c9f9c93a999c2bfb340dc6aeb8069d0446a1ffaa78891271f0572034b548e36e81f50159d6da4bdf25362e0c4dfeecbd265bddf8a88b2ad73f829296d7839eb36591e45bddc9661521833377661c0069524635de4e80917026e23b4dbb70e4c2bb9543b99f86672b47d86c573154c7c7132f7b37f22fa4c56adc3384b203925f14fd4f943eadd6cd3289951e0f2668f10d5fabc30ce0b7a97cc6cef52f6623769907315a3490a95d550af03e4a2a733cac4e63ae22380015c4b414d22f46ac4a45b3d129b533e11dcc44994309976215ebe5acb3326054a1d7ba59a54610de9fd397507d4e62fa3ecf69ebdfe7cbf79129734923ec4dcf92f652a1e6e478156d71d6a68d6ce00cf0e5d6d9ad108b6f8e97156ef425e64ea2f4bc0cb0bd2ff3ba1ef665dc2a1b9f70359deef4a71d3b8e442aa11af4b81f7e45a3c903a59cb8c4f60108dc4e399abdcea4094443df2d1653db4af99c43e2d5966b712c9b0f69ff82aa4763910bd1d6bd6b2c75bce4089f4696832776f13c0080f9c177782bd7a9efeb127294475418d1b5d41b70e33888ec57d8d8944d09e4bb4621ef3ca6c88bbbc4628c8ed365c85f25d21206e3a5b80f318ff870b51d465c58d56e9db98d2aa6fc18f8d8e13b9beecdced0382402b9837f57e56cdceed7890f6427bcea15d74ce04cfcbc116eee9de074720ea18e76679f879476f15ed283c10f32e9039c3b3a48f345a96d94e2bb49ea27c085f3ee1bb9e939a1be0c6c0d04d064fdba6d507595268134e92e40e9dcbaa3f35b179b479d68515bdcfab185f1964107dfb0f8225aab1144098182c22a77ff4e379809041e3309ae56d59899735e5ab316f9d033b9be18b91fe42994e2d60c2a3870f773b58f870ebb00e2159d72648ca0d19311ce65d5b7c480f3370dd66d57458e610e2e3bb8e0f2a649f754ef78ad1d5a541134cbbf87945d677485e3c802493a3a8d95951f5b81b3ce80be3f8d6bd336af765db9d9c9aa3601c82ea1308c883fd3475bdd10359db073f3c63b85d1426157c5a745f35536bc856dff3170837e79ada7b8df76a4e245795f2315480dd0e777c5eb3089424824939e314f8bad6d4d441ab2477952897e54b8da56f7df9ef40ea74e63c06190e14caf54cf5383bb0238ff8c47c6077c22b3f9fa6ad80b1fb7f26f81b97f3a55919c9ad8ee5363a3575e4077158c226a10ca01590de28e9f7fee487175c8fcd09ccfea93d6343699d9e374121fa11232a4687c7106336a40b6e5ae40ad10cf4e6dd6d18ba729b45d30c260cfe7658cc96d9bd2a3ca6fd9c9269eccda5a60c05ca05aea54d61342165f6e4fe6e76690814e7378f9b7b6a80c7bb7060f25c031ffc1b55e7fb1ac99d33c7eacca7e50fff193605b33347c573a80a13d86372266fc18306ea8342a9001c5e247fed50982cad36c6ad82de35ccc43b3cff514a2da7e772dfbc5b44ee90b80d4cc14008a3f80d59ae9b2345fd29fa10b8646e277dc89d85ff0c90ef4616e6c62185fed8a29aeecf9ab9d0f7709fe5b6690a2dfb0465b4495d2c5ab01e463f58a59e59e43085b69871a0b710812b8eb7d82d4fb1b03c6cce4f5ff1c027b637e775d1038dac9e1da7c5ff21d0c7e514772221ffaea2f3693f65eca1d37a99cab85ced99ce2af6aebcdf90806e13d58b47146cbb9ffc13a8a20325d6bef76503fa7503ddb8909a0b2a9229dc1a6fda223ab0ce7de5a857325a10f315e619c160f53bf6ce2ea2a9310d864c38f859325c94ffc15160a2b2c3eb9154cc8dadfb932dbb057f44c4fc7f6b63d095493ac8f5b53412a07053923303547c9d54e11ff3f0baa8e9ebc4b27341880a02d6c70eb1d669d2498bf66542b5b8e965741906518b01c034caffc24616e1518c9f23c426e0bdef7cd4b6bd28e1f5b8d53ca1dc98e845d579b7915f6ccb9f95d414be248adcd8894d8743d9b03ea76af0ee516c48684e909c1b283256a160c52ab794411eae7397c092335aa7a176d002097d0a452a216bc021736f4d7b7be3b5f87f1d9bf541549d7b52fb5587ef2715488148cf9c020af3a3855b3f8d10b63e06d85db8a64772729407a0a004a3a49a7c67b19eb2ce12198395808c5bbf77002c9df3c4f6a70651bae3e3e3fe544e510735e84b245e4cd9c7ceb2e8e96b94806b65fab9cf99777cc28d2bb4e4e2c0f347f18dedc1a4fd9d82cf5ab551f9268eef3dbca52ab613db5bf27af9392363dc1f38b47d039e5b11286bcf6a83642788b28a767748c7b0b21c5b19adfbde7f08dc13fe7439b46e5b31a2e7378c522ba3d4b816ab03f6089fae96f891cb01980aad2ba837aa80d7313a727ef17be61e24fec574760938819559f5fb51d948abe6d099317e76a3e12524e9b7c5ebea8d93160bcc313e968be612c06a357b291241159faa09af63db142f4970d50b6d3310700daa26fd0321cdfeeb265a3477860c96d0b2014693f8f60b05f6041131f2a96ef3be72c27adb3ce0b04906a5506c12d05b0f78025d8b7051842c3152405dd8af5208848ff60888f2ada37afeb843c2d56a6704e99c7256e85cde24a8d700a2359302ff854e67c4afbf0594e120ab82eeb76ed569072060325dcd55a599254e1fcc77750a51013517422f3d76413e980a800c4cfa99080d6731b57b886141a1da7888e299aee6223fa20bd4a62e8e790dc2f665520c29c4d7cf1f6e0dfabba610b20be86b077cbb653d0b4ebe65376c49ec557997943cc369c6faa422f6e99d162b07210c1d0fd2315d8ee2e1a410907b326de9b1c38dc733ce32362cf82d4cc6869bbfd1e817385be2cddb3e6670f04f26cc667ee45e81d7e05b50b950df490a3b544a79f0d5209f17e9267f3021dfa663b8adcb8fd06fcb9ae830f0e1b27a2304cb3c4b18ff48cfe468e225a9d7c536ddd1b066afba14b8b5e118c99df9be1c6f30b8a93ac194d70dd7cda8d6dac1845cdac4963761054313ff2ca6d27ea5dc92b6c2700c5a314e69bdeb9fca45d9fef759c3f843d79a1e03b4efb7f8f806e9da025d755c48fc92e4c76805c7753395a46256564068dd7055ca27d840047ba1e4be6cfb29ebe34da8645ae8a1446cbe7672ed959745f764d45342c24764c71badf63af507459f0954512f9ca0a3836d1b2c10e7fce0bbe23f1060d195e0d16995904a099a3cb600d789de8038a8121962fb7ba7110981cb255c37827c3e3f6ec257a3314d51e749d17132994563f75450fff3f92c28694386120561214e2e9fb9a8ff37b94694c1c1beb00bacd7610f658066c80e4f430ebf36fb187096deeb7a570196eca24e9b97b077269928b21e2db5f6a71f8fd55b6ea8ffa244863b3eecdfc82864f3590ccb8e13e541fe02203f350f3dad30702fcc16601da50d884d7cc3c5fc96e6f4a9d547b84b0ed160068400b6309c6801aee4ded65887cebd93f58bd32fd638e0f09335a8bb66d1032c9879a8bac66599c369e6a7fe3ad72fe41e88cb0f89245924d250c994d68866e2df7edf89a87d4c8a114e750144f04e77c9e354d8e80af9cd630ebbc34976651ffec7fe56907f31391c2e2b0ab9dffe0d6604994daa9b29674f8f92adaf6f7422a6fbfc57b033c791b6ac8e1e8a3e018b191ee7b2b0cfca5bd7ec13559b79cf9969db105a2e17a8a2f81ba6fcd50fb92e2d213a35a9ddbb4086b6bbd8e3e15c90081b10b1e7e42f02235b06a0623980c6f096c8bdf431087b105057c6b6064cec5bfb7bb77d234d7d70b3b592314579cd1624192475c9b7c776ff806c99a059e8489f3e24c35cf531506e8458228b2e6637d9d4c4f56497fad57a5b034600bbaa75dc0f3a7317ac633d256009cbabba3f6921630bb3772224ce52054b2f015e6f1d482cce1c8a04f0d6cbffb270503a268b5f742b957ee410d9a5732c454ccc18d471ca322fe27cc68e046b71bc9532ce3ab4e37e81d9f08448c2c7ad81e54e2a65d3e21cda43a57a9f660b9d7f0f89173c36d208f2e8a9c3a121ec28074727b7ba2ee4fc35ee833478196ef490da36ae4ef023f78f1d002391354fa13b0a7fca3d232a6aef98d83a0c8e4ca786c22a44197e89068b1000acafb3fa70848d623f2e693605d5b568a4f29e0077653b53e9d867960f6491fed9479d4571d7a7dc5d1af175bff0dc0aba93a45a62bda38ea8a17c10139f9533fd5194219f5ab986180ceee0bd2222444bb91890229f6a14c92982b2a8dbe3772281bbc8ecc148f48d8b8f1a3ed1cf6e9538b3eae923671c470c222bb8e9cdf9bffc77ad284a4b49cf4ae454c0b117d0c2b1e10e55afdb359d35b3fe3aa0b9556d9ba6e1b8529a99cc7a98cf5aa48fdcbc46508330dc52fe4c5bb9843e329e56ad4d1785ec3e17c2e75d5d7799214701a3ef030268417e2096cbce322d9b4ce5945ff8a2c285f47e71b3013db26e40b8cf2288e371af8e76620ecdd9e296437b8ee1a98797d84a2fc77a4eb2a6a2999bedef7f4f98abe7767fb6475df69815bfd495d48a78978e8652fa2b57f41447db13b7081a87e28a005dda7aa7670a09558b811ab39da8df6cea67953efa877a5392b5409ec06a62f1eed4df11decaf4ce32f8ff724e0e2bdc7615cc6b6653743bf52bee60a04d5308a1984f14c5b1f2b4d2a663432d5916e6ef54810f78667ac180846e90f1ddf0b872fde3f7b4144247dc95cd18e379ecbdd7e8218f01b596e42ae54938d20cacd46d878fcd56e07038a0624b433012e793f4ac9f6f78ddecfa2aa844b6b355c6552ed0975e0b4eb8f434fced6ab1369db992fe8f3325970503ecab9de8276cc342e7c7de840f9d912bf86fa1a60c331d922c3c720e235c0d5a17269bed8009f9be940a9b06bd083aff9972b39c076821026b7c0680558d6f0e48e8529c923656c6f1227b729200645fe249c170fc888c1ff17745ead52a1bb9aae846f87def6d82981641af8cf537abc491ca8117634745956da0f9a20b976dbfd2f1ecd8977653dac985bf154f028a43c613f7fabcda05bff1025ac36420b3edf1c0562b4938e6124f927655d78fce116ee678cdadde10e22104c332f66f11d2fabf45e6731a7f121872fb53143be696a9393629a6ff43cc5ff0eecd38e0f8c8d4880edca8eb6f33045c090249c43a6aaa7bf16b8d92368fdf3fe78eed132f916b3cd3c98f772b880e93b5e45b5f3bb9b64f566d94adcfd67e1e04210722fbfea063ff4e05a0b7f7cb20238ed419b5c9f8429272dec0d25a0f3b269e84376173848f95d784ed616e99bc245c8eb1dc646013cea48d87cba18dfdb8a38ea9efe99e45083e37ee4fd97e4d045376b5e9bec40d8d52e0582fc54d51d056f4a78b653e75cd93f61a38c5e204750545a21d1575c66f36fc62194f0c1ccbf810aa81ecab8e60a762f6ef54573cc0dcfeed901880c4f0be403bc4591b94ab2bed33dfcd867f1cd66751b2eab4bdaa2057975c8c2b9ed6e7c3d15f4452cafae99c17bdbd8fc12c3521e34c4bf6e61e2b7414ef55e3923af63700762418a421efecefc621b7524cf802ffa071e219f15d83da63ebf661a78cee05b3a97d200e9f52ad8ce358b6bee7fa058f574721a18ec7d4c6cb0c1766e680f089dbb6278238a26a32296b92e8ba002dd172d3c0c2177e90e43096558e19ce7d69633b7f0f592af68ab0c3dcdd71eb313cd25542d28be8385e799b0f90f8f664a95e536a9c8725b18deb471a8530cbdddc2e7e826c80aa69285977d4dc2436ee2dc59ce0215ef0d01c48f62d578b0c8de1eeb9936ac7264af91589256b50716e5034e4c1da4f4c481684551843eb89d187a548b086d31a4c45e481fd3fbd404f22d438b40589f3cae42df5bfb644fca081e3427a991eee8ffc7dea18f633a69d348e7ec158ffec032cade737fe626406c10052bdddcaf0eed98c21abe120efb49357a16178c2cd9d235e991767d08fd8642c950145e750266e3d9710447c6b8cfac13c8b190a335d0a322f9fd945853c0033410631df20c224cc469d98c62b6f64b19028365d7164033892f2823420a57957bb1d31eeb7736b4c3e52bbbe24b9edab5a74153942ec5bff972a9ff0769c94535af299f1d555b39ecd1cdf121a3a376f540a961221541af035994b92b1db6909916533b98a8693e27d49ed451fae512ab3c408c8d9a9f412b2e6957faa73d2a90477add09d573f8a1150b9295c5ba97ba2d5823a6a48ab634dfd45d1dd8342603b5522f7afe0c93bd4a1f0a49d1bde57714069eb0626f20a3502a88449911cd274ad9e468b969e52a66065a26c376487257faf5096155bd1e6d7e568305bfe73a9d57c6edff5925eacc27b97f00ff273aa9c06566f7aafc3f7c5feda76b951f0fff4a07aca5c1a02f882e1988e1a354e96c70f9b129ab3f1cdf8b270fa94aee0969827b270d022f682b8bdafae51c06aea057fa17cd5b69fc5c078204f2c994eea49fa8ddf8c837577b4ea7947d95d229ad09ca16f7263eedb8766a32f44dcfc6ff1512d17878c6c292fd9b809a0ec95f8a7177c6db3f0c4bd265f891f1a27684214c0895f549323aabfb3736fd62af4e856d38ba7bca66abdc47bb6c524101500c19199fb094893eee041e9de20e8fa69a5fdfc52435c6c9aabf5a270536b59eacaa0cbb4476505448872591687121ebd6b964f342a56cd2152c6cc859675098f920d459f1126c3e9084c6ab3f2da8eb16a6ec4f40592781f7d1be14c517ce2759e3a7dbaba4990f802bf7a72cfb106f36fb18976a83957e026d56f84bea4234f2855a5db24fdf1a09d4f5cdb8ba84ae421ecaedc5b7eedf3080787aabe8e5f8ad3b3b2ee3d5b61054385626dacf03040a463b3df15c5d0410e99aa0dd76f17161717a4cfebd723eb2acdcdf45a7b536ef8f17fb5c64cec454cb39afb637f4ef1e02639217d9aac5ea589e06c31987033cd92069fe827ba98dd29792284de7fe12aea8df6619b83f98f37d33908878cead25a2308f5eec039df81045704361d97d0763707e22781a42a10cefd1129d11d4d95cc74b6a974fe39f918a556ebbd6a0661ca5bef73f3024dc9375684005d89d4c534b02f867240805da0ccf2c3f97d470c0a8e7bf838f6d26a08ee9add72353ea4bab39f49418a23657149bbdc23d6e04ac79c69f65ba660c70ac594c9c266074be458cc3de2e960e73bcda10915d38c474a91aacb46f04663de86835af6b020b6cf2404a22dcc52911fb475c5448e9b61ff165de96488ca42f1f478971233c05652b6e16b077bc1b73fb1c9ddd59f1ed7db3935e03c22cbf8667f2129272f96cf6328914eccee2daba1431c40e34c5279898bf2c381b965afb570263b140726d27ae88094cba2dc27be58fb2339dc33e33d39cfe7c8bdf61986fe1418d16f7f05424283cfa56fa9e053ef48ff14ad0e8a42583f594fe250139912f4a32a8343ad08c116ab73d8bab2edf479bfd75a866adcbd5f807f741162812733a928321154477f1dd4de88509dcae9de0b2fdf98539c9c6561ea02da247070009dded89528e2509837d0906aba74992b65c4bd8777149a98e51f56c48ea9c80ead043f5d98b62497d41230ea3a532d50b0cf442798176963f43f40fe7b90a62753a08f71a9b05a9fe8fde100a2c1396c64c55ba43e98705df1ff072bff917c2601c1095c0c8ed97ec10ec7c114d3f95d5bf038a489469b554b2d032ba05ec324dbd6af54280f9cbcc1c4226557c5938c6ad1dd4bfa9884bbf86786e4fc912b5e732ac916ff9765803431ec05b21de8621e2fc29e23b5ec3b7e90d740a209c14f86b36138a7ad2aa4b6a854e7cf6fffbfe9a251ccb81a811405ba478f764fc61dd5e0e43ef23ff5a16cde8a7b5467af6818262d027495b246b58b27a3c55eb47facf48c222cb83eba7f9ef5864537c71284a03edb027e910344a20c6906f4d25f32ca4b72447cf89f38d5f84ab685cb3e6704922a3456808c1e996d56db003ee91951b7538215d41eea436cd74b907d468c01a26ec325061b6bf3e7c7ff6bb0b37c292b21d80db34aad6a4266f413568078ecc10373b630e80cde5a71dad1509133e01a92be74d19d6b06648dba22db37fb42590741dbc8575fb49a3e3c62cc26a0a04a0219a8b4a8b0e3e549fab73c54afad21e56d0556d27bcfa9ea99401929f26049d3ffd26d6f2cd3b4fabbbf9c62df90a4a9c57ef87540e0a48202393be82a859eb0719bb7ac070a2fa15240d99b274e2b3bb489e75c4874c8ef7ba7cd027fec208203735be5124cfbf38e20a63b01a1f73ff8a95e809e79164029a665b4f19efa4b791ccbd434ce465c0566f575e25f87d7a8c83b8c80fba85237ebf4eefed26dc7c49be3744f1f6f65abebaf8c05dee06fa5df9e64605a272bf3c0dc931cb3f009ec484e84694f3999b913723bce21e6baf4c30f8fb04f1638269fbee987c40be711fe523741d744050a18941dbdef316965d8c7611bc1b3697ecc9cbad97f4267d316f9ef43d56add28576b1eecc926fc275171e2bb943367d7b83407d67b565be9ecf883d8864d0d8ffe2ad28a789a8cdb25cb051a1afdd9531535964f769595d1b757e30e25644f8d30ddd66eb5ca5fb8297f08f15011c8bc24acf36c88990cfbe184cb1397b263d8e2eda5e49fe64adba1be398e66079206650e2145d45621a5b62b8807d3e8a725059ec2f290acb7c9e996f21aeaa694dd0eb1a337e6123d34d932d6b91c8bab590de9605c0f82edd7408b5f7919c9c18808fbccfbc9ed28a63a1638d61a48760ba3addc4f9b242f6375f66405c411df5fa59470e31331a3e0ccbba15b2fb6459c3b0c35ec8d7572c245a328ac20b83feef51b96770e5c1d64d1eaa41b5184b5e20affc328b17b26ddf7cf6034cd6f932be88f68e1bce28d1d0d9527b2c4e0ca1a08bc57030dfd39210794c94fec258992b742ecad861b0e72e2014edfe3a1790f0fba52166ad932af6c82bffd2c205a870ba1059ec20965d5e7e8fad53dc7fe1a6153df82d61a70ae9c85291db5f3ea046f3d0a007eb264b6eb3b016cf7050e355ac08ae00c9138d7b44ce181b995b964b94777470900bd8e388af87b24fa4efc0f5a60ad2df4cc34b826e154ead369f1578fa55f83a0255d087eaf829c7125d1b6aa67e0436a732385b4055df74b60f4a34ceeee22d4a104b137de9cd181b2c4507a86dc3efe320953563db4ee71c7ba951c4cca4983c36a44029003bbba3cd19dcb624d2da8abe3fad9fd838ec5ef8e572871e6e953b2783ba479d2f9148dfadec5731375c7012e80542fd9f3cfefc30ff2f08b45e1e0116ad15bd63c2bec5abb22c83406c7d3047184d67859e435019b552d4a864cb967e4216175461a20a0d250b3281fbd1429bf1e314a92a5a3ed0885c91c3ff0eb78e4b3e38b82f540102c9790e410c16f00ae769655bb970d996f671385ddcbf36e522ed9fbcf3b7a2da9dd47ec09ef208c4a72854550ca5561af7d30c7cd479995cffb9c5530d82e2c38bd05dd9b117d0b0671390b571af179bd3c27e1c7ef9f4c3a5860dd58fcc9f02de6a03376747a5925a9c36b7f8c3b204f6b53c3168b0c87fc8691b4b2be7f6d04627260f0b70e9a163f4e0b776bed07c204c67078d546350a33e6f7072e94745cbb03b2264928addb0b298fc62cf40fe283cf149d107008c8c23b5b838982133008da0052fe371ea1f93c21210b18b7e3cb8982b96337fd79b211dc0f8828cced623bda9fc0ce28180b016c453c43e53bc8e5f560f3e73cca10b25f31db0397b935452f6d641622d808318fc21b770cba46f46972d1403657c7dc23a08d7dddb2f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
