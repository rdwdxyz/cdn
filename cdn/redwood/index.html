<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b26647356a886e1dd0089160f4e4f5d03fb27a7452cf149a0e08ba8c9133aff2bacbc06777b502d5aad8c7b6b12e3eaa0a491592938d2b6d8a26437af515d668737295ee737fcafc35bf9c110d1b36bab6ec10ea45a44004b3fcf76e0197718f6ecaed685b917dc294ebe2aa5c3068b782d115892e8482fe4fd7525a8e46f6647362f99d700a0aebe49cbf4f5e98ed173ab8f0a111c859a02d9fbe0811e0ee368602c3d1d7d74cedc36ef82abb8db6f38b7ec8a39c4d7649b740fe0bdcce6238c7fd87c8be9438b582f761e9215274ab65514954296a3abdf6996e719840d7cb92cbfcefc5cd54d9dc3759e7662e855b2a548567d6683e26ffcd33aed6d5d68cd19185f1ef608a3f1885f2a7363df25d4751311f0085248f92ef20cd28c383d0cf76b8529130ef47a4d44f9e7aacfbe15646af1e8d13668b3a64928cbd9070f8c151209b8d30834c47085e44efec690c0c734bc06bf35db9060e5423e5fd72e4664828ded31528c5de01a282957583387328a01b1890694e28fac09955b8dde1ce4c94cf1905192b0da70e6966dcf671f598322170a6ae957b95c47c3714fe7f97b1282d4fa4c980e832d327336386e79d99dd040b5ff6d7bcbb9ebc4ee447ca9ca379726b2f605e9c3de0de3421a00dbbdf239b961553c22b246261056a39bff68d949afaee3b1ec415eba0a00ad523955f53745599d5f312a8a6bcb2aef0e6088a928c85b50eac2b1d5685655c8efd8104244f5fdd9f0a233fc57d1c1970d076793cd780f363900c0eae0afbdb9f0fdf43cc16fd509e5b46c27ca3b8285b0b9da43e4fa2c52bfd5c4a6add08b6314259c2194a5957baea608dc4a7a5cfe6b599548dc594d21eaefaddfd2ecdc2517e92a676b36d7192b6b2cacb0af54688977249256ccfd69e190db96d66ebda582a8362e9e80be2cdcb85dc746da5fd4b6068d28833b4a24d46cc3d6da24aa09c820d87888005fc5b4547cc9323f2d675ad6452181f36ef0c379e1b93c36236c3fae444af488b2fd89c7e7861c0280d2503bf620113a76b17e4d09b7f306d7b6dcf5630553c9751bd2aedc21c4de2ee8d5255148e0279bb8d6094ad5767c848c4e1381e45d0932f310ac292f9a1d54bfb0dc22adf7347dacf8e994cc1641115a4543cbf601d456a74c854ae2804983e13e41431bf6884b7afd6c59090949d0f5c2ec1f18bda62565969bdeb29ff6258f065c7b86617bcf258a77564582666d5445ca9f5cb6e1e458e12e1257306f0c296fac8c760586e31b9f3f17c46daee789d25500c50af8e2abe2690c4ce0f1bd38f73ffae8ecd393015580b4f286e026692a3edfbfb6802a07ea1a5865833429d391f98aaf4a1125e5f8efea724555831583354bb5b0d2591796cfd9097c96adb066e54800180740b813aa6471983c0b671b12451287481788dcfc054e68bd2c0651aed52d7a63b8b41b752c60cba1636803eaf083e3243a62142a4e7738ec17e4a8b754b495515544a2ba6ff4eed4567f7eccbeca076c475f389070da4f560627db4d49aaac7985bffe51b3b937a62dd98e14097b84b74140bd8d1da52634bcead195418f8fa3354f2881e6f5092357f4d69cd1cb997aeb7ae1e0a57597b1220fc4b593e1b9433535b768fe28f2a466cfe71f8aa3b0086add5373ccc381aeb42303772fa3525ae6632cf79f83183addaf11f0611642387704d94efdf6443ff79a2d8c03f719f77fbe7a5d125f71a14c779c98d22de851084c4b942dcce5f4f7099b2eea0dc69f3001f1d534d39fe3951d6e0de3502f6d21ea963525ee84946e08e51a4f93931d9937fce4cfd295ac440c1ff4097b6022a4014db53c01f48f5b1e0762329a3d2febe4985610611822e380e5c32c885e9bdfb79959030d31d71e82747cb34133ec09dfb69a86ac0f41c32fd48244fe658151037b1faaa9b396bd000548101ea8e60abb184878bffc3c5a0ce35a59fbcd845a6b98f8cf576bd2229b1391caad7059b3ac961b57540e844821257d913cf09f7645df4327784864894450b3b2b6daa6e8b4365835f8cfc67881ef909d7298d33a6160fcf98a318d732d873aac8b9dd1aef4d5662d605333aebe6fd94d39fc9bd7413cd800190147e3bb5e5f6268c7bb2898e5d9ffd365e7ff919b54a2f6745ce36aa361ef33a67278e6d965832d719f236fec3807bf4a50d604ce37850257319b174b90c9151f0cd93794d6ced4b12ad780a76060e90ce32b635068a619898edb3dfc4459f21a549e7a9e2f0ef04a4d7f20dcf2725c402f109065f52a40ee9ff552c7d4b4b964e6973b3dd2c3deb4a252cd245dc7e0848a8e09db8254acf235ddc7aaa948b74c5be7954438c9dc64b0135e85f653ddea2e7dd107d8f45e1397e4c67aa749e95d0c38194eaa808337b2ee8a60a069644e747c5a89b90c56e28031363e68d7347d7e01ebc1edceaba550cd80d0a32a48c1c2f5eb095f811f9e745ed55e4dab4936f9d9473fbb954390f9d6045cfff8c66e01c9e8653c41e9b90b5b6c574230e0e75103347455cd1b1cc9cd13a8b0054b11208d781f8d27fa06434ac9c11fa931f5f96bd2471a0ecbf28d4e195aa0409cbeadce0db2cbcfef47607b38b3d189ead1653b79ea6436a942bcd7681938c438a36422012e217f4f62ff0ad38468f4db975108cf01d9f2cc09bf99bd190cd2bc3dd9b836366692346110f2c28dbec014a0e50ed4f7819166ce82ed7e329acb45b45f164e43ebd216ed4c79d325e2d1e5147810721128cce7af75d436b7ab537035259832541334f8b93fc87fb912e5ce0284d4cd8a8366234f73a2c62a0581a7621e4123e67dd528fc7384d674a348724d253989f7a5389bdd9d201e7578674fa58d0f74c33e85d0a07041e7fb79810f96101c81bcbfc54037210a04304422d4c287d6e312aafe5eff1dbad53d95a6f8211e114f635ec14389d15f5ae65f50dc2120d0eff91826fcd166045b8fa3a18b8714f0b7a43184ad88501fd8eabc28afd1887d5b0ee48d39524e2f272d652ba469287805c1b95096db1489adcc60b52e98b4c7916b591b086578631441b2d41f919241ebcc8a95f4a8ee008b5fd45fb10bfa5c4c27de7fbecc4b0f749c8cd16fa912b6b77e9e9d6ff892db8011b93b9438931d919e2e692df62f783552e95cbbfb2763118c655b10212adde5f84d823115371c510745e66d7e6edb0c18471c6c61581ba4acb0b29794505b29f178c16d7b4674942fd718b76be48daeba11a10b185f4edf73609b03c14d23457db9a47f26855c04a53e0f514578a2107512242f64c6912d415f179b98dbd020ce6d6b0037857acb5a875237f7a1cca2e22dab601eab734fb8974902238ae737d0f1e73a7442c71247dd9ff28eabccce3b205c89f017c9f1faf929c0135807154c502e165ca558dd233733e5e89def61407e6b5285d0c17c33673d302c8550cc169c36f8dcc97034175ce4d67abb08066f39fe44f10e43f9e019de2c8f6414851d74691521017463e46a08f46b1f5b4f3a2c37283b06ee13bfb373c5c19a46284406296371b9491ad946bc0d18531e553c227da71cb0a8bcd9a95d9a7f23ad9c5ed7eafc4630b4daa7ea83723950d7eaf2bc8da3c1de50fab13b2b336b5e42b376b5834e63f715d2dce301ac893429ff62fe60e0feee28286e93e01edcaf9558af91485fab939c5bca1decc0e4ed3c3a3ff6e75ffe1e54c6800fd737c9e88ba2d157de351d80d1053bf0535dd8e78d72fa71d8b2d52d759121643af5418701844083142d9bca47a929debbea6bdc07cc697e6e4907faab4a8f7652e8c59d0a74cc8f6cd4f16c3c05daa542d97d9a13f96296aa3fac429a0cb4c32cd563a2d22d323dab8f899aa2c68673fb2b3d8fbafc23b63ca7f3dc66782afe2fcc8ea8fd73a8b36d10d9520f3903faf09dedbab084c93cb72a784027ec389cab3d4742b7bad51963b20579e294ac6b27762715ccc9a686997a977df691e3cbca029fac704333fc69bccbed8ec5c3818b24f815cc0cfb7657956861268ef0f4e6462aeb5618f263396aa09bb7360b4eca3e968b2e884dd136c99da7c0b7aebeaff1dea2493f6ddedb3ebc5921cb7115f7efaaffd5e9c522b4283ba74855775552bc8c0d8d9eb2c9d6845c5444c62f72f8442af8ab088bfaeb6ddf411377568b7a6081b570066a02b8d81bbd70d2ae5cc8d3cb9fb73686cfd48236659b39784b92996bf360d8b564972cbaadb22d3abad091e0423683373caee52d0cb1cb54faed10648964905b70df2c4771ca27924394653c4a250cab94713f5617439956e40497c17c8eacbfdcd65590ff7f58c4ba7bd5142d820f683a0261ef4cd8d4262c5f9ece54a984d502ab75cfbeeb602ce2153204a6c22db9a042b89819b1d34a9f40bce084dc1e3a19df656f490c5a14a1591ffbe45d1650de7e05b94f00a4f510ea1a9577530304f16970d71dac5bcd98d925045ad8ec50f7cc68d119a65f838407414a125e027e9884d6d6d1c65338481629519cbabdc8298b5cd51e59ffe6d6f8ec611c88d1d9ff0e33c6c3ac6970d1dff304d030f1ac59b5b9b2982771462695a16516e5cbd5517f897295984fb7c92fded01126e15f0a4404a65c5bbbcb51a8634a82353ec58410433bcc0311ab89132a6726d51063a2031b04f505131cba3a5a125d43bae4e6744d140132c9eaee4fa5a736ccc2c828dfcacae3fa4738c5f013a49bce858c50fc4c7fb37ae38a752c2a04a181867b9b08e33b59b2c53cbae57b1085403eea82c616747bdead93b190105e65ae10d1e03c3a2e6f08b137a5ae367d3ba6e7b8f9019d2c010e493fceb5590cf03378f58e0a28b36a771e2f7e2606a81590ce16c16e8f5d4589d8fa5d91a49adb00d76fae90ddc9d559e2fc3dc2b09b23ef62557ee8c78df6bc1af832161c71ff02dba073acf53018277bfab055bbae3162e681a9ce6e06290e408d802d4f2a558081a137f74ecdc3305e0326ca4f24c0bf4f1aa77059a787538ff24a296813e77e838caab4a029152de6deff2edc40aae1a36adaefa79ce02eab16f3234bff2601d0f14a3abe7864b476b3beed1c7dd8f9cad08d2d80c477b77e2b0e5980c80f74f28342d0f28c96d57632133092cc9f002d43ea3a51b52ba2e9dfbcd8b4e17c6b7e312dfb3302492fc1269194c9096a8b7a029f725fe6a44db4139401643a1e2bbeb2be5d688888c1ffc6463c165a4e594445fd438e7e53aeabae0f455eb12eabd66c1cc5416b9c45f7fcd6fb78db0442f28d23e38064bcb10f0262602f79f8aed605382d562a93081c707d3b850e2a7e497e44daf345e76743b6d4fbcb3f908a3175f8e821ae4a62ed886edf8142d0cbed81290661c07cd67416ea063a01b5bf92c540b52b1684f947f15422e1b4f0a75d15ab7e34f00ae3fc8f9690834d241184d39e45504b9b8efa9bc677bf7b3b4a393727606c91777b92a1f79cf5ccb5e9ebae139e58716d3b37f376f904fe2868348e728cd3d4650dab0c6d905db2af2e46b5aa123e4e24c5521120f8ece5de03c5c2b5360ce1845213d289c4389a6ce5dc6bc759d37281f6832e3994cab9f21ff1511234ef938ba2fbc0862b83f635c56524c4e66e18a08d7af532c9badb60c96495c602e6863207cdbdaf2ab9a3cce54c294e3096c849d7a73c323ecc9e211554367f2809e3695c450f66636c465e7a567eb6c8fd2a3a08dd35ff21e0c679ab403b4403d7e432fe9ff1b723c24d9e754408cd364f3213137281ce301be9a467d57efca0ba912ac08ff5eaf5a7df784997280a7f73bf8a93f30ada4f87cc147e1927b79e218268c56b8a771c06852d60956766ad7240fd3dce243c2fe66ce768b8fba7a3c5713749cf64c124754f87298332fe335d8d5ce260e8ee2d3dad9be7364e9fef5090c45c1478c6b63e78323c30e5f76f76f2506500e2e6ae89bba9f6c718334e908182b0ba0dc5009d667d6918bbe3dc1e6b775d5481bbe18d8cae5c2b3b9476843c7c2d13270fb7974d0cbd110979af0cc2671ba34608545b29a4863b884da8546a2e24fa0e7c181f4cefb91424c033ed8507b51dd824591327ff3aab2461b3c5099b923e53884eecd560f6e386f1834c2150ae627ef43ea1c56fe2fd35926af06495af80004bd415777867dd527682992d4a841c742be9a67b3d5f4eb0771d4bd89cedf319e261bc655792a858148fba1d2f35703031bbb808a30cd3f52dcac7437b19a7da9d3def66fdfc80801b996d230d66d42455723335ad13c1e8d76a0325525304b5bfee19f9c805b3c25c78384bae1386669bcf455d97b91c1f4696508ab3ad45dd2410833e7b9c5862e4beff3b88ae2f3cbada7b731f8534a374fbfac8fa072dbb0448bc950846998317ce3fd0be0b9a6ca2af613884e7ce97240167f718f0c258a3a569d8283e1bd62f3f6d8a3b8ec2761fee097ac898cd21aff7727de0ded7238fe2b659df7571d8f477ebf0efe2aec484ad6c77d354b036fd5a07a3a8f3c86c23ecb918d0fb5d0136911ec081500792ee25734f4d333224907b3212c90cbcb16f9e58a43be78d1265bac80fe4d2dc7db03fb4de3fad7def58a2859951556f9e5fcbe8bd62c0712959f5a5f1a2a8f50f86a2a13cc517941a5414dbd46cb9eec16ad05a1a30443771c58e2e35756b8bd9c0720f88a2ae70ca9043bc2334560c5654fa5af4188f7a8f0c55c1b5d4f0b2017734c4f2fe08de623d562939a3389cddd103b53955ea8afc223e09d0cc45ee7946178a32d55be0bd30746302c2bd132affa34d307b48386d039862324a0a86f3cb92dc35794082e0086fcb8e1e180ea17a726f9e7e38de90cdfc0a099262bf10c8a7de03f39cd845484d8159662449a64e37fd6bcec0928b9d4ebe4dad4594d980deb873bef820d95b0694faa830ec914c8993ca537568b3af2bbefd49bffedb497acd72708a203009edf1b3c534ed20a5cbbc3d48e5b2acc80fc2ac9e12aa09698d18f80e397e466a6b85af313a22d32677b0b3f9244141b75604303cd311de7715eaf7e911ba3816cb595aa17173073c9db04a150cc92f925699c7ffe1604a338bda033ec5cef94d8a37d0bf42068f2bb6e1c656e1263ac26584eafaefea63635b30af912caf06f139b6dbe9acb81f5441b16dd500adbffcec33c220a1eb4e665bacfc608d7ca148aae5216186450a3f3b79576bf48b830cc75c5962716028bfa251e4f131d05afec7415ef52ea9ace0656cd841ddf4423dc891f8de437100e25a2a8944dea2ad3663961090e325d5dac7fda7602b74719b50021eb057687f5904518f3b1fc86907d0e8ad8d7c267a99b88b6136a29b8b8068bc67f70e769a7eb1bf2e0c1b809a92ffa52e605cb6f0503388ae3800bef06d58f015989bfdb4644188150ba4019028888f5b4d68872a024cba299545572397b06d4fe02a069236d58b3f004a06171dc8077edb144b4bd8869e1414674092a5936cb5357b4dab859f3b4ad95e12af6c0d76c5d576fc3419ef6f431dd05a6fa774c2ebeee6255f6987eafbc989b97446fd94b62ac042669a7396c5ff378753691916724152da28ef0dbc9668eb6d65b3bf3b84a1586a922d854c603e6cc08d7509ca7c23d978c83c89c7ebee44147c51e4f703b709696a79169e6c074fe6a7f02202011ad86930c5d55d071ff3d9ac7ac034e46cc8e9cb4a19970927b195deee7b6e0b026e663ee97c31a7e74f3e96890441c6efc4e9c69c0cfe89cd91f2cc3644c59ab532a6fb2aa78538fb22ef01cc533d7fec0235ab6569d1c8dc5dc5b7a6403e93a2aedf17ac08758498afbd60b1128200fc9a2c46765b765c804b4602023f593813bf83f24de2ec1226e4e44c1a33167b22aae64e16fb347b07fbe7fdeb41094a002833934318c4a5d2a841dbefc46c150d877b2a9663910632bbb1548e2f37492eb41237d9412b2910fd01654bc194e9be34fb5b2766e1bb8ee33ad8dbf76ae9b529b95fa8bc2b07d8d34189493871811e55b75970666329c276770709d8877b745d671b151e6c5efd93fc55e98e98220c56f7fbeec479d8b2f0c5edbdaaaba0f138296365d00a17218e40cdf454091bf029f8981d6b7e0951cd6c6ba81b6caa1f3084fa94941c6719030a45a353712a492d46cd8201629bf8ecf422d2f4f631154ad719aaf1847fa11db9b1f0045b03154b30056e480209f90afc438e5898745549962d1b17d632470d5f145dab5af0b7eb4f884add4cdf725432f63406433c0e9abfdb356d137d1291a937724ff21247539c4c1a402b1d34c5d4d5218cd736f509c1b262e5f008fadf84c8a1f1d8a8eb39e2cabc955a63c4bd050b6643648ba9b0939f93163a897d879708616a5ef19bb64fbc5c1d292f85ee0b6e0c775d68d5eb29a561c50fd2e8aabeaec406e44c7b86fdddbaa9534f096c92d3f714d47c2c8a73cecb9ba888356286a500e5ee1e452720afce305af08fddcd3cb2a526a9037ad623bdb8e0ab803406d49910f49e8e9c83d2973fbd6fd3d5c93018dd8ad5294307600409fd285b756dc53235e6e1ced816fd82e4a3d05c09320a3461b24f9de31a6858564ef7b831d26b7fccebe9cb417f3fbbc6f3ab8981d818fa684df7d5ed8ccc9e3322d53d939f66634635d0a28ea6cfaa01bbabaa67a1bfe570c86f4dc7b91d2af287766568a1ee9a5752c556574ceb2e1406302775bad365027142740a93fb2dd013b7ff2a8d9b757218c11827f58145da8338df1b9f4ae961d7473b03c8fb570f5295680983479ad126e193101f74798a08091c539fdac1f1634a42ae0001ccf7295398f70a953fdd93bb797b8f51f8a3fd8f2111f76c47cd0ea1e19a2947e8ffa4e2570bd6b7a57489b612efebdc0ec7014e5ae0a67c82c63a9bd751fa731d2ac8d29569d250e2d080e2642670f3e96b6125ccd40958ec7f5817d6c50ee7587e0bcc563759a9b42c78499161e5e569e25f65b5f3c1000004ad67e876acd0dea4bbe73a1a795573643a863629d5088ccd44d637f76a9a2a2531385c02a241d94e012581f8ca5fa3ffc8c0de46288c59f1ffac07a22f423b083276064af9102afef1d8fd8721b703474b33fca482bdda9811069694919f99211477202f4578b21e524666e6fb158a39bc0040b26b02910a55fb0f87ff32602dd6501dbaa50e9b43a9ae2ad435ee32f941c08525ed09e1c4c25a009588d87a6a01d583b1b0856d6fd47aa839b283fb4ab3bc2fb3078cc48a5f551392b4ecc7fdb2438ff48c089f2aa95539faaf88453fb2d0fb9e5e8b7c2321d48c8437940f00b8f687b6c21ee7975284efc900fbaef4698678981f6bab9d82549fec8a06dde384b68c39ace38c67348d911d8ddd72dd9790b24b5491518a54ce3fa3f73435c8a8413b21c9bdcf5e92b4bc9bcafeceab0e01eb0b2852fc57434caf37bdcecf90ecb424ac0a37d1adcdf8b4856d30015fa5ea9cf0b766bcb2099de5b8bce2444ade36bf86354261b6a19e0b92550d00c1bdc70d3229936fdf6877ce9047592093881a7a10aab51a9022c7e6bb4bb28ee8103b39fff3b4e4fee7511e1851c08df1b1741f5bc7d0068eecd4752db31310af431ef880fa53e790a2e52b2f019051e947a62171a58d5e149ff8c49311a4ae5e80c563e5bda90bf1f1f9e0cc9108ef5d4293760b1e414a23826def48417c7d29b6b055bc97b70fca5b8af8aab10e8c048ac692d20a71398f26e779deadf0a9f6bcd3491f1e9a8c672566c50c3b2804d2801667d0ba6944f1c9e011873ae6e6912912220f00c8879779d193d5dc4c978d7b29dcbe833c01c45f87a41c8ebbf6bfb06015358f04373bc8ff1488b9a5a28df01ca41b1a0ddd78a0374910fc9a1c77edb539e72db9e149aa1bf000645c12de427b143c635bfe89165cf54dcba266f9cb9ab8f97d7e03448d47b7b4e7ed2ec0101ccd4a6a931931010f9c445b0ee08ea30e291b1d9232f1d010e673759d3df98cf7bead19192cecb6df4437c5e8172bf165f8fc2a5d60684638cbf2f7d9d95cbc8e57147b0837d4ecfafec6613415f4f8dbe6206ab3922876e090d70434eee6a5887d82f093f8ceda413354e06c1dbd2e5c86c3f914e216decb38dbd3dee23ed1e00498c0bc26bb54e6cfb3e699b74f130ec78a65761b35bae426082c1fb821bbc7acc7de5965cf5b798357660544f7a81ae4592e28ee06f749d3659319cf65d4ada6edae19bd1596690368506f175444ac778ee4a9eb974d29e14c082bc3e7394690a5dfcab01f83729b6c3157bfb0755f40a6dd376a74066bd0cba66fe8b266c75b9e0a462b948c1a32870ebd5801b44a7f7c0c0621f9219808577476b42fb01c86fe34b6e78804ae008c4ad6f97d74e599a203fe0847219247da77fd0cde5991602ad296793c5d39c673fd9805f87d7de28deac2d1d8b536bd5f36f1dd8d45033b2ebe54126743481e0a0ca4f2062e39db268e285eaed2a6ecf5c269d96f696d80ac61edca49bf244187e594de0d7000c89642206dda88931ae008d192c2fd7e8cfcd3a40e79f3364b374a3633436c98f64cbfb1aa1740fc764ac9bca145bca9769b0794941b60c91878c7e187ba3dfcfa487fb759eb0f264b3b3ccb70ecc7af39a858721481a1db3ec84d65387e20495acb5d170eb40a96e02f6073424ef4b063bffbe6a333fbe4929818f63dc958219182ea501cdfa767f501c0a5ca734978a149be2d4bf937d862a87126f3db88969ce72f3a9defa7be72a5215195111453624e7230c7d4b91a373cd9193c82407b90c33df082ff0125c8d80912e06f3989e925b5e48f17050302fade7cf97129e345ee68e40a99938a5641458146b0629526969a83d3a289c98cb541edc4bb051040016f02f07b672f50df383f7f63e913c6252eb860acf8ec62e9a24f094308173be978699e2c11bb2dde99e573734308692d1f9e1c24db8c5e81c3ef7be9bc95a83c8df74a6fade6cce348f67b8c96b96790479534e9ddd65b856e5d988b82a0a3d193e0c241c4b4a9ea8bdc4692ce9abb545ed75f689bc398172905ddf6b95434eea39cfb911bfc587a131384f38570d3aa21d5d1d2ddf951b5fc2947a01009e963c4ec40c569b91ecebeefbb51b2f29bfb55d85394f77331b8c52bcffb63406f5b4b58d7e168838ba37949f58aec0d6a11f5d4495103e6b145d2541b0e02472817aac8a00c7ce83aad3c87e32e045ae9707220c517b0795040cba63cc1dfb5b746a59a1d987a7d71718d33e088956c2f05977d6897361d5f2ddac491426f2282e047204551a49d6cd92bc58cd29fe19fc58313f9b4bc4aabc8c9c2bbd38d6158d56d11836f4efb54dbf68787bf74a028ecbe3e9d171bb4bb600e5a6872b29e050b37f530b6faa753a86b18569d118828fa11e794d6b4547ee12831be6f9f0f28fdb2fd1e1f85901ab5e19a0afa66187bc55ddfc1d6b9425ac23a7d020b6b5304f7c15149f6b1ccd560ea758a109ae1ef26c12cd382b073c60bf17c564c64d3b4631ab1d5587d7e05f2a31c9de8df698ad15170bf7034ad6d4a758771875cb1c549ec671a2f4898fd2c7260c3792a7d63391c05502131be705d3727ae1a185f9f2e228fe1d7ce15c21e1c3918820af6fff0f026647c2f69a2330def046b57c575f3cffa53a26b4c5bf57513f968775192b7edb055dd5ec9600cc4d6798281b2646c7802610d06395e3033667c8e702d51a85e6e899bbbb51e465ee7ed75afdef716da6a70b9969f5967d79d7aca3e169e20d1684d333b8799e964548a09b029a192018adf685686f22ab4ba50dcbfd6ec43a20d09f1094f49032f5681cfb31356a73e2460ead9e1448eede9941675ea6b9deff4053f525b390a62a28c746db471ea4e783547dd520f59402698035d525552f7c058f95dcf636d4d119f8ebabe5c13e5115de55f4eba5da2c8c0cef79224f9252986ad9a98385cc41f68db96b9e5aa5fea613c930b3a09a1886c59771e478078a7c0e39d96fdd8e3bce375d171ef109857c1290dac5f4765ba8b1385b3bd4a66e7ebf4509099bdb4c3f1af03d63f7145b90ae4bf3e521b2b20ccdc433c3cf89b984056b1e2a71bfb5967fe6efb29cbd7a6bd6b13ff7c530ad2bbcbd3196ad8277523af8d16172cfc050b6f5d7528876e6ab4d9c506ed0af62f15e64fa81a3515146694b17cd15adc6217f69035365d8afebb5374b6de6b1ed4c2759754207614d95507b1ec7e6324e218df6276151d3eeefe88bcae4dd4c1ded9dab55c73ca8749e24931327f64f796a3f6077be9aee0154fcf8b2321e6f2a991dfe85fb5bbe56b99e20de664a2aa609e331a87506f66539ba271d9a8777196b88349e61f1fad75b58020bdf8f9cd9a978894da25fa304eb9989a52a417bf3cef7b331173bd84d5f1b4b7bf6a65e574a08ff7383b83ad6bf1a784c90e70a38050014f9c1556e2e29922e70fd43bbd82f543541c697d775746c7bd7e521769566452a2c171af93dc647d18a27cef3d022630514ce0db9c9648d4d336736d3eb4e8deae0178df516d9761d4071cc83795096fcb21718feee5330ef9f2b712c7b46d802b77c91194da5997060987d807de45c319bb93d14c1d5d5d76aef218cfb90771f1edf0b65b786477dc3bb4e7b76140cc3b894b473d0be46f16d3b931d67ce3c32573b99fe6a990f6e4d07d77aa2ad8c26b8d2d61b36a3ec72f3b7f6c6dc2c152344063a7830d830b9021ef38ac7ab21a5924311304ebcbc27b752c0335d5d3257a1b354a6f76c0f1c9559b46845dc5ec1dd223b744e9c8fa42e1589bfe9a757985e10afb693b4b2854bb2c86133d31c5d7a939acd0eadb8530f0316ee083c21dcd2916ca5b9d11f592ca0e95f5d46b184a40fda294b52a108a843e024a376dd00465898f93defc4288cc65e456dce4c9b990ef168ecfaba90623521afebd715dd8e25baaeed4afe72b0beca63639160311b9640002b16eb0fca8d3bf00cdb087217943a1c2cc331d5fb591a134f6cf0816836dc8d8a2e54d7ca4683e4a4f2a0b8f9d8b6ca0792c5328b66d1b86db7d52e93b21f3d244bfdae88ecf6de96a5046e0126f8b7f77074c31332828f4c5b3dbe939112ec3af9df60ead4eab0817fc62c9578fc94c1f7507bda73fa7a61a2e183779dfa8f02aab15644cf7f8a1f95c12c3bf5808c0666243dbd61b01938abdbef6f8ccd6846951c5387c0ce6e8383703b3f3d919894b2aca65426845c98801c289b499f7a00aadc2ba1a1530fc33e508691a7c2fc2397bd48e6acf271c8bd635d71d1ad22ec93dcf12d68b8dbcb9aee5bb1691ea72901a8b5ef6f157d9d543a1373a54951b85b3f7ca2bffc994e3a0c164ad2947cb464f74296e4da297519bd681b41f8c9f6280340fafbd2fb720c47e2d9bab9b2c7a6b008200170055ca1e2e57b076e28622e9a8aa0f0aa1cd4afec31b7e7372b6e86e5c4bd2ace2fd6100492f2ce28fbec2a77078f646747ada12408d1898ebdd7a0fb720bbaa0b4df64eee8d5f7e734ad58daedd2b21bbfeedeb7d4a6baaa5b7adcf16451e9e67a381091b1da8954d7ec295033baeb22310f441251a5af264d92a42681663b762543ca5a976fecb3be03a0465d447674f5f8df390052e07ed92dbede09900a8dfbd42b2b5c90fc29cf4cf68c98e518c95ac8f3a408fd5bbec512214f2b06561b2fac15fab5632cedf559c27077375965a87654a89d4b422902ef959be138b81e384a95503ddd474bf25a33c490b5949426b5ce799f726ff9163997dc7933f2aa4a7cbeb178ca6be732caec0b9e165cf3cf7dc83c38aebaab9b8c6bd42b24d63d7fd74dcf064530c8c837d58889a60360cfbcfa1cba5d48479fd99ca8295cdedb68b4b35d36988489325addd5a18f8a2deb3a6778c94f4d493d97aae3b580e536203bb824553528aef9f61bb1ee9f6e33b7f24163a8758884d8aea62d2ae1758845807e83535680bf156e49e0b0c54fa58bcd5526adc8e60e31e401beb8b719090d14eaafde1ed82d1a55f6793acce45978752e40a2850491a0cf306c4f82af88234001cba67e75625873ac101412ea6f70105245c9f3c91d4fb1d04f6ff2a18c194482951240689e092221910ed61d215548030827f1f73f2425f985ed2669fde25667753645702aee5f519c9ce304b76d207a7327ee201361270ce55aafc837fa02136849741fc864437e3238e63432014d81b1426db2da9d67aca937419746681363b264fd48697dda458a2bfa7aa507c94de11d4c5aaa8ac7ad6495e9b45cb3d7f8e77a5e74e78703bbcb97a4798cf260c52c6aa4966b19661e506701d06e7641a5777b4a9027a2d304ec56bf0ed4c226d2c8a7d977e91f7bef7705a7c4b5a25f2394232cfab55b2ef22b67a6668106ddd6fcad14153c54868b5996a288cfc382b3132ee14d81aae58af051760fc83a112da5a3dc32092875ce9b6f0af4451083e4abf2476fb6da41895cff75ede782ed848441b0f46771a0e90ebb5d1f8c7c1d154455df3ada7fe4409b70e0c90e7528facc656f80ed63287562fcdfb2ad2fddba7da57db34199317678c3527e68c5065b347d7117eecdaa2c34c220c620fdbc16fc98e7fa662f34f2cb31ca085546163f1c3bff100e92fd6aa5bdf7e2442dc72dbbeb97490deb2d7438eff17f829436bf315be5ef119f974052bf0e7498f6ca863feac7ca8b14fd96be6568ee1575d5fa3cb752563c1ed6343207cf3f1700068a2c71bb771a203688345d525b30a4dab71986996af8821e4cec3495faa8c035861836f531e75f554243d910f4aa514aadc739b0129855cb1dec288fae209b06f9b5db9d3c01712f27683f225b1d192c144c3b3aee01084affd34abb65c50ef6b04dbdee5c84a8e8b038f47c26668f1e55e235cfd45d5ebc932c084d28f7ac0d752dd49d5a05c19ed20532c984d5d451680e78e108537bd06c5a7c7c87178226d57de9b6687a90b977ca2379fabf6f6d6c9d94537d6fb0cac2200c2a39faebd95484fde035e298a4b717d134c620347f585e4d7b1549bdf4859cce0bd63284fe72882f9aa3d703404a36766367d5ee902858a2d63a5a80e35d82507f4fde1d7988e3fd32da60e44903fbda88f4929d36f870845bbe7c3eb100d68e759ba90d2e364b52c712f4c947e6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
