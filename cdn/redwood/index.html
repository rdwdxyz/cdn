<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c97846d37e48fb34ca17f1088966f49990605604a39cc0588d7d967d1b94dd891fc924a2ac7637e56c7d4470ae16349d3e92af26db95a81dcfb89929590df1aa8a70dcc27a3c1af2f08b6219c05d0ec61bc7b43a71a1be0d6b855ad125db93e6098a2fc1e02f1c5a35d59fea67667ed0449d5b1289d8fc5f57483d7fca3729b69240e376bb4884c14f8be959c5a08e3d9984d42fadef88f41323fd52e2692eaef2de17310ea8b990dccd3c49f755744933bc9774546bb8c244c98fb70c2632af695fc25eb1f5b32962f3a3cc82b19c38c1e9e6e5e593022f7cdf32837f39739ed90bb332a29403cb6c9a59e6a0d746bf50b76292a64b69fa4680ebb8f8e97a51f9c9f4977d3bf44272080d8f75b458478a1fe785310e3d6c0a9a324399f0d98a27c10b6b82557eab5a90b1e2d38cff8ab19de6df0ffec8960af3f66900b60a39f6540e71a3e9d3b45cb61bc768d96a27ab3d0b659fc65ffc786add1fb9bb665f70feab4cb0f3f93f1934854a400952319c9d47f84212ce4ea55818ce0b7a3b6140d5fcd26cac79a0138d74237805414f235c4f30761a5e53f0bc7c365b7c915b0102e0f16058742082d308ab98052596bbdd01bfcad097f3329bb0763689b698d5b649b31fa7a30b0ccefe6af95cc6f9cb746e606b4596c9208fa4fee497f501593c40842b6b64bf49d30617adcd480d4b1993c1f13758d44c9689e65319435c5032d338fe1cb4f49836048c9941c53120bd1f93adebc3f711788bf56db55a9664b34d17103463010ad4f9657a9616c9b75702cacbc9fb077a9aa11fd66611ce88f68b8724086cb1b68519a3bdb54ba69fef45d7c02188e98de540f4c6f5b4aa339439108516febdfb0e47f185cae19a16e3dedefd8c8075c1051fa9e89081c53838d7ae42088a150d2f7ddb0b2e999ee3a4b48ddf1057446112edd4e50b6ff09a55273935c55ee3a975b0471123fb7f35c5982fc927e5b486fc0d5125ce18fa23e14a0485b0176ee69ab54faa3a74560d0899def5a35349f0808a0a9c1152d988a6cd027d6cb7bcd920c1f88c1586c3f62b51f63868d339ae92de6bf5712b91d3f28219be6a7c1ffb9bbfe5e23dc3627413964e555480c768a7ae28e3890f8aec11e0b4da1aefafa53465d9ab877f8795985697bdf61db8b5ba5ad9b69cfc5ecc9738d0b8d1eec95ebd0ca3568ee54162123749521088257603a40b92bef26d5e7f0b6b44b7443a81ec0bcd6ae0b12f2ae0b03dbf705809799f802288f70828fb458b21a56a4bfdd6f2441f05a13fb5648c18edc0da9f76b0a1f8432e53ae4fd6a55d84bc8a355f7d077ee7ae5e5fb3bb1e023d2c4290f106f2ee2b8aaa675af5fb1b8f730ede3560d9e831f8ca8a697ef25a7ab9a874bdea43681bfc28ee06b9c535d2552ac1a6a75e809dc979b1b6ab003276b2f9dcbcc813a9ed061b89be730c8748d83fefc77037139c6983db3c07a4af1f46f75819a8670111da51280ec2a7ec3acde3427199b196b92113933b4abfb5126e98630bc2cc67898e9e0d167eeaf14ed185a3759ed3c3b59f9494a8723650df27bff44a4d8f58b92cffec9722302bb0ea4761a1cac6f91fc86a6667246a83b6a9407439b55f4d4dee65f7ad41aacdce49082ee1b66191b45fff8dbc241831ebd90018b928ded4a0295fa77e85ee84b7fdeab6437dafdf3fc301b02c4e117306c8c9b220ed5184b45aef00dd356b279469f68140a59eef3dcf435105b86a9ce4779d8bc808dc02becb4dd0362eaea377000bcd0ce90d3e408e2fc0622fb91e3aefd331e1d4781b4f47bd47af04ed70f0ddea73f801b7532e823f8039233913a31c3afeb3e637ddae29e21a5c2a5aa14d84690479cb9fbf3d61d68a3b37c09fd469a883bc357f7d1fb31d545b82283e4d872c846081ce63fadf2879fe49a30ee345827fdc1fc37945a6e6cc5d802f00dd0099530972ac97efe45ef90e8c438282db5f0540f856dbb66f22dcd7ec6913ab68244e1843f6d0a3a7715da896da3f7a0b6a1955b3cde34acf6e537df098d6a0cd64239ea4e3ee10c2cb4ccb9707bcbfd1b0313d4d846b809f5c02aae09773843d1e30e4ab4a97235209c119e68a52cf5db29e62ea0e755e73019ab62050172a7f86c51c459e5cf7a166a2a88cdec82fbbd8894bf320fc1a9d0b9eebe493535acd5e26546bb0f170663f8dbe5bb1c6f5e4377f63f5a1587e44e3a39a07010d32e9ef94b634c53dc76d6b2eceea99c7627a4786e3e5b5a71b1802f7b97c0e1c0ad65a9a9d786f97bde643a6f01148f8053cf9745a7e843641a8e76215a7a979eb512e3f249499ac43e455d8b9a5208209d332c4d0cee5bf7c4c0013c0c86687abae139ae04968266fdbe7b185b07b4dca8e69d6134d7edc49ea7c77935c9abaf85b3d191a81bafcc2e000612a121f433dd185d5874f59c13ba9bcdc7cf7de1c291617862039848a2fb23bbcb82e11728de316ca14a902b7258acde1006ebe731dab19ed7202278217aea45b1eded7a5e13fdea1be7ded99b80c9272fc97be5b52060726290d529fb36bb901fa399310ed92e187a06503a7c9b9001b83f6f78c719888fcebadd13471a75898470a31a81740f796e4c44b43224067e98de22203711fc415092cee24c3edd8b72c340c4dd5fd8d27fc5a1b8bcbfcbbd6956d63199d4247387310f45e4747505e8f763bfee4c272a807998cbed7e4139afe5f7e7367c2d8db5f1ac2e6f078a76b67b9c76b7a00b035d3cc36102934bfb36592067cccdd1760e7ad1e0939028ea8d30c9005581beae7454c138184c9e9731e853d60dcfa55a9a5d53dacc6741b6c6c0752cecfe1e62163cc9928fbf9e83cadb4bb74ea6c0ab321d98761dee48fdaac91ddf9037d1ffc0686ac57fea60b59733bacff80e79a50cec57683a935de76b31fed7ee2123dc5bb477dff10402d93024caff8a970926a57b5898f536a68410dab09e121bc6d0a210b10db8cb104666965dc18377c2dbb5a6e64a133d35790df2b11c4a45b04b616d542263aadfcf582f6d1f563bc1c063caebbdba7febf05cd5a917910f28cfdc2159b940b98b0555adb795c75be46d4ccd3c139a46f947b3cb9d7d24304db117812f1c2b64e83b3d8bee6aa41184d7949006a1878f64abfbc4bb6168241797e6cd204d9014c32dfa95cfa67c9c32eb8e722a5338e70c45e16b534f30dd94c92dfd9688af7f7eb56edb8bff71d14bd5c50915675a4f9b95f5a010c461bf36ae2d0ddb83009de2db8f99bb96dce0b00ba798630e3d43c57a373d521796218111a7fdc76037f04c39dc1c4c4548a948aa403ef044c0626d6782a0af7570aca9db2c7a21bcaacc7310d2594d1e46bf08ccdbe94eaae31e26c70fd5258b6b8d31c4f64568933e2e7c0bcfb587f1007c0ed3e2bdb8e8f9ba35f272ff50fbe231b2f1f4303161cf62d57747f5362940e667f8000587fa4143e7d48fc051295c1c40716622cb46da422c34fd686d7c235c0fec6ee7f9c0905e49fd1b1c812bc82caa0f1f50fa810e05356e4ffb67837adc54e62cb10bc0284f5ae8a6ae85e016843a071e20163e54579b62d9a07d2507095c3c7201b98017551e57ed0abf5b3f844723fec850ef4d85a829616154e52faafbdcad90b6316560021f0bb3d14bd90ebc814dc293bde6efdfaa51cd2e603b9b1031cdc1d0fd502b54c1a709cdd40847eacb27e1c7a0057c0d2897beb9fd5b801985afb50b3f3f9f456a843f542f480a83fd8a0555f039766df5bc60f101040f1c543324d7c4c5492111390b6f1724cbf374ea16eb84aab99a39760d5ac376200c8161c7fa65b73af8459211274c85475e74ca1e372778334cfbd8b659beec061897dbc6736aa437cd1859d0cea53956013179c37ec3dc3c0cbf99465836c4547063fd8fa23029cb1ff352e1cbfc4cc16358b176af50e7e01a48610c40042407cba90264d10dd4f419c79206ccd5f5d7cc66646891be9504bace189efa92c232231b3cecc155e37c7214bfcba696a8df6bdf8b499de76737df33b81222a99a1dc0fd3c5998ab9f820a3ff39fa9b618dbb3379aba55fa0bd94e069da650904360ee1948a1126419e6c61453be424e31d8711eef9404d40ed65e038d55c9d93d079a395f546a77551b99664254edaee39b3784f99b90a39be4c08ae6026977f038fa4bd665b7cc845adaea97772415c9c8d80937b59e25b80667b7d2bb3d3e893b432a66f03169b614c0d25333ac19ccddbc87a9e5f531cd00e1a36945a4510baab6103233694523ceaa0a35d9816539c00233f6dd59658b07361b82c2c7aade4e92ad8828ed0eb5b6f40a0293670610fc199036a6e7113a4d01dc80504b21d3825614bdde22aded6817958fa9be422572e0a402f784a2267ab4dbd2a8e001251cf62ac8504eabe1c4a8afc946c7eee5235e1d59a4f9852d4ed9e98b576691676280748670a4e99db841b1eeb3b2dd42b6abaad642ab34e874e08d27141229e089bb4b862564af7376684bede2f34c4a1d3b249f14a29c38302bff3e74c6b7e2f0f149a4f1f8284902e6ad239f41040d9d1ed96236d7850b267d55de381730d2b6982c945ece9cb3e6b45a354a056491d85a3639d9e3f2b6bfc8796863fc66036cbc3fd5a48b446665e82d106e1c5fa4bae33088a2e2987f75d062b2657dd9da77daa85deac7bb83cc54e9d11e0b35a9a7ba01f711cebfbf2078ef243cd1e76d3b45ea3d99d48c4064fc488033da6905b6462b44025cb89ce02fb4bce325486512b2938161fa2e3ac35970b55026c097b2aecd373bc5ee707f071109d39fba99cc0fc9cefadba7391947dd684cdfcb4d870e632982bf6c7dd909b2b1e8f0a272cfeba6ff9da2fa6acb105698fb633fc2e42b37fa28dfc9a54b388bd00e67fedabb0ee67c601a9242f259548ea013ec64e255c27a37ffa50866b02589d8993c79b03bd425365f1366e99e19359eb587ba71b3b7a4e9b1e77719569f15b9585bf08423ff2d2ea04f51e554ff6ea185c6e909747c6e78041f64f3d47976ed70c8c74f6ba9621c7e634f532b51dd233155f438c5e1a7cd8cd9a8edbb66adc6dca76dbeaf53733bdc21b20c2a763f65f6a65933e8fceb096342dffea363cc81dcad70d6d53b5a90a5f530d42e5b7f66e10d2b9cde9e8b9bd393c6ea3798aca33394f874f5f855eb4385802510472cb62977d431fa87fbbcfe995056e39e31f149e78e9f6c622c7fbe105d6cccaf68c017debea64dcf1d32add284c9d1a8704bdc051f7a29c8f5b67f0456fcd066b1ceaec6426bcad7539326e5d80aca606edae0f4c2e522adb9b319088343a6bc8e47cafc9be318abcd42bfd9c31cba7223fdb5005d151086e0a0cc1c0a17683cabcd42e4c8d90dda39fcb4fa265c2d7dec78eb9d97c07379756ad4f8ccdfe42e025fd6c667053929982b45946d423eeb05b04191b211e5287ed4e74a3de43f0a75315ff87fb6b523c11adaa9618dc115c3304adeb9a77dfd77862f8b770670f1b8b0d96cb34e3134a562b0a36d34b41891ed9c4da162292358f166c232c81ecf51e9b5b60ec2f1fffdb8ec8a7dc5c7c66e621d9e69357f23ada5313c66d82f0743f98e3c4567d8a041f6599b8254f64e27da29d20936fe351fdab9f421827726f923da88b3335ca158c0f1ab495de62e570fadebc3a92942b064f6ee385645a25c64c7e8f257868b8ed6f3ee07467d03a043bc940f4835047c760e1140688545f87d54539592e4f297d97127bc2109834ef098b48411ef31878629449e968597a3b7780b45015a03d54da2ade80b1f1d0b8f2db569c622d8133ff497776110f68b5250bf10c3f543c6c31569ce3ae9214c1af9f0959064149822e3cfd8e50849a9005dcfb0beccae34d24668ff9782b8a08fac5d247f7ff76d7a18eba498ca5cf6858c4a0635a3240de881210f8a25dd18fe8167adb6d565748c2be66804a7a3a87cf72f9768179e61505ea5a18ae7b230f9e7f44c1ef429880fcd41b5e04456755b49a3052693ab824b32bdb4df296c7f1d2b0b44c0c1615ee4a0aa4dcd14c261f512510d1b3fc0a73ab8a74daefe26cec2fb8e0124505f1e9d201df1268b1456f55a4c67c39b69abeafa19dff27627231b67af13779b8a7b1ad77fd2f66c62e891faf32a3df9795d18ed81d57ced7ce103793c515b567490093cac734dc079df5feccfcc92efce8ba2f20034095de6e70a9a90320de3ff941c9e5b8add15e337160e2c740c8be35e250249f363cc4fb4da63cf834ce180319fa1c33fd0a2ac620417cd158a9821a9f0af2c3ec9b1994f11857789059cb01f71446e7e2c302c76b5514d013f5595e8ee803d462ae249675ea7a716ab95fad66ce1cc90a86ae5f1dee3cc44e2ce448bce4a7f2114eaf3d98e2a227016c312457ffe29fcd06707b6aafb52d6957ef17348c20d8148dece72efe6d9b0e4eb8694dd6c0d8f2fb974a48ef08627fff999ce0894bcc317316d600a6d66635d8697f5553832a9127747c935f6999322360850e8fc1fa4389d2c6db18ad8d0f0fc38528cbd1128c1a0c3fc93e94dcc9499890ce9f8d1e02296d3527fc4646b163fe7e14dc2f42a48fd86c3469c4a07dd6a40b01d357035833a28a4bf4917db85221aeebfc5978f6a9e99db5ddb7f205eaa9402e6183f2cd9655a746be089631d0af4e330e5602ab93aa325c45f57cbf71741c5d3f3a1672648a7d0c7ca33ee089be99159eec7e69ba7240ff5586ff187b8f8b487eca0ec0a7b889952546d9c88ecb34118e729ad26a956ae9b796b62f6b9a00cb163ac398121da516398a8887faaa88a4fdba1bbe224613355df953268772ff784460392eb1645780371bb0c43eb24f8d2a5aab461686276855436c15f5082edbe5a058408f341504862e84a3f661a5cf44b14194967e2aa34ac6718ef6b3df46b1def2016dcb9e74eb58f790960060e6ef19d2fab1fc6f62d584102a5600082437ae2fec985eb12b7cb3b3fd4c794dbbbd0c38f42e50b4ff24b51b99dcbcfc42d498fb8b33e0d9885917413a710eda109a62d3023c85a0fb9d113238f0781b2cd223f317877626791a969c060892de514ca0cc7592d65f09ba7b6a2355d7e523755bc09cb1fbbc5567b93266c49fc10fdb96f4476d457d877c43578c07191b11c392eabb1107349d7446335942e0035705a8fa1df5a57123ebb0342d6e6f59ccb172f553439a861953ca5348fa4e07cc2cb09e9f633f200282abdb4b85dcecf784cc03d788e3e62caeb9b22dc7159a8d1a979830d4c51351d195831a37383ab0908d4f3316b4ddb23ce92278f80199026a3e831ee4d65d133fb49fdb50a9b045f56616a329a06cc6a0bbe22d1c9d56debdaf157f59fe880cd8f67ed575eb922660527217c350b9838ee3d574907ab3d5d610b08367d0acc76e51021bc3c0802913383b9dc560d64ed6cc6ab35b7abb3fee23cd68ed1216c3fe9b48d9e4fc261fbe760a10947bb0b1ddda47f1512a881c3a6646df22b8c5c763a424fa9d5c7b84ce90f24e01d3fcef06a3ac9ff102dbadf6b7b013996ee243ad41b1e09ccc46ece0de1995027bb7f0b37961678fa00264311e0de7243786709fbc76b3314d5b62e9244df3af4945a58f24b214eed7557f1cc99629af2a9d7aedfa2c72d126f4aa3daae1407d8407ac1a4f41f660206f1d6a460ad8e5faeab059c9caa70c52c2952b0530c46f2bc8323e10fcba0f2b69e9dd0dc05736252b3b9a08b29dc5ac6ef5191461e58002ace7e19af5036cf1a90eebf571af4e824316639ad04203dd4c98728d37bb1e9b478142c78b634a200178b2a98aa1938f453b208d91998e2c21a65fe5857ae2ece64c4a27980438756d71de7077ae35afe19f61f777c8f0458f809a95893ce25e487e2b5374fd267f3d355167348dbf48a69325fc95808d83a80fddf58bd1a7d1e5e77093557c67d3f1486e1502969d479a0bb70931c47ab055575d45a6b9bc89633064a2193761709b03f3ad0e631af99e74a2ba3b7ef0ac29c0d6e095c445b5de44b6bd335fb569a2152a85e35fbb821700695ae3847f15012cfc8c5e47ee436231d9c46aff79e5c2e4fa411641e39a21127874ef3a89a3f5757e6ba32a6980b85ff3f17d94d148e50894a85a0347a7117a2e2c29baafe07e47311b1bf02df206324d9a8ad396041e0b2b0b1cd9b6d3b8f2b61ca3dfc30ad0e1a305fb6327c81ac69a0bee08fee01de81f6613393efa6b138fcf9b9b51b73778eba0637843114cfb4ffcbd083c76e13c5060f926f594669648e957fff8979f97e6b12e367a367ceadb39c4ac1b9a7a9f90bd997dc9ed69e70cd493b6bb3ba0c29a4ffc864a8dad51850acf941d131774925c09c0f6dddb9e06891164cc0cf2a1b3c3989a71ce6c377f9faf33d10385954f02c729266d926c7a44ad1ff2e4b26537617ddc98d54df00faf3744250697d6630a7a276b3450b6586a7e431f8369b1c767d07149c79629c3e23d8ed2ee24014a6432c97ec32f6782262e8be3586ee7be1244e71e091d6dc3d19b46075ec73a9ce8c58b72c828a2561f2cf413864dfd97220bac38a5256ce7ce2a232b72d9cdb16144213695a4b9a4e1985fbecf1d8f6addcff3c3d60de304f99fe9bfd45a66b54e15ee74a752ed871519b7a72fd733399305d0215e38a80e59aca508c97adcc2227cf27ec387c70b4733846abc1275d5945890946eb44863dd7bc2bb8052616e004fb79c910c7567781809a5e60c5bf976264a1b6e34e91c8c66aa0896cdbacc3ff851e75cb066c892eaf70a2195fc6e22a96bfb39b715b60c205958921c7753960999cbb7cabd32df6f80160337052719d3a13f285120cd669c3d40f54a4ff085f955d8654b884610fbd909cf270e6a30c1e0b36c9a0b2c2cd995a2048bf5584f26f100d61f5060c84a8adcd8ae701709776f1010bdd80045311ff9903d9a4601dde4fd20ba1fc4d45041e2dfae31d4c012319ce13126397a5655c850413bcd9bab4c1d95e61386723653592ca074f1b00d85da418ce855ad85290433e4a6bfe87afda9a3bf4e963abb15617ce290e6ae4c3c25bf86e7fba9d99c9db9204da748df0d28c4405304cd23737c36b8035d12437d0af89226dd8d5cbfd4641fc26a944782fdaa953be4e03a19924acd8085e606fbab3d82caa601c3dc62d322d9f62d75327d678df30fd22a7c70e853939c80426f8f1eb15372171530a3e59566e6158f4768936cc926b0967538db0834ebeab2bd18a4a058f9a497f68e84c47eeb940aedbc29c915d655e28bb5ed0ea9664e7818622db07ec1d00a6a5d55204285a89d7df5f175cfa42238d31a58d3d7c4d7dfca9bebaef039e3a0aea83390e56d967ae4e646819d8ef5f97bcc51338e4724e33fa16bdcbd01ccb86fcbfb926f646fc6f180b12128961ab84544009bab283849c2e94efd2207d3382a572bb3cb9fcb9a29667f8d7d316fcce7f277db26462c073b832676190d06aada9be72bae4c5ec358ad90afa0b2b1abbe42a3b0c36e7b6cd5c6baa841b61b6704c91797e21a355c7453e70cfba162c81058b89653a05001c3ecad91469d1b2638a1433317e6f1d9fd0e2a3662ab4ea7b05fbb3849f0f9e4b3737774aaea13bdaad0d77fd7b12394ec5ca6e393be344bf80095300aeb8d078382a4d0f215c96975e0dd309b91df1880cd0e1ea169bf77df1bbc30b8061c142dc7817d292653ca1e7f3369a6de753dc828f2b130ff38b284f37ad72e2209f4eff279555091b5f36238fabbe80354230cac72a8d27472b2938b6472af77722e4f3ca8702a02d40ea91c0aa7a237443bd710c2b5b3eb4127d3be728e12b50f3fea347757a25991a812f8b270ef5f3a1a819e37dc4985fc9ce739f4d94d827d1547ddd3da324c277e75bdaa9e09036e1f792150a58950424754b65614d707d2ca571fe1e3da0a4d83098741d1cbb4ebaba860773b66e97081fb44cbd862c6f1434d9b1ffa54f7eba7effc358e2f51df1e35981946d2e748f2e4a84ca48a495d3185571d7a59a5d02445fd3f2af1d41126cdb0a49424bf643af25c1ffe7b82526ce157a699f4fa259136e1e134539c1150e9b7cd376393260513cc28345cf05f47c13b608f0932fabfb95398b4c5382375f8057f4723f736598d51a76862ce6d837068d5802febcd2cb411672cda5dd89fee08180a4ec878833c9ed164bb28bc4cfba45aa7451651af80c364e7aa08f2d4ef54d879ec51c829ea48cd405f533de762a882753943c16bed88d0f33cbbf3697cb9503e8b600aa44fe25a288f6d9fa21d64b8a321be489ad34677ea135257dc9384a18f228b9903a673a41f72d35d78924de2808ac37a0ce9cbf75b3e6963a414948515443af4732f92302e267b085ce01a4bc22a94ecbf7bbcb0aa87032f5a9a1d1b390ea8d82cdb20d1aa0380d918053ece3acc4f76dfd3121507ac4740475bce60f844f99461bcaac276916ecf1a0930fcd1e982826bc13fdd1956b6056ff05527a018d7e0c94ea8bb0d4027e901e148329c0c996f0cfb116c337c3c383d51244d0ea7022fd9c1102aa015f6c906796c0f120e409da50fd51f8a90f9b99e9cf49dd16dd5d0dfbf3578444b5ddc8ee27f1b7cc16f1517cdfb0bb9bf724d7fe9e07f91e4bf2eaebb701ec9ba6679076ea8914f5b8e23a0a569f7d8c35fbec5d1d88d0f13a55497f03c8db71701ee35673a5385f73a567006feb67ecd10e8040e2ac76a0b7cd41d2d0b68ca10a48b0fc2275646d8151e6e2301608a515ff16f7aad2119fc9444f3ee2865969372755c51c765bff2192cb0904ff7a0c60209e8611bd2e09ea9dbd8b6601402f352dc9d94815eb7284c29ce7bc817d07503c7354bae95ee443936a8dc1a89d03627f04b71d8750fe5f7f21305df300227d6934f85f12a46eaccaa20ad00b7fb7cb64f9b1951e07b77f55554c2432767d1e54de73bed17062d7e87b3aa7d9fdd5deb46ccfef39c0e2ad7e505de71963c52fe9948190cd28c17436df7097188a357bade8ec5c8d9d4cbcfca7f8f1db452d07c806c271296a44e3457b0afad60c424a7f9baecdffe09441c7178fd8a3f0f9d6ab7cb9fa93904d3fc070e2054753717e6ac9b998fdeab63e8beaa4bd0937d44573fdc71425a59361f04d71a96446cc4ce6dc5bd7040c2e4d9e2416ac2ffb7577425388ec92863d0af61a046681e990315f8d896e114e9241ad82727838fe844f4ef56877aedb2430ca756bd5f31e36a3c00f8ec3bf7a9779b66fcbdb1188b7260f53afd0398e73978bacba165c9aa67a3da8b060894c19211e5ed78ef2f2ddc28460ef73a4d07e94e75aa87381d58472d906bb1996bc3ee84d6f835925a0db5de2f9a1744788c573b20cd4e444752bf0887b5084048d47fb3699b1d278ef5a0155fcbe0cdd365df626cdb2cf563578af4cc45562c116eda7832eadaa593cd933bd29bcf18943bcb50e8d25313346d8990928faeedb9c2ad725ed6b2a8c45b0f57d5fa82db953e92e6f31471105d0c659a93d85393360e734d21a9f3c2fb609613001bdc03893dbe2cd727a4c9697a661082c23172ee367fe8a7567fe8f8d6fe5eb6c4d843fda8485a0066b69b24081bf09c505c9e600d095dc193f09ab422c39f4b80d8e4891c93b05cf3be856a36dfc5ca4e62c4ee523f514ba430e75d2329cd9361f5a59f53c7635d7f66d9a8f6177697a4ce21a8e27b4c3fa40873e5457dad277f3791e1960998d33c004cb04cf6f2b0d1ca0eb4bd7b92327ffb2ae24321ef249aa369792eb05bef92eee38aeb62a07e3d1b289b60bd134a8dbfd1659aab3dd573227582483238324806bd39931e385c205badd704303d8d57c10e58092c412fa65575a831a4c5b2c6a3c86d59af62d4832a39801587289c43693f15c669a05e2cdc100daa6b249f124f82a148e009b80c6d096362299f4bdaf251c76a709d9f64ef9d3da1540f34473d4d486e6f6d3ab360cc5c1a75717aa3af51d37376b46da80eda2c4cef7eebf59b4d079b22b708346251d9e7c1067811489b46a91c93d151e433e0135418599fb397eb9fa5ef6f85147b4b7805c801e0337418b5a10394926a4e26c4d7fce2a800a9cab8fdda3e925264603bb41420e517b961fe7da757020d27b975abd1fc122192c31ded015a68e9838d45b2b7a1bf34a072c32cbf3028d6f802b8cca5741305e8b489a827465c9ea361c563694235a6fdb7bef56c538ef8f6518085ab6439c2d86ac1743c973f4a3b3a673330b6b60bec4e364e6a5306a33acc881ee532c78b5da1e7736036ba170054c367fe558b36524ec077111b754810e9e32b01668204528f3cea1995daea12042d0aefe4c584c90d6ae1b241b4e0fabdf5b1265c5ac4aab4bef098373d92df8365912b8bf9cf63ef1eb83c42cdabc828e7bc307f50f0af6a0a2eeb5ba98806cdc54bf6dccbaa911ec993f213a0a8ad40febbd2dcd2b7a86bccf9d6dc01bd1886447ead50fb4912d3ed67d2baaa678d0af06e8a3640ba247a9df8d6af5f304299fc5651bce357f9526d5bd8eb65eded84c1b838249627460fb993eb9b172088cf6350b90922b42a61c7b8fc58e88e17ec3f466822a5898a541b8e53c0d6f58160263679adabc09cdb016dbd841f4e6815691125e260944965a05ac68dd25a5bda98a151eb9a1bcb2c692f222cbafdd5c3c057b8d6f3acba5efb0c1f49ecd8a653b87ec008908a7dc74985ee7122f3a08fc4b600d9cc058ef7ac35343b8bc0a54020b94942edeab3b211f3195a089efe2072eb48b7334939fc94d3590516bab6bab2ca67e3d269480f6cabb81f4ff32377ebef7900af60750c760dc98552a4602400a9993131012f4a0331b8e03e8edc115fe8e516f666b39fcdca39b4c2a10e20ecbaeff6b61831d1d1581512ef2694ccdc32926f8f1c04ace8c5f1879d464704e6a565e9d7442941ea31dd12bd7ae171aaf5a76361af77a78fe766a3de564e4f13a7611d620494b79abbe8e7ee4ad6559c6a4896c330fc6d61aff1a1c02a64991e36b80572d94e2b95f11e198340e0ac50b265177c49c58ec013b19c95c0d0da3afc7c95ef9ea0cf3dc9b5ac33ba33a425ee7cb4a68bc4c8197fb1d7f88e39ad2cea4754d98f636ddc0afd504f8f3932a7fdfbd2d9e0cefd7a7514ae83956d8ffe2f68ae28370e07a1d37fd768ec3663b6f3f9edd51170641aee20fb4eb6db590eaadf6ab1392a72aa42495dc192d28c73825399362d2604d420c626cf5ce667fee937e55630fa31d7d7868d22f915884ac90aa79d8ab5a8006e93ad108b7029e4a669bd346d40a2205e3913d470a5b4873f1089e5a75af55b6d80634cfddfd30f9391bdb89eeaaa7b258a55f68d99def86b88a4846b8f81bdaeb6dc0bf906890628d21a6c5bfea9249eb5cd8a741eea1982013d1a7c184349e7dd65d21d8af3568df0252e0cb81a1aae5996d4c28edbc230dcf243b6a7dd692e674dab3d7b9d730ef37aa50eeea9f0fb760dec1e04e6257d708bf4dd7d54832ac2c5d8f58632907e93c1bc9e81d68245301f6471e34e5057e49929cf4a013ed9f4c7a22af4a164d85ea46f704fc0b4cd40ad4a13c05fc8475c95980abd7ec5b380bae5ae4b2be7d5a4e6189337ed46585672abb33acf54b578b4d70b5d6e5b8818213457d46281c3775f5574dd73be7ab7dc87da4142927b5b83948ff0e8db65d2cda63ff76bd81b5423eed3a7d4b7e34298ab337347e52a33c0a7ed3694111a973b2b5307ac8683dc3e748c3f27a1e247a03dd2d0c72efa4d3bcaec11a0138b9e128975e80c776421e67d9fad2e1c00b3b0043975239f1b81ba62c5dc34790cb7da5ca5734da6a9b07827c9d4138ff59b299e06a3a3478ab3af52343a09e24867ef60aa43db5b874bbc27b6e43e8bb3a3e3fe5113cfbc13ce5cc8506f7ea466ff668f1e05f02266adbca7653c299becef11b40f59b5b9269e02e991a353fd9db5d66735f2d452d274a432a367cf1f35ba0f5dd976f696d374e269d2305bbba5c7fcdc315fdd23159253f2de42ebf61c73d51ac005032b6fca994593807568dd8a6fb15c7451bb401a02b54032da2914bdebd9fb247f552294f161ec826cd5ba4276f5f844fa12cd5390059e6922a78c4d3a9752367bf8961da628e2a66b43ebc16d47ee3f4e72eaa334c9a2b8b8aef4a1d2fe930f89336e88890a5ecf39c7f0eab3678c0293c860eb69f91d617b00ccdb3530046a40abee07e4c3483fa1524c1043ff40824f8d499d166b3f78379c575faab6bfffdaebf810f1b3c2093f21515fb23f55faef6b3a16378c6ba21ce9f61e99ca83ae42a768ae2466b6e2fd99860b6625a9e58e4101c73a25789e6e344f81fb1f0f1c996f0f84de10b09d3995f1f7bd37f578c87e5953781e9ac14874a94cb1a5f540ba96842187687834b35f4a9a9c43f0408659c82320f2c57ad7de669f6f692be691cb69c0e3f63da8842823373932bba75bf4c5c0614ea76086666e2f6463d193900cf8046a32dec02c0a40bb4223d44f941227dce154ed0f4ec1446551b8d9a82134bbbdbe479ae8a17fd2288800c573a004f35fcffbaec6bcff08903d033c00a36b33c739e3af50439fb4da38febb92cc04c5396aa78fff5de980e4b3c523027f9cbe1990b432200395ab4b859f50abab073b3a3e3a3f75a6e466b298e0e2a370fafdce571f171b9781e61210ecd67014c450b0488c263f44e4543352cf3ea6ef3efe51cc6c7eb9fa6af6e26ef4300c06368f0b8cd41be7025ba0fb7943f697125b93d2cc17f7c68de96fbaea2bfb6fefd6298970a9c0ad3ff1bb99d694a60f2a905ac5b7ffc6b19a42bee130378e54f5f36537ecbfd61d8dcc393e60d88954c0b5af38538aaeec3a37a6ef69e9c0357c0547597d625eaf83d754bf3d186ec8f2aec71d5d2c2e484cd6b16da053f13bf605a231661aa00f9b13fe92540b66e69dd84652d21058a1c147ce773084551c529426ef8c871276692b722883d2b5d3492d0c12f02daa50b9a04e369e108c028e1682b014b44bee4e522f592245cea4db38dd7eafaf0891fc4342e8a54f81d6a9a59be8fc9895ac588dfd880c10a89a7e34665760b76cba6016471c0b3a5144a5179d6d8c557ef821d01305621cadbbce6d7da07c614bd80bc4a6d1789a9450854004","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
