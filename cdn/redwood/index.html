<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e893dfdfc5743330c5f612ec13aeb93cfa604e966f9153e2a16ad888388e17719e07e7ec5a2a93f073d0c13cdd1065d25d14787b178d3102169aa5d5f9232475c33a201e781ff18bdbcce56313e222fc18488da414056e76b063c9386b21d355470149447f62a426abf5d4bbb3012b18b314e13d281b38762cac0c7ce746da1581b3dc89cd29f245a5bbbf97cf26a3a543dd3efe09744649630b1df6bd73dac48fbe6f2a33368086dac51215bab3717f6c73bf84dbc708dfc36bcaac5789eb097576d9a50b3eea1cd6cc0c635051f7f6ee32cd46f9fc1603346531e247ad657441c2f3ff1320f6136fded46b77771242325e712f7cb747f328fb73eb96a6025fc225a0192cafcb6df344977f161d2f3e4b9c7ccb849edbeb75821458744fdf5c70c698b9341322553ca69f92ca4d4538c42ebc9e8142dfaba505bbb427ae4491a2440ad3dfe8afbc068d736754d9249a3b9c2bcaf168f31bb610f0e42909cb9ebc05db10f5a3002094f0243cea3c1ec5b251d8004d016f1398635049abb38cc7fd9112e6a77c70d66f871ec2b73d9a600f083446e4d15d7fa731c6fa016c72b82b0adf32d41ea87ca1f45f749d2091b0b872a81a78783cbfdf9a6de8bfa374e16b261de8f883b792bd6e25eb4376b608ea4c5728385bdfe336cdec7e5471fe7897fdc50885afa58c41cd6e50bbb10e7aeb25ce2f03b0a466ec3c0b1ff3b78d63362fef890fc49bd5012a415399ca6fb2200b2b31034af5b79502000bb9d87aeef28de329a3b6bb3bc64cf1ecaa9ee7ae16d3dab3d55b1978f082d1ebc01a996cff09696fab2c6f4518ba20f70458523505cbfc754e11dc028ef7f9149ad55337d8f7c7b661f440761bde70f150d870748ae1731a6b08a109dd04cfac664ed82520527c40af15f9471c61e68d34dc603d6a9326774a2180c59930391bf1daabcd85a3fc99b93b692600f56deda4aa9b2dd5f2bb313c88336238ebbc5342416a92cb40930951355f8558d70fc176e4233daf0b39a600039f355bd9731626cb246fa6df184ed92923009a9868b963a5df3a40f736cf02aa2c69f70af87a4091df203a29dba389d14921fe4272bc949a3802176a09bebc89efd4cf281e796ca30c21ab706b7819924978fd9851a523d2e3f9de8e3805386c64b500439784477dcd00dcd7db34a30dc90fc368234ab2e9c03d730993e5797fea417107d331fe56a806436fb93a9c298a93a50fb2db2f25e9778a86fb84eefbd3507fdaf02dc0d07642e8d5c402575fc0f25271d205dc00f396b166d52ef79820da21e610423979d60ff951a3dc710ad294cb7ed179a45dcac416bdeba592d47c2ef6ab526c92de8aa5b56a2fdd2d953c775a6efb00e6f4886611a49ff1be3233e326799c382e39219b860f425ebfe2c8aa4a8a143c6400060993a5bc234d2999fc378d4d951569a77e9cde29a8d502b15b614a1a7a04fcf6e204e2dcf4d6d08b79b984663ab409382dbd0a1af833d514d5bda161fc9421285a86e17874d91e02b57ebd29f887c3ad74ac784f6a449a3688ba210bd38385b4a1e9312d43f3b4f8260552a488d804e36cb53be4fb7718ba4f7cb934d17caf6501969fe38cf1a5db6e54a2cb1d1efdaa623d2f92c8d7b28171538eb0dca508142e85d8bc01b265c327326544adcce5877fc81be3a5f178c5c505a9241f2f5c9de4e84aa07b48a3daf69f73182ddcb40b093b9d25bc9ee2ead63e3901dc3b6d89ed51e19b19e404cc3bc3b1b31872ef42991040e7f66bdd458e46060cd8d3483eb225a93fcaf1eb7a6dbb70f28d58649921168b985f36e8e21319fb0b3f2389d6316fb9426068a901fbd9e79cca1467af279692fdc5683b471e48b16d2b7152445a07e79ec0695f622aa47ccf84cdfa9117cfed2256fde3f5c1ab3d824f2d440d07feb2f04f92c5a10ff5f4e2ce2257b7af15b72842509b6fbd370cbec55d5174f5b6958c44b43a1e626c5d50305bc3fa299818ca888adf812447ffb6d6b29d67383edfae49c93c88ec254ed54c7b8731c2b5b15e0fd94031c33a6e214784e7e78365ae2fb516330187bcc832f47daaec889f70240db31e27e1d336b1654f28412ea54af83d3bab0ebe5be8992b4c66ab8fe381b7933aadb52229951523013e044273ec6940617c23379f158d3eaad966c37c90ce3349098e700d5b72d58002af24e36e4c10ca3c7620427e00252f0e2ff7d46d728e6503f8fd7943699318b4ce0f3f69d5a5af790cb0edea56ccc6477720b133ebabfa21d0f8ceab934a05857af68172e3825939507c6460ae644a82c9cd4abf8f5711f43eab765e13fd12f0cec718f8848b5ee0bd7d18de449ea9035aa271b8c18a6481dcea6b703b7049d2f9c3cb3725fb253e0db83daefb3cb2f60fbbb1e31018e5eccaf81bc1c11490df0772af56a49e3fae7c62bd911b870cbbcc457ba57812c1c46aeb1c0bc8a7c0cc3c31c5e365572bdef993c4f188d084777467c2d3aee259e9ffb11924bfedf153091f04d992113a2e0db986922f1061864145acdca8591de73c816a1ff2811f4c40e76a49cc18ec7b720701037aed77eb6841f2d6f2485eb981fe349133802ead83b40a5a9e8a03a4c06e891d6b9a9a35d5d8edc7515d22f6f3dac5337864e20b66f183a532c8223dc243214503510aac213de7259141250448194ef450ff55b6f021c1601185c2b8e4883326cd58eb50b32c1426fe89fcfa5251135eb2a792aadb013771e131dd1a17e2aa1167692aa359641d2fb33987c3d247420eb9b508409341c4b2b15a9455b6c96a5bfef4bab304977bbe81263d80aba01d676ebfa5a2d47934ee1137592ea7956a2645e2626660d7bcc38bf2d0b4f7623fc6dfb1aee6890177b4833c469938702495df646ace042b0c976ca0132b9dbc27956d4f9d99efa2f2878bf2f5d55131b1fee532f218f8d21d8f4c5249be8bef3d52afd9f95387193e782f613a4e8ace8c33eeaffdb6b37e3b3ff5a2371760c933dc84593b04db7e23192cb4c6f6ced96946e71a3a349db6eea01730baf1d5804b1f694c5debeab0323b4aee07c50f17e5595280432135821060b046250c2ba3abdf1bc685cd69b69660d20eef2e5d6fbfccbe9141e43ac1917b04f2c7eb47f8f5027c11f7db095d6ce80c85517830a339f13e774f5ea3e63f81e292c6db8dfb415f090c9de2e2e561c20626d13551b0179ecf61fb9b06a75b57ef558feca616db58afaf5351f8e15d167f67ca9995d5e3858453ff6d972476e480ef74ab4e087e9dcffa363495963f0650ef9bda786d08ec0e1f24cbb8751c822f683660cec9268604819de206ee7261325e9b915dd2a2907b8e7cbe84bedeb157c84e0c95ac855e8c09192aa52b890b1829bb23799325e069ead5a1997630377999f271b951a3664ebaae4e0c53ae84b4f169d0d4d8517099646d53c27f1abcf1f62d4b1b310c5ea26f50346567aa93652baa981f063921b15435e209851d5e35db39ecef4bad24bbf22aaef4d092ce24f3fa79d8fc39894de651469e3dd2ea156ec220edbba3f235fc794895aba32a29503eb673ca00344faa197d5037aa79c3cbecc6673b798d94979263041de547abb1704c9832795032fda020fd5a0e751c1992fa5171d7822594c362f260f93acb39aacb1061131906e74c1c653a7a2c009adb6b04d2f46d23e5e018ac1c74486793ca35d85d7d348e8daf24be4accc3dd6e17761f39fdaf48edaf23d74a755c7f896019f487466f4072e9ecfdb006aefbe1933de69ee2d87bee7a4df4afc7b1d31cacc8de90362f972d4ec4d47411af288ecc1f85c40da2a23e4cfca7a3fb584d89fc549528f4722746f7654083048eba947b14f7bf4ff0d85b7ba36eed5cd6142d56c205ba01ba3df24a396d81a2a960323ac0b76a49d5a7660c3a53214bf9a86500f88b8e0fa8ff6aa33998f1a1f434fcb17b30dfe32ab9ea8da27cd36a0ca658455da779a74552e71b8ee53d4635063173fa8e3104c9cf55ed2bd57414bac2e7c18eb1f22069c3c1a06b7c2e1ac821c6ae0705bb729418e09a186bd8bcfa6da381ef02d3583eb2dd7296706b82210c5b5a990bded565bddc24b18fbc2af27f95935c6da68826c078489e82e576563b5a27c96f7e4c8459a3ae65cbb282d08c535dff4eb92285d7b638a9a0df3afa174b0c6837b9719754054fddf35a2734b0339c79b25d0b9981b1cbee3fe9bc8dbf67517acbfa376cf9b68b231e3928a031c2c79cb4cb40b48e8b64763b378813f4b7b3c210b296701daa175e15cdac184ab3466699f9cf7d8afa81306fed15bed962f7dcb5737d0bb266e852b05e8ab702df86fefad617450a5473bae9fa3f215d048dd5d6c5e61f166450f98dd3fa0e038ff0a682049702b34e15ec27b17c6d84949739d20435e69c5ec5cbd48c6fed45a0c7794b6d5c1477278c0c52e256f1aa0eed61e66238b2ae2c7837265408a6087482e1c9c3e47f849502701d4be3a43068e434c0f0f7a89b08a5aeab83bd230aab0e971c99706692e1c83a524076405a0889ceb1d88b25590117c01ccda462fcd64371f6ab3786ed01321f7e603010fb427cc2b0d48e22806657485642f8224130501e54823502c67f66c4023fce8f5182b053be85b8ab3380f43635d532a40195683d68eca0564892cf3885b24c8d1ca70fee91b49f2ae00b46b6a832606bc4713d218cac91870e0ef84cf93d6cd6282065089f12fee228b745765f7868af38159709b3141867e58b3b9881dfcfd4b7ca97b1fe07694c344f91f986a6ef828632bec4aa660ec7d11ed62d953acce88664ba550d33ce0b544bf3dae4776431168ad5046349013081483e85d631954e71094cfaf09708e41f9eb86cefd0b7709275b465630faa12d7c41c131cd9acde02125bc1bf66d52b5437948e7fcbf4869174aaf7c10c992f33b057e011d61f51c2827fe7fcd8435d3545720becaea3fdc16e63b5da46159a25c0ea192510545ff80af70edd87b540e4df621204a3529c46f339ae5c60edf1141ba175922a94cd6bbb4556d4e7a3fea4be961819adf83b4d8d8d2c2b744260251b41fc68574e0d7542c51a8008ff917d1b70a2df764f0d26336751edec23575f900f98efa083cb2a8acef17cc0a8583b393aef1337b82e719d39b18559dd06c0a0660f1dad6b11256e05211667fba760bd609e95d8a0552927c6d5d427a9080adcebefbd33026d9910dcc96fbbd3f0225072aa681ce4fe1a81852aa310eefc5b63230b41670dfdf65594ca9cd8881bf99abc6e32e622f2a695f6ca95cda2bfe31a6508c047a33d0bb86165c722b661aa5926848bb1d84806049cffae0d662067087648292b05c894a155215482b9b068c7e029a6eb4772f411e64fecacdd47ac64b9ab5a881f974b341cca5fa18c075cc7db4c806b60fec29d5b6b3881794b0766197e62f74de13d55099b7886c2efeb7a0c2ee0a74d1efaa320fcb9a46eed7ffe637b9fa482599c37f1fcbfa6bcac45a93ea2ff4f7cfaf2685e89d8932ba083249e3eb3229cd9f1f5b442e51025772a2b37fa3def573e3639215ab85242f42fb59f079684b2805aa68e717fafa69c6d688f0b99ff33d9d721ffce67e1f7beccddb5e6ead0675d596eb67687435fcca1d6d33d8ac13d38b13c7aa0e0077d6f9343a83eca3d6c72dd2840a2caf01dab4b7b7b2cadc24335371bce2de223ade0f07658c3d97733d0bbbea2db1ad85af22c9be45462ce5e685581676e8b7f93922bfa5644d63fe8ca6b2dfc6e0aca149f9c2b3718519f114c7284cc12597557366612771c2d69b292f036ae84162b6534418d95131e042e408bb6e9212885dd91a671ba5d59e085d79f67f0624d2783b641aac36d3e8c3c45f78012120125c74d114817c343b28f09d0c889c4cb9dc44ecf627d1680cc6e5fad697b94b3568332b9895b9d941dbd810dcc060d551bbb0f7f0108221051abe93bcadfc7c32afb5a9093064e4500e5ef3cf267226f64dfd9ea107797c0166efb2245895670eef24ec33ff8fb0b27cb4211458a8d8056a8d50169f228edfbcf50a78195f465b717215186189967e6ae9189840a1bdc4feb716e11b8f3a76b47ab0361d2872fd036f915cd632dba547158c2c98cc9fc5382e37d429336572d556e6329e831a56a2c3770e808dd539e761650d9283a0f31865ec1269bedde9b8db569496dc0dad2f272802ccf2fb54da3a9ae1f80509cbc7bec2f19d17bbe25ca0a78525568ae6ecd114fe1aef80635c503237e1f3531727294b8d489c14f46f7e99ff31aeb8feba4ebdfa90c0f399e36fc04cb6552247012e98e878b7bfd3ea54bff527ab52913ebc903a48232a2a6326e64b57180214789ca45935216383ecb24b81c6f1e9d8760154d7a47ce845094da2dda35d3972a0b427bca6050ee4e8e10f14dece3815cc621060d78894942dbf77e996f9f271028c6b6847e07daa0b13490a0540a666c358cae4a5af8a6d7ca7982d06ff54085418da944c63caa6fa9046936b17de50e89bfac53c0a5fd2243d3e58d1d007b55573717b84f7e2576c76d903dc531431ce07d5223045700dc4315cc42a62d5267a3f6b2f4f92279c3a41a5f9e3a483978d2b345e1888a8a024ef3ecb17da84939502705891e58547c11a184d4248e879fe005100d3b0eb53a1f87c67d43adf0accc2e32b372089b4f6d672f60050ae28df97701f8b3223c0b562a0aeed17e28d073bdfc9ff03d5d21cc3090ad00c9976c54b23e41050407cba93fbd3d18b227a08b1611cf12c5540477f9a4a0a2f0bca431fc53f79d6b8b306f9426f7d89067bdf7523ff288809d8397f7d5de56eb52b898fc1b08468a5681a00c408be3828cfc009f832b45a6489c62a5bc95228b12637ded8f971f32ebcacfed94f2e81ab0ce0d99534509708d75cf316d714dff4577333bac4d49fe1509705dbeea5ea75edcac66c4f765bfe111ca672c734c3a7e63613b7852300488d7eb6efcae1942c8974d0b78195aea8808bc983f07720104c98a0cb46d8e0c94ac773baf152014e588b75d43c5f1ae1cdc0eba8ff06e4866a48a752d833e8df58f497cd8fc2811f298a893d9f3a9e584137ddf08d909de4d53fb2fb0d52bff92d6b29c80b9024a7a3446186afd8ea1f455d618d15fd33d5f3ebbe5b72d9222076fa50fe00ab707673159ecf879fec693b3229663a281230f88628356cee1a33d853d05b81d739e8846cef0da9d3cd2114b52edb92261e06d818f2dec5f0c31e67c9ef182661a49dc135a15cbc567fb68d084e89e71f12904683aff398e50424a1bcaf3b061ee331b9592edcb64dcc9635bf1de7c17e19151103116cd6c6d54e0ccc1e21b43c0a43a9070529a805e033458b8e23fe9b5d96e5aa44a88a5249a2a60fd2340d09b22485836e2ce083ba48b3fba76a6e566f310bb0dae6c2780230c1ca0d58ef4832e47dbfa777fe69501d64234b894b4ec3ff0bf0c6ab1c2cc76dabfeb4cd10658ec168474492b34589440a8e73eb7bd94de7012ffc79626318b52c6e6d79762cda3d8baed4071caa564e96071ba1c8830532dc96806b41d316ad196c054312005fa24b4c7a5d4b797344a4399c96db2210f8382236a3a57cc23eb96dc4f9a7644a1bfdd6a390c30dc9d5e8951105b3186c83a6bbb86fd1f20a69332d10277669ced30121eb9d7e8ec67fc91408a7b598f74499373185d96c4470a94f2df1adfedbe3dc1f3ffbeeab624ab7481dbb856e5fe7d7eec71c3d2428004b6f28cd259de0a19ceb893e1553320d1666502c08dda24c6902588f0aa5e67e0a003051e5e54187c3bfca004604db0a33afd89304dcf639f03541a0e895dada83002887ce9e5b53d5d2cbcb0143e7e54bd1ed83d550d2e46da870521ab308aa927af170794223f83991a0e51fd58c4cb90d71d6912ad132eab1033103909f125c6f8d158e51a12225a65d2975ba8f285b3feb4d8069ffa52394f390ab6f3f897a976cb3a001d804faa9fc5805983da46be92966a33d67b08cc2c6a9ced63243d117a7ef93633841b6f2a2a94a28c2e8e27d7bdf3d9ae887852d8ce95e728b52970c54df2be073e98647720ee435a1e4520828240939aa3ec88536a94d7c410627982b3fd8835a86ee4485207378e1baef19c941420c65798b49428654ffe2d61f58dc8f0f04c65e6674dce79d877d53839bac3429953631d5d1c5b2b27a7f9a8035f017c1736c792aaa6b9188c3af73e616b6eee3d06bdf91a77897b66214466458505e3a37a71dfd09433e84669365127ac64c20fbb65c3cfca540c066d2e45fbb1301b7e50c021289566a4e0fbe451fa446e95bd04734b7c59fcad50d9b8aea73cc6737ca24d107e856ec115c7d7626cd735f495dd8368231b1fecb949a90f3f95ab4213ee7fffd90d04aaf2964a9c394a9cf41810676d97d7ef0722b4da3ae72d4ce19dda27d1655755e6cf6040fdeb8d62c0dfb19fbfb20f323090f5858c478412a3ccbb6b22c692a876cb3f3755259b0522d761c5ba9296e047614479847129f25f874b504452aedc363bb0f5e99f8dda894721138ec1ec664e8d6616a4f01dad55cc554d327af12f1076045b007de61908bacc90c76682dc45bae9678d340120f3a225ab2f993ddd8add16fcd1c2720b6775fb9d2b6c9688e6317a4017f7e4062c5880b34b499977a0139f7df7f86be8d61b9020916ffdce192e95e76799f06c7714e80ef40fe3fb5a90cdb253cc21c9439e3c6449a0afbcb0f7db3eb0bc0ecdf33d6e9f35af28c092d76c3aab89062e0235996c0629a06ea9a0d68fd1bfa5fdd1bb30c645cf253fb6652ea6a6af4d63b0af00125305b992342718e467689bcba9909b3b0b7bb4635bd0984b79c2970ba58474cf7c41415be0036ae44015e0e7e71dec09dff9d4c35bb2b6ab650704b79e7f236e349a620984f988161d2cf6e02b82bcd3f1b2dd3f15a223b951a8305c758d154e82efcd37820e7034884fe9466da75a8c6f4d06bf833184150a08eb36b5a0fe890e43503925698a9739a41643af4506f1944712fad87bb0a32ba2b79c86bdb635d3eaa8c3f778a7886b2e56c027b7fbd49059a32207507be6db54ded717c123f517a653e8cbd30b23383ce678e3fd66ff5998346c7930df57715dd507263653581ad520a09bb2ec84ff684e5048521e580a13ac473e7216ab47f88988befa2e6ee7fc8c63fa12a1569de7471a5e928da7336623ecb9e4c9946e45a91853bd5e5376af1517a5bf1ad49760f100977ee075dcdb7b1e5a5626dfc191f59bb3c6eb4da62882cdc43e92edeb97e113f176414e31c9cc42c4d76de4ee93933d06959de498464072098391ebe0e2af55bad6d7c7d8242b21d055f30e5965586d4678682837ab48302d4e4e03532c8f67b4b2c18d0ff244a18443c64a5e7967b83daaff75cc490fdfb036ca46b9274259f7b3290a74fe98222b60c62d961c147267ccbef04aede210365c3b8d45706e49046a7c14d115bd88847622bf4162f1ea34fd12b46180bbd9ccd9e02025d942bf408011d8461f2827b5fbbd2269c9b14702b8a57a484f40fd7aa2f689db926d67aed2766963de4da8c840c474b611b27288bd49b25d8cb217676290ff824052ecbd83f354d73976662e25bb6ab83baa4c8a02dfbf6ef944b534287f79955942bbb9f3c2a8b3fbcf055904abe4f766284263ffb0e45e741b32d0e4046f5ae6b9069c4051f312011c9de70138f3401f2af5ec217cf5378179ca9520aed670fdfa8b25e25cf02a1313fbe6b683fc4f2343801ac5ccc24c5a4e9cb636a975edad3989d564315ea24344b528871e41dcb77c37f6cdcfda1eb669c52c86b4e1cc60595f2908924cb90d5eb3cbb7c2ac523bd346977a485536729a69f5ed15741170907012906a06c928b4a5a3f135c288bde11f3e3889681d5a7f4c11cccbb3e57af4e31e40094c7744e4057665084f472d84e86b3458257bdd9dd7981df49302e40b8270c2623a63568dfc49d23c5a57018e8fb67c49ab8b9f5a967ca133943696187b5b7e946cc55ebb9c2f229773689c0c494ecfad47e61be779128fcb6f93ef07fb326a9be45dd2b4d797e34f59de1d0e6e776d9313bd4ac0493cf21f199b346220b2886a94563ee93584257829488d552e33be3a8be8de97dc1c86ce3f9f4ad8bd7e014a04d821a1be0fa32d7d17403f6df7559476d2f7bef8f1c5c7f9225f7f752099ee49783c1733eb312dda9e9c1b99dc2f3f4e156252df26a2307bdec5467efa9faa3e4c68e619fedc3cf705d6ae6da037f858cd5388793e931aa51b16c6f5d1d7dd6eaa224421c9ddf41ee70ca6b8dd3374f6f40b4f5f2f80eb2ae671748b70daa801a1572cd1f739c3579643e5ae2b9a4d9306cd11e2cb442469cc4cb96b4d4cd01d9ab0c5d257284b9a58585e88dfd2f6f747536854441d335f3a0057c187ca72c5467ee0fb38173569bde4a8fba6dca8565fc1a0d08a3db38e01947c97b0a35c201d25382f79f31626c32074b892d67e829aa335536ac81fd82216f3fa58532beb98546ab716ab429cfa0fd500dbc5d3a43b3b4b6d12d101dc18174fe7138d1e77a5d05a23ffdb2d73d551d04f5558d97a9788ae2eedc1ec374a95c2c4b5f84d22bb3e7572301048f944ed274a0b7b832af525ae5acd80d9c4d7c7620f72e43eee3212e70955245382a3cb3f9bea72f877d019405a23f362d7a713a0da695f0cf71eaece15853e29aa67ca0a2e5c740b8172feca333885766bd67d41847863c2b89abd0fbab5e31100f6fff886301359880f2746ef897a197d6889760514b65fc3b14161ba510864fdc25130cb269bb9b67acb94c68c7f0fe5b1cb813b9751e1bdde462444614dd6e25d0d2b82c072bb5fe3e9130dbf6f9f596d82b2769112dd6bd4ef520fd56f120c15e2a82e1a9815fa701687842ad9cd7dcc13b067eea2e326e054daf21701a89140e1ed959f45140d3227a21caa1db6ebf5e0c695ea9e2541ca3ff8f78736aeae42ed481ff356509e52b750af9ab72c2956e41f22481958dc4b98f13eb5312e418f14eb07e0350e262352e2b49e816c20d75df6ae3de966d767749987c864b91100c08e7b38270540232b95014dc7cece43d4fa55cc6a38e46b06d99da6820f6c1cff2d033b06193dbfd4e077472968c1d5b2baffd4ca940d6e63c807b43a568966db93d739279e11865e231415e90c0caed9bc41bce9ad169e96e740e156406831fd432a49eb9a016713cc0d6da5740b8fb6ef426535ad41c4fc5614bfba7729b3d9bbfb55b441f1181311d6be2e476a7fd0c158567d920e4da19605ab0fb83640587a12aa17f9ccdd519f2d202c99e07e42c587d8abc40e575ec11e8c0703e432ca36abe187ab7ca16cf49e60f1afab3fb530c51e4d294cf5a56debf52846bc469215e05f071add42a8e6023b48205726268399f054d456fe5c826f1d9910192b8d95eea1638109c5a6bf3648c9b1189e077a50f6132e93dbede27dafe6484322819db8f9f68744b80e52a523b74926f0d113f6786bea4628d852d470dd26a69434abaf5c7321a73bb596bdb6ba38f268a09815a10de0ba9edc7815cf16513de6498678b9803ca2cd3556e8c5ed8bd9e02a0bdbe55578f6efcc8935f0407927e6567db1a012456b4a3213f80a6b585ec79ae12d65e74c57eb54b7a1fb8fbed6b5673d9da7ede39d82da8ea65fb2a3ad6ba47118dff9ba0d3d59a86354ee3c62306bb21efe2bad15cb2d8ed28f8424868edf90e2342951a74c5e696648b0d9eee0258b819b6b56da35b2b258e6e5279ed62652af8d05252f107dc3d56a125b74161a7b8eedbc96927baaded4f3e57f9c1e4d781c86143be73dd2df2f988d1afe789d093b8bcdeacc91eb8b33026f1086ad18110320944617965bf87aadd69811c777cc82853c7965882d060ae2eb34ea9eaf7f99abbfea71ffad3fc8e0c739d8ff2e01b5fdfdd77bcbc427274c0cb1c4f6f8a5a871dc2b3d7c97837c8857f1a8c0db6be46272763dd137715c898266ba7fef3d5c821eb2be73e63dbe2700eabb3d35c49ff9d2f10135fee67fe0b60b9aad8001aec0f0ca6d0a211fad916b91c0258797fac410f954d3065c5b84f7e382038375f49d68c97726083c4e12223c805ae30fd756077f8cc19aea436e74d2514f66b1126cf2f986e2bd837b9c38e00ecc42afe2d807e2cb39bfdbaa09c6880299420caed06831d54167e2aa602a41947984fc68a4597829e30ceb78c53259e144f0fd8ab6e215ddd1cd6f0b938b958c53623d48bfdee946474bd9c736b46aabdfeb89be4a06616aa7ce51af972ac07055cdbcd83f53ca18af6191eaead898a4b8bd98e604e2488fb22681af122dcfe6f22148de46c340be7c11e21a755a961703439397d6c4e6e5f7b26f73780ae881523acef2ae2787ddb36877747ebf31ad0cd592913f0d06b0a60791d3e8fef5f0240b525bc85aeba37e750e6b75e5ae028144f06b60c352a91b98db284c0b8dc55ad5e9199891393938c0dc0869d164fb6c196c0e48be01f7166eb3270186522fcde0c11bf88b041640e7b6d08cf9cefc8d3f7da5987a3684586a3032f2d9d5c4a447caa52fff0ea3b9c16f214bf31e48b01b18737a4f5c6cbcbde37f94377ea349a5f65bcb6f17a72bbc30f6372ab98aee793452c75f4aab2d2bab0b032df04ff4eee40338af7d097c42b20031cb20dcd514561d3c4bf39ceed8df6c1dc93c690dcc663ce02a1f48ed7aea4fe9707f50244e16f219f736a360df887286fb11a601b541a2eed2ce89f18807010e150dc4787ae1a38ef2e3ecf224f9e1272a8a6bbc99bd188ed0b7b336c99cc26193ac6ffe496a6ca858f22240087c40ff5366b265fdfaf7864919a3d7ad34f7bff6b760609da1400b108e944ee2e3f87d24251033fe7ad39f7d32ddb7253a93710958431306894f2e4b464242bcdce8810b54aa9ec6870265da76dd841c5210158fb69cbf7ad6c00c4548afbaec31935fdd382eec3b6e09d54a64badc1655c03cace6d93a253c8dec9ca7b02ca2201e296f84884ef4b82a81005446bec2e8885081ca2033c71d92b7e66590ab149d89acb5c49bd7e2018cc9fa7b1579d0e939dfbc9dd39fa0611ab2a9f9a5343ac695464b8cf042ea8bb72c6422ab79f6a2a7e1247d7cdd633aa9e8a7406815263613c4591ed9a5b306ed27bdb8ccac57f6abd5e1e303f930f49ec8788d8a7f326a26c73f1dd88f7b9ded15978889230d85a001614faeadb18d50773ddf78c18a259ed882e8eb923497c78a222f343abf0fce8d4f105da3fc1706afd7770b751bd46972894da9e45a85479d69b626c8c6ee500906b8eca7766e165343fa3d861225657056c14d66e85541d74934441f2496ab94bfc6968421e5ab0e1561fbfca8aec22d3db4c7aebe0d5dada1e267b7d481d8c5d9e6dc21fdf75a9078217a5c78d73448375f78025985759866f9140d88fc7710a5896fc82d166ee2c85ddc7b268aef9d0ec6d05120ab2db8f361c498a2526ef0c35986bffa2b1e64bd3ca479fc4ea4a3d8cf684b9d62dc0ec76b8fcd972bcfcbc12af3be857557aa3ae715a3420ca63d7544d84abc332bbd8cde6be6804bbd4ef383a230d574b9137604e1e290fb3a0804f0ba6957fd5488cc6e5d6b522c64fea686abb328549b1b26096fae14b10d85fc817c70ab91f2e42dcf8a997b2978e9c40b24c3442c3605a6afae44e10ce5eda6b790b5a976635b81157a6bcc05b4fb2cddafb59b9beb67a6f5d0c308aeab361327da3dff9a4b2ac54fb62be0a4dfaf00f30ea8da73a6ff48cad974f11937bae361252e53f96ed8b8c9467ed358c9324db284b88830bfe2f9cc4bae94d8f2a953bf84b06581014483cf087bd099a2bcf1b3c06461c27b5da10aa7e25b22d94beb3283c30692a0ba28e44d077c7fced521df15aa269f792d291fea7617ec84bb878ce5429dc332fc8a14511d0adaf1867f577b2aa3ec5aea5f16309531fe171d70d8f0598b1292ff0cb38bba460ea057d1de04c877915b5453e6f863219bcbcdece3da440e42cdf1e166781949cca8ac38631720878cf83c0fa86fc0dbb248844420e814a38373125c6e8bb68724d438eca4f719d662b1e00122d4f98c0f7bb95396cbfae7e31095019e45a7ca2a7d034b506083a0d653f4a6a6b84c0a6f921348d918214887aacb495b5ba84a8cf27b1554acde626701c329ee637b5edd92d2cf941b8ef56ec30b73ad59d90f0e8dd7a1e816240cf91fcbe57f2fcb51b434de751454ef5b823299f2af47cafbd8637754cf11dc69eba28334a0a256850077437ad06f64125e399857e55a94a0e1503924bbc69eca85b8083413173c38b2e5c83141511efa5f3b7710cc87b3af20e6f49a343d725679ea4699cf3ad537d4b9d6f70b16f28de6bbb82a87a4c9757b487d7569632ac996f22da192928c3f79ad03fd98a6ab18543d511f4725882cbeb3f35416df9edc3c0c2c67579fe71287891828a219e5f52bfc00e56dd9603b956f749dbde00394e95f6ba91acc71bb446e0c17cac1df0df54eab5e687e1a6a2242d2d25fa46b729066088356f595943c015c940333d2bd071ce33770114c3ac6f8c46a366ad9c0d6aee5af2d8dd205324ba34cb24b4d350e3ed125beb0aa4de2847b53dec7f91353bcbb62140795bc4c72d4a8dffa14459afe9ff83e0bce0d567534d23b131d3bbb5abc215ed4eae016614709379db40a61d869690c43ff267c0ef1855e3a78563eaceee619e660de8569758b798b63b35c866024f8626ce3094ac80f7739eb6686905e40437882705c6fba2f3e71e9c545ad2cbdbaa67905a118ebefb5f5710dc5008305c2734102ac1f59fd6f77a1c9b1c02c135f442bb30e58bf016a0a75474cf32d4e7bf0e93127259de54f5337c74746bc70c0775dc8a00b0f75e48dd26c17862a9294f60859b4da8d946d33a7298ec56808f701d3b74e6b0bde1a98f460058d45ca8bde5c5b5373d0cbeafbcc62211bc9727f8e9b5d00ce534bbbb91edd4b90ca873ef2d01070cd8f4a8e11a4022cc56c8d2bcc1619c75289287e7f88f0b5e75cb684c673cfb39ca100e978261d68d7b7586d2f31d475ee7b3e7c35cd77cba8f36238732b361c3d4c21996e22c5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
