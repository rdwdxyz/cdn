<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"31f2e6496140352403f1a14874971920c53e3c8906e4944a74e8ef99bf294982ed985318a2bb3163ff69a7650111607bc996c749e180163a488397b42e1ceb20aa2dc6294e04db0541c56846f8b346b63fc9abfb7bc33f64cb68bd92813ae3f7be7f835e721c4243e41e0dff38d28af7fa07ecbaa571dc95e09d78e29b60fad7d0bfcb727a50a16cd2efd261cf88ad0eee614e8b19e9552d56eca5fb84cb0042ab41d615c83ca58be04b93b0a9bfe7038edbe25561ed5f2b13a2393e0eaf066603e55b4c97c9e31e1743fdf4ff9f8f7092ec9133a85d04ff375d96797287cbe37174e3b098ea153ebc498dfbcae78fd4a6b797c03cc8edec58d04f6d13066a4be3014d9bf775b8312fc50ee2953d98990e4d04d6ff6c7f20591d656aedffc96042246904d866069a191301140d15fac6656d91ff1b18defdab22e3af74f327f01947d9e7c55127443abc1062cca07ba1cbfbe30cb31577bc62df0108427f91496f80eec5f4b5448f4fa8cc399da7e151725b55567347553b371b76d0087796ec436ba68a3316a21b374b6188a0d7731ac249e51340e7aa9de42e40fa2e8474168bdd94c6c295a792128840fdba9205ee8b0d5aa9fd3fa1333798b9843bb29af2e155258d79c2267533171d5102cf4b8ca4fce913afce593a874cb49291188eb13691ab19e9efccb6f90ad493d1bbd04d277d5462de3436f3ea8893ffd3fbb025359425adf6c3bf31030f54a706f27d30591b5fe2f32ea52faf398152426e53e2da3af21dffc77207ed8a8d5b59ef93dff50e22313f7a16247a3f76e90a84fb5346ea800d45c86c9d771eb180c7b5b8bff254d153030223068fca467f6ed45813df921e48d42d872b4f667ab85fa6827d53a90031d5f5f01babb06d73be19a20b0424f0ee77899aca61a31ce4e42a74c9c68f3e1d42861d1bcf6250ce672d438545ff9de0aa8eebbd4558849612ac939b0dfe4f15f046da55929327821359a6efcf92693ef5a4543680f17a28e87a210606e15627967bed41eab22d4749d9a8bdf21fa4ca02b7c64609beebe1d4fe56adb76c8ebedcf02682904a00d68315c05429f6894dcc2703e836c13418b2a56bf39c3ec3f7698f2f3d7299d71368d18d9797cdfa4508c277d6e615c437702cda6c7cac686d3730ba00072cee3ca25ef66e6b38578117c9458a8d78bf6953ac28e27c53f994117c6d171c1f63c1777f739335e106c7f008c36be4ec473a7fe0ea85852b92419ee6defba2e901be520ac84ad97922e909ed62bf0ae8d7ff5443abc81bde787e98ea5c22697202805f2a7fbb2b8f4e4b44bdecc632c71e97cf8b20e08062bbb2b12308a7d81c3ce7045772ec84c3b1a9a8f143b1fabf95dcba3bb8b08734e3d4b8ccf8b00269e2d9793dff8a95724e4e266f623282fc634a7bf87e5700446696f178e866ed2ec6777a6841cd374eab238ae06315f2a6263a4652c3e720034725219290ebffcf48d00278838d558e8be53f815fbc9574f446f859c855afffe7d1074a0bd76f634ae4fa092272b71a29ee5ce208f8d87640f8d14d8c42ede774fd587f3629043238502cff5dddc99d50f0614e6df0fb1f6f3c5e3a70789be17cf5a2869c89006147e111262b8feda9302ecfde3b2f239e91843fbae080d7ef9e4675fa08d660cb25ce3b21636274d251f2834911edd748b45ff8a35022109c67476993d043187eaf6a83fb9d4cf7abdbd3f7e9b4cf5236c29903183ba0e97e912dd74e21de4d8c47aaa297a038e32068ccc72dde54b462a30d62937ad181b8065afb368a057ad729df39db5496c014ae7db4ecc4ec290f848ef30d3f63989a9fd2370bdf84c404da7996f6bc6fdee3632af3cbeab4ba8865b09f0ed55ce49d809efd0ae53f5a464a528c7e8238bcdbee201e837fa0b4bd2a3bf7b7de540b2447befc045b0c5f6caca0bfcb28d64c6a550adf8d021b705c07f98d5905752ad96311e505187e3741c75667531fe0b6a46e72a91447fd2591e563a2e5ae9ead5a253570e9a3c5b2767d76b19ad86defe6d406742184fadb670c9de35519833b7b0e0fd7327db72d1bde3ddd58a40eec8a3dc33eeb1ef0ac322e78e26baf174e3f6ccc703bdcdf2da4d1ee1188172ce3de885245ecde37d8f5a733599d78ffb9f11b146f504b224e626cad5c0694d9a66e55b7d7e9c667d5a971bdece56827c63938522b530ed9f2170d0dea103ff2012b61bbfbf504c686ba19dcc71258ffed730e9aff9f7a0933a93089aa2bcfd4f4144735de3209df98965ce95bf0b8a04abb5d88574ee78cdfaac0bde42864b74f02e9bbbe1c48cc9cf3148cdca915061a11b3971c287f4bc96f3c64c337162fd030a8691cd8d895993063a778b50e72ec1c6aa46a016d0d375fbe8edf63473219ea6b0b0244a42fa528368dc61d413114810d292d0db9efa84951f7a87f0bb199506ece916b301462612bb0c0650903f3724e3b75dfd76763c243ed5576fa1dff4afd1a4ee987434002ba9c7b6736453502c0f532c93640b2092cdb8960881c66b833f144c793ebc20a379f9242b8e2898988ed97681b1a5522ea7f1048c0317ceec52f170876a87ea40a66f3b995fdc28856ddd401c6681190915ed4480b47e4aad1145e15abd5c9e0ff8dbc1a1bd4021dd53107c8a59412fe58ec0cfbb0d2460a4de1d1b6548dd1e9f5e0e17b3c53449b81a26297afbe8897cdfe7119eadf5415934d07783d12ad755a9d4ece1c8a99268d00402dcbb6d6ebe592aa37a894786f5c9dfc5b034e05a1427d2c4630afa5fd7d9fc461e173d6b211697e1ede117a6b63e2669a8845f62fb551ad1602f93fa6759d509bf95927c4b3abbefc898d72d98a910854ae5ed4ef144acfb217f295aff17bdf8b670c41721094460502b5f715abeee531579739bd284421204ca89b9af96079b966deb1243c57327936643d59cdc28f556dfddbb17836d7fc2b8522e2cdb91c1f7b60759be698ba3edf3260219184ad95220a5da18c714284e42aa9c701fa0dd0d884b2bfb435c386ac7566b02863d2cf8a702538ac3d86e74f947127ba26f71fb0ba1bbf5f3fdb04fdb92209be0a84794ca670a434b0078572cd871af0624990e67c91aadb8bae8aff7d0ac74e9fe5901b9b4f1f70dfbe3882b04366ed1f0e428213f0015dcdc78a6b7a4be5f30df77c457d376cbebe51b1782f8e76878aca231a19cd3e42c352226b623f90aa8b4bfcf6de8191523c17b3218e30768b3d7b54ab37135f71b10d0d48730141674dcb78c4df98f8fbb063e15dcbec6932a13fcc4fa35e9f4f8e08eccf14968281b4c71c49bf8dc2f8d6f09e797e9fd3af0de1f0157e657be3d43a815bd2fc12652e6bc8833f8a55b91126ef98a745ac296612dac136fd8ceab042c392380a3a3f452daefa700dcb343b0eff361c36ee1e46440e379eeac31e7b89145d77b408113afead8a14feeb796154ddf766cec535b4d112488644cb69c247910abe4df760322e5a86b33a0c1e07a55d91a66a7d3cc93ab0a6bce22a0a019ee7181fc795e8a1860d7261d841a197973ae7187bce82ef09ba8bb69fc8eeba6e19a07270ab065bbbb3a53856f92f23c18a69307f41790aac157a3658d078ee4ea4f55326a70e8443b0aca4160f3e9cce091994f810e5782d27e073c31179ab02d5fda9c453b093daffc61bc18d4c3618626028599cba8bfeec40b6b2dab2c588c9cde3e62a4ed3367f30d86db6e44b3ea6835064ce32e06ee10c1f990916569ab42fc4c30664d8cf52fb206487373d874c38a8c5b0fa981d92306389f2d7cfed0a1154f78dd21c07e75c1245fac847fd9b5d5d0ad053da7d0d5312c815497cb98acbc1791d036a10272dae947354c208f58d3a3577cd4a6d4643a1667c29fd9e65584ca53528759fb0ec64271f3891b4e4728ec24987483e4bf758205a0b7be66a84e24e43c50bbbced8b0cc596711bb2741f1e73ab2fa70a28c19dfc014736c1816170d13ca761dcaa6b6233aa08eed44f0781ed27f1d531ed1463fdb5c88f11f609090e3dd09cb0877ae8b6cf1bb44b4078568f9bee1f3a9ee99b1e480e5c3a6fe5eaa496cbfbd8df3513cde0e9b2bc7e04d0fa84968209e80b2fd9cc2ef14b44d24c8ccd161d916f3d5650049d5c51eaf77485d3d1e8eebf3e7e5dfb64fe47f97c86f939776286daa2fae156437661a2661468780f16a628b40a3e2b259694e4288b057d16a2d63f4dc41d553cd159584a7f99fcd63fda75b3bb7dbf2863f663f9e0a8879e3dffb69c419050bd2039062f307bcea38cbdf89fd2b26eb65210b0e801416d3677e6f14873b219bcb06fa02da66ec58aeed35417ffc6330be836d4fbbaa95888327859814a21693ad40fcc7b03e3747dee3278cd5a2368d686bf4a12f4ebb26a4927e798b78a2b7a04f5ba47fda4df0bf6b689a3ddd0696bf925f907238118f37f84824695ef014bf8f83009eed8eb1ade366be917c01a640034c7be083a244aba504e7ded91acc7ee40f4620cbf20d4bffec225b5b50973555ec3951da40f9474a819146e60db22dca310308b5ef00ca57c724abfda83e31a7d87edf3c1b7dfa358f001bf6a5e9860f7f2d22c4dde556ff14c749379b1b508b364f17ad042c2191bf6d74e3e7e4c0f242edbc736fd37bea4acb59c2b81ac0157f1a7502650d55d98621227cf732f73caaa3390e72c957e6a9b3692b054a6c7910e8535e8a4552a9106a7ecdd77e6287b4ba39bd2d1b14ae916ae8c0e97492e305278eea4dd320402ee218345043b5d16d7370da2e58685292aa45cb900c9092fd48ab0e23db953ff804a59c80db18da697b62290c8c03172adc0292e99a0f6d0e1f2cd8cf5a76fb18f727a0c61ede800e721213ba7a5267fce6c61651cc65c7d1f5d6a8386b6533c7d225d5abd6b52f3f14d53ccab535c3830a977d88506aa117bd55486f9996cf93aadcf464289adf6ae4d9e5a14f61c163eb429c3e5ec97048b84fd79a4a1384e09210f85b4d225c1e19490dd98b525937db60e6bc49dc08a8e1944556ee94af34ceb71cad5bbc981ea2e7c89a93bc7b9c9b4a48ace32b0fbf0ee6c40365b52c5d416facc3196721518cad673d5f53872a3d3fc2c198bf319f2126f7e345dc24f3b9b47e90f9cb9bbffb8f4dd175a53af7f6e119ff5829e6078c9c4d0a4c960d3063a1fe53e6dfb9b251d1a8b7f3dee4846fd507c7d27c341c0538da2ae930303a745f0d13ae3d208fd76e3607af673cb371d1d112d3cd3cc013de9dab16866ba01e16d7b3625045e6234a65ad6e3fee8999ad758d636133c6f48512b7296b8240574a295439f45aec79d8480f226a28c3636d02f97fc2ed6cbd85b7433312d93935ab434bd1ac43bf41d6c2a9ad1ac5d5137c7a9eb111e1d33019dccd13ef7695285222454df8466e9102d4a9871e6e5c222d3ee9a9a2c187224e04c27d5c461957e5a2a595cbcf2ac7835ed98356b7282140a999d706438128c0c49ec710e831a440521598d280d4e435b96b90d3e7e6ee1c9d46c3753526fbb3d14ef0d910973e75f7bd100ffd9f0495b6ad17fde4e1b4416e9fcc0efb50bb9927a22b617b725973af0410a4530bcea780caf74c6c8757cbd0671e2e099a00fc4cf381cf9d065a62f9be0968af380eadeea711f5074f2d369867a543fa927d4ad15dff665fc5d387816350e92a865df8f901e3cf53bcb47b7fe00e356c27fbed6fd609191ea53cbd2585f8d94b92270ad506d89933e2b56e38403eee793e0075b79e9eb0a8865354f09a319694ab8ee5e358b6612b9ffa8d560735db05ac394522d07bdc4fb66ffae6257a72e428484acfaa55d80cd82ddd1269bcf69061eb2f68b7a50025433c94001811459ffb8ba8b6be939683664854439cc9b3e989abb7382e5f5d56be5612b7879105b255c64ce0b240e21243db7e8594aff298b14a53d4e98f5f154b993ee8e533f3b747b784b3628f81b383cfe1a05204a529c12f476c9bf303c5318f6884dd42fee54a66505ed9e4191045c061443fcc3d9c272718e7f233442fc78f127b3f4533dd9814b9a528e8cbf2410c03bee714f4f3b2bfa33c9036aed38cf20af42807230461a119037a1e7b69c7138b30dc1b9b249566fed33503d91f12786b2e01e80c1c9a942dd9c4200ecfb99fecbfb5821f38829da22a5b3e6db0cc068140b70dcfe91bc2f8cf460508b8a5f4eedd4b809fe37e7429ddfff837050b350099a0c247ae440aa6911cb0d8e40566e95717c2582e377188c721fa4f7c813e9735b71c0066ed6a4c68595ee4350d6409c10c8899469eedf5d7376f6ce3a622fce41d0eff212b8d7b33b9a3171dbb29f44be1a9cfe39b56b221283e998e53b6c842d930108e4a0f9d9a23ef80d20c3a91c293ad418e47485ca842bf77c834fb15864e5ced85584e818b392e3c68f1ebfbd09c721cf5df60c8eef7233f1102590d550d3d8600f15dee4bd65c5dd3949329f6b3b140740b386824b2d748c5a881287db029db74c2470a8a509d9f2cf64eb0ce665b50a32ab26d671487380205e7b2c1d27f980c66a893625cd0469ca02e866784e05e91ed88ed219ae7d52d05b7ca0bae98877f356516b1fe6b0b7f6deeaa6fad100abd030d397fc9c66e6c8296d33783b04b1e976c69a9f554bda24a6525b94af19b263c557c131cb75a1e32a5b610a5462cc0c0ba859f227c7a2381740eaf18578c252f73f9c5ce52a56ed2c0c2a6f05ed1d4714b44c0b53b8e064fdfc053d8ab8f6be71b64947043fd4a873f847fa191dccedf9cdd56cb7dee74574ef9b1f5d08ec9dc3d559eb911be749a1a6dc5c50fe9c20ad181deab65f07323e4e105979e56b0d0478891bdb51d78b15e51f03e922db8f63a3e489563275333e9946a809c3321c7d19ca4f965aaac6fbdb7681304bc1b8cdc645f3de7ebc9a09541f80cd598e5ca976e1b9f6f1ac3c29c2f5697575c56eda8554903863d78b0e5e7ca00ac69d276114db8ec47e8efcfccf44a40ebba959041de96786198de2494dada7170b3f7ed4e2eff436950f273a66bd5cb983048026cbfaea3beacaf682fc8b89fea3a9fd5ae9f61ef39c45baba5f3d39e090e01fff27809080fd89defe7ff01ec312d71d6469344ab8b2b0f9ea9976317bf326ecf31005e25eee0cc053190613c5e5ea777e0705df5825907f6e59711f939ca5ca6083b4a9d0a9c8e7e9bff68d4085d30e828cf0fdb650060ec55239a96f57129d3036f1400ea4beb1752756fbe3ed66bbb7684a86b055e0f3dcd2eb087bf4bca5170ab0a45b4d34feb88053fde7d39dd1c002278ff490230199398a3c8ef3160f2b2e2ae3591cff93908886b30a19fd4837d108fa707f96074709504c1a58e83d256c79a6a45f43fe20ca27962aa0bbf6bd7c2caa4efb85dce7231bb7da5fe0edf420f5798b6eb60522d862a0664aad9eab6314f15c49fa616279e0d5cd6c785cde593eaebd1cd054dc38f64e3f261c1116df7790e98b703e40405bdf27ebb1d48b89420c8c36647b178a53f58aa938c4ef1a7845104b9c6bc801e678f8db94999958214506f3b632d8355df64f65fd15279df7e9f2f8166a4c67ca4c867b687deb8e8fe47882b024f0d0fd54fea0f173be6c5f5e06e76a2f3363ce54c4bbfb46f7e8c9848143ac4f8b838e2e9eba290aabcf8d6ac47e734b6cba1d955fd60dca66886f18d772d1fb410c543673f210032e31e2df33031c6ade56eedaaffd7de1e57ef727f61ccd1ebb3d2e167e2bbbfb5611eb262510e9a700c1dbff1f5fb48b3113d2650a86577a134a12253086d3d1ac286c85a3fed009a5e5a6b2e56b8c47417a0888d7bcb14116b8697c9c10bb36f8be628693d94283d6260e7ea91531c2d3e984982647d72f20dc162b3a64566b65b525b4ae4a9015e617f2f20ff6163b9619d474300b0ef1e0c388287685dbd2f9f025b9b171313ffc05ff132d4f41ae1e8b21defebcbccecdf1e1c808ec9ec28692f52b59545aa33cf8808c16ab9f7d6600276d0325419bf8449a6b6d674c74e308d83ab3088aaf65f403b99a41e36c44384790fd8c5e280840c8be202ff0b55aa9459ebe144b0990e630796309c16416bbb93d6bc40d469f52bef75802e032f77d982be2fb85140413ee2c74ad39581109822319ee12ddc4a736d88f95eadb9d4ae274214129d2096d72eb5dbceabb5636d3adb765cdbb0201745829398edd1b366e6ce7c7c8c8317e339e810381733898cb9a0d8580e53a19ed7d50126fbc0fba738eb15c11db0ca344c2d28e7a522ce524d01bf8c10613873722befb4e14d8f1d5d5009fe410307ccf5737ad831ff5837169e67919a60f7df650cfe22b302af8e58b55560703d4e4d6c7d5a9766cbe852cd390cc1c0d2ff6c158eff08719892c4458c4f76b6366493e60cc14d225884f9bfc7a4db0a84b75c2d51998e212d16a291885527cc9545a4b9b8b843077d9261ca6949e636ddf1e6b58149ae2227ad078502d83ce31f5e87aa7f8d0546f8c0e31ad80627bd57569f5870f95c0b7000fb3fb877d77f0f4d78ec5c43786e4b85d72c27bdef179b6fc9e7fe97ccb7f8ba4b027722f1b9efa635150664c64d24f7d74a1bbcaabae6fed5a87320ad6c9ba0964efab53d5a5f3f1bae0ff3e7592447cfdf6dc37690f296404cc51e2831a3a1aaf5d73693c280c17a5d1f5d9b92b3fd3b8dce263a6299e4d1e745981efcb7b4793d913b671124ad3a323c3f494ce673c418b03365d15da043171831a1db74584e827aa0bc8cff78af02eb7a2cede14adb424e0e2be54b3031d2bdc02d45b2a40e43e15a939db857a5d6233052fdb0e46da4aa8257d2562d8687ca01e9e2c3e3bd561d637af0dd834821dafe1efde7056c2f0be9309fa87df789a62c231372fbbb4bbd5f02dd688e98360f295489081240efe8a1aafccb9edbc2df60959dcfee1d587bf156b1693afe3510ab2de41f05ca1f5bf049581dc3fd323d02b32b7bdd50cc9779f16e07ec4aad60ec84095953e84cd678976048ce9e4771c55fad42f148f505812243ed15e1434b883692a2e11f64ee387d621e4758210daa4a9749b65415338cdcfb4df8eed1482ab78434dbe66f387d96e54ab86db06f4ba37e20732a56ecb2e0fb74971b56c63028477281ca6500f8fd1a47dfbdc459d5221ad0f6448375ff7639c46aa5c1a0b5ea9a90ddc8873d9629da7e88ed0d0172f15ad9c173a4f12a00d8ca31be2f35742d548f056859058b103dd5753759f53d4ba239e1321a325cc66fdf32b2bdbec68183d89357e3607e4f2ece74c20c27d8ccee1bed952b57dc53710feaa951620f0f14619b72bdc7dcd02e53e043e4a267d715e55b42f34dfefbce6bc228ce1b076e4cb22a8398772c0e5f42c365baf1d9436a52f994df459ae3b1d812d677b750f5da5582f6a98c52331a854395098b10aa7258465ea2cfed7ecfa2dd61a477824f8f2b396bf0a34a1cc3e95da40a7b977d660b10c44681b4dc65a7a6bb38742a7a47f946a779d1ca14c37e95b9485b3412a9ee6598aeab03a05b926ec291748d7b950f06d8edd188a53aeae914a87c21f521d3eec3779652e519a90298cc7e42fb663d0a24127da050b23af0c76352ec64ec1ab528a89cc53687d2df0712c36575e604695e0dccdf1db4cc513ca35607c2aa7fc030fb30b6af67c1e7d285f0a02e3e408242ca3cf6324a76240186d5046f263acb5dc9f9ff5c4617e0cf8b6f4abb8523fce786766c7dbe05e52e14791ca456b882ba41b9e40a6e0a87bc4ef8d71a9e1ce5dd0cea1703a42a13b47e5d54e507e70bcf2b9be92b94f01f852b5c08719e0662e12f85e244321d014414d362fa5c051efb9b905c97da16edfc2a0de9673d830557ae794a4a720ef82d5142c8c306778969fcbf2acb9032f06e75539aac4644e4bcdf61aaff002b552a6a3e8f0394c5f3b1aa258d8a7fdbdad20a892188b4736639797951f1ddff28de50082192c5b96b134ef4d93297b3ecfbdcdd501f66d984d876a7b4ff970381e4cd3a58412d7e6c662a68a5ff45837e77d9a3998b8548228a070a486dbe0c720875fe2d3f507cc0cafc6e09e9f6796394f57e2ee76c0cb951ebb5cb74d248b631cd0153aeed425fff8bb47ee0e6b1dbffd4eef74b4c266618b10755979c0c0281cec5f879918b3c61ce711ae9f691347f73758a94644b074f5a112511d816dbd2bba3243c972c4e85500f7a2a1b098b9b86c90c975ef3baccf4bb69e19524752b4d8f827fabe2d6e56b59239a1e661d88e5f5002e83283dd59078ba9c7992123dfa0061929c459850c6d7b2f379f7732be43629f616fc9e588330906f59162fc7721eb37daa2c02e632424d5876ed3e01e398c3b2117f23a46b0b26038118212f8c083ebc6dd8fe0cb3d06435a60bde0ad060d1c2e24f897b3ac76e136aab16b165e8eb35a6bdd5d483e73ac15166b804167aacb57294362b796eca5067b46730d2278bc2a51bbe99809068ce807b293004f3b269c2913a10204f3a0d9815bb0d1a2bbde75c597e84e8eceb458267c85960d4087bea76e516f06cd5518c011df0ad699cc3a74de9b581b5903c6cbc9f7a2f75ecd33d1f847a60e8517db32d61a523a55b6a0e027cd22a4ac8abe92a2140d35333264800db3ab49245887ce5238bd58789f06362e2bd982d70b2fdac599984b9f867b47e52fe75d944a0a416f8b2df309f8278850676488c97d9cef117ae90c585ad2b51a44c231fd28bf839f44a0ae30b57508954623b4eedd82372b6014aef8af459748be697616b0cf20579d06eb0e49eb660e7fd35f30dc4ce3d6e1afd7cb4e6cb6c7825b8d265454b600bb0cc1a693a55ef6c95ca7884a7695dac0f7ae8718a8b8bae4a2ca1b03de433d008be6095ffbf229f6c5eb191738ef06e88cd701c568a1588409f84945bf82d51c15356a602558d76e26e65b4ab60ff8e3911f0494f053f8a74b64df6ae499f298a40a0d42f0bb0eee178bcd1baf750c97b51b89defd2c86227eca4f9a22c60a17ea2ef13b6b3bbc1852405498be7159ca0628ffe9507221f80ec67e4000f71925c1a96d5f652f985535baf068b7a11c52d404b06f8dadaa87c07a06f067af15e51c7ded763a3f8e5e7d1806ccb8f0edb6a6ed249e6c8e70812772e2fd1e18bf3b415dbb0fd260bc0c75715704d81dcd1a1cadf5f560def6b9c56e79eac49b905a8bb5b717c9e1808c09ef2f051c06b674cd792e485529fd9891bd3ad94e5ca4ebc567a173ab8bf750f55bed74e8765c9de4e187c22ac39ca468f8e7e59f6a83e633ee707cac5ed1e9db9c2de85d364d2eb5662fa204be844681a5cb10b6c236ce2646e93c5a1c58bf6721e7f50807bf794f0d0b636a02c2f72f5b8af8b0664dcefaa18b033d847702c913e203a98ae715148ae0da7a7e45f997748f46b451f64a4c32e01f7113fc4b530fdf57480879d0c513ca66ee6cba31f5e0e7ed8b3c4b4c29e1113dd5fe2d16dc5fe972a479ea344a84bd0a98f821c919b832535f1991d0ae1034241bf2ed2221fd161d1adf4679382e871a7b9ff60f21333d1a81c69ab123e09a1d277ef1d5827782276882484bbe8b550c45fbd267c33ecd5088c3ad7c5667a15f8aa686853e3cf2600a6b8037806fa50f2160472fe189b4646704379ca6464ccac4acee1c6665381cc1fbeef7858052e009f83d41ee69367870cebf9cde56d1b4dfd569ffcd13477ae5c4e6dc187d50f3099485ad35685c40f6e5f742f27ca53f87fa3842ee602fe8d0cabafd1ff2317cee7bcf6556e58aa5a8e3d7d93d19132eafa89c89928a6984e807b1f7928c345c870acb0ea558eb6b062a53fea489da46007f71025cda4d1edbb421d7055ae9afef28e9285becb6fa15d18617a0cc95be6fcc593adea1cf2068e16a5e828244b3f022fc882a0e108110ba8d83ac3c00a47021c7fc9cce712c1ce7e9f432cc6283705d683a707eea8a6f8cd40bbd57a1c8c7de70493b60d550ae65a1114357297e3bdf2b9c73ad89c84daceda077df98c5a8bfd0bcd76de967337afb2ac8010d940ad9e2f45f1026444fb0867a849d5c8bdd9655b3b205e328660a7db4a20a8e824bdc28850693c8b8171baa013b4f2cdbf95544bb1361ce142a1d8bab786abf55bae50e89c5c406f816201d4505522558755c48a2e36f7ac50901d54890df0a2d3b61079937df8d07c1d0482e486472c112d24cb945a133cc441fb3ded86705c925af9db1d6aa7c530d67daffc2a9ab68195c83e2b5b64eb3eb317966eb956d431de4f81c7c25b730f378f8b86073128cf041fbba85c6d1c46329af9ef169dded640610e3c31eba9161b68b49131bc219ec9a9e7ed52be61b6cb418ae06929d32814224d40758127a8860c4ff73b2e82d731894700e38abb54641ff177fc5f0758693bb402c398aa2a868439245a346d36915a4c228db8d2083ac4f9916223c94b6a37ef88978f498a6d295f151e9b7d3366c9f93461819b592aa6076392c8017391cd4e314de0741a3b59e01521cef3c1e729cbbd7c6ced64ce7d1b066bd7d447c44242bb2d5a0e0e08cbd969a03b1c60d0933870d4a1b55946b593d66fae9d544cee3bfccdb24356e343a35810735b4cb32df8c6fa188c7f37bc2af4851beba9cb07ea8d41601f35a24724effc77a4a99e9761264db8210c87d90ef3c3064f4c816f8c77537b2d109133c71c0493f864c2286445bdea2da98519e53804d31d0b023ffe71831091521f53a300c027c8d0099207a5e65eeadaefd5e59e68d21c96ce1cd8c507c9aba9623294ccda8bc62395b3faea730adebaec987f72dd552833c2186e78597bb0997c951fe8d1bd0b5fe86a4d91f9501066a3ed6eb33b494bdd9ccb72bed886a127e2e9a6f9fe80c8382eda2fdda9aceaa8a984fb6abb6bee6a76368cc03b5309a2625bea99fb7e4989a40933731b6e0eaf21c3d1620eb78871f05bf1ea03fe0ad25a175e5b83500f1db98fcc963b6c407de62473992318364aba39bd3e8c9e40e6d676ff9d06f095caa1d46ca4df4097a48167b7b418fa54e9be0b4eefb1b5a5376a14680c40c3bfe6264c59101ab47f66ecd5d8fe874892a2fb187ac6ec0f809e53471a6768c5eb96f8e4a0880725be7e0a438803b70996bc53f30237b60b46794445447a0761ab5537f453e30bd021716d098b2b657ed8e6a924cbaa45b51e94466ed1f494d8e7de54a33a0319fc6d57ce9554cb1e88a940a6dfceaf2eef3131fa3882ef1401877e772c2136acf68d4668c6f9f6bad56216b1b3c7dff4f61f5bb240aa5628585098ee9521f9d76f188707d6a79e4bac845d838611a68772db4b9409529bebaf4cf05b2910a164c5a4f932f2148c3db5d414fd64ca439fda869f1ca992717e25bc7cbeaf464be05a0ad5ed120361813cc49f4ad207fdd695224c7e05e25555299ec725a3e650a35e43478b5551a92a4b9f68eb0cdc78188c1c3bc5925ef1a4f75f9faeae328cabf2a7e9806531263a9e367a0d5650da242d5d60fcf6d58dbdc673cb38a11bf45a9d3d8d661343da8d99247d582aa3eea715f8a74536141599e441a0454f03a9be7397b408d80b58eb0b057077646880bee309f155aa6f66adcc9d57d1eae31a4146837afef75d91e2268a330423d5ce40be561bfbae1d5eda886c05872d6021c7430e3b8110efa60ccf776b10fe67195f40bd4e37866e57726fbbdd578812231f9e6a97f10a28640bb671734abedc2f0623d18aed5d26bdc6982dbf0aa639c6dc2896cdd01f807d80bc0666dd1864a3db304dd93db6d340da2482bfdd61d65fd59bb830265f56424b56f5647dddd24e032c2e63f662da554968da558891778ebf3c2a8f6da6859c734afc7ac7e7b1264e04964347b2ccb94c3bec3304685d89193dc102c86a986b926c70bfcada78c4a7c495019d9851c2afb5c83625dab795f062b02385e64ed7967de97efa85f07eb8d276a9352ee263d9ba05391e836a0d2147e4ff440e2243debb198fcb857ac634182bf5418d601dd4b98cce8dfe1418ec8f170ab5c9b2c71c42ce37a63bf52629efc4c90b1b589beb9fda8f050b71248756d195d2dad96c1c2c9409cea684c0f4004b7e32e42c62eb563d03487a7b0ed524d1600afd7149c503350017e39343090143648f1e650eca810a9ca35eea845b20afd41df04368671c21217585d6a53448ad36f9ececa096b804a7f0ea09336a8ec0ac8bfd16d755c8a241999754aea84ee8933380fc8f332e7d1452497797c54b7993bc334781fb7924cbe2476681ac63624733c40192ba768fe0d45eecac19b4664b4cd324311affa3274c38ba3bd799764f5bf77f48e00c4f8c7ff133efeb9e5b4e455bf23cb706149163a6ded6fbd3e32c013f14518928508ae493a97dc160cb22c54fa36d3aac3cb4b723f600fbb53d8027fcf81aa0fe4189a8265ce96b548d62b348a251f48436f091ff75a3fb93149375f9678eafc1b73e3c16b3882a79c7a70c5c74708d9535355268a301eac637f7341396bb2b91c703de2ba636e4852355715da2c22ecb9f343ac9e43900759219dfb8502d721a46301fffb6e718ee079ab68d9810078a295edbd5d9cfc7a690681517a0bfcd246be36e571ca35609ca8da61b5b506683c20c278a5c14137e22c2bf5b69fc7132b9319225a543b6b7e01b67be3a5e254129a9cfb6edef6eb40eeb3b68f1f2469ac94954a0076eda481722867c1354484e0fa757ea7e8f4e8815c91e6f141ba80848332100739685f121c627a4ff27528277214ea4bf198d0bb5f8dcc43dc951657659342f81d12a7b49b89c0fb8b377f207b812f8e6557afa13cbf75ce25d704009ed88675a4db7fc5fd0880810965e3dfc9254fdd82427b38fa666b11eab470838d015061ca718beeeba2e74caab24ea4f4adbf0343f660f233a171d1b3475323de226e7a3e912eeec56aec84e34664cb568c8307f41fa5b5bba063805e97600364fece25e3829f93020911d29f5661e1ffb65fb658eaf2b0bb889712a24412d22d94f25e5cc3372b91ee2dcaac17b5bba7d4c65d06f8a2528944a0c15825a36bf687d18694b688f174511e633ea58446ef4286d9e0d0c834c336fb453d8ad88fc8488667ac558a6ed0a56bf323237e4dac978b44a31d11c8f2c51f206e9b0d38466a05d79ed0b609da6ce7bcfc04effac67857c4f5aff880ba1966b3b6ff74c2e7cda7472b1ba59d7d449aa03426241727b6929488a1ca240b7c9cdfe3180e882a7fd97bd906932b0e0c72b1977258dbf80a93019591b488868a21b2ee3d9d6b65fba0922c59e191618d728e00a625fd21e08122398d8faef13f9576ef2a23742e54ac3c31a6ea89d62a1e633d000b8fc5f04416c864971bd9a0b1fe12d7cf1fe9e200fd335cf6c333dd639d1c4fbd078c2413009d07b5f54d7a8102319440aca49a6f348956de1e4c42d9edeb722c6271f6574af8059213acdc510c01c896b3a77d904cc98fbf3af4f6cf9339a4aad0fd2963c1c03def74b2c52149d0d148769d224deefd26422ca3e9f5d2d07a3892f0a81b028dd07c836adf29fa3eb835e21ef692bd1d207ed5c02c9348f44f91733d057d8362d4810e39b939f6980f05cb9ab67ddeba5f8b96a39ce52fc547bcbe9806703e1c91e971110fed44ffa11f0b3fa60409b306f15ce8df2d110a57d233f9bc76007cfb9cc3f8cc4b85d5444e7a170ca74282865554054099029ee8beda0793bb116f82653a5c89afb9e9d185c33ccb7741c9d1ecd277836054b49255b794088c43dc8a43f9164af8e13717a182797e009b24c9d289b7835a0cd6c6aacebeb6737fb67033debb41bdf9112363efa62453ba2afc48304eb476513936df599d5229b9327d399ccd67f66d7e77889eea53e3876d0989625cc32b0099c2e64935cea4a01a57e37840b4d1e6bd54bdf119a07dae46fb13738be7abc4558d6b9b838798c0a1569bb870d84f0067c3dce99b55fbf6e3f7225dd86bc9333a94ebaa385cc01627c058c48c745900505dfa9def8b2c32cc27ef338ff2bed32165cbc8fb3f23fa689b01c765bf5abbb455c55997a3fd3f1413c2e04964d41bdf8ee2a01f3a0a09f9a8124a8a6fc72e5bb19f81f086f68f86b554542fd9c4e5ddfa534b11ab08793c105687743982a2d7ac8831d62fb294614f04e91a2a236dcfe9201cd486538bd0d8954c9368b874415712718b85055e86bf4aea6747c42af61bdc07b0bc045ead17217d85abe18307ba78047e8778007e34fb8a731061eeda841ca05929148b89130c736f76140b4b08785efa6d40ccc24126eecdb7be2944106f8b342685b5ff896234ba560e7d49ff3a1d3c52e2d7f1cc0a811586f51f7f479f458260b3cbd8567c6b9717959a32465ce27fcba7d849907f1497880de323e61fe740de999f7a875b151cab486d48aa3ebdacc088824b4d44c1dd53d5ef7d2df8102e02bab6283e1865f4f8b803c3a951ff14bef343944dd8925a7cec8d4ddd230d080c036fa2b193a04e6fd715aef1219bb783c6c96e2f81b56a05e9ce67b66f70e5889274af346ddddc3a6708361755c1095ebb8aa63dcdc0d1c7e48193d300e4787ccce6cc563af83040ebc38eb78172c4b42a8c9b68fbbadaff9b8fd37f6b5b07a464b1665197acf4bf533742df682a80ac5e42d4679dc45af50ae961b1064d97a82f635b042491ed6c9b5e6eef161ccc1cbc9b3eebfd1593d30f3bcd324c57e40301dd3a764077d31c1bd7c0bc14cb13218b8f2c431b7ab0fea5cad043b9803fc84dbfa77a7951698bd77aeffec964b3382a09ef69d42602eed17083f4e54399027be2e5913558dcab11be3b157879cf23dee6309daa40cf889504c8c5f656b30e40c0abdded40c6e0199288d22bb205c97ffd87485db37148cb81a5779b9c8c938336e0a87254891840e18f45807ad2fd6e52a78bbbb19e9c182259eabe910673e74c3988e3114b12d73f3c3ae6e98085de87a93244855fc6eaac003daabcb67f79b2b94fb46d6af8e8056bace24d0fae9cbdf108867ec3ca0fd48aa74beb21a64152a7e121d1eb71fb3a457473abea12f73a15d7c41265caf558ce3351747aae9caac365780ced6d9769f79c03c03fbe9e36a5b85bc9527b7301bcfedec3132abf0693c0bf421e8c0b46c0a10ad5dcdde2e7f1466109a3ab9c286351589cf90a67afe253f32122369519e0c9408fa2a56860db11905020b1c009ea746e10c390ba20e26b1f2dbf0620d4e2a05e4a7df4c31d2b1425a6bbd8528013bfcf6191958433c2fbe050c9392c09bf8dab3dbd1019aa4f09a72193bc7996578b80b1f194d9729b9d965d20aacb22beb3a36f31fd4d9fa4fd5f5b326215c4700c80f8df464c42acda79edc99dd8356883ed6c098ab4615433e014caecf059f1df722e427f80087a1adc9ee8d5c205f3eee36de72e040115df2c403f71da121a6d018ed36c780fb152afa7793740a43fea604ed018c51a38d5adc5ca5b1176bdcecd48882240e135eccd132520ba4b96a9a796e3177bdc2b1acc8c8a2436d2cdb3a5f41f1fb011e8c3de6ee362631eced31b3b4656c21615f297c584743a522a3e24aa37eb3d9e5c478e87ac1ab21f94afc3d80b6a5cd23f4fefb5e9bacfa382a4a7318f105671d846a312fa5b9e5893c6392ae02fa77aaa5e849a253f0a4a896b4452a598b748ac2f94c0d17aebf2af28a273be09ab36bfcf4d4721eb2c77800059084d46524d66764cc3b8cda218a2edb7f512da05284d6b74de3394bdd01583fab69bb78a379f9a33be817b3e2938e2be9e417a341f681af54d9ae48c699478e4bb25d2091f71e4631b7dd9006cb083f34b2cc3d910937f47f57848f3f112b2254b6702ca7d38a28fe1c6c0269333cc2e635e1f896a0cd2759c51b8815d71de70b77a864d7faa6803b6a0b639ae7638b4d2476a0f1f08a52fb4b7148b077e3a8a3408bfee1f94e02d0d7cd8959d1d99f603812feb6dacd4ef20dd20076047e390458865cbaf351a78acad9a235a5cc2c951aa08192895bf37685b0b2736518f5fe4da12f48ea394241f84302257e3ab6440caef0316cfc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
