<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bc051b31d2acc4d0fe6fa8d3b9a4b3122038b62c15e10b21e2a4913d7184c32127061197f252c49ef82f465da42be04809ea7613cf8a77a911f3dde8440ec398840b39429215de0effcfb1be1ddc780359ffe34ed23fe34ca1c3c7b6a64e628e204a3a39e507eb1621f1d03f41bbd88ec843199854ae2cb45457c753e3b7eba1ad5b3850402ada0bbfbc3c17124faf3e1f5192bb75dec811b0f3f5997286def02c8f8ad6898e73f904ce324e0db70f1e9cd7d72c57e2e1b463aefd9681f7834560ace13f735fd74f09cc87c55c60f0a2eac375163c42d39fe18ff3c6fae1070cf522342329c59c525640e5684caadc8050b7a0ed4aff430ba75cdc96ff626ca13a4132f2118f7acce37bdf0abdedc7e2dbb4be11dd673a199756340a01c4139c21f94e11bbbbbbabf1562b6092c6917599ec8e1c3fc9fb7d32bd16f697f5447e91ef9f217fd2d48957c157d877961fb820c6666b2982d20d64604be43bc0a10970e2bd2aa628b6b88c353d459e970b30af861d4a0156d03c7510ebbe52cceba553a9dc8eeee9d5e64175b56d04607388ccec898aa905a641adc56a474d5fa7453214e78d119e2ffae0ebe9199e1ade0b651b6a60afd9a09c99b58986ec5b641a1d025fb8b1fe94e951ec4d44ae042c1d0dd93cc80bc20949066976b0dce187a8f2506ff076ae06a341389ee88231f886d260c8df9014c83bfe0d594d73c655aa29879576722443944f6f1952d5607b16b1ad2b01afa2c840830cec4149f57615c53589772f3da78d79553c8ce36e2e05926e4421c0b7512841d5f09a5b00c4dbd4c6c0587770b9ef555a739748702894889e49fd22476d5b357efd8b29b4a8684fdde35a58fb0780054249b81ef41f718ae7e28544da4fc2f0cf500d4f2a4025a5bc9211e57917b9807f1ae4d288a0abb8200298cbc4f9651554589ae6ee0c5ce8a376f057a186c3d1d1ea95fbe5aaaa6198d6ceca689e8386662e9c69c299f6c6cc6219d78eb35b05ac1c8360461c75bf3da8a09782eff7e7b7538c920b1bf78b1bfd8ab7e9c5c5589b86971a505748c48d40e38983179133c680c7a8a5d9dab63b316e06c63718ab12d54875d132631d0caa785c6976a175e1c5141f7348838d245bbaa30394a4c3b4412b821e0b2a10ee5982f22fb05b1f9393f9ee18b99915061927ac0e6a5efcaed6332b4049c7d8dbe42cdd83eb62a9b6e0146ff9f0aae736775bc349e895b225c5ff1af9b90493fdbb1a5d6ab11659d83c3f729ea591a94bf099cfde54dce8c01d33d39c1b93b6599df2bcc4ac748b29ad743f6cbd31fc98ad2ac24712d3de1c1d06d76889a07899a8340217004a6db8f6dbd7b156b9e801d93474bbda39bf739b678d214153f8347e776af7fad6f67c956d199bbd4190aca636c2f6ab2ce613047d6b69ad9a1f9cf3f918ede0a2a4668bf14e30b9c3491b54e5e7cf2edbc179cab155efd97ad93b3310b29df9be082c80c669f9d459bc48659907ecb2423ba5d782a185e771902abcd83946db15fc8b4e92a97441dda377fc07c57db74a6a32a320be50b2a702f0b0692f38876da1a1d5e0613c170c623e3f963a5c34c3c941ff4b29ce5785c3889d322fecd5d7c8b2ca796cb67e6033cf00beba110d64c8531372a55b66e5e0e5b60b8b968796849014acf3454eef7e558e36487b383ff80b6628809ad39659dd8d3720ea98e319a3d639c1b2710d3479928e89ab56db1f05d2fa09e4ee5c3aadf72a1d67fce18edba850045b6e864ea03e6e56ec33e69cb65e9908f133248f087c935a96adcb4d771eb6b6d4ccf876b11f91411ccd71e0745fe1463582f35deb72555279eeb229cd4625d7c83b805af88fd13e56a692b84a11599d89dc6f6b2b25351273c1314a97f087027d1e3a9496233532e190112ea1651630858ff0482947cad62b8721abd6bebf08333d320aa88c1653992ac45944932fe777abdfdcb798ef3007b5a1de10d93a08a3b1d5f74f80afdd27621d964a5bc91fb86d5c3bdb278f8565cacd4124b32f6cd3085373142dcbea9dd2bb5d8b6d12a42dd41da538c47602e17c7c6311578dc8797fa0801ae919820f72d044173e3ed501b33f80207c0214014d2911a41219ace4776e4710b4dc6d3ab53f3a16949c5a98e1c8ea70697f65851bfa87fb6d0e681bdec086d99f4a650472c1abe9285d1d246715cc3f18e2f971db28c39a22a8b30369d65f9223b328a3ab215fa2b1c309f419e2c7ac0c22897a37a83077137c42b5e90ee75c714cc3c617815cd96e308d1173fddc765c42a9f281b35999d4076a169440288f5caa0f1362e1150a553f6da890e0f8fa9f19696749d212874d1c43c109da268d06a8fb8ae6348070c4a94d815bb31d721cd381f7ce538dcecbf5291fd03c88582989d28d20ed609332b8a639f71e5b319e32735da79f22d7d454270139ac4c18e2ec6419b0fd4b618cf5a09d8f3d829260a68007935b370159f3017f28fb05fa0685f4f79052c90bbe6f8a59f19d929402d7a7f1c76047c59640c3e038b29fa1342db4213bb6875ee606301189694ee963d1fb65635aea66d5185dc2aae0993efd3fcd8cf3e14ac404a7b75949646a505c31c99484be3ac42331f4592318197e47347fabad73958b540b9510c6565c4ae08f35c21dc1d74f99980177e9b4ca785758bbbb6d1390e2ed4f4cb3e524571c34acd9e4f798e31ff683ba2e27b3ab2bebfaf4f72bfa80ced058e74e9bde48dc23900f1f2ba2968a0e2d902d34dc2b8589191bdc00f12fcd222482e68bbb5790672a4b6cb1e5638ef5b27e2f53f918e4940457daac5b6ec4b330fe569df94aefac49acb2ed5f6bc0d429d548d68f6919b016e07b29fc109cc1164f88212d8f60e7c7501025da776099882bd91ff9e7a5eb7f45c491d1de80cc9a62f8cd2d441d0ec1edf662a76f91aa518afdf486015cbb5420b69a57ab0828f72534773de58c3b10e407954a46b221c5938dd2d4f294517e472c2498e8df60293f9b59a7e42cec9a68ddf3e5f476f5901ed2d7b6d26240f3c336dafc57017add6e52bd9914bb64a0eb2fcb4e975adcfc4a09cfce100055e1dffcd1e5f3095b53c6205fb5fe004c84e36e1ec22f9e3785c74f3344cdab6c5959a4bd1e054a26660c684a2264798dca2a0aa0384d0d9d9c04096420907f124ad714fca87c0771a9e2f29b78422f5d081688a828bed60d72b189051188c7dbf2cf61f550b4df4894a2cd8869a09173e5f2b39df41c71300142f8aeb30f1bfa422841b93af1cf575e3fb92d6df8a3120e4923e4d9b7b5114683209907f662187c5f90394378a246543c0ef9a19c7af759bd6d661e099e32cf9decd6397c123f5ce2e2be8fad14fd7967e90c03b58ab48a163987aa08f3bc264dfb69d01ddbaa5161f9d082b202a517068187345739b46e4b7f60ef46017bf0e8243bd8572a193e88e96a40d137ae7ad97a361e78413dcd1bb9dee9af3ea4cccb2378cd629a46636d3ed15fb103a033678fc977b2453966249742d983b0056658cb22d0452c69ea84f5340bef88c05ba00e4f476059ae1a3def0c05d71b9e72d73e2e53b2497dddc4bc9db89a5b75431c3bccacbf7bc7e1beb1ea1474f4b55989b023ea42f727412d02abd11d16ab41fb96302bb0ec0a9491082adb2248a7cb9caa97657e06a00877c99de02768637dd0a2af721589d3dd76d61a7489318ddd7170f439f3d006c13587f271130f08b9eb9a97e88bcea8a633f689f52b3d9c58b61ee77f1f4fbca4bc8f991c05382c4364776cc981a5ff44679c2ef0357220f72a4559a1791ae180375ee952c8b50e2cc2d6e77c70160c9c1b141765615a2a2e9b41af582a336c5ba8d44ed60b86a6fab6f2123ef559d39ddf602a68eb21ad4860b2e2a525d7182f414d2336883384c5471f90366f0b16a5750f0444756fce019b5ee7c944174566c5abb411a4ba722a683c09be6af1f31107cc90ccc1bbc4097b021983806c02e7379c3c82403929bdf13cab35e1b1b37c96d0ee74ea226bcb14cd173dd54d09bac7ebdb41c65ea6c928d9a4153033bffe741b410b9a94b3549e251bcb47751f19591c790ec1ac062913d4353fe3943864d6b10a442186701333942b312ab6e5b5867e912d7178549265454b43a9784b2f0a8fb331b757a50af676f188c65796d361f998851375752be8908b99317c549c6477cc0493a375db94ad52f1f61c9ce58e51123b408286ad8e3b01b24936a8e8a6c08c3cd9893ccfe67c1f8a1c797366747b01c3c44e65c0f9e3e256b5fc97b226f1375c3326fa974452785cdf84ad1fd8e5ebaaf6435ae92cd6237caa2e738ae282581ec964ea104d7684a87d7896b7c6b4cc7852d98ecb13cd0c3c5368dfbf8139f9cd520bbebe1a8ed864a3d3ea56495ef554d22b800f962d4078337041be6623a0f6c67ae2aba35aa5cadb6f73214c453591a704b720203b5cc4428d643b307fcf54bde7993a23a8c00933e16fd739c207f80fb8cff48cbc02527df77d76d469f1b3c446c592bd1ead2651d5dc0a42303249624437ac06b9880c4222f806bd21dd570c22d9fa5575c25ed5f38479d8a76d0da83583fdab7c63e75764f9f782b6d757eeeedd91f7763c23b209a52e06c1e839f0651433bf2313ef5004b2e42bf230942c96db754cb60dc41abf32a6b2e9d70190bdb3b09cbcf9c25767fe87f88dcb22bdb25cb21479b7307baf038214b85ddf7dc5cfd6b2887164d4c1ef27e26d55d50df53a1a0bb073610100f59f0ae05de5b6fbc5020c574318f661efea734b60719cd02c1de54d251875314f6da6574ff6035effef6f9eecd0a9ed5cb757ba2e94190643ec9e90cefea97794241c31c8586fb06f419394e777235f476ad58fd3c5a0d401952ad8f544387cf551b90108e94e90bf63c3b2371e9d07556587d4ad59f329f6ade06678da8e5ca3104de4b703beddd7379d5a40ba6fe3406ee3b2d5f03f112fb7487ad5e3f2f198dfbf7123e962518c12f2db1c51887561f49610a312e12021df3998691eb9ed2a907798e9f93023c2ec7d3f6adc9a0f3b4d7bff79c883573af26a42b5c4f32f4f3737973cba731df282574489e177789fa64fe15ca2e79e6b9b00b084ac7b790fe10b945c91d408f88a95e45040a31a0afaf286cd75d40d81240349bec84cbd5906d002c64a3e5028119ab35aed41faee4f12032e2d0323a3b5365f89d359bada0c0184dd512dd70f2d017ad9744b38f2dda3be033b3f71f3c931c11f1ec67b191ba50a7a18157dc0776f9dd95f0ae5cdc0618ad6d674e8e65cae30740efb5c51882f8e23c9557b493921ef0fd5e5e95ffd0a8c9cdd4aa1a871841baffe19628804ec43221ba177b06a9b5e36a2dba1b6d50536ba3a90a3d9edb0f6579f83b83006d7ffa599015bf58726813865448fbb24c98be2e8072698fc79c2622206858bb4df2846c64d6420f5b7f2c341a17eff7c88d1b0b0c4b343dfad05c1a63e96e58598f179a2619b8efeed0bef297e59472c38ba593e5594516808032b951641ff9a036f72f20ed64b2ea90d5037d98ac81a800984511d84de57f94be4a20f0749cd2249e4f1c88ab2f3581cd8c90632d4d274582a5be82890a2a33dba88a54c0c3fd6b1b8843f6cf2a8cda763f279a9a092eaf87e91dc7535e802f839c02602b489e6ffa79509daa1dc6095d61944385039d1e0695baf92fa62b5211ffa12e229b8dd430475925d609dd4228d917135bb12ceedba2e08f083c85275a39b63c26c26792550682db360f2956958d3b58a417b20ca51b34e4c11f2673d557e33fc357ad95ddf3356f1cd634e070f84feca44536e1f2be9d168ce317b655388cbe04dd11d334cf3d282128eb7c4a812e4b3f63d0fecde27052aacf04cdce41f3b34b791f7145d6209ef3f14f119ce2efebc2fe4871d0dec749a1cde393351c6cf38ca5126e6ede123aea75bfd91127a7fa1f8132aef9a3391d30f025a132ae1ee2504541f7d7c2acc48b8d6528af08ef6ea70393fdb021c12f38782bdf22589f51a7e1789231c97f3e83e4d3588ff9e7f6bd12a89bc04e3c654779070dad2b248de76f4818538da68876a954338d2198bff42a127aafb4d260cab24856c908fd77da47d00d9d7a7d04a110970695cbe614f87bd425f5e85ec76e3246bc9ba2d4baf47bed9d562de3fc7037ff858eab5f6bdb0b915cea545ba764f18db62c1b69b9317ee79c764bedba74e54104586ad3633af564f8ed28c1fdebd48f69cb43204441d38cc0a5d98173509cc17b3ed04834ec875038ea10c4131ea4c08bac5ef14ddf2f52b96d1c1c8c374472ed28726c2b087651b909bd7ce38380971e3084be3da18de87842b363501890e8937be6999a38c05c8a8121468129e2937e65a076fd96d3c9ced6a571562e2e4da632462a052febcdede245d6a9d87a41f102b3ffb4a271a9c76d4f15d6c2bf4e469c044650134e5a9fe336a317db8823fac251838a578ed5948b2e036b4c27942bce5c231b92ed42320883827e278f7372a42cdc11442f6bebca0dd429589c0e840253c9d8042572a952e12e02ddc44cb3f61119f25ee5ab68934f218efaf5254435939d7cf5ce51fa9045a6ac12626ee5d3c624be53b6fa9565b84d4cb516c4e86aca701156a894cb5e7941b87b0519c5aa0ad3b28b20e0a01c00f2cc6fe2a3e5b481a18496a343ca5569a59a46817cd993b3815e156fe1f6ec8bb4237c9d73e7db8847a69921d64edbc83ffc158ed50b8cad79fbb9bce0b4c5d08671c4e2e844068b7f9595bddece47c99dedbac8ba65b088f9b97891837dae1bfee3809e9916c0c4b0d028c20a52d9a1bf4ff5ce3a13a581e2584197783a5e8bc3fce2080a78d4f6aa2b4bef8e7ec681b24552fc010decc6a01ceffb751132dd766da5f08f5b96b6e8b5518815087c1783b1979a7520791ccb3577fcfbcc205a67d000a89380955b31e97c649226ccbde426b0a79ae64f17acc7dd08cdac14b2e2a664a778a81a1615811e1d8e8eb80e0ce3f8442150e2c9ca360a64f7a0388f9fdaba3527fdc00a98f46cd116293e2b514a76df72c662219d567b41eb38a0378f5379bf9bd42c26c115815a001e8b2f46a9a4f18a5a4fcbe8a7df8e6fb5d3515fb169be62cba43cc7544b9f55bddf8a9441181bcb5962f001f28896d150bcff6616f92857845ad0ccc7af2865deb73268fd627d164f979effbd86494b7571f009437e8763045e7d3bf1925a776310fd83ce9b72aa67517b8eb6ae3b81c7d665f6aa3f79057e4d5de26b76ad15b7a169c30169a5abf0afbff2807930b175008f72693f19095f4f87aa60b5557a10898c11cd58e919d303a526666e7c98d1cef7c95b80eaf3dc9a910c1e47b73c9125db12d9135949bee41c821ecdaff4f9f908ef7f317e90d109e268b137c91f5269a643050a8fb4dc9d3cc0cce57880225001243d39a19c12ce56c245eb8cd14ebac0f139592b69d9c48c41808af9a49d9a7250edbd3f629c4def847144164a19288849ca0c4c603eb65fb59acf90cc5587e072dc50fef7d51c4ae01f444930cd846b15e72408b8ad643ae9416808f748561df8054be0c84417e5e836579a4ac518db7f0dbc4fa1e4e1c4a5f34c80fffb6724cb552b78b98e042c50b3c444511802077888bc420bb2c56850eb496919355e29b9322659c087ef4f4975b71db1529185283a258cc6373dda9ff0dd2f7d986bddcf008e91096ac4751516a8a3778b64eaf952fed65feeb05f5d5bd9233bf0c69a11183a9da2e57ad8a0c0a4d5bece1e1da19f7c3d1df23fca4f06c567dbc7ebcc3498aa283831dd8a37cfebfda485364361a80de24c9fb55df3718c8d308cb073c0c3d896065a0abf52d06337575f0dea25cf2452ea9389c88d56dd6c22495ee4e48bad333aba263b06d57d3e4937f52246c84977b675d1ca09a042291817ae154f03516aae8cbd2506657cb2bc3483f51f122ea208e1a9badf1cd1a46fded36b96e9be0cf9d6b13fdb241e291bdea1d504f0bf34cbbab13c96a357ba05f2a6fa5f0c8a9afcb33ec494528d2a4d25df2dfeeae4957609836a3f7198623270d6200bf647a84c84c468c7684b455bbad4e75975fabff2d9b6ba2ec42e9ad0bb05bd7d9312591133fcab5265da3e944b51eb52ef67af19a532604ac303b801698e41cf9ed983e1adab8bba6837e24b7e17ee4f0e2e54cd664794f0280a2e8c53c73dc5000634dca3e8f6b8a6ca55fdbbef90727ed7a998c2b57f56ad9ca3d7204f4ad3d7ccf1b9dbcc74b14ef109a65ee5b6714c6089f1bb2349ef080be876494e3b8597b13b681415e0f085a9be8b7d655dbf41f3135ce4696355f7fb88b10dde76e2f2115359a749a298dc948060a2d5b6e261cc90b4a213394df5671108daa809da9c5cd2a0d7adaa195ac8305d136e3710404a897612649c57083904c9859966cb59ac0e69507f7dfad00a3146cbdbed937eb15f29b9f62865a1a99228813b8cee4d3695857c93413eac24834d3542a7c66041fa4f1b1244dbb7a8c3f88e5bd49672d096d246a2240699a4edd54aea3a2d9505cc48bac3156d55fffad5dd03180f97f776dc797c64659932386460b9dd7dff849b31ebc563cc4eb696c039c1237c197d64327d6377e2a683cf76c19cd5a2a06e34ca067d7dc7ce69dcde9cfc7e8c8d66915ec1dbe2fd8321215b50223efe82a45acebb4173555ccdf7ea94962a250df44226fc11ef99aebafe86e0a5d143bf8c7cdace9692c84a0870cb05bdee16508d03e039ef91fb58ff47e5e68aaafc83649815b2d9622ec5277773aabe3c1f4ede0cb9f8708c68006d96dd7047e550d61f68e0813f82193e3fe4cc7cda6489f995ada4d5e9211e49bbc5bca13ed869764c86104b419bcc859a63107ce31acc0aefd64c7756c252f33705ee241ab69b57ff9c37427290a9c0e884b10d5f8153dade3506f82a7827f1bf3c94aedeb516e76f6a222936549762757e417f36c60e1f4995858da1b78b0787b7d638eda71f4c286cab400f2a906d7326e071d33e0d7bb1dd35e704e5e3e5d172b4ed79b9a2daf9885b76f3114c59c710d35dda20f6e486fd8c7864128e654428ad0c98392ea267fefcb4d9559783aac08b7dda39f01be3db4ad5e833ce79dc4add91b28dd7a057f7094dd47bf6ed8c5fcd80ce1d40234ea736d3d719e33ee355dcb3d48fc6b4b650bee8266976d9429829c74dee8f40d54af8e0d047dc5fee9da48adcaf89ce130cfde7474fa6ddf37cfc5bf8bccb2f0b2217adc74e5d6d3c6dd47af3297d7a4026c94615809a5b619e3bfd08c2ce092926dd9d2a19710a4fa6cafb6092fb72cf91bd469146ada18a01a7a5386ef378aed7924fa5e3191c4389e5dea92d3ad0305d2b23be72fc2e3b098c7a05c71d2dd7bec614434daffc7d61620b3b6864cc1cfb91b8c3e8caae0b4b51e7844ef59b25823965fa05dbd18f10cdaddb52fec35510d44f9e5aeb59efe5e3af92cadb38134e62c8ed0f2446fe61a481933f966d8ec36dc481f0e50da681bcf07291e24640b3ca4686e44749a79204974b4bba300f7ffbc5faae8f3d0a9c1d5b093085fad42e4bd04928be6919c8e6a00bf613d395fea7c30e41d85832889cae52e12373e80cf4cbb6abf40dab53c385fba090810238b249e64f6dd6e18ee11106dddc68acc07c7cc1570f2b29696c057b7eb8005e6e648caa69d290061310dc0a6e744e1c2fc95f3680507e054cd7fa9b70e030668bb81e3ad2f8d3799cb8372a2ff3514e3e56197f91a372ef78598592a436c3d80e18b319ab82e7b27af16cde09db34edec6ede3083ec919573225af1646f12848d7289ceaf19a4f643c46d260dea531df797446e047c848ee4dd16236d63914ceb39139cd1f0486fa93899158fd5627c299d39063e55a79e8ba906998e543749abc7b6536af1bbdf53559903bfc90034cdc25916960fdc356ac0fc8d7aaea39a9a6440b7716e8e2c06488d52a01b29cd20928c11360870d5946d03ca162a9b3a6aed88ebf0fabecc88becc0cbe2e60061f7396e660c069ba5f6567cd7b9e477c889eff6168c50985f433f8329ce47e583d2cdeba85de3b13f97182b0ef03e378f26d3c2388abceafcba9adf899ed8a37004d56d224d819d393b7a577bffeb4569e08c235b7042a6830c20f92997bb6d89e1b2892704dacc422b7e50a28692cc196e85bd3ae3c3a71b30f3e4842f09c6bca54204b6ec53632894f1004d8633557a90655931ed1a1b01a236ce8ab60a8cb963efe81171b0fac0e8739b18e3350a68fe442e085a24dc12b3a2e8a262f287078bf57470a67336d79d106e1a047aa2d8aaa82868d9cb874b695b31bb2c1107c83f44315a3f9ec03861f76ea203964e414499dba2561bf75f2637fc7ee57ee30fe6dac57c9b2b01b9e4bc5addddb19f46b353b7bfb7ad8d6d727b613891260d0a14ce35601ebe29e5e37d421b18c0961f9ddb6a33f454d075416dfdee6385a7f875ab268a489d098b1b38e3c139487f85bff72936b26d5ed2ac51e02e9293311ff08cb9bbf8b5c00a19d85c9914375f6047bd0edbc687fb1892c389c82da8a5f2d5c644de021f45ab443a8671642920a61b5e22da3312679f0e0e5c562f6a09dee58b5c0fb40a1c6daf97c44466f63219acbc05c3e0e86ae35b244249eae49a5b9f8682e3500813c9d5c76fae0aea0e1b68d4d7308d0836c8ce542ac3355f8507bd4839418b138569811695fa777fab9ffeb411431623823753e58fe898e75ba2592383b5e204fea7cff7c97a1274782c5536b261a0d37b3c9e86f045b42a62e0dcd632635923268494d358a248b74cdf293bfecfe5ac6fea34ebd3a403fe57955dcc0351f5203a258e23423ff4f2373a45e4a56c609e409b8819b21745256ca1df08f8258a3aaadb48542c3b66faad1d0f82d0630e055da8a37f1771678113ee2373e4efc816228d78e9e7c4fba266d87a1d6b747b9a04a3b9854555ccf25d86f7d1c30de8afddd7795fdf4a7a1c23a8282735355d854dd585a12c655505deb79fe5a6770d2739d54027af8969d11994d8b85bebb4ae872da99fe3eb1d545f05675d11765336ee06ef7525d314b9cbe11f2178077358cd67d7c4fbc003b9c9f152f664d8726ae317303671350609601f76a8bd616aa13626c909777a5eee53cf5324861f8af605482f82c31107a1134f8ea626303912e4b0d5756ea9b2d38a9269673bdfd666f87257ffc00cbbe698f349a67fdac743c617acd06238b6e29fb569dcae3314151b266c08c6fa643c4bfb2d3c4ad2397d8c914a16d43a312e225f68877929aff4fc6eba5a82c729302928ba63a6fb14dff4ee76c6f697481fe410aa798a332ef547e20d76458ab589431b197f6f1e7a6234e658952f4b73330cd27c62bd3a301b47d19d19832129f7186b52c6302ad9c247a97320f5d021773f791c3f3bf27600dc27c40ebeec2c67d00cb0b88f3aa7a17b8a8d9a29b9adff5fd355bf2aa1f9a5c826ae9077ca19f8db41e75fc22d9fbf2e6194cb35e46f2d03cd4f7fbb7c47d706da49b7c523a76fda71d905e74f1527994e0ab237421c41bda0d1ee80fd8020b1ebb81aa4031ec364907032fedfb977e98498972523812744bae15e2ae38affde50ebd8fb732aa47eda6f3449922e153e9cc583ffe1ecaaf0b7ff2d3c8abf5411bed9975939f6f000515689da2eba2631121f716000fda9d60f66e5626468886794ab9a5b80b42c38e3d53b3a4c86f75357294a7f6b4eb10afca47cc9daa557c25b762d13315b509ecc5fc9360b6b941c018034d5b367d17d8679391f3a50f3c42c413d4fa1bc3a13b587bb4bb4c1f2286e7d8f6a06a211d98108b437fc4612c999170c8f8c1b601ad1b1913dea8ac28e06b966a51f2b387fe42dbfaff39e001641c90e4a8b31816f1cc163296f0fc23749164a777c96b434491dce5798307f026e7bb16da876415b5660f99772d9a989f4371b8ca7370573490be5a149e83f08af04c09f9f0fbf0ed370db983a49e12a0ba38bebcd57394f8a20c2603b30abff8d2213a30356637582ec6285233e4404b8729ad252e532b5505cac1aa07ee1a05ba0560d4f3c3a954b7c85cffe67794e15b22a82e6519866f7a4f984438149edc793324e877074b385d096a185f2b33a5f99fa0c8a5c9369111161c50ed060d0f567221f24268a4625e7893e69fdce9ced72855e1dd3889eb0c4efd2267b402b4e212b649913da07dc26661533ed53b54ac1dff25eef4ce734a93f504c789f0082e430db54e6ebf67f68bca7148659317ce84581cbe5dd28a03353029eab6f58b1e5f32d5ba67ac5f4d428582bea0b4127896f0c19a9c92837aafe0308784f2dfa5938407df0e9e13bbf2aa8245b9e935c6b6865f0468959beec0f912dadd4c25a8cdc1778da1493938337c4bca9a0612f4e8db4d55ef6eb41932e201912568dd1b44e754b1cb1fa0963733b74173d8b832d74053a3aab54bed4b9cfbc15d4fe8436781af6f32123fcd1ab9f40670cd8ac92d116ee87bce0d618c91c372491a789edce48dd42ab8836924832e693f7fcae2ccb1e3f6ccab635191ea797bbdcdc0a5f9db5693b44bcd5af79eb74b3b40be621f1f6615288654fec59ec3d36bb26a4a4bd9577744696af8332b6b3a7cf01cf55c10278d8eb746d8003e7679e1ea7d6b5cce37fd0e1301220b3e02ae102e4afebaf3229c2606a3d17acf1d27321c079fca2c67848c0bd92deec8f9d9c60b49444494ea58b8787c79947bd0c096bace0e96ef36bad4d15c4cb497f148263600c35ea61d3d450dea5c145b91eb0ca3deb05d0443297cbda28e85731de87c41b9fbbabfda76c782911e8883e94085251224794df37a686f710f276ec3b4b88a4437f05a0bb3927d33f9fe194a47c35bcbb9c540ccd5ea0f930c1a494382b6a6554fa6caeaf1d027494d955949f22e041d81593a45780a13df7f6bcc9834f782dfc9a12a04ff6c58219a4828bb736f11a51a026f64404af058584fc10e04fd552db2c76d94557a281be848341e6d74dd2283246c1b7dc7b4f6a1179f8824a3a9bd90bb687bdf57f1eb763619b21336988b4657de0adf6dbd15b558f145f8541a534acc1f2d69fc71daee2b4b5254f45b242766e455a964e5e50529ac4a0c52eb2d58a884884e6475fefc7630d8e5607116aaa84af5ae4e297db6fcb8ef5b8f5cc48adcf30435b1c46900443dd55872e87bc5447a117a2168e41cd71091ef96ed32af97a5fb7a725b9be465b060c33e2129157cd5dccdf0ff7711ed8dd0a89554afb2c317a91f0cac4c6a502e82b3d20a1ca8b54c0f2e64b23ebda2706816508ff8923054e0da3a2e1c8cdbc4f5b06255a41e0050921ddf76a21de3580455b85cf41c9394e8f96bc22c1b4b3c79f072875c4b21da0091594d0c1d8567bf29308754de21fc9ae1f7daf1654374a9b820d266ad1c4d4517d3e0d71777459c3ec369ed2e33db9f0add874f31bf5b067037461912b4134bcc00d1dc0267619d3b710354bc5fe6d34382393d267036edc43ea31bf170b8886504b72006307e4d017752da63a1bd9ddf4a6b36d167f4898d3690961ff72221af61c9d46eac8f4e7106abb18b4b489d3cd7ef7357d99d102084bb30e818c5b22c13ebabf1d9df7e09fcfe1715de64094bad1ff6b30b1331280c30de46182e664a22b5922667304d9ba405713802925b5d83426c0a3511d1cb9c329f68382498b1939e7f7acc2dd321f0c72bcbd1a0564300aaccd56efddea3380f3e789b56dabf545ebe757773d14763e65e799b07d9d1ff5ee3cd030c81da82302735cf86f8251e9f5e581a5b13201667c3e6a4e431b6e068625b0a8b9f6b2f0938249c6ef61fccd9223cf1b37cf5b43ac4b151ede62126133cf075f0b6d8ad4e077af10ea3f133f6e8e0ec26fe42c64da9100205f7257302876c347202722286baace38d3877947e6898ae671d499d58bb53be0cbfbd52121ce262afaa4ff8d51b9bdb6fd87c9d6cb3793ed233f3a131dfb95b7f150746b8328c68b6f7c4824b41ec6e7902c0dee6492eda4f0cf8b4f1ab094ef453e63404f7784812be7aff61a603f1f9b0c98c2f266d2d834b615a4ceff3cc18182d24114b844d336a2e3db58e915b741d882d3e6f8b1eb66692fd185f883abf9f3ae7d9977afb12a6ff3231664714e9cf12ba78f5864830dde216dacb2dae8028f454e027a350ae1a01889864b53c8be5f5e475391a7a2171d4c87557e9f76f9a375c41a6c54dc637fec43248861d05464bcecc0d51efb86b553dc78ad35889ed93ca36a68b9a155d7ff09e5f2f6c65431706d9435ae4f4a7217dd7fc793e35657a81226ba7d3064db8738d4f86d327ce49e80c72a4cf65a42eeaf13c0aaa6327328a314cb8d77d5ed364266dd66d38dd7b3f3cca1e61e035917e30e1afe6d845a51a650ddba8400feaf0331eca4e712ed1a1b04b2068682a848948809234ac234a4ee36db7a2bc934aed53a61bdce5c201adeb2d200807e8c46e76fc7b0788f965ba12bf7e81f6351c33022ce829ea97913ded38a934b97a171f36a888780f1f678b7e1f46ae601a07819ea96eb1582946b9439a5f00b432ac6cee780ff0d8059c5329ed663e46e2d21d05ce6be79a340b9b3decaedba044771c507f3aaaa8cf2f3e530e1d90eec1f9da2978ff95b0478fbb1fc4191c125d16d94f715fa7d4f713b1216b69a86d8779c8b9a6f32b989d50213deabee20017d51d6351ab1469aa5b32c42f14604cdfe5af4b122e3a1b3872b05837470ae9f5d22ee62bf8c13d144dc3e5572cd4837aa5070a802a83baa07dc3b9608edfaef1e6a7d908641a0106b724755c8915c042b3778eb4e5bcdeadf897101fa14334d2f43bf01ac106f19c90333ed0238bec1ea7d22be3ff5ed74bdd97392841b33a75fde168c7a4d3902be334bbe00afc791ebb5fe1cd2f33b7cb08d3a28df4cc6609c522eb540e7aa3d734a8fb0f0ff9ebc0ae91816e14b32e22ffb1a240ffcbcbfd0c959b7291a277fd78f4c5006413711920ee81554cfa89e75ea9906e3b78a527822a109929b126a3e0b7a11ba9924cfac4335c9044dc043c394398c241d6df99e85fb8ae5dfb7de779e89f6ddfe9646cd45a73a05849cc6a9d23ca0efc3c6f449c0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
