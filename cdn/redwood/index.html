<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d58e39d7e0a1a7064ef5add75eb65598f89e4d33673be24bb0b75be721096ab6a92ea3e69325e780541ab569d17394181653a2dab10d59ffd342cb259a5f23c142e57d513920e205f38d905350ebe83ac325032ebcc0c3e6db85e5457de9c9370f5633048c89033f2707e05baf056653dfc105042a1188bedec2800926663e206de39093da012ee9311ef65f7a5488dd32c21805abbbc582923344243c17ac05387d4de0e265eaf5482c1c340ae947e3d9a29ca396c2c1c5e9c7a74cd83f71881f963d297298ead453070f2cc40cef78722e0e1e4d83b2c1e8493500319d607e63cdcd140a416cac89aa36692c2cd5ec52ffe6d01b369216b3ec1b4a4fef1f4365a3eb9dbb9feb78a09c525a5e6dc144ceb2e7cc26bb177fac916169b4a595ec271681c8a40496a66382faa26e2cac1a92c700c9321f71b247d1517124962886fcb86ff12d3d76c3215fa10bdfebc31a042ec1e908524a4ab2dae8a98c6f2c9044ab5636c3a3df164bcc07f8b0138262edc9e5db0fade2074b2c12865e127b12a59bd91897b007f2859a2777ac6da37f8428595befde21f5496c348cdf1ab6c7ecb113ca2c819fa7746ad70951b3c8881437a76b711b5ab7a596ff6d0bf596195db553ee685026a7a434a8c24359829371967e7c2246f868adb2b1ab17beb3403737486702a7cab83274677f374bf5f7bb85e54fd91af194f3a31cdf063e0c3257f21b3b6e36327bd718910c9d0c0754042eb9356d2324e7c48f72171a65d0017c9f7b9afb03696ffb5cbcea79c0b806ae801035f461de7385a544f55f00d4d1d1380721c70a6dfca86bfe0ffd88514b79f596708d01e6900330486cc146b397fd2182dbce00cc70ed825c3ed15d8ac03ee81496bf6ee31798f1eb4e8193161a2a6fc5070fc7a21bd5ed87bed759a87d8739167dbda2ba332911ec36257f65c6e39760e29c7e94a704843176180ed6dc140225de702167d61fdad6b70741e76df0ecf2c75a0bc7af3574dd8770c555ef7a89efa242b5bb94d74086e6c5e706d35d80d87b41f449c690b8a235b0b4b53ccfa0ade3aad5d589addf3071ba0e583180be545fc16e0142a4bfe198fc5506f41a9561974780598a538443cbc03efc094a40a5d812215b1d1b748bcae9174f5af3babd106cade7adf8c404cbb61d62695c652b3c429ae064c369039dcccc1f2c9300e8b84b2a14819b5d0e2b694449ad7c72db08d288ba0ff22da64bc5e0a1031c2f6c44f307ef1c553ae26a9079f0dec711cb2ac1baefe76017c8169f13545a2a2581c640c4f483dd21b781c85550a09067c3bea8fbbb26e2681b5314cff1b0a000bb4d4a3ecc2fa3b0ec9027109ae4068e303366e26d314ace6d3b441a3bf44dafe62fc0baafa05e26a29e3e63b22039da6665999fd4a797d128354d18c088fcd9ce5a4ddbb163c1a73cce4c59f4474a23e525b3c2e551c3144b4ad108fa6fb551c7230793b17e13f0a279baa6a3f9ad7735f9911a19590c32f0e2d5ba1edde94a0f0910e44f98261fe66c570f6d8496218811b4266f923da9066b2aa424482108cbecc2c2a839f10fb511c84e1ba3e21ff5e99ba3347d0e241ba7cd2953dacdc8845135817d756247e1cef9fe9234f606d1178dff9906227c3c5494498c86ee6f3c856551c84039e89b39b09694b125f681da60addad9759f6698c7fe5d56a17bcfc3b682a525bbc7211f8cde1de72cf48874dc59fcd629325d587cd4e7d7c5cdfb05b7ebd4d7472ed367363d3bed48d7a8ab1550b4d9395af91f379ff252a6f822f873a0e6f92c9037aa6b31955feb7f77cfd1f99a6be272383c80237d746c7f83d917f1600ff7c89ade654623960df58cf1b5b9588695b24ff2e68c61868347f787f36e4019d7322d3183cc13a8a2e259a7bd1faf31238ec5224ea3facf75cf64ae2e3a415084a14917aca0b799f42ceffde84cd325b161bc4b11f4e02dd27cc7836b9ba2418563babbd5fb2c13135ffaf93ab42c497532870f6eda2d6e2fd650e58e500b705244b8fb52d2874acbc05fab347ee06237bcc8d76a3ecf9e1d4ae797c44de308d279a77a5ddeab90bb30b63b92b18a00d2d7bbf96d11b81f5561fa59b82fb2f89604b94ede7a387822dc4600992a110992ea9057ead2f460347758db538e1a363a35d11c93653814c0afc73c630edc2a2de89f97c5cc2fb95a097c69ef95eeabb4badf7d6ab5e3791bb153840a358c4ca84cbf624ceb58a2a41405a422d661e31edbecd7e445e57eeba317592ef9feccf862feb9a8811ea005c369c467fbda05aea5cf9930713748d4ecf2a6692d14744cc986205ec304d72cee543428785fd643d68c59b38fea77c7691d0748d2c46d49b8a7fa79a196b9431215f74d0ceba76970ce1a910adc4da1039a32ea30138fecc2e4af24425515f074dabf6f91541fc410b84180fdba09c9f9127758db85b887dd042bb5c20873741e217b8b0a576d7d2e2cf4c883ac3fa893a70fe1eb8cfc8cc4dda407f8f866ba632385847415a5ad444b10aa0092432ec24ffacb1e898c91b60a7f7195b08ab2396a4d034e245315a02adc755d5bb353bff69511fdd730ee1ad4cec5d04d0fa9679f38c5bb6cfe1e7dae1ab7b135beb924bec1acad43e1f691b301fcf2815defe60540eafb0752293b2a5a7577e779e1c0854b313cff45119e5d959babafc09baf7c21af0718e6c912ce78545afb6b33e6339ae9a8a267b5b52952741e0a2a85ce661f043a90a70408eeafc8d9ec5d4f946eba5ef3e62a0732c3572ca0585ee8534a5e65c1339ff075d67964c40fdfa36bcdc9989fddeb6a113385e5093641aae948270a198406b6402753d9b0e404b470df729e83c7c00e183613b289fffaf0844769f86e14aeaef357e66cc580e872fcf04787ce36531f0a3f29e7382cfcd3f9f0225228897feff9fd75a0df9951f2620fc9611087f07025e6144830fc393729efbef132be2e1273bf5a3b9d09a6fc54d5fdfb41dbebe24d4e93bddca0a95d9621d3b5fb0e5aa961964cb7ca040681a0592e9737f4374ca5791e2de7d4148ca80f1ac9940fe9894ab8d03a11843ec92dca2e2674c6eb1c65fc33627c41f9fb7a35c3b376ae82f8ce17da524bee1980822425d633c4088820edeed77548d26cd03a382dd088fa0b9bc6c8e593b2867a16511eb9a6921b9359368194cce0c5b89d65faf5e922aec67cd08369e2962e2c7d27b6a350b177da308c1b9558876ccc2f7300ec1bee9f126ffda3f1bf8ecbdfaaab78f9d1e19f7cd9af553221de43a325802458bf0d268c509ab2334cabc5cea22389baa73afadce7bed3a45e1ce7b48c875fceb748d1880d7979ef0141d09c301890c9d896b86746e59b1a90d6c1181fe457c720566e2d01f711faa3b2f711342b799da3979a468b5a26b418fdf6ce033920fb09fdd6928a2a7a255997d35fa98c80ab5af3e42d06ca4415d64ce26379c3ebdb99aca35170fc7b1227ce6e5de93cc1981e3c898b860a5833bb692e7de09f6b67dcc67e313b09edf59e4bec7ebab9069e48651d7076dfe22102f0147863cefdee9191230fe8eaba2734409c8ec333851fa3a0a522efc426ab823cb3292431b990abcf07e609a6f07cd4b57f31cd51c993eefdecd14bad23fec99cf04d6200cac330f2ceb76fdd6c323e16bc8f7d006d2378ba39cdc925ff1f4e35a7d5cdc3b175478fc757d7b3cfbec700d1b3abb53888aca7c1eb0271d124c960d18acf81951f3c07fb0f9bb56d7d33ddbf57a8abff8d9552dab1c692ec98ed6b2eed2158d6a398ef0e8406b23fe0b63c169b218aee7e65bfa42c590ac5223b3b1120464e962d8336d5fa3a8adf339fa9ebac87057571eedfe9ab231cc5014349654a99d1080227d88937432940ed024c358c88c09dd8a1033f8252ceb07d2b25273992bc32ef28f0bd2cad55bfd43c83adfdbab2b5d53e65cb8758b59128b58441a6b78f6aa8ee93d204ad0f2a9beab01f7993a9068e3d10867c974f17ac61d92d9d684b70b65605877e2ffff9f4cc81f171aa07e9d60e6887c9b5c1d1c0c4320770f77c517882fda698161156e7e216af5a76cc043b7a1bd3b6405cc79ed2ae5e0de9e217d8bc8321e74e883b3e66d974cbcb26dd6de5c55cfd9cf89010d27da25afbdd30a9bc77ec9504d8e11e631b27bc856a6638a7e8b103ccd5dcd014aeb7a7c643e2646067dd9e160ea827af8f8f14ed8e239f129f79e8f9821ba6f49250352c84006526efe02aa69bbb932015d3e2ecb8d98e49e8285cd455252846406ecaf7a0a2b33dcf6c143cf8189b6819742eba074153ff8b4cf295d10b49fa60a844f9f76ddcb7366aa597a97472b3963cdca46b358025ac01acf7344204fa640d39a14945d296f5e9ada47d1ff7bf0dbadd9e78b8884cd121a3393490934785a736dc0e234300dbd01992b23b5a10abeb99cbcf2f14f636965b62b00966006ab7ab5e9d27d0dcb6987a59393fde204d55df093c31ad9ef448531589ba3fa902ebab11cb8a25f434d63c5509f702493c432885c9273e0b539e66e16ddb3e9f59d9a5d5203fb196b7cd20df2b6264e7ac7ac32d5332cea299f65543978b993fe591b4948586dc0d4b88e09d5b7e7ce6d6e47a0360558e6d565bbf70da07cf50deba552fae3277a2cbba667f1dede91a643dd6a563416de1569a992272a795711a0c4e531fd342bd5707139fc8a85706f82a2fb355f60eef63e561698218dc1a9a1c890ed5c427d86fccd00db6d01cb4e159ae3762355fda5d4e9267bfef9cfa6cffa55df139bb6c9345fd082d1c4e841ea98dc7b432a5a072fa607ea9e338d84c880ab98c64b60e4a8cee65b97cc47bf40bb2c2183c9b24f752fee02ae0cc144482cd830f8a1651fbfe2950ef2282f7640bd55059a62a1112e42b7b029bf3e665fc3940b3722db3f6172322ecdc167c3735f55cbb18736672f59446e94faa0683ef49795913117f3b542e225cf9554e6b4bce1914f57a3b138aac8264af55cca225b31e364d865dfa8c5bff322046318de978f97aee13e9e3dd0adecec8701930ed1055c5d7657eb27dab02fdd51d5c5e8fd41fb88af62a09e46878aa2305329ab82b5cad1c64ad5ec7323409c902ef8afb27ef44ec8949c63a6224db59527ff2cf51a78046538f4c843c17b5f337d07a60e942777ca0795d3c6cb8b83ef8b2daf426d79825610d87e4cf05042a09cc3b65fcead94f64db7ad671b0891ce5cea91836361e65605147741b289d0efce814dd216bbc2e7cbde3aee66f0faab83074865ae4b8534b4e8592f4ed15d1b7144e516e425b40787c8094d39871a6e8a4e9cd18c6fef6c55a8878d7f53097892a8e451efc7b9832b8e692f01a7a20cafa2b39e5cd7fc1be95df6613269a87a413220b4be09ed57161f26e7423d7a82204101d424d65b26cbbe27557fb676304b228d5c302167839688332227bf5637c909968a22f21e3634a4b3e078b42967c39ab7622f0a92b6e4e8004fa2253fc2c1f7c7d144811b631e75a1d6c093ce64312f6a0db8a5068a0d334df85f238ad96dc50b96c24bbcae0fb3e1e404091abe3cadd6b8c7e84dc07dfe4bc8c4b6610d3c421dd239f0061e4112d8f3ec3ad8a984815758dbc2be80d0dad37079e637eeeb896967f15ae42c4ec76bb8d2a646882e49e446b7875a7b69ec75a7ab617c56beb26aaa625340a052d8aac6df466c4baa5c621e9897a0019ff911897e3c4e77a09bfb8b17d0c363d89ebf54342ee64586a4afaa9fd4fd973caf3501f90fcc8918b16cdd1926dc5332e563472ce44fb879a220f1a921753ac16766eb05565dd898e7535545324707f690aad7ff91d8f6e24db90b108d27f33ee789eb5cba65a8130ab131348e5b93617fbd7ea03207257d5c89d1abe1751de5e1d7aaf1d6e1e653a8af6b7989c09673127d3bb83632dd28f0aea7c128a691fcd720241ee402d35d05b1ff5ddb460daec5670fb630c19ef367af1a0b9a2340b1e581c7663b30880e59f49c2a6f99714f3a5ad7599b257ed50610485a33c6d0c0e9269a783f7d7ba15084fc9be5b6e9a6b8d746193de43964f8b663a179075bd8529924acc56867e0369f0bd557b5328d7d29ab8be35d6a8fa9e3b799c92aa59b114b1cff60ffda813dbca136c5443841d611c9878c7dc76ff9ebd347e8ec4b443fe151ba756b73f1c51b80c7f3d098e8d0d238ff90cbf2b49db4db8983383e31aca7c9edf0e924b83809e3f87800412bb7e44f68aeec19d3fde5d2d6e302e4379d2efa5c86837adc345d7e9a52354b4a7dadd64dcbae20ed570049d9ff59a9b520f39621fadc836779a16db408880aaad1f564a865d3f2db2087d06ac2f628afc62169c9f3989b9bf4c7c56fe5ede48cd8e458fdb056070e3be7b9595e64d94bd38ffee6a8b90e405a8b62ecea0f3c1cf2ba371aef615c61f3be6db099e2dce301afea7631b983cd12f91bb679493e67d2d53903c62c2ca270e3bb04e097c1f8b93be97b8a47a30872abf44c94dee0d5c4fea84c33764647c1917840f86dd194d50961a69b2258646a76fababfa2186f7dd4a11eec32421c139252ebaba63d3a8bafa7f7b722ff788b4ad692b13d1ca094e489552d1d9bb0645ede5823bbdcbc8991ec4a4e85e6c2d8e381afb5ec54af42479d830dcce3bbc6a8240d1b52eb47fee1ad5943edfef6c2fe86eae09a55220711e4776baf26f2d6d46ff4bcda1c3e2ffa3f5c61b62a4cc2f950bc1704b4e8039c9ae6e27000dade68b8800bcb87381175191031151243cb544e02f99d318e3846c681e714955c8f7bb8542343df1ddfc01bd70f548f20ccf5716e84d5ce65a1fbd5da5191a4f4eaf146c45ba13c04385ee39d7b736e08d4cbe94032b94532c180382577fab5b98e7ee9db4124e5b2f9c50bfad19545922918c3635ddf42552fc44b8ba2887a8fa25785da0b72e3e6a7c3eb2e9519f2f8c8e07e56ba52006d824165006a6289e806cafd2cd5212189042f8ab330f3333d97e142d560aaaa1d029f88d07bec8727c8a0e26a3c8fd6d556d52b98b0289ccbb9bbf7256d64b833c7d418222bb3767f970d91b35186316c42bf6d484881229bd700a777f019d3f7f1cbaaba3355204ab27b4a7bc2d4f7699b6c2ed515111ed69e830262da8c868da0273fc19f1d0a820ca8dc345c60c4479e905985aca384a8091b16f057574fde44740a0958171e58a92e115b05e4dee278c2207ec19bb09938810d5deaa10792c47c8ae1da4b1291108491be0cbb88e52eb93fd2d7de71d131e814f1119a980d608baaebb6c38dced5c03c485ddc3c288efd4e1fa5317d21b958ec97661d71efc3903b0fe15eeae1f7b1404fd8b8acaeceade18fe8967972a9835e291287878864253bb9eacb2b2d6cdbc2baf49c2789d1e69146c683f2e35e7eba20c644a4fb482bc87ad28bc0d42ea377fe32c248723aea106fe77227b95bb7d4ef5859d2a9cff46a982184fd6c0ad9401c09551b79a6d6f72fb86ae3a68883a0145317050c9a18b7a8188cb1980df2921dd50eae48c5bd465e7912873030257b3db319d4353e9164ec1709526174997dc71f3cc59cbcd99d0aae8522ea02b18ec492521d9d4b20f78f03fba6770f2bb3e26f15d6f40b84c3a65d0a07d9affe6ff8855b302afb1b6c9c9f1a5eea714948841315289495de88c1fa18ba4ee9b7a929dcaf4be0181c4ad7ebd4c8f2f56b23ee4cdb6f91c899c0b0304dc9b3f50cd36e309c4be09fa3e5bf5aa97205c51185f0265db5456cfa50e8c0727326871c0ca18b0201377dbe459fbc5aeb7eeb0a4272fca06f1bdb9c89fad0e62a3bfc7970874d67984cd43d43a8b32b6d9d4b64d5616e870b05a70dcb7583b057c7a71d4d77992806f7ae8a0229b878b3acc24a2a819a080ab6e93877e5cdda1dbf4492462002669d7fba7110c4b656790705048921f06f43ec93bfa072d250edcc79ea7207ccc1d22a1c03b4148648779d0b79e212eb1e927054453ceb5bfc03fff603423e23757ced230834f51b46f22c8448ecc85665a7db637db36e2105772004005654623bf2d305b88750c18912d2d8c39561f1441c58d333e53e6bdada744c16815c02bd78ac52c4cf8d19889f699a5206b1dca6ccdebe5d0f4c267aeaba699238d7bd670d1ec8bcd96f3264074e80f3c19090ed3cc978bcb27b683ba2ad555ab6e958096577c8ad0967c3cdfe0b76d7bd49039f46ad1d3778fe5ad130022ddf30b1d2868680dc90b1aa3a4b394251bd650a56fe30aae938fe1943106320ad012ae291f7c92ee1241ad468717773c60afd4d60809e07c68000619b6816ae110c5d3d0ae8b3fde04bafd948fa9a018cf753774fccb7ee0fb169870e0ee771aa026c0798ee96e9fbdbafde2e8ac441c81e03cfdd01545af4af9eed7bf5850ff0e7bf25245d00ae77c01ba9ea333c1e21b88d8760addcea0192c336a09a335e23cc07143de0d1f1a1c97d6d04cb2b4128e34f484710d4465b7692edbd114825065b0b6398ac728d5b1f1413ea9860eeaf2ffba970138d7b5d448d31f22f64cb0ce31a3bd19f55a8127587c738ab4386884f5446dfcbdd284ade607a1a308baf5094c01c154e4deb23de79012454c3ba328bf9b29ce4d22bb3666256c816dfae5349ea9a4abd25bfad7abe4df5846500a86b120383461223ed2ff6c5dde7985db4b1e8e4acf2827e797a4103b91d5904a6bc1750da340d4ce06dd6b89dd39602c11295dae050b9931a01dee2c7d6db8dbbe61e3cd71524437424bd381d94b10f3486264b3014c96df24e360345744a6513211ca93d952558bfbc80b70f9645d0c913e38411cbc408707252d5cd7a57082a0adb36b267e5595fd7647e8f1fdb5aa7e91559a574337cb66fb0c806c4b474e208928bb88da5ebce3c609d86056e4764f6c164e4bdb9dbc32da3b3e3e8e1d48dfa01bc6297b0357de61212907829ff6f84d92ae1ca813d6c67500df25aecea046c7acc4d95839ea104cda68861ccead983be7bea5014a7cee87bd1e1d5595081a7ef7ec88bb65c9145e710e7223871137c2c1f176fbddd54a975458adca7bb92b33fbc730aafffe7aa0676f7eb1cb04201849020e2a22f9d876d3c587001b9c051dd3f1753f59cc61111eb6f2f6096e2d5c983cf7a9740f92b42d9688bd8e2301b2695ca4462ffe354c502584aa7c8d95a1a5844d302f120d2cba5d330e0ef0032d8f114c118dd8503060a8746623485cc438ea9b25e9ad234fbbafa925ff512325aa3b3af3d42e3ca882b7d7cc2b3d3e777e1c3a2129c68cb1af2e8347f7202e92bafc56ee3a396842bbd54f35ae7f38d2e7b1bd79f68bd2ef7dc19ed0e98a7fa94cd30b3b5e20b7974a093a60908cfd0bab79ae560f115b1d60da9dfe5fe4ec58c29e3d11781107440332ba7c065136ced24ea53b6b58e77d07d6de685c9bb15e9ffb23d68721fc1d4f3e191452ccdd7b7ebdf295d9c7519d76db0c11edbe34e351a0eeb7a9d4012a41ad400af88fb88067a70b0be9b03604a68045333eb7c55219c7d9e051ca30e8da15a981e0fa3cc19e0e47974c7663724e18df6eb605fec7d2a9bbbc80cfdf3b1ea3c5d2175695f91c40c11e4732153f0d3dbf7917a253923005ef682d366b7624b64653560bfb33115da7a88d2754b868dec9109e931309f3dcc5c6433355929b5f4fadd8d007475d9aa2895a03d5b1389bc7e21ade08e868133d0eb8ffad10737b35cc4eb74341887a71b3f813259b64af834d56ab745b6127dbd82754d2a2645628402f6333147a9857add795039bd0a9a1d9ff702b0eb2adcc7b48d65b3b1cfc2732a38b7a1022c59fd9a936c64b3aedc2980a7fe5b3a91f7a8e160bb70a4fecbf024857145a3f05ef87e6ad6280a11ea802761a492e8206adf59a181c03a59dee595c721da65b2ae23a6a9955351f3c059fb9dfe25ad9a3681c21f6b59e41216c30f9f0e1ffeff5f4a58b9f8d65f074c7b9eb0cc91de4bc61e23fb3880b8bdaf4ada59dab496997f1ed1841b4175f6a09e64edfcca349aa76a7f53ab1da46c81a59ae63b0b2602b0b15881e33f194a5e7cb4af55ab2bd81c98ab01a33064747320336bb03d48b0d19cdeeb8540c53baa2e870398927cdde30c8bd0d283baec0b513881efe80b188fe7ef18b4329f000e59cb19497d7e46cf6ad6da9812b99e5fda6b1e442b2dcadceddee2e34e2cf419c37c8c1a77a03ad14443aef146d99160cc90863015e37f0cb54dd47c6dec3290032b93853bee8477ec373105d646c4d9c2be17db2e1cb312fd0d316344fd6b0b317b94ea07c49bad623f7a93cffde7a3c20c9fa672a4cc0fc6db6392be3088bdf114f8cd79af642ddf87210e02b894af4a3a3a115c782937ceff99f5547899a6fecbf0feb8e3015b8dfa80289f5dcee4d4ece6f6d7d770ebaca2a0ca153d3282c16af4c6e243043970b0415a0485ec055edfb7407d0eea846d208ed478779075ce20be0c3ae32bf5e41abafbe95045a70835d6599fca96f7a3520cf6950e87dbb3a336bce540da01743ba9b153a3323073e4324a6bc0b8ab2b02756db02bf2aad0b62a21a88291411d1fc04a09e5f1054c8b3881550f96f68a55d2d937dc3483e5891a42b2a771083f1bc9bee56e427a4150c1bfe3d7c69cf4b2bc6b0ad0525b5049b972d0aa51bbdfe1619a514b8c2aefc4339c757f5c96f3e8602bf8172a202bce563335c03d42a31b6b98368f5c46163b8f2796731a6446e198d3100feaea73256326c35060b5a68ab4f0716df9ccc2979810660942b8d94074b1a4e834c3387d42845a2056595142e80bd3b3bfaf2e5ed5ae983ad373813bbaf53e86716ee2e98fa0e2be068459aee2ace759a670ceffb049eadef5b6155b08310f4292988ea231dba88ff53f56f61b979966e387af0c95ae5c4ffd3950575e336ef371b085399e91d2e4c94719c0277f2b86f147386d9b8973e23c01c5256e77e4271939a152372de28479eec3b28316681c4c674d8f1d5e0c9c9c5f6fcaa73c60b7422cdf43feadd02ec3a56aede357870207e84ffc1c9553ce2684c7c199437861eaafa693c628452fa09e4f41330e36126fa8b802fff498d4b3a7b6a206d4b9c9abd30fb7c921adf13079616e6659042aa1f730a8a7f078fd4f84a83d38c1659d492106c50215df5b145ace3513bcfcbf4c9498adf3c47af8dcd4019c641bbc34df26033061ec44d589a74fc129dbca77276d941eda1d041c3fada0f98da9623e0f70445295e317606fc2c806ab8c993022c0b16995e148e6c11597c999ee0198e2904bf492863dd5d9a7251f709083647518e837fb7553f8ce72ba33ae0dc731dbfc499e100f6160b4a99385567dd6e8ad687baa88361decdf7c40d6d4f8f0a8e8942747ce13ca524d3aec460b47e0519f2da2a7e8726fe10ddb007b1ce5240aef6947ed9492e2c602fddb47aa12a7e2c839e14e89dbbfb9871a631ea4c816acd5b5bc70af916ded4301fc4005954534ccd967d3b4acdd65d95bc38f81b84dc66e1853cd0eb386399781a2a7dc7c42356bc31c8cd0076c24d059c14b5c836a24286c2668d417ff7dc1c46a4831237c3f2a3d45269edf3383567cc086901b496dd770a109035bd540c816a874ef803d758d8dfd29a645f09bd4f447ec193c7e5fceec2387c9963fc4a626c5b2226494ea2cf7512f20bfa919db1efea2ed2bcea8879db0d882bfa1e879cd8809c1af1078c0b2b182440984906c046d5caffdcb2cbc36b50104fc041769e141b4d3c1a253393ce019f83313e1298e6b192e71ff954d06223191c8998b610752c2ce5a1d3f66b8c3486010c846e4ee0d2ed5155e4f64f705ab64bd64fff30dc9ace9cd459a74871d2c2af46890178205cefe19b2128af5ff85df7ad95f16d9436fb20e6a78088b6a3e44ae57df495473b8f1d83cf70e11d87a1f577896affa0fb27fc5a4031689ed113bfdecd5394aebf12440182e87738d7478a6ae618f0cfd87b7e002f05ef5f3d8ae5e1d20a6168502e8a5af98e1f4bd75749f351e3882f096ecd4112a240dae095903c2ff055cd2c0bf643fded3245e9738b75129bfac041497255fd49b386e55c6b7ee8d4dad40da402da51f067d35991b8b6895b38465a949b3bc1c81b5024a91983dcca86e9332b0b68230c6bfa0522ebb0563bf530a7d999deeaba946785e6e42cf9e760441dec0e1e197cc41959f3d0e26b561e85574c03478157bf9bd39cdf9f6c9dd005339aba8de15556db5b04b042e209fb95743ea3ffa2ef956c3411cae1157f28433f0e1bf0ba0c21ea300e2b0512828b184513ed58aac3a911473dc39a03f2bb9a3e1555ccead6181d3d81b66400ebb4314167bbe75f41043af3a5553f819105623ef26a466c108e232f240bf2f9ee7da51bf867bd0cb6e51b688de3b327380dafa7bc9f5aeb5fab1be05e85b7b59be954c62f0c0578df095135bf52f307ecc5bf43c9eaf4a04d9ad81c3c1dbb3de9fd37b077aa2e8e0fd008f360f05140154b84610e6b58bace200faccad82545c8e4dae8952960240bc508b788260b4aa6273065c645ff781a765070b917bd8aaabfc17c5ce763180912d0b50c5e0babfe2c3237cbdc278c7cab883094ea391bafe6420a6fb6aafb0339f74e7544e8b7111e779e247d796866be6d39d607d5f6e5834cf4b6ec0ad5d2d56ef8a0d04d0b192d7aedb77a03fff20d8124f939e903c962c48a3aab00e7f1ea6464d196e24cfa93a6de998f923a168a93cd350ff31443d1ce51ae7487b890bc813ec5bb2447821d39eb784413381ffbe1bed7ac75d7ee754ff2d98a5a27a067608487b299f618a5de1ea4e01dab6854ce0928e670279b5a6c6d1b060440d7956f5def1c78649cc88edb3b31fbf2ec8f6e7151deeec3ecba4aa0d5fba2356d487643a09c8826de47cf5094608d936478a6fed787b7a8df7e29937604faadc1563c17a9c5f729712ba930ec1856458ea3a47106234cb50f0e9af929c782ad9be7723aaac25946c81699303db29e5874037e1185ee47822c04bdfdb7d88a9d554a76c63adfb1424630900102b59a9a51c3112bd086327ee8749b984da9283de8c34b31f93f2cd28fa38092d11ce88cfc45c4343b489d4a30673810ae2dcca59bfd62da7c2277a69fc00c02842cec02ebe25862de800ed7d9ed27a399d1def5687c5ef38e3da2993125d827d352d046212701d956a94b09256d8c5dfb6b981055bf5653335cf81fd49495ddf8d4f9f3524c5815e6a34794ec86bcbeb367dba2b965bf1aef3a59e32ce27eac38ca930aa90b4ab552f58695118b246b8bfbedb16abc1aa31be38ee9d56cbfe4db1af93dbfd0c97c90a0c117dd4b87d84a69d891b369400e84fe17581e54b45994ecfd02a66256a73f7715fd4f15ecf8a52ccc869d8f866b066aba651bad587111ec8af58b3c28053614c6e9d0a519bac0c8825a3393ff3a66ff474636058c6deca405b788cf9fd19d17ad696f7187809817db40c6df4cf9b272f3e9b0df690c0dc6351659eab67f526f8c4cfaf07ddf447044a57b98783e36d4b1e5b1500f9663181776d59691d582252cdc7a3c5a986cdd73bde5f805a63eb9632b0f4959e2cf0c7fe5116ef40049ef8d3e5394b1100033da22c189dced7fd5787840330b08f031d9097883fbce5b135cde03e2717d6b7eb096c9fff1f88ae697641969071272e07bdc1cbee5756cf8b3ede9dcfc6a082da63661b9633113c72dc077106aba72177ec2225c4f1c6e02a419965807fdc5c94d27050017ed7356a4a788275fcdd70c35e11c48ab9a3f081e8f2ac7baad266591c35d0c40d8fda22668a283562e78aa941164939ba3386b3b78b277d54130bbef431b6194f65a7b5d4859946dc8bbd17183c2335e9b093b1c475b3fe97139dc9fb65995a16a69b75957215132e7c8e22ebeab3b2f01d1f48a1f8103cad79ea1ef4c18f80abdd4eab02fd82578997f588c1ab8649ab4c1a87aa8c72761ef1174f552933f0092cc4c9fb1348bfe8654165002cd6fe13f9ea302605ba73ab955892c24642097b5e7c5d17a55f6d568a59e6cf629ebd4fc9763d24c30d23e716ba1621ab1300ea666286f11553cfb137e47c1dbba776ee644d7368b6afd2a0af641154da81a0045ddf7f3c233e75204e3dcc86e980a7d6451cbcaf1524ea0e3f50738358e3095107c91e0ea26bf29c26170af972a0fe49bd9fbac47110fde37ae568ee66677fdbbffec42818551906ae73402817291753cb389a43c5c2cb944283bbbf147acf936a27f7fbfa1200aa91439b07298648297be39aeeb714ae608646f5ffb60069d3d607eac6e5de160a40fd85e6570e0a2ff93324333c86d8aa8a02ca906669e5c9a5846cfa251ca15d856301ba3ac21974cb948c758cd70ad438ad060b33fd6111e66a031797fc6ec224d6d81392d293068a9001c182c656fa3bf048af99273efbf2d5ae87e38e209385d8fd9b2b50beedeb1422a2801d6ee4151938ea79ff57d2d7d159144405f34fb03fd0cdd827c720ec244a53020a45f46072f297069968700f18805a17e056a98495872e665e66a0a0660759b1d5fe638a4e14c7ed041933125aa320c9df18f9d079bb2b2595f2f716a22e0512b4ebead56bca1ca19c00ef5d41ba0f86bcb29e10ab03ea6647d843bb43aa1290b3b3971546132f630c5ab89384b2235c74161f1ee66184ccd7780b721528fdc9e77e0d9222f78e2ec8042855b06207fc2a730d335b15c2893ea5011d8a49fe3c9576408bafb6b69f7dac349b95cd6bbcd58d7666b5cbafed24ac59c942be715d8ca8ca0da1f6d80d951dd69c327fcbf4995a79fe31d2b5e8c3f08f7f228960d52db7879776ad167305352c0fbb5971162d17e9e024d1576aa841f1631e257001685f695165804722958bf7c00686c058216211c1f63ef1bfe5ecc4cb11a8a264555c6df93b0852eec4ee189ced0c795d9fbd27a71aa9984a25135ed3d8be56c25d49253a4f1e27f3f09509fb1ec679f5ad0a7d759345888431dc87b41cc480a7d810747d5030d9e973fb5f2a3dbaee625aaf78fa7bdc045338527332c001c20960fd5e9652397bdf172d3ae9ecc3830cd46e58330b513ce7cba9419ce0b2796a8c70a01c7198ffda01227c91769bbbdf67b83ade1c22dfe221506e781f03b3830496b0fd6a7484d9dd668f669fb5aa2a9ed041dc88da8bf3ef9f4941ab7bb2a5985eeff38e15c94dcfaf1a994c4f707274e0651efd186ab904d4bdf15ff0adf3d825a548404fd7642a2228779942e0567266b868c7827fd652892f3dd6124c20c9202175223b939f22da12c2ed22208b36793a889157009928dcfcf4261f66cba2dd5d94ab03e6e5e7bc2340040d62108af4311407a45a79fb403bad940edd17161506646935a86a56cb1ba37d0bf4bafcc03096627cb4e6e089dc9f328c0d11fc3947f065051fc0a83645c47218a95c510a85b83e0ab3ffbe3373572547e4539a895fd91c155bfa761c63e94c4cb96aa4f37cec352c6fd0b45cb506064c2c02ca7ef74a7f687a7acd9485939dc9a8a7afc7e3204f1dd1df65b2c202aa9e40b37b5caaa1726c4418a90635b52e63540b37b20a90284cc1d69800d67dbb2dcbdb18bebff0118ba36028051d25a64377ef81ad1171529760a9514a6d188795889c5acdce30ab5ae80b5bd49ed7c1f498bcd1ff9d541a070bcf9a584a0cbc58c16909dde910b7f5bc61ae701ca0121eb8ca66d0d962ab19124da438fe5c82da4b7387d703689ce0bbed9a23335da331d35a1fdf43fe96a4886f4d1608829ae5964d1be6b920b54719620c9f9bc2c895a95018927ae5d497674dd5d594fe53e1ee6964a213cc27a294a8f4333699fea6cb9b145df45035147cdc99669a9cdbc9f5a80b3dc73a9a5759ec2608bbbf53867a4f042d44243dd1136be1248bd45a3c5817d833b09cf863473e4f7852710e9fc1adce9a15e17aad384e2724251a408e2f6041d4a24b3f9fe124d29c901fc3a277feae088ed9809932584b4d064ee769731c03c197726690257b1e1c0ce8ebf8793eeffdee52c75cc2bfb67b4d6629023bce72438fa4cd885385a8ed06f4873cc327567a8facd6f20b1bdd372826741fc4f51284018aea81a612ca98638f68183ff89af5b837d4544356a3dca9bdfcb3d68432c26e13e4219473eca5239bace80053c2b055ae49fcd1e439204bc2a7c2b456bcfd0370219d92e020d13f7281eab64cf7ad30db0bfaceb8e1283845a2d88099dc726ede0be23f52f6486500f8221bb5fdbd91c23484e0210d03a93356144892dc3efcb18b8d9d05e2e4bfcbbb1b8ff4bec9e4398ef1b4346aafec364fba3aa4a379adddd98dcb850002b535b3bb289765b68c1cc3ea1b943e8bda4e8db81bafe04724d095f5afb9b8c1ccef96237375bb5bbb37d51ff74215138ce731d5bdda3c4c120f179f07b1afb95e748c489453cb21c164b18579c74b897aa308ea7d4f23a538a140d5e031bde80667a8cead1d7235ccfe70735819a0b2613ef8f457b3111afe68981cd14f8fc6134853a4e37e16e485f10afa6134664e29cef6d3a8c4603df3d333c6d557c098117232f19cc79b824a34b4bcbb3f84793e93af4ee5d49f6c39eb9f7d8b1b2888c4aa3d71f682959353047ae989b0dc791fecb0e75ff5f801002e943af3b0f9749209f9e876506e981e58c602069295f7ffbf76a75d1d1a436f48f13b3b44ebfb07843b6ebd0158a82d0e376d491d299b8dbec12326725d697787a4a14890570d8dfc025b05ef2261d7f9ae7f999824ccfca08ebf27513d449f4ba296f265a58ca882633a2bae0f8257a2b16d7cf5c83270311adf21873dcaded942abf5cd017d4e240d0cd6c8fb5c7a10a9bf49e8f6fcdf090a0ddefcd038d10bc3fa30e1ff5bfb094e42999b1d2293b7cf8e2780596b599ab5e5cdd9ed355e0eb7e2684049995b6be4b718f61d556924c60a2318ab07fb156f7d2fe5698e6e53851231865a2b7519ad084f05684699a13d6aa685b36942c1ecd157e77f7d0989cdc3e1a1a0af18aa37b42b1b72b99d393df55829425ce83715033b4672d1f867e457ff698ced626c34cb31eb2187acc61784ca50c46802187d39be7021cafa4a6189beefbec3009e05c58257c47485faae6f405642c1e98d32d17da6b5ef4d4f3495db9459f2dd46b801c5cbbfb556032529029ff492cad620e50b3dfe86ca1e6886f1a20f8c0e273a8136ff05651a9a0ec256dfa0f9e68373a21a3ab87985ba57c9c3d8f8df42c5ece1197231e1b67c33e32c5ddc691a8db86ab3775f661d37d2d09b15c722d1dfcce7acc52afa96a6dfba2343fc92815e8bf518f616f21cb358633fae75ca05ed83595c60ef6714b83f42a3e824d2f92ce94f413bea009091258bc69524aa2c90a25a8ad49abb140336ddc464872b4941fcdd6840bee7d060d31f948e21743afdf1b686a27c913910c90d83618c0ab6c128f11ae29fc66a5a7345d2e651e052b957615f60050f84b73522b4a0cc0be41f2f3a7366a21d1031c65ada9a21f65990809aa9633cffe8c2b0814fbfab3b0b1ce1a8509287014c9d2155a6fdea3165933cb9e1693d7f41952625f97689392495d3469ea8d6c06b90476312af7efe2c4035dfa36ae7e6106b84b9eb6d67f9b89e3053fab01fd989f2cd932266004bf27c4aedb56c83a6ad4683486976493eb5501e5b0a623c66b871f71ee47a28ea7f78f35f0b64d2c644bf54e855dbf02c3686a5104214b06adf377f8fdc66f68be4af8826ae7bda57dce63184bf09d8c97eeeab9eebae22befadd63d68fa2b8ec4175457d2417ec3d025c0d3e31262cb6a3603ac408289436d97a3ba3ab96a384a9a3bf5feb20fc08ad70f617a913c4756f215f6254cb358086d3cbc9d1f9f56df6a0e4a9ba5c5c45af4b1b20bd60622f44bda86e04efcb334b4549eb6bbfc30835b5d8f47f7639372e8471c2f864e5e4b9c2513b2685a55d8a52467e64aa1ea79443003b11b12146b164cb46d52ff53763dee3532c4639618d8c100f8cc5115fdf4198a101a7cdacdbe4f28b8dc06d70e22a4c81c0d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
