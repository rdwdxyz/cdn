<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f765a62c016606c30c92e2f675d6c34e77b703ef1644d3d43bf9e3649638de355f4d494a8461f3bcf9b2be9bafbb958eeaf1c5eedac01ac5d55d55d144c7d3cdcc99cae78c6ce090aebc2c5681abb18f56620c1236d80c65f98cec87af95e0ce5c8ee6d83a5913933b4d7c3552c8b904c983cf6ef02d0c64565e3f35c6ee799c73e55f0c6bc354cbb509af8fd12b6a59bbf55e2bdd5b8627647f14275032c2380a868dc627798bd1356df957c3abad8d17c740d5a8d26bd14d9610d3d80cb100315b7385dde357c7b8a08a91f14176282a6f14fe329a17705b35731bd14395b9f95b376e0668b88dfbe122e19595348461caf41d43d662359a029d946279e8a57d149ca29f3e11abd8e6bfe9c5e9f480c6c939b7905aefe3b222c8ea7cde236546cbec940d668148e3ef24c019cc8bd838e1d63ffd91d075008ed72c6453f3881710bb8991fff517a0f6c9c918cb26b59b784a3f2a1236f29c5b05e14e76f103989e7d33c0458f2d818e31b39c50840ecb82af530351d28449dff93caa4a92862f605d2dbe3196e7839952350e58e88417a78114faedcae99a8b10b425537dc1aef09583728aea5e56416c24c877d20e54ba9f5016c6759fe0d7c9dd67a4d899943acd0ecdc93b3caa073f627c86e2adc39b55b9185c2c281720187912b1aa897ef83d724ab2d60929cc12833e2c754f3fb5ba5342bcce12e88c027b056a44f18f4e670e5319a8bfe7f31e2eed0892e45de40eac99706705d7ecaec0d378a0c24922f45fa79ee8d854f054d41ceb9420915c2e804b95ba8d62fcb7b4f174aa382092f18a9a2aa820029986fb24d518d0729a6c7a712b2269689c1e582d3a7766159c82b94bd0c56a2f0fef18e032b49651bba6c0371c5413f26fbbeacff56720f0a1eca9809697a0fbd82a57579d588723bed8bd78e44510b013b0ebe174fe16103e5aa709aa95dd9b3536262428c536c9b232b2aa4210b7a36958400865b68bd22be1a2c43a6185fba30ed54fe00ae3172860c39361bf548264fcbe7dc94b0a11369ea7501ad0209e37df23e653aabde664ebd5d7ed70570311e267c26269f9e2cc42953a847a4b0dcbb5be40a924f0595552c0c07433788aefd6b7a00a48de0cd28f0b32583ca7dc0c6e216f1b5511de6fc1d815cbb8b1865bc8c94353cf3dbc4ef46270c04919e179614b9f9a6c8bb6b1b12ca12fc0c9427634bc7d8d527d67479aacc714d82337409d8c44c182201dde49405d5e8f8d9181d7c4060e6753113dcc287f65d54324c46536fdf9fa4ba507b404821a3a50c5e996230e1c635c013367bb45a3860d4acf298044ef5126f3206d82d5a7da849d152235805b77fa92eb3a706b1f07ec91746d9ee61a2911a4c54db94c56c0e770f163117fa2856937a239fa70eae2f5ce5a391a421679c633992b691ed5395a2ea3a9a5a62d698e58860eedef1cb5b0091f7979bb92fd62bc8aa7c755a2ed45185eb9abff2b82a956fe02f4d78b36656d2c79cb7bc76975db6f780d6b66eb4f976658a70bcbe9f36930b029a09184b8c61d522ebe36da70cbf9ea12bde65ee79dc7d8b4385c4eccea6202066733ae7de1b84ac750a8a7a479840ed92172e5f1134cedf34ecf80d21d716989f6c25656bf31098d9e67c9289981d71a44a05bfafbd1de5d1db146c65baa388a17398b7fabf0884e1a4c93985712901f98ad1027309ddf7ac894d376492282d1dd0a47d4529eef83c86aca5c8d7362c39a6565332eb18106069c05d747a2f4a2d7bd9941f92c86d37a53f3ae59fc87a902e1b02db75c97ca929075a9534743e98a23c34ce8bed4df666bdcf0bd3f68f8f8393184f1d00d082a367956ffa346a150dcdc5222ed3886d5f79660751be5b0f9d10cc71638129f9bebae548208b287afb7b02a2335553b98395f3847d077d0eac975118cdf701aafbd73ea51c76e83b5a0427818eaf01287d4ad972b5c7599d4723f918e10bd66e2c7e73704c25721e3a55d2d5e14f81895cfc2fac0a8eec819cc46566184947967e725cc5aac8d677c93b0d7e97ecd91fe9f75d48d82a34aef1ef6729a2002d8345db688415d907e93809c4e75e3405d81d0e1f90bffeddadf5a50ef595389ad77e76cd46a4c2bd914ea750cbe6075bc497fed6d953ede7d9c5429dbe0d096a05d203dce34cb616d4df1587dd0a9f897abcde45a667281f8c26fade6f4195eb8b9adaaa29c372458b301e3ebb22100878f3627e27b171ccef6af700fed51527c0d10077deaef4dda99fce3d2b844947ee56e5474ec38034bd3b7c5f92e832a524ae731a0d18162459f0f5e25677f6514a2f9526574534125c1c1200335fbcae82473dc757579b6b9d457f3229fee3e75eb6ee4ac159fd7b4a047947d61a352026e89e9048f17bb60094f60131206bd4ab7bcfdf36be5e2813ef9ea7bb4a0b57df6c6553a2c0c444073f534f7815886b3592c8473479065a237a5d9c7c5c53fdf92f0649d5306b55c70d275ecd959cdac72039daa95520e2ed5c813dc73e5ef14ab8de0d24edf38ef9f5e823e0f0119d635c24843e44ec3711b46948308dcc83806f75e47128ef03e9f30f9cd04a3f967b999f021e452dd8a84ad5be421825957e78669405d4666d6a53456a21fd983a02ae157f52676a9ef3d7fdca6a1ba1ce68870fa1885bfe2784ea17a0a6f45953dc38d63dbc8d0f4fd1b8bef37fabdea8ee42b0d1cfce4b3e9455666875407bc414d8dcbb00e417d604b01f2d5fbbfc4d49437a48d70465d944729ca6c9b57372994ab6fd3f30edec6e989755fb55a3dec4bbcbbac980ae0419791d36144ee1b986c51927ac079a5962793a00741fed560f339f0c4eace8d259c45a5a163bacd62bd2ff0266991e2d61077e953330d7e4279058125d0b33a5564abc4b7c6a50f3e21a5e6fb4f8c123b4a57cfe8cd782b2f2603ccc59935b154376ccfda9c2f38862d7c739e2b864581ec1cf90c789167943e4a69452d09abd3df5805fc3f4b101ea8d1e6f27f1afed579e642d7a165040c87310ab6306ec60ab1cfd8b77f0173cba5c95c5ff4a27b64fb6eb4e186764cce845321ca5f2d58bfaf72219e51451686c19f54b1637158ff21b8ece5a09d39315c17df75a3f30a21093e32a61bf582885afad3fddf1261eb682cb1d6ee608c27396c813455c27468e6046cd19337c6e201e5b73be012f4a7af0bd485d624fb1d849c578b04215e1bc8d48e0d42dae45cd65cfab0b48241b9776be87a5500d9b9e728a48e6baf91c1efdc6895a73d6bf06f6db2a38d89a0a97e3177c71af9b771b7bf3b73e533501653eb494a6b473c48db3b8a1d282749a94b84364eb87f56371e6add49223c71af834dc56d31d5d35049b0b0da290cad5d1982b81909e4fbc4f841d5a2386d8a38b50e447de94ea88bd19e1aa1041c67733f0e86edc91bc3af571851c6ac8b9f616cf4b777a145adc37d510c24d31fa6e7f9103933986bd6aa6f74fbf13514d54e930974740c350a059793684d492655ca1bf66fb99249b067526919d00f2a9ded4579bc68853535ab46a5c34afdf8e5ffda6ccd63e21ff2b66c11b098e07da3b9fb6180d34a2cb14da2dc970e3bef9bb21d403c62433a36171525fb5a92c4b8e39270d5c5a4f9150f0b721188246abddf929c65433509728799565608463ac26a87420e7cac0c9d173a633755dac3f9d1929cfdbe40c26ec11bf1ab788571551fbb312418d089524399f3bdd260f2fdfdf436f59bb71790f7bd097e365ee7b3357b28d6e3585545bd77dfe84ded2ae62d21feb272c1e13c9740c0053191a35c537c1ab7eff3f4a3ad6451e9270d789b322c33c41995cb5b8dc640aede17ff756d9f635e41da68d0ea839da198148378805102231b02b7505c5f4b5373f0e2a69e1de5e5bd5801adbd9523c74a8f08870afd4342d65f5dd884fce7dcac91cb468d804a649464e61dd48329dd843a8cbb15ad1917a1eb9963054e0dbd883d91d1cad677496bf75d736c6b33596c5d9faac710748a7051c7c7a6ce928dee1a7f2c8bb9944b0cc706e194ec31c9f54cd0606c6f4537fcb75900bf5c6d71aedb4a318edfe134f037f6d64beff029fc67a258eef1b2055376e8f10961be8cdad3ae8ccb3af5448ce49d680c7568d4593f519157155f42a83bf7b81355738ae4aebfa7f199d1155ddfd49d95f1dfd4165721f22bddaa54099ce276aa0cada36f11dbbff08635abb897b8ebb4ca8c98977077a8023d3748b0ee63ee6542b785811d6a0cfb01608a7411bce12b0077ae6583f2e121f9d8d1326b5531502497d5a35f2a96a0cd48cbfe74ff8fbfbf7c70a628c42344c897a2af2dcdd49a9958415219eee500d1eb1c32a9379512038816baee344acd966c176e5b33146732bf73f13cf0b38a6fb3e2ef03a44592c89e6e596ac0fa4922674b5e899503df35e611008d6ae6cf5e371d9db3c126092850e2cef6ec43f4a9c4fd93a1d7f0b1f4f6ea1c41a7d0a975a160621eaec0f3a7f4ee67cbd2079be3a9648ae0f213750214e28f112373fb16a258f81a2eec61fe9be09ca1dae861db6d65ac84f1b9c7fb7ed5ab2adb58083d879149553f586d9e7e0e9df1de91f3ee382deb3e5c9b6d322d72d43ac5cd3be4c804b80e4571521d831602fd1fa9bd4ca40cbfb3ec1c097c217841e647327e810638be50914a8f908d5de99521d4698e69b0a831b453fd7b1414f5a8459e92eeaf4c03924f94e85d9254caa126eeb62d88efac0014e8bf5e135b631281f9261a6f8a46f7d2a70dfe26c04fda55b2b5d83e994842ec645c202b988ef8671044fcd5beb08f55c5f97b085050e0bb1541b802005a7133b56cfe106f5f911d80b9da078ca8478eba1c1170d8a777f44f9ace374e6fa6e1438eb685033c47a2926751ab7fdbc4e5c701ba92da5c1caae04b6211c99c268983751c85fd5414dbe854392090bac427d256ae501d96e48317b9f07c93990d16d5852862b7396c4407cc9c23bb01c1042fdc3f364423e85c1c73315de481ffc996bfd349b96c70557ab72c30d5d6d7b72f18f37327dc07030bd1bbb75bf2d48c60a270153a0259153fb2d8605983c547a6ef1aada1533e8d858ee064620b0afcf4e49d0fc275cb4821ba740b7570051e209379e9cd81651037bc025562464342d7c010bfa5b030ca6259f3c64e79dd9ba892492126afc9ccb2b8a2dbd2bffa14cce9ed2583c22ff36e801f02385290ea6f825e66011bca6106e553df4e65744dcae680f529adb41d35d6f7559b78feefe8bad3bb77a247aae86f23c104626a73ec8598cfe8375f82148c983c15b5000299d587d955a86ef99d5426619e4795e82499838d68bac6d998763fdb1ae3173df9df2639eda1584f14f38b8bf181503daa48d4e51602f8dbd963927e6b04c267d3a5074c13c665f62272cbae38e5c452967717aae65b0a923ef8a276b32c1584959baeee1b324b695aadb307002e0446653eb362e3aaa49551191e88c86aa6f239acf0cf733058279c936e18fd60c6c66d7450e1897265758d96ab3075e8099d078378fe0bde5d54da8f79abdbd0d481706403c3d291cd83362323bc464a179b3f804541167313ec03a602aec1ec60e4a856139f4722e3ff8d4918afaa24e50ab62da763f2b007a38cbdc45a9ff6a63895e817982ecd8f71fac26958f6cbc29a968ed23528a1fafbb82fdea2d540eb358c08ca006d5d7dd80596c4052b0d857cc67d173c94a735068ef815a9bb9671731cacc1f004ea66d1221aa8b13ab47c6b49bbed3f23903cc335025262d7bcfbfc393f5482f96bc66eb89f94bec608742b2358ac7658e9ab12e61013a6de43c6103e8ac72926c20a12219a32717d63b070dd309eb59091d7a98bb3d95a24b4e7db710c71a9ab45d470e18ad42babceaf1986e947cee68cf5b7f7f770794ed410f21c9be82f475c0476034cd4a527a280b5a9cbebc4aec4d5fe55b31512a786d676aebc991d32fe84bdccd12b73a2085a9c9d6546a2853dcdc5e96c623a5ee3a15d147e1eb9503aa50cba2bc5a2224cc9d5985cf682d510c68df8affba268ba7721d9f56274a51b320b0ee30423455b3852c103b2b3add45dfd643be883ace146c03d6b373db8a233ecad740d1ca2d5d20fe0193177af583cd23cecf816cef04a0fecd61c8c76d3c2407999cae71feb0d7bf083287b08c287ee9a33278c1d394716a7e44552c1a754750dc0e9c286076d0844ba5dbed7a546431463c5629d9a784af78f3063dbe8227f27b77686577c175438c00635b6a31bd805f456903b6d25d4b3e0eda794a19e9407295af3147ab30b12ff56497b1f9c2f41ea89de6b1f22ae90c797853d733db6389b884dff794b2089597a5ac214dc812dd2c3a73a370d69defb6dcad8fc22bbc55f951a13bfd0018fe800ed9449a16df7356b9028eca84f026ff738e3c95c2c632b07e26a1f0e48462cda9de47854b2cbd6dfc4f1fda39e9818b29290876272bda5aa0ad350327ecb5445b34c296052364be96201fbf7200d21fbd7a3cc5cbe306435cb41d882198f546551639c29f69bad47b8d3fa877ad71b7cdd686841bfaf24c65c1549393c9914cf99805e428463ed9d8a6831ef4175accf6b2af62592b2f0f870c8e12ef49a50adb8a750a0d264c9bd41072bc1dd2bb433d7070264642302b5e8e1f70e365a85bb805e121896199ffab1488e8a5a1fa68a6da47a5e6c37841fd5af7b42256580724a304f52560df1ea169f1939ea18a8d844be7e4326887fc3936872757dc9419baddc4960920bf6a78d26444ab87e6270bc7bfff023671e2a55615a2b17d89b258b7a47365e4f11396d20b57fdc830c89d758e650524dc73ec0a4554e253a1da0e461b20f4867b9a9ecca1cd04d889a665e74b031ea3be4dccef810b264f21e97d9950ca573b716484ca3f5bd4e5b190b188d3032e691e522fdf14bdac8eeb29760f2b2a9733357aa27d0e7c76ecff053402afea95bf76785498bd284e09964549e090855d28d8d007421531855f6b685551c4cddbacd9113a6b9acd76fecd841c961b3ed95365016708abf441d7eac42b18160acb22eae36fc1212ea3c10849e5317dfc17a4d4f656ffafa660af92e2dfbc8e8a8eb0e08c732b2006ecd13c4585095380e72faaa68178dd293ce8743fd4159f226ad49e8274f4a8384e12b8f9600501c7c522b2b6c3932ea569bb4b574cef8c3e2ec5d92c35c06c40bc2101af0d5df7ea94a71159e6aaa404837f180317be04a4523f59414a42f09a6d9e2344056bb0a5361f309ba88b06b94cb4a795ffd9e2f44aa09b87e5c7b5bee8542a38db52d886f1f97e2a2c1d0f25661ae2a7c84d0827b17c1bda5dcbad0b122efd4209a1136f341d9f4504927a51efb8944bd6070e52b9dccf5a077d97bfac23ab4c09b6df59aff90218b189f4616ce64e2f892390357f188009e026abb824bed276ae4945bdf55476ccc8c525da6999809dd97812e28112dee1e51d52ca654ad3450a1d7e8dff3ec17911bbf8003f8d991ba206d057f8f764e5ed22abcf70ff87625fceefa13f8476584d21c0a5d35e638dee26eac6272d13b67d82858abbc0cf11709f5c9e3d0e520026b5535823c38b11206b0ef3c8032fdd5145b525220e4b188976460581028e02a1003380c97e9e8c9be049c7348f2f06b11dbad81ea7568225691d1aeec49fbfb1f346f864f4a4adcf8314b19d4df58d239cf85d967c8cac809168801a18d8876e5f93481e5f3c402a729c0ac8463546da25cc12ca992bfd3cbd62adfd0987fc883696aaafb81122c1ffdbdcee0275741b48d97d19ad5e529afb88c36034421e7453af1139e7db5705bd275537fc61f825442f988868c530a435fa1329d13b0125801d6b8649fdbafa183705fe90870743fcdf4243d11ed7a1976573120a2fd9d9e9ad10a99e987e0cec856b21a69f08385073007036793502725bec5ac94a250d3359b89316a2f1cf6b00793e44f72f3050e3adea4e824bf0d893345ff4315a66b15977a99350fc0954a591496370f6137ec55df864edb38a3a8ca5b9555798a1f06cf6fad627e33d69222ccbaea5cf1009bcb6f2a3080a8c951ef8ef4a2fab6bf02158ec4d426ed2a040bae764a09edace8004c936979e395b1da6341d2d040772a3dfe40fd67624beb44f7b9d3479d771c03995f5c230ddb859ff1547b4ec9bd7a3828e6a21e26bc375af182a36ce909b49dffc2a58da82398e48ed627a5ebab5804d77a3c7ae7c3fa7f73be43f6b1727b676df61a933dd8ac59480a4dedbe771b52965405d8c2291ba7360342b6c4e727dc751c9d95b3c67ece853168b682815c81f60822986e857ede8eb137215b5bdd660b0944ebde57fc49a90df8f13d35e823ebf658dc44f7b5132b6aca960724a23d875ac02622c08bed96ee064081837a631b2071d445c0a70c603f34a12a2331244c95b6f3b5b7fb10125434fbd3c4847c5e38811134faa72eaf2282b479ce6407593544ae8ea0e6ca15074876e537d40ed739500ac7a3b8cd3aefcd67a850b2ad549502472c16598599e590af0180a5c2e5d8a1628fddb295e14c1096510ba4962a52915099661d486d7ca558e417aebda5f4de18871a1dd12126c6cf95e45c315c386a4779f6d0c67532e605043c27c95e0905551ecea211ce35d40c095a5badf33e6f71fad3fe7eca9d37ebb98846f43f47eb1eb80f7d1978913bdab86608e7e21d574b26dd591ca11da7ed742069eb4152f5fb3a44ac8fdea86fa32fcdac5715399057d7d962c7da426923250b7118808483aac55010a3c33fc4c8dbac6867b229a704b02215fbf1638a5c0bfcbe1537fb3a4c60e944cfff49fbff5c3ea017a132074978f23f0207eef1a8ddcb3163c8b6dd3c84b71d896175f5455707122b0192a17800b9fbfca9dbc156ab0ca8332e73031835aea77b44d59215eef4ad2f86c642319bbd5875aa3559949ee97be789f999903f337a6f3cc71ffd1f621e113078140083682c91a5718d0bf2123c3fd8896ac535413f89d3742445e79b0753a51ed0fee8cfedbb85e447c7eba67954be719dc8cfb938a6476fbd5c446459464997ab897d27c6e20124dd77c7ee092abbe29b2bbb8ee31d823f030d4256ef8b52825b0e85b6f78ceeca9bb50e6ad8398aa4c0a50875eda5d91a958a396559aceb25c2608f4f10dabaabec056fcc6170969c574b7d700b3c5d517556e8a7f9110ddf77dd916e78026ed84216f65c5ead0cd0200e7257fd0b31604436594986127eaa0d00f0f716e397b5a59d66aff827ddd530ed632754306c35b44e69ef396819afa237dbbcdde7d60d3ed3f240ce39584bd26ef2390dd71533faa462c3f03687960e778e352ee226f26c21236e234816104d05f4253a20ddcd4891f0538416e4b8c080cdae8a5c631fddae7353c2d3a2e3c4f2e98f60af7e38f0e3d1ae888bbbda5420e68bca6159d4b2bf9fb8d76b26032d666b70c6963dd8cdc6012b0bb48d413b41ad373d741afdf17dabb26f546f1e9f6efc55707924ba5c0f2dea81a0e7aa3f9db385b1a54d1962f7c96377a02ae44808b9c71ed1055c7d311fc152c0d0c7286699fea95bce606cd730b45b4926ab3d7e79ae2f15b39566ff0eaff524c27d8f84ab46841d1c3a952836d7d00c8be881d6c6af48d037e5153f7f2d0d4df4445a2d3b6b862bc32989b08044e23de7a816a177cb22ad3165fcb87eef2f75f2643cfecd0218e9d8ba483f37edbb6a020ef8a658b4a312e893795030645ca8e08fe8c805ca14521c38a81a1504feb6e279b1193eb101ba170be30033f3bf0f975786ae4cfe52468ab3ea8ad413cef982d05e2d3afd54c3f1b135c95420e07c3d3bd57cf21aca515679db4fa5e0654c4672ca8273d8e89209d0ebbfe559f00d05ed3e2b2dbad16a0b702a9ab797733870ca83f6c6209926de31e266a401528b416239b59d37b299de694673fc0f2487f964fd5108a1fbaeae0397cec9e379c1f33bc1aff6dc22df64e373d5a0346debdaad19df299e47db237a8b20e5ff136726fe8b68a36b346a7c901ce92070e8d0cc538a7469c1bbb30827006bc7bed734df1c41e942adff7243e538e2b7e61826431bcb114c7e2a0ecacdf73db9db21ae38c3b31f9c1cac9d7b656d1c997306cf4ebcf8bb21fd01b476a30406d035c2f8910a054f11513494574e3f5f5aa328af73bb5aa339e9b6fc585fda9d09ad3dd591515f83b80f4d126d2ac68a6d6192bc46109006696910f42f7d523b21a2b5f77f830961a29bd9abc4834fd459442783f79fb51e69ccc3206dd9d8632d2fdacb6bf73eba9afa10055fd0164e13910fa6d424bd80a32c662d9a909ac7e898956eb77454a7841c32f19c645a9cac77fb8f803862f948a724dd5968511462c087f9589a6a80773db695d3b1a0b0b7014253815c3cf9f4145f5555a4e8462f775c6b445e6ec702363627aa3a605e1bb6883fa505d0cc6e625c54d9f0cd386f7faaafb69fbb4ad1ceb9901a62f5e768e0f8cadd8eb525745e32e1be78fd87b931533f49d982090031edc7465f5816e28b71d10cca4bb0d212dd2c1788ca9758b49b8b1d42003f6b48dabe56be640bf334e1a9c8493d6f6923591655c6b43952c6eb0612626541ac6b02177ebe897285eb4305679e82808d6be491e31ff7eda0adab528a24cf941f555430fcc6dbf3be82569056ea35e704bd84d7b549cce892860b194871d61a5a491a897d99f064d844129b24336dec90c097ec37c23f2cdd71e8f6c4d7edbef104252d31432d025b1a08122ae8e55a35d9cb3639ece5acefc0c4d8e0d0cc957a7ab9b7d158861070be9afe0d00be9397f010e2eaf0a954cd333c9ed4b1a64fe19d4e33a320a14d53461777bfca81a79fa004cc52236ab984b5ca1663271938c82615676dcd4b53b64de0ae10fd373f261fa6fccbb14d60d1d39d62610b405ec91b0ca62a3f0d749f13c664fd1e7e08f6885a2ca29922133f4754082ba9b4844002b098fdd761d4e8d1d3f7f2c5de077dc93f526ab212a1d4aa9a9b3ff9b24c3efb03767a9f5d5fc3cbaf26f40c86bf33b3885f97ed5d152b44ef205f8898d2d7b1136c0874b8e2a8b9b6115aa9ace28f3e3c33509318667d8c5383c86a290bb2e33044de5ed5950d75aa56597a9ccb96a9c4c45daa4c2fe956abf82e830a557040c3d5ecee07c453b7bddc280ed8711ee2abafc199e142bf570d53a4f33e69bb2c9298ee03a0330c0eeb8d6609ec6263ca6b190032e46e6f4194f4d66b86c0ac0b69ac15d9c9e1f774b660159e408700bf8fc47e217b92035453136b79b916fd90b689a1c63fe5005adca017f159b41db9ffba3679f30db6083c3415ebca472332812e14f2b93d0a33923c543d1198c86ffefea6e263a0071089aea986502196583dd831f2d4703ba7fba8ed36248e1a9b8e0a25543797282a687f991138925b0458f78041cdb88fdb32972bf931fe218f2ed77dffcffc56ecbdb7d85f2736019c8b2c33ea5b8ca90c886f9f6ec0bce3a35c99c96844196db4867a1a34b508195f713d98b43f19a790f9db0282792c76ea20b9282c0db0191142f6967f29bd2f99327862782670a0547836e45bb3b2930521edf7b20037101caf9830da6d2dbd4b22f097bdbea00a2467cebd6f965c9ed7431d86a654ee455ad2087b7988eb41952b784fe7ec382ae1c60995325fb57d8ff5802ba442f84776b2e83f51708092759ba45a4bde8522d93b00787308d8338fb08f466f87caf93d55871d4b03de48c88b1f1e745ed319245d45a9dfee2be315deb9cd1612e9756d4fbfdb4191dab7dbd0c09f95992841244e35ab83657fa3964f7dcea24720a8acc4c813ac172176f7c5e4c60e02276b1ae73c913b398296f54f358f238d11abbaae1a1c73bb50fa59855518ef72fa6fe05a83d848ef13ec468b6514f3d12835d673115b4a4979d759446d86b21ee09e0c7f307d7165062e9e0126fdeb4829bf36f118c434d334f6a5fa8e54bb90442587789c214002f019781407f9c41c7f6a6b73b320a8b5a99a5f33e427aed1e5ac584ee8e6562562591e82338acb0c4cd51e2df6d4c846b97aff33889e453120d77aabfa2c9421f2affeb556839a112b7bc2f9dfa1c985b67a06b5d57fd2928f05d258f7b478a2fab19d16d0d973e1b326dd527431f631a31f6c5ab215b0c0556b82b32e576b87beb4d17a3887f3f1a8c44ffbe65893c69af517d9f50acaef52fcd2fe210f2293e9cbc3debc4495a0c88beb81229e7dc87a2b9df799c0f6031326bd5e4310c6ef2d4ceaf1ba4c6d65218e45de8dbbb0c26311af1eece194544544e2517cb248b68b312b39ca3687227d3136c6ceb95681ba580f79f25fdc0b32d2d6574c30986acd34d3f562a569724bd91f7de0c35eddb1be7108ba40015d35bf844492d95789ec7f79fb2cf1a8dde3d495d79713da9e44c3dc74a8b51f16b58a10903d8b3a898713880296c8ca29b405e34e54c36e09b8a18f4253a6081bbb23b7201773f23b7efa43a6f69ec9877b38820c0f61889d47306b47a63d6666901ffe28ef699ead8686a14c13f7097ad0e9e5b1ad76c60eeb4278e77b0710eb6c19d7c3e564d01b5b60a48222d344fd00fa09939b54f260eba88e68022aa4d226e06a96b81d205d522c83d81ca75ae8cf7241efb6ce7345bd916a7b38909d8b87262c2e195f6ad6e62f1f5e0126889581cd26a77cd5008b14e4f760a8f695bfcf4b4eefc1bf3c55ac42528f613bd27d4763da75af6d8c8bb9d5bb5ccba55a17a8d615992334d523d72fc62fb076bbe81d94f5bd6ca9ae0c0c094b44c078dd8d80ef023d218b914a5fc1eccb7607667f14a8242d5e12ea60662526714c1caa0174ebf1c433e7773af2c5f1775ecab42ba7132af51a1400637d69a6dfe1945cd4be40b1b22d53b2176f36046a3d2aedea121e528d2e008d8957c0c6a3386d820785df9cb041fba3b702f12ba81e536c811bb231cb3f9a6a251613343031bdd3680aeaf12d3eaa85cc242d99fe9c9a0941419ddcc6a3e6c94efa09610b1e3894249b09dd033e8c0321755307ee5dd019add2a49cacded6bf1cc72550239685e5d41880f60476d73e969ef8ddc110591e87f5f7f010357115e19891b25ef01387ef69cdfcc6d880ed2f51402c89f05ce73e337e34d47e156a84b528b892e6b751ea0e99c831efb8492a8072073b044d72ac6f98b80f87dea0047e06b87aff70cfc466a360f2eb2207a24ca8a4ccbddc1bdb5e5fa6912622fc0b9e9d246750241c901c68c71126e2d5bb016f04ef556984d4bc2d33ef44b810cafc98fc63a20a02f5d80d8e0f02c9ae81bcbf9f09a0760bd6cfff924660de9dcae021563322d8a1676256460e4b1df80fcdadf91cc1dc0d98f622f62f8e104177348e62a83fc41318e5a25f2dd56456151e283cab950fc5d94192831ba9afddc0aa2416eedb80146f44021529eeec837d614ff64b2146020af9a190c1a026236e017d01adb6d22478f9035904a5c9d7ba87ed2492dd115fb0fec8f5351e99eea20d89439a305d132f6f72f69a82a23e38ea5bb691225d6bf082f4c22e66afd52b533d497c7305efe52c9c228797643067e01cc3a2355d690c6700ffa4301979dcc229e0a8fd4ca6ba56d8001786c6771a5a217fe282935db46b85cb6f6b626ff6971e055d943dff2184ff3434a6261487caf04c84131319673fcc920e47eb3981ff8dd3b13e7804033396cec6d154244354c63268d42f8da0c611890062760801003bbde311bb9896f85d30cf25b2ab57ac542619025fb28708af5763215460d99de9a5f507db49de4cfa8ae0687f2b60d1433320731caf628b5cc3ec1d5d0adaff5d1a80c848f87dea4ecce98222bdc3aedb96af88e9146fa5447e9dff7a9238462411d023a8ce5246a2c039e2a62d37a45a325b411343a1179d132d6e382e4464dbec113335981a47d83b018f3911df9829190ac3c8e96eae4ce09775d701179c3f02fabff33dc1930fbe9ffcc6045c5568702eb02ab8bb01a106e29cf96e5902960ba73a69bbf03239b64eea75b2333d5be876d20c57a020c50a819a23cdd0895768eb79a588a52040800c8025d82d1598f1bdd7014ee070181c62033f04e06953cabe62dc9ee1dab99cdf77b844a6f39a54381306703f1b395ef5adb3a6d0be9d64cb4125ed53d2d4c846d6a9e7bb9ca3d00d06e129228e3d21c143a1cb06fd41e8eff16353e0865e9e9c12e4b5710acfe225eb970d7ad27787ae7897bc76e1ac966edb529ee82230ac06c185a66dc36c8f2a355c4feab67b0915dc2ada9da12141429638868c464a7c918f2166ba3d7e1339907765dacf575e466d28f3000de0ad0ba37b0f8804d7b04b903695a03b9bf97ff8cf6e78b58fc7e6e0cb3f2d56a6b1e7f9d8f90eb60d5789fd63806b2517ed4768aff789613352e14fa6e46e154c72484391ccc14199286fdff92e84c5703ce1baa3d7b685dcc00bab178193a772eaea74ab699dcee6efc4283ecbb5aebff23ecb184118b94970ca0ce7059ace2686e2ae1d9c8e47f376326a368f2c0a55decb605bfde624d8a6ec22cc54543c6afa90b2f203ee349c8674e9cf3c5a990e02a0e4796ec5ae5c1ce0c82b888c80ac2a1ff9fb242d0da3af4349a2bbdc0a7991d62807c67ceddbb5ad40c6f90c5cee87961b8826c72a879296c88078303f7ecf2a04597905dab7239a316a4c36d79d10f06c45422e16b617dcb4b53a4061a6a90993a1ff545b2e3cf9b79c2e47f3961e31eebd0d2229952e92b0cbda3907d29e32c692706c40dc3d5942650b3a8d8bbcaa3c632fe459bb2aac3ac055e638e6a60b844d883ca26328d76f5ff5a7f04d5b03473006edbad16cefd5fa8d77d248dd46f01976176e217af21849d54beaa3d598cd9c08e52baf0633bcab4a752df45c921f20ada0ae08501d58b171843808f813d83a366fa7d83298589dd45b64cbd611b74c5a2bceef5f3964ce8bfc504c253d450472c7029953a6d608b1df25e07db09ed4c18ee12cd0d5c5747954d6dc5370678d333222a73981526b6ba00ec8445d0812b8f03aa1f36829b033947e57f2b2db3a92450e67a79271b4a0daf2116cd7862e3559c08bb2ed33c0cafe5956dd4da26864fd4c4637ca1698a744f2fe4d8de0a0ff2e39cb51f98c9fea1318213259c28e95c3448a2123e2aff92621494d3ae6db2e52eeb7e724c4e96cd081e8fdc164012cebb96e44e07fe086541cbf225f10c76146c593a83ab20b8a7fccf4b75db5c7f38bd2512ac00fa96f4f02775d8f2344cd4387838803952274e5e0db1dffd6f47bdc1484a5f32f1245dd7ce00600a8b478295f0b75c4aafd40d509eed17f0aa54fcdeb214e2c8de65f791f021c033e2f4bdf7cb26e7f27b7c79421a10375e1d6bf8863360f31a625107bf2b95de3c4ca2090dff95c6a2737e91a19aa61693f1d96a61e4766458cf6b33968bebfcdde0123c6c1d231375d7ccf6ee25d92150b883d441808246ed062c4e93d19838f9a4cf1695fb605c1c4103460536ac07edbff80b5888d1010be1cfa3c63b2c150d625a769d71ad441b5e6c3917d88a4bec7a1d5739e18ad79356d463725ce43800069767e333b250bc71959c0c5850fbcf33d4e8b859d0803ae1850570440ee6cc67280829db7a045d2a1e5831a27f5c103ee89b45e3527c68e3b8b44f61032a861939c1815c2d0c09b98ef4fb6704b8f76076d093fd34ca32e89abce8c2787596216ef7cca1d78c8ae7a0ae0be67b4a73cbd447e002cffd74a67c99b4b8c9f57663c41ec113f9cc7c9c3474b5090d5c3593a3845be5b566db71b31ef80cebef867dda40ac7342a7dcc2e1ba0e0ce95f12d10fb8fd3cc12ad92158108add83c462185346219688c9e1ad1668777bebf6d38fb97aa4fad8201629859341f291e12e20f2381138af6d20a6d50c405d6394e590b9bee5b622afc35787f15aa1ea88d0fdc111297e20125076a734cd3ec575e28bc9610f235cf1ea85fe09b9b8ff68126fe52413a5e127b88b619cce6bbf69e4f3bdf61e982c4be30b0e3a7ea9bbbc20297033675f9a1aee2df2c98ea3f6faf3db5693ecace5bd428f3b86be0339a2ce8e96c34942e0fe805a8c2b2e52ab3ecfa00f73d56647fdfbd29b3e909deba01c0ad066ba67d2ec37f8503f4fe820697117861ff3e97d03c0184bf2c6416dbd174b212f3456d5cc266fcf68a9cbf612a7199ee1030640f494f07fbe42c83df9d2c23d258e1e03dd7b7aaae93a3a63591bd1067b3c04d24587c3976628f317a9aea0c5168370a5a1f11c7afebddf67c197eab15fc209bac42362fafac0851725f6c99781e75ed882fcb1e8cfd59177e5dce3fe566500060f879d93ea6977be823da1847724ec1812602f5ceeebab5182aedb5fd5b74243490d34cb153e116a4142406c5feff1cf9710619cd4e1f0352f8951d9978cb80e861d41a1f771814428cf73402c279fd0841b7612bce274af23e616c8132ad2355935fd8a3b547c5f3e665fd86083536351b1b280ff498bac6b275f963d35e8dfbcfa2a283503ef8ffffc7b0976509c0aa79dbc112e266a272c928c8c6a4f4c2c6208ea5fb3712309fc1a3c1677af591c6198182aab22f9d5d7dadab115fb5da473c233b981bd87cad6b084f131c1118179f8d04e7e3b1a357c0e1f370d2385ea0a863023020d4eb2d6034f4781b2a239290258eea9c73fe731518857ff3ae5c57312bb2d965d4dbafc79f0adf8cd2c0610d9573b0cae0e580273223588d0b2a2d1b3d56c61aaba0083c3c56e24186b33ac4def80d2c98320ceb1892dd2931e37f5881ed1575b55de3eb79af7fb25b377a4b9d91f82afdb077dd37629485c641f5ef478fa9accfb9266167692b1d1cdc8f070c7437c0b7194d7df380b27a50772bb9941950b336d15ae98cb651376a4c13aa3e0ffae347bcddc4019f6a52dbbdbe63ef42cb7708c51e8f37af2071c26f5bb76e4d90b8f1d7313337c627863b23feed8f98cc424cd70e26049dd048e8368b4bb9fbe8176df699889ded15c79d5b02dd8c36c9958ebe8fdb6a4fe643cf43603a4275f9aa88fa9084995c3f1206f8720f8ad460c224afb0dbdf2de8555a888d55f32f5291387ca63f1f2b398b4f780427e441ebf8b7d0dde032ab2fda2757bbd1aba514b0af6f84a97128c647cf226f73fb44fc428c7bc2b3ac4d06ca958098413564db69d5b40b484d4211c02cbc87bf6221b11628419401ca5bce2d5863174c34c404ba092da6889b2c080d86739360a0905908e5662b598849c0643390714d2c51d200fa6af88334f4e69afdf4217278e64d104a169140af1dc7f6c9642abef9bc25b5ca36e2584522476d22a84528c590128774c3b94c652378f4b0539e9ca86e33c542871e7afd6af8fe676db1974d22883d918cf94138bf0e4d10087ea5e133b61b9488419e6785fc5da1ef5db75b3a75ec28b9bc5592d6b87f628feb85abc6b0f703e187586f2e0119b5fa2a97aa0bf963c01866b839f70096579885e3e7b6706b864d33efc3a9b6a5b9016862e5ce4f5562d7d85b34e1bdcdd8e2d5aad7fa55712cecc017587a27f1b32123d9a8889fdc083723df78ea8e812baf0b3fac9448e577e0f98b65ca3cf1085189930129ab482d5f2e1cfa3bc83c3097ec93c23699cb16a523d6732ef6d22b187040c2ae2d8f52cecf2b959091bceffb510641927f5ea2bfc75d214f6be87e3d0b8f36cdacab76f7d051da0b0a260202bdbc21f5bbfb8e32f3e281cde487b10e2a27b90543d68d9ca892e8a5e1e553eb2eeead82d15c921d970ef8c66c81a01e9986fbcd9c36f975b3bfef9b1434d38e203460f04f86adb0f3cf60476d78f5f662ed79c6963f1999a4187359b3a6e7b839041d7b2d0c2885ab2f372a71f92fb284f0885bdc6f5c79ab7fc40e5603525f7f87e298c09a92083879d6f2325ea113b97b0f22218e44d9e4902ff5450f938743cecd9fa3a7f5fd490fc18d322dbd2634bec355eef849ec8f013c1330e4937fb9c31d0a9344c72d7a53a3936c97e16d3496deaa6b2facf3cce058","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
