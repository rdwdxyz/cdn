<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4842fe9c4cafba0c9989aadb2336b685169462a87eb6c86534e08625764613925831f7c4fb5b664f272e1a19bf8cbceaae184ea110240e45e20b77e83952f554e93a0d92a59280faf484975b72293c737ac5c9169b200d84be9931f0f56967006d5d40a45db5906439b15a20fe5f17683b819666c49b85d6671832bc57e2063fa942f3294da032934fc80934f6c4967dd49d446fae559b9bdd44a02da15225e894a84c873a5db8c83962e57684803cb74d0c7b1f62c0e6082d251fd3d9da59d502af1ababde14650e31f56adde7f69e538354e007753e97525a73153550df34ba99c4f7fb28a5d7d3ceead533fd1127cdf003c63f84cb5dc3567b1ecf6afba2325ed90f31074b2e6fe42022c2e0dead0b207b6e7fb79b650fc07e82281507c748092ec9021f9f9bec31f85cb0c13e037ee1ed2e1319acc6f9f1d1f7ee02c625a2ae2d6020a89c0880bdd428f470742a641184553b22540915239aa4ac53ed272e4f726d6a7e0b27296f121d5aa96df595200564383e4665ba2ae71321b3fedb43c9cb6c1deeb49826498901e6077a3cc9ec7ecd329052ef3fe151947ab3a3421d56b5f8f2647572186f58808f6a41553eb517f5da8a86cb8a3aa4edfc871754a14ba7585f728c4829579ce120eb8bf7a9e6cb9500d4d0936aeefdb8de66063910e3b9dfbb786ba9709af577d582064351584b6090b40981a39ad5a062b414b711c9579c8940fa807a74c8a4810b35811a6fe5a96bb17de5ff36d4a449f0f182701220f5cccd55d8aa4bff54852e270468d1462a76bd952e573ea67b7b58d4bbb0b8d5bda1c1cbd994561b29582c7d36f7734398d2fee6daedfe6284ff3a7b9709f9ee48cbd05c0fe7debc6096759a11fa703a4f35ea3536bb641b3ac628164d47dd626c953246495f359afafb34da68c7af6634621965ce4dc1fe75ea151c7876ce152a07fe9fc55f995766e2d263f97251828ab0086e170f249a1ba9041296431873a499b3be4eff5a899f187e575f09f9600a4fdd450dde6f337e76769ef3b8f37e9700f494fdee2b49e7c88cca414abc38f64db2caf75e5d7afb5572cc495b4fc5d593a3f3324df93703efbd7e2614848a290c86f5dd2a42922954b73fe263899b44d2fdec96da815ea5870813a7d95c202a240fa8d78707e7c9ad94e18cc1fc7612f1870b2430f590cded64711e54f12ab8cedd814b50d9426555f1a115667e64e94323f85aa73e0e06d7d4e9dbd63be8035023b0c8e85b9e08251f0365a945ae741751597ecabc256770a7b7f3ead37a5c289deff8901b8c9a2690dcdbd6210c85194f360f7fffc5b386a2bbd5dcb966636c8dd1837a9ac97d7aa7dc07804eb9cc20c9fc5777fafc9e13782d0d7c740430a8aeef084299096890916b887bc2db5af1139b0754ac0b18c4ad8b70045e795a9e01c1727f75f8741ecdeb429d838c7e6e9a7cc1cb50b5fa40924483bb45cd56ebab9c767708c966105b6bbdb895dbfa88b668af18675848aebbcc05696fcecb44e3edbe15886759c3b6602b27d83fec0661072ee36fe0d42bb09b81c25bece37bd843dbfd15647c1f3b713b674ed01bbf64cee1878d0d1647ea0e0612b151ca13858676347161a1a6e068314fd412eccb16dc58042c41d43007888f0a19cc09a44a114e12178480d0cc260e18f3f27cb7a06df5af4d12b5c2421dc29ee24c2a8cc82c8009e0674ee465ce63212fd28281ae9146e8f3cad4a771ff5138db6ef030f199f69b131606107e0d948194058bf1062d839a3e801cddba0b900a56ae1961534a48a9a6da15d9803ae9b210517bed8b93282425c8d81f55f8dfef4e36b0b8c291f7f56ef2e92f598d6e04e5038d090401b7ab9fae73879f26ab514b38c2630858c6325100cfcd59bb7f260cce3a66e8bd7be5777ee4d546f24cf50de063484078db4de032253697642a94b233df362ad3b3577cb86de7e7904232b27da872f82ec8f4a16860550bca6f098a017be18f99312646b9aed93f91b844ed0089d4df8f3c4e3c1912bdf81904909276f468138a888bcaf296056991e74791816d0e49a7b44c08afc3bbf3946e2fb0bc06a7f7c234c6ed76b11328e864a0d346544535d84cc18d729aa305f2dab826181cc154da23ad467ef139714f587fdda72e7ad29061a8f42124bf37bd4e402c375561247bb729de95c2c04d94ac36ef2d6ad1c866fdb0e65f399ff2e920115aa1a76e8e91ef3e383f9141306f12f25b6b7be4bc9a8e22888b065f7fa75f63dfe2af91343b47592c6d927368193e17292efb9b275bf398fbb16bab2d49be943bf686f487469a094952d82b587426c4dab4513bc6ff86ef1794c718c15263cfd14aa948164f86c846768e318e9284cf184cee455c1d8688c3051fc241f66641a6aaba668b39bc1c74fed547ff3f10efe8ac9f5b827d0984d20855d230d7241e6361a5def47c321f4f48b2ec4f61593199d7c8f06f6812e83e238de43c4f1c40eb0b501a8840ff40a4c96310946e987238250fed2badf85f178874902efef777773d4efdab729d754e42b6be30f0d47ba4a0667fd8e84e8ee41ed88c1cecba3f183306619b7d598f8d6dab1e394f53658f293aa85aab7d22e656adfac81a4908694fe672ccbe0e4506f3c060663c5330df6b80b4a004f46fc3d3fdd24a21f76cb9027da52af00bcc2dcc5e5bcd42fd48430c28822658533908670710cb14ce308a154c8d32fe2b4fe84dbdb7e629c8beb9f0baed5d057ca7a75d11b649993901b7e925d6cf30a15e286fd9d24228586d0308f12e84d11e464c40b50fba108b25b0abf5ec981a0132816a8330bcdcf648a9748780626c3f1540a1e0f22e06ecc980f5e41d92edd49c226cfc0e76a1a0328d33fb92f6ed3babb02ce356cf8526dfc3a7d527851f8c653c2c9780fb5b33e91cd3db1af0f1e27daab76e1f4e466c6750d740b4932f22f7ff300d27dd70da423cb304599283d055c74365a11945ef3402340f205d801634791654a474c5539f86288536cdea0541630f019d980e54b0483a9f35478415ac6956f70c03d19eea859d8b93ddd08dec7c87a113235f42e2627c15248753bf980efb647c49dd222e1828a8c8bc96c274c319090c7666d7e582a64a97ae560e0ad71bcfdb0cee63dff331c6f71eab2e887a58832eae16237923018a088dd6fbac3bc5f557cf1b4e1cc0dbcfb3687c9f86812fe7176786118a4adb436ac8e4c8c849d690f8a025d98c74c31acd9a26f21f89d61fcffaa768e0b96acaab7634b941711a035a447cb9dcdf84043f897e3240f78e28963060abdf46a541d8af9f899d3771c3ea7c2b931e7ba428946fca034854d34f8985c7b249594d7a8b0eda69c474ce145f8ee1aff88f79cc8e26d8b328334119b0e8349352ab07f2316f5883ca49a4deb7c61a2c5b9d76c637277f803966a371bd943f89e9ffe8ee230d7d9fd5c9e7b1e7a32f2626871591c17ba0d6511cfd6b611492442df89bf7f7b195b9e7ebb118ee76861de94f91960573faaf9949f6c3bb121397e95f5c21c12e24df56490911e3a811721c97c224d90584aabc3aa93a46e6ec403f0cb79d5ae36a486190453b16cee3fcc86869cfe9d6bada87b931a20d3e0fe688ee72ec558ac521260d3bcde420ff248b970b8caecf451ba31af2a0ec85cb73ca018df331a42fbc9baf370071d97389ea8bd20e20db6390134f329e31109597f9898085dd592c13a4f286d648fe2ecc86893039758d6e1d38f2440005eeb644fa6aa3b2512589b414e1defc2c882f7de0676b22754fdba3a54d28e2e192801b9778f4fae675364ed06e3d89f7485392739092561db4af1f67d8edc844bc577db184db6dc2c2d3b7d6a988cb3293285a8887bcb02e8221b86204c7eb357a8f8fa7d1117002ba7e78d1c7d55a77f65b398c953642ca7ba1fdd9684a926a66797dfc5c8568dd9b134c12746d70b527f357c4204eff79fb23970f1349536f131b77e5fe36e630bb49644e99b20f0b2835620d511169d6193343bf0f593a84d0f035ddbd4a700a44c500fde7a317ee7ff38ea5c260c0c2f600ec59f1e54f064bd4bfc49f0f6077cb35cab1fdb9194f4acfa80a589259d55e6ee1fedad306d39d24af425d939eb7d04f57ffa3546e0ada325f53eff92aaee368225efe37c51598f5e27f92c07c4c96f95ab08554a6d9622d23f62a02f932bca4ee660ed9bff3e4851580e5db217811419ac0c4f9aa57b5e9d4a16c720ca6737f09026107d1dbfdea2e929b5ebc5b6ffc86c9e4e4683852705572103300f4f284e24464ffb2ce83c1c2aa9dce8ea09769fc3d510cfab1bcf8b623543dc47fb5a9e93802cd4241f911ef79fe52235390dad1bc5b1a7de1a50170339599ca125cd0d6c07826d99604060860aaf76aed0d76694badf6342d75a8011c7ec59f94cc0d2efb88003a684ef2237ab69bbc9afcd6b19e144975f811422fbdbd1d32be7a57c8e6e69db15d6ef21335d7f056e3f7d533b69f56dab63d21774ad6815f6d74c59736534e42dfe5290fc94fb71b60f4356c1fa63650e07300558e8a7aac6a45bffcfdceaba4c2e1e685624685a2d424a6d4340c608295d4c8e7348b667c831dc6677bf050dfae61a45795e4efce0f9ee74a7a9d9d8705c323c3bc6e2196a240c2607f89a93a93a0be1db9f398e560e784a400cfc2a7f663d79a444c50d2ba1e9cb08ec5a7ad4e939b406eeda4e87868f5ca4e5729274181c004b6bbdfa504bb165253291b9c8bbeeefb5d76ad2c5f2436eae05928a18ee8c9d2777d1b199373b5ce30a598c11fc7e165af6e52ae875abc007eb248c99d934302d582d37e7f8fce621d00eb46744f5afad0ced02758c299a1266eb585d797aca5ff873e5a2df5fa4632dd60f65512fd3711866da49cd1887146ef93864cc84571edda4b9fa3cb07b7b8d1b21b90fba849da80052bc1264e2657beeca51525364446d433bd69a8362911fdecbfbee0cde6f7946d94c770df70f01b29e100c2ba3b64407c1f6ff7dfb7a424986375986613afc6f77faa1136c37610287e50e77806100bf97bf4ef3a1b6dbfb834080a428b8b040007d882074369e438da3115439caf6076bb5a1ea2def0b1b477914d2cfb390963a9b1cf9c3874aaf75b1e4caca9131bebc21ccf0fe331c8b1bae8aa6e73fe9f33ef508a0cc04aebb195b33e8daed71a71cf9a4d6ef34f781d3911e0d9dd354e92f706659a0ba8f7bd08324c378d592afefddcfa9fc58a13ae0461618feacd08124db5a326e4ad84cf2cb5fc581b4fb853f35350742723e3389365869e039f63cc6eabf7855e88c4118f09e04e97546231cfab47e82ce0e7e69e3fc4c9b63776e7ab57b94e559a2a9214ccfc4ad70bd87553a7d7946295caaf022ff2e4fe2fdcb6a1c8297f914600c4d382843cc6cd47523950288b30b992c42525854bb1613aee70a82e403457549d3a9220e3910dd20ee5029871664b99e6f95a046af14ef37f65aabe52aca1efb7d9c1983a31d8dfaf50b8453e8a0e4de2d576b6864650b4c50de5611d006cd465446866abefba8a2ed932e9bbbc3627f2b3fe2a7356a508bf8b1efc145ab4afa950acbf4570670135209262c96fcdd8a09592b3a10da87f6127ab396e015dfb78d84b3f66586b0a137b87ed0e5cc524195b4a87dae1f50dc553aa0f0029d80edc0ea755baa176d8e479ad778988a4afd06953fa075117bee35eabc712c6d6762659a0ddc88bafe665137d682060e832834588d04736e3d753441afd1782500570bec8b6ea576fd956291b97ab08cb4ca3450c35bb0e725064d8ea739adafe0a558a1d2a261981b3d018dcabc3c5e4838bee7eeea9bf38274a4fe79c5fe771777f85c0053fb6566472bae1ef506dd95015093e47815897887e6e9c9e06528d8f42fa7f8e85fe788fdbdf3875fe4d2194afb8295647032368e444faed21100247cd7aa40b3c20ed0c966b7e713d3287afa5d145a9916e48343689255ab58d7919410e066848a7aef368947d173e092373b8193d2c0ee903722a61f5b6be6b81a2eeb36adf4ef03195dd3bdd337933a30d964cfb79dbe1a3a1ab2ea0c6d110203cc181e5657b95f894677557d485b02e65f2cfc15b6782f2bd659e6e3066c209c4ab938496388a9769bee5dd632aac678862d8bc76e830fa66b77d8c0f2b5e8d5c65c846cf77889f3305c6747ae6aadc7256909415d1fd754597508943d6e9c6fdc7962a75acee151373fe4c44bb66d11581494ba179177704df16a1720bd4baecb5aa78007d935c36ee3e8d2d0298f452b9de3b9ed3ebe2bd680ad90dac08909c764cf2f82ef66fd519afb08c327799770568b0201af4d73a5527ac073eb3716b3e5be5f00b55e22ff42bf66ee0705964c3c5ab3cf085f3489ee07560d17bfb3ad494dc5a777028a8a77b23d20e64d06b440a3bd932c2f6111590d1c54f5eaaa86565906a269197269f6d66f4927aae5d7d9feae8ad7ba2a162cac8b21639a2bcaf33739d6cf78f2e354e358eae0e4aab6b626521f0d3aa585301df6f4345a3fc7d175b0021149e93350fc6aa4462f8049fad5b70d3991063bd0e6e50dd9899193508d40da49463edb86ff001dd65107a2abca1a587396607ab8c88cd831525a79be3dbe70bdf70ba6b47fb89a9198481a8e68d0e026252c35f37c248ab3fc1b99f8a19e2893ee08cf286aa6297e8dd5125b6d10dfc989e5674c5c616e96f9a78f756676c9517f8cfaf417d5603c32593b43e4f33a2d5f79a19268fb984b03150a1e4eb0492eaebab901315ccbaeffae7822c94ede8871c1745075c7dcbffef375d41eb37f2dce84be5723ac4b611b43d248d9c9098f93d7f7293102d860b3b2cd905aa0766fcc501979e6d82e07974d881ba355e48098fcf5118979deb4f7e170c3a577185f80a020869d17e503ba01453f5078b7409e40e97e81bbdd72defc7fa46e5ba0255806402fb09d3aacea0bb9c4bcd3c3bc6e43aed911b1fdf69396000b63ee7bf8b0ea9385ce5f575bf23364b161fbbe2f38c73b710053dcbd7fba31430556512c154ad76abe1e7d89ed941fdac86b7ba4974262d7a642eb4da9d6c084da62a48917e18821342f2db3cfc1f8541c5caae3d053db212bb3c548dbd21257f8146346b9ed6bfbe62277a1847c2f03515583b479a8a4aab5d9252d69c68db952eee3a7bdb53ee4ed531afee5ad24c8b21d7030baa2dd681a377e43d5570e0258a90187ba4d9796f3121ab094b34e41845a20bb05312d60514cfe0d4fa4be1b16cbd29fa576f89b62a82da187dadbbce939975240653f224ed14aaab682bb49ae18447f9902f1cdf943d55e2950e094185e80042951c163ce1078c22012297da69684564475efb05d1cf4197826c1a083ca3c5a2130915428a0531ebe3a745885fd2bae8fdef23a6211a9c7ed201ddd5441f8c97bdc1cec6490de0a42ae7be1a335c22838a014f07f34a77de7a11e9bcc479b0d90a7b1e1dd7ae390b02bb547635563716470c7ccff0f403f9c5c49479f81d7a8c05844776baa0bc06eacd7cf0b6cb8abe34b6af29132007e4429974aeff6462cc4fc56d5f9d2e039ec5a085e766ad54f7feb52bd7f175758ba88a98bf4711f9e599bbf23cdfa5dd5ef172d3d13f4f3b7d72e49310f62403ea52ddf1c6bd2ca29ce1a5980a51e7bf159f73dfadbcfe89ba7fa28fdc1f175845c7b89111ce47e6ae40bf6fdb70da54382b0d11af152a859fabc5b5eb60d77d4aa6c939d9e3f3ea8cb1c20ee2672ba9722f5eb24b27f70ac59eda16fb5d26a471fd39829f981b0d2ef45440eddc9a6d0436cf1e958350f5e0a567d87874c5e1c55a837b0960a173577d4a6e9cb65137ee691e1e1ff376eef02c14b7f21ff766d5f044781e52950a0fdf168b87fe70d09bcee904716cb67a82502c025010f97f7b3a21821c2675e1bb36be90e374be2c611156454bd3af1798dff417a5052c5899981b26df0234c20eba3ff094a6d9757c1a3394095f1bbee24ab457f53be11218cc4f8098f5af91688e9c859df99b7a1ca3243f37539429fff2c5dddd8ab37a611fb35ecce8e430066a2a953d5986e473e7a309fbe92acb495499720c40651f2bc227d18673df773525cfece640e7adc10aad7244d603240f8391c74593280bc23d1beb8affb0f3eb16345311db51c0f890ec891931504dc5ec1114bdbf4fd45e71735ac1f35e6868a4eaa3503641c8d447387d0bb8723311c1c9fd2e4cd06e01d28655f9e1519b43db242c1a28cd27aa85277e95389e1249e96c02a3f40dfeb24f0517965ae6d5d9de5183469c0e05ec52a306132a070d98e0b1291696627690d8a1897305e3e629ce538261d9302031fe2dd86a99dea995d87855ae70b3c1de48aa34c53a1f334b54faa3a5c49c3d4824e63620d46073d8bf0b0cee5282ff9eddcfe7ebcad6ef3d550decaaf9d406b0f7c98be26e8833dca4d646c419ea7aa07081f34079c9d2a19e710c1cd24acf0f1d5448670e922b5952cdaa6721a7945260a03dff166fc554748f37d5b965289c6418882a8ac395feb354315597975b727e3a0f527afe6933fa344c67bd203ae7a4f73168266f2a843799f6beacea2c9311758ebf5c754295b7507735cc310d14181c12c35a5c5a984ee7073831da89ebc844dd1cde729fcd0c943df0fe7271f5dd73ffa0c88d0e520cad05a06dfd2fb35f965ba030c72fd8992d6df0cfa1ef053230cf53aa2c00d2ed9a73ede86eca1a94c60fc46ee9c6bf32833b07127fa46a9a258e5b57ffe95a42a72c82ee0e2488643e856b4af7719da5b4e193b9b9b14dfad1c64fce801f537d142be4900546ca577e75746fa2162fbab600cea1039a9378fbc74926db88e216344b6520631bc5ccd225321d70274dda0294e62ba37283ad7fb96a34ea76e3f480fe2f9444eb4ee59f6c1e13d27cbb886520557bddcd638b2215db5dd2fd41d907a3506823f5f8d608bbd9b4381af9082196b2f9fdb4cbc68b4a0164cd4c3047771687bb99cb45d09e2edba02b1f76623b8ccbe8f29fd9376c87cb04b79fc03207e3e624e742364ba2a6941279d91a2acf44126f402fa8c7c1684d2f2812d1f41fc7089eeaea4474452942b379aea12322e29048bff89df93bdae7ac577097df48c3047ff1b5917411c2b4ffefbc986e4a1c35acaa780c0debd686580b9dd9f3e2bf1768fbe97de934b69be4a497578933e42d266341342b5e4d3e6a1c3243f79dca3405738d6a6a4ef0844ef7456640ba413c1f7c9d5bdfe0fa651e9f7f31db0a1d8a35fda652f9a45f2c4602a95bb0dfa0d336205e9cabdeffcc19578a9d4fcc892fc2c62935f4e75ef6044bcaecd1927700d390510ec1b083849de668253470654f910f0450bde3cef1d4dcb0a473c2e2b68ea678c1b0b985c063ec46c2255cf21e3a3b06cbbbeafc10c477d84d2e301a929e33db631ff75ca119ce9ca3510d7f7460239ce198ae0a21e8703e39badc7027a188e60aebcc54089dc312d6a46d885ab88a0bf4b7624400192324b811cfeb9811b9689cc23b9f66ba687892ac76d0ecaed4b4d80d4ebed6e10d366ed63ad2a09e3b252311256106b84409c3f803f68bc461445bf091c6373b0dbce54849571b1c3846906531dc422b0bfb505062d7360594290d9a43305c572e71b52aa994464d2c10db77e041b9b653919f832660a93e30c0d484765c7906343e65c2161aa78403c59009b7c8eacb12d498c47911f827509a138ede03e966b011c115e8c308cc72597a3cabcad521e8920aa63f99e3316b8364cd9d5141a1550d390c36b32a8073bbe0b9da3ce70e6398dbe4bd4e69439db7d4717acc8e8f6cc09b6a2fb7d965e3c42c765ea16529a91a0edcfc6d54f67d804608c667aa5b4190cc6a0c0410f66181da142f35db05178ece915edaf1a46ae8679d541ca3ff5fe01d79fd7b46e3d4614276a4050e2e1482cee504b00deaecd96fbf4ae118adf3e4a0e67b98d121548fcd9fea212142144949d60e22a6e544c4981a0d47e4fa177b1cc2f55c93a9931d8b3dde5c89a9c928d1cb1f9f83825f3073bab97294790834bffc584fa29cb5d649531fdb90237c46ad6fb1deaf4bff08f02a0278c736f8397075267882fa3d4dfeb341907368f0e02c6218617000f13be9a833089094d4419e4a8a358ff5763e598f54613e987bb0ab2376494140c04bc7b34827983d81403d96b8e96765f2527e865f88dea621b75a10544e0d536875f863ec0cc12acc9ed418b603425ad63f5832d44c26fa457d12efef0af588cb42610029398c7af7e6d19535f733d85f0f320cfab994e823bf7de56cdbd890eaf784d831f623ef850d029721976a2b4b4029e8b026d56f0639621b866bb036f4cf4a8c1700e1c9fb5802e4c9a5c4a832c69b01fd570133e461655494d919944a777421ccb1aa21e60032787fedfd16a6f5b21b96b1e083bffa85aa98ef4bf25a9cdcf02ee1c1c2b0434e86c3b25db770e9f1409087a271615c9b41bce1b8e6ab6a6982a15efde8cafd0f495110f87c59546ff1021f80fcff2cf8423737a9198816ef3447d6088afd2b3044085443e60bb356618eb64d1fbbf327f73cecbca097388d18c69fd408ed37e4cedbaca6923af97f7761c0885de2a19acd8c65e02544b15e45d7c3cc2abc86d62541db56111c1ac8b2bda1c03e344e2d496f4ea6931f2ec7213868a39f3de7355de3663bd7e3f8025e707d5e314b6e431db2e9532a0194777dd17bcc7200e5f3356fa3fe50ff7dad5d8540155f47c5b992a9bc8a3568c37a14cba89c22a60ecb95f24e5fe55ef7cd3df143fb29a3d33d69137ab34b649dea4edcbef3442708ab32c604415808c7692b9e4ac5a9082853da099d85706cc05645ae6b0bd1231b2934737be06e793cf13d394c4162d815a14f6dc4fdb27bbb3bac44b5f3bb7effb03a7e8698c0fecdfec6cdf58084bcefb2b4b07aeeffd0f18c1b529bedfb53ed49046d0561c17256b9e381dfb3f8d30db33b6e69aa3a0e0052affcfc31004f9aef3da4e9085181610a3b5af4dfee84e040a03c86c99fae340aef20179a35fafe12d60adc2159d8a883d6069a651205fc72937e4f9e2c0cf7fca2b8022d51fc123a41d6efefdd2f1a2b838f5c4e15809d4b62ab44d7eec50bbcd5916660fdbd398aacb9ff42342897de00e6cc4557ad67e8a57aacc7bc070ac989ac8b886b3a057a80c52ecbc1d90d67ce132c8481648cfc397679db8942b8e23048f11ebcd920e5f0b5222f2faa49fbd102c68502df181c9b4715ffc7a71fcce9fb2285286ffd967d4f9bcfdc792dd863d193ad047443cfdd94b2ba7ecc4ead777387eae95e7bc50dc7988aafc5ea8f3745b9ac4ce0342813415b92d375f0b480996e51d66ee14ac2496cc9487d210ca86e0a3cd35179c97841af68b9831bf256d6ccbbe04a488f89a9df19ca6b1a0e7a7e093b071949a9d1801821b45f66f890fb94a0e908201ab93c7120b4ca4525dcfe9989ee4261cde34088109ce7796a28adeade9aff418e34401e3e67ecf61267d6d83b89aaa3f7f3b872036298f07def48e61047035c6aa0fea14158c943159c9fdd885acc5aa3bbfd46edc788dbc12b581f0470a1d04eecf22a32f9692208aa72776afd335f607875108876adbcdeeaca3d7e1f1e9d6578f37117755c5ecf8f02b90c8acbd3fe5c23e1d8d4b60cf8e81c1e7c224da0f011500dd95291ca9441d605d4e93bcc793d3ad328988ca59d09d6cfa98b8d78d3a072c26b34f5eb36383eba2de19a5ccec06a3eebf9c40fd163d51d0da435989373393266651663b56490bf0ef784110673bb7d33a6f591f4faa23ae6cab9ed43fe5e5dc9181ac19ea81a36b3feadc441e5906d2952b3dc893dfb95690a7d58be795ccffdc4c031ae8c2db42e222b9c5f73520d2d3060f03d08004a57bf9103375e7956e863c7897ab10408a65c9a1c43a4a17d0745c029b6cf6b387b947ca79e809569a33d17246ada0f81531e8bad48691220c95e34814616cb2c61a79b6c6b21671af65592bd399e486830f10a31b2545c9e48569d0f4b868f7eb94ff3f6bbce3116d62a74aedb6f9d1ccce011a4f7613d77ec848d4202583ce5690fd6bad83f13079d20c88cd90b6ac03c8c7a86e1af6a2134c669cc9441e4a48e0812db1bf26adfcb1e59489469ca2ef120025579312416fb3108a45e23cf425c9bce393e51dbc8447273d91e24ef2e1f5a8e6a61555452572f3e23d6a0c1b1a3ba9e569a6c76752d90b725301817bacd61bd159356013299bd27da7b76d3dea62139d9996f669012799dd8200060d09b180209cd142778503dee6187fa38fc1716982f9d44772b41f6b1698526ac28bde1264a0d6b2f335ffb6b90904510ccef9a97759616ad0be693ceaaebebd7a4b57314d09a88bef3e03510a8ab5c360089c87ecbde0163e387ca4937bc835e3e875b35bee392c295a79f834c3ee3ea28f67ec028982bcedbcad41953659b6a948c130260c7fff8f6e04ea9b5217939d8fb64bf1883a568c1bade38dba4148a4f47c7142a103774a4dc7c40a788a8f535df2bb134e39e44a16570fd8d592ab2993a3add533a3c7d6cf9557727a94cd18b810da494d4a801bfbcb8fdaf91b7c906577265fff69621a4935d8c690fb6ad6ef580d4cfa8a53c19f30f5bf6f2a7cc74014f0b12339a852cc1211deac7486e912229f0a529104e84cfbf2d79df7a5eac8d5d201def1f68a575a9a15f07883193d358c641dd4f5e0112c27b2454427015aa2ed2b3664344ace5f1dcc3233b59d4f8708938d267cc3caf6c26182e992ad96603d5f6a807e314bc89bd04ec410c6745891c6b7a22d0a24b5d0fa39f16636668e2c0730fc406ddeb90a259559fdb348832463292560d15d25bd8a5cd42f085039c9af9344ecf58e741bb28d41b5b0ee9fa68e48ddd778af7df96864dd25355be0fb7e47774eb09e0525497ed7f75c2032f3d2aa9ee372116149959049f3ac7cb715d78267a268b813ac4b4f3291c20e7d3f8325c731587e14dc0cbafc88eff20dcc7d08b9d73f0c6e0258ae03ffac85eec62b37efc052a44968888104b1b3c809afa76178b3b0aa2e401ede612783ea09ce603f290af86aed4024ed3dfd0edda45490d85221e7558b841a2fa751527d707ed7bb4f163ec347ccb375d7de2ac38ffe4674acfcf61023fe4da4cf15b9599285e9e5ad19f1f22ed324d9afffb6dfeec7face066a23c100f27e2c83369f14c79ba6ad68625d6a422d677f28c30b894f69ffbdd9f923b86573524ff7bfe9357f4d66f62df453a21c587ed7945d18c546b29e7c35ce71370b7fd08357ab3b8f02be299e12843df8ad3b481e8aaa59a2fba7f930c4adadbe096734e00e141c91a2901dc1343863b0d2e5f3c751ad083341e8216ce4f3ec1bd668b13647b0dea23b8c7f141fa7653177dfb404ca221a636c59c4e5882ef6e652e8c1e14d9e0343db5cc870877fcc9a4716174ac854a34269aecbe50aa7c367f61b8805e9169c5cd6b4bd1f54d7d19090c3ad97a7691b8cefd99d1560aa1e1f50ff97225f88b23ce39d1ad871baf7a1c5de70df158b9b3dd08a16bd4795123e66c4e5fd117983371faa580936c4c492e1864148cba64ca5b547ae46bc1800b29cb15976f0e54d9990dbd469f957a0bc12d0dbc8d86307384ce4ae485848ce9e2d973ef691c33275e77ca652ec2cf205b10dc36be00ccf07c2673e97eb49705b6e1791f5dd914331dd78de1e932e6a8a69dbf64d41866399ffc29dee576b68c650b35c0270f929725a746c47507048b90c4968a26f235123a6539b31c55b0b66103237df0dc16cebb13b913508257afdda5f89d535a8e86d2d54e278e54d5bd688254a47d403bde74c1da317ab9abd30be2d042138557f0f39749a77c685b928fcf6f1472732bcf972550bea7e3fc5bb7c6a99507619f15fc15a059accc20e982f376b4fdc89477cbf7f63ad479f8e51516d00da4bb431f57e83c15c1e6574ed96584f68e5cba242b272363ee66729e400ac49e509766d1758686ada6bd4faa33654809a2af60e0b52aca3ddef40c7cdca226770095bd78bfa7e59167f2aeed3dfeca0b6b40c4a2a68f89f0dfc4560d47da6e76496435ac1e61eacac2b5553f487ca4c88016db61753bc75d234ad7fecf909f177deb8256438859586a0015fde28a6d58892745a2f2b070f87a1142b90f345fac15f56a1f0abbdca1d8a3490513ce7066b38a5f243d588b76440c571932ace28931d7a29045577f252aff26a9a37623096e5277386ff03054ccaf69ca396c75027c2c5beb9ca590d28fcab3b20735c1f1bd529561e12d9bd7385230d1933586abcfa43f861f519943b9d527b644f433eeb04c3ae90605c1d7f73dff870462c4b53056a1887448590c934cc664fcae2f8967d4972c40ce78065c8596a30c59e3818b171e011e9ebf5ef309c821999f14279bb2c9d6a10d3159f5cbf56209e71bc7df58c712dcf49caa187a987e71c02aeb68b678cdedeab47727130b6463c51dd7ea2235b0d6bcf42563e8813bc3ba984eb9721bcdc7b39b8eec84af3793841888a8fc53728eddd8121c7ec93533457a3560910e546c6a6343479b63db153f70d47be64b9a95c4758d3619692939056cf78b9d5159ef9d18a21b63664153927ff090517f0131013306b341c7665339607be276397cab89e1494ec37c7b876285bab77c5abf4c12d48ddee176ea1bc4fa48cbf5c685b49ebb0bb8847bef3fec43534e80a934ac8232fedbb847742f3c0a7b2d8a9dc324a9c68f6a47289258ca8fc86749f30a508f03ba55a50aacf236f49994fd6f2e33497c9e5f78860b155cc23543286c70572b1270bd0527e4aa1ecf03a90de000a678578495d132483cd06c4c4aed0f8698196508b74b6ff3281ab1ef785fd26766e1cf6367fdd85890c15e39e2d1947990cd362f6ed86b38d30ed7488d26ceb2a3deeac2d412ff42ccca78c306941962cdedfa070ef92f9e5bc1d9a1bc1453f97e33c547dcecad3d8ede8e2f68d5bce1facc27f84b5232617cc678afc67e886a36b99b44b814e7c6fb2b655a9aaf93437a89a19b8b20480f90495236c09fef32a195c89341580c0aa5be5157ac512e1985499e85434225e9221b6c582da8a233f78399e045e83a24ef1ddfd47a044fdbc48c7b21b81ffebd6b2e23ef02ee5dfba5f2b956702d861b9631af1843bf9f999fd8f399c252d65604c8ba4e388a6f8673cea82db291503a7fa7983174d4ac57192e0cf1b9c828f67390e225d14844b3390b943e578812b83b8dd0d0a02fe72ab9952419ddbd8aee2faa4a733853f69e686ac4fa8c0eafef3fbd07cad879cc9ce4a8b0a376ec97caad55fd9511a86cdb81084e400486c57ee15d5b8701e118090338d9d56afaf2afee4f9ea90e0f2afa94984e88dd5d730b9fd805c622c7c9dec74417fc01e8857a7895abd49b4a91bd454d89dc2047bb3c7e9a0cdb0e51ec7b578fa23c1102219ae13f8a8d2b815e125db6788169d339e6ccdf91f92ecbd565bc63e9d2748a86228ace0cae65baff6a0d099ce4e6d789f1367c08215125d3eb202420742808fd51e42e9f2087b3a03febd65892300796c9ec1738717dbf1fd1ae9bd982479f41e3feb443a21c933874a4459cfb92f0fc31c7df21281ab51b15f3802a5dc6872b4a5018d4da6d191287a4591131266df52f3922e9aea48de1beaf6076d8776c340c894c5e349147c42f9aa61b9028121bbf22dcba374d718074714b6170a0bffc705a97c0924701d72af6b696004d16360d4833da2ae8d7920733ca235d31736366355faf1c75e5523c40997821cecee9b14b0bc181bf2bd42b6c60a5639d7eff66dd25b39a76eb9299140eaaf28d37c63c38fb36f85083f43bc7d59aff7d62168e5bda0d951977cc14e63c7210260367474eadc3ef6c505b444aa125af7fe3a04af2bed0dde12143b6e22ef28b7e329b6815c60853abb41ede6f2d390156f8d8fe9566a0391443c06a16a36b99d5d7a1d3559bf4b51fefd55cb71246c4f7096d8bd396f226ff93fc439ea57a1822cecd5627ebcc1302e06d7d4efd1e7a71dbd8b1cb2f76496ecf6a1dee7028067b770bb7b1db753b93c90770e1365d4fbfa383e014dd01507cac49ddc4b1ed2b6ef4515dc69efb63abcb248b9199e5a5e2d5c122b8bf4f96caf9168896ad355083199dd099baad307afcbe785816908c834d44cb198a00f9970547fce65296ffcfbdf973c0bd8f3a42db969be5354045b363d174a75d967b36c4aa32afb8e357df41cfa1f48bff2223726bd6e870bcf4de43e1da0d8c02683b92cd972c4ec283160214ce217a47a7ae6e64c79e89d32007a896a2907fcfd3eb1debf00c39265c8cc4eae2385979d5302ad2a47061e05de956d9a5d4c0d8ae344196627023748474c643551486a9a3cd047e10690e3ee7628d33c39abe55ba647d5cfcb4bfd29df923bf1217080c5ad0048de0d3c3bc77f4ef42ee77568a15d2fd04dc683cad140ca1777a185a9c95e617f555303a5468d923ced3a30b6aebe4e97d983fae88ee63f0bafb8125fe0996ef42dabe2c667cf32a0614492eb53792b399bc03db5bfe6789da057562a8c97b1b0cc9bf3825ed497893ede516f900cedfaee1e916f6f036e874386b9e98f504fbd5e99b1745b87a8349b8d6aabc4395a194507907bf9e336e21f9044437d80ffad5135378cd33cc951cbf4c552b172884275ed97d86eda28ac0ea6c115d33cfa88024fd576b1843155e82d9973edc4788000ebd61ca78fbd31d93d11d3963253cac542ad8130cc51ee39d011bb48267dac8eaff28b1b5400a87efbe0f2997d53257bd030bf75b56195199581e06a2b7e95918920df4615ab40c2185dc841acef5f2653b7e5dafe4e4ad9b4972222a6190d0e3b1f1d27977c3dc97b66124b2e977b85b3220c63c5e08035ba03305071fa4f0ba11b9371cbee6c3b33fe724407e21208bc9905416a1e888f0b170e981defce09409ed18086c6c0b8973bed826ba185cbdbd9925ae7bc492789ad0997a144a45359e093bd5c7d216661c69fcc5f6620873d65a5dab9442e51d0b7d60f99786f40026dc4ee2a321cc035f9b94e8a6584dfc5e2952c70e331cc2f83acf4269da9427cf3312e4650c828aeb8696bf62499673789ac199e65eeec9b06998df697fbffdd24888353a670f36c56888dde7607bd7b6fe53893a5127ad570a208ec247d654870fc165e3e6656fcb8908d59a40f00f1b8bf00f6ccbe4f1dafa1a7808db1517d51344f00f58ba0f6a3a026d952d3c97b09fb4111c59fd7e9a4d111da61a2a2cbcef67114d74146d38e13deaf8ecf0dffdbdb93110467134564ed1a1a65fc0cd291cb64feb50e06ba9a738923c730cdbe40136451585e91c36394536794df4a6e6ed4c26e3ea4f4f9a4bb61a66a6abe9e0364bbd253be18e907b9f3fd7bbf48f886a957098b06755bd9b41fe397c70e3f7b942f6439f2876c247916f43241d22f9d6adbcddd34566f7de55771a256656abfaf6e9e7c1ed2ef5e8c41ceb8438f2e68fa3a0ae8c83b680b8361b5175f7f4a5d10ce9d00bc69b9082aa62497b76a89d5d7fe2594e252e8780f72e72440084901fd873e81e6601455434f5fa849cafbe6f3f8d82d81647d75591bffa09a2eb276f981066b622b2287bcdc180f11906fc211cda9d0e5ad2b97e08bc102067fe7dd91022f144aa255833a58a101fa5ac2d8a314fa5fda7fd69ba36fa089c33fc612b1fb9f3e2770032e02a2733db44cfc02d8f88d12d81ce07b93d92d87d04b73708552c0059b547fea0bd94bf8324ecbdc6d145667133100eb6a239c1bde46336149fcbf6005c632a5901739325eef1536904d73d3a50c1fa83c2d1cadc3153e1008e56558645a53174c584e4887c0aa42f58e4671bb4a471bdf913c05bd77b93d39bb9feb1eb61cdaa3c7b9c5c61286128e2eafa88c816a31cf729a063f8d7cc36a4f7b9573c5f10d7d6e73eec20b8148c6a4a37cc6487acfb9baa492376bd1cde45c50be85c5cca0e33887d348e0975582ebffb5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
