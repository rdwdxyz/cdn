<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6caf90052a7635d8b332f67de7b1652f84f8bdd39b7da037db1a989199350951921101e83c9dfc00e0bc3971f62a186291077b0d2286b11a16bc0f44a739835739f174cb3612c48b9dfe35a000fa5638788170a116850cee427360ba2f0635af22839b3d44ae7affe25b7ae7e2388a83a6f15b9c9df8663fe0287af7e83287a21c06f8f6c1b01c1c550b7ab8897f09a2a92b97627f56a0a9b26c7fb3cd439b5807a22f08cfb94e52982f65b06580819be99a0f0d756b72eb79a43ca6a6bde0992920596fce78108b66473b8c5d04237a74567a54f6ff17ba96855e1bcc4ef9d2bd9927652b8270e79da3379e03831a4b802192519872abc3fb42c2b1dbd0d08e3a062bf5bba9a13bda81a94aa64c68e97be0705e42fb140b729699444f7e1b048f39132fb7adfc181165337c5097f6d35e088c1e692f164ef3d0975aa191740c8b170ca2cf476cdcc3fbf284279204b542015ba2a57f37d12cc7271246268ef763915727cdf79ab0e450e79ef6718cfd077160bf22a2624d935dde890cf9efcf11d46c187dcea3250b98e6223496f6bd158f7311ee1c20fce8ac7a556e995144f5a4049152a02473cdf34dfbba5ccd07276cb03e4d36482292e23ddebb6f408c40cae337fb19195a3b23fb83a10cbe66fd2ece28a9b5e329c9f113583aa5ca655e0aa0032ae208d5f02e47f3348c28253ffc87bdda99f3268bc5cbe6daa227932500aaad72081bf2b3e25a5d08c45d7708c97d1f86394213109ea5f3b6370258fb06e69a498b5b97708284217e8a6b8576d6290028a35cd248d3fedb7b73508167f4db6b915528218c6244c2432c196103f1583bafd4a4757e5cd9197dae3efc9c271f2f8357b4a2e700bcd21ecd289834a151ca40f44624a360baaef6f7a9a6caad3ae6f581422633ce3396d83db292c7f42615b592e7badf86712ba994d4296af556c2d1d9ee5ce245601de330be6971d7e067d3f94c6839ada56e8e4959b56f75229e41031281993858923bfb62ba3224613b78d41286d34419860671b9438560fd69f0dae3382e71948086eabfd9965cd66b4e2dcf165ce4df3e228d3b227b1afd93f067f38a30fdae48fd2ea2a31ca0c98110efc39ccc1303e8e6f2ab6cd87cf9dd08debd61c2228a88e5fae686d1609aed7a1f1cf32d726fe26ca8340fb852200a39f37001a8b192579a1691428c5f1a3267c6c51cd5676d114b61285bfb50a091d9755f608af3bd1c952a5d189f0473e035a6231d7e025e4525aa7bd130d43932de6b91a4b1264d75e84718d4bd762b1b4cccd0b1b428b4258ba707faa7d288f6b941d9c478d4609a9ba0d1b1e390bb6dc24888240ceae0afbef9103eaf575d29fd5aacae3241b4fe72d80b74076773be9f192e918aa682e8d379ee26adaaf7fab783e99fb44bfa18f66c32e84b7d693bcf81b3b2fe63b434d084e025493699c363f202cdf25adc027c2e67578ae86378e1ae0c83d344d3f77ba57fe23519ab80ba4167037b35294fe0aa4ae3737f718a8e5a63087181bfb5fa1b18d4855a6bbd1d8a21abebadd723a9c383f8a1c60f7da5dd714cef5bccf3e48619e32a4bfa386f247d55707bf50938091120cb9012bace9857baf5ba581078f02cffa3de03fece95745425714718f53824733c4afc170e17ceb6fafab03887f1cab64f341eb58566504bab24661ea193361f19ddeb63dd16e0d54f4e0b7795b0943788d46647a8af91040f94f93b97aac82f202f30dba7990014fb22a9c4125da6cc231764bc3ff0602c50ac61cd6b03f9ac52b5a03a02ccc1e937533c097e0588ad0269191353048d35332b19abe3fb0ea0c81646b6a3b3ee3ec882200c62a4c855e1ad0a4790b87e05563ea068da6283962b1033da5435acad8f3074768b48be71c71eedd79f2f601ebaf96256d5a2498e38a4645df01ef33929f59859b6436a80426723bd61add24c17c6d48e234afd071119dfefab0a295097bb47b91809d2f4a9f7aa9ae7c0a863fe15c2b6e8c0a7b0ae14eeefaab47ca6062965c0ec1a6754abb64df7acb0a52ad981eae50bcce083e9d6618645c10ad7357102e8de62fe2986a27771daa51f3a4d88de05fe18f4786bd702cb3b76cf3ae58f4aed6b79c6b9dad5fe07f72db2fe8d73a5c641062e4b08681c16023849fe24b253011670009ef28a284ee44736a3af544ac4630ef707bfc5d6844f31b0ba013068e0f4b0610a44603b00a68e700e7941ac1d6417bdf567fb0ace6eef5551a3c02e907698a6197104639f9d7cab48a84185ca23863dd4e9ecd73d19ef7fda6f033d575d835f8c8709245a68fa5766303af636b223b85cb9c70be67d28527f98f01eec96022f089aac504babbb2b859329d2aadc105ebccf71545d3717eb670f52ff6aed86cd95bc862ea07eab3ee5f51b5ac400007510620d610e04b5a53a349b0b50f00a4646abddeb77d153b9644121e17dd400cb672ff722a55d94a6abef38c30542fe50edf4522f97f054c1d6812075cc9da3fba96948f4a4feeec178affe5cee65eb4e5d5159dca21e07b6b1138b8c947056a6ee79708e39a45a2609d21d68c60639dbcfd5a68337fecdb609f530e5921bedd2dd166c61a93b918a1c97d1bc57ecd7abea887796cdfb69a1366d42f3a093f8503846e0c6a1d9c298bacc56e4d098c9e8eb3aa1c2fd4c78e7953ac3143fe3420f0debc4b3c1b9cbf24c376f918390678b6b8db8ccb89afea031b51bbcdb1248a0e3a6597097f18dc2f72944123af9299c4fe8c0a0c3496342568abfe4867e258efe9cfec9641b56595188a9e607f0d4ccc057d98ff9099d3362d6c0549a6a86c746a30542bc4082b0e9002973857e0e3f973366e3dda6b8293b61b93e8d176e1b96731fee797596b9eb2245f33d3be4edbfaf7dc2e6bb5096c0de1cbbf90360cd83ab718f798c9c19c50e67c23106cf2c5a3021782665cc039b3077b201b5a72574774200668971352016a473978da82d5b10a16734cf45c44cc780cfcc164f9023967533c915809bec6453f0aded7f4456ec0a000e84000a11ff59c72ec317901028273260f819daf412511c0a43cbfbb5a80edd1b78e89f07f67a9a68726fa0d8dc3b60b58c2dcf17d7c572d0d46ae985b44cfbc67024f681564abe6a02b5933bee90b3c18b285871748d12a8a7695178ee3d9d8c5eeaa4715704c4cdce26a3387270db29940f82455894bc1c879ad67cb69bbb1730bad32fefc58b33fc36122a2b77f021591b41eaa35df4014e2aed3d2df32c36a39a3949e2b372fca8d5d55a7a58bb534fe408359af54e9e86a55b37efe3db91736c93a573aa04dd04414f356c893782e3ec294903caac01f493865ec0a33781acb88033ae371ae51c78a166c14360d2e175f5d93746b0f95df39dcc3bec0136801fb2f3aa59fa6fbb2da96108dcde26d8e5e88721f38ef8e8f2e1f18dd1b1cf1d3294082f80cd2bd2c702bbc8e1de67336add1cd924fb316c57b050bc52047449e18b745304b2ffca093e8f54c9a9cb18513bc8c9976f101da534b9b9a1e6a35cc2dfd8727528e7a6c914c5f97f367c17182e3ee855363d5c97544759889a538990d1c62a5ba6964505ea22107fa9764d5f65f4909a81f0c35700992df389b8dec97debe75708c072957717c45ca567a98f563d1452d27edd158102f9c03982e135f6ba0ab0807112ec1982fff09371dd4b522a2e136cb58636cb6a81bef6b6a10b0d80444e125fce5ff4285eac4b91e30aabf0d9edfb76a9de7ae55b3b2bf9c1f7f970bceba8e449e8c31f24d7c021f3e4b581e8ede7b99365aa87d8a0d3291ae99ac41fc2383d015149285eb433b978a05745ee07b339613e8baa490a70c8a2485d1ff1c6045083c81d0e926be22aed18cb224ea6a4c8c7924f50aef65ad47dd4f6bffb32777e2371af3d0f1af6d4259e1f1bd49a9c68f24dc052a332d61059ec62eed2c9ba5ceee625bf879528d981d923fc35b609bcf25054491d9b7c23904a2873271ec6069f9e308623e84ddc7e645f7a32edf2f6bf68d31e1b8a35feb87d6b55d28fc618f88cc11e049f6dfbb6fc3da590ac4d73beb81db1653b0b7e0a16b25482fa0643598e9560dc8e942f340a5e7e5d1ad1e3d4ce1258a40ff044c3abeaff9b406ab51c6785124ce4c1e6d5446e4e3f81fc0b52a3ca4e4195c8255e22addf69311b5193ab75ea28996c01865f62e5884e94f5e74b82ae6d74bff328c7996ce7d303a48588e6a6a1ab026b6056bcb9747b74708008ed78073d3c140ca8d15e77a250e8b704624391d383c52d6c55bf4606ed4e91bc28d53c3364a1634659c7bcf015d87b5f2aae1e7ed40fe846cac5ebcc690e77432b1aa2eb8f1800f03f703b78b12619823049c303a7a76f9e630129f4b4e519d6f94446ef5cdfd5f721d8c1825f114dfa61c091ca3fc174a225b8331965186fc5da948258d860e89aae53a0874177f40f7ff289e444e5c1063fd044fde2200fb75c9fb53fa0a77b0a55ded1599206d348efa989296c22ce97c280c751d3698b5909dda0d2bfbb064d869208725f87af2c4797e28c6a8d7dffdd91fa44f164ba2ec92079d4f567561b578b858fd0e3effa2a5fd402094bbcb4b992d722eeafc38d981d9ba0a94b1eaf4f3df64635e21e2fdb8ddfeb1244f984b21474ab8237065bb97e76505e7b5a21d7c1e5b1f5edff0b7efcf2d8590c2e38ef2e4c076e6e39ed8447848b4fda56ba14f44c793a2ec8eea937347215f69b1a78b2128e76107e098a0432705db3a068ee167ef3f4d9c56c7760baa3bd8f5b608af16ba299e69b63f04d2eff5a98ac19793cd5e9dc92fdf2ec670903ab8da527e6fe317cee0b98524eedeb9cfa3616fc14c1464e6c96e2e5195cc5512e268a0b20aa23056e0af4b43a9ce63261aad89b518f60f30a10c9f0d1ad075c59fda485b40d0ec7e4fe12782bcfdf35e925ba4545a63e839d5b3fb99997660604393a2be030d8de37ce27c81aebae35cf43931e6b1b202d983731e5bde3daa9946dce73575fffd3abc21f198269c8cda495b8395a99327ac5b3197df19904df8c889372320a82baaa44f210a940dbefc303bc798a2acac8e2a861f0a3563906e5f3629fd89a30bf56ca8dc58e91ce1998b3a69e1ba3fbb89b88f70b0ca9b82f2a1c36910fd775538d601a2bc5bafc8d92febbe85fa427af301864d0a3ee826eeaddd2f625932db65095c9eff6453535aa1fa16b7a0d314f4b27cf251afe65c8abd71d450d99f2f69253e6d0435f841577c3e14fc734071d22de3905b2fe97ecf7c4cc601421c84dbfdb5abdb9bd2bfa94b00a5b10c25afc2ad1f3b0e79f3ab9e93256208f28727826ab31aa6dcddcdc96f90117ebd7dd6aeaa70cea8806b33aa2c54dc2c4c9c5d057904bec7b6b695d284b7afbc2b6df126e5b3da4b6aab3c3152dc991aa93c3555d52b3226dfc898f8256a9f46873269af8f72adf8a40c02ec64658a6f5230e3b181ac578a7b0270768952833b5e4bb9dff31dca6c45e2e5ba603acd63a2682576ec823aa6607550f649721c7758b69077ac06e5cdc17414b518648feb3c41ddb5699ccf53958d977db47b1ffdffa4c0380787fccd065ba4b5fb3d0096bba7579463e49f8ad48abb772ba4f9f8ddec7e8ce35309282b8560e43ce11d4842187eafadc7f7eb0c4959aaa27623dc67ca4c3c10e3b8326e01e8f3e10d9b7cc20ecd3943eb7f24845aaf2f83b2ab57111cdaed6e681a133801c29c5a66c68b6ba3d67398ad99793d2c8f3a36fc5a6f8804818f7c23b44438f4095f9738827fb0cb7eb372fac99a4b7ff4e855307e0a191ce040fdc5cdba5739f4cf053c1853b9db271b61017a4f4f95b029ae878506f631bab0cab8c2fe0a2a5ba4ee8356cc9f37048ad1e6e2581f31e9cf29557d284e5abf9161ad9ee35c0f901e4863fa2954a2c032c1f998907ecffbd7c8327f1b644fdab8efa0593e51680b1098083071071c9976c3309cbe60a84ed1cc1a20a2fa4718899978fc4e86ce75654112a7489d8dd12d07a35d0f6909c9e9ba935ffce66e81467f161723347f30ecd44f38f62845f474b353e98f9c6bda2a644c82f2c6b822c52e9908f2a19686295e9b759a049acd9a97731e7b6ee04b03f90c942e98256803847853c06e9741fba6831d44576bf26496d42a9116f21e3d4d86f9ad8a8a09476b5696b63a24e6e27203164ba204dbd87930661478181491bea2bfea4774f25e73f3d844f59d9e9ac38a577323e3d7b78996ae846807dd0a08d605389839bbfe668aded7d299cdb3332317f2d1b860381332cf6ac2106c1f4081c14f78504d6f1cf86830c7811a53823a39bb0eb414a401fb3b6fbb4a24c592d6eb3a24750f027163cf9410b68f2685e2f80567159708519feb0345bc78cc4c9516e5321fc5ad58d1eb9f9fb00e0e3c35439d4303120c7be1ab9c799a31ee7c8abf34c003c81692b7e53c73ef3d2c47e5e67c7ef8400cd82d8063bb9f4407f640f04f2b86bd01dbe5ceaca004861853082f068131fe33f67495f274df45f1f0a4efd97d35f8644b69dfe36c026ccc2dc88023a193ee45ded2e808854e41f21c017c37d5e48e18b344caf369cc81733c68c72b5a11724e7adb17e58a1ca3df2bd6c650c4d173738d1e68d7a734517145834d97590e3a3e5a5a491796af7b818f3f77ea1d1c07de52d56770856c20122da4303b9ce5fa8041d9136ca07eac08ef2b7fc3920edb1fbc4e925f3a4c3595798322c25ae02e76b5cc4eaab059051dcafef1cf98a4643f1689ec1ee03ae55ff8093ecad2c0cfe1171297b6c5ba5ab525768de9ecfb029dcfc3c7e2941ad0bc61901b6e961864f9c85d93b391cd2466d421c1254aa8542ce6fcc9671823843159f48433eec6b318426835364705de46027a0b32acbede309ed7214fe44a81a37c85c3da788b825e2b1ab855ebb794ddd6ffa2625352d9c7c2511ce45815adf9ae8e9bd376b2bd8145f06a4a2278fc90f3b0d7d9e2b0e67e1bc0c1343267831c630397f666aa6d13c33fed8b3d57f24c9011d9a89ddc6725b86d41719a62a21cd11f3a4281b1d0fe7c3dc5c5a02f98b91c5f9b34ec68c268c8cbf19f78d891735326c0087a9925c3f4430d91fa76a133b67dfc09b132a65289902683885fe802a956f3f99efb2186c1e37a4b342b9d0333c6ced360bf773ea6762eeadf693be6801969283b2e602f863ed30ace27bcddd6a5917ea40df27966fce6e2ca751181cdc912afc677382709783c430564f714408e40c21d4abee670040968f8a1df3a8d766a1997c114cfbb801014e84882ea4937f59352c4a6445a2100ee57d01a5c27284f8cea831cbe3bd5fc62c9ca7ba979589f54a6f57b2fc58ae98af6e69dc68a5298477f7209e10b74b183f57a5901ea9fbd6959dd259089d1ec15ffaf1e7be5a26e6d6ae557089db0cd03f8b32d76293bc49656c1f79d2cf6eb4ff2c0a88e7c2635a238fafca6aa58812d2cf533bd8fe6ce6fe6bfd5b4cd27e77a6c9e25ad8d79668e8cbf81599ff50eb1d5530c5ec37bb035efb4ad6eed80b9758fa3d9a32757e169aa2c2e914987ce61ec2f4fe22c4ccdd2e71705de89c5c943fdb77d860e8f65ee801ad7ac0f454872d14c0f002828ecdb45446a08f37c9f26821dd7ad7960416286dc843fd3c9106d36d5e4fe013b179e3f725f198d5cd773a26432c035246a94561e5c5b4a6e11da8cb952abe280961668a0769e22a41ac9872a954aae8d5fda4c81a4d9eaade3aec47b5fd821147c41a07bb92d0186031dfddb7aedbf9618a0a3efaa8c2132960816b5f8405d2b509e410570138a4ca589ab9ab443af509692365e971394ce5fb4be3a7d81a9757771a6f0c5b0f875024558bc848b5213b71c2b3ef2d44aafe594f36dc97e677cfd64a8ccc8f9f06d8ad7634f7bd2a4ba84d804f18e48a71d072943ce4b4a339be4e67d19dffc0743ee605741964de0ae970ebf857508208f0c37c0fd942fad5ecf2a43abe17562c7a737b859489a912593de487ebd215b74209f5411eb63f167138ba57b5875e62c11dd132aca776cb6b5debfab16d2dd6877c336c9655c09c1fdaed319be668724efda9e75a1c33107df39541454217c55e840db854ea7c63a75d0262a46827d3577a96975348decfa827b3b35082f613762d3623b3a5b12683e70f6d023ae33bf8b259f186d370023cb328b3e5dbf696a541c9f514293861c71fba798ba548e59f909b6aed5c595733faf61e1c5946e32f18aa1406088b810663b77c007dd51f1ed1e6161becc4179bc539c89313f70889436cd4ee1728bcbb950f0b99757aa928686cb4f59c752fb97325cd25de1932a45146280f12517ee52cf84831eb809ae5aa9c02af7fc23c176bb39c1ae18d61592312972fb4dccd1402930c15866487b599abf86e485e9f3377248f5073e2faaed1176e06b5e41cf627e9d7514b17491c1081f068a5a207c554b7ad5a132f4b68c850ebe0405f30a5204ad6b1d5859d117b2cf855ffe1e09dd3307aa62edc2b4eeea4d1385d2db9b9694efba999f0ed05feb7d9f4f46d262e5074aec770f81fa9ef12dc2fbcc607e2fc0d3d90cf06c7f1ce80f6e8ba758c6a4ca321ee3d20cb386cc3b9a6f6ae314493927b653ce75cf2944b7df1724a87433a9850370c8574162f8fb7e4970ead007bd99a96cf9f15e04d4a0e53e2f2af9548642deac65984f2999b91a70f2ff3b7b70068d48778ac01225c5c575243a3815e431f6f08ec400ddb0402a2c322f930699ccf04ad3a1c4051eea48bc258e3161b130dd7d4f5a88ae238460ef961e83e8ecad8371f5c212df4a0dec7534b53de2a28556fe1fc680a6ec3a273839af79384e78357674a29fc715471fc7812642d13b9c93a273aef693e4f48e00a134d5e82b7fa9ce71759c317734a43587d058d5c152f3f60eb0d23ff323417f65d9dd413c15f371a1a2c4841b7a242473f87fd11532fc1b0d18aa9dc7f43c0484fb9ed5c086745a5a16174f95ba3bffd535c2fc908a64a034195c27112cfc911639794cadd4cb5c0eedcf73ca17e33dd918358d41d029cc05f2776cfd6905f40a36f82fb291dc9e02fd41fb58dbfeb98f238616e9fa1cf2f7dfc78cbc27e8544c5806f1c41c12dc9a9aad84b7657f2dfc6525885b90026d63b3d1009be4a43ab7b10310532acb730b9e55fb1949f957358dd49b22672c7f481eabecebba66a03f5f07ca3812f0140d732edd0987eab40bb6ce8a224446bffc09c3aae04b59367cabbbd39663eca526a0e4a4925d22ed52e38cb9cf8ac583ae42441e7361a606258905ef17613f5f49274ecf7445d2f4db2180292d68b3e3d8740f0bb82cae1265ec05d67a5a6d0025904eff8e190d9190e4f27439b078aac77db93fd4dd33b96940305b05451a04f05f93c40e6efe3fa1536735c105933f6a366a6783ceb3121f86ad88962d34e087644da0bd5f9a39167b084cb5174d2714b396467a8cfee1d43e24c62b890c920e81728618f28612a3eb28a1d0aa571293728152a98ad574271ae2dbf058fcd984b0eb6dadf6242ab52a554595676c00a6fa371fb281df1b1e9b3a954151851e0382ce8ac457f3647ac47ef8e6cc544abd3d1bb2f23a6bf383768141833c13170b32f805190f9e4e7f1ddfcbc60eb2d024752a67a3ee77f9d04d10133555f3b216344912ddc735b535e6616b9edce8e40b20043b1007c3057b3e95f191588684f9aa4a9e9e5027c98ed36f6d1720cc42c2ffb7b0bb0371763cedd854c42a4a19c3ff2405c40f7a01af8424ba9355a69654b19bdf1c765a88d48126b60112bead6fcbbfa6c4b939cd527e09ed60fa9376acb6de61f7f3ec89274a15c9c02d7908a5f012a749a89410f0ae7d9cf3eecd6182218a79bbd39c6d1404ce5a2ef1dbcd5a92647f4dd6da0996b3cb0bc046a7eec3eb013c470a1ebc1ae48aedbeb47266c538bdf0b03efa8928580c7bab4a397ebbeaaefe2e91319d2a495116acc5009fd23bfcb7bc73273354d29971f1c1dc6bf0e79428ebe26ff6278eda4a9a1ca1e4dd2e297ec66340cc5ad5300fb86a3ffcc0bf23afdfdd32535c66a8a061793bc91dcddfa5d8575fe6fc7f5eb22f35b3b13b082b9a98b27ecd7d703f425e2442abd7655f9a715de14945b2a6ce8b3fa140b55251aa22d9b49b23e92236758d78ce72a10daff269237c16cd3a636946a1830faf80211a5774715ade484e3739e8e790e7e06ba9b9fcaff7476cd52da163795130437da2a3dd5b63f0888b0b6f93a3aa1cdc8516752d6c8a39381a9793f338a366685ced8642e864332107a8537d88d280c3f5ef6fff4bdf71c9855f5163f7ebc13f1347044f2bbf557287cafca3c84ec9b589740883f1f1c6e7718c30314cc3290919e541ac6d55974d10a11fdadce1e068dbba92f085a04afe732cba0f36a92914054655a76694125284a3f55856fe584eed43335519d29cd0b9427c2cc48998ae5b5c006a7208a44eed579651be12c02b2db6cfece36410ef9c20bd74fcc1eb70607097e9a2676415f19021fe2419b78be0c269ba47084337197f8d8673f21e1b037b5fc95d5e8bcc3fb0059dc2ac555b95e43b3b07589d98737bdb28145a3d8f8ca2568a38f405c342b9c528a3a56c7b466ad092b437205617dd3e12a2a35f631c9d852055e6bc4e454caf373a92f9ef79675a276ce684e882bd713982d159bb614f07eed6bf344ea0027de954da77cedab4cbee0008e6f1d5154dbdff5d6afe82b7a8fbfe78bfec04de120648e7ef56650f08abf734c512c1bfcd309b5b735062bd3d7fccc1fd6116b141c3d50fada1c1b0aa39ee5a86ccc31ed06b0b3acd477e594ee7737facfef7d8bc10bf6aa93404d4f8ba09227f039a4eebda95d593e23e5517bf0a10d0dc2e75e769510dee6e733d6baf9e2311b041a2c519ebf6d8537704d5fd0d6725fb4eea15b9aa5f5f41664582525b3ca686aa7b99704ebd7d6f075620efd37aae6b95d52995699ff1823ad283b2fcfd78f9ee3e08810d373ba2ec706be1eee00a4b3fbe09194c9701e233c6326d1effae851d2dca5af77f6aa12651b141e75e619e5b15833cea0776cd597912ccdde415ca7f00ec7d7eac269adde99a532a37f5022cad4589ae546c353668beaa711497acf104bd8f4aa73cab85c6f289dd503d9a3eeeac0e1c130cb2036bc5209fea08d56e100a9809f1a5fde0d0d1498f2fc2d7b2d7feaa380306ee570d1b04fb608c8e3cb7ab64f111bc3c52aec41b20397e464a816ead22beaca460d3e0eca7aefa5e86266ac6df8f0478bde3fa274eb9d486e49fe9004a3d8b8ff8d25d2bfdc61f393e6ecd2f81739a88c8234d0e3ab117c56b3f177b6b9054f3a4e893699e155da1c92e04b353541e9ccd634a17ac7d3454f2a18092f0c0cf45f7cef6f1f36f778cdb03b1c5fea2a6afcf32bfa4fabcbb92c39fa4c81df8f9756ecfe429ff5a1f830d4939da8df95ef9a244a37e1657b4510634f1897d4ce74e5dd2068eb8d0dfa1ec49cae47d933ecb6b71fd6d7b7ad5972508fe86fa1986672bb4a22e0fd560b5108a04fe50cc7d1f1f6abde833212f7f55a5e6eca1557d4722709adb84bd065b52377629dca9057c1f6fab6e1814e2480cba394c5746f8abf2cd59e14c602bf841b541e1195cb707b6d71d7c9c2d2fe7fb4d2c150ccddcfa396d2934a8f6e1d3738b1fb617fbd11ac1a40ce1301827547738be476b69988a076dc369ba24fb2cb71cd174d3b796b7233b85cef1e1f2530155556030cfe2b2b00c12d271777160b2e94dd1ee46a014c34160680200cb561ac8f86fd6f9ce1cc794a7cac1a4a50d063982f6f30dd81d71f4c0a446a8de5dd33c1681f232ddded38ed046d1f43442e64f75ee3cec582d1b98e4558fb37f710617229cfac6a28da510a66980aa4e42df2c4b04b434402d71a2265003bb149391ff390d9d9cbbe1541323d6b616a5fe1c2d55511586f78a3e9b9a19c1801e58d270c0933ab3d21ba7204a8c107de10c0b2e2661f6404810d9c9ff5a8a66baaeef3441fc0406b40b312ec1571cac8407cc7c56af0a831a57025dd947829bc438ce32f018d2c8ccfdb8348ba2f7b673b6a8a5b1cfe67dcbe26bdbe75f16955f80ca363e26c0b23e74357634aef303bfd57394b40102402640ef37f626e862157a29066277ecfcd7c0506d1361d814d482780a2d28ccef2d020a7137535b004f95341e73e5b844368b81b82b42caef208773284daec7309f54aa234b68e41d3c8635689d873df1fd45ea61b3fe6d8dcfe1e1f091fba9a2cc82f9619d280618dff8de8ff3d5c3915038fd83690e7065182b2bd4493df57271d953278733431b9af214aee1ef07078bdbbd4ae9f392b59f1e12d39ce00cc0a05210e6f8b95234f9062c8d049b0756da4e20d30c1a7f71cc49d0ab46bbcb4396e34d8a1c70c1a3c3ecb43e68b526e8254ec1ded4c258f4cc530a4819903bad6c637b2d31ad7fcd6ae6ade52745d905886bd566bdaf45eb0efaf24941734cf9abfc953c64bfb6687b7b18efdca1186b65d47ad365f185e8e58ff892e27e7e0cab4408605a1bc8c6c79a1fe6973e7b164e722f758510c3c48231d6d83d44251420de4e2ff553a59bf5dd8399e464dab8e4cce76e9da44e7113c160a763d6065b704c33f2b67749e7b9159e7587af2e442e93ade21e13144f682da6ed2705b154238c250c3f3bd7d6e53280c817e778403f4a8c2dcc6c85f76a96fbd6a38c8a46639df60418b3df2bbc6a6ad8c693f2c1628b382376b18fc0d5f165c62fa28f4fbb13d5a71363d39bd6ee30a2246e74a6b1d3b7a56cea00265e2bf558a9758f64c4fed486d815e793617caac239ec308449c00529b35558cb414d214840248447dfd0a3b14890d7eb1bbad9166ec39c9a1c16b68a7e95836fb1493409bdba2727b58485052e4a8a4b4d24841a37fa4cbce40abb78adaef53165e1d41a5f688b12b04641ad63e624398666bbff2b2a3b9f57120e0f1d83cc1b25fdfa9456d7a3c5de3e022cf1c6c15eed27ccbd277a103daff60348b54967acbae8e5103236ebd1059a9adcb7020e3a225234b945c4a8c9f9ff857f715ad56ab5176abf764051ba5ff36316972f2cb246313f4910af6916ae084c1d4a18680b6a3ffaaf761f670fab6519fb60a318930358c93606c2685ee63a69a47eabcf359f4dc003bb2417ce283dac0aecfa72b35eba0d055ef28c351beed0fdddfad3a873b6b168a62b0260e922df9ddc0b0f3f303521a4e9c4a55d809db95a963a24c1089f65034aa3872a96aedabfb1873a5d93662e5ff129d5cd605551ca7298562c849c713530bf45247ce202bb5783ce3bd818863a73545e4799607d6e9415aeea49d03676bbe3f72ab7c0c70c7579069764f745f5d474f3247c83486f4553e7fe0b6fc6206273213205c32072d958dcfff531d4ec0529a2504171b0dd7838b6201e66609a18742d0e50988504d8354b7b1f80ac286bbc08e2e870a25066c79b1b15addecf60a16546f92839c9c954b379ffb81d869983cc32f15b062e7254125d44e0f8cf256dc082240d72023250456c2340a0d0b8c282472c4383dcfd07173fab9341f13268a5daec2ee99029ed4baa0c6aa795d34d6438e0970aac610ccb0d12c99fd8bb732c65a497e310551c93a16c8d18308ea1c98ca1f7c78e599628dbf49491bc0ae7266d27e953d1346f79d1da0f755d3313446f52861ce812fa1cced81559bac2459d9c2132c16bd5c5a2558f69d307e1485ab775f9b03fda06ff7fa70cffef853419a853a8e314c5c787c982d488e2b75f7d8c6c2d06b5fc5aab36eb3a38f01d404337ddcac09d7db9102eda237fb444b69ee6e1672b1b7ed713acb9ebb0eaffae5b7eeb72a1149833af5ca7ed07cf8ff45c218ee81b6af5cec86feb8454f6f370ae8541266fa25bb275778b8b52b14748d244911107b9ca5c4e86be1886edc557e28424dea9a39e72764194f1772cbe49a2ada2abb6dc581b8b3b0877d25544e2dddb9a31f36e86f409d85d5c765352f5903151e9eb9e1a75b67e401362888b5870157ebc9c28935ec70a7911ecc401c75b9347ba217b64d4a48bedef6a95869b2cd7da286755a9fcb5baa84aea58cafb2290cf6409018e4236a0feae4e08f37536f0a866910e68a16b51bd781a51bf9cce71ea541e822d8a1ecabc6951e042d827eda0c35e1f062a53beab961c1911d048dda3714e30677607482b7210a169090bce9fd261dc7102e58d2aa9b19002cd9d58c92481c258edb79984123dcfcc23b4674aba0d59745a6593741d0154443d33a011186b48bc15c262e03f92364b5ce179704655afa52e88fc82370668fbbf0dfc5816795905b3b84f11562df1c7241fa156edcedb92afd04bb8a579354545aec7116e9253790863eae3277a6966d2a3e9509dfae5db1a173c8ff159ed1f4525181b311b4d6ae566e7e6d9b34a4d31be4ae60e531345ff427063935dff1ed69ff323dcbac1d48aef774d5ff77875a2a5f7744a054f18b4d36ae874ba62531d2f5d42e9caa736ff8a31dd1cc19bd1912bf76814b68032f5485690e65fd53a88775fc94f0f1f209674345873e88d6e5caa9f1e475d3ab3b7d3f6da12279277d880250c4a7d5430af04d5999da3bb97c21f28eafd499f62fbee2a91677462f7c0a7256337b8cfd9ee08f446b2563dc6c198c235a6f874b1747b5137c8c0de66d9d0314d9e69f88d7ff6fd0d59c1602c4e2533833ef4969aa8bb585be73d030719e36b3f5c58bd3dc93f13192d79546e6f7c62dd8d7bc543230a51a4c8c02a0c5a4cf0d01e712277e1a476dd18cb37013a77aba1b02ef0d59948cf6bfd7c85e801582fe700781b32ccffe96ec2aa2b1664911d6151b3a9715560255a3bd142d855ee6b63311ee3b68050680ea5ba01a6b8bd84c1ff6e935e7e17c361a39fc419956644ce269c82dc53be22086d2066840573d831c562328c4ea1f890cbf30db58ed2cee7f783c22a50c578504a5374a55627230c9d7ea04b63629387e4c9030bf9b9b58470818c59469f1aa8d4cbac588a2c427c1c392d92572a534b7f0c6d3ba24f0bbdab85129124dc91416562095a0c887e4d09c021655672eb4d536ccfd71848c913f259804b6c7a1858e71eb587dee0324fb1756779ef263c500949b0aabe0834ac3ebe664e81448b77626fddd053065388536f9e6b04387277319baa925817ddf197b9b8bd4898cace46d4ede22dd178293ce69a7eee392c4d3d0665a592edd92f7f100b392554417bd6f0f96a508cafcad4a0c080fb2995b310f872d1729db8e02c68a5c2501ad29d120e203cb89f8c1f874ebd03b25d4e3525516ef627719617cab081892fbf124ac6060cef0c7ed4d92788a48430629bb952d8802c450a5b7d6625d4b7988a418ebf9f897b1e67466f9d4239aa69543404df928c23c952def662ea53bc8b1ab2cfb283a35eb40e96cbfe454bc7573aa5cf3c61aa7e857df51f1034b4ca874b643ddcfd10e29a0b55d59ea86d399e6c2b066521600ed9414baed4518e02ea6cc57d279e8b27133c4baffac5abab7812f180b6da378e9f8c12fffc97aebfa4f80f703b4281634feac3fba0fd665d5d8af0d04b052c2cecba8648a4de49cb55540f71de9f1865c22f50e51518a8dd820bed23ef6f0d1a988377483cd7c3940c1629c27adc14d46d41c0663244a520cb1bae8ec4ef81a2aebbfe29ad7c33e4a591372cc8a6a266b85a0718a2c055653b103e60ec19896b0cbca40d301ef8d37f8d31c24eed63d27de106efab6e2b57a1b753bbccdf70319bfc7e834d697eef12383628de1f7d6ae619a18488a94e1681df8ccb136ef321fec3ee81663f66714f2c5eab46b9b7648a7be9f4855d105710f22f28c762c6d804333a0b62c0bb95d432c9610eb92073bab01c0c8d2b8625bb591bcb47743a54a621a72d80bc64ad467971004d0bb65c9ff5d0cd929bd8425094426cdb121f13eda16da2e321ca876e1f5801e9e905dd7a16741437cad99cd89246a385311d19dfd282f1f10df18afb576c3907a07b9f0503f691cecce6c3d34c1c8c84322ca4e4622cb7439e40500716dc673f2b041edac021ed4b0cbc3489bd24626d72c26333472a37718de7d16b664892b5992e1ea508e97e9290162e286eee07c97b88e4d7ecbda3324edb7340abedcee0188ae5715f3e49d1688c10e3979b5f31da51aecf52b2ec747d8226c44ef973d3badaf6111ed90a5c9485b7dafccabde34dd4cc965cf927b709a905d3000bf183d299dc7d2cd96827d76055477febd77bc08e93f7709bbf319cd2a36b77152dc835da701e8e126be88b42e6516e553d088a4e6f1236562a4ce8bc3005234d932da232d0ce0f28e60144450491702787d5df823ce040b5e23678d9e47ab1709909f3cc8871e56d21821033ed19aed4d90f7d4a1079c10a499c88cafa22bd238ca1152fd70d3b111636bcb3bdd45f4ba2b1f961ed757d8348a79a95c1f7687ae6006cc8dd7db9f6b9593b42a8fa5c75b3098c4e1c5fc7a611b9e799096ed5e724d31d3582277359f71c396d3ca6b558347b98b130cf3f59c23f12b02f78311df1486913c26e263c26f90f416eef040cda01a640603ef2e16de2dec79f8a5a02acac04e096e4eebec551f548947d34657480e689ab8a6b731cfc99b5bd62d87f2f7a43e2155344a0d403fca9346b94e69d6fd93c3880be6246dfbc4ca54fb17bfc72da2235f3b9ff6f27a6594c00e027ba1e1a904d0611dad9a5266ca4995ca1b058b0bff692a499104606bc39f377fb27f7df6437d4c70093b092e31b2438fdf34550d9281d8bbcd36039da19d23cda3b8fb4da3ae9210f250b6a9173c11384550c7e4ef76faff90ccb2ccddd2f8b60788bad814d79aab5861185c0d568d29a8a0759431e485dceac34cc33996787d0dbd13ec7ecfd0056f1fddcdc7d1f5663067ac4993b83a071ef38aaef05b98cd10ff4cbfe4493e1f9439accfb438988a707da5e921b2f7c84efb7c2677887de258a959d11c93d206c790c86beaa74716c4e32e4c13dc445e5945969dfa2fc5e35bd85e91eeb84ad3826b547bf14a2ea7edda1818741b6fc7862fe0f5a37b429614b8814e3c308fb87c7f35074de0d7b2cddfca37eb5d953d84cb089ae1f8ed4d9e0c0653d39a0dbabfda14bf238905a85a8a7af9fe699057a4b841f2d8a855a62a1407f74966d9ee3a3fd75d3dc5bb9ce6ec85135260278b9c59df8bb59ac93fbc4a5d716855897acf183490185168a127abf15aff0254bfc2cc7399c8a2c603cf7aeed06250f4e0e4e15689729b0e15dd89a81fdfef11edfe59679d2f2828eeb5fa896219a6f9a88cf438a074d914a505ef65d044e84350cfd91f26b6ba93eabff88aac55e712a8c619db369714fbc4f708516d1b454bd2b87d9da858a4af11234b69ecf6e3416697766fbaeee242871c18fe3b6be6ce7323fc61595cdaf295c0b68bf2c4e93324df3f465fcc23b2ea5ee96d52681364f7e7b681c115263f5c3e121d8ec8c6631fe20bbb1cd9664374a1c66400ed1259b74bddee6d56eb828deeb72876794823fca6d00ccd1e9807a65fedb5d1638828487008073306b2ddfe95125ca68e3474ee066550ac2978b78078750ebe75128d63d43959dffcba5225bc173ea58dab5de191bfa587891fdb2a8496079b21b08e82dbb0fb3ca676d6c7806707028f95c2d5c06eaef21bcbae00008542fe07ff06cb55871498585962896cc8fbb7f40fc0b187d3f093dd4168b58eb535b461030919b9316025aff72c03feade96782eccff3aefbd22670b046b933a38758bd7f19614ace7a31d867f14f50b3409f8afcef566217b9db3138750808668153412809e0d32233f5321137380fbf8414227f1be3017116027df974487cef27071ec11db694ff9e3d02a6e1e1988e8f2f14b5f8967914f6cd863efe6a8d356df5d10f61cb79c22bf0fb6ca6b77edba9edebd824dccfa4a9c8626d0125b2190d62efa4157816abff6bdcad7e1da946e19be4a424d155987a269db29cb28ddd1d4e18ba3d581f90fe2d4907","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
