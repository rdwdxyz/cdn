<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0b45e82c7bfb347666827d17e95d52d789412131bdd4c66b3797adffcfdd7d8d338f5814d0460ddb1218db17567b4e6c0b87ea708bdbeb8545a41960d057e37561c8ce8df4c01655136b862ef74e806b1d7bec860f317b8a462c5853a391f5b89f0c7367160954b2e0b9a8ed09eda40bac0cd38a83d179c5a2606d8d4741137e60aec3e29630d5420769cc5cb372c4199dbdc2e915c0fe6b0b1393a2dcfade6d8aef7a5d5e7872f594e6779f9390123947213fee313ae2b75f018c3339af833165fca7fab4d35a55d27e44e6945fead4e8ba60271cd2fb2bc03dee4a5845458796619d4af439fe047d707ef505076b7ded517de5b721734ea6c6749e07e876572dbdcad20e56554f585d15df88d957a22172ee0ad002f0038a7f9c151a8f29d9a37afd6c9a979a0fb7c97cf223fcafde3bc58d074f1682fb448f2cbbe61ea1e9285ef840641fc65f7c496211c541b6580c5a86d73abf38981c2d5b546b4fa3021a6b3e8575ffc8da703e4cb4a9e45227b8c21ce4142f7cb64874b6a25ba774d298d93a407dfd9f5c53046a2ac2c514034b7090c3a17e77cb216952f019a4cda559b0df2623ea875e2ef4474a295e0d2cfdb577ff8f6414864d12178d146e8b219503a616718625e9651bab98c04da78734f611439abb1e920d774b6e229d4d0e99b1cf12f20151338d808e62fddf082b372f782ef1394c9b0dcdebb1eb26f6d3b21dbab13c362e2f02073e31a9e428a79f18a821e0dc6fa2ad48d7e4d883ba04b4a5f0b0d1f34aabb7c23687f0ec5529f323bec1fc9967ae5dbfb320956268a04233ddfe8759a7283145a53b57f9da58197613b45ae6354375b01dc06194efc69fcff7034f430dbf30a1e8e76d4e2b492f6f3437bf0016d0f4afd55a4fc088a442c16159cf672acb44a9c8320f85791c2667b97c57f8f73f1007d0829031288748323802878db9ab184674c8d94957d8cb20d57cb968218551a9b81d86e87d8aeba2c0453a050b3c5d38bb1d8af4bc319d7e3a49bcc18d2b7a264903157b12a09d82588dc1e659a4b351dc66253b7245cc404ffce0da7b430483372f6d636b947dce1c2412422c15c45845d73a267d63d2341b53b7973a7abedb1bde6a0e95a63e565e838b05fa8a217db38f368e5d94bcad45062b7ff2d01edda4dbcd09600c1476ee6b1ce62d762f0658221c6a4b5d5473f559aa261e6ec005cda3ca344d384bff9b4d334fe397e4d45e098fa5c0afdf23b52d0538caab807d463fedd462c1117fd7992e29715ea8d70ea32a4914933c0980505a7b7ef1a9c3bc69a9f8105c9dd9036eb20bc74a3fbdf5a2224cb7997e9fb2f8db06476f6e241235cdb5c2f4cf9e56bec764e6d3973d36efd9c11aa62d9bc9cdebc89d562fc0a90b577e903517622168932d036fbc525ad29543dbd550963b0c6d2d160fcc06fc0ed9bef2528ed382f5e256111a070e8cfdd5fcf4b3deb432b665b87664723bf6c57b6e3ad2b0b377fe8015e595d178fd2467432690c53aa341f57e3241ab2bea2ef8afb5f4ebcdf284f7b9afcb47d8a569aaef81e5a23cde5cf3bdfffeb1fc1a39b5fe3bd3cb4face9db97ce2f8bb8333458db55e78038b3c78f2a8906a90d4d4245d93868ce0eb751ef30c4b8e0404b38dcaa587a96507017cd815d754a9372c6ccf32f47814fc6290b46211a440ef83014c4f664fc613dee582c43c4cc6592f1aa2a5c85de063b64c2070f1c7683b891af3a15d68c641570c111ccef8e36c1dd36f7ed7922ebafe4f0228f8eb89cfd4a91dc079b9bc4f5890ebf2fb44fd3b6b146f01a90e678895f789c88161853531cad4b54d9e48a2acd577f8794cac264378e15ff241d8427da30cbb4851b82655edc0145080b4e1f9026250c54fe6641dcb6c30e1b500282b833fdc4305f9d5c0a44fe6336ef7c2319bcffa9a5dbbfc8a5e16e8105a3f2c91d9fea149b91417efed1b02da2aab77dc5c3270095deab49ed78ee0dffa0ac782649d32b90c119863f8b2cbebb2433641287eea24af3647ae115fa18356ffd6f90eeece209a726133e9968f554b6b67242d23d2858aac14dac8263b34bc39e2d24c6cd6c6929f47bac62f168ac527e30f529b978745c44d59c8f111811f5bfd4ae486eadd95b686d76dc5ecba02f50460ba39f005a46e70e8803f6c8f01773d74f03bdf7df775dbc22ef1c40b45e31522abd5d60da7edf158816725315046318defb83eff44c6a4c21abb4b741f6b4f607f5437bd6cdc6efadb1e6ff41b1810e94d490832b218305fa13fba31c69299dca02f6f6c401f6dcc2c7d976c55235e792c62ae8827b4aee97ed9583d834295034d7b6bc1a4fc761e5a0d95243f66b15b106b2aaf9d7ee71113d2645ca0116775a38006a0ac7a896caeba90afd7fd90cfd921ec72988b29a9421c30b5a9adab2934e93ba01110d5d6b27e308092667a282d5f92e956ad7969f1fd9c17301956a4392d6f57d734ccaf55b06f4a3fe1fe127c8967a1d932b755078b962315fe5d89ef3f8a90d7799c62bca97dff6e1e05c588f765ce2d96cbc50a773d0392e26e9373924b7e0279fe811540f818a07589060483822e04bec6dc6d610ed8ba5db4b4927a96a0928dadee23b3a5132fd1e1db3bde24a7222f34880c07a3f6a976342f276a7a0c19d8032ef3db84cd5f7f762a40cda5a6194928b54506cee60b26dff94d373784c449e870735cffe4ec4b05879527467f4e0c6125fb11c04c1e664987acd7a44e09ff17906fcc8aad8d66ad37fddd6742a1a81d276a272f98a33eecf2a2e1464dac4d37e9a682d4f4565fee2a1dec80443b1e96b501b84c405b72fad24c3e93d8cadec9cfdbf9cefedc2b432a967e4642ea520dea52654b8d7c64517e9eb54e8fd4f89a6fe5022bf2e8a6c60df9983226201bbbd7d309bfdb6d96b56258c52855c39d97d866df7fa1e11e650c57742fa4b4ea0ce7c7f42db103d83c4e96c2f4947e2fa5b9d17b07ba9a244dc062b1a93ec5bd85462a75784fa211fb7234f777db7c230b0c778224069965be754407eb1321001a2ce193547c44055fc0528cf8bec0546c15e9e4f7163aaf20b305c691eb7a1e1c6109714621539e55a94cfd879d9503a2a22174e159dc81f987bef6ca203e6ed9a330e6e7252fc76909c553d48b8c1a270f8ef57e571f69fac5fbfdb940a3e91d87b3e13026b36d2efc875dea6a588a5d5acf27938ea9c84171ebca1747443b90c43005befcc156365c06abb488a70cd83e4ee912565ce34a7ccae49b95162f0b3d8ecc248020ba8fc5d099520d8aebdc3889f04e50630723460bcaa6f190e3aa6e06769491a1b02f6e94b792cf50ec8db645f41e5e9f71980da14a085e1de056690bb8bfb150d35ee7a480c0a6852cdfb5f3d1afd9ea159dd7d2ed8cbf7d06a7a17182c42e4f15e439796bcdb0a42095328135e5778c0c58d467e921dd7e5165598cda2fa021666130c9ac31c134bc3c636e736b342704387d43e2441ff1849581e0a2cc53277ce87867512632f8caae10a5051b713a28ea927b9b01b5e0a2b74694b0501f413576c41e010efd91a0d749282aae21ca13bf53a95d0c7df99198f20c7b897c5e2f4a314eae286406ad5ab29023adf32475569c3d0371fd982f1c9678b202851fea3cc53018981d2b21b0c9e420492723666d11ac3b4a97f43181540565bd2ffce099183a2bd064e2ec9b794f0ab7bb58e8445f18c5330355ff7fad0d43a2251605b96e8e24c9e6f903820237ec0e035ef666b75df2b5603178ca6e0b7b65ec61a5272bf10b2b1abf4868c783dc28be228278d8dceb317030482d497c3b7e5ec9169b8dad25bfc4639b5aea0d51cd76de017e2a37b53691c352e51b19ea27e5a98ff68218fc0013b4285583ceab872ef3d8564487ab4b8ebdba365ec79aaf05313b9cfc17e95ad0232fd888c220a2451f3cc5f31dd080f8ce6163c89eb7dd09d492fe7b5f536900bd2ff29a8347175763d63c73e378146a42ca3b4a59f7c67d4c3345fac366fa82ecc10a360f93faf4725e81a3257518e5adfb7d531fef92182b519a1e58c133bb451ac4c11fc0475155d7e562e2ce71f413d412f2bc97c1244b06b2982135c8095d090b73b43317449a1ebefdf9fe3ca709f55e2f0c527f9e9876d315b71f125db0857499bb7e940a54046d98e8e4d002b1dfafd06f00b058a8069401003ec76d9a73ec72e81ec4ca554d6f8f4e971360d0fbb4065e1c0bcc22ecb3c984efbc61f699cbbac21bd9d8eecf726e1853008155e9b719b1367140613610f2b06fa1384e3bb770ac64c80ff3c97363da28623e9ae91e58d4a350837c39f2dc37b6acab4c2df226f325357377c72c54a8cfadfb6dcc90af2e249f5737b503527e3d575d307358581c7ce31109509b6053024caeb7effa0da69d31c21562b3086f18f3414360a6eda7c5c7f155a63071310f0af050b4119b08a1325cf5f5d3073ca37daa00be35f15304ee221a15aeabffcd9340bc76a7113aa7ee9ddba69432c897c91cccbe84a6a14088b4fc796128064089239d25e254c5ca436ead229a73dc96ede7fa65db8c6c5261549f3f50c91b2ec84a0084cc8db593f6a1b044f26a870c157644a7f825437d62e8017dfdf94b99d8ff652c50bbd3caa116e074376d3365aa76630ffff649da33f3fe8734da5311667ac0f1bc4eb7cad0f4d71d0b00417e2db0976121b4769bd7cf2eed21d42864f9e5f24b6c5809eed37eb8a16fb257d6215758234d7166b06bcbd28288653ba328645b2aa5130c4f926148bdee440ec542cbaa7fcd81e739db54b26d288b0171163dd534b09b522048edba744e5d202961278bd82c7da271c683f4968dced8e7e8993c41d6aff3298a4aa2cf87b0db97294da4f9fe0348f47debf39438c92e16dd8347b24e764fdf9af29299738be7176f685df469a0a22b74611e92aba76ace179bdb30ca5b5e7e6d8f9cceb9af38b31fee8b547d7bfec58f6e9a0e043915b7cf714e737d2c66c382936a590b7ca48a2aee28ec523fa21ceb22fcb30edbbe6cedd466f4a0cf6f25215c910fb524047858f3bf976cf05b425d022e4f13cc06f8f864302813dd9847391a4377ee432e5e90b35ae742fa92145e4135d168b23bd694fae150045fffe1d0ed2506aa4c97b0a2697e25871de18e044685693f6a516bd1b92cbe0f43b24074648e048a71cc384098327654d73bc66af94232abbe8e92d0f44661abc7ce55c59e5ef02f35076f995de41dfa45fcfe7dc1d59f29ad4ca36ea3adcb6c9009f3477eead20d8da439e6161d294ea882d858f4f4113da5ddf2f14f02860807630bdf66f42f582ddf94d505096a76114430200448eada1a910acddf880f82b2754093c10ba19affdf5c7cc3ea6fc2e8fa49163bc89dd0dd6707b126cc945d5afab65c717655b9ffea5f93154a2a6580e30f45d3c7cf6e1bd06d41583038bc891fa9c46c270a18914e62e60b43a0721bda1d52019ef847fafd2f8988dda56bd18fe55d0bf44f1d2c5a153dcaf3b6ed8295bcb7dcd77953f2a97a7313426187a5c075ae99026c51788e63161bed2be08048266a53675c77707468a6683c0b6403e74f4ae564aee793d62c0b1f09e0069cacdfadbb39cd90e6baff9f769c22a1a7112574cd817238e55a31aba66312c21ae6e26e878f31465386a7461081a0d52fc9d8ebfcf8feae9fef6db3a267bfe6b8d8146d27e5754f622488a6dbd038d5cb9070faadab94f63054e1be6739a8bc9990d4d8b00115774f2f49ab1dfe9c26e1c3e28cfadbb064af04aaf9a5a80d4b1ffab4325d8c311a84bb59c11ed717d8818f81ffea1775cba99bda1bbe1a2c53837c67922c63ff315d4391630b383392100fb7b69a4aa58a1815786d49da907329a632b6a4990711557524e7cf492fec8fd22cdaabd93a41d84dcb12e2cad2e143d0cbb74bfec70ddaaf6b3136f03f96c366b4aedea47c968aec30dbf9c3e5759ff9c6d8bef28a6a23729cd586a04389dc23d4f69c160c5a0a2e50897a6673b0abb78b23f4b1236df597914eb97129a2689a3698d09d6f38a56c84c4857562c2d40022b00ea14ad3235f6714b6144db2f0e48d6aeafea1d5811e683c8492b17b01b6b064e85cfcf10ba1ea5fe16af3333429a0304e09bb4a5ac2e2a05892aa0d31f35106c558c97eee7015b6bc9db87aa2de83cfe2fb123fc3e9232dda034b692899372c8d50c65341e419d02f00d1ff1d059bb1e0d4c471969d6ff0f6a0a5448a763e5a1ee092c9a3daaa2a083a548687f8af1dca064b1aeb1826ea1bc96c40015fa2b1e81e518a7d6605fe16ec8f997e60dbf2b4ed1b6b3974372869cca67169cdc86065a30b883250cc0265f6e9dc93587b05746554a7c4f419fb7c67c78f6b1996679ef4cff38359f513b2c597ad3a941e8064e23dd412389c627fdcd8919774bd7b862fb534452d4024e74df3f4b35530b754738ec538c7fa1a7d0072ecb16e58c792d9617d6d6b98c8df36e11ffef53220024144332fe7c1017f1e5247366c982e7b26ada220404377ea20b6bfde14f39211be942afbd81ce606fa5957711270adaf1454cc2d43298b44f402327f4d0b74fd0e88a24c2315bb89d0b16298e7216c47f045f0d9b244b75ddf8f85a1a2c58f0a9f8c3a0ff91b791ad9c543731ef020219c773096f5d4e3b3708cc79c5ddb3d732769cf03cdce385efa0d29aee72c4816f5887be83812ecab99343d0c552412a7a34116815294d0d312ae79c46d293ae0a3732ae45ec1741819c16b848ee4fbbfbc138a4b1e58946ff29d13aa3f67c3f3e2d195b8c60612a87c6fa1e882c4e834d0938965e1686049886e8c1c7c5c18428af93b8b35df5f4a50846b561b4dc5001b1b2fac09df57c0dfb8832ee4afdd8907cb5deaf35c777bc532bc50d701180bc6cc9ba182a59c4b0dddf5fb97801a50ac9c95a9356e163175ce7703ef3b6d5e59f128b12d399fd41f2181203eef3d121249c4bc2c84c2efe538df953ea065360108707b872ec69bc73fb1c1860480382f655f48616e8c2540605d2c879c46fece9961a3b61bea217b6192e6fc10264d6b80e7f219de8efa2a23bc0b6d7a27f224c9873b5707ac892fef84f9816299d900ccc3c006402a2ff8fd80a2e23eafd8d1e35a44fec829eae5151616f235b36cad3c84e87629e835adbba1fba6855dcba82d2434dfa2ff8185ec009e1d5f24b30bab6d7e2f41aa3499a19d384adfc62223b295399d6cbe13fdbaa38418b253144faa8dad2ecbfe13e6ed84c1bdfb8ed1b45f82fc87f1160c47e436b4fc9c6d27cf6984788cdf4d93bf43618d9661f07ce2b585507625dc07ac0a5ba1dcd92775242bf176fc70345a4a19fa135b904db33d7bfadc10b9ae0d9e3bdc2d42528ef6ccbd6e0955fd7e6ca753eab8151177d523402180cbd137f2f2e47d374ae0629f641ff62309211ebfde2b1129bfd04af2e2090c7d034fcd0c490d90e18e0bd5ee1d3f74777b188b59de9cccd8454dd131a00a91b4a633f85070739060258e370fb8b3f34e671745703f3c469becd1b771d7525f5e51d3b85c23b2cf6d9931377cd7c10f2d6b8462b11fb73e083251fb6a9194a3cf7c01be383b1547448473b0d037d3b69e4cd5930c61f4c092f2765d7a21accbf30a1dabcafa9c831aa93e4de0358a47db89573dee167f2417ad72842455f032785187cf2f45596326e7da47b12fb5f04f75b135331a260ce5c3292b057e63ce381f681ad8606c924ac0ce63df0c27ff3cc5975c6cfc4f55112717f49e4359abc6d48a2d370210b38cf8f9a92012406b57c9a4ab935cf917ae452c895d810b7a158166a7b8daa24d38080b68aa4403202b2bca8dc14e2337af5896e9522a727d05d13a079bd420a40e339bc432c0d4d5139a0d49611e1b6c9b19d3b85ffdbac52019b9d5685770008d1d5fe294d26e728e827eed51fe0d77e869e632fa9d66796880e0ef025947a88edffeca14e95eb89f53555e2c274b523a00b0c2d7fe927e6b59e414e3c8b41056103f5c9a73506d899fb2b9905446216aa30c969790f6ce970626803b253998c2b283458a39c7edcab9dbc4ba667bcadd1af2b97f84d1f395a8a0f58953a29554b6a8c16001f97ed18e47f23a715bf17a1af304e1181e651eebf3317fffa22ee43af86462db101f7f655ea0049a6e35fc033ae7a6ff9c91b543651b1e4b547769986af0e0771690f8343f4817a34958e4d7075a6aae8ee354d83f568a4055874675458d8be44a73776a0d39d39f130c220eb753d96774bf29d424abf429192fc3e9c5b74a03d6fdee2fa21ffc6f66fda82ffedb4e59a29831e23811186f225baf21cc60893a3246cfe3df490c8f82ec69fc54c0abb3f3a7ca922c87397b1f4aaa2f8f66f46150333bde44de57ebff07274fd368bf526c1e84115374485a7fa5d2af2a5d60d878431e5d5d4784b1383209ff347808cf142f4fcf1e4440a169f53e7bb8924682d24b36d2c9d3425affb75e5a34ef3279c3bd8537c0539b56a597df4e0bd9b1b5be8ad4078826551a24dcd77fee558b9d3c24e808ecd87e4fd8b9cbb3163c11fca8e071954c665142630c9c50fcb86881010b6ac3ae040e2332e35e25f664449c12d9274c845bdd297aa6d634e1140d9ed2be33edc209cd341bf96e95235a75a70bb9e6a7f33489a5174ff306de9e553c2fd643d0764423a6af17971b510515a2ff3571b833802459c008f2d2a5c4aad5461800348c642627253bfbb05b09692d4e39ecb828006a42de9754ab5b15145619ad1bf2710124e45db30c62ffa07ccc28ac53e3be649a072d0616b3aaf2f45ed3cc7c822c6751b0cdb49cff969f6a0a4b8195dc7f463b4bdbeb287a8343b82280739693294c53265d4e13b8e65d9d6da95e1ed02767db25ad8eeaca6a49bf47b259cb94d78fde2a74e7c6d35c61577c874aae8d78724495cfb1eb06f7e19adbcf077193d6a477add49c8f4c409b0ab36310e5aca6d71a8d6768c370334fdeb5922c9108b88f706ed67c77d1e0603ef15af98339af707903e4c344690c75487f9f0c2be0bf1272a86c89c2ab1ce82cdcd126ebaea46310769e1fc2772f7bbb7bef363807a949674303a225e3f5560dd4c880c3d8b06f84c89ddd5cfbb28f038eca71266ee0363fbaa5f8242e3d05ff2045bf12741e667e2b6388f16144448552a0812ea29d87c63ce578747a295d0c7c7de423df26effa5dcf6af1dff6316f539ca1a3bc6d1d07976674e1825b6a8fcb2f5bd8687cb73c4490ad551fff52de7407866076b8cd31cfd6636a724f407f20344608d3acec1afadc2f1c84f93a399db73f1d905264d4812f022031cdd1f380b2baef5f23b08fdde8b73b5038235c4b06eca6f845f577bd85422ecd5c86fa8a89261253db25a4155941e7c7f53842095d269e7d19902084db9136881682727d3b11115d6734a7f8a7da7cef3a626b9b571921690a37dcc9ca758b390ce7af2da3ae24f2446843f5acda34599497636f342eb926b9d6803e5e818fa528f6e64511dca3331af98d380a66225564803cd192662bb75cef35a660d0ad504b3ad570f68be4c41070eb0c7251a8a750a2def560c919ddae8bcbedf7e9057a6a21cefc205b6273c331e23f980aff4654aaf56f2761d0c52a5a88544e1eae88490dc9ae72c113c43a661f49434b2c7aa81ac6cfca62257c5fad4adf9191f24ca271f44fd246e69b306e30f1b00ae2280266aed61d26763abc634e87c48d8e1699c929bc47520cf06237a8d884c68974832bbf532eeabf9881574d11961a011c278b1a854c481600b6aae92093dd3eca79c186cbc8e28e03dc1994a1bf01cad7ec6dca923a8f1a1d41c106daac8c5146dcd0280f686b5f47a5700ac51649304e418ee3f6dedff8e7ac0e893719890c12a105de5f06d34a9e02be0d4116754dd66086c9722570047b4b268bdb2ec42904b862f9df601292271f9e2f0f0ed5f8296afaebc5cf80849ed991e8ca851af3a4221d74f935ce241eb7c2999c5f642a83ead83b2fe92e6976446b334ca3ef6867a2641cfd5d47cbcd52970e49f61f58f4092e27b316be9f1cce2999d5d850de173fcae222364d8dd297e0edb6332ac6c2a8a445869d63887388e5df80180ea858ef1b25193fc7784a54890d28756e482570fe4876962db945825977aaa63aa1ed41b7c83bf6f8ff8e68bd70bf4c3a72d93fcf62d73fc9a04703294fabf343246c6dbf92e3d715c27d9fdbd0afd39e293fbd1a721b732378e808398946a8d23cc1d06ca38475f5210e46c88b6dc74f74e0446d04da29190a18ec39558a0d673d35db78b3991c392bcf83c92599f95116a35aef971d10d71ceab4fce0ee02536fbaaa1634aee4b2bfdd106809fb4381a8f528920ca0179e9bbfb4d4a7b333cc029017a806e2bedd17d38bcb68a45cdf2db850511f25808a617ef9ab4a9dabb4b848953d5fdc08bd8c7ef34130f7a9fa3d8343d03c65b774c2eec772372f74090c0de484a336948620146df6bdc466525c61bb7b74f3503f831273d3f42a700c8ad3262b2910c12cba8ad7703a7282de0ca64c1a7199cb9af7af49ee215cf3fad3b61c05058b6f701c239f4c69fcc82a41e64a667150c581cbea423aef7bf17aa118affba64bb5ea30f341d7089dad70348b9fc5646ea39acbae5da49d580919ac708373f42c30049fd6510e6f3be8d1235f66995b5794fbb5228d60ff1aa194c6866d30905e793d3593d96d59a6921f555266c577635bca7f826e8616a39c5abfadd4ebf9de47a32c2f39e1590d0c8aac231c2943be69dc8fce826e134e4cdaa5375d865838be9555d90dd325eb9e5f110d359eec0b0a5a546da57ace9d17d1e7d6c3823381f6db44fc725f43397d659766270b6cdd21be33ca729f6dc3f3d6512ea62d674f4b78a4e87dec32fa1e789704073c153aac0d76700fc51fca3f659fa77a89b0906b95f19a8ed11130eb96287e0047f77bd742b904e884a8e236c1585f2f4ed721657430acd5931821c3749e5df3ab09c2d0ce59ae408b246936169335147517e27cfe21938b1988fabc706dbd466ab448d7dd1e787af01c9b24bffe79aca4469915222e7dc5a3e960db3850e834b929d1d6bb62e0660762da70b9ba32cb790f3f99b70aea59fbfa0abbcf8b21b8c9d90e7f1027dcc3f0d72957b3a627ec88d5ac3795e0d63518a335a203fcf777064f75147c8ade0a11210cbd60b0e377d8bdd0d5aa6587b6294440de2edda636c58b1961333edcdb1b89d71bb9618f403892f58439864f63dab2b523c89003abac613f32948f21097ea74402cd897c79e81a5ef2e6d6abafcd002e88983f82a47f0cd9da6130e017796df983173818f1c9241be97f06cbf311105c3b4645135636dd8626795f60aaa4a52b5913f26a9e926bc1fdcf3d4c4bfddf4b49cde1ac7cd2dfe51b157ffa7707e9ea96a7173e799fc953d75d00186f42c37ee11491e8fc8a5f78517a4b0ea6ba82eee460855be906844b5770da5802478590a9f8e28f020875aaa73e5088bf428f42a0184b4b103a99e0e9d5183ae524b13a6d94f29178736ceec4a28081ab357c0a4257c4e1738c77e73bf5b1a359ee28e197d8de4c3873d823ae2b44746f0005482cd9e2754e14d537c4d94da6ba09832669d67e8df5f648eee41b90391ce94333b1bde7d0eccd805dea876d7e92e5cb7dbeb8d693648fd3f08b31e158326af20de0fd75b9145b8a86bc6535a63842381d45fcc71316caee86f4d696defa085b3e9f5b69a40d549ef29df77cbf9c3ce66cbce9f00e93a8154b2614ecc82a8d86d231f6fc359ff612596ee319d466d86512cc590e107c715e1161816bb8b5be24debccd633e544b04fce6a927f17af25c48823ecc1125a9043c7463b4a488032979241ff5c4a63d87530aaf17ace8cf6bc3e6a5e6d2949d9c0bd68e401651cdca245a757bda4b7b0d14e3c7cdba546aa2916309dd1140d24ebc5cb9a11034a150d930e97c82068386bae508d20415a3bdf8635b357d14db504bc03bde4d62015e72230acb5c567e03a95fb6241d4103ac493c7749dba78af4833c062a3b3594ffb5bc66449cfeb7081c8bc7f4ef1927f38f0b596ef7225e8e4b2a76ee33ad78c4eaa183bf5dc5b62546f099d1130e125e49c1dbd5fb4cdb9f220bc7558ae44ac45414790b6cdd6edddc2d93367ab4b537f88b361ec09c08be176c2ed19cab7fd661f7eed7fa781575b13cf943a8f55d4bca6da19fef36b8df6aa33547fba360b5425ea92284793a59094c52a73492de2f6fb70a3df27a91ab2618e7106f3581194a697db6fab2da37604dfe37f9c6a4fb42f54ecd153747453d7aabdc8e8f8e5feb55ef8db94042037c108881862430e9e41b58bf7d8605f4e7bbe166faeb5dc0b54876fc723143621df642ce8071c3ddf68c3baedbed86dbfa2351a24864a849b781feb3c0eab5697f702d0af1d5ff6ee17c6737f1317c29183a22f9ed7b96071976e327a2f197ff38fe244da3ab40730528de7b3d47ea8b837656b93cbc5080e24fcac25152ad62c1d46a76cfacc2a48d9b048cb8261955e174b8cc2b3160fe9781c629f94400d252c4bca61c46a88ff5b452cd077651e1ff088f0817abd6aa0eae8c44d2d77140b3344527038b4a457fd4d047905ee2302e6dbb53e7bcc8ec72d2128d4d24e5c8c416b02f6b32f2713d54af136fb85057fb3b6825dfb9037b59ab0a77bbb88ecf0d8e32efc83d8972790c5048d5cb2e892467995cd657d521234d88d5242f7277152d110ef06663c5dd0b1e7a36119e0ddee6e230487707f4417a3a6f27580144805b4ecc1f094d9db50e986fdf16449c10cc25df79c30f1d52510fcbc0da7b9983e366fcc10faecdf9ddb8dbf65e57ec2c51c777a78d0fccad7002606c773b7197acdcfc3a8e67d5dcf77bb62bd522adad5f545003334ea5f4e3ba7369472dcf142dc4e341b453e8cfbd6d9af54c9828cd3931e16a4c59e575243ddb55b3706b5f7d9284873441cd67e9869055c7b1c141e9c8f316058a21cb5236ddded83c7307ef3d0cff0c3495d205d2cc8b8f506a1875e4d1a0df14284336d9db7c7ae2f258fdac4b43d0a1bd26e539c9ccc93ed264a146fa4c69e98bd10508bfc0ee4ddb17ae95340fab8cbbd184834e54102fa93181c110c618e80d933f4251bf4cd358aee0c6afd7946a9b941d712100a8e522843541294fa966a875a1ab047b7fbb7337b670fa9daf7ecdb74d003a3a5d07ec23c614e31bf4fe81f87c13d5afbccca4318c53caaa5f6c9e81606b80f4fef1d2eb0776693a78bf74e8b6e7856919e92cbfc946fa2c69819d3e99d019d5aff7bb8945867d093ce69611e4e89eb5bf8bbcca3701fe908ad71afffb490fa5df2e3707ca0164e9e6c126598465f4d13710d7dcd71b7ec13f0d76061bf7c68c11348f2d0dcc6945cd8856c310115f8ba394166299eef1a69e4bc9e3e021454eb4d0d9ceb428162aa3e9b358db36ad38511c2e74d2f4a81bb93089eb3b21cb1fcfcd954a3ae8c8e4336b5c70dd59b9f0c761c380aa5318553f6b41c84a6dd44ae283d1faaa920b34c592787704f400ebdf935df0108783f7f25429110b9a61dbe19c757b4c988a55b099e884817c4dbcb3d629d9e9a2c10de61bdfff0abe295b0175da5731a8a29bf9f0bed6c32a4c48d4f7bf89694127f1a0ecb8d24fe6936c7d45109f92c52ff38ec97ce29ec07ac73011fd4b3c1aab20171d0fc3e14c75bc3532472583d25ea8f800e2248f6f550843e4af44a40a4144b53ed69cc62f409589534cc1c326abe3e0fe406f4584e410cd381606d3d4986cbf5b694657f5b2b3b3f2707f0b58523a1fbd8942095142e2bd417e995018e088423d7d85a2ce24113a449163c2833350d91dda8025a2b42c038b1d7cca80bdacfdd4bb7a574cdc8f5998cb5c1e541ba8276f61664a90e6dbc1450f90cbc363a2e1d17779161e5f043779069d93113b24c18ed1fcf3f8df73974e7ad3aad1e34c5604e2f8021b0cb897632446ac6b19872662e306904638707573e50dcaf269afa5827ddfa089f48dd53253507a578e78fb3fb856868f5593cb2b6abcc2c5d8dd340f22d41cc081a26edfb8f4dbd7f67e75527792c277aba97d17f6400fe27d1ecd428fd6ecaa163ba851377f961c2632a8d1922e64e837d68e7f1d3ddae4232942dade2592a0616ba971fd9c50fa3ec8146f21eb7016dfbdebc8c7dcdf39d99b6ee6290c06636d9c6ab0ebbb6c3c6a514e7e7ee9e80164b4b279af1383309055fd0f8d41caa298040eba18a04e4510732e20181fc44aa5bb620d73a2dfcc091ce59ace62f78d9ff3f1e285d1300bebb941e536e50e28b1710385500c4e2fe2949b88c7bf761ab36eb906a16822fb48c1b97787ae8a79a571e052f51185c18f027666fedcb61b0d80b65f1fbf6b604d252b9c984b43f1073685c7b83e8189a7dba41bad2ec87d05115982053f7377a2faab5b7a9359862a76fadeca2175a7f3a00fd40ecb6e667cf9fcdcde94b68d9635f26a7edd570da36531667004e11c43f2929b2debf36495a6dbec61c6b1e50c5cccaa0910e63330d2a1d00843f6ecd22f67b5120337e3d282b856ac04061d5af630632c827614088fc94e4a3a7f4fac5164561cf666ac5d6b91f7264ff150f39b372f2da9cde2d55ed6e563bc742f5440998658e20d4240213bb5a565717e8615aa38856a372a313e36a40f75f5d6b16edd14e577869ad2aea2d5c6740ece327ab4c5f1554d120b0d23ec0448d867ddbc5da4e9c6fb62051f7b169e8143241d30484148782ced3fdafda5a1b7f0a805ae52dd13bfe07a057ba33051f621b9e2e60b8a4963209e89de860fd3f927eb570932f1fff512cd1a90bbfedc2345af1919bd544754e08ed88f9fb913f00aed1951c806b72d1b0cc5d609e1c55d4b8c518394e07e39c428dd0dc1f54ad7f30dd3a8c5e945ef1cf2d3e28820357c16a31513770741af2165c27ee9f28cbc7b780d96335ee76292f8adef6863d94a9f6a198c8ec143b277cba73b1c955cea512d92cdbb76101319f7a114dcdcc34a1e0e4497f4fc6055c3dc2ba676c28533f1f5728b382220c4b67582f2207eb9a23949976faca21983f5577b61ba11c3e7479509b558fc08dec88a32221d881fc4ca12f9b441fbfe738e2ae671dbcd07fe3bdb97b1ff916e795fb4d0984122bb23d6c4413ac39a2727af698846099ac7a478362d38a4bdcd7899bfd51fd739ce5ee3fdeffce7e0b728bb303e7b105615f21385d2d29352a99fc461e616d67e1b4f810d3ec63e1222295dea7c2aa9e4965b7a8852f2d803e9c1a163ab0763b5b7f187cf1aaff5d1f9a0dbd5695d5838fff5c9c69dd2e46de90e169e3f2af99a49e6fe06733c85b2ccb0489d671dc0911915238ae7302cbaf925b8a14fa34737079cca9858d80b43fbe7cf715801deb57605559c97228616607e3969c5468708135eabb2d5a2c39b18dbc22040072e3b5c9bb43ea24ed2ad531b317eb87bdd594a3d61ca3f868e4c2d3240d3eac17e41c689048deb0cb3b31973becf2f2285cc337f7576d1b2954dc149c1514ed93db8233705f0aff4c0c128c7482595904fe760416b7696fe852ace0867e771bbdda1135bd086909f22fd2ac149777d087776840ecbe9f3ba37458b2756ec7816536079bda81dad2a6d674a5f1907ac8eaabf194a3b9f35433835e6bcb559ad880d478c14a3c80d7f48d98a0e9b2ddb793222b1c5a60019eacb583fc808b6d49c88bdef23d93a2072acd4debd9206c9dc4b09bb1e339b77c94aea6c003380364509ff226fe8ae294a788a5cf743dc5890dc7a4ec7b694a9e6a901460bfe8bd19a580eb814f75b5d7b59730de9458104b6407d7cb58f0976fe91cd8d827f27c8ddbf987029bafc7437417ab4b95b35a581ce3826f2189f8b055626ac9eba4d8a6fbaa1df620a12c9b1eeab1fec0f8f47f7e156f94e888a93c5a1b60767e05c2ff89c58813f56839d6e0fedfdfa914824473e223a27ddff1e9a5feb8fa931646f343c863cc8b241f9d471e958adbfa7c57870bab02d20db3e1f955af64e7b61e6c1075048c5c56d087c9f3ef1581bcd747a827649845e1a9a476b2e46e1f99f0aa1a96318b25910ade04330fbed708fdc5b3aa90b4d100203784c8e2d6ffceba1f7831f8cb83db4d6f350bb9637e55b08d662fa00c18d147e725b8f1887ff0d4ebde3d111d791f15f2ded572e4e7f9142327c39ff86a163d4ce6d45c6c7503dd4255e048aad152d57932756384301038c09d8a9a8e44696923547bc37c6bec7d68a48cfc4c2eda275b99897ed878f9e00ed3bca7b745ff4cc6e148e8ae88127d3e2231a6e94fd5349aa6b8f2f9b5ba04d6f752a661db117a7855c113e3f7a05c4a8563fbbe46b10a6bc0fd48efd3305494e1b8e41a01de8b6cf9aae4202324f979d74508e2b2b7766745fe16e0ff040a177ce08e0561bcaf772dc75cb77a3acf1ced6e1a227189d8e2f6c9f99095f86c11b207ff589c908236937266f79e391d1192d1db131cea155cfdfe1dae109de866a5d55a0b3cf5e553912691ec3338b50ff2bae6203bed5671ec56152d82b99044736464809df0c326c579487c5ccccde99842dd9e35694f14f26497355c8b22e434793cf069725a38156d97edd8e6d795be6b8f1db389fadf4c5b4170efe6261f87765d93218e83da4cae9bbbb7bc53c81709664ea62f503811cda3b7930c2a5768e687b473c6863065d2caa7f2448641dce9de2583a628d9bc0a0c7f209d89f6b80bc063ba29001730a646b21230bbc18f78e8f348051408235df6e753c06afedf38d4d15dead75f757232aeadf1369d0af8b69cae5e514acaf8e8950ae8aa6d20b72189dedd60de6b095a969551a49abcb2d337783561ec8c75e4d35a0b3c825e10a861ea1709747aa6fd251d6ab05236f70353e35b1c520ea0ea9fd60680a36632808e335bbd1ca7ac2060697858845e209a1de2d8cd6271f3bb885c1b866c2973a46e6e4edfe81d84c288498817ea8f780c18ce5f23cd4dcc35e5b26ea71812af47bd78cbdc829d52b06532731def77c634a4dd4ee765041be60fe4fcc9175cacf85fc8093e28df904f4590a0933e36db667cb77b8773607f77e3cc5ece6aad68c52b0ffdface2d9835d5dba9c31fd84bdd0b5c766a0083ec3b919a2728e6bf1123e4bd1015d33536dd02dbdf21c3d8f6d672910e9fdfa1034b35b99103d07fe36a13e7b392b747590b6b244cf98fb0cc4642c38118710563dcded58a897eb9d0fb42bc10fe53be342dbc655b06ef5c08d3ad5b66c0559ba622b0637d8ed005e7f12a98aba9e16c8ecec2c20498081aa41d0446cc02f92f4ab5ee0aa9df5189686417e67f1993b11a63d1863fceaf293ad610f6d560a7c07eea6fcb5749199a660ffe6fae677532ff3a6a53add6c0cd8b654703b825e37b62ba50a59e2bf90178bc5373e70302c8f720a9340a4a80a9a660d4026752a76bc5cbeb3d2a5a050be730dd29a0d786c87bc7e271e158129a8d8766f4552f67f2a15c7d5f32d1fcbef7acf605b68388138aa89b6e7768e4436ee2703bc7a26f85b38253e926d07c2aa93a081d24f1532bce65337bc366705068e03ee4e06758aaf2e8d4dc42048bab2ef62b20a4b7c5a5f34436e6a23e951bd353989e237180f20ee29deb54f627eda956ebae6d7dc4b7573b4e221652ea766c7ad9b3704b9e037fd6c8a0fe3d4c43d636ebfbae7c9b1895cc87f26e62c153bf6981d4479d15018798a27dd69ef63ccb9e7a480fdbffc29f4616f23aa7ebd3fbb2b9e0e797c16b361acee6c1623a059f870d23f2c789dc1fbf2c6a057a09a4629ab53806e33559454cac5e8b17f542a8d220a9a70ce3627dd47e50f3c141688198101ec1c1be2c9d2fe59cf9fb119090488bee4fd99651b7c960bf26de8f74d0328555e46557162126de6526b3a6b6b8c241034aea2503cfad309a53f78900f5536f9b538cbd85728ac40f2007ce823cdd78bbdb91f7dec6b6c168100a96677d1456623dc06ceb1acf00f03fe83ec8eb62d3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
