<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b13285920c668fab72ebf11e1b78984419f7f23f2242b292341fe66fea5624f6010297492ca6f65c490c300710e8e9c51182f48597ea920f96b81664e7490da73f79fb5f7978fad08c5d7bb97fb62afc4f74f872854461ccbd328d0913ac5a2a789fd626b98c34d14060ccd7c06570dd08a8812877e70643a8bf4ba33b79981248f928274b72fb34566de77df1e2842e1ad8b458f3dbe080f8fbede08406edd017c68f093d6a83768b2d5996fd0dc4c31ed2a3d8b38ceb678a2dd5db0c90e4871974afb676915119f76175c64d7b552af3a8d21dfd1a377487ce03954adb8bf8bb906b69c71084e4dc3ae442167375b38305d268e450996349e30c0a78d109e42997739330fe59b33b19bfe69aa5035c9f83ce3c0674d7a7820ccf3e9196883be483083235f390447687ea8b633b0d1708f12e16641d69722e9c41ea1af2292af36a86f4084a436ff1bc533ee9e38c1f8a689df244556ff05a133ccd5f040334b62847d7f54d6389636ab2b0b0eed4c0addc1993e0f7c0c3832959bb15fa389addbd1072b2164c571716f4d79ca193bc692b4d0fc6b06791410d4a8d88018d6e3a0c46ae5e19dd2f19c13be35869d5415ae65598f2ef34144b7de1583704fe4c68ca32aa9c7436470cb5df9e4c5016d2e555fb05a83a3d37668c356fcaf4bcf2fe3499a493d45a2ef8cfc489501b8533386efd115dec798e6a5771ecb9cbe69aa124a638b04525123779d4d9ea5943d549f9ded38f3cbea100e3ab02d3852065df73edb132a5164fff2622083c2de61c67eca84d804f68c6e9ed73f77f1c9d813a0adf99603a939260226136bbdf100a54979b9ad27d2b47dbaf444597aeb1699ec98bcf2e2debc37710507f4ad480a0bd7c9140f5942d4f148fcd14c9b1a060122424b91455e802aa4ba55e1d53559797af66f324fd16dfa7dedf59a4d264ba7b6577e4c66aa908ecb87956ad9d590177708cf4d7d5d7b2aeaa1dc26ed849d33ced86c4c7d417f471b3ec4faf3c2bf61b552b7be458b343c4bdc39372feb6f82d899681477b8089f6478e26019ef9799a555f8b34d1205b4a67a7f75be0cffe2c91c588ebbf2877990a04b648d92cead9beb4e50763576f2a84f1e43eeb49f637600e478a435e3f111dbaf2718bb60be7be089258d19cdd7a5e106fe23b6ea53e5a322e63428133fb022a688f3581ee34e14085643c7a03e10686b9bdeabd74f095495b84c32b5bec213d1b06e43f7f0c1598a8b09510fdd4b0280e85c8b02880cd9366ad0543908ad9f18445b1e3d2159cf46d0ce929a9a7de9105aac8b3b357f8eb8530892744360939ae749f30ee35de9988137d20df92cb4e8b088733eb8e4a8842f71de4d05129034f1a0dbd1c31dff9d479c002b90fb783f24ea398dacee646f99dbc1396578769f437f7dc82ef8b3a015e6d4bda5a6d81bcaa0e7c024055c3e5b86fbb05de6097414b3fae87dab7f16b5b924fce10ac7db37cc993e1dda75446cf45a52881ee8fd1ca5c52ab0806fdc645ce6e98cc3e1efed823e12049f936bebc423d6b2e35a74ae6e08f3dd798a4cbe6801f1eb08d71ad0f441f4eade262c5c3bb08a93985a2ce5e2c695bd7e11c976f3d168e921c1975730a3195710c86f154677c17ac525efc1ec497adda4b65571311970277ed92c6d2894d9d238214fc9d96e08c9aa777d4e7238e86da5b378ec5d5a34b1edec02705d1163c389984f152154381873cc113a2ad12431260396e2a485a01503432e08bc06ee2b29b2ce9a4fd5bb7d6e4e34677b30980dccaf520c5392b7246769df9eae68f99d88df90bad5c5eb42c555673e9a69def4fd68a09be8b6ec4f4e45e3a1b93231abdf9a4a3f4e4d914767028947db7077af8582131a2c2dc47e77c4a9918c82901c3f1c651ac0762e095f265bd715ad2dfc51803e5e7218143b4efd848ca52f6539556d62a396240c452297d5964a327bebbf99e723c5f09c3afa113267c7080135f3707b49e64210974d0a286aaed661221ca819e9b5422738ded0807f4340ae8627cf89aaa3df4be5d539a022519331b490904b1e1cccb05ba43238ef08686b7626ed9690c8c7b8ccf7abe4cd31bdd8a38847b835a62a30389c9ffc15db8b8027dc17c005a62ffe325e0ebf6ddae7549f844a5a74dcbdf85ffaa002cf9383836c10307af14833a34c05942aaa7c14ffbfd8221ad3d981a05c1a0a4197fdb51c64fd8c4e56aa7ff2ee44a23a7d9e10755e579aaa29158fcb860bf02d0c4727dc2a459891dc1652001ba3c961b8269f5de14667fc79ca4c5cf248b1ad760771cc0c60add0977a63572c4512308719756dd1d44bd3bc5bccc72f4444b41391718a785a6e0b63a89aca3de08cbe30be13f484ead163c15fc1ddf4feee45ffe5de0ec05e8355d7f73246424e4883d82f498e2a25b8e1c19f8063a43b6831f83a2c306558141c1a5d0c0db72ccc91606e2ae767a135d6fadfe82a4bd7c5046c93f20f38299862b5b2294f121140944baf6b8b2e75cf95b83f16fe04545ddccbe0f85d018a752a2e31419a11fe843bdd5e20bf9f01c2460a554938d6193522a8e3a172e431247cca42e09af6b12103675ae674c86278b2e946393ac79785044ee0efddb16d954eb1ae69045d313b22a9aceecccadfea2200fa6eda3c8da6f0b56b2085a0f01eb386f44d50496fd2e2224bf01e4cb13ea73b3a276026146c96413ff18a24f783e715013517b21b940cb8e766d13c6c414cc1bb00c63c48fd53e7c5480a2e98368856e8e3d4e3b5bdd82f9f7195b358d6ffd41e449d1d09960966a06dd35f0020a6186b01842b3c79d8319abca295837111de491b88e6c0cd1c5b8a85f1a6e5e3f8a0125265db0172fd2e6ee432ce7a94b76dc15282adc6faf8c129f4c07e10485d698b702f7860c3eada7d2ecb4086f3d579b0518fb0accb9855919c879180703ef35c9ae12ec84698411ad957fb12df42e6b2be9458c71ce19114c683138a58e40a4d4dad4ecc5c554291a32f2dca6a1fbe1ba28fb819e5d4376ee3e7cd85e47424e9a8e4432f1d382b0f63929a5befb056db2633e8a27861970a59aad758ab4bed5c933d7b1c7f801c9d1204eaf5e0a2b263f6809f24d1a7ef54434dbe9da7d33f3f1271059da3e151485e56d537a8497f7a5ea4348020180597f2fcb4b3b00fb791f431fde76b771ab61358369e10502d724e1848fbee602bcfeacc6a7e7170b1ff169746346b3b1e29d6a00f027fd818286a759f72780bba7c8c205bd7b23be50d6e24494ed0a8af825c05b3dfe9aa80a262cb679fc7be45e9194b21bdd192fb730771600e5a196c756dcb19978656c02b9c1bb897a7c349fe1ce3c24c09131b95a08489a70fe80bc67ca2b3f59e0df14cf53d4ecc4da3dd8e8c4c4e81b8cc929bdcd31b2af5d284754f6eab7521216c28d9dbdc23d74e69805c7c970ddcdf64c25f0c4fbf1766567bd5db36581ed317add5c0e51fa537118bf5f74d7538f94a53770d8bdbc62c3158715814924c88dfa072422f99e87e4b396003e83402866ada3a8b839ced85191ed60431bc1263138d6dfbd3c0b85aa908ec93d63a83cc2f325e72dd455ca9ed250d4e30ab102a9557e86e82d545cf9de172a99d1e76183635512d66a69ec62d1c8ccb85b4ed38ce44be9180947481506a1592082e31571bd5fd728d7e1ace87f1673863358014407b143f7bf3344393c761b61df1df031883468c662c99cfe76de4063a9c08447fe5d3d212a8515cc46a0b4754cbb842c42fee7a186e615c90989d32ee1bfecd253dae40ccc2ed0cc47c0bc8401df34d839a80cb678e68c2904737a44953a9d3785e38b027100f63607077cf54378aaf6c56312fa385c87dc3b87844844bdddb2340923a64e8a5483fedf6cc01e4f177c9de5a38ba54123e232bbde70024473240a7100b7f5376e4e27a1b4666bd8edde097eec453ede8e640555acb6447e1bab9ae7f42d1cd8fe17be6a336cf474a33773e4d6e77fa225b26b7b84e66671aac6c8ed9e0c4f3296b27c194de3073c6df1f5fe22cc7cba170067157e0f262d2ebbc1b579a89b3f0c2e32dce3417bbf5a5e2d1f6a08ee9867f909b80de22767d33b18b2c3fa3bee5ad4f397e652267052820a0d2033e1b9c450b645ebfc7fc6094866e944c56ce5c3c921bcaed13f52684c5b0ed47c9757cdadedfa9afa6889517e2845067d13e064b3da0394ed9e1b98d7086bb3cd9715ad42eb9a4b18599d7d31824af7f2d429d7a245a98be0edb5e09fe7a6dd782c1ec3c24eba73cde6ceaf294ffeb7c7de25ea2d7d1fb199d7121f5c51e78d9ea3d9ae68b332a7d2813f0fa8cfbbce2ec372708026f10eb18a383361d4d05b2324cc2657ca6b5df23da3f98d07641f410e4b6a639d5a3a9b4bfe0e5757f10d2566c7d9361b5565f3e4971c012e976a97c0f144931a87e378618d626d9869bf9400a2714dc442ba8c467d1623a4980ea5cbc7fc6b37a388e1a1896a73688f5245cef8160e211650eefc05523f433a7f1352d83b92c56f89b6d7ba927c1a3d30e5ac80df89357a7e9482feef6798f2cd37fcf0ff319517e4d7c4cedcb3356d63f0f0b6426341bf3595658a89cbff5374cef0a1e8d3aa9f0bdb1863f8ca715a1c62cdce64335107e6d8ea4146d7575b1969be42a591062954ca5ceca59fcf30931ca5b2dcad82468d7fdc801e39498b3a932705bb6bda8b096bbe5b244ac1846c222c5b6b8b88695e5944084d1a1e58284e0f784d0df74d4446e1742e7646e1a271e373cb5bc1daaa5320092e0e0c9550ee6de960d4a69d04dbdca2ea44f2d756fb461d0548b14a5df87e64dfcf210a53623f7962b2280f0beacda3ad520f8c5e3bace672b82181d9178af3357ee871151041225afa2bae9a762f88ed7ec72bb5a2c7d5f6bfd4c3b64f128553771482d3163dbbdde5fb30d5110103981b6a35d4f50a9232948e8f3431dee25ea3c4311e35f63f3fcd4f40d133b60453c71b373ef10e8732e5d97367f533021c24c602d4fcbf30b7e0bc06575f4ed7b5343a70f1a455bda71549ef26faae45d0cbf6dce7c10b28cbdc01e1a49e26128d6f1e6eca09a655df54e5d261a4bfe1a4d2a770aa92513e828ab15cc16c1e667bdef5d7f7b7415fbc823fc422f200d6cff3efedf606936c83ba672c04a20a9af049b8efe9f115762d4df4ba43629120c0e6a124e3ec0e9668527de2fe8a5dc33ac8c793be752700500fbd9455e0f548711cd79edf9b7be53cdf94531d31158437437749afc090a15aea78bd7632559347a54471dfcf9b883b621dec383914028535dd521c1e54d91b52599a8540833e26084d6ddd571426457a7fad35ea23901ee659036c257e14f9c0f055438faf278659d037af17fa472daa026df74ca0bfd68381fc5e763f57a4585087fb6e3906fa6ced969ef849dfa116ace67159eaf624c17adbee066f08af6b28a9b245f808680fcb26c09a352e562cdd5f9422bb501455d47403231d1f4f0eabf2529ea4e721afc50aa3198f6da4fab9f89a800ca671a7c482d359ac186f8460c67beadec6144b630e12611e7ae97e123617567c1ec056f92d8c6b14e748964d582e94db740b9734f2507732f685c44ad0e6ff6d9a1ad0675db491a5f4a8683987043a026889af81564de66bcb65ed7cd0934c3befc16f0e57c6476061a5c93ff32a086f1f405b7930a2107d4a7a7ab6b911c69b9d1cd72195600e3b6d9cc9cfd7c241d6fe4585954ee090d6ee91f864e2be0afc85e9fd3c0190c4f9bae626354dea5875b22b65d8a2d6f0f032b8ecf6b1ecbf6769c0b22a6d49c345ea88ef4f50c893b729ade33ba5d9851ab65527e6c95e64d78250af5e10e3dad053b270f7f95f58997cc67a21ab728369a53fbed1461214ecd87a1e5c784af058e601407d995eb81efa9564887d537c56e5fdbeee43db53041306e1a81e90686609f9bddb9bd1f4f23cfbaef76d7844480c9463335fb247161dc8552dc2307b4d6f7729718f140ef9d525a328721e60e92ef3ae823b59df37618f8d4970cfcccd77777ab8ee7a369e86a7274645f1b9cb77efbbd982432c4c9173e70ba56ed572482464930b69a334295399c688c586ad40c70bc071fbd9fbe70effacee0153548f703a2245f6dfe84b0a39796d2aa6f79944672236a5de731f9c86a653af24a7ef6a6b6d11e90c3fa2e4f3c9e6254b297ced29cf5e1f11fba2ec8c4fd92cdd18ed8db1c4b47f15a9d05051da22a889a1a4b14dd90604a9a84366ea6db33a1e78605a94495fdc2f2abb50bb93c8b32f2f6deee1a50440ad891fea835edfee2bae414cb9f1bb5246775d726d5e382a0f1335b8d86fef92780b5da0069c181dd0a88191808838ad54382ffc53af72c9c314da88f7550a323c4fe6b2abda1041d6cbcf22a96a4db25d7a6e9db74a49acf3fd2dba5e8905042c8be78248173108e5482119f7c142b39e22359d57c299122b60bfc74c085ea22bd3e6fd6cdf2f10c2e85307a112ebe5629b3f2e5f21c7875f9e8b91077eabbabdb84998723385c23f4ea4e90f11e86de41a5c275324d3398ffbc9ca25a1d3fdcac9a6227e25dd73e40268a8a0b1771c065aae690491e23deff44b630e39ddaf5ebe7c1a97c5e9c7434a244604f9ac329007f1a9a3f8180b4e5ab2ae45a83d72582038fc9d5dfa377ea8c0588f2ab53b540833efc31c84100f1016fa9fb939725f9bbc59f80d87591b6e2f457a188aac44fde984a87667b26b43205d0bc40c93d477fa28afc44b66d79a35ae6e9faa28fc3b47f311a029c44a88974340ec375b630a95eef16f768e8f79bdebdf02715e547c31e29fa8c78a5fcb6cd8d412255c955e3acc5b90674bd117cefcff61f1c993838f789b8d44bebc6f87ba9f4330a0ecc7854f42d19c35d1b302465e5abec30413b805f87606d8410354e90b9724512402b50169f2ded2155bd2d6863d0c112761e4e7db096859003e2abe124fc7d54f8c08bde20fd4fb08302f2e77b4f79111ff1d13691c7b27e53b3626ce53eebcc493a9726a8b4a2b1bb78987602c89e8c74934e0447cde540203e4be671f63fc8bbb28af9a26156882fe4265bf7bd263359ce4d6d10a4dfc5f85dbb0fce5b0c2691d19a3635ee613c00e146038334ea68726c81a7088c023e12d10311ad4bd556b20861afed7eff63c23c01460596a650c144a75674b52e749146f66a4cd666bdf9ba6bc8ab7c389435ab745b5e517a2b5f0d0196716e35e2eb4c7c6320926afd69f5bbd9e0e2366bd3411da02fd80e59dc4f21cdb346f5c94be2664ad1b0f27aef890cf7c47a30d8a69af6a2c8992e2193943f559ce6e2ecee1b28a2a1c60de91b6eaab797aaccbe11720d8f5b7fcbfec276094047420b416d69e6038dae8bea03e1787f7aa18274b00e21c14bba83524067702493249369275988a49a61d4bee816ac150ebf7f702f2d4941d2f2a24528d757db78362b68f239756db82765992df1a82b75c9638cf05c68fed9cdc3d355ab50affeeb9c67a59c9d69f3c9321e19f360df5486e188b178a791457b5c62b3d75baf48b623d5422fa55f5e171b9db76f2decdb1cf0140de12c7b1ef087107ef2bcab062b9f9fb8ec3379ab9a6d0ce09df0406a1068433af269039d15a2b42880ecab7c3c9b0e9b4cf63bd758e74afaac9ee50e034e14968879d05ee743af335601c5c97d3cc7324e093ad2d23e8b0c1e9c8ea40e0a00f0e145d43460db581356075eaca0a62b157078ab9092108890b74c29be5f491fc690487e13aaf23170fe324a2e6d4044b44ffa6122fe7a3aacd83d455cc5ca490bae413bf74d15b4cdecd1e11970d1fdb5e812cde814e96512101dd89c9d8bc82f9a34164ad2494a451e6370e9abc9bf8eff511b916eb6f6c93caf70fc8b2262393ef848a90131308674f9f0fdf5712fc5d2cc05da481f90e363ba0b5f2b91ae35e1c22ce96752e28789cf443d41603e58e94fd131b69f9970f3086d6042c964c96f4c3eb0052ca7db936b49fae40981b7d5e237b40223610eff3dca5459f910ef1aecd3d7079c22241df2fd5563b9e1c2958600d453728d8a3ef42b6a47efa606709808ecb07190d85aef735d70cc2832362773a3da465bdc06c29148a0b7ecf55dcb26d02a7caf54d9f3262c69f28c22b1e8d4348ad0ae96bdf9732d9b67b3772b702f8c6b8dc1c2910505f196bd7a633b8ae529528cb8f682cfbbad8ecb14f90ea7a1731b7252f2773c30518ebe265e2dca750ca6869260443ad1867a5aa42f998845b6dcff26e2634a6a90cd803aae776bb14687af6c3c5464f9026781d877774e86c8233fb81ba34e6d65c5c8a5b26ed28f00432158acb5c7fc2cdf57fa7dcfbe120c521da73d0f7573c5ea414bcd09459742ceaa037cb79ed12ce9e3504893e15715c43e46ec6dfdb47d9c14134943498eb4bae89b866398349a7d40bae3b323375e3395da48f583a465c3317e13d560d689f8935dd434cad55127114b2450af43a9eed1c1008e40b0ff61778930c6c7971e39025c72b0879660cc101d1ff38bbc93d2b3656ed530053cde731b2e0afe4c15f539d75d7e54fa79d237ad872a6c2bca1384b3a4f239f1b96f2db75016100bd9e9e3f214d64daf3dcdd9fc30526e002446f4830b8dcb591225c5df034f6ab90d2f2949e40d3c0f7420d85c3513c143b12a5c69f6687e75d36206fa00df6a110b53ffe214359c23d3a71591045fb84291686bbcabe68db61d8aec7677b378a551452ccdcec843cdb52f57acf571c34ce488a020ded98ef9662caeb3c9b4fb687e1bb9b2041a1d72ce09c62411badbfb655fd9c1db8c3bd0506baece44c5200ea1e4c0e661af817d18c506c59c81d8141d37a734ee23b61835bf9faf59c3b3123163e001f483ae3688882cd4a42e6d7483fbc9b0a9f675672cb3eee1bf7f5888acf0a671a913450cc3b3d03851afcb93172c80479c2c63ccd204f059d717f5a4925d53f83b717e3a9deb73ef2ec870075d169de5a6ae217ab1ad71fff4bedfc15096c4ab1ccd507203c0dbbdcf18fd423c9ced828efd525c72b53b194dc4bf49b8af49bf194c156aca1da6fdc8363cbc399ec43b947bee82cbe887c14451ff820d4cb17cb9350cfe6d68fa660a03538d95f1ca3568f14ccafeb8a64f8c161ddce2e8641f2085ebde94185a52be7bf85246d9205da35f2d180d73f60f072c9a84e69f5ae2930b95185feb2c1862efe08244d9e624d3edcefeeb6393887dafa6a4f4d1dbf6c2f4ffc8559f27a32d199050f6dcfdce1ad7720ee0103a8af68c4eedb0277b4c1fdd2e5933103195f4643c6e83922795512450346bab2177ea31c691a11d1ef296d1291b6e4e871b2fa1ce92314931b2a0c74169d9282a975a77a65d304b15b47a994841c1f64dc020bda8f9debebbdc977f7951afe217011b88a2667dd6c6eeaad8848697da9ee5515df3422f83b101ea167f9cd9379bb8fde62229caed33d73a3a75119193964ca5aaa85d217b4986e5e48ef6d134caf1bbaca251b78a598e280c38b1bd763e0a14a01174e5b296b6e3e71e1c3947268345676b47523af0d990bf8a484ac13db9b0e036da510eb6c1a5c908da5348e178e62b7a309c43deb33e6947a43114f9f35fc65a644709731ee4acd81e7f9c4fb8b087221f1779d88722f22f70685a97ec56b091daf6a63e7c1e737fd6d49bb6f381abec0ec79ef2542638e64f536b14d79bb75006034cbbe233b94f397584ea71290aadde64d7cbd500261f21c8f7727ded579baf2ba8f48d4461c0ce547531469522fe8ba27abf8ff8fa102589d54a9fb839c4c81ed28c2865b0cfaa18ba099f5627b2b45167189deef67f74a93ae74940e58f63342dc6d657d826093d30647e526386a44de77bc4c5f1783f334601551df1c81ac6aabc7e371efda748429921332f7a4d27736064c2f3728fbf3cba8de5414a0282c0bfe0a1b6533506fd5101e6defd5c81b6c89ae95f7b7829845f5ca2e57a55eff9dc1be0846796933edd1746bc46714a0f843d6f53511eb8c639053f481effc9c97f79d86b86160224854d6d59484df0d08b1ea5a76a3392005b2f5afe300eb0648b1c83ed09eabfd8426a38bee9bbb236563fa836b9624159d15587c5cf5945977b6b23ece1bbffd9adeb49944ee9250ea28f9780f1f03a4a5190fff39b31ea27ac97006edca41e4975578d10be77733c81dc22d5092648942a638d4841133d3a4daa961e6f169cf804d10b416214b6e7a403d6464a222c620863c9832dcaa9e86fd893d36810caac4078984e24bfc8fe2f7ab9f8eaeb6fec4003ec51bd383c7769b23d1607237c49d6990f54c40a990e9a14ed5b0d3ca5d5e37d06181147cf4a4118b5e7fa3d9f58c126b106efd5b35e050855fc8731ca186ff504204f5de19f3a0c8da96039b26b281e258538d522ad12425d48e38e4dbd58ff83e7c1d294199b8b873ca3e7380ad56af3d3fb6f695152b74f498ce997513bc92407903fff310725560db0ec6e72057c9b0f8bf346baa27758254924f8527653582854154700fcdadeb69e60578b8fb6acfa1ca1c7f86e74b830b03fd2d2d614a0651c4b6fa86ee23cd081335c81ee9d079bf9d14b01b29205d589a646febac40423da3c40ea2da4d2bf055f586c28e3ebbf8c508fa1d06b698ac57760c33f642f37f561e4dc5deb47e93ee9427bce414a4dca5067b5fc584aa306ff8ce5e6ec020de110980ccad1897f51f5e4405af9c4b9dd20d422f347e7ba11dbb753d93f1384d6c77136510769836b6ea2f69b96b5137bc980142590f33989edd5b8f066d5a9bd723c7e8432ad9d5a2029854dec1c5e00a182ba23e661461dc56df025cc9727abe1c575f14259478b1e1b28ebe34500b1b472d17dbbf0f67007e5b933378b1d5b2d0f2a508b15075202d422936e547d7b43f442ddeeae118d0eb6b7d5a9295d2a99394f0e3ffe8d14eba578f6328876189852b225f67d161f2ca397b55ce75ccd940e19c521cac983f8bf0ce7e50b607f0e1cf6a543a1039923f6297d1c7c8f4e21612a33708629c3877e3e5e9b961ca57935253c0d9dc01b3ec85678647546a972652a9349b218ab4313218481bb3846899c992410f664798077ec2e9537ef8b49076157f53b9e638e3a31fe6fad922ef381f7b6ea36c3a3e87616fa36ac855083a4339ff103985cc4d3a4218448a3bb953dae84dc5fc73c75f193cf2e9ab65250076b11e3154380df13af170171fa249509553f2b8c1a8167dedf72d224aa8c9b92f09d048271b12ab610cb76828e4f055ddcf15d0222d7821b9986fdd3398f3638a962a8888a640165405cfeed358fb27327c662625d6aa25378d19728f878ec38182937f12a709cc42d1fff564472e6ef01bdd0da3f635af375a61bc9dc0140f005042867045b1ef2b528e5554f147c90b7e219f65ccec8806e2cf46441d66914094000f2613bd80eb4e727c92210cf7601f871335b24231711a6bf45bc24e0820b8fd8aa7b6bf1229c2792358b210493c016e600934bc3f1341ec72115396b5a96bf1cb8f413af89fc4561407c84b211942044d780cd98629c9dfc694ee01d2d92fb129ef56d760bb1af7785bb2da156a26c40b18cfd6ba90e9087455ca3156b890916265f3a243083ca9d2eeb418ca52f4255a24fb4d77f5e0354401803fe0f3583952df6b0f0d100e9c38d1e43971d09fb6089ba4a692dd6351b3be4da9f444a05aec9fd3cccf7fa07ac46f1cd4f1383dcc06ddc01c1db0a6a6ac5ba5a0ad4dcaf8c5a38607d8c24bd094ec0d82d2caa4f9ace25dce32e088d056f882057e504564d63f1a1360bc40df152d853c6dd7e128e02d7af8d4cbfbb7ca5c1b4ed459c2fa862d852deadcfa2cc1d4745caeeb453ce1bb669739ac2b43b61542a037ccfe8aec1b4d74fc900eada57c327d449258e7b084caa8532d478c8fa9dabfc43bcbb5e2780eae0f0a937fdda461eb6ad087c4cca80d3c307ac329a09e49ad169530db63101d6ffb7fbcea21dbbae894fbd0e31fbb1eeccab14051ef784a933fd99743e3a1de2fbebfc885d21db8f1b4ed5cef8700c3ea0484aee6c46367524b3dfacae98725c93c826cb33403829ff9c88c736c36a623196b7ab1a5260ad83960a1d6ea3c85cdd12c6d9ca9dc3a897e8d2059e1c7e41f3d1d598d1a9619bdca0a3c1eabc662f900521df2b7705ae5a35e98d5ff54b3b433760d124fe69b1be71e1a655a1fe28cb244b54bc3fcb0f3b1ff4dd1045f24114aa34a51f286d60545fbd227d7619a6fe09fd5943175d9ff85f49b9bfb15ad6e7fd555c972a052a21265e9d23e184181ff08cd22808a40751a48f26f280a92d6e4af575c5e82eab64eb643839b056e31528f915fd2bf0a22de6d300dc876ee03ba46cb3647cbdf99f6007db02873de42da31d875fbd8fe15b2b7053cd3df826272e894bea7490c51ddda90bd89915b3634a6bb455e3327c4ac2d4bce60efe1a378a66329ffbeab764505547e7b30365f0572ac1baeaa8dbcf0d8d5cee69e9c2c20e7b157b0a6cb24ecca916601e70bdb8c732ebcf1187232d94a47a9ff28d0719ce53c717fde4f0147614efeb9d7862bfb3641d22497c17111d80a6c852791ac8089427e9f675998b3f81f7744a7405c86ad0a555d90eb1be76cafffe70c8acb036f65d7eec76bcb3a280b4979174960a1ae53ecb963de21691a686bf3d9a48685cdcdfeb7e9ce63d9d055c07bd35164137b968d411419ecb4ccd50318cf43b5725da3047a08c1d72d92a451e2a2bee7fa6120e728cbb6f9226d54dd23d500dc40390b01d9612ad3d3da87a1e6f02cda58f5a2823d36fc27e7f2f0423aa8e0de518232b5801233c98d21898f15d094ea2ff0d15f1f2aca78dded274d0b9a117d22af7526ac506df1bfafa100edb1a6b1c103df5cf0e2004d739da79efd8f7ff5bc47b71ee2e677c687e43ee42ccbd7d2062f94b19bccdb64436b023073749218cb2611821a8880c89010432ae82b7b77bd737ca6e0a7b47db4f527720d91055df3b87d5dcc1e5d43e797483fc84c3a4bfaa6950d2c32e2bd8c869b3142537af98162bba17088c0425f7ddde880d58fa6e5f707122ddc9593f6ca283d43b5b1b49c329ea48a0495ee1794bab517cd83dac6a9cc971db2509720ab06cc9f07bbb74734075fc4e812b8d1243ae8e341e23dbec8f891938766923976da9fcadc88441afc06520e4e156b038ccf1439bdaa2efeff5760d5e89f9123a598dcf0e57c8712dfa1eb29428c43abb62683d343562e714521b8158dcf814292b246b5940e7975e83fa2e9e3ddde22d1456e37ab636da85767af167951ff94b960400df4368d346dab63f03b60fc17c4443472a69a875441fae2a23b7b67c2aaa09bb4732d9151b26092ab150338a6e0e3902a8933011a07858d38759408b2a9589cc533ab522059f59266a249139ffcadc641bfbb95dc4498caee6c9af1c448fe7b011bea17ff2686d5797946a903cb9079df3763a8366d1d76cd36ccbb6a79fa3bb384c353c57aa2d5d0a7ed2119110f016aa33e4d813d15db5cc3f3728305d719ef8a35d4c7e1002e4f6272886288c2f1765c820256264ca79d30147274b2b3487236ff40ed52501d1b567e026d104eb54cf8cb3cb4f4d883282b37b4a39b3423ceb22aa333444bd71569117daa96c54cc4dd71fee9fca2d0641f5a781fa5e60e5f535df53535b0f35d6db9d8be295959e6ce06bdf677cf79149961d086fc0b361dc84188a3aaa157c6c41652a47e99b70b4cf71a1980e7cf6aeaff7085c7af7908976cc79b005d943554a8f948663ec6c3565bfcbbde644d8d84211cea0467223d069b4a86e1447ab467e687460b482334c093bd90a0cd2f5e67847bb227a7dc2f9b064a76f71b2e3f3acc09d3c77ebae1dd0645a03946b76b7fe081e4341b2b359d1459776269773c3ff231ba362f23bbcfe03ba93e8e37f80e09c741b85061744cdb72cc855d536d709ce2792caf8e3124c0b03963ee935a4eedccebe6498c02b81f05373eed2499c85842b37a672a5b4beb2eea4a6eecfc99fb137a23ad58b1a4cfbfec0920064015655f1d732fac10a39132af49b379c1ddab2b613caec09173389ccc4f12c3c77c93402b779ae03d67ab4f62ed763e9a4900b24c58aecb3d88811386f112629159774dbbc01788f5d54cf5f0730b541c32613c2a1715de1202d83a21f1f25a398540d277685e00a4935a494e34919f9f7fdcc6e059201d7a0c3c3865cd5d7e6f5cd3298ccdcc5179ab7ffa7497b52a30530999c445fa6b68014d9d5ae23fd70ff734414b151a561d31d5e2d9a4498c5bc2a352046e0a65c428e4f2cd31d5b5e1b86f01333a6380ba92bac7cc0cc4e2669a03f2e139b298ac2d6f1bb51e5bc5073e1a7c904c60308d3a79170d56ece82ef07ba3329672823a28911b6232b71cbaf703f19f1615d2c6354a1d11e71c24adc54885cb05868be698d7f3125174f770d783a532f711ad9c1de1ee0eca34b68a73345c3342b0184ac761f6bea65b85a924a13a579cd57228a1f2a6b4d4a24b11f6f76ad2939e3dbe0bb0e351bbd579eba270c9c0aab0edc12148c97abc4aa1f9e54347a492608d91368c7fa2ac13e1acb28b5d33c63d6171b8489fe6b5868a38caddde7dd19610b8fc09ce2f103631214e0552d2623ac9303998282218bb875a12f5f754b5e86ad7c2f0ed9c75323c9c56c092a76de532d4c583ad389992428fe5130965f0772c3056b33a30b7788656a3354ca3ba70c9eed1f51b6502bc815ca417fd7ac734d6ac627a4630d008b722c6d1f8e771491a6cd06dedc1493d9e001c09dce131a810a073dc4a745838a6ed05a5a675ade46b292f6fd17089520056183dfcc906432af651a8921e7ead1237c5e6fde882d68b393d5e8bbb72aa8ed40f16a116742a2d41116316b5ad98746f9c16f715b417aed69e9c3b9afa1db4db330a0be5258419fd9cdb8529694fd61acfa34a9b5de0877f3637b2ff62ba22e54052bee5fa6aa689d8bffd48d76b781e384bde77d13163975c9ce7aad77900ffc72c075cd017032f4d78722a00687848b1ba8cf3f5e000532733c0380ed0e2d21321181611aa0d7736f8c12116ea1c272873ceaf1ea8531c3ea2e9313c53bf67d629be9011f3cd66","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
