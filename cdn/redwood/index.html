<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"78804deb28b0e2f3146d649f4409dc7a8f2ab5fddea9707c796ba6574ce57473af690bb264e6c5a65193c96e5f9de59cd0408126a8659f354ae85eff3e06e599e3c5574ff16f33dbf0d8c597a5bc080328567a3317c10dd46e7b15b1b5b25798dce54bf988e1d2ecf84d3e5acda276a75fa0e66a7715cefe295a1a406a76a58fa7dc42ecc76473f72b91abfdc8bb7d67b2e61be78174334b761d693266210ffb118bf7f03ab19dcb253ab244d5875f67f8569a1772996f817c8baf6a6a585cac99582b525ce1978a8103e77ab90c2bc787badca8d64296ab4008a33fd97a3120906b02f6da7c995488a3f76279d6ecd2927f8c7157b05c6f023acbb28d547a3b8f12e8c6bdb2f076219d6bbfaecc3a76aa85983386b9eaa2bb711e6198e724f753892842f087e7ecea08ceabca66b6fbef8b29780ce3de42bab7063048c1281c9fb8a112f00c0b820f36b88c1ed794c12b3510175b18da65bbf09d7fa5ae2034c7c59343e572cad7daac6d6e9076019d2d45901b4c4eb58a84a8c761e5ae6d428e93abd440106949c4dacdef6bc46e583030614206225ef8fc9a75ed0cbe0f7ae7aac9375d574b0b12df252f0937bbd6a1a465716e26e457afa4f976e6f54ec24f8f74d3eed54aaaae69e8d3ea8c0301551ac66c9329d197f1d580986d76a2b47d5f74b534a4e7a2a74d3ae3f5da2e40c27026849b82917998c07f01c3735db2c72f3fb872f6f9b7d731d380c58ae5b889b7dcd7e52fb7036b6bec5d8ec3ebe4685c06233c194705c383de3cef1ed43002e6618e742383f75ab87e4bb1a6df9ad33ae6a5aaa07dc43d308a00b5ef1d4163ebfab70127fb073c3ca011f76f6c3adb39e51150c3ed5f60c2b0aa85c3939d70e9f5a8ae8edfb8096c94305485a7c8ec309d8157cfd230529aa2d52c9b103c40b45ab5414ddfc4ed83755848daf54e11dda937fec7e500932de356c8ea5e72a969b8d70145b9e13e1924a440b0f889f3cf175822b9fb0cea1d64323d60196d9338b4eb1e4ec32dc34b7684e6f6ddf6f416b6bab0a75565e4d6a3917b839a3694b63001e8b682ca3348c65b4c70066a25fe8698f41b7b6a60c98bd2a1a93796bc95bebc5851ea01a2740c5574882624a354817ddd4dba9b9d24f18002fcf8bdfff37c1352c8a89d8188198300d1afa8342a7fb85d45e099cc9b803912b74c865fcf2ae66bdb0c7bd5728ef6f15c8e776312fd2092a9172781e786bfe1ea916fe4fa3aee04e58c3d4bee2ffdec2180997dc35720fb680bc1a3c2d6f8f57176d6b1e8585eb193158d47e6bdf72ddc6d1c78b4f49795d4c4df3c1804f08c065bbd4f1072d62aac52dcb7f6fec78ff57a92227c1bb2012029acd9822245814fbdcb2855499b73bb44df57c4f17b39caf553be91e6741dce51b4d9054467a350726fb9376dba2b711546bbd00688355f7c9d1fe147b9c0bcdabe30e52ee15c1b2022111f98e6859bec81a29c3c46096ebe39e341b2315050dd8cbf2addc2935bda843fb5b00e48a1b4807f95d72608de56a1a7fed44cc35954bccbb601949ac06239b164180765b42d017a01819de93f0463f89b310ac69c9fd0375c43de547b52c6e6a9ee5dc0cf389f40c30fd9a94888a8bf7d43404e02a59e7b69b1fd68d246d5a331fcfc55a4006bf20f1cf53cce40e073ec2be08b8793ea82bcd906cc8990f1805897247eeb1a2583738b37d7cced23ce979d1d17e9429ce12ef9508aeb95b8be83880f0141ac89bf18024d806214f0208bbd8bf51ab2cb175d3cd1c533fa54cb8390a694b34281725b24051ac31fee73ec68d0c47602e910f49c4182de379956742a42bf5825ff142440e54adb4a4219de0765651224b3fb7e1fbc3404f33e57492883e6ed356250bbaeaf397e4012dc6cfec760b33dfacea688a64d36284754dc717caed43e38abdfea41ca9eaa46e6742d55f35472195a3f0bfae146586fc786451e8b588f849bcfd99c29d3bb02bc98d8794879bb74f584a57b7e4405fc9fd730ccfe236cb3e8238e2a05b185e847a43e791e1d7ff32448794af9ccf4d288647e28eb6f2a40a4d71476053a0c1ae325a8bb18d200bfd56ea5b318b4b37e974327d6cd10c6c206c0f24bd67642760e5d83b4c15383fbdd782711cb73e2f903228c84c8c84af803083822a2b4043c0253b5f86b0ff403d90048f37d9649c63af150b2398c1e7b447b87468aebd8c778d578ddc8078d50c4df01e10202df392182ee2e7664d39014084bf630d5921bc8960f0ed29f9a26cdeeb6f2b9218d4810492398ad7c5bcea675859772e9034220f7ee8178ee197f84f1221c098f834cb6217341f784fc19c30206b7704c34ea6caec6bda6852992c35e7ba59d6bdf43d60793fdaa3ba50cf23e18908021568d3c67d56e2f82b81ddd0a3d39b58c22fd33d1f3ea5cb9208b51337d692acf8b0a453aa82978eb4b65588c69f04a66271bdfaffe8d88a75ebed3b0ff0b8ae78a515acb37810d6a3651d655f323a346acf1cd355b85bd6651c24f12d51663c7e05e0829e230881d4c5f33d16aae5b13427e74f653e8b3f6c85408907d484b060456c581868deaa99c64993531127da6aca47805107e5407492ab9b3b1d4fb8a96b216b335748d6a4e54f53cbb053c341c6bda7577e8309ff1d98ce048e6dbe22c09a30bfdc393587349cef5a2691c6e16ac6565114f47c0a50fc03189860636f085bc9fdb694ccd30f5e9192bc0cf564f6a23884d34d78b6bc76c18fef4ea1c332e5c51b62efffb48a1c6f80789b116647978dfafe0ef024192638f2e076eeafac82f3d297587e67b198f1ce7000e8a017a72a3ac65e9feaac88e9c507630a32703dbba36f51642778781ebf4c525cf01605ca64523dcd39eb3e155b74dfa20b30ca7b2eaff0bef8bc608ce23181914691e135ccac687a45c89a0e5c369be2997badd79a269bcd2ccd946c0454fe5be68763c1de872ca10e216ca7935f144f7d427ca500de4a5c19961c0abc06a42005bba6ab7498c7bb004379ac955d629694798759abb659747fea1ceb4deccd866d5b38b014d054e8257078230aff016ef177e5c1637f0bf4e8592b53461115cc42dd80f76666a0ce6fd05abd95219bdb2dd968b0ffa20df123500f70fc50a736f8682bc12dd8a390499c60279909e475ed78c8c6d83e50d9f5fb32fdb8c287edd7c3d741d3e670796a9696bf75af849d30df32881d29d5b063c0f7a85955da38b8d2a6d08c09afff37b04c97c7e7eb9e0eaa94a73a58ea4d8ff9059bc6d93349d84a8be7c2dff2a5fc32870195ed711a7df38b6004435e7015474fcbfa03e3596dd97acf4abb60f86f52f11c1c9b4f19fe82431783ff1e42723761edbd5906b96f7e15e89edfa42b3ac02a59d2cd45e42c9827d917a6b708a225cb29c19fba4589175a43a20e78de2035197081f9409cba676a4df10a6d8e6a2190b1c0225ad7fb0c055fde39fdbaa7a3233613cd1359e9e3211e0e7d13a09e6f1d3c0454b55277268e3cff9b7c656a69000cf529732828f550d9b3b5928fd43e9380d24251fe0f7077a2a25fd725ca8ffd6ca11b872c1ab93fbc86e5e8bfc3a6922ccb34c98071c2d58abb171c66a3d96ee807fc847965265f7ff25a91392aedd24eb3446bcfe8bd8d8a2635297c6903a25eb5effc86c3d7a56bea99fedc828dbfb7b969966fae1c31780ba8f706e3851383e9508cc911a6b377c0ef9d0bde43d59d25da57041cfc7d5dd50f9ca4f3cab8ea783785c0f30cfb163c5378d36c03ebd9d5f1a25fa3ba816d77ffa26f83ba8d2408160d1b12447736de89c017ba38d62576d223cef97b84c96884045d68f930878f6e6c70385a9463af5f0e11354fde938b43703b64945f2cd70234ffda308149101b702900232e8d504969883d3598faa76e94aa8daed8e648d9b7ccb3639affb92d1d7f27c75efae6d755b0044c5e898794d59174593e9d5e9ff8378838a14dda62bdbe882698a0c162163b6d92afb6f5dd03e3b471b4a0a25659b60af7b06a85a6f7fe93b9d58213083c46e65af2dcdbc51e46286ee3d8563f58aa94b780ee1287e00ceb8596666cf4c8d4e50d3e77e78d517b5d28df05b6262b23c373e8e4c6d926df9ff8ee86179c1ea307817077125555a6a58c28b8f64ff57b701e480c2a462a749ca59f2b66f9ce463ca2d86007d131d7ee65f82e4cf34c8384e83db09d1bfbd0da102cefa1ea2eb0b15beb4c20ea65c21f30ddbdd39040df4584800a8e2c1373d9d00f2a32cc5f8952d9eb5890d040944ce7d1640687384dbb36a65946afeaeb302dd0d2a2aca02ea95d3124c790e3f6636b045260364e16e209476e5f80504e94a951a157e483ea6c20bdda1c052dc8b2d041f790e2f69bcaa5a191d9fe4a11653e873f545c962fed866a882a72e94de8bcd00242eefb8bc493b0d2353d616123a01d737bedd4529b6d12c53915247b6366c4bd29aafb6507b08a331cd9c104669c43407987a7746679d2f2673052830bef257df0357f057579e102e3ad819b67c959b27896bc6b58b56d629e62c7e97a459d01775cbb727aea83c34fca2329d48ab435c9590d2c82e8c4a43f70311756fcd55f7ee2ec18012bb7736cb1d6f66126c60a7e4f0dc05fe7ac455b2fb821bbcb161b94402e58ed2acf430cf616a655b433ad225454bbc1020ecb1950ada213900c4686d9c4aa6465697b4b937cd96b7d327e32fba90974e965583d58d82ec412b382e44477785d003718d1d0aae359ad77989826d204af32cea58be1020a71aeb309c386cc97206e8978e43e4a8914df5fa78e631e1577f26dabd7e549ed6732f798c94dfc9c7b4f1554b2cdf700568907d5e786b04b0e1f2dd57e3a9f1c4dc7a47b76d4aebbfcf91829723c0b7cc5e2d36d2960d1cfba035cbc2ca3ed6812f76b9f2ecaf6c0c888d22b79954907d1eb4cb412add17d8f25c0ad78734153dd2051f9b74f1260d5448084605a8cdd0c3295dcb700b3265d159d9feac63400cc10970d482e0623efdd72223d75ae9e41235be705a057eaf069a415ea2f7d94c9f1436d72a76186e16a4f4be8e48e4ec6d6f76ae978983b6e7c38755c0808e060d70ce046422f58d20ee1dded672b3699b027cc3c02e957ca1192e25c91832203cfa209554c142ab116629b6f3c5ebd0ac98b722610c3d72b5e130b4eda16adc55246d51948f50af6af7d0974c9a2e7b740ac4191c02a27d3c0121b5a91f007b5892048ca15f3619552670ca505ae2349c80adcecda62b0bdc63296a3df16bcc130c21b69dad27d6acf33affd4cbb8663cd00a72c1c1e048cc9925ea74066ebafba09c5c686cb04370273a16ac8427ecb859e3a3647f5aa150e2f8df136c71dfbe01c84e9aa5ab07f8c6dc68bf0305d55f69869ecf3b2a0d8b88e1a0ff69978ca0cf278b424e03d8caae8d8047d3dec68116828dbd4f0a75966b9da703cd4ec0a4091cdbe744da3f3feaad9ee77ca78933d7e8e7f6aa44eac7f8ad7499ebe18f26543a5935801d6c05f9c44eff86e6ce04312fbcd31db666e5210eb207cad509c15d96f3e1a98f6392a7a1891e1370360d19b03c61198b98b2336efda110621c344edb0e4811e6f3c6fa806e23b856291bac6ba95f57d46e6a36b1e401f6799a825ba69bc32acd9452892baa64da01b5c0947527ada238a2ba54ca1a1b0fa05739559d2be756bbfb0172ba9e02fda87b0a03f8cf238e2b725522f52a0825bb92b2153452bf7466665a965bfca68f31b4cf9daa63298eac037e12b146f9ddb10586e1d2c572576ce1b2113cf90a3cac452a5e92ac62b43b9fe2f4693621d4f55897aaf1c918cc9171551452a14ff99093a906108dc8b2ace39012619bf659ed5938639171a631caa8bd9c24ea1b9cf97917f3a5bff078ac6211fd09b448c58c3f2567f9760ade8e598ba2f21f60100f1c0455aead158dea30cab7bb39cce92a71cfa37a90fa7c9c28275b7caca795706c7a195f46abdb9dcb93ea9bb43bcc57fd96339e13def686c07acf79376007a8c23c26c09466618539220f16784433e9f6f91778780721050e714afe8de1c805210e222f9b01fd810b783e4f3f5449a42dd1bba066917478a1173af39402d99e108e80a3ebbbc1c2eb0436f0c434fb9491e2f899db28c3532d3639fdb446e1ffc3bbb5e06b3282ab0bb3c61fa041c41dd8573fec997d26b1f7b23aa911e8f2ba816c66cdb01a334b802f3c94fa2a910a39a8caf97bc37f5f072b75e30ecb9e093816927e2e5bcf431a89e530856ef85df9080fbcbc94b1aefec0c4f12efe6272c63aeb8709561a7947646f3469a0e17cd3a2b6cb6507032742cb40add9d7df9d9f50238ebb222b627c68fb455ef1787c78e9e63a656df69a69e8166a02be1d483c884897077a78f6caf8618fa181f215c5ab92ef219d22746f9fdd9404f2dae5ce5ea818cebeee4c5abcbd3c918c90c10ba9d61c19970057b4d56409753e5ab6032f68ba5e60f4507919eb366064ab5b5d53487c295dc2eec5649709194a4fca8e4d75c5d1ef93d92a4243a3c038e6de6aaee017af2c4742cec8ef217c7733810bb6f2b1b805cf2ed36d8ebf77af12e6933ca665934d4bd01025000a6bfb7370fee066b8efac7d0b57d7189b1ffb900e7c2d18cbc9d8cf8994a22289c28539b767be16b40ce5b8af8a69838ae2ee20162dc23a7a54abf245723703718fe24287fc0879a68bd2fa3771c4b0f574b7b37a2bfe44ba6aa30865e19b9b2923a976f17925ae7aac276cbb1dc28b42dd54b931e8e1bf2cd67caed30358020083b81d842377d9268f433f6aae54f0c8c9946eee51ed09f7b11ead92c577373ae1ff087f9233a7ff6da43d095ec47c1f704af5122a7f4fdbdaa0afc02f73d20b11c1391deb0fb777f8d809c98576525a277ee5867a61bbe76726b7fdc2b7c418930973dc429dbd3a95035cc290a50ccb1e852c59e3a7d7fee49186386a92f6d1bb0a559c101d00fd40ab4feaa2791ecdab856f7959bef6827abcca0a734192464d60496679d2c163915b57d02bd774146c4ad436c0e554ea216a5960b9497d8da3b6e0e04af92343995795eccd8544acf2c84cd05772cc7e2cc4aa8b32512f93f096db34137dcffb9e4f9fb0b11ff53fe4c036f7ef1bcac054fc8625fae280d3b7633afeb2af4cc591c90a44ac311fbfbd22d72ffffadcb745d4d6843df201507540948fe14220f9b6c38df3a0fc2dce6526a5d8366bb2537128628101cc114a91754fb217598c59df9555d87b58d474f2b911d8fcdc1cd0cce8d52e8f6b71c1943c75c34af562f03ea6d5a589b220a0f95edcfb83be052510808c84fda7462a9b0c84939aba5632cd436ecbc74374c82f1e297e96f3a836cc67de096761070904cbd80125081ac70805d8c234a3ee827ce879cbfc42c85ac671f57cfe289e5a1deff6e2e81ffa7f146e7ffaba57a55681deb860027bc9f40e0ccfaa0567fe3e50fd641599f0b757a93094eecac28638c58a279ed3c23ed65e985106696ed1da5ed74c513b4e5b0222670206f9b128805f065e2bdf1a3429a39c19d1bf06826c5ac2c3c039e25d86b26489cb4af383ccff2760765b617cb74d02da4e923907d71f8f998595d5b23bf19f9b4ae723d619a649866cda3dd9078cdab9f0a12f7cb03c141e6e64df104117cc1d7b3f8ef46ccd13784e4d19519ff0f9169fd817861b67f0cf446507a4052f2456b5654f6f7f6e7af9a4e1941e6b98358fe1efb6e116a92a002f19b0d1c16878498c378fd1753d5efa1d54eaa329556083e7fe281562679c3f9af01f832ee46b8fa0d01f06ce20c01365d63cd3015ae5f8ff1dd830aee170e1e48657bcee1b0aaf288abac63547c070c7df579d0822f74bf0bdf19675d1e8ef9490fb8bad9f2c6f44d349ec8361ab1a28511e726cff94877ef19ff97f3aa662f39f6578093eff5cb9941b5f301e3cd238a20782ddb8bdf0bb74a1a3d0e84a4fd1cdaa5a1ce707c4611d5af223c0ca5627fb3a8b8c26c9308445ec5450e338f1a240e79d2a2117316893f3548bfc44981e9a3cbcd0f87cec102145acfe1d69e309e31d342727c454df29cacec340507074f054e7ccb97cc5294752498f046661e116a34e5c0272b37809694b266b66fb41b547d50346c0a00c539d0cbcbb20d51ef06d41a8bbad40e34ca6678292fee1709443124dc56f9fcdbdc2af4da1409b640aef148c0501eaf99b6c494b5e658bcb7b48aaf9ef4f931d3741f3ee1cd917228346f659dea81f25e7649b9b266c5190bc1309f86b8c43cdcc12d51c436d04c1bd00d5bc408fa59a919d472cfb3c07e5212b426bbe1479f1b195c63d95bc4f7e4138c1a0c211c89e8d0bf35c41c98d566e2423d0a272570977735ab4402297f49f9bc07dfcf97af68f6a98e2ada9c25cd9ece7aeeb93fe68632620f3d479e713440950ec01bbf34f72052e02b0e21bd471a12691f615405e5bd565f08b0d0752775f4086a7fd6d2f7983dabb66629e689eeff5493792fe8be9504e77498ab7d0b60906e66e41a3bdaaab503938b6856a4aee40b5995fa316389e72b81804e3cb7fab5ef843ceb7e046813aa163bd32f2e47f1f5dc72877eb94a4731f8a7cc4e5c21f215de4a3c61ab7eaf0b1ff98225fbc1c0179333a9593fbf900d8a1d840f27485b042f721a151cf06698c892087cd2c257ff18850c873fd2a9a64a14ccb10d02ca3c5c930b4299bc5d8989d6d09c3ea737a811f3dd3a3d1ea56d9da8b7a815347a57a93f899a8f6bc03691b90a1234b50347d60136b2ba860ec8377135170b71c1d83f0980645b62805854d5efb1b112b3b3aaa0836a0e24834d7620d22d412a6eee760d074629ac3f706b938a5bbf37a90763c522c79e0cdd97a71213d43342253d103ddb7d21d4b1b6bfae932a102951b4f2350add12b66e0e57592eddabc8918d6ed6daaabdd530be90905d4fee14c9bad353e11c4f4faa56b58e43a23a889fd67b6dbe731a8fdfdcdd604ef88f1874922aa0b5f0ec2cb1443f0e2639b86e2dbe34e833abf28091107afe656ed2e851f784693199ab21960af27ebe3616533b6fa12173b1c323d7d34471f12e29585dc51c6324b6a6f4d2aab1bce91d600203dae3815b452a72380bf926ac746c15708bf1ba2545bf79e10c2264b8fa32ccdce29509ed66534bbd705e78f0bc5c3b7a23a31b120fe27234d2b0990050393069e966c693e539676240abbe1a2b90a657e5da31195c2bf69f983b149bf6d15086afac9664fdad496d9d6b8d0882299ec546fe578d7b4d0ad13a7a0962928389c6cff4b0c83fa64ad28bdeee3bb71ef0ec43451d039dea20b87602afe25ce556473336aabda479ed385b8ac4091a3e883b03b55f15f70658e0cb0a4419e5ec97d2d5c0d6f944b860eb6864a0ca8d77ec1b228bcdc535a324882c30ec96772bd5a1d3ac00e80a9716ed87903fc75479efede7e2781a1a62c73b2444dbe5a777759de0cafb0d5a17cfd587e9d7232b6f54eda7af2c4bfffb6e5ac82132f9bd4c0dea478f716f382ea9f3abba4d87c0907a207ad3e69c45c9d8fbb25d31e32591abd2f25207b8511578fdf238e711c4933d92e709a1712de606dc772922945999c56f2c35487af13c4e881b12a5185d0aaa85f87ee9ea750302e35b0f576feeba7e64d724a46182351fb84e5e9c5510e419e2622617466cdc09c37589c95bb49bedf12c727c3b0b47fa05aaea9c9f14fd88b3bd0bcd37e030e43b0d12fac1b1530f36d8940299c9f2554f6b0e433b171d531f622709ff17fd17e8f0f420184f96ebb18a8961f058f47b4e163709baf882331205cb1f734f82dbc4770c13d23808c4162e8d044eb3a17cc1f19e0c4565a992040d0cb1079b1423a9e88631702e6390ee162c1e3db046b693d0f4aa70e211173d61f7a62d098223af55ce073fa9e5f128875844014279c1aa854beb4dc59f2c29fa58217e2c3d748a0e3a986e581820c07f2798bf783b3d0cc62d0d5e907c738174f0b9906a286ae6167a33909671f9275e0166e40dcc5ae987a9464d7f44034152a408eebaf89151bb584fdb76034b5cc0ba359ca278fd3e8bbf3fa86b8d32b0921e93c254a2921d4c82473284996b34e6255446e35f8d82d90bd6da112c77e01f088326879388c64a292bbc02380de157a608afb964fb4adf997270171e0af14a80988c43054cae2531c54498ebe043d8d5e16ed81ee43ed1e8efef5eb76bd93186822d7c61e11809e3c71310da6a2f8b7665cdfb243a374308d09fd503fac74cbad7fcaa6bac3bc494b1ac805c99f35e8f736828feace047de331a3ba66de2316372918b454c1dc4af2d1487cec0ce7ab1c6790f7d574f7f579023a4c2a8bf2fa817b5b6f716666733e86dc323625fcfcb7deab13e26c3659f34bc2036343ba7e58360b208a45c2a527614518196c453754850983f4c6e5f873cfcd908a73fe2cee142210c08f14bdcb864deb892250993b1254305e50bf0e70a8afcadb2a8affb7fc8c3fad9bccca974db89d8869b34dcb044eafc5f8962282a8d7c769525664c3b28451e8a0777fa21593f03a518fb379ea229493c4621587af117c0c9073b3998d3dee1134d5d21c47622b20774607e845b380c98174097ddc785f21001fe25e0062001d2715914edfdfb14e2a949065346e87e9ba40d63fccda18669a5570f8af7f1dc0e40cb88acde1506889e8cd1d67f728041fd6ea716dfe410a03a571de22ac721c378f3d46b9c1813dfff0f0e5da749e219e1c169e94e6b18a7dbba80f6dc20d38f418ad6993fda483bb61f5fc5bfaa2fa34a94c0822e4eb0faaa03add6f45e3f63931d43558a2c68bd364e221573e6f6583787136a960edff4df9c60bb159089b36b2fa43772fc2fb5053fcab7eec8176c12cf1c6805db4a9f26b2909499e2fce0078e3431869807f3ced53342411ff6c29261edf85daf1699a2cb5684db40f2c4384ad6c71fbd1b9de75aa550c0e879e8e0a9ab1575b8c6045d28f19e467eaec17df10466d7220d8f2c83de0ffa701a606dbe5eddb5a027826f9398afc280388615b1c93f905047cfef2358dbe80a0f5f5ab9cc860d37d68bc50ab232147dae7dde2cf90f2d5564bec9575a1963c34b6c8c77080873a656de415783eb50dfd34694e68b2f8f0f2f2fd9b8d3d9a7c2d7aa75a62822b86e52a9b9bc07eafb61c6c12e0dad94249a789e54a441492bb0ccf9a0d9aabd716a0eb0b7a131026538ca7a6874f0182b91fb0db81e065320441ab6d1493e90d19050a9d0cd56ac03bf0cfdb6b92176e146601c1e1f00e5e559844419b79f09b7740114c6c78885dfc3ef59b3a0fc8152630cb76388f9199d9fda1fa2f367d9a71d18df0409db5681d3c8d812ef665e1b9ee7b0c767a86e508b8bf9c30b7fac632425171515e8d0c333ad53ba90f04778241e9996cff0e31458c1698ca0998b03d18f638bca8cc6e7dcbc2e49a50230735def236171609176ed29e58d97cb0dc728e286b9522e3ad3e4cec25187905c1810223bd2921043b664bbe6feb7c242654764f6f235e55b10096b962529c6a831584d79d178fb8185b53ce4941a3c4cb3e02d752f7798f9919b3272f2d051ea4284f561c37631a0c70634b8cd1772e5b0ecc602c23e618a0645d899e0abfbc4d9ab0c107fd005cd3bb3f901b4f8c645768f80421b50a1c2ea0bf984116440a2ba0a04440b6ab8f09a3fe44e2c9a26b093327de035ad74294fe964a52199479b7f29c3e535663668bf905d4a415a1746a6c3ef5d5c1319fff3d50fe837af265508dcc63c12ed4b4d05ccde637ae27425b76d09bd109d5943c6fa3ce5085627130987bbe17267f1e9613bda93e4fed66547906b1c4ec2b28ab95d20be9637ae60fbd92f0213df9386d3c06fe9954f52e71952b34e13e241783f345238e99bf5fbd2789a2975b8da353404f3792028986270224b0b252151eb9de0e8cdd9dc753e78421603a995d5254ff2f5313660af6771bbe84f71f05d876fa5ef4162f4e0d62f39e85a6c70525f46cda2e0c329d2776c513eabe4bbd083354d53d2dd067624cbdda761bd53d5cae30c54c6342178f0a781fa4450d20d75a0c8b59e68e795435115927050c3b632c0989d847500de1b007a0ee938de694f130aa98173ae71ed906858cba32739ef49cd7ff1f800c257887319d1148ccff135d6f19550bfffa7d80d038d7a8303a80490d74b4da45e1fd9ff12eeff96c054bcfde387f54cf404c2535b5614308f0d94cceb01fefb0bf49046074fcb02c4815b74fbfef1cc937966633d9e1de90f8801c8188851a7541f8c4746dc4e35da53fb4aed738b07f5e8206050702efa0c5a0c130e0b8a4d4f7b72d98880c894897f07369af6cf8b3b1ee22ecfde3dd0abd1211d5672e064c43ad571b478bffeecd54e72defce8796412502c75ce42feb05746b607e455a9b0c0d871a7ebc64caf2ec489bd2d3a7c6ec2658cc7358da92d392772874314b2b6060c9db53f73715137788f654669e7ab2a65f38ec580d8b0a30e90fcaaadef442f8378573dabc342ebcc29f2e1140faed5fad225add0bb93198c8232c55d62bd25392f0d884bf4c71af835ff9dd4a2a47da680f04eeaacee7f2f6da091a5423d05e3d86a84b5a4830f287c71dc0e35e6365e3b029dbf1c913ccd595c631b70bf2f4218c8239271f99d8e94f7c21123fcd1584c45c98c88c5bf28c851ef91633f49f67e7067e23ef55e10cbd2719680ea728b7918b3c521a49b4d5b14378a6cdc12a867a32242c0fb063ab810fd37feb9193008fde6ee381e94be6c42c76622f6f3d55eecd66f330e5b5f0d2120eddd61a1b55439977d8414feefb3696aa6b4a7c6f1886c351766d9342b185d5872c898133b9c3a68167c94ff0ac4fc6fe3a29bbd59ae3fb55ee915e5564b1963cdbf763cca7c756e1ceda75e4213ee191b3899c611da569be8b7fdb5c138c25a68cd5af807e89ff73dcfedcaab13bc4cce0594d37e5f7d1512887962e08bfdb866416a9975a892089882697282da03483d8aa1b142d4fe8e8629d6b17927f15d6c4fa6a67e523ddb02be632dfa1f31a8ced1f86bac96988e65856aa673333d0939019cf1ba204bf6e197e9a67c525114ea8f802092adaf11351c1b5fa4b1efec772e4bc4a8ceca49d909250a899df3264c013f31e0c7baae9cdcd6491011f4dbfb041f537928f23045ec1fb0029df41a8c1632419763038a33bb953d1c6f3f051911f36dd444966755a9930228e0cc9602fa1546feedd0214ee7b5dcc7ec2201c424fb6bdc08446a56342558e6ffe2f056166223d59fc04e1c3f07fe67bcb4b613ec817f7fd954397819f3c7621533c671e83bff17a96a39c5d88b3027bc0c95c97fd1711d8ae0337b08a23f7c876aa56b76400814cd1f7a2d0947ba7d83c3b4e3acb876264b08a67e54ea2d1c27f30d8a1443624de3e0f7b4aa6c78e70b4274eb9275e66966be1d114c5ba14a71296d89d371d63bffa7fb09a2ebe3833582f75c3b61fcf547be4f11c8ca9fd6a802979a0bdecdc961aff86b93cd3813aebe6fa0857e8b3db00de49badc407c3c78e1185abb8e8f2fb0e011e981dbbd2ed6601eec38fb8fe0bb055973cafaf8b0fac96d7e1e0abcf940353769c87c5cc96246eb6ffa378f15bfca93ee38cbacd726d20b5e310e373c14ae4ec05e20d00b1a11f193b6ca97df313ba49dbc329c1d08d96b7f0bd934b97fbaf8f563581d25fbc6b5c8c235fd0e6d1e8f8e6809eb550301d4b572598927e2333cd16e9731f5a59a01391fdc530aa5c63a3cfbe104641127ee374f51dd78adccab985949cc4783cb85fcb2523b33d39adea83b79ee6bf2a4567c6262d7c1162ff75199c01f8782736d072756d898607a1346c2f841ec9046f8e2384655c2f912600e6945a2e68ad28973203cbfac8fdb3c0da17b627638f7ad159defde1dd297f9792c776ebc42d73d3a761beded7eb10605d684bd923ccb132ae71aad96082c20797bc61de503ff303d2998b81fa1963015d5a0bfb8ddfb0b57bf7f55dbb0b8677560d90774784ebd215a820f0f9c7eea3b0d094ea727f0ecb7922fd6cda2c5c74abc04c399049676bb7dc0a1790b4f39aec558f80856b962f643e985c213ae121d628521043020e106bfb05944eebe18152cf4932088bab6bfd7234e185740a76a06e8826e1bab1697f3010fa6823c3b430c20e5556829792386379a7927e0724b3e8a48171932b5bd4324d3890d0482a5db9868e2c03f517cb419ad9347c8da46a23c229a95ef53c9a9f5c04b321054a0e30001a0c81194c45447baf4118b20e0a2dfa7257669cddbd705f6e40e1311d75542a9547c1c18a5fbf41ce98107524a307ba61f6dc8501ff37c1778e917750963109d61b4806ecb6b534f0fb02d71e59ea3fb0b937898b8bdf7cad12ec1a434c8574396c21acdb315a242a38f273453ba677dc827c96789e5cbba88b7ef234440fdaca77d991751d654e2cc3d5e263b554f5980df213438e2502a77998999bc65554fe6c174970574b9048862ef5f2f6619b31a1c170432bcef00a1d4185aa3a84d69a37a7ac2584c7840127b5948df7b9e90e8f0b76c6b53ac1c37211923753b64e21529b272d93b7f5f5b89081e5ad9bd0ab1566daee670648b5e54f5bcc3d242c545f4ec7ca2ae330e8ca309ccb0e4358752b23f12db584d194899111ef53516ec2af7173c8b3526cbc62dee3adcf1b95aead7cefc2cad0c6f734f3e275ab8f842e995366961502c93a2bebf511dfe265e4e1f8e9d12ef4024b1fb7df37bd235dbb98e04c90316ea3493cf1885d16f5b0dce7a7770213270f59511d0d3b48b4a95aa312fa32f1cb446edb460db71139a470c0134ab34b98c5bab8c6c6921bc3e93be1255f3fc882f18af55a9a45996ed3b6899515b4276b698c1dbe4d94cc26077aec2f026c91b5ad004edf446604c0fa9509608397f68bd9cf524c89cfe90560d965fc8c02df4aaa047737290b31814813024b4f649617398c5e9f4980dec01b7f69c2bd62e286a23f64ab236dd51e2d13e49fe2056486e1770c5d48dd37babdfbed172d34bd06ec7172a9923315aa2990c251917e2c9804da2ca878b894ade423afb68faee72ccd95a77200f1069a83984916fcf55c4948e49c1c6dfd1c13582f193747db9c8df7105a3efa35a66b73778360230365ea223f7713995445b8891dd0d7630857aa61201c44223500c8a8bf128179913348ba8d5300722c1d42795e76c7f744b7bba77cf9796b20eea937ac1fb9c42dd3f15a9473cefa5218ffafa15d18591db81b9de3c298a44d92e2595f09089ac75334ee6b4c53fa095c2aabaeb73f57bc1aa9bc570b18ccac9f155deb05a50b9da7068be74770355df2d874d3b46a32035795901e3922c3188d233a9de2f4b90531ff12bd11145fb4e30ead8e87823b2d8b67dd917c9ec5f5c70ac2ad27cd3768d4536b46c7ec83fee2e67077234ad6f62ee27f589ddde159f0f1835e08bc4a93517541729416478a92df9389a5745141019dee2c3e8c194570e9bfea777e046c4a1a867a9e5c076291f84c02789c637b8ad22cbc987d0695606fcaa53cffa2b11a4ead61a547ebeff876600d81c7cb34b6780056c5a67deba4ca91b7df2809e2fb07010871348b85f95058ff78ef5836aa5ebd9c160f65a0096f4a6fd733cfd1e1339b658139d8d457a8f9d644e4d22a4603308caebbaf6d1121cac296be473ae25d159e4395b1a392fec57d6136845b68515d83552a7b7890d095d5983c8007f35907ae6214a7edfce66375e69ce528ddf091eb944a60dfd81ad7820908243e26ab3dee9152036e57d7858bdd104f91d0284aac1c46d6b6854ae2e521621334eff43402ad3960105d3d8290f176476726b847512d782edca8ce6c56eaed5063d4c1c0418b087442636e79bb5bf6ad400933174bfdff3f0eae25cc6e6c1716ab5b69f721ad2ee8d2a107c486d1ffb74e700402d4ca308cee853227f5c45920052f0e71be95b9cf37c96aadfeab86577f1147cfa3d38be7a6b1565956b7440d080f9a310c922a56c4757a08f9f35d40e1b679d3df91c39ccecc833a00c5580a0a30f215b5990f033fd398c36fe28afa66b4313c41e6d061c230420e7ad604d74346480e7ea3d996c4165a44ee8de4a4c612582c8f0e54a00d64d42bfba8854e36cd9d2c3a29e8d66be5f7c29cf236e9a94cddbf872382e7d077ba5baa4f136ee448a57bdfcfaae72097a677d0dfb4a0bcb852801dd38a0b36c94e47565170a6cc4318c25a08f256ced8ace811302b0e4ad77a5b7207aac5391effd465bd6b079f5c24f179cddff74167dfb3e7237bdcdaf17a708eb946c924465aaa1a1eed223d67ac170ee7f63b360c8b4789b8aa4447b80f90121edffe2f0741ff0f5d7ac825bcd55c440ee658cd7f0aad8a389041a094a9711e187e6d4bdd1f8d4b262bd4b989c24312670c8bcabc69f1763bc857d7582fccd645757fbc4a4cdaccc9e256e4da8cb2b680b09c3fd9b7230a9830e9afe5c1be016a185258eab821d113bf356d26ae2ebc20986f8f82747e3c581864d1634c33fef46b145f4657a3949d007898133b73ec0c95dd26c5bdc1a0352829e740b5663b9a3901cb82af630395f9030f9945ae91762578566275113943fda215b6e519d49f6dffebe6aa8bcf2f25407640f90b1593aed15a662e117310d1f83a654440eef0f0836f5a373ea75c67bd2801df634a6df0202d63493a3a393c8030b11544839433bab815415ab7bd7e9152e9677ec21fb79c1183745524915c191f19ba52d3227e544a9555f3a0e7c0e56128e77e9ccbfba0ee13a5274f92cf0418b4e0e6e961a32e8d42ab66aa64d7fa0f3780b8f858a2676f4ca598c0994b491820f3d3cf92b4e6f71337f3237b18adc0f35bba3e3e31f94551378f76059fea560eb817962ae39b2f405c52e2be003374e33a034be558db7e2bf4618156d34788177db47acef4312f43a3747164bab39031ffa2027d1bf0c50868c1b29ac788e4b996a8be19926c12a889ffb1c7ccb8c8d448641a9c6aca1a8109f5854cb7de7b705bb949c4a9855d4644cd71e62c83f2b1f6b3055ea8ae58526260f7b0a6ac860d39270909f0edad8638742ae8be55dabf16f2b3686e7563d8bdcb9545a2ecd2149931b810263219cf6e60f60ba639c40e63a2d9cb0107bb964d692a8e941d25b04c42aa55dd5fa7db109bdf9fc33a3b2d9993f2fa369bb6632043d9350ce8089bcaae8729de81873da68bdabb93b97e312ddcc64e074fe3349957bf5a2117dc66b9a15190bfbba18f54ea552b4bfe869fc92de74d238f4f598266e29a8d4fa4ac7afad4d34eaa116646841eccf24e8db7fc14ae7e6e8d89c5f29ea0a5f4215f1aebbcd15b44d5bdc1b9088c634c0cdbf226f6e2136ef4cf122d1eb0de7bdaedfcea37d0fd6e7234c2bab536e210fd427e55cbf826300e943f2c8dbaa817a125716221df8abb5af41e9c856088fc6b8eea6a2344cb1284f79edfbd777a57c16879bed251d9953a0b22b15a289107a4d9f07f75108250076f9a2a18f750a2f1c1d47e8b0a960218b63c73ed531abf231f651c81299e9a3251833ca022cc33420e07eb8870e7ac29d1ae1b16ca21571e1770d82621ec3712437722dec799b14d8c02474951b26cd744eea55d835a2299951412c77810c88c8ce4b8017ff179a152107368fd98411ce50b37db7394a79914f292ff3b8254ab6b0c679a7b609f3dd3476bb4d693b6394cd1b8f41d2e807bbe45d95f9b2af8411441d7c38404620fd7e45f5fa415977e1749a97bdbad13a40b013b7b9f235343ed64131b35421fd586beded11f6fb33a1a7001945b980e9194fc24af0d4126375f097ed59c6e9de31b88c4b1ecd81e41fb0c8a1a9e70aa4b57e7f2d8b7b3fcac04001e18f29b929a6973208e9fc7a1e933097fb54c851400bbf0e1a4901f839e1e205cd5313666d9843f00beb44cff3b450d181d894810d6d2e8e195d7f1c403a83e59c30fdf14bcc23d2be64f42f95cd454450ee5c45a1eee4d643572dc7937470","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
