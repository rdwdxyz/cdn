<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9de1335359f6d61a1ee013a31d22ad787a269278b89067e7bb030638fb537450df1f4e3a268a83c7a3633b339d58c0c6bd7a1ddd47143eac6e0c96cc387365c1e037cd4f597bf9c2ca312fa3460f2122673ffb817b691b71732ca782ec2c505ca21798e00d50dc6c6abd1be98ec0e6a1474fbe94ee719da7fde98353d56cf8a96f6c4342f747d956da68e24a77c6daedfab7f9cd429da72c897fe512f99b3dedd04a16f4ce7cbb9fbf2992179ed54fcbfbe46454c95e83bb3e7c35e60389fc70f3139fefec4f6639f06611597716d9c3a06145d617c825098fe323bd628bc3e2ba3ff8337152d06dcc888f4fc06845a361cfd8848a4f8baebdae79a0f73e2c96d478eec96cd5194625cbcbec6721decf0fb7c048dc92a61342a09bfa733989e151a32b314daf2f961eddb227ae2a7d0dda74c9d352f1a85a0df8cb5fa7f1cb04b935671d45982a07eb66b3a960ec9390956787c9b27b01821995346b3156c9a76aeb5ebc24e3bfd06effa34473c85f7bbe76b28e612c5e50763847dc2d0297dc0520514a7ac3fdf9403e873faf730819b365280b036baf221ef4839feb777dfc30baa5eb45abcd1720f5b5479aff7d1e24898674fbdfd991de95e1f07918ef7f1a7950ec6e174d3210eeed6258e7a7405254e7cfebf1aabb0dcdb1c4e456ef36a5b0efa100bf3be1765c74554547f1c90c505699ec4705d2bfa91486ea09dcc1aabe326f165daf86ed67c110e2982136f1c0d522cd88d97798e0a84bb18623882cbe79cf4e239b24db4a40fa501b0b44f3a04b05818ec8d0fc20216d031e58773095df77ecb71ae9d5c25198b81681dcfc47d928e4ccc41cd5b6c6c81fc796f6489c39643a9a4ba0e50e4e85c4e1c6f6581ce283d020df2df488759d39147d334207a0d8f3f4d4f396a1ac6d43ebce0ace67d5c398408429b2fb2412d1355359a90cf96312a35d33ef9170e31c2ce370d5c52896ce98735134b769e1660b8272b9071124603463fad56d0dd74b9a3f4032e4f8a63180dc23e915acca5f8d674a2c75229aee8c6fd98d3ba4e7acd3f00d0efd72e4fc59ac72a1e9b7ef6066ddd1bbb6857134912482346ff46b0dc74b27c8a6b2e305df11b77535d28c883087567af5e0477d062cce5080ccdda6be01a31eed335cf242c0e91ac79737114d2e89e396e454a67943edc25240f1db6e61fd9cd833e80cdb44f63c778e4701e3d203eb0301a9526967e33e1a11d45cd2781b90afb0b5dc4ff84b9ae5a8c7f16c2398b876841204d204d2197d760ae701312f30431d03cf84e59bee9d7af9472b2548f57c1bbf4160c7c7ae3e64ff754aa354f7ad1b428cf573c6df33c6d9f6f3d1dc188dde4eec12d7d6799afae541f1a2d10886290fe20f827c06a3f61032ed304e1c5e2715e053928a2a458205c35800ee65b59b445fdb0b11be166230b96a11411a360893302c36e71842848aa24efc4de81f9bcd4bf2e056401da49c69324f2c4bb0fca5e94a2ef58515cddb21092c6d255bcad4f23bebd77d1b590c8656976b436da327df1201effc11f0b01ea94d4497a0d1ca9bfc1f0017ea9078a4004da85bd708e1d0cbefe84f86a5ffc0fb55092f5dfa64b3b45c99802966eba1ade57c07908a7bb74f4515f5800ae9cfcf332180c5edee8fd69c06a1e51463ea4a0efd964acec782aeac0e07bfadf4350aaa0f2383e0edd5e8150d10ce3c1b589c4ff2e132aa93c633c28d7e221c180210df2d63f3984b6c31bd13a46ddf3333d3c1c0795b4e1ec8cbaef546441f1a3c687b063ebcb214be1063e3a69240289060798f6f3e74f60b609cc14d625afef1532ef0856f78e69155593236d9897e42076b03eda9be815b6c24b822056cfeaf9c8a56c4f0e3e5279a65435911e9aa3b92df86321116cef30c24d8a34ad52c0f44b89fe1e248c4568541f23ed9425fc5c28d3d4e29152378f37890b2a93bdd636ef3a348523f61e47cc5baa72e3dea0eb97c4c226ccb854805ec4672271837014a8bb16de725f9b0770f92d99b2d0c1ae3bebebc2d45f8870b777334156ea8481ec31b758b1dc4345fbf9776bda16640dced847c302819ae2e93fde9c40ab28d5d7c9147ae013d6ed7c19564398f0e41e04c330055389e7afe533ecc658ae2173a32f808fd4bca09985fc00addbf7138babad18f6cf85577f8234e3615139f016b1e49299d73d0099d3cb2ca8d7867838b708808b9e16e0a7d1b654c4915c3e123134fe6cc6c70841a5541be049cac3db347689780d018050b9cc74fcf3dbe822616bc850e56325703633939e004bd1e0553e7a1473e27a51075b3f6ad107ef2c34f91e1ee8693a573e743e53b2d23e3086b45219696d993ad5c582ac8568808e8d4d3b772f3d9ab5558d0cfc78b7ae23668694d29a9c5e82141d798fa1c95c6850896d97509afdc1f88a430eec615c63d2a2ea755b67a3d579e34a7672dd1a24355ab1b63ae32065b671247adbecfa2cbeaa015aba4d399ee07085d1f0dcda6099d24e04506f0db62fd748e8eaae05b45c3d1df2bde4822d0a94f430b508d9da6bae0b346348241101cb5a141a5124713ead9f2de91d03baab9507495281ed8c2caec3cf8a38d81ade50be84d7cf77f354c0dad96dfed5a08b135e8783ae946e437e9284cb2cfa1b30f1da3f1973283949282a41bf663ce7a091d3a0fb7f1d9f9e7e08f16b036aa08d11e21a745033d3d1fa44429881c9b8a85263379e77e76d84042dc4c31fc044c0cbe8e9fd1c361f72a309bcec50de017413d41e9d94508c4528fc92259116c0330f5c26b5c891c3e5a85d71a0f3a513bd04cc12a1ffd6c6f097e848d0a608f4b55a4951662c7986648cbc121df93d2707376b0245820f6fbaa45cb4f30db4ef1c2c25007632e96396866cf7b2dbc03899a359c9a479bb14dc9961119c639e6ea380bebe0065a7e3f88e89879abb89739804a396fd8750db0727605c811ed54948e1ae3b21ec5343c3b59c092444b79c07b117542d1609310a187b0769eecfc726fd4cceffd1f0b7d492200cf9fbfe847c36fa3fb1c2780572b58f90a7392f0d060ef3716f1e4663903bf4f6e2484357ff88ae0432fbadb5fb4348e9ab6c9cb977de71e543b8706ac9eb1d8702afcca306a77ddd26c443c711ca377b6973b176bedc97c167aa9a99d784c3f401c04c351e385798c4cf5eed82efa777e0bc12e874e8ee6f2459767815560340dbf1a4ef6cd312e90abc90567f7b10ff18c3e0f42f21defc1bd951f5188aca194c8a2fc90fd226bd14582fee176d7b27eecf6342a2df2652cf18d71a69acac132de36286118c6eef023120b2b3d1f3c8a345595bb0e0335997a12932158db84d4ed554a877539f3d5409c0ace890aab094b986c57377c86d07c65e2d2b75dd4a71752a4b6c87644b03a183d3640ad03f4f4848f2306b2506bb7fed63f8a206aaa9ce7b3d4002718d44977d079bdabf4a41446d0091c7c2815ae299f4b0f6d1d188bada8002961b1a353aeb8c61b0664012b45a815e554d0a7e555f13be3ab84ad06cf39859c09777978a84b162a2c6d6435592a062a574d965735d877432cf5d20407fa0e3357382b8d35daedf4eea8515b52da6145e57b37b5a871b2aa77acfd7afb4de3e3722fce532512e8c732b03d9e7fc1250a1f4a5994047048faa80c6fcd92b09f0dd6cbac57091d1f60b2d5a55e40ce49c84c98410cdcaec71660c99302a059b75f80ef78c4c11570d9816b6f9ed998c61fe018bdee47cd7a6b9628225e6e48ad84385f4f84d54549656ef99741c1b59280a55dc6347d380a257c6d19fe518fa8f4b0d124620799eadfb33bf5bb918c3ef8ff8e44f10d3a1368ee831122c8501be731dddad79313cf447c1775e5026cc057ed830fa81028cea1fdadd53c1522f2a720d4e454d2b52f9218963281778f370d3bd8a27101eb6b7df5042fd1625857b14d31908d0a02024c3e18fb3dd54b9889ac8e5c4acc63697f5be8a50aebb5c061ef5bb914ef88c5ee4fb48d771ee67cf3ae420bf0f428392a60dd301c561b2fa722860132dd75b43b76dd5412b9f93df1ac1ac4786e43f81da123a67c0de663135f2bbfb7c0b21192186ba7ac0bbcc494322e1073d15f4d89d224261008760227aceead7c7f38f2b1ecb3d646413a64b7d68cbdd87b36449f57d094fe9e1325aeb15a4c9be1bfec96b0bee9052e5337571ed99f05aa8e79c4eeb00881c6b9d1116f51e77137faa3b578da136bc9126b179e7a15702b80e5efc387f32a813e2692b7b3308d16abe4e3425ad30ac808d4d8b7de78d850ee88f2fabdb12bae7e35bc21b6cf81afb5daaf37e828aa7a1d218ebc2041c6a2788db8bef8271804c995448ebb5c9b56811141daa855303d5d7de0605a27ffd06e8833ee399908dfe50168f8624f8ec36aa1b202ee960748f7ef5b8a53e21f48b638b41ceb326faabe370cf0410c83538cc4c92e67817502e8711f963532f5811622680e7a13815bb635598180c8effe9adef982b8593d92839d7ec7619a92d0e91bd5338d43f62b2a9760d659bb1bad1c4f9bf643a259fa1f3fca33bdcfc79e4728e1dfa6968f3de5730bb5515011ef83bbc69aa3542c54fa8aab6a7734330d61ee65ed1c66ad1f847fe54c103c1ce7c1486a63a67b570dc03b4e7f38afbe97fd4319bb4ed157370cd4ac6713a5db6574419950d1131bd0c12788265c71fd93edd0b4bf7602ba2ae0e0a22d6d77adc87784184740fc4dff6dcc902e27343b7e2d352c838315a3e97e9af0a2284c9c30b3a90ae6bab75ff7977b6d5a88cb17e2cd1d46acc4a1605163226c111a5b5f1ae40f80fccedf62feee5ab7cb5fb4ea16d36d5bab326958241a2c90d010ba91e406ae515f0b000620627a6db2956342357a78c5ee44bafdd88f53bab2c766cc73256a92e8f1c61a600cc510e4b313534aada2a47a636e27ac264f8e9b4df6eda76a25e95aadbed49fb25a7d4aa3864304d1768c0a1c85e5ebc025820b4821505ec3d9f468dacd6ab45040a654b7b4039f55eea367ea1081d7caa3e760ab81643930cce405fb9c057f7d5275973106179733c1c6c658f2b3e479c027ce71bcc7cae59ce4edb2e428d2935337cc08eb433ee262886d37ef38e588134c5cfcd39871407a68820339c37e2d2092f63d43afc827b27417f4e9397e7ee19423488c8fdac006b2f734278c9f9cd23fba73bbb32ed9cd204e1152d02fbc135f2d05353de87153364bd470509a9c15354d71ea8dc8a965f612af9c418503a90855f55be2dd87a207bf0b1a7a55ef33a465819688ac4b30807cf08394ff4c9c74a507614d0984537fb50673301035dca7f126037ab40d450948e60b672d96e2cdc95edc5a18f6297613826e988e07c47638087e687c360969d7ea3e7e148cb1ed84a5fbdd690f1737f2bd4f74acad3adccade02112d99293a029945f6a02f2c4c9d27b33069dcd3747a693c723d369127e6df24fa7315e3b8f591cd73a941f3d8c5e7e473bff8b96f532a46e1cdc28b27c9d91bf574c66f5f986ecfca4b7301a438a359be8263acff52a00738430c5536f9329888a2953d98778c4a036b5b6e44c7839d33d32de6bbcb93d6a69ea7026bdf371baa635faf06eb610b19f86321dab9ddcd0fa2ab44631bff74df1e3a1b9c5c27568eb7bc62e99acca073479c0ef78c8baef61514541bb13bcf6366ddb037c1a333ded739eddae2363aa57baea30a9772b7b0154df64345344e3b921c26a85931b91aa8a6be64d474a2fb2b6e1086af45328342209cd4afb07d10ce13aa1140623e4a84483dcb651023bd8c19c1e76a9fca4d963a4e091cd29d96ddc1bd38f4dc486884610e1c8d14d87b797ae589d0dfdac4aaa5e58ab0fa29e51da9dea85e1ec6bdfad49ecd31a0309e1761c2ae7a79bb97832f897304fe833f63b00aa91f35433c98b4b7a8d3f77462c274bb0650e82b646c3a3c4a07cbb93869492cc7e670325eca3087d07e6f40306cd7eee8502418c9aa440942fa36b75588612feb4df7e3d442f155ad39e1a030bb33a309690c93af021df3aa378810809628afd4da57896f34c38b7850fb8ce5c1ae1c15a5d39f8fc67d0fcae98996f9ff91f56bb2665bbc9e0de3a3579519f2cb9a171bf1b952b3d68db7dd49be20460c56ee26c87bb9aecb2f0faf7fa8ff59ef4c5d53cb0fedb12966059d3e3f01b099d1df5623405fe8c920ddb42ec739990692fe0688df728d2ce3832179eb153386d868e761fcd4e53117f161a573653a5cf1623c8f22c3fef45974fdd4c42ca908c42c9309b17ac10655683de174b164588776f4a388eab945ca5937f9640ddc18288573d30f193fd18f4e83f97b85ac48252f619902855325ba255987b1c7c2ae5fe3d74bfd640bc3247ee4eb41d788dc67bd111a2d3fb99b5b96aab864ad1762f858c57ef87f46ad3727427ae96277caf94d10dfef3a76f351a08a3096148d9b1e8ba1a5b13e50dffab9eea2df91dfa2f745321602bc8f561017766580ef25df69bfbe4a61202c36cf06d2cfe9a67f55fd7bdf5ed902dc2ebd3d28822d21680f8a57a90bc7ed20042f7ab120c25e6a8646a00f6e6903b2f4b82e69ced63364be1057d8b7a522b68fb80e70c7c30818a17c96ddac8ee587d1faf37187314a96aae0f6bb28630cae991e5f7c5740b38e45eaf2e8366f654d4bfdb260923639c770d3cc4b1163718d04667d4daf60b82c41aa245512d2c2b835f6ed7b78e804678bee757c7c20a0391f9d467434387b16a072ddfd399b9f0fb603337a1ece1ac9217e34e28b35ac72d296d9922320f5b96ac5f9d83cb465d04815ab8133cfe7ebf0ca0de158f2fb46cbd5cacd358d90bacb91e5d434c202bfe16e99e2938acbf79ec5f2851d524d2b56761b271eabae351c8cd3cf3193ac73a84ee875f741c41dc8c4b8e0e1e50361dc09e33431e750befab0f086b3d644a618736e347a342b166fac87bb5bc8855597b054afd63b62d2e2522050e0a10112e35d1250b37d8714922e3502ca8e02b890fd0eb6101d347bd430a6ea79fe7f4e931ef258b4fa6ef7dab3feb101624c630f80ea71c3f65abda172031b2b157bcaa83af4aced87fa5275ff4dcceb4a561fa642f6ea475b31eda265717414493142c52526c7089708a32ac087667653d13870ec3409380017cb3f6d996f435d72b68333301c2d55bdd752b4f0c44355edc8693f256812fee22187a6684abf25a393fe093032d347beac9ddf6e539390fce9a8c7b2bfbada0945f642c89908582e57b74bd5d192e8d6c348f2672272e4e6b716d6fef84976351d4f16d4341c4f3b4ca44648b95c033136e36cbfc7db5c4176a75cda5fc5728e6c7b123268c46ce39e2abead8e3aaed17d87c26e8198582f8cd69efb9ca80d56f395b9b125b999a570ce1c2252aafce126c0adc8816a51cd6bb25cb0cb59b379df6c636d155b020fcce13766bac4693d2798f517e9deae05e7155a973477a1eeaf26cb25c5de0f63e8a2f5f0e93bcd51a314816cdfd17275ee37d14b8ecf4c5dd30a94fee6b8ea1002fe94a22920a920f959c16ded710e6ad87f9eba7f61b9a089cbedbee0b77c16bfffd2e723a4e5de2a41e19255f13c392b54a07a4d6631f4ff2c2b596d6b13c3ea66e090c583c656d809b21fa3b3898adfe204d01ee8a56dc81350a6bd997021faa05fb0fd352aa1636228d5242d44f2cf10dfa9b50092fc9da57e16db315003d9a115af2172c2bb0101c858e88cf05ac5a487ea69502a5eda53882b015caa56c9915c5c1700c0887221aad2e87773ba74097f70043070ddb448a3225e45bb03647bec4c718c03a24314b15fb18377e825aa6d7445aea0d986ce0037e7aeb9132f3a5cd183216c44763930a4e39bbf168175268aa3338473b8da1568f543f78de5f76dd4cf959222b76045136fa6baaa72016dc12e5d0c20b88e79acccdc0698a2930a5596d44afcd2a9c6cf13fb7402a9e29fd10f2303f6ec623f023d87e54fcbf61c3497d4bc16d1e628c60751f1049bba28f158db460aa387bf3431edd95b55d18a1d0573dc5769b63305177bebde78d66f0cc5695e5163490dbb014610326cb416cf2dcff6c20ce27eba023798b448f899ebff333ff083bc077c8d1b72a432e5e7048c3ff493c27ea73e12de98d72ca1963b5bef097ec3bd934f06bd52f882a852f9f5dee83c2823bab1ce32b0045bd2a88565d096614cb45ace785a93c51f7b1d4ede4378d13fa14bc4926be03fc35667a9fbc85285e43bf17c47326867a6da7d47f9e171de4a28e20755c5c23055b0a2074d6d91f9b9e2e75a54e4761bb8882e77958be5359fe4a49b0d6466746a72fc82016f9a1a9d869583a9c003a0836a372e8931f0a4af75b0c9b0aa4d66eb33e0fedb0a48b2af9682419f0d058558086406b6da9182f22474805c4c7eb089ad257927fc0894b29cf56228addb55cbfb8205c5641a5c62ab7e9aa7437ddd99b6073a6035687be1bc291c32c2aa21c6c3f3db7ed3d1d52a417d2e0da7cbfcdc7d613e535100ceed1543484b7399927162ce83ef2604c69f15c1aab6129646ad9b6de920d196a32e56e9147db64bc454a34e7c13c146fdbfdf6214021c77dc945de4bd0994ef67b115293a8b8a57baea731c495025858a22261df98d773749ee7104ae8182f276b9d1a251254ab875076155502df0f29245640f11a7b412dd34b211be7078da4fbee0d2fefb9810622c9126bc8e9c0792a1e6679cb0699cc3a2faabef11c5fe2be344905aa8d25e7482726df2e5cfe8c5e179a7179017d0b3135bd1bc9c6e3bdd46d1e9ed0c0432b8ea67ab0830ee5e39bfb480f990ccbdfffb1f6c0c96001a4fc741cf8af144e762977cfd826de3096ad98924c025758b96674bcd76e36442c279ceb601a2b08c5537ec4135b0786ffb270941530c815ffdc59202033eda8e6660fc33fe9bf940bc60bf1335f54db3c350b236cfa8315c8603a55b3e9d8062b5271b2c2319039e7b4e7ab5ca254dc0f85f713d42640d602ebf5ce2b4c9345a737e47b15e511046004721f82826eac7bdd42107a97605a9c59f909bede63f0270a9d04dcf73b507078619fe10ccf30576fff3632072f9403b909555000a1ebb2442a67586eac036554c23d24a40954734043e87fa178db5e5f31af627f7e56b2796e83773823e2fafa91f0b0d0e706ba48fd27f738e6b6b549c8a9fd42ac436777b00d29d7c8994fc058a3bb84ed49d7c174eeb7c26129ae14b34d1d109d8b58e423552488deab9ee1e67571eae0a46f5a1222aa4638cd8beb8838d4cb8ccb69dbff3dfe547889237b560266dfaaf392830d2c2e5abe13e01b12e24d9b77d2f80cc617da441f1ea39a7699c4e38562922c3c5302069f72e4514deeafb50afc86d0a2677198e2cb84231454e9d83067d1c71d2a673e2bea29d97e92d7dbe78c4bf09738fb0573e1569864d35cb2424d0ec1b3085923646fc421ff488737c97f7182e5e1e8c2389c988e754da73c708f554a67b6823848cf14aac5c62635f6f44eef7b13fe8adcf553cb6deffb753870df0eaa8cc65c0367da9ba736eb0cc032d84257b1fa55de2b19e816c1ec1b8553de02e26176ecd15181b797dbbac92cf3775e2d34196a4d2be78647fd9a3a84bce1182566d71efe0d7890af85f25d6c82aa9fbf91c5f786f9084afa50aa767348c16479c0947a6724633cba5f44cb67cf595b60bf97eca5ba008208ad5c5d80e9188dfa71972035c8d0a1fb9adabbab515cea46f9e60a538de4af194c645d842284aee886af4894cc959e787bc8ab0c07362dd4ccbcc9b6b6ed385dd8670ac1d0f44188bcd8860f5948aec2c023c10c7d4708c620cf0755808baa69c87ad34b166181582cb372fd2cab2b10cd52df44105432c31656a8bb06fb25ba53e25ed37deae4cc7f2d457e715cbbb05f8e5165d60aa2fdfd68feb248d7ce6e6fdac2802b4ca8d27309696faecd11a8447010243896a01b0ee6cb6db1b1f0fc1b77cf3e43e050b731dc84d667213df78777b4091ec5b52d055d2fa01018335afbb1083fd890cb23b1351a45fa9058bced255d2c6a39d857838e6870ff97d32fc446b732231216e79d819e0af8477c248143927e9cb066a18b1f5f78ab0b7675ca49d9347c905370490b50bfb700ab7c370aabc982f656b18853ee0337e9226b55d51dff9144fb902b73881763bc0922d9bb11c295308290465c9f55f08afdb420c453a9aedb7d7c2a6cec8407ae7fa6cc1dc040743524e193acbb1e86afa602bd0ddb3bc11f657feb363a37fcae8fc9ead1a5638af166e3e6926c1d6a28318bc84f2bb9b94a44fd26119186416f9972cef1ae44d722efb0dc157c78a9527b8617474b49ec0705629fbc0055f25391828760063014955d21a923961ec3578572dffbfa7c238f6e5b7da3414559406817a85b43a6adf8e4e638aeb324fdb235486f4dbf454ff0b05583353e6893a4568bfe972c36991f71b69e1b912e878d9372005d1a69ea2dbc70d6ce2f82006e3d18f7a31d8f76230594e5f860f96f59183f8a242fb10a34444d72c15d3ff5700b034b267d5b32affaaf30817edb8f958304e00c18c02f7e9eb2efbdd24381daa5dd5a68a83c19cdc82665ecd5b22b3ae04f57704660ccef9e46413336033c4c072c1c89af1a8284fc9efbcd834259a6e4414142158684fd1bf4b516be0a9d1d1466f7e7bd24ed78d4a6474c4d402fbecfbc93c9e6f245d9b14f9072852745590f9244ed126872ebe3947517a491a69ba07f480d90c4a6d9e2f777e5608683dd174ab783cd6338008fb810a8eb7c929a3bffda927b626a2eb0bd23c0e30142d94caa34bfd14acf71a72147e843f754e632f282a0659111a06c82c931b20876ae7cb63664210a5ee9acc96f1e68bf01b61cc40a16b130f06abbcc84304a22958e796d5d22a483c006fdbd09241336d79768107864367f2f41694f7b308655f16f1a95d9fed3c0bc2724fa0add484718a6bfcf8781d3187e30424f1e9e4c2782ac3d616bb66f38e5c01b82f0eb6cee8d43bcb09dc61fde9b40a738adfc5fd9f4b895bb484c523b7831c64fe50867c42a0343d26db9ad0d5f3feeb359376082d93667262f5e756c2a0760c6ea05518ad27e6acc8d93405233e9e72d54b708c85d3b4e9ef2f6f82eb84ec3d34ab492599b9916f864ff710cd33e66dcf733e30bc0377730a390a7e3ae73c75c5d3bfa41b12c3e18962ee441e8f97a41f402610d07da87c21e6ab876ce76db0b9a03f56d0400db651a5b583fb52000d2fc90c7d8671ab2a5d86b226a2aa5e83281ece30b460f569608f8d212458192682bd00ca9315d0e6def08a23039d3309e6573453b464bfd71f56f91abac9088d06383f6996f5edea20234ed112102a90e103931d39920f47ea27c990283d576499fc1e36237a290e88033291f92fcc1ac54df818567e520de2b36b7d1952656d045f75b72096ed70dbe6c97a21745df29f2a284aff9e3d9cb3ebad8ac4c17df1918ea08e81bd9dee1b9a8abcec31267aa524d376e750ad758e5a824566552d0f12894289cb26a0bd81cc0d55bd8149d72fa27aaadde242a5a6cebe8a64242025cac51525f0c87f24d55b5f52341bef5142c7d3163963fe4fc4794a60d608c9a483f84fef5ce8756ae5ea0cd009faa18e5157fd2e602f2570c1f6428018ec664cffe1e20cd2b871323ee6228ed62ab7fcfea611bc6430bf3f40eb5c74c9324ef1b8cc1ae5e7f895a4fb5938b80cc2820ceab0bfcaeb5d996cc4b63b76ec4c7399d2f8ab02b3536256db97c58a24c962600292a769fd6416a810334649260d3bf7e2afc37378402f339524af8d2762544ae597bef0d436e1eaf5a2bfa29948d9ff16db1a125224f7f2968a1d12ed9922acdfbd024509d364e7d1fab049703b10ea36898eb62f196a82c02a22bdd6e0e0e737ee548cc694c75e8169a792b8c38067749907b583ca8dfe644819d15af5ae9474746d2f7c35875eef580ba5256e5699028c9959bd84615ddeb37e06adae17d79a880981769b2f4f4366d9278534b229596c502088b0b74c78be47a42b63db09314fc12dc4cd82ff731218dbf6e567214bc304b52c5d977bb6e8d14cd4d69037d6ea2b31d0bc5265643e6d03fa7b42d9939f4ba36263dac890510765a0deb19b254f2a545816782fbb0e5ae7d0a24288008f87e766d4e1050b470feb05b3869829038d92a0963d24666050ec54c67c74b1d9f28875d46a9a6e8452ddd33db1e371a724020ab9aa2ac81e7880a0ca4de1e2c79c1bf013c773ae964d82a0c0163783f2ff08272d920152a23c83b214a7a3a0f5f92d3d86ffc1f8fd58cfb5bab8f12143da30e90f9ebd5d341c19257066691d2df78ce45088bf32a981d66df5fd8847420b9405289179c52d791369bb59e8893f2319635b10af89e820d8a2377a9651c6745889ccd0c398e8d42d0ca5b03f8d2c1963a54088b6288e3c718e5ac1ff2e234418bc8195b528eabef57175850e6bcdb19257ad985ff03b926987b0f1f603334b14b23e3901d66455c76bc4583e6dc3f0358db42904381b23b5adc4f647e3968c46a599e3d2733b1e739e3eaadaf3b5479d9d60d880594c7cfdcc7678587221aa6b8e1c5801a091f8c8f51f207a3adb51f90bcf923a0625be00f90c94f5a76aa1165058507519c02e8d85c5730b952c5878bbfbc0cd11d9c94c1cbf27a518fa0244866ada089156c8e9850e6c2408d1879815088be5a546fb787a2016f4860150d4ec5674e0c8a0ec85eb151c931cd59d5050c667347912baf80182ec7cac9bfae192d98f7a88a855d4c8de03215af039b0e02a676bd0b121bbd025e656074eb75ebab157b06d3a471c63aeffe782dc6e02d301735177608817c833e6199cbfee30c230bbb603c5d54cc7a086c275692b3c2e673744e271d452f964bbb93c0a9309bf182c9f2581369d9839ddfdee49b123b79b20a55f66e68c6f74867b93803aea7df9e1227504e156b2030aa6752e973c307039f87e29121c56430fc140f4d504226524d7d21ad455508fbc83fe0579a16c1ed064c889c658388094fc3e499ef19835ae3a74aa4124309da59c7a09e9b3c58d9f0ef4992b5bd5337d02f67153ee423e2e99dd535dcfbb2bac5131d054bd2a4d884f24303e8dfca0c533994cc7a9821f8e8c264e44d8d9e0cdb30e186fda69c46070d4bf3f75b5af7f0d6b0485abfe983e8d8c68d64d06f4080a8a2d902089fabefbbc22a7a52db979e47530cd6129d884ae4a246e5c7a1ed47257786153b7d26f5a66db49306eb20729a17c6ee80caff1a410937e1307d08224e5b2bba38cb0480998b3362cf51f1304ecdf46bd41c42c29ae32873e67fd6e28056fa69764ebefbdf1be9502ffb04ac03edcf6220456a120d38e75a7e2f7713e5b7a6af8704735f703e6ba44f561594080b07fdea66335f7c6d98dbe5e68f3d99c21cf98e1aba2833ed0dcfd970e75808d4ee84b07e9f95f3376a6ed66c6c31e4191cfce91d7ba621a4e84c460229447966ab1f5b2aece197e17fc3fb5f788c62503c61ad31799005f11c027decabc322e25ceac9f1712d9f4a8b7a157da578c7a048c21ec37d8d97e48a5bc3b679802954cb321eaf395af1e5f31af077261cdacc7f6288ff4066239552c574be0fb19dc30bf6659b8cc57e334a68ebaa3921ed27444f62cf7060000cfcfe4a5db258dda2d371329663ddad5f88f847556b2f1f923eec2f2190816cd67a1dc5f5f7a036858036618a2dd42a2420cba60c185e9a5f1cfd85ae1c2b04d007f63ea105569839dcf3160ed996f020a48207aa5691a07fb917218a52d058e2a1ff695108828f7ca27348580633bae0a6359fc3a462eebae2efeefa2c26c0f167cd25e3f4a2a9080826372e95ac541b53000450d635dca968ac5f6cc21b36fb36f1601f89ff1fb43fc725dbb23074a7ffd69c732d9106d17340bd11749e7e4caf6897e06284842095a4fc1f689676c9b9340df77b8e318e5793e1a78d972c5d178fe4adcfbc23900908d1bd2bb1345b3a90aa47143f5e805e49fe9d1321715fb7dee55c4ef4c2c69a559fd3575a15a3a0b03bae7c7d19419ee838b3b60f3d49bf4b5c70b94f7da00310c7c19b691a0765bc6de1ba25d4a322b3b0f0eb43530666dcdfabb9cc6396c8269600063749384c883ccb79cf7f49967dfe6e46fc9718ba903628686ff3ad6512b9983e0ffff8dc2377f499c745d32ec15abac09f8627e1732bf8a3874a5473137c697a5eef5ba4e856b31aebe6246ba8f1d304b14b66d6080e8f6c1c57985b4f97c78d8c294d1cc61c24df0b29d1dbe239fbcf10fec0eea07881fea62ed1ccd1cfe5b04f4802e32dc9da90c1efc35b3357566c2209cc1873142ea700f906b051f3712dd76c08418d61bedc472b139c182345fb7674760c9f65958009a3c9a0298748990c430ccc8cf577fe924f1b3e962f084c0c272d43ec1a0b4243a6db7ad8308ee804a63547c15871211d0f9627ad7c3678de37ce4f2e0478587641f78abef82b8fc2b7b4b3b46a3d51709f4f1f7100cdf2a357ea53d03baa4eff0770a2128d3d1978c7a6fbffcb865175784e759c7e9fe8de7aa395e43b3bf643df862419953742ccab0c8f740ea17b0f74233e22779eabf70c457405c59df6b9939714726813ee7a2ee32b3eb4e1b2fd18a2ef4faf472e5424580035bafeb392c30bf06a21ec1ea437b58238a4b96907a5c849c84749ea99d2d6405a7c8499819afad800d0d4e6ca32144b3b3f53db39887493f48dcfb31d79f7e4ab463a84076e93763aebfa23b1f80c6095e79e71c42314f648f37b41c851fefce68d57d091d96fe48b45b6479b18e5ae388c25c391ea89e73e87481101ca34172f4b2eecb39cfb7a27b38d3fb93e3e191dbfec8ac829bde8a529f9039b12b8e51953183d372230d1e571615574e7c68185f4de5e35c434fdb146db7d6b988284161f4e57a18d2b389f820a5f46661a07c2e43cd2135cdb5198abda0a1d5fb4dedb178afa64d106602b476f201195d9a71f3f8553cd04c93c048795eaf61e977ccf4e78c010ecc0d3fc6f57d87c5f58c21309b468c7e2aff3868a205cee1bce9d2eee20606aa641b22cecb19e9244e4ef5f841","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
