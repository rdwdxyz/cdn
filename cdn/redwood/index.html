<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b834b05944fa158e1d9383e1f03e9232e556a482913383cf91c9ee47ed088ba9bbc418fe78a5d9207fa1468cd93bf721595afbf804e509ef6dc30886bb6daa6d99152bc2ab336a892a680d4f8bd493bfbf5a52210fc57b1c64e4d1007782341163c9c3537652bf18ef91582330bf803980cbbdf8a88c14d0ccb2e1b066e64b8761b3b2c35a5685d8901042fa4761f7116195c6b0e91ed496fbdceec0cf2b57c314b10d6b7d6b0ca9d4715fa9d102d8607efaf11ec23d79e61bd5ce55fed0ba2b096d5b07c7a556cc899065ef253edf50edd60f75c1094cf4d266431da26eb7991bfd45f8ebca5de40ecca99ff64485a14e5df169c57e2418f34e6c0f6075b67a0f181e45478ccf0febe4857029b67b32e2bfd1021f23ca17787d662833e74f9e15f3a149a43597225d8fe0606d5711c2f58e11659afbca95f2d05df79a2727cba9e309b34b23ec02b747d17bf9e3e36ba50896c31960a1b3b96628d9b7a7b91d9997a55bdd5ae77a39456ddffa8ea04f2902f0af05df636cee10af57bed759841f166d2e63e2817c50733ca14777cad94a875b97f77d462387aaf8ce3d0b361a57b6792d2b5a453feebcc459b6fc8417866fe049825f62918bb8e99c44551bdbbd349b18dc91cdd3b53a607058fcac0239fe4195fdeb48c9901e24da9cdf8c150603c5080d36bd7f3a3553af99ceb1ce630e17d966f0b5466078ce599311367a7aa6628688d0546f457d51a1dcdc8a5d56a13dd8df789ca039078fb6ce1e3bdbe54a04e08519970d152b871a88d20664dda6e9c15fe7e03c4bfa7b78314108df217fdecaca1a52314075e15dea1ccf001ea395c5edc506ea8741a01ff06d487977d56cae874b86f2739843cdeb19238c53fea70184bab99604407c75fd00234addd4c1008cb0c9a1013054ce2494281a01fe3090f678b84d7b02348f39e8a2c925fbe8805d454c5bdbd618efddeffe55f811490707ac5db61703a5ddc6d810052624184f931593aa0adca6019c4e17e349ac3a222b8867226ec7ca13d9cc580c005c19298ff8bf6768c0a8ab2ab7acba7bee9996a5feea6048bdcfc969312a54d624e61db0b9dca4f95ec8749769eab23359fd91d17ec3ac8c9b4788fdb5e6eba1821be83a8efa3d05e2be80e56b396d4621d274cd710061eb39a818c866fb7edaa5bf12062056863f3cdcb8e138710a4fdb312110b6e694b8cf59bb5ca35d598015c1fc5b047535fc67da17f89ab917b448d07140e14501c11c82ab509df8e4fc3faece14caf437700542746f3495f39ac9f9691ae32528e2b69ec3806b38e39f027badb526766592d8dfbb863f6a6f40e52648944230a89f119184b54f4b7e7919aee7ce502af0db04a1bf223e4eee20384fa3dacc9838ef5e8451d5451ef8f2bab8f0764369c694042e8fc110e2175bde81d50fcfe8369aea0efae52f1fbcfaac2c09d78e3a911a688360a12443f04abbc842b64f50f4f8e4ff380d8ebb4e6a55187225eb056e457d83877ac1b042e3b972c86061322eebc5a09dfcdfc941fb84608d23ec58236525ca1b437545d602af88d82aaaacfaeee3deb16c0da32088a7cd1024926d8b492c222041b7e2163bfc13da26a57fc15ee320bca0f79a0736ec210494a0c59bc5434ff3af2568b3dea320cab4546886708cb98b8a18e7d7970783450dffc9bf8c150c73984155e00f0516410fa6ff5d5ae95c3c7138a754a16d899b4915636c7b74cf30e9961ae09642c1203f9207bcd5cbedc0bade1a9a9fcdaf43ffdcab165639f38adb8ad6545232f2657bd94be5c99388d5b50e0e5d960d0bfdab1891b0e3cb52a5426fcf78278d86357206567c60fa4754b486d61925ce5caa6754546c8b0c565f7274b34f5a8f83edc4e1a256977b6824e96e4ec194a70eca3b4636c76fefb2ab73a0744bd7d35c7c2f91a2d12cd3865d6714be9375b68fcd3c1c0de0a814891695ecede2756a5b03d261802849e76cfbb086352532970b72a94fc60d9f1814caf94035308b84421aead958279c178b8bdefeb93ec9864c62903a624af2ceb26ae422dc832e7551126141528ef88a1d08812528efd962a67b01cd46db722d75816e1b6c6d13b3730d7ca2d114dce6e0194e32a34263e7e5e5627e9b6950d39c191dcf63ca090e9dec60e03855a4153b6d8086514ef50dfd417b11258dcefb31a00dc88ed21ca9be2065cf5fea97e40bcfff1cff2fc36f0489ea2607b5fa97a1627fbdd6bd109643a64d8e448777bb33b5539d9247a1cb952b5a391da00a28049d9a2a52ff7fb077aaf623fb79403e84b3705dafb442637a9240d89173ab2baff8fd58a65f8af57bc47290bbf96fbe0b52762ccab2e9ee932c4a2ce6121a9c197a3b66f710acec2780ee5a610519cbd47fe2cb1b1b092d012f6b3f7e87e8bb417ce336827e103fdc2aa6cc3549400d015961449b0b65435b5f65e69cfd594c7a1af1f7a8729177282bb8ad15b175f40095a5e76804d16ddc0a28bb5b4084ddf3e4418dd233e3b7c8687a1ae4080b9423fd766e456c1f972a8f0ad0d177d88ae5cb7c1baa4f352ae2bb01ea129120f0a190074d2c138a24e491d20e039faf6656e5461c9445e722025c1cd8c8d79c6a24ff0ddbf939bbee6cf5dde642a903a4288a6a8458b351caab04f9ad0cfc47fd5ff3ba7edc18913cbb9a4a030beca588ab4465f38c08d5106771c61b55d7d56ee19745d10305e801b1ad56d4b3cee49448eb5440f7f49065e92f786e700a890c37eaa08a0f6a386864d5aefa1bcd1bdc8f04819908873ac24564c1f4bb90b0e68eb1b1236a3510edacee6604f2c2d94588d43150bd1ad0693537d5d1e6d24f5efb1c0c1a46a933acaa64f00e7920e2224ec3bbbe9c8e3a0c2bf2512af556a22d52e53adfa8fdeeb9e80e2712c4c93d23b1f7a5e7f7a8f0260ca2d7b66552a3071014b8e4629208c2c5522cab8d9541315258e71071fda5aaea301d5346e4b9d0d5ae7a522e65f7c27c8ecff98da42ebf7064d2734546ddafe941d754b8cd3b76e8d982bcdfa84e732e8efe684a687c574640ffd67a64b95e067fa24a54fe13e7a6937129f3b5e6ee9914ea58032bc2fe8ca1c2dd4f3492ca90ea7dc45a859a3ac126338017144a51cef3841f8dcc352e211ca19f98227a866ea7514d0bae5ac0a5a0ba73fdede43168dfadacd79d38c9113e12f3185e7d29ff9cc7f3fa1b28c60f365a1600d6950c9f325394d49a6e6da2e7433752c83020bba053b58a72b77ed114cdbdb625b54b4c3c6add942262c6e15f7fe4e4e06320eccf1f9ecedbde08c785026973906172284b86f6e45dc4cc6ff5e704ec7126965b104d50c1a79bff71e50690c4ff27d08f8baac0544141f24a0d0f587248b91f24523e8cd9a4e835b8e328f4ed88db2babd7d443e6867117e89e34d9551249ee77d0dd9d9752603512d13259d11999c0ca37e25b78cbff51dcc8cccbd4fe4fe015fcc0b0cf66ca93fdd6671a61b78c44248993f60ea477b03e6d959296084fbd8489598c5c2384d3333b5578f0781a2a8d441b9ca304aba53d4ee3564a0714cdac698198a915ef303179cb1159940d3fa2d0bdac50c75428f74078c5068fa29760ae1ff0acc176bd986abe69f1ba410d27a7cbc72b850bc68c879af7d2bfdb75b8f788c4197861e58de0377b68acc1c61c11e42b4e5f1c68deede2c66688e54bf9ca50409af0ab5c44d3fecd88ec35e72dc4b3e18ae1577c2bba989582079418ad8d83e90fdc5b18b2855c7770f1f716c83e03c1a03d5a8e19c86f8c23157944f9099eb2ef166487abf33c721bbb031d33416a7bea6c6d2276fef1a64693a4c51ef58c73eda0897961be6913a907f69d41b14799cb06d1a471d6f53343cc44328a5a6b11d9e4a4ca5877facda71ad5432543d28a4587de03b53ea2116865acdb48fe1c581d5d56d853fa5b328a8347e43e06fd683f3d2d23f04328ac1c13c4a27fec7c382c3cd032bcde40ece56f1f5d6900791fe093daf43ad5bc4e90b3d9e3ddf67b1fb012f6744614640d4742cd7d68cbcf50e2997aaeb75d210e18ba47b48c8a5bebac5d1160a3b6398a92cdb1187dc4b5c6118f9f148bfb825ca54e8684bf7b96eaf9036e5407d16a73a850ea9e5cca13230318c7f5715720ad8a99c60ee0017bec18ea448612be2e2d298027369f80096627e92796751296c4772b6b294b42351c9cb52343882e853f18bac251af4a785d75496e25db51485ffadde3bf2314ddf3494a418703186b7a11c934dc7db83fd6b39e1aaa383b340bca8de76bbf620af0a421c32fdfb4ef34072246db27427de162ad6ed387330beb209ec5bfa2d07f6ffeebbf40628646e347e27637ee6477472df6bb5c26ec269587a05be9a1681ac145140001dcea61ece678a78b4d1178f43b637ff4e87ab257c759bb7a36485417f891a7673c130070ea0459892d99521225fe61519182414e569850e370b435401604661a31e8b4c9bf0b3cb064bd03ebcc57e0300a089bc679e93fd6b1e18206a73366d003492bff69423b6597564e861d5c1e28cf6d57ff10518dde983b87434ac7b25bae8811d2de55c2ff8d026cb39b24c63ba548ab9c254d42646d9a2d3615212558cdccbafd434cb4acc35b97673e66f80d3846586153f4ba2ac0c98c27ed63e98c2d86e3cf47c2d087d681df53336cf7992b26f3ce9593ee37e280f523e7171d9cd1a0ddb4aa5e956c15fe33d30ff9a6945c86f986080e12fbe7fba276126c7983feed8af3a7411cf9fc2ec79149c4671d25b4c6276793c60bcef2c85d80798e3eba3aeb2d58bdf80b1fac8f39332c6bf0417193d1d4a25c4c01fadaf1925138a03b65b49e187e0e132ba13bbdf9eeb49c30b0ab07c7bf0d36c9c5f8a9e90ae8f631c4649b30d306a10aa7d35b9b1f4d2f97f42be61947b618e770292e7bd5454e5a48805b96c8696478191b77f68a40d55bab890ece56a8f658652e9117237515cdb4eb0e29e5fb626da9911a615a59feda7cd27a1dfe37807ad0b3144ff87e9769706ca8a4b61004396f4e49389b039b71b99e3b7ad009a5b9e570d5b5f8b621045d4b5d6721dbf2bdff0f00323a54cdd163fcf0b23fee90f6293e913d3140c7bd3d42dc4ccf00996265b49c2edff02b530a5822173813d7b98b5c53113041476a77265c3d56feadb8345859cf8416d1573c329c8040f42697210154b2728c7f4b9c53134ac50b1510cce2f16420323e7c26480be5b3b99be75ccacff4534d0fab425d1eb552f0e709f91de2198d06c5ce029cff53fe1cf321f42ffb39606dda0f87e3e82332bdc3b3f850d89161aaacb97073889152d69319850eb7982e9a09d1ebd85d1dcd7d806169c1d012264a5ce185cf2a360d93b9ebc69e5c22f228b7a49c01bd55b163849916c521385eaf9c22838fc28d71ea55f9710a5c97fef0e8411acb0995a25481c98573892885733e70d02e348bac13a7e0e64e5d4e94f95096bb8895c8d004d09d7bde82a4d0462176d2c4931dfc4f80d75da7ad9a8ce4ba0f56b1b5f933d06a21ad03f915eb90f0459437789a7394070ab31c5cd986cf89ed862c9b64894fbb7c27dd5e95cad9467a2f8f61c5aa0adca4107fe21707252ab7dd4aae421aa2413a43d602a4c2f09228f49cece3a6d95cd00c1df011c21f4f6d03443d18bf2d84715bf4f0ab852683646a290776705a0bba150ca30059f25c8e44c570a97fda524ad8ed4eb80943d4882b763194de92ab368a0a80e870d23f3e347702ae64509897baafba5a774f078121a10fdea5ebd7b0eee299d5f896afa495de20799b2fd36f312c5bea1f3bf3cc87f2e2ee0b1a80c80d0000e6f3c79d52a2a71e7f3bd0cb8c254b117139f1fd56bc074e917fc057648186202bb4fd3324c30618321e35253d23e8652b2a4f3ccb8eb911594eccc336255a9a25cddfd04dabe56657e79a3c68448d3c56c259392e332a1fdda0fe59311007ed4d701e02c05619cece52a31e6a99b19ed4bbdfec35d448f5758586eb7d32744f0ec9361649cccf963b89bf951fd003ef3f46ddaa2d6696bde11b2bab85a45c4cb3c514fa85cbc069327b1c72b0eabb187e5aa398a0f02be4f6e1fe6f1fc99fcc874b6b24e9b96b42563b55de41571ee6f7693a18ee58246228bd3fcd25ec7cb8a05545427c38aa6ebbfcacf4f079c6cddc9ecae2d4aee60af542881fbca38d461243b04ebd17a919e19bdcc457fb596a52809735850c3f789e89bb947406cce1c3ffb09c6a43032f41ea62757fe331873564e35faa45b5f7884abdcd689658606cd775270ca70487e803c64fbf03981852c4d8d81c801ab3d069924cf589fa891e7fde8db60cfe9fb8ec1ca14f2e80b6c8640c4eb5b757a41b1a4a7d88ae02321b25f25630a17222e0b70f30a63af4b4ef3da9e8f8f8a95fbebfb570ce1c7b5ae8bfc621b5afc7c578472983a331b292e5f2e90917ff522ccd58b232db5b9dd62b123e47f1c9078593e054fee94afd65c7b57ff47e27b22aba16b83cbd47f114aa60cfd32ab827ef5f8c6f2f06389832bfe6948ea22a3d416b7c38796d8b57057792ed7093d0a9d6fb07419e30b64c67eaf39195c9a9c8fa6fd1a379c1b0337f8cae3288f1910f05366fd7f537b1866a26400f0748adaf83092e74afbf6c16c4e195d3f5ecd555b8a2248defc35d68bb58f7c64d00313b14f220f1279b8e2add1716c4ac88b8eff1f99ef173cb30cc05540afde675b699696e13e1cace79cb175f33d36e652c3c1b01d8b89108c3987d1580d1bb5619c5e0cbc1a3dd50df9b3f8bfb3595c549aa49a3cc3bb63cc16d9d9d5267461f9ac3c6c5f6a55fd462f72f80c3f5a62566641ceeb9c19ec21c1e59370979bde849df5db7c17e804947c95863d6a9f0ea748eb089d3cc37b8aa915aaef4e5122e5618ad0a2d0f11e31861b771353ea925cb56bb1981dc41fe1e53d9b8394bd8cbd3727eac11e9b202efe1b217690b540796b7f25dd6ce69ca7ee0934d7d552383c0e8c48f3911f8e52e2d5f485cf7b14e002a96c0f74c3e066cf9885c12ed8444d130f7d922e9458595470e7ff0f538c9b0259bd01ef70ed0b42c62149eb2a1ed3a477bd36f8375e55814daf3ef4b4da362190dcafbb936428d8002183e9dc4e58e852fad8214ef9c69cd31208bb4c5636e7dfd9c0231274466b852f14a0e6d8dc78ca9ca97cc25473c219ff155f305b739490a6064087d496c4c0cd28c0a383e7911f585c42595b999086abb320ec84978475737a9126f0f2bf7dfff57fd7e62570e5f286b396a733541079f861b86af18423b9d4017e8a3485ad306030440690e8fb1a12614ed4380a14cd3d18869b0e08635122d470222531ad17ae62bf125a9c738bafaeca96408f0648fcf651fb84276be2a590deaf9306cb34d588368d708f87d62b50c8087fa92a920ee971f99eb283948c5125b8103c7c635b4dc018238bfeec5edefe8a2e586cb8127f8b839f46c427e97d29a2a3c69800e16841d9beee936a3ad53340391c3beec2f3c3b94ebff34b5b0e4c5ba02fc16e9689439b761a6a308704f0b69122b014af3686980c54666282570fd7abfd1971fa0eb894ae461d49a952b48a650312baa5afc81928f85beb9a2a69d47129a702f01c11e5296d5f7f998760f175f29bf2c073381f3a653af3d2079569324d291b4ad5db21b26cdbb8f3d86a60488fa867ae9704055b6991ed9da9e7cd70251ca209e9a4498477e2149375315fe79f3ea03a86c128e3e9a6016eef3306f1f47b6a06de0f2f23029a83755d6d2c740bcb49a5cbc0fea93d4fea22f53ddcdfff5ae5871f24191acaae7ca6e4c45f7b67ea94f63da387074ed088799581a1aa504d5d8ecc900eeda9c3a4b55667e0ead6e2243ca3959e2b7ac0123b8471702a31778127b7575ee738014d38928f5361a50bb35a1327c01b5f0ae549842a55472bef26a637c6d98b4d8a41544cbb6c6e45d89954fa71dee9807dbbf9f77e817e9722e265ab52f460ced3dd13c8dbfcbe2b6bacc7798b01b132458657d73df9a8ce20e630842b0451bb59edc10e7d9456be21b4d122af5b5e33ad87817522ca0b6d54e51464787dfe27465f6acb3451a8e8d55bbdb1655ebff23a34f4741aa733f8bfadc0d34393dacd63a73b6567a602883343505b603b0e9d7da6d86f665613b92e020093e19f3e08ad4d9d6654db02523792c27e6d9c943bf7ded2cbb28998d5f60333befcfe693871fc9ae822332f860a6522cfe16251a8edb923546b6b2c2ec2efe3599763852a997f53f9a244c6e9d4be704413e9031fbde874fef91f7a64b9db343a94ee68563d7edfae09485a5f3fe7b6b513e60bc66fa9f7d3e5e1d02b0d09ae2ee7434bffebc0409c2fcf94ff8605349341c93cedc791ff6f773c17e363c0862ecce1c3ad4cd60a5388dd8583370fd54f17fdb48d7c74d1db7b61fb81991aa4c867877672705de194a7f7b75e18aee3051e2ca6a8e69f8fde5ea15627c5a9e92d8e4cb85f0c642732eee4e2aa8cba7bd869724d76626cfc26f8dc3c47d7a5155941151b64f0fd037be81e08fcbd9c4c1b4be360a4eed6a01baf9eb042cb9ca5a7830340ac61e04b816c9cee33402199f40686b7fd3b93f3abbaf6791b6a072d3d56ad55072ba0afad01afc6b03c393e78b23168c4d26393db73a86d691fc9e98244438a009a55f698d03d4860c9de61d070dbead8d5577d1541efad90914bce016d0bde8958b220ac99dfa274a1e3f6bb0a37b3d6f15c58ebe49514b293742a3b2ca313cdd3662aad271c521355ea054f7ed5132a835dc9a66b8d978a858395347d242dc27b65da16317c267fcf5da8c8316058b8afa8a0719c2a239832406415a3065f31e0e6496ba012566a45fe56adf8e1c95cd511783ef8466af1dd3b4fefc96f2f7425dbd896932e624f5a5510566f62ddf9b7d948d5404ca6758dd7ef1dcd3579b4b98c8e5c56ee8ac63524b04db6cfd5e63db37be5dff70b0014187e6618dc49389fca5a6ceb442ebf356f8ca36c528e0b2e6a249f56c2706654b1baae78dca03b3458dd6652f99776fcc898dae78d8e4d12f657bcc323c1bd7b0bbc0a371f847ee18f7b33b3324b65118b64c0e00dba031e015772f7ed9b66fe7015cd617e4c564ffd704f4adc7e755d9099c63c6d3b7f80cd7387293557ba9404ae3195a434f6b085b813b7588cae47b4b3d7d3ca09102565b3a490ae2129631b713f1598778eb0510bc0a9f861ec1c2a8d973e6e1a8d2338c52163f2b14ad050c4be477730344a256b5077a5824cd5135d632bbd00d4b5d6a759fe0f02ee5127af327a8722ad1c675a4da901bc0b7dfdc0a0c61a8f673b55983e7caff743de0efc69da1b94da6be180ba1f43dab0f2cbd54d5d3198b109a13547023485025ea42d90cacc26fec04c0a20225c690815ad6bbfc253b9b500fa214e8f8fd18bcd4e1db6e2d9547d2eb1e3553916b444cbef43a95c56d9138e08dda463a5456a632a84542e8836a57b622b8cb142ad4e1015872d6d24dcfe9724c1a9267fee3991f652b45b35f068e3a8e3e63a86a7b669d6a382d7b3ae07022bd5ec10a9a3dac2de5b52a2e1633939cc54625d1c912b731cbda355628b40fafb59011bf3051c10a74c3b11ae44930af584cc2c78e147efb1ef3abd359cada83a6071425f17e111cdcaafb62a065fdb1a3c9cb125c3accff857e81f4c8511e044e6e215d721e4dcb42e2364294f3123c522ea6d1242de9ff24bd924b059cb2fdfcfa5cdb386af62d4490954ccd15b9eac99ef9f81711224f9c4de374f5e29ad3cede7539f1bb0ab3569650423c85f677bdec9907864bbfde85971e346e9709ced4a15c80898b77e4f80a521c4ca2cb0d57d8e278b194b6a1550d5bdd00ccd4e23a3672d699bd0d087ea5f7b3cfbaabd5d5d32f07815191c24d867946f9d4d37e00e78b84478591d515aa5ad2193fb5302e0406c642595340a00669ca6772e8acf9ba6caa771f10291266b13fbab832b9f371c3fc1c08337e9b98e1cee6b5fbc8c467dde3773eaf8c0c08b224b2fe803ed9f167c22f81e241133e25c3c77147b68391589f90dac9576d3c4c82610ac639f8dce153eacea1e18514bb1612e04dd7d4fdcd1dfe7b1dff187480709ee5dae29ff3a4114ace9fd26ffc152cd5241d06bebb4a3aac12ac09ad64be8bdf0e7114920f25c69f916ed2f2a7826f806f2aa1368db7b5757917c50cb23df365c546b51071719935947806a0536582d558557481b4e30489a8160afd44066a71a1bcdf3f43dfa99ffe8e58a5584fe8fe70ebdfce38cdc2f1fe9a0e67cff81b41607d478f705888b81a99e37fdcf174e9ee93f7d2fff273df92bace30379dd5ab7d8c20860d37b54fd6743da31efbdc9fd381846bd3c0c3034c6d4e4938e120a1862efc3d9ce11c4b290bafdc64f6b70a12e651db7db76a3496f6b5552aaaa903920b9205bab38dbd218aeda7099371208a6ca91a2599e3094faa1fb7773f9ffa2ba3f1c0c3dae97fcd219d947d9a3ce17753d0d49c914587768b1337f29254a2c892d96bdf4e9e2054916491574b525ab2261c7a5da4b9105968ff358d276d516b94ff1cb6f24fcf0d9add9f3f17d76c95ba98227f4ffe647c8f8ef3301ba58cc9b3e26b9f1d081e783be297489751b9b2c42a5b7286f61ddcc80310bffa51bdd4a5111e962297ea54d3cd7e6559f70ad0af2947caf08842c43310d226ea25aec2e862f91fcfaa17cfb2b1a058efc33d37afb918bb123ba5ce7788b5ed511c26873f931addaa45f8cf49517ffb675667d513b4447920325b86f4dd8ffd133b41a3e4353db1da5be0be6a4706d01fe78d5def4105863ec3163828975682d1d0337f7fc9b718ba2057ab9c4f10a3fd93c04190ca3a0f0dc82185319c28db781370dc9dc9de800edb88b179f344a992f83dc7c179a72f3864fa88b6d6e2be7a7d8c8a6556394f7bb438465f111270a8e80f96ba8566af81164d761e7fb5f6736623334894d28a179c02375cf1409bfd77ceb6389755de4ba6a001d651dda1559e9b27ff2b99ec59e8406de7890f0a50fc5529069fc7bacaad434f5b722af7cd96dc2bc11a4ab7cb79bfbfc4be95e88cbf04ca658a20ec325aaf9b4542709c1f6116cb6d1791d7758d424dff52faed60721c718acd01de163fcf9f569d79d305f92fe85c7dcb68b07489c6e93e3c87cf3cd6b4d968bcc6f0b03692521b26d26058e302a2ec5bcabbba3ac4b8551f3c294ad872121ee1b6faf9cd66ad27162bc1f8d4b1199c9384dd3077de390c0dfaeba84093c3628c3991d5dc24c5bd828f95dac6a3167c8e960b91ef4c9eea61754a91aeec26a979cd9de9e42e9c7ae7925fa6257f1d12b3bfdfc72ae978b98bacd548b13745a5724cff26c65fc62315325cfdb4d49745992748f4bca43817bf9a061207f61b5dd11deec6750a67c7986e51550dde4b355d2c0ab1ec1a0c056b31e851c7afd074bb4020ea32f9d755ab1c95be8725d54ca296ae7f4b266f7c830bc037ea4bfacc1de71ce2cfdb95d7a3ab04e3438680c191f1d131a4f4cb676f4d8b14ca944d483e7da56f29f37581f5a3e8a79dfd7383dcb3f262b3df44e1720eb0848bcaec75ee32fa5de0afc9beaf98b36f9a22476279a1b68276c550b94e4dd90f38e55f295682eeb23911bb789a573e95ccdbf7fb0c1eea49d8193f0a30a4a1b349078973cb1c464fd5b852528ade5dd3b60729ff0fb21449c892d8c22b60d64c9217f8461c4da00119a7c2aa6dd7d4c3cb003952e46c474199e3b743c6ed9c47e0f321da7a28a78b3ec2c8374bfefa2fc50b3e2c920af8d099996f03cbfdf43a8ffcdd9d699fe1a6e86ff37d254f1284e47db30ee96abb5ee8a2b2bcedb01d8d22b408fd749bb0cce37030fe6bf10990a184e92150e627e3e5d716e4d32847cedadf6d33ccf0af6252787352762cc0d72a5031891a138b89a9a9ca3718bdd52d199e4ca516281492179825e6c7250159d5f1b0855a063a2176a02b46831c60cbce019c62c48e69a133c31f62feb2c6766806f1418f1737d08b94ca0f0d9899d8665a2bb5f5c1706774bedc5f5010919fbfc331fa70ee1606ee5f8d903cdbc1eee8c3e39fdd3ec7541eb432d1f1437a7cc24a6474d70229c805e38b2d969daef4dd0a759c453ce6fd9a8154af7d2191b4b3da06fc8db379f937d52f03cba6039003e0d89baa41bdcdee5ea58e00add70f6a6423541b7bda64f828282b44002fe51bb155d588eea5ece80eeba1c8f8f6dc5a1ec8a56d7cf8793b3e33ddbd8a83b87e0cb555bed79596be0f229c957722eee8e5ccda42700543fa2bc92235cd73893813e9b77f0de8fdac6e03474ed54762589fea635e8236334bcebda0ec653608056bee9328ae47b68678b46c061ef0eadfb2631cfd82a52d02cbe615537203005a2c81f0cf043b992e1a5842f168fafa825b384f4ed7b01b844ea9901772c832cede1c0e9377e338db65949e67eab7d4382aee1df412ecd0af44f5b6d7c00e67c60ca37f5424388807e78a9be90772b33b4a41b18935d25e29cdf00437c28e06f060ae4c1263e30640dd00a3d217390340fcaed4a5b86a87b47f8f004d1bfd977d1d23f475070743c17157e4fc58aab32dd6791a1f1277d66ff0eaf1e024ae4d3647c2a9c5ef2a39b95ec2623f851e740a92bec7c7cbc36638153fb344eae19c67260610040616cb1f6fcfd9fd971dbf659e48ae1906ac8ad04cd8b76ca737ce9ded43c563a978930f325cfa7a42f64fdd33bafbc48caa115b4ec8975a6b96d89a149e2ead3ec9911c9c275b62ea25cea8fd1db106f33b338f92d1ae5232b836e17a3757b8889e3739d97fc868d17d0e71ca90bf79548f47bb1110cbfd10bdd86c767c47adec0456f006cb3532293f031829b19d9489e352bf9cdac2bfdc186069cdf6ca7ae5f6b2f34db53faa76ae56bc167a53049c292293e2872c13ecb9a4e8b716cae14c763f646d3622a678844e5a9ea749713112fdff1653f5b953cdbbc139e735a54111cbdcd02284cee2c4cc1e05f466d3a74261dbeefe6b01570291adf1eab20c93a14bdd0793c8e1b0ce78adb377eaefd1502755bd9971330408ba5449353ced0807a37b3fbb43d75d1a71861b03031b0989198825fd2c37b7044e68064a2c035d67d3c8f4078db6f1b4a34bab897167580b0958716b80a1fa8c0f360edced7a3876e79c9f43682f7789c445af85b814a0dfea198349c1e31f37f105c2ca7cfce297600430c75b0c5ae2b844d988e1319d5f58bd81bf6ac50fb6e54e1434b6b4039e091267bea19688ac9d7026e1d8054db26cec6336ada623bbe5a36eb28d1a53bda35a766d657e0c775480b5cfc7161f47b9cad53e5b4f3c073173ef163e6dbd54c40078e169298cb5249cd294411496a7686dcfc74d84f1bf3ca2caa21823b01c39d90b788d692c0badcdf368090777ef48fb84f388ef8730a79c458d623e8826b41855b6ff195c74b2660dfdc0f845f2ab101bdc939997732321f50fc19a3ace93ef8098039b212281070884148e4c812fa0ee2c46924514420e3333e64e39ccbecbd05189fa9a2ad0bd6746640f9490bcaf9c78dc1a5cbcb7c6a42a13ff0adb4bfc6e8426224bf6dab0ee83ce0566b84493dc2cc5f07b6c2dd340adc32ea2ed987f48b1e24059fe949664cd7fc50c928ffefce58c750e1a69811b331f6293c0b9c964bfb8b5b0fe07cf6b8371b4be455baf92db22093025927bcba06401bffb3535dbd31f6720014283386eb72546e57ebc6a978568eb462eae1ce06d58bdd4a715ebf458a96cd4b7b265a1a5a20be1b7fe69ba0ee4b162865459b0291fc5fbf25166200ae7e804d262527fb28c217aba3282fa86036219922c507fc0342fd75c300b23ef4ac5ea32cf7ff945034fd0d06aa4d85a762a0fdfc5e33b8da05d2b3cf8226eea07847d02eb6b74f2c28e3aa75f1455898cbfc55f05ecc19bf79837c6855998481cbfb05c02c9c469ba387fc096e040d5dbd56e07cf8c61ee17a56298216914404be4e61c601080645410bf89035e63673fb0241aca6e858164082b8d376a55b73951502670f8411d52a316a3316170c2089b1e5da00c179f8a539391c3d6ac61ff2392f960baa9bcf3e81e6e29c57ae16edbdebe7eb4c83cdd1506fd39eeca013abfb0c3274e0409f02040ad7db154900ce0c4356895029dacef7376f63caa3edb6f844be27d90d65795665b1bb49dcd908435e2424b5c395cdb4f8941d3921c84d324afe5aeb886e0ce3bbbab2c066d5a7501b0e31f24ce5ebf6657511e2bfb33cfb2719d0e7bd350de71516228e782cfa21bc8ab1810a9f913364b6b51e57e3cbd7f0e101073a4e3d110e95d37ce1bd0f1433d93116d179fb9db577c0a0cf092fcb6bb812df50c7c293eec831b54209af92b8a67b703f2735c30198df261ab15d1e6ed93516be77d27f965db496d101c5fde933d98ce1e8692eff286159388ca0748684efd6b4672395b4277549eb5b0e50e8c45bc2337adf3d4e1f1e36bd2861f3987092c74d1846f55be8cc5ed824c451cc59e50ac438c0048dfc2a562ce4516335972b668417ac76040b145771061df5eef4e833e56ec61aac730e660cd5aa559205d1307081c90b89b6cc6d507ab1f4260a9bfeefecf3ee092e972b5273744d5bc171507edd02be37e99178066428952643f42df9a7ce11bff24d5ac579d9468b33d917e6b7944a32616771368adbcfc78a5716ba379bfddf5e754835fda6053b8ba9658d2321f9350057a6602cfefe7706f7901167384ebe3a8d8acf42a9e1cbb86b68389fc8eff5088f5c4dbb9036d3835bf265e70ab4a056d05fcac05f6d4221835d9b5a06f041859c322bd5036cf488e8ec072756a32342392ddedde3c2f32b1ef372563a332c416f197207ec6d395e58f17bcc7409eef158974b490ee7eec818de0e9a45946f2e8c292fbda0abd0244d36976e77dd565cd16d10664373e51886290f68ed3eda2d5b22fdca708d21d3e5fbf2491df1ba88bf3eb5380ac9d8b401f3e0ff392a68d7257c5965bc9e70fdb82b44077d4af4cd0044648f7ce1678e6d3251dab61ab7c93947fa9b41e9831631a7abc553178ed4a97ea9fee0f6b1bd410b26f0a7ce8ca151041de12127f8e5ee3a3b1ef93980f1c0092316df50956edd65a1a7afb9cf4b816972fe069b32eb68610963db356180e796cef361558181a9309a924dfe331efed546a737ccfb1b5af4dfb5066b34bde3e44a246069cc7111f95693e2f7e4f43b0028588be9b03a2f2540fceabb4f2203711c6bf1ad68d403fc23d98d23c2f66303a218d3c167872d4c71cf2870941decf7ab98a095973c7e9cf9ffa9e104069e31a30b6d1b99317a4d26a3697152d2e8067c11d8c1d11afa7f71a84e7e97ff33f869a6186090127d21a56209c16118e5c9f91cb9726b700ec2f74052c4ced2997d7f21278479b630be2db98a396320141f5e80c15e3449f4e4e26d7e0d34309271b2945feff6394ca28501f2073d30a6ca1b715b2e15454d8567677333aa9087d2d6ef22b37759513ea9e7e5daa33b9c6a56964051caa8f374d52f3caad01d45543d2be83231fb4ca29e2c2642456c506a233e7dcde028675a58797ad6892c2d180cc2a7c761a1ee7eec87b4448800647904aeebc4b6b14454dcbe665533bdd44ab74ec96de9248fe8373f47e09621f9749de6545b7b6cef11fe0d97fb6f4284f208e578eb732b9ef70dd518484038ddb7adde1f107496523b5af553816a6d4bec442a6011460ea5eab2d8c65bc5129a4ac7f8c3e4b7f251245e59edcb6b8d683027bc147d1793afc9cbcf09f0561915b152dda9788510cb824d8a1f1432e0eca216696f801e39e697a35ab5614007a8f90a5e396d60fd9589bba7312615462d97167f155b689367e2dce8f7009d9a91eb76696681ad4f4a9adca121886e618e0368d684fa0b59b6752037edc477dd51825af495d46b083bb7cdaa3bb286662b7a2420e7d4725b904bbb5a4237b31a4e0a2a5f1633750c5efe84d44457cf4c5738c546f6bdeb5b4469f0796087502e1a0c60439958211825e3647c593ec629a8468978dda351544ae6afcb0edde9cbec08a835bf76ffe280b86dd2eb17937214e8967a1ce08c2040aa9e16a757115a83c0323da47f6f70f80942ff8d9e9154fcce18103c77eecd5c7aeb5772129141b9466459b472c475bdca02335df7fadd978284ca3fac1480632600e188cdf443be0eecaaca371d4ffc612d3b0e8a957cd790114a3dedf5d43da344f878d471ea18a8e8e995c30451af83fa15ac926012f029faa4a312777b384269dbacbade3524e05f932780bd4c80be8815a5f12987bf0c5e8b228766411b89963053d7ca44ac81a01f11096bd0699e827c0f7811b8968449a6d919cfee0dc5bfa2edcaae1cd33bd7d6269bd301d3851df0e2663c24239206b56a10e5f65f4f466438738af7b8833e8ac00c8d43199bc1a88dcc10641780695d311f6a30a42d0328b6da1988fd9e8fb79d0334bf922f4954cb943a444e64131cd4df62e018de80bd9f2741d8afa3ce8f744f2a868bea7995df31a08069cda846b6c151fceb0fce1b1150c2e5330c00ac92d388c2f86828b44cf142e797a10ffeb575af25dc18bd0ca4c431051d58cb5b948b51c91c01c00891138bb72a55e46ec1d5bbd4699710f7c20e9667858a999fc435dc58e10034fd0b31aa3e0591f51c0e2182fbbbf44454b814bb31995c88f404f36312a53d2e42e2cb37cd616a5e6330852c00e602c2b73b5152c0127a2c50bb251f84c8c6f35a56b152c5a9d3ce0b2cdc39483769ab64251b625065439d526f8782981277ec36b7356e46bf9b4f07e314824f71240dc04e6c22f4bc260688e97615c7113b8022f5dc13f1fdf14ab5a59cadc484028142dd842fcafcba983d1b60a609680dba2f099779e3bc7fd8d3d3e8c25c2653d2c86ee3ec5a68473c54fdd7f9ea209c0efc9b0e6e953ff8e73b546ee88ae9eda44bdd3e3c68843537664c68054ab3af60d85187e15966c49d514a438a9a281b79428287a539d692426745c4c6e18a6158b7dd06be82d440df4fc631845a873c7045fff046cd24c5fa53e6aaec5d905e36adc0a9e63cc4209d654606e6a74779bfeb5b8c72cba9c137ad9cd32f40cb17bfdd80f97401f97d51a4caab6f4b14cf0ec89276888cc02a8157180f2ecb72485ae826149d420330d4399091fdc5d51c8151746ea1658c3df8b0f3d21bf10fdbf02e98ba8e30470b6542fbdc10867121222ebf4449b2e0a5279b86adf4ab239b5acbdfb775d51d0b443ea757ce6b5c957bc8d54a6188e43670484416c47a909ab6ae7b2bf14cffb16469c914db25fef1755b28cbaf6b5efd70aba86098488aae0c50ffb3fd4ab6e9cb22e309398dfbefafade327c54c8943a5e4e58f8063a20faf736751a0ea0d0862c61664acedc385068279ffb1be811c9e6e1da1b97b527ecb5d740e23378bf6491b8d7a597d38daee8ab2bc78438407fe997d26354d4fda9a15d649baf28f8f173c5bb258ad773919ac58aecb050edcbe851be1d16a4d08a637b3fc617233047deecde15407c3481ce32b07afc675f702bc417d56dc1ba0a786e8181a7e75796b75fa0874c98f23b6fb61516957b44d468ad8292b66a563b54557e0cc340108f370913466184ea884c2f5e836c8ed8cb67096e82f239d85f30607233390364e86ed49007e6aa3317d5f37ed3495f5e9a39d3f53224b72b35c2a6c415cc0c6739df0a9c045bc6853f95a56cd44f0a67291a73a4f0f91541795b1ba00100fe897ac3bea883cc8a1f81a6e271754c9e0e88af611bc8409fbdc329c4edbd87790a12e93dc2a23a2e55ebf2a8d74514ba3b81c73bd2f2c3670db5db282d408b1f7519f21cea4b64d5fd49fe91867a35d63c01cd827b9e0466397482a686d5c6cae5f458ff63887471d0622785e333869576c1eaaa844cfbb8a95fbd3909c333a38680bd1216f4dfea753bfc6c686ba2a4815e5f79a5cced6468ae80fbea9aed0ecbda207755835f1c6ae3a67c18","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
