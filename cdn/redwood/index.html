<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e67d62e60941e549a721e86c13cb774f58bb13268cce9f66a9571864a4c8693b788752144057f5b1046c518978fc606b5abf483ed046fef66d59fadadf490c5fcdcdb987f7cd0a87391c45683ab7832a23b01b64de9c295d0cbaf486b366a55b27b90e7923fc9b25a641dccbac20b454f94e46ee5162a5620858b1dfe499b5c80562ee6e5b4ecd0c6fe3f96ce7d4644222c10fa87c42b93bf91868c9a02958c399c553c9faa5801492bbb099778255a7fc1e3178e0a2c68050b9c3b01a831280dcc8b6292d27a9d6b4137439c63aace01235887a629ab6734f4d2b82c05ca78c1cbda8c941dbbca7b27e2362267deef0c4a6b96ae6460adfdb365607ee3463e8a198f9548684b351c0549b93f8309dd5622e83024ae5dc7843dd3ef5a3c3b0d295d0af710ffdfe869e8b19db5b4ee8d5a65d07dedab450798a1595d4a351a2897b0aca2fca1c3db863db5652712f47af457650d326ed690dfec56bffc0e1ba74fd0858d117fa49a94c652812d81bd5f8af193c72baa259b8806c9db7ab8c961f73a34c5ff7431471209f3c61917cb466529c601b4d38fe521317ade8106bd25903016700281f7cc5e800ddb009ca54a6092e57f6cf153b07d4e6135af369096b824eb0b95e7ead0a0bf89fc825332079e6a18a1d629d92b55b2fe369691daba776ade859201df30ad6a26ddc70d297c2e493c2cd51ed800b7ff74f135e964bc06c0a6cf7a12872ef2a52915fec0c2b9c975ffd557ae7a3a5e695307059a5cbd5941bbb01758bfbb3d44246f625c2380f2719fbd52510ad2436dfab3ebfaf68323b725b909617a85359e7a346a544368049dbb36f5d92da28bde7416d31332662437125afa8a7b757e5e7f9f8025fd57fbf950b0c84750866f6c19c0b9962e1f72ea612df8711ad8993380814fd49a9d404841569c256fe78c9f679484bcc610de6c2b9244fd7c31c00e7c2d5251dd6d2c21f46bca4cefc54e326550997474a8e10b2bd71e809f713b87fc824bbc0ddf8a53754fd6660f739624fa6e1a0b247b7d5c308eab0c89c71810c31e3ecb613009ec01d6b5a30977567780a3639b921d55a9c06308c3c43066510808062119907110bf3bac5619c814bf3de326f402629d9162a09a84c4b321577a29c7fd1c608853ce6d133a1fd9b0f227c6692e60686f3e57501240dcc3c26b246a6059d3f9a1529792c8ba4ed7f69143731042844134c54eed951c03649a3e8e1381740ac46b88cdacfa67c5bed02cb4fae3918175db073a79c3e05528936404ad9f9869f44f0de711b2f66bd7ee2c511faa3732b78ed70eb3bcb98aad922f75ced86dcc6b212e3c816e87cfcad12fa94dc5b272636d4ed79f8f10dfe4869131dc05edd5708a2fda40ef3fc391c81215cec4a25fa536c5ba070a6bb1f812e5e52c677fb1ed5caffdc783b661f9db50392ae9d7609f8d17e52ff85eb9471d3b77f1163e7ec6328978945b8839d1eb99def26481eff6b1e1189ff469c8df68db4a9b845b94368e16155924d689eb5a26fdf8577c46bac1fafacf3bb3f52cdd34336f43d6773680dceaa0a36527b9de6ab1c07a5b5df30decf5b0993eaf18a67c42db8bd9b8c41acc43f6ed286c73b95b09ef592ce23d431278c6bd0c1dcb10caf92cfdc2a0da74d27cad6245a610628eac88cb3df9635ca264946e0ed27bc154ad89cce06ae5cc0d25fb55b04bc07c707db66560815a9867017f9ab49d630f43ed5b7a2d7d3509bf54f80545bf945da1c9a72a5f2a6e93b75492d3642c90fa9ae7309ebb787f0883d1578ee8fdc74e8869842bdc12039b3a926c170c33058cbe83e4caa65338cd692215e145cd8aa39288db35ba61a88b1dd39d739a71b78f40e07a3984711e43535171aaf61c4ff28b5e2088a18b632bb24748442837d3bd8de29f613fcd5246f88226dd7e2076fccb1d504b371fb62d39ea2a1f2d7007a74e389ee0b0d30fa4868ffce2e1c761fb70074c90df5fc1c4e3a0d4709a50a3fdd66b4f8ee10a414ac0a40a9389006c500e3d7a1a6adea676ca96d7b617bcfcdfa67242b2b58e14416ea8c7d9a6f76dbfe032bf6e0a00b68e94071be13786e0be590a07f956d13842d40798fa364e6860aa637d8c781a2998c2a5cd511bee73b63f37bf0e5fa16612280e75dadd14b3960c09044696122432f4f1925f76103b959eac5650f3a7353591738b4270e1b42c561e5e59eec38a65f0d3a5730377ed5e0fa3190d77a7ce9458c73b1e901664e8bfbe0a2846ffdf1f81021a4dc1769c8d887a9ccc2cb3f4f19f8f18bc47b0a18be3b18dcd6bff5ca55844435a610ee75a20253f2a8df766cfc3f68bb9b6866f662f4cb0457ff2a2a55bb23454e076b35ad05d426e130cf771684d8347ab0adc644509a64880a1efc5f0c00bcc6aefdd3fd9851ab2eb1ceb0f3a050caf72002df0ae728708634880e7e3bbf1d4c382532d697e907ae0949e979025043ee52525c57de0de74de7267c2df75a81a46596c5e0a67f5b5a37bb830c36b15204c3e9853a9c3ac72f085c66eb9dd5451c8bb99d1fc85504057a7371ba8e033b4eec11427f753ede5baf591ad49426404feeb6114031d2028378b0636113c06138be995d87570ada2d33c10d2abfb34cd61f377c1c721d415fc40793c63fda5bbf936e064f972d9f285768b59799a8198418bbedcb70926fe51473f098f1172ab2d3ff77a248db02f3d17bd8af93be8358a0b4a1fe9a8d4dc6a1e89503003c4d06102bcb5a420cf830100121eda0540bb724e7d27266edfc35c0577555034c76037b773847dbf022fbb46a8b53896aa7c9ab6a6edc66703fbd6caced533f42ed8734409134b35dd3d8cf0f616487dd635e4520b97d2bbc891aaeb388178eb92aaca04eecf03ca75ef596a68492e457a893b8c55f8d50f2ce468a9f726c130a58e25b4fe71cecd557529a1ddeb8d6594fdad1bbd56deb5f4647857fcfcfa49f1214f99e938d8632c394d96d3650189bfce2b4c627716dd67389a525f2d1dbef9242f6da521ef206cfbbb3913bafdd67a8c426258d119514f2064089ec67c55a7f8f26c3b9199f5da11a2af85bdf4bbba943d7e48836b0c25e877a5c7d39d5a51d81e0afa4dce1d2cfcdafd24f2555d2d2ea5f955fb53292ae1d467932d054293e2061ae9655f36f356eaf10d6bdb99b77cc421bbab29c6d8fb73b675bcc08c43105951b423e611aed010ef6d405b41274acb1afa6e3e24e96f9e7dc61b7969e4a82eac3be6a9ab59cc140cfc9915bddb9387af710b8535d22e80157e7543ddde6705e685f0ff50e75b8db6c6751942f29ab5aaffb03dae2c1d677a323df4bbcad455b4673c28937daf180c95eb6cbbe642e7240e7bd92a46606d8329422a7602e51fae7e23ab54e1cde500d99ce3f62f142ab542f6863e28fd8617a2e232c99effec68cfb5d8eff74cc4fa5ab3e553c9afaca99f4dcc1d06abd5ca257d01c0b909ce746a84ee9eba7e191b20fb6ec282a8f50e55a8ac0bbe5eb0fbe42b6b90fe49001acfc477846f9be1f0a2327c0dc369c8e0d6381ec1941df59a8b3f274fdb0f8116e2491cf828efc884a46929a439b7656b309493265925c47cbc87495963ff5a81e3f762d7521e324bf4a6954bee688d6f0d35c75bc0e9735f87f636a92ec3a5a65457f9f415e585d909ed7fcbb30a1e301224155aaf5c958d036737758ca71b1e4e20e319c019648e48969974dd7d61262266dcecf0cf5bfd6ac903d0503c5c23f85b8dad4d24de0a565aa334c0183d6c5e54608aa7505e50ec9ba1774710b4097121f05ee73459f96733d656cee9a65c3a26d926954f8978af9bd2115c58de88b44de913a4460143bd39d6d4d450d1f9e616ed6a3171b4944a39ff5df6c48f4e02d04ffc27e4bbc0b5c03a2c6476ff8e31b34b7a8b77ff317d6bddfc6814357353589433ce9877285b16b58f0bf2db30d2a3af29ef127983b34572ebae6fc5e2480949d7f7ddbf4e37e05e261b44ca3a0961d1b1db8c4048526d0de9ca21e8d27a85f7c9d1d156ad25476ca4ff10de1be5446b887b03ab6db58d323c57fdaa08fbcc86fd6bf021f10be47740508a30f3442c89b3fccbd3f70d376e15ba0d0087c3a33d177b913446ada6ae851c98be31dd17b14199a159e54c6b63b386f330e4ae0c438fe137ec1205c2735e8a86669f215a19039a104ed637563a165e0716c75792f154df572c6e09be1b1ee7fd0c1b2884a6c894de19af7f0aa08b9c15bb99517d980e5a977ac639d3fb03e85c30e3a09f10f238159ef4763c7e9277ca1d7a747b00601884716bd4954d2980bb7a70896ecc43f6a0b42aa2330ae54f600aeb87f42edf465ce84bb404e9d89baf19b61dc0bd9042f7b39aba90d9bed41e50623c980bf83ec7b35fcae4f614ce53e4dfecefc0f484a360297078f3c100f36fbb0d02f67cfbb17710c1647155cad362bfe5aa62a53a66e395b10f4052e344179a394ce39b1e571ab117c668653d1c9404af96ebb1281414184210bc4f64f54a975ea70465708195fdbab2038d46010b1705b128f9bad6873ed2b6ac1b624df28620594c223f4f4802a92c3e17c95c11f02005e9dcefbf67e80c80e5bc239f5ef9a3ef80e90c052f10ccf7151f2328e99c39d7fef9f31f53b79a20e275e7faeb9b94c20c2c372aaa1e66a41e89a3ab786d2479704f75435198a76149b8f9c85147274456fb1dfb9d2af1e5a0a72154bd808c9553c0ba5bf4a975e9240c71ac4a31a3a57ab27a60db460031ef603794519bb73dcb5c1ce4933e513d7741e8d468f346dde468cd429cfae16f1816f9323f5cac361d9f3a5c25eefef2e1de57848a13bded2aeafbcfed35e715876fe7022ee89af98193c19b6f4e44fd6ecf08affa964189ff39aaedde4f80a17dea7222818804e6a0d89fe4781458009bfe62ea0ef8e5d0f5130cd29795643d7a14749c334545783d9d1ba873fbf6be17f92760e17315d81b23c33b1cf25fd5b79f0e62304dd78d3241a0cd7d8469abda9b85672c5d52b8d8542342f959991f5b5b9f9e2a557021f88db27224ea95dfcb255e350945ee9d6dd8df73245971b723a37c25eec528895d845e23698df5e4cc1dc59e9e117702c0f312bc3f8603e38aef3d0aaca96b1e824320550a5ff30fce835db950cd5a13e99cdec72685d4d9acb2306a073c0cf5d143af4ba3fdecd09e3f78d001cfe06809c8d12a365c6a546f358050eff4576a1b6557f3eb635ccc0bfcb1194e92d543530ce64def8fa6e76d4ce201fa14b8becef041d819bfa3deef811ccef769b3723fc5a3dbd520a80fc7b4edcb3fdc83b2d7a132667d0278fdf5fa950413c515c381a55fbaca28a1c85357c0399547109b3ea2db1307f318ee964d1080782e106efc1715bed43dbb847a6777756732d0fb01cef072cd5449caaa685989b0463476b2f850d5a96218e86337b2135bb5e5988247dc5f733643deb1a0eadd751b0b0e2fbb33be855a10e3409c16d005f35613235d6efd7470c3609b0c012aa20dbcde4e6955df48b043587f6a3c4fe65099a7877e22437f7fd094e45e3b3af25c323ec07300906417562ab1fe1bfea013cca2e52bb20526dd15b66d3a5efa631d6619d472b5585210566e0fa518804f925b7cb0384e71cf02a92a58303d0582e6b0885e43a300272919ec5e2f1c31210ec26b51172d03275f0d704a79100abc5946473206a4ae1298876b45c28e17d9c505fb521068785275f6d7dcef85139e6438f36e292c69c8c50f2f1979237e69b5c2f17e1ba0a412643e0a0034a6bf818f7aebac455d06fb0d21251c8ea8a96af78397a8503c391e0abdb13858d038b78f52402db8d9cf24059c4f8e2afcc169bcef74623653feda3a6d9341dbc24754592b0b405b0fec19e06ceaf13893618f8adcf24d46d62dc7d6e0c0398cd0bfaa8976a06fe66f0a982c0ccfc233b1f6f19eaef6a38fc1e01e34f8456944436134fe3e8cdab0fbdfa2496cedbebf1048b924472ac94b477fcbefa44452120c99d377ad6af7c1408e4b8c61f920de9555b071875c11aa964e1ef02167f07997a9865253679556a5a7745cfe08b04cc8073cdecf78382add551a8bac23f3ff7cd4798bcec0711797684969f06495acacc9217a5bb716c41ae3b893d1b4da4fbc877620520c3f1939afbca45f3dbc0e4bab58bdb4f551cf2f3897dddfb0afa20233c2069ac8335d0d32946e13118276ef9d9454e627893284e5f80025c2e3fe673007d684e24d7f2eb1cbe3cde8759f380db9a5da62a1a444948042bffdafe3d371cb65c6c5ba42a90c7ab7eec182030b896b9aab3108f18681834d9acb1a0b8c5dc602d5a091550c294e530279360b03bac2260128a0832262e75c98d3a68eee62d2e66b7984c72b2ff07db67e39d2e2bc9b9ff4d06eb1daaf654fcf20be2dbd6c965f38ad0ef43132d21c38ed9581a9cea24e4cc22cacc4377a9ba27619963b566f133ffc8b12ad2c83aeed633786fad62f6813dffec96897a790e38a8a1c1b91738f4a1b61fbd36e8669712f537a3168bd8fdc64cbb0166068065b6eac4a6d446b233415b74fd755f3e413fe530ced2a599e339231dca89a0a2ae323ae4f16913003ac36b7a080bb485644eedccbb33d131ac3a7291ac2264dd06d82b8168027afcd3574dbe7234524f7602ab7b4fee2027fa8b6b8b230698582eca6bdd2c5f82a52a4137fba0a47503719dfc6c0220e6bffaed85fafcc8c3b72633ed88f18497573dc436503e21cec9635db63a26664bf5dc7f111d13a9be56db46e8f686f13edb4d0624f441b910f46d212e0a700a455854a89e1bac04ca4cd92e33f0c67cd2492f9d6a1d9a9b29dff753f081fcece6959f7e20c5a5245af03dbb508cc0a916851f572dd90f62bf75335acb3495f1f4d743c41b137f57d17ea9cc4a635f453286322d0c3653daa475e9cfc41a6514ad2741f9985ff695aba945d0a22199b9ac0d3a9032d40d2dbd2a626d47d6386923f660c55de0e6c9fefbe4a864ab4d7dfff492cddf494503875fe8cf79957fa35a615c90a6528ed650dd364b365f3a132591eebfb7b6fd17415a4029c918f2c5c8b11a7e2c4632effe10e13c51e99db0916c7abf6f1a9bf4188d6c574a16c0fa17580d15ae554ac8c8e2f1795a7b913d1951f102c7b32bec0719cb81d00d94184fe2ea952e8a4334ede09b1ca1963339d86ee49638d90464affce8562279d9515593b7ccb723d627959f8e236e9caadb630941c7bf8597007165002d93114a57a5764f43cce9e5e7bed1d3f67bc2cd4a0738b09f6d903161377c47d46df598e22aa4530e103fd28688e26b86aa9e87f914ce4954fa73cae50ef6fbfe49569d2f91c90902febf92cdad1e3326c57f4ca9699a7a9d7dbdbf644c250953c81e7c7c469b646c995753420072af277119b1383425d9ffa69dc8ce2b5d8ec4a2c6042790b589e624bc06f2372dac1bb5c616c01cae0833ae6d98522ab326f2bdacae6fb898c0f5285dc9fce630a325f83e7678bc8181f3f106fab90afc142c959f656221f9aa5f59478fe5b658ff993369fe1e7726dc03ac1bb793f5400413701cd569ecab7f35d7fb4202becfd2e893882fe7b7bdabfa228c3b829fed4c68884da12c2cb4dbd36991615ff7a00a2066aec8bf8326a5f2bf925e9739c78187b46fd9023e82cb52af8433d866ec5f94f22b7645a77b03ded979d62de3f605299f2d85e386c6978642715855569778ccf052902156ca65112d73fbdd2e938ba2e52f5cfb093526b378a02d095b4f55f7d326264a847e42c75d123393fe89b602e8b532d85c5626535f7003c4a15a1e0216dd815defdf1cb6e9b9bc53a76f24b647ff3e0ef17a0c35d5f604681efcca68dae6dc1a2fafd8e0ed23ed0fecc47f3e4b753a12e0176938f7eae875ac7c805f908e865064f5b947fb781668533ba2d718e615fe9fe6834f7c099ee28637150056e0717a407b8fd40823cf99ebb90920c3ca70db896f8df2f2542a087ff816b0fd8e1379fcb97b2bd48803649eb6ca18a640791aa04dbbb84d30fe5c77eb332a2a27a53198e114fa044c234873ee30004808d048fcff7361df9858610caffac9ae90f7b2cc841c6a506b4699caf96683feb0f8c935844cfd014d7bb12545b39964535efbcd47b110030b87a3a39c1c9a2073fd3159cf4074b788f3dd1a7b9095bca628c613dea46ef2945320e74a8a58edc8a7b2e3a5877939ab1a224e9d8919d187f6848b77a8ae89c40eda852cadabfd2f0912f66011be5318189a35abc3306efa7cd58a15f2b50ae97fd6e52b9bcdb63469fba87a1af1b019bbe115665d4c58aa4e3166fb3413ff41059e9689e2fb448e2f58d1b37808ca893b6bfb92d831d27c79365ba63b164c5df62d7400cc722dc658d931efa046aa99e987fa57bff8f6602696462e3fd37f9d75217e83b5e061fd39fd6aed9c29bec9c834aa36e071a4fd7bb0b7ba5b332f1b26906b9cc57824ba7a99efe510b23da9e7133ebba32ff87ff24d2a95a602ade2611db49649c131b6c74b00f69d1205f88ad2b83d9db389f34a46287db44e49089c058f883b165cf96a6d84f273d2b9fff57f0868742c58abe2492df74ebc2739d9cde3cc11dc13cbe8fff8d2a16417f93c8ed5eec78219932e1f5accd6baf661d107e60115e5b9e95fb904e47ac46ca692c0215bc6b4d8c4a3bbdcd8fac6660c38eebdc4177d7eff8d35c0e6b7c1f337ecf4ee5deaa9d82d15f41576b0d1d4b68dfbad68cc5ec4481271f54acf7b6de04b1842128878115485ba2566a19b682c67707581543f1be9e6a8bc8774918ddfa1cca4e8514f1cf7d5833de10271998de4a79c4542b0b81bcb097c76f31da9e7562b63f90eb0ba7d9c27090f8273f5a12c4de54fd7dc01d3a91c1d39df629cc1277d8c3739b45a4fe818aa2d8c3634e2fe3a337ff28b08f4a57b72ebc60a49abc5aed20b90108eff09ee65dc9cef49bbed51df09fe6f87ccce5cf209f7887a2306738a3dda150476665e0aa580e683e3814936ea8e39eec7455090c1e294215afaab56fee1d4718e404a2caebc8eaccf5aee8874a3fe0e3a6a87bbdcc19769626ab8c0e2c6984db5ac2a9933b11199ce87930f01db56a97be7d3373e6a08917c371e09c66b9c187583d1f68711fdf956779de8e7a0ac71ff3158f5cd777c5eff029214e31e4211c5d55c33ee3f7ef6a2236778069544d735d6fab09d22e4c1d326af85f2c878084a070efa1570c23f93978b135bfa8d8648a33056a304a9738aec14ab2932a259b094351daccb6c181134825b6c16463c6a72c80e83f81cdc8f799bcd178def3dbaf75b11396430f037d6d53fde91a637a41393365559034ae0d2ef009b67fe28692c451d939f16ca53dba47dc2614e45885f0282bf0e4b470a89ce341bb0a63826ab1200df60894b2f5aad407edcd0d65aba2bf62ac3f99d35afe49cbb133bff749738e9ecbf584bd5423a2700fe806e12a1b568cd1de1da723c71134271b176a47be7637cf188faa2f33d76567e688d57709161722441e9123724f4acda03a1f3f1248e6198aeb92a0e8e847e1485d3b5599481e60188f715f92c194231189372afcf5b6db01da50ee8b0a4554f7c253540f33c5c316d5b68e8c0a9a28ee93e50c7939cbf03516dfad01fb52d22037fb027934442939ae499025e5b5af4381ce1a194f0722265a4f810c3c443b17fb3387faf7bca6d3e9a66d766e57d04ed4dfd2bf94fc2a06030b97743a9d9a2d0ffa55f358c8685b63f58f53fe918f0a9e1dace71b2eca38cade3c96e0c40c9565f447a6290d58989dfb2e4840c549ca8900918b2b6c20f6723df0ab2dbafd6b766764ba1f80ed54254d58e75bb7a0b503a3ea4a52c8fcdba31b8833e5f9b50d042ce78cb938f42f484a524cd69bff488e2c8d75921a39c65d693ae2dc2645be477172deaaa6695bb3e9b4af0bdcc0a2b0b90b2ed49b6e8467ab16e0ddc30b8ec8fb874316a79d52744dca57f5124460d13af82c140c8ffff88b704958fd5bb51cea7dcbb909ca117bde8be8223c0e9f194984cd02e8a8dbdb2a06944ffbaa82df6c127c3e10386dd3233c66d95e4f009004673222bf7f323f288dddfae8dd4e9225e4ecc905d41afc3634b86a5c443506d48908354a2bca072aaf18f6089df902676ecf25e4bfbeb268edad74af8ee01921b166f6491f57cf4f1c0d5e947cae5be86b2829304e0aa6f87f23ad4238dc3bcadef49553ad9abb63571d0abcc5385c7679c8f97a91b1ab46ddb687fe23beac4a732e11108818f549d9390436567dbcd6c946c28a72ec4c701ec810db0a9c301a72be3ed299765ffeda12ce7faab566b4e48031dbf05a69ba99cba297ccfd0da6c0ef3c75eeaedf27131d990140b790a5971c81da209738c944b654a5fbf70608e02a61d3035c2b9e2c2c7a26f05a5b3e9b2812bac344e33fd8941fa276961076e44269496e3068c4cc35e5d0fb2f96d47cd46a182bb47a4fc14ca4429a9a3fcfb027fd334e3ce909d6816769f358b2a19bdc8ca7904ebb076451452a8420a90fd96c35b74e4230d26a16af0b5d9b7a75a6232be11737f60e6f2df4c8a2021ac0f02ba53b2af0e9563b7b97ea524d79eb5e903725d2fa34c36419480740e943866ed8f1eaab3dcdba7fddc41af6be57e66168e6585aba0e7225d7b2bf9894241b779cc039d03e4ad179e8d433b8b9c2d2bca63f5e0bad149481702b9770fade63eebd6bbef60a2e2078f54b97ff72e5c7e8eb0923f6f587c86df4f5d8d687ea2c5c751ad902e9203b7439ac7aef0f14cd8ba1f0ba065784ce9857ea8e2df72e8ecd475e7a15b4d752875bacc18f5388cf23eff35e3fc29adeafe53fbe14cda139efd0a515f98fd533dacbfb8360202cde79f967ef7209e06613979812df34848036cb9b98b939c5e0eb3a0cb8bea43d52e5b6e13ef2ec5abe8df9e68aa2f11a78c450cecc6f659ff03a3f166094005261fcfd1d40546d10ccdea179975881a3e227764ebd418b2e9171320ed75b26a1ad1803f90e8f460530fcbe73f71be57da76cdc6198d7ab9e0b5352122c7536c0d148259ae3d5dce106b182c94c8153f0924a9354ced338f9da06337c4d97ad1a10b939a9d99c662015081a3007ea1f0accc6eaafe78ebeb93ed54d13eb7e41450d60a13b3454a569838911338e881a6a576a67df7412b208a8bd8dfbf504ed3aa8a2979bc4e0fcc2beea10f276e29be598a4518cc641a70bb739746310b1ef2a95e815bbc4da96d4b63b5b3668fac71216b140df1fe93f878301d847342796d03523ae328dc132b523b68e351816cbdbadc384ce6179c72243f8188e5602b973051be47d55e7c297cdbfef39ab156c69460101d841376263047095da6d23f3180efba52c2f008cbfadb2115ba05a09384299db06cc8da89da9aae0d8fb392b1953e67d3f886527013d9cd6ac4235076254469a1cf1407172c487b96d95dba7c9a229fbb7ae9debef03639a452330db56f6494aafb9a4972077fb972c5653a8c06316d662c43f4d7084785f22184cd5ad01dbc1574f70e8cfb881c34c2e7869d5e575ec879d40736cb7b2fde80cbafbc4d689f7b517ef4e8691073bccb59195db92d9a3e094fb8d671586698a980d5241305a0d488fd0d9ab0155131b0096439ce36492dc0e985ed13bb6083c0439ff12b491411f5b0870d0fadfac468025d15ae227a711ed2bd21d0093d54ce57f69f332a147f1b9f086fba65f78a54aa5eada223512de53ca3fc8b103f0fb7a870262eeeefb9de078da297748b3a3ea7c802d6116412c636590d457c7745eae022fed4c88942ce8b9b914183e5bb504abc7d7eca004dfbb7d1eb02078a0b5c7630fc904c907cff4f196eec38c2430aae491843ea029fb16aa15896f0d9bf1c18ca4d8ab87fa49feeacd3be7ec014d01acb07f2b709344752e010353bc0d3f2b321cf0d7ab3e4c9b2799de04d525c6eecb17d35dcb9f9b01392bf71b3dac2ed4df49084930acf658c6757635c7b8b624034332c2f028302553e0ebe5e74aeab6319efba634f1e7b26991cf30ff51942496300b8415da4bb59cda1df024c68d76277155461d5e54e36faf2e86ea1b411729f555879090eb6187f3740b866f96d92387fb11d029cf559361d9ea5829c17d59d618bb2af182a8be949f890c90fddb0032320bed0146681c81a9e0f1d3d16823b3a642175ec2766ae6e6df092d9afa6214f5f17fd5061bf8fafc6039a217a3f0a5a21238c97d41c216bd06c32736d0c906a3e85d0c42421c51a7dbd91cfc705d49c325a83479305affac08d288a5b8ac6282d0dc76f2321b03e09dd949d37ea0d5cce3b144b8d4e38192172603e0b4ee1f6cb8661105c66d2ed9ba4d71d3962eb6b011327601c39c95c767e3afd807a7b69cc60f09b497ae3b9acdaf28cb8c454c09a50472849641004f1f8601515edf65244b628852d1bb4c638f9cc8d8fc20e746dd93d525e1e4c0a5e17c3e070adbca6d0f9615ac857148d053a984f550fe218a753ca28fb8febff5b8f531295a48a9f49a53ba65d154d3dee2f2cb96d850d8d84bf15cc80100040bfaea584ff3c15ec96a4c6dce771f9cc5a9661fd9e04605a460f8a877668c4d87df544730a17b07308786129509a11cdd71e8fd7a10f96bda0a922c6fbd0e850c946c5ad7fa2700d14c89e4f9258a7c8356473a6e6ead10f9f08e894fe09f70db6e5c27d57f47641f64385ccc335438c8d568546b91e3c3ed0f6bd8159b090aa74ec7beb2dbf08f30521a98633bd9ed671995d76b33927e775971a12395bcb562a38ef14a7933a2c04e7711f50f6e4342519381144b3ecaf11bc4092efbf98c82b9706b3792b07434c4978476ff5f9b03db78ba20c4d33694d44ab7e6fa7917f1efcdcdc5a67ef99e9d7f8bf9e19f102ddb1ce8bc3c83f1476fc8346cd1d1a616062f01e218af1632a47906877cf3fb0aca8986c592078046c083d141b02f8a3c901e0a8cdf6f69129f93e9e5d82f942f5ac7a95607e94f29af1abe5090a7f0fb6f16998c993e560deae826460cf07795fa4579b14d4fcd53b771e88070a0929176301a29a5117ad5210be04b91218f65cb02a45a607d3c040c4bd19fcc2537966adbbaa683ee1c716ad4b0148fdf57d81138218d13d4ef99872717401a6e5152f5e30c3a167829f028508453a4c8159b224086085ead973df06876bef09ae382f4544f18301d499045a18febc6def7d980fd7ab923a8b4fb9ffc5c2c66090e1f6dae025450e4e8e4611d08bc37a36a9e3afd497c6f7d112c08164b9b28016be402b774ed94c3968dffaf4119874800cadf96ffc2b849cc81f4fe4083bfbd016f557f59f799fa5650f9ca62c6cdc94c3684a63998f541bd05c6a6ac62cd58efc4416df20fadd3f1739702f0168fd0704e480d0dd80ad6464a770442f338cf77afb82d18791d7f81edb6c36ab0d99abe41afcd3c3df6292a2fe87e73605e2e2ab59940b02ed300ec93196646907a894962bed7886b22e08c023b024b2e4a031cd1e57ea9ffdaf9b76a34dbf1a9dae7841f6177b4132a235d629df6769c5588e9da79f2b98499fee970365ef4f8f3056ef6f106cf752ad46857084a06669e18adff7f42b1d592ab4fad3180db64c6760f3be86bc0f9fecc1a7db6a88111ec714a54da80a2b88fdbb7720e16ade27cd94b78addcfe050ed4bf142bb8925bed5382bbe7fe3f4fac8773499894f5ce38034f98e861a454d93490ad7449d9b6d31a002c87ec6b07bf1504056c55cbd59b9fe9bec02790d799bfe1a27494394dd5670fe4ecd3c3541ea29e26cd5b16688fbe868140819563babe614dfb7f7321f3c561f3b3dca6958e850eb2a7d53e4edf3f1fc2f85566c16ca80d46cd6d2fb8bcf0c7f64bc61331660a438420ebd7337cb9785061c13da3bca877e515d8b426120743bed4040cbee8c3c9c21bf051116ba586c916da42ece8d4ab27cc02505513b8d95b552eeb0f668a4206106f41a5498abbad461aaa955234497ff384669492f1b63a667ed333bd0d39e2514e819f375acf654a5a82820d369030504cb0a699d2025386827ec7706542fb44e06d50060c2459a83ad5f37d62e8d3cef0171799733da20fa0c0f258719d9bb1bb1efdc015acd7ea11416a532de372e925b21fad6e3ab96b9b4c69d027094c63a9449197e149cf9f49931ace8df2febcb7a949ba46c0e4a4402cdb862e582c3d59e78a32d536f8f0b0d784799912f5a2ac99e48a00cd06cb864f8a1e7dcc6bf5e195deda46de1e158a8d095ea9ee303720f2c02ef264e96d581022749c6c8660e18657b94f29fdfd0f5447dbc3f564f425a68066e1e704a2c4971810ade2bf11722280f3d9c30e48f2a555b2a3963fe2bdb789544f4d5209f2de8df1ccafc7c7fff72ad3999d638a36f94cf32fc955445b2e3e74240fabfd38d20acccf12b0c609ace70008079a29c1ca404ec533c22a265f2378d1d600b30f5ce9edb224c8c122d5a3adc7d80deedd769dbd4116535341a72181b2ca85f83b75773e37765ba11128f6365fb33c7eabf79623e8cae914b11bba0f36fe6452a7ea46cb4693f95bf151a5a6e90a6b981638156044ad801b40139cc5621abcf6ec420887b96615e02d4ff05bf2d18529e1887d45adffb94a43a37f0a9677e49cba9739729414447bd36069e608b32626036111728f759e13e22f797b3d0d25ad9ed5dc288de6d9054039d944f12b33fd35fabce239bfbc373c1fa003da65dcd23fcb2c0124ac5170b6b49b067913f7233bc33dad3f14f535f9116c7634ba1b659f5c6d66430bc2a286cb036a27d9129c0bd47ea0d210612975ad4a68f1619a93ba705cfe1cf7138f8eb5bded512e13768b87d93425d5c9a3c7273221281ee55943c267b7c75a025e35a342dc640502e3296ef1150cf43dab8992e6adea78f20765b0ebdf84a96705a8fffeb81a84ace1d65ddbcdf370e47429e703aa594500d4b5b299a64ff1c9d9e21221d8b2bda8e3a65b5dad942872e1ecb60079ebc9cd8e099891817bedb644491b73c78ec2902c1f3fc6b0866d4f87173bbd013e310b311de0e833a811f7158d44b3af85c07a423c8fca5bf44c15e05100da48e285e272cc52abed6f008f7c40e989c55c09c3bc209cc20fbd256","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
