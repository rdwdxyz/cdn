<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"654ec3c1b5c8231b96b0b0198fb620462d901affaa53a50295c594a6b946be32c8d7a3ec34c26be47620f1d4e508e329d2420c6c18b7fc76d959162f283b6b155d3b0166123f332a6ac7dab3d71a2f53fbfe7f40dee3413bd94833895c04acb016c8683742529b3c6581d8823ee892a18ef0ab2468b5d2dadd62d5535bdf572c0c3c037d8e24bdfdc53ce2d4cc8dd8579176d1690c66282dbc2a8a93eca480a94942790cfca6205feec4963b713be8291be4f6dd0b3bf611c99d2255f144b59b373a743a4e079caae59db069779f18a91254b18192d1a96f3317a129308ae02d42517679f2b03ab242831ed889430e1e1e9536df006f77b4002726aa2af0bfcfbec23d53de0d761c2287d01f3529906b434c66a8d3d1936d6ac9de17ca6ac2ddaefa0750a51e483a8adbdd0be9cc6b626e12c455fab891f4b6fdf4ee8a06882d2828fc0400c78c96d77355f29f8b757671cc33207393e6ba89af0054516595c1460d8d7516dd223b2e2b5d7c88e4162f243261f5c9dcf1793f45509724b1488aa28ea806ef88527ad3f50e7dff7686cc00acd487db5a2fd8d2afec674eec3ca219dceeb84f6da958e72aa36617c967567fbf7bc119f0f5960213b46d8a51d18dbd33442c35f614e9cf803b46e5bbb8c344d8d4a6bfbea8e1e12fffe8f1591df0ac99f3e12450ec4096d5e94a8e6fe11a70431dd013b6a348e4bc162ca0261974e1745fa5ffa5670f66c463fec1c689da1c8430819096384942c5129778cfa4fa809c198aee30a600a9474cd0945eb54a2a19d27c3be66a2e7bcd03d861d631288c03286147ef3dcf125f5d98a625734a9ca2eada20508a09b36c1454f0ea827a6af2ccdbec80d0ec71032de4a17890f1b8d039a55e92fdb05770c7cae52a6d9eca7a3442731910fe050a1f6c56fedaa028f94135dd7d747ee37e18a4f1c83ebff6c5a8b09de68f0c44549e83358b9c8480d12ea0033f26e0806a6c9953a3a41d6b3ac9b48f0763a1106db2e60d54bcdc6e562f299604b3c47a98600c8c6185813ab82c0fc2920a79f6467aec6d588c2155a0ee7664353d9496d5b03050e54383552ed6d16d22072575e8273092fee9f275bf9e168e6c5a981fda8ebaca204fa06bab4e9bd89de7d54e837319b05d5fc95eda4f1fced48176a1fc2969749f6ca4fa5dd5b3c0e161ae3d8bd9dab9a29a749f371d6ad4dc91cc1e19b005a6bc7d317c647b1c722f4fdc12d84a26cae90607287049400b62a720e284f9a44fbd2921c3688300090be9e42ab34fe8d2ee4c1282d08683c312456064165e18f4a50cd82b17c08c5177f27a4c9c8d0dc19ba9bb01458ff14b2587bb7dafb1ee6a0b81e6edd8453116b0e7814feeafb011f5cb91c753cb7d4b1da881cbcf57c9974663f8f52157fcd4aaec8176fdc34e881d8bab097b56522b92cabbccbdf7595a676068c11af16c00fff921066d82b9bed99cceca6f6fbb105eb502f2e5e9906d74a3a50eb88b30553ad3190a00e560a3b69eb220cb192075b9aaebeb975b8fe2a033e9fec3e6a822d5645c60b3def342299c7dbc9b9180db946a59008e910dbf85c352573f68837c8f259bf93d11c960b1fdd5f60322c5c6cbc544dc86559307e826eb8f5c2bdc0db7ace258af395188f445cad97c02ec9283490ae34fde1879a29f32128def825739b4ffb1cc2bb203dffe380b04adad339755d929bc39dd21b088a276b0330ac0cf9f73d0e71c5c0c4cc7d33bebff4759eeeb93fcd53bacc0c88d0f403ed697bab49a012d22271ce1e0e3e8b92f0d1f369b8cb9e7b2136197425fe2f032c9722be5ddfd9c31dacdff6cd6bbceb9518c794301ac95ba4762c8746b5fdf34a2d79cadec85b4e10487b1917af7a07ee85cee0d5bf6bae628681f4f8cdf14c90408ddf5fc18e9950c9f7492ef0b33e886408fa34d18371ec3c43c93ab23b4da079cd8729036836b6450ea280e284a35d11fe0d3889cccbadf995bc637d2b138f9aeeb708613cb75867eda548e2205df2c23f19665a4703127923257576c91360324e0af54e5af295a56374767de17d753c64e0015d4d2adf7e7017b3ed35a7c58a1141e47655860d82c4e4c7ad717ebc20f1dfd75e9b7bab6b88dc5d759519415b74d69541073375b643c5cc20f2847396033aa62a1684c92be4563a787ba0c056ea293e33b3f3aa2a8549d81dfaad10af74300feb56c6c07a3f20bfd5fb263c5bec76a5eadb6604a06d2a9ed6411651a2a02dad2843d0d3dba383bc4491a24f9af300961cf7d06b58a84c3d30726f629a61d994921ca92a10ccfc5521cb400187794362645e332cf9cf5b0d6360cab8c245206e576ca29065c677fb4c13811ff2a6d440a2e22b48a8185690edfb5dd26550ce39ac51c81b8eae2513c7011925637c325bcfa1a11c02dec55541f0828d0efb15e4128e08ac1feead07ece32dd13a488e7b64fe3f647447cc568702a21feab48a97d5ae33b686dde6116f90e5f0304b6cc3141c4e7f56d5142648b498764953f61d9a4bcbc738873b749b24f663908f223639819bc49748892e16240f022a8eeef74b6eefdf12d293882e6d94cf98584fb42cac1331f2b6172e3a4323b5dc86f71be2bce02df5382888fe4b1c71250b4b99db21832972c4b892a4289dc8fe977f4a9e0c0dad34b461546f71c23b5d8943fc2b664e11c5a346290778c1a29ab0f391c3bed410353049a8c433735b6a1ecfe208c7c4993236a3ab76dc40b5f38226e308302f5305954c1b29a8723552e210b8f666561a83caa160630491559460aa9ba458afa89d09c28e64f8172284e6f4cf252bedb0dabca699cc362a4569b173b26299d742a380d9f8e74716fbebf5c12bc1c0077df87c939626d614deb711bf0d6fcc61ff0576218f900222af2acf5d6924c71c8a3001b8dd6761061ab46806bff494bd31e3881c8ad86cbb321738253a8e49c7e941bef3162c174d52d37bc5259e1c56c128ec2f384aa2967bb2214059cc6c20703f40c44129a2165b1c563861759ed266223dd6be0f7de7e7509c81640909bd2e55a36352b58704446c7817eaf04516771875272cdeaaf743ced95da83efdcc424c32a4226c627060083d6b54f67eef99dd1e2a90e70897b4648b491696f3a6f97e3cafeec3a5c005a3e14e9b98cd1b48a95e75bae9849693bf47d1066e5b7978a2374bfb297c7e5fc55c6d289025930fa308d9a2f69c423e98b61291e491ec01a7324fd6395c7d2444b38c49c7c2dc1f8b038b3e18b17291d219c66a0fb6b068bbcb374337da997bd775594119b184e612a216cfc8f7ed1380c6f82fd4ec20bf3d1a7a66095da779529a1f7799e8127b86426cf9699e0bfe117885dd132950900a779e01b7da243a0808ae9be16243a276da251739204ac6501154afc5bff57fda3a7a649fae5173420e6af51fb0935b0af83cd4df252974315d8c7a347e3494f2b1bf8d19fefe6c36d28f8e6380618ff43c4d15d133ead0e62a7c357d23432080db8744006f073000cf2cf5f0b040805f8722ce8e0bc23adecc11360648e344962fd82ca82d5e2fe6260dee41b2d0691423bf47b36dc92878c9a50b33d7d6ec6f7430852ce61beeeca2940821b357b9549cb06d09d9a6cac1fae73ce1ac8ddb542885b1f44354d8f7bf52544bd4c281c71d646287927f769c562e0c916f422aa0859bb806bd267bd6a2e5421aa7f8bcc66dd2288833765da67898d034ec88352a04567f572f97fa382da005174becffd3b832a89017db71c2b918e460da6ef78c71e8fbd9ccdd2e918ee208594c73f1c9655d84922998dd81a8a944646463a5de7ef93efffeed98dd1f3a0fe4e576da0644160a679acd054449d9c743dc27fcbbc5956f9160828db60db8f717c30d4f47f089ee95acd0d07f7bf440c94874a24b54df050a6e86339ddf2ebab587089903205b3158117ec573e557674122e1d65db93542bdc106e23f60e6bcfe5b0bb6867ca883f7acb35c5965ccaf7d482816f62e9ed46cd81ccf6b1749ba56bd03f00c6910aa5f45da95eebe8baad24768a915ec13a5a969dd17eea17648550a3887d15b45b6b2809c522229dd702b18a0f1f10d15e64508b58c222e9739ee05e53126eb431e55057cbf318d024967c74ccda219f62707aa8cb1cc8eaf0bf55cc4ff259a372cdace80bcfa8f7d9d91f216b95b5b2cb086455efa28ad1e0a3f09cb0470a97abc8d428137a33161b66d462557c7b999ddcb70f2320b1e43abd77b164c0257121b135f1676bf9199f3dae4982102d0d97ff816e528d459197fa5ca396f698871ea902099bcb42856114caa9d763679fcd194272638b2c214aad1a2ab520ae6a8da9962a157154a5d4fd3a7356ad51d55404429e4846f5716be4f88afbeb7e8f4bbbdc4db0104d6aa5a4e762dfb463d44c39d3fa0fee6334252a25d762a6c4257a66534288f3c7670447630df61ef59073ff71fc80471748243ed4f04832c33e6d4bc7736712ea3f9d1939d8d568241703602078e395c6a37b69ccaa22609798d6ff325c2dbb8286262c144b0493c078875cecd076ee32aaf3389dad85e899d2f6d77c9344ab92209ad0413051be975d8e1cbec6b38ac41fc3dfab06a48fb88dc2bd5654b5a51fd5ac464b8cb29b9ae04a6452bf04c31f9d519a015fe2f113e7fae0aa6b260671791e411de9105ce07a376b781d49aa220c818b95769dbaad4b6e8ec7609c63a207ce579cf89316a9ec52285ee7462d3271825f1e84c468af3708180a1a3ace20d4464de21892612314b0eb3b1cac7d6fb5e6ca941e80efa38ba76d0dfc4916deab629468d5fabf9f008492f19487b9a491a539014eecb85f091b70abb6f8b9808cd674333d5f170ad4c49d036aa26b6a96551a96d477ee8ccc779ed2460dd716e33a6b5c13eee2167e3ea8782520419ec40975fc40d098a76514b76b6cbf5c9b309860c67ef1b5575eec1f999a7221bdd3064f240c051c3209712ec8a82c1dc583f04f8642ddb0ef22e8a72975099998fe9871be2fb4a663ca8d4bd4baeb27e24044bc16b2b5ad00b8319a7ea2095a50f45078bdaf38d7c77e7f19f6a1484ac3d8b14327dcd75bc148b81f9b1d98e7f2072900f8dc2a24e91a582b1b18c76aa55f6346858b641644cf4636f91243bf96b920caf170c1004bd433ecdc42484f39d6403bed34bb065ab0bdb1578665444362dba6eae290327ca0a61155db1c79f5ac63d1c16a6ecef0585f5d17cb691389b3c8087350787746ef04282efee5c7072ebe50c38492426790a75340f6b4a53cd0428130f53dcd8fbe353ce328b963d8da054f31785397eb036329d75240569fd3043d16e8738fbbe400880f13eda006702f8a009f234f6a5338f5677dfa5053c30beba57f7cd2c5c9c07bafc519368338b040041e27fdf1b7ab86ce0c286d80dc735e2a14eec4f3451218135ff15601ca5c40d324c30d39c607f049e29ecedf8ea44e5fdd43dd45dce7b6f9efee2c985c13c81de09e3ae062f7f977c156491694a50fc650bf21776ae75b4ba26c058661e1c5a0f275b072c000cc57930de5e866d13b6344fa5e442acb240460c3c1b445f5928aff70d0fbda2f5a4a6add10d63bc86fd6bb246e4cca73bd25b8f56158a96797af32bb34f764b487cb8cf2691e4ccb20d8ecb7088f0007441bcad4f9fc29d0dbe0f840f023c22c55a2a08c1f3ddcb8dec07e3fce6955ec5e1466a995217b0a6b59660428d1993a91fc30cb3f0a76d474f83216b85b5deff96fcd32f2ca2921bf92c4053d3049f5ba09d7661c77c0d7c9d382c57ae3f91d596cd712740e934911acc96d4f5f0967ae29f35de8af1eb1857a0dc1c8e9a9cd5f20a0c823484323af245483f3b8203bb2e3d6d1d356d3d1145860831db17603ee69f8149c71a232f9bba89269169aec0d2dd632c43fb765b415aa07101f656dc429661b49d848720af34633e9e474d976d89660e948a168b715b0565e9a2eb4656fd80cf85b9ce057b9fb658019af405c4abc0ec9b05189c8ba1617d59acbb25aa8fe1d2c78a0755581f47ba98759e5fab7abe0018d782bcd8f242616f7b6069c0e3d2c90e1a16ec8820c7d64d5081b6ec3ebc092ca6e9e5bec7a9fb2b4aea774d3c5ac4fbba9837f98a25ce831018e6ed3e4de9d80a6cc5f1b8635bf950a09aedbca5367f0c114db2f61de4e1dda71ad1e1eb5d2f1c808a452c1452df06a8a0c9b46ac4077afc1cd99791a1cc88ae8dab83cb42a871978ebd552aac914f414a18659f8963b9a0165b9fa9aa52c4c1039241a276c4fc884fc9745d1d6d68d0b7cd4374bd10d21fda5f0a7c1df56f8aae8e210e733133939e14cdde2dfb2a05f3ffbc5a3e5e435ae9fdbb5f2c11501c9df08a808c4d3d61067da11411f8c97cc7ecebc25d6360e49e9f81b649037c451eec24b4bfe86c2b1aaa0e48002c1775a6c715cf13cff1fcba2f524ebc841ccb1f7487f2d73164c8c39b143dbece1c56a4a212619ae4bb0874c6644d5a2cd71805a088916808ebd99975af39a364c880d8adb8401d19dbc44087d414d3993ebd9fc041f358aa02f59997aa4963dc57f9600e1ea15f97e827aa20c19e37e40caeffc1aef1cacc2cbaf6c0f7b855f378ea61821e793899789a5c1b537ea1a603f78fc48dffe0063cc1d4bc4441ee722db082a90c8e7855c2d20a218648994b7ce8b60a00326defaa03aeb31a5b47c0ac382028c80fc3fa2c83a0d0199c66591bc45c8530a72835792a92f02eaff9b382c308fa8f30be9f75d4654099baae64db8cf007980b95ba3020a001abcc541cf1959f0694c8d31632e0655c52802d6a2ee300da504841b4d9ccdc231df1053ec7a342535f6deddb5a80544a8e10d045f52cbf67520a05791d76f5500fc245d258adbf6c2fbb209609332af369034888f7a8bcb253580f3f896f45c98a973e2e598297dfef756bb713770b883ffa8b54d0414c5c387a43156229da1910eb5340b45f0b7ec2689772b72891edde25e462db077f409144d2d2925a2c999ea6a1d4e08489749086084c49daa13d2e6155d1c130083b4ac14f77463828df3ad6c42e77cde7753e43b3a56f62bc7cd9c566c918732f5674a99948ff599c1c9975d66fdf4802c5e075e490d0698ec148285b3a40e427d3b2aeb34605913bff40890a33f7a47987b9b81cd092d3d40828e1f9387d7c7ae28c3c5e8501243de246cb178eeaf2a02a8612b52d637919176d0cf2178415b75ce6823235c2011c704be98a12249f5004af4cf68f25fe5f54633d809f0b8c694f83384b6002641a570e1d4cd166c7a85c803556abd760bf571e52feca4d8268d0367278c80622ca458c8bf45818b251d0125cb2a7765ee7382075addf27736dfc19294203bf748f9af264da0188d50e657850db5dac25be5b25cd534753d9fcbe695ab7a7efa004bd4a79aa0e67f93b176b2edfbac8fbbaea2419b56bcbbab442781cf7b1e6bbc0898e4b9231e02c9d93a265b1cd4dc5829af4029e3e6402bc83ea4ac3acaffb36962758b10f0f375259ea93d57ab6815e846fb875afb2fdd4230f729d119c0686de2f1cdb283cc5a6cc5e3f23db44919523c7ac7bfd095f9a5feeda153aee672441764a0c2132aae83b30a3177344307342646a1c1a53833a9ecdab73d6cd35b85ce3fd548168777080aa6a84b4c3c2b0668a169dba1ccc7482c9bbb8550b2e596d3c7ec5f58c47597d247b848b3e3df64468d877d7efba21fa0b987a105d3b4a0cc016f032cc746503bf03e6f934fea5d1560f254721e6c2b259b051392034040c8c06f0a653080daa7fdc92666ae1fa74def639d8a89c9c0bb36956315e80769574ae1247f31e3e1aeebebcd0f7a3556364463ff6e5b589477d354a181e98711f48a57b97d289932f9d18f164dc6252a706dd2cb07d45c4525d1268212816b21ecd1f246c080147b0bd9e10b7e7f56fe6962ff415db9b4622d3296edea0fffce0a133744e6b281b4ff0059b60aad55431b67a9eac6052153e4c0b84cd0b86d79174a2e452f01543e9c46fe1eaff23a29da87c072302815dcd1e8f26805e19f25913937380a43582e9568a893a13f5ab336121f7daf25469114ded639c1753d00a0ddfe9c50c25eb2734929a3b746987112704bb8f4b21617ad8279b4346b689481bc08025baec32f53e1aaf9cea809560bfdfd8aa27a66364e1324f971bf0a413451ca2fdcb0b5a7068fd9b42177ea5dcab6411b56fc08b2bc7a7199f9f076e3777b184f4556d2b64c491e63886ab319abe463b1ce536d5b62e2f330b72133714dc2b2a26f04e251e860cc6d1ba30c44381c85014b4cd9f23914b04593e4654af1cc9cac46afac8f8b57b0d60683dde5c5f45952e1e9e365f96595dc5ebf7d8178f1dc3e46d9f385eb09756202e54b8da96c1d2dd060aa21599869da687e2bbb55edaa5cb5f26a107394576db4387523887fc398f1af229ac8ff96e7fd7007ffd325faedb4891aab72e3ebdefbbc8184602677424a1ee12fd54cecba411290ff568790f865b0c9e14189457f7b6da4c98babb0e0f79d9819d6d2cb750e40e5820beb6317e60171821bca45f000354584d070817ac72ef5aecd1dd1238a69fd5618393cbf0015d3670beb1708d84aed6ffb7203adf7fefc0d0bfa4ea7857c750606fee151ec74dd9b67409f238b68abd4d07e21e46972375a4527d9e5f5e7d4145f35d2415b2e8cbcd043946bc7816ec10cf31c7344d4b9b66434d255b965b7f210d1585edd17b6a9380b14955d2e62775645fd0f26c6923f975a05fc84b018f6ab70b882a582aa41320a68027ad28acc79a049f88007718c915278ea91e943f8910b478af7e759a09be0c2de726b9c9d79d9153bb27a69cd7e80f46f5f3d6cc3c421411e694692a329295cfc24b76d1c71f68b27cd45713ddf619a47bf7715c615fd02e648d7696da37163823f9af11c93c0c64ea1db250758f07d20058f53e49c5f9cc20f5864e01e887f50016529d6bc743440d3f94c337906bff6919639c9dc8d4b59c8bf1fd73c9280bf71128e32c86eab7cb25deb2db5ac86079a77a96572f7e2f8f971d82b965917487bedd5621e1ba6867b12a76907d16b4bf9d38852559c152db9b38c92a09b7cc118e61effc313dce01b97c55475ceca05330953ba253b8c3d984d41701195402206513e6984d403dd6b9cac81508097b49b3e67544920cdc34983b0101952376bfb8586416d49af5652fb482aa185cb6dbdeda86887b78b8fe6304271c077f61191d72ef968a5ae2834978f1b5482c7ce51126db99181b568639aa49d57db344e2f51e089e0bb55c84d6d07f2583d3a3e1c90089b55284916e451dab6da669eda4650b4f686c3a04e7878edea103fa99facc0ef943417d5526992b91a52fb2e28849cd4992847d3dd89126c410660671f95b05613d77f50424ba3cd602744f458d58c6f8ed231e71d23ea7d8da064c21fcefc2c08301e976cbc33364a6049db53a8f25084361b33e09eff4aab7330f20b0ee0806307890a387d3fabc04403b0ae3ff6bdd80756dea4e2a229bf855021ff2ee31d8f92c36b41ba9c584912c47f7fec1695935bc7dd946abd7a72391281cf9951fd55238c501e5b002adbad4096842afef962ba136a16dae3b3cdf656ff8c9629f1327e759522c456b15edae85c96fd5af2e5e29f38680128c030b25aa75edb6dd9a5f2415aa7d99b980dd5ab10de59b8237226f5ce6ad8f105b4189675ba47f1850087018ccecbadb09be5662e229456aea1baa2777d489dd3aa80a2aebf8466fc3d54fd6e2037fbbc26adcf9dade55cdcda5d5aef53a9b75b5de3ec2082465180350408f1b2846778d2adffe4d705f5e8247fbbe6970eea7cbd2f0c917ed12d3dcf2e168d31ed1aa4d51752c542069c8f8e4f5b6ee62e96e055a035b53f7abe60f6be7682defd1bab89d3ec16c70bd82b329b6c932c827d95c975f1fa5187e13d49d81474d1a1314f481b30a850b16784a25659d524d633ea12ebc719c7ef755b42d707ae4b7179d15b84a86f32bcde12168e77306eb907879e59ee0e4dd1ea0f8d9225eb9c2eccb9cf1857658f480ec744e3fc6ae08df37aad3c1a65326be0f03a871412d98ec638b66f836ea3d81feb2d2285503a149451cf69e18daae470d90bbd498b0aa31b24b3a7bfe07178106ce82b3bf40731bc3162d0e08273df0da6e5f18e236ce43d24a6c14d804ea575a7365289941d31a8603f2bd74a04e24c6732c2d7fb9030bf6e584ef52c9068a73c37beb41c0b346a18c0ededb654882fbb355302227be169379c2334c0b3aa2ba0e396ca0a52e8ba77343e2bf7362797090007e85fdb6b5b8eb6270d0489b41077ccfdcdf97d72531d6b3c49a99f1742cd420a1d8a3f33fc96fe8d024e45267ebd8f76f9ed3d89e87850d6f4153675342fca7fcc4ce2d2364ed09facada6d5eae4c37aa529d6d41c18f0621ac025417afcb9e36b22e303d20291ce855ffbe7989211aedb3a07c391f9ffee5e9975aaecbaad6cba86ea9db78b74c9fa675a1e65a1e5814dcdd294bb78ff07e4103e895f4f4fa00d46d90aa7d606e1627a34621328c689b1c7984a919ec217b31b95c57f3c2d651c11733258a38a41ebda37ce88c1b459c606bd6d39cb2b1f3c109686c4e1fe0dc3782359a06f1948935a99b9151d55e045ce5542c39f25293dca85408e232d742c3b66e9e619911885827a55401892b3db8b174c054a4f453b8ad57198a926d7c6dab9edf619fa637583a266e48771c8f6c31d0e91d2805da3bf2ce8b106ab96d3ee95efa66ed9d5ede161fae17d0d4233abafd2e8b9e302782b99eef089edbb7ffdba4d3acd9eea5b41dc1061f855eb7557da401fd4e854641928fe9b8eee0df0f0d1d92388da4aa65afb5227529582ce075e02b2ba566a9943d38fd39f8e37bfa094afacefcf2850a2cbb87a90771eec5a6da2932164b6d8440a93ae98054258083b6a8025d4d6090e298f8cd68530c45099e91ce50817850a01ae5638b223057b15a4d4dda784bdf68c9f1066ec6b737e203d0aef74fa069f01fb1b380b565dee2e94dfdfbc86623a95d3b501417c19371e1f97922328fdc4b734847306bad06653426f6732de445a5ccec4bbeb69cd36d00a0f51fe729215a5992fac2374f8c067798551c5d12a7eb226dc09841b11cd7636b9e6736590924cade3ccace8c5acdf49808f20c498141df72b14706e6aa80414953baefbdd1fad8d7f15d11e4747432ad99620350be6a295290e58eca6e7ff8097e4f1efa2feb4762db43db4800f578c5f38603a457a53496028b4c12fb3e443c0a6a48d7b4a17879e4c2a8a1b768a74f9263568f0b5e27e3228c1aa05fdaca5ddd18997dcbf6d5fd12d6b23261d4ef45d306506dd20849882b3227f7753f154b0b4b7c660634d78fc56ec58202354f9b3b0907988805b046ab4f9b8aed4e8646d5225f42d77ccbea3542578f21387f68e9f886fe7a9b998544313e629cce9b6b6639c85509ac5562abfde7d5e23912f472120ec556443085b16479ca549267a387646e30bf46818c051846acd2be430a81be6bf47b5e58211ee8224d050790d7562aa6789c5b22118e7df56524f320d6a165a29cca540e7b88e6db116c47ae6007851f073d2cd04da3c0d83a5b017130b6cdee02909f33e3eaf702277fb92f72a32e6b1d243315a5a50638a0e33583eb7f5d0070b5ffe29efcc8bb7e63a25f5c7a8d2451ae2419b9e018fb5c4e81cb2470b3669450ff04602bcfc3d6ba5c8a455e3427731df944f178a88b69a6ebd31b686e82e5618526563b7ed1705fd8bfab7c0a804a001c3910710f11a3335b1aa3689b52fa8483bc287c2d96da1c18fa43b4468d678a8833be3b24776cee39b30ff4502d815ba27bbacfd5309ea287d34f47ff38e5f84651631b31b65097b2e8ad25584d56da89cdacdf1b4d7a05b5610a39d9fb47a77c0a964b0581d96312c1b25d0807010004616a7d0692359e2b70b056d85ca51f51eb6410880d35b70e612b68811ba32a2196c55c4dd271fb932d6916c273739010ee35793d9d67e206cb646078c8d5266f0dafc31f2aec1cdfb2c0fc4e02d6e62bfd0390819ce7fb02d0f16ec75c8fc69bef0c57d01e24b4fb3007d826cc746867650c3c7dab83162bf542151beda8e1fbe253b6080711dcf94ad4392f9b833f6a874dc4ee64cc46ec0f0d685b562ba92fab09b2e3e6a4612d33b90b23e6ab0508a8483d183aaf6d87c0cd072f8ae1f6b020cb8ba09707f139897c32b8f40a0f325669fad74125e4c06ddb695321e844669b0d5d10f547ea6fa507a263fc8413bda7fcfc328ad321afeeb47575a095ef48a90fa64641233a891ad4986de4f699e6d5f19bcb8dc5633db5e9dd2b1bc020187964315a8aa4709b3b668f6e733d92ae2bb1f3f98ed5264139afca5e6efb5d91bb62ea6f641f5c05c11cd6ae0e272e0c5abdad9d9d331c32eaecd4bdd73ff41e7cb504de0e127257c15c8cabf17adfc19b0c2a5e01a417e38ba89dc5cf018db5dfe22736c84143cfa179b136b5e3ec3be4ca51167e4658a6ff88d5cda08b599bc695f8efdc23cd57da2a37887504f917276e8ad8f569e9d07d036d547848be4779f29b8aaf003f0d8afe68a470c11521f5cb7a7c9f95bbcb122149b40e6650109a1a4a1ec5d51e4a56dfc47465d1781d20dcb3c47479ca775809d120c1df0124ad582f9d7f94a3ddb4e91929b7f27630ac00ed388e494425b3d10778b302e909af45cb8eae74373f8e33561d65198eb77c5fdc2bd95d73754f18b6cf2d18ea5d39a6f21405d0c75ae71f566ebed5acc15f71613d178ab627d299a6d80e82a483bbb275fe0755b18bd4eb45ad5cd2fcede4c0bfc1921274b5507a7ccff1baf4b79400b30c0068f4478aa81b442719039fbc1dcc1d71b3dfad3dc52ec2a13618287ee8227acbdaaed6c0b4fa9a3e5d8db3941118fe8d50bc22a1611115f04dc5246de7814e67ba06da00737bef5e5796a0be8d6ca1d2cea652a1accb61e004601a71537148c069887c953ef5b838781f863d185d75ff13ab2382e3a25432d3ced0261d45388a78b5ab76a8ee9380ca331ff1be8d028529601acf74c689582252b43f7f368e02a901bc947f5a408a2cfcd26ec69cc526140e2bcf90dc743b3ffc50969700492cb3f6ebf9ec12d0f43b244be0b9fa0a64d11a9279facba0272e4dac6b26a6288a535f53b3a5013f12dbf65ace31665801cf1faf3ca84c179cd6edc6fc4358bab0a81351ffaeb5e00885c564332a374f97b70d380e11fb3d868b596f625fdcd32b5b5952f9e778f32b1d88e20fa9d3360ded0420086ce365b0c392ffedfce89c21dafb82224518212f5149ab6b0cc878f430bc4e711c0710c610d1bcb0e9446b430c41b6dd457f632bc44ed0f738b706231fe768fc8ff12c582b2fd6232937f2e55426bd285870baeb5fb3e6a8f15070ffe88b8853a1220bc7dad0227edad34df0d7fb821e052c0290c0f0d8ea88bd5bca954bce8269181abe58c88f8ca8c85a4478b23ee7571b2e9192df6372f0657f9de1966fade496ba95a7a292f1f557222a63362a53e15d5e7131173d34f72733db433ffe5c014dce03f7972654477e134cc32b16a6f732d7534223bb54fb737274b33319620fa23b97ba569b11899a6d979c786302863d6003a806a54bd5f8a484b5caa066f447e551ebe069c501ee3e3e88cccc41224925ae5da2cdfdbda36b98baca0fe2426f95b7108832dd428f6455281d569ccdc31ad4f1b2101a26b663c2b65378a81b03ad597167532b29b029e6e899804edb4a23ef3cceb8404fcaf221db26a77a23f20459803ee677afb0e0819cb904050a6ecfe8806ce69356380c1238af5d8ad560899a92df7595eb0adcfa23606ea60ebb0a6ae41ec1d29203c08a2ca8b073f8294537671c4fc7aa88d5dc0ba0d689556ee268b7e0ddad38eaa726f9d7bbee976efa70db84b8330a8748bab5c45c9896363cbb2265c37c42be6e22dc64e11c9a37969370503d074b123563168bdb232f7c3138e7bb9ded40b6ef141d4ee0ff7dfc19a48701a86073b1b72907eacd7ceb46be3f450dbf37721390fb358a80764310483363175cc6712cd8813e74ac2e74caa852c5dcca4bc3cf310f712ac8e2be4a8485bf8d3e0c5eb67d4fa24da34abdcf6f3050374d6d459458ce61d031ffb842823ffff7eee94bb59becfaadd41bea10aa4a85b3fe4a25557959c98330052f8ef0ecf0918167ca6424908a1497954a921faeee389441404a23ef545c50b453b4912f54fce83d0d1e663feac3ca67a6c4d598c1a53a089976594767eff6516ece30c8a74eb772eb7f0befac97fb0a01a5401d9b50296eb50bb0488b05ec34372d070cdfcce60814a7000a0fc0aa65517f848de06355c17551aa07bb3a873cdbe9213c77fb53709dedcc8095c5f1d46309417e81dbc63b7732fcff25aad8755cb1a53962a66f93eba1ecb9ce7e8ebb1d19b64ec938a8f9a8199c164463d3b567a54ea5e471f69fa04748a61a9f0e43d87601949edb5e4eead3df37688cf4a11f7aa9949834df8fb739e88cad3b6748f92bef8c7d62cee12a4a98240cbd85399d5f7fe06d91ba16165b8d3391b6fa2644e927ff634499cca2d1bc551c23d634eb5df81ea6b92b0d6d3e118bb39e41c48172b1d6330dc30060d1fef05c96f984293aa04e055843a3f616ed61db4656124db1cbcc193246efc041adfdb8d49b0d99d795e36e7060bf2cb3fb6d160cd07d4c518d3c7ed66ec677ed2f53da16e32444f07c907f6f44bce86e6917f1868f076057df31c1cd23c91307f3436ae81e81d1d2f07c64e7e11253ba9e298a6e780282da8a97d83dd55ea4a0afd13b433f736b4fcb5dee53f67abcbcd437e07c702f419b16bc7ff518bf7bfc16f7888a65f328c54832a2c412830fec24f07c278a53b94acb61953cdba2df38fef712c3b31be9b303f7037953ac4045d02916e25e3f400eed716fd56d1a57483a3263c43ae489aeeb442b60f8d4b54a6e014c002b6d4131615b08be272e82187727c2165235deaac6d12ccee6d5610a8bd7edcd39f5dcbd412ad4ec77ba6e337e057a7e483e30fdb4d7a77c4536f91bfbfba0f6395ac9843c3d13eb9b0da89c2a5d93c549dadf8e2847c768dad52c9d31198d5a5339f7e5a6a09066cd4a6e18b17126b1f98b01ddb8e95c4184aee7e1d47d4a3cc06b5cf3a0f496b13c4ad88f1d9d06c0750a42a20c3fbb268778b2c445fb9aabf0472b610b8bf59335b3a7e499106bd217e02614d62200bf202ae1195a4db47280e4c0a661557f5829c6b274dbb0213544cd9ad5bb067832da6a7fd8e21872c511ae1f6404f53b66d99e462e2646770fdb26ce902fb08d7df27598130559098855539bb798838f56566790dd1ee896bab3a53ef604bae31459f8da30c76c18fd6c192f8a39dcd756a35e0568f5de184162c99c3d308ffec9c7b812c78f7a342277a943b88e4167690a235ef28d210b3ec635b5b6b05803e2134b3de6499af0eeccbaa167aa8c9201510cb3b8be7b7ac036bdf72da3b796950636268f0f2f7e78b3ee16681a59c2763e186b2bc755d54e7ebec4ca66029ddda09f40f0739d5a9df82f8e3ac039c19205fe63bd77db4b7f839fcf1cd2af00007c3f50cd13fe7af254b161da8f03e75fec0ec1dbc910a2d430ef343ad98c122c9163afcdb60dbfc99572061526aab9aed9755db4cc24839e2eada8c77bbaeedc3dd6add17bed73ca67c400031783dd9d6853d83af325b02f32287300dd57d757451535cad779c2bf7cdbd4facc97d62eb4b27b3a78511ba05eea5cf1c42a72cd8d7b0045ccf789f0585016717cf6ee6e0a4e05ef7990b9d5373faadbefe52fd905012cb3d58f1ecb0c7665429de350242b7a30d9047c27944f298281c9e7fccf6422c200c5ddfdd72dcafca3d7cdc4d702088579f9c17aff19e7da9f3a57eabeb2979c8338c752b6108ab600b1f2cf0f380bb12881835abae035e3513da8fd67ae071222cd34dc129e8af399201ad26525d327004a7bec25028149f5c0343ef54a8f4055a27c3605e0565e4d88bd86b322436a951544d00b2dc8c7a28902f39f1516a3cf2dd3e4aced77c8c1fae1c84766dbcdcc6e56b1eb7fcf6bfb660b3490ff8b7aef3f8c2b4c07f633ef57e81b82f868f9552fb0e687bf1c085ed1534d5ea62c40c444b5bd1dd099705dc4be008083a0a6e03538913b5143a5cf8b7a68418b32c328136e68dd6d260878d59a0847423cb7bbcbef748da0e4537286d2b28008e654f4c3183e14a986f5907a911579dfdb7eea4cf9285bf0d8a8584fb8191f86a5b85306bdd50706cd2ef59e5a36871410f505eb9bf8d087e83fd9b7d0fc026892165e2d322626c734ef45f002bbdb52db0c4146154ed2144a4b61acd2e1aa81d9ae2c18f6c74802bb94d40205db967f2d356616170edc6ab5a24d841c097e8b534ec4ae0c70bbc0c7286d89d29a07c5bd19050fc652ceb2ba9cb73bf0b958a993b62ead573e9bdd2ef4dbdd27e4bfed912e532e726da58b03932c863918e732c51939a5b24dedd611bddd2e27004f945192d148df6e8bb6915dae2d0f22d602d0d0ad3b3e1de6a67ca039fc9d62e3d0b7fd64d58b4d77e68176a73acc4053a1f4f1c1c8622b969003df0b433796471ae86496e64c0371ba295d3b5c24cc1beb0ef30a6dafbee2228a2f553f8fc593618a871fc29875dcdd71e54c91074becb777a4fa9d8e497e7d5cf7a6ba83e2e17fc278d821f42345fd715f3a586d53fe2e03908d69a92c5e791a4e634e1a8355b8f7a3e8a52306f0e30e0cec1fe03a7e75686140b974f1865e4d78c7edb42f36a1917babbcd0b00248e6db45cd1dd837935eedd2b164ded1f2b40b9dc0ef9f6d5c7cf086db6cf8f6217ac60ae3b2bd63d19545b6a21dfb82339ab2f2af183ba0fe4b7e9355ffedca2ad750a438a138dc9ebcaa8edee845d1eda50b38c47f70f4b67a22987916d1adbede3567703f74d1d88229adb4ca3c1cb320ee3dc0f648d43b4d7c0c2e6ae8d3024d41f1db83238e5e3f7e1e8b2fbfcdd16fd46c966888ea023f07f8f353366e41684a393a22414e3cad11091177dd35ec05e1e0dbbf338ab398cc0b2e89813997d98c9a2dbf67692142b3d6a07a3e673038bbbacd23b8eae251d483adf7a95ad29d59e6476148c742b44251ca3dab36cb87956b45cc7e93dfa0d0c8c4d357612ac5c77b0a1e12ad48f04589545bd0e313592d93b1e6c482c9349542dae4ebaf9affcdc631af169d6395c03eafadc88c8e329f9422392d104c4a0bede6f5d1d7ff1eb14e72ea1c457f3aa7781c6e6c8ae326061c02018648133e6828224c12e2862a4f29f3c84b05d97a39cce403cada748a1713bc34e80cdd2646aa69f290e927c61f3d3f6726d5423d57898e16b25a2815f7ade2deb642deeffec263269b67a5bcebceb34bf49a915424c83ad9786c1cb85f8a231638871008f525a6eeece29eab81cf90af50a47ad77214470bdc128901106d04a94b846dc74ab77078dccdb9bc524409e1c84bd1794e330f38d28601f757be7a5183b705ef2610b729c4548b7d224900c513e5c35db961dd84a2b9549242359a7dee32d342bf8c188ae75bf68a225860c855b174f6a9fe03830a01717e246e3ae1229fd6db1b170ec3ef2c0a5ac043085698a53cbdb88d50accb745e955537581a01068719b218361a8bd8e97425b753cd6576ecb9827ae5d248f420ac9d432f684601b7b5d108d1e5efb2f3805b9225c8095bd210dca2840973a5cecfba8e3f5d01a9724b4372f5bd1cacd34346ee9d19c9796fe3d34cd2a32f45f251bafc624d5b542851a34c310939fec6ac3fa7d6669722f3e375eff07453b4b0efdcc2d4aad76f43e9404348f117e01217caeaa3f5fc2e6346b21f4a12e8799b97eb2a25cd4e541a5af4316a15d33bcedbbd647e53869757f0a6e9cd3fffda751725e257e6f0261e88db6822b36e43dc7475f2000a892a8fb92f4aa568aa28d9f9e5b563b890d2508ea18502345ab62b5878f4cc41d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
