<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2728e9cc27202e0610e69763cd31fcee1e7b9b55d83ea8a12ebed4f2e48c595fe703659266b27d500bb8b58eadd73572c6779a3dac7cab15c8d4012608113c606d366809c31d6bfa9c3d69f7ad6bbbf4357baae98fa869149313a43b70d6a42d8a98ba7dd22da621f89e74f185ef85d9172396632813ae012ca7fd8f2283d6cb57ae9516a6c64d70cc481284ffd20af815e2900edaabaa685b47841173c469f871b76c59b745af822c4c1b135e770975e8db823c0afa66030c65f461a7145db69eec6acd7dbe53722deac6e5d2d73d1418c9c1444eb8f3cedeb34a04f9571083408460c158f88d538e75bb8bfca7d37923aa484c7f85f86273cc6d043fd356be546642e43824b5aeab73e91e89fb9bdd64f4a4bf4ffc784c972cd47cba696bbc432763aefb3f1a5ca0eae276cfc0f08a500dcf7287c8ddbb2490c31a3403bc1e90234f5ec6daf35c14c19a389d5a96f7125729a4be6656318a6598925032c48965325eb0fdd091a967cc9073cb6be2cf703b3c846f303bf2b279a1fad2a121119c1a63e85d58e8ca39a7b59c93dcc0f8fd4e33ab475a4929315dea83c601fbcea7225e96d56382be1c7a24008b3cb1fc23df27f786fab3706d8a58db6183c3e33351c08f76b3c06ad6cfee247a02c584f3b7d113dbda8599f9a4c0107fbc47a23d9100198768b5b8da5a19c653085de986ef1d3cc4c312e554a3e843bc7c48c576f564d7205909cfce7a0ddb1c11ed6170f8a79c7049189b7c8584cb869252a1dd76277d6c1e2c0d2d8c26e6e5bfe8531bf71b61b60ceb376f0a4240a109f06b85c5376cf861e89646d53043feb12911cb1f8f4d60b013d9cd019e066a86d090e6edcde2001f0e6df34cad59c312abc9292c70f54346f3f032eca705c46bcbc13489f6258c9aacae444e5dc75a794dcd9c760a61315ee3fbac9a72dd8c4b2593d65338902f9b342664621f618484abffb6b2d6f7afcb13517574234b66df3215799ec3b70049dcc8f8faeb50e94cd0b537c7dc4c051141833e10c519208d4730815052beccea374c408e58839167f6c5b034215cfd8d55aabbb52e4e228583787bfb9840b7187706baa538bc3a7fc5692b2c366af43228ee10adcb61cba6bb6ae297a8fe415d75fa217a6817a072db298d057edb77df2d50529d1a7549aa5bd55fc75d2481b0920b34a6336fa9e034b91777d70359fc8f04f89064b5330ccc5a84ee519b2bafb34fe566fe6dd11b15920530476484be0f0fe820c2c94cb29b1e403e4352ec7b113e954edf27d81ffb5f31304d623bf38d3ab1e1504d0351375f6c224092d88dc069bc048fcad65719136d80ac4842285badee36dc7d281c2a316bf3b1e6c2b2aa2eaa3d61f53461d7747578b3685b9ff91afbcf0a75ce895784abe6439ea7542b9c639efda0345c8fdfc3e9d027aee1549ede180905610616ab97b56140d29e8295d259b3da0d84e2e1a174fa92f090b7062e41612bf56eac7c6e2e54a28fdb0e3e52ba4a07b48a5e6d455eafa185331da22f5291f60cf57330c31936557588a8286ba37315f9727bb5ff22179af1340ee5e73477ed71dcc20dc34586fb8192b493840363958bebb388bdfc8d7be34957d57fa1834c7c2dab9557a3c2675adbc9f01657fab755761f20d9f15185015282fc2dbb1466012dcefff2e859d2ee07aec01a2652a0ff6f9e7f4f675b6badeb23bdf6cf1cf61b4fb132e0ee8aa4c76aeadc45e920f13977e9d3cc879424af9f93bbd7c3dce2d60f65cc9103e156aee79f7f6514fa8bd9168ecaa547dafa47ad7294957e78ba581a3e9cd29a1f620d3128c574200bd1c089c08e9348cced5cdb728472bedf6adbae8046de273a438afb03b6a6d0bbef9199c82290ea0b9a092887c4293e80f77b88170d1e72148649762ce87d2b693c6c6167fbfdfa7b498c41166622cc094f6f4b5ff2f04fd4fad27e83754603c9c20ab9ac18087c94656cf76089beaee0522ac2575458712bad87760c671b9b40d5568e5fd5133ab291ffb251572ddcd6cf73f564ff62d91375db6f9c3a3b35abf1e6582df3ed3a0a2e7db79b1172080935e736a3513e86b4b93a0da5ead6e55ce607f3a9fb2987ddcc15ac96a0b29c39ed866569c7d3c45227fd87da616241bba3438e419156c9f8e376995db8f1cd9deab2cae3180e2b4ee180b2956a8664f0ac7bbf8d80ea86b58637b00e03524e80715574aeae21def854ca587768ec5fec1c53113d0dde3a07ad5fce06a1791442b636dddfab05cc5cbb4233a1cfaed7be1649f79efe669c68fee6800040ef21a99ff738de030f4c18fbf683b5e722ac0d6b5f8cf45ed171831f6148b0fc8476a95401af8228d19727743841c298b72644dbf0bebd326616ea4dec2bad4d68c28a9ef11df18297b0c08accc05eb76c8252116d28c148a239cb0741f1f0c84a5f2646f123f54872f1333c91324a86a9b9a5a7710130f8c3597176e346f20c91bf5553afe6c3cc88a6ec2a4dcabfe44972d131d58f2b0a611fcf9d8c3516a9c6d60fa2373c92f2cd588fc088a4ef10700cc06269f09ea06a1a9534b47ed2415e67fd24e9309df0edac8392854694c4a5982805eba1f50c79022822b35cb0b4c6b35bffb3cb75eed41d6dce8eab0f75b9c0e9da713767ee9626f18bd8938a6cdde2f4c6311c5cb78b565bb48538601ae3731e19e954d0e0083fac00b2ff2afd60e9a6d54d6bd844910d13d9a56fd9cfbff14296827be89a53b03d1a4b023fabc7dbcf36edb5afd014ca2c646273e241eebe4a4a3df191acb75a90d6b8649b374441ef37f27a036b90f1c4a71dbddc88201e08903fdd3a051ad34109c12e9d454f7e4882e015e9f49c90ed09aa3c533458c38f3a26e7c37b9329d2234e6b2331adbc834ca9db0c484b87e03ce748abbeaccb00af9f056b2a42dbc4a5a8e2d10b140568cc4fbf324a24236da2004f40b6828d35ad5978a6c6160325ec06fc328acc207cc94993cf59006239a4d2e40874db34b7af872fb67d39a16bedf22e6b447cfc996219f19435cf74d7f082fe0feceb40928acfa19d903e86a5d2dc2d069fa8b7a23ea09a213e21312463ceeed5373fe3adac9ec9f44de9b39d053a3059136821b30249dacb807f3d017f702e89a54ba354e9c619c9d78c336c9455ed4a8768fa07c600914fadb8ec842210b500612c829ea3dcd608e45641bbc7b349104796a6f6f711cca44e67527cc23038556d09233d849800d45fdb46ea18f7d135fe4e647e4fce61fcb1004657caf7aac18ec6063e158ea74027e0df798eb757bb57d07a435c047b6792c41af6e95a2c45d97eeeb98c49192b856014585cabc9712f895e9a6694f54f2f3730d7689d80d1afede32b8fe18bc51ebdaa1dc0cb1e97041bc62037909c4d600a2029e8b033587fa642952e7e7bc7607578b1992e9d46eddbf51c2493c655e59b4642df7a810f70a5a71b403bbba181427abd73dba381c08c0e9235a883cba105d1fe1714fc17b73d7f640156c5837bf027e8417a15ce2122c0c2274d402a006b7633c9efd0df581140ac80fa01413f273351909d94c205cac38f4467cfab85e3522ac7a81eea6d4e23b609ecd702c41394ca8e6a26fb52dc8f9373594b7b8d2680e8a6438c56f6e5ff7c144ea0d442da3775ee61fd3f7fc49fef21b68cbc3171ac7ce8444fc3cc953b646ec76d8b7b183926ca2c559595859ac77f28b2aca26eeb67f879112b763dc7d641d8298a986b942ed903e204875ade729484faab1153999b5756727eab3239a946034d527006c00661408f1117d9a35766b0dc3da8113d5e7d80a55d689874ecdf1d240ca1724e757c5e254b7789e6b104e61b13abbf0f071c617a9c88d29062629aa745e507148a07c0048e28ad78d1058c66bd7128067f69a9702f4b4df403b34b3066a6e37c1c450207fac8022af50a55145105b359ea776d9d02c942fa6b9e7f438a1e5a8a4ca4730c0b3d80fec27b113cf0e24d4ebdd97d3e416019b2097820cc5110eecf5e294d1ed518cf435e29e1633908b9759b12618dc11f1b45c980df1f69a4c30d9cda80e4c5f051e282da61ecad1fa0a76284807b60a083b2692d190d005ef1ca1ccc775be3ebc2c7bb016762b00d0c42caaca4fe96f81616d20a58b140f4fbac74d7167fe8e10668db29394b356030b1a65aa3e537d8f87f42febcca3f56fb38245c9bbe2fcbe0d40bb6395187124c24878a666e3857b6caf226f6039e79b0f0ce49f671cd6f0540021e89f594fcdc58afd3fe3bb54c80b17b6e8d08cf7bad44bcd3ab7774c9e2b9f94807e5f5210945794d80039a5d8bf84ba8bf756187cd342b64bdd32687238b9d3425a1ed371f3f1fdb07dd46588694f207f61d68fcbac89e8dc3486eafa20ae64b30da7076dc346f909a30a5126ddf456d206390c16edcaf0569e5d86fb15613c3d49680358d97e8b58de41c3d6768e77f43ac2a81330515c3636b81fbe2ac3d2234e464ab6b87e87e53c6adc0532e7d6538a181750605b3eb10a527709da3c4fe1b5431f7fd5a6c5aa2fd3c8e43c6a0c7867574fbc6d44a46e5c78a4318961beea1701b76d2c56e30b72880dd27d044397eef67aa5cd5f3780b41e09cd2e1dbf38fa86134abe905319ecf316a2ab8680f1467cd73d0e4e1860800eb0440f43b18f07048202be92e61c4d6251d2c561ebbce16903e1036d07a71783ecf08549a832fd389dbdbe8cddcd6f4a8bde6e6d3a8494473b043b6062d10e4d1bb98e224fc4dd0972f752c561bb19ee7bfc0d70205b64dc2ece21c90e2ce840610f68675f92846065bfe8ea6f5578679aa58d86ef1b593ef6cab6c21f237e39884fd0d381e9d5ffdb830ec7ed9ddea663e702372cac089f0e1696a0b15a182a2928ad9d715a88710d11dd52c9facd0ec34893b3c68c747392dd39a1c96c451a4c30161680e808c6c571977831a64775f5a90841fcf55c713ad831a183670b7786fd32251f36147e1c1637571200378f49baf0dcdd4b15c0324e4fa003216aac4edaba8c2033b67e9842eea57ba854012534b31f141bcd125e9b0aeaf01e9410be9ea10de22fa2809cb0ed2dfa9d68ea2b0de0717fb746da02f454cefcff2938394663e689b8c8a1dd4ebae09e9c5e5afa3c3e179a85cd1d59b1508cc8866cb2af21cde408ab04bb9857289369be7b05efc99a30710a62a361033904b24e2bc0860dcddc80a6fd62dd3808afd20ea142204c489300680e844863e91bc96cead0c2449362020696ffe691f185d7bb317b6616fa9f9153789fce589d4291b8b7fcd8f21d906fdff215bc510f71e1bc0f32d21eaf680f3234e4b72d3b8e1a3fd492611e1291d936f6ca9b1eba404b99bc38efcf479fef457949c0efe1323451f057b6c5e61dd698f03ae6a3f0e307041fb2b0fc9e97a0830625c648a79cb7e1f973d2ffbdae4ab70e765e8271ddeb1ded45586a013260ff889c48827cef717a4685423834e6ecd1dd50b013a3a213c366b14c7092cc09324da1fbd9271f90a369af806260606832c7850aa6e7359e516c39a49180600fbd1ae3d16edbc2435e09865348375c16c549f8a840ef1c31003d38bb37f98287ae8e0e25e6dfe82b58d80f24c90b56f4e960e9165255b2bb75284d3315c551cf1dbe5e1b3067a71459ed43f32ee3fb9df665b33f9c05c47e00facb95b6109d938381f9770984b8896a866a12e1b0cf317d2de99c6e48b5be27ef468458a6a7719cb86776209dc30eb69f3c4edc6463d07d3e2fd9ffa2496cc56334aa7202504127b13484cf397af895dde648424a3651af7520a6d9d049ec7fc3789a04890b1ca2128d87e2ae8f37d3c305efd02e008a27c5342a394f7e42625bb6d6b01b470a4bb3f3ddbc8b6f6cf9571a54c127df1cbc163ee0c56854fc4faefaf57e79ced328ab590fbba530d7dc38b3e8e90c52f5d522a2ac287c1e1a1ec14576ce31e76945421bfbdf09bf1263fdd7f89c24c3565ae08e73ffc37630ca7605cbcd92f77610b2fd4f31c5bb098a52c7506ae7bb0ebbad9d6d48af1de4aa65675c65bc97ba44d5b72c26cd2220c55752a05ebdacec2ebd2f547850f24192ae5eb1e460935e7c90c41a7bbca9d2eac8cff3c28550882084953009e4d4c10deb184926c42e6e1ec372844ec993182ccfc6cb4f1872889022f7305c4e907ee973b8db6d2542abffdc761afcf3ece7fb011017b1d162f35488c8288ef3a3cdd08825ea78bbf93faa395d58e7cb5730b68177e4e38af0b00fe63ba918440210193fbf52f8693fcaae83bef987eeb60eb085164456f349130308ea29ad628d6810d477e15c7dd28b9eee012fa1416a20964f3f758a731fb8d16da2eb7b6bbcb04902c35b191b20233d853fd340efbc64fdf1bc85ff45b17821cd75e287b7cacf73d0f2cf847367dc75458848bec23e34d619d529093deede172ca498cafd90973229db01a4b3751f39dc7bd571929b1f0b4a4fcc873693faa407bcdee7daf2010d1a0864fba5ffe6ea3962b58e4801fdecf1fddecf84aad7e6ed7e055f4af81d7a0ee76ebc6f38577fc16a345b62809a9981fc8a8624bc4b7ab13bd2d9c5cac1a57d9256a946fdae6bb5ef864ab7b4139b20e7c361212174e40735c8e10fa14394ff16d89ade90d4bb3fab781b5203251b7b4ac75d6bd193ff23ebae5d9f5967d0751604e9f9d6a5c07d85b1d16e337b00cf618e4168fa6fe22ea0efda2f625a5c8b639e71fc6783eab805759a0a6d3aad5fbc03804d53e704854882295652e762e7e1029b89bae665caf16b19b3de03845d6a75b914e30878a1ab7d92370e3e508a81e7d69d416b391ab7692a41eac220b7a2fac127c342bddee252148cee64b45dd08f87366bea5d67a07791141f5e47c615e5ddbf55d1697492f1efcc45f9cc8653f71a6c94f9a765bdfe5664757c85a9378ae72db20bb966f19406d327505059e540877726e94e625acc0210abbcea8bd71eab05846a44ee69c205a915e08cd831ea1745435f071e32eab50101e0852c9d89d9f93b355d6ac421ae908920e64a92bcc7e71df79395f3aa73889916b382c6c844f96d1290c41dac86f2099822ad4cf3d6009cff522e0ae16b46ff3eff2c1a7cb9ff92f1bb7046a4054e2e4100b7319f2926088a8cc8863f586074c80c2417dc6491cd62b8cf155560cef6f822f78e1e44332d3b441b2645ce66fb21d0af184a3f5b00ace3997c9f4769ae3f9bbdde5b8eb9bc8d90ba36510569301aea50a3e53bf85b6dfe8921901b8954fe485255629b8dab7423b8a15dc7cff5572b5bd2a7a8d811ece2521ee95bf2ebb607ff05d8db0988073f7e74d7378aa246c495136736ca843cac86718c7ebfd452538c9af58e0c581b29c56a8bf4349fd864b18deb6c2ef298e2cb0bf4c841b601e7aa26a25a44d8045a247f76871b71a519c55cdb0df0315afffd14a1aa5bacaae98c939f4effb5568e6ec29beeb063d6b33ae26ff4ab37b880b66e05f20c84d5a4ebde51cfe0b6eebaacd1ddb45bedae96062ab65488c2ea10812a1cd31ca8bf62ca0c8e3a04b2ef935afba496264a5df96baae602c6e46bbd186f7dd1f640b0c31189e61282516d649cd1026fd16e20b77429c9a947e5a46823dcbd871e307ef7175f3976155eca020d4057b5ea1b30fe0094a9a664b494c5f5f94fc45fe36e1449b4a5d7077fdcd6b714b2793f3af88577376c70317cd6923666b96c5aacbb1ad8561697b9d3b04b97e99e38c97126b7d065cf65dc74c0572f44c98090883caf5a91f9ffa7cec457fd4c1b7c8ab1c53ead7a74de69f26f118181f29c6c788d3012fd02d800ffcaad4b76e061019696b3bad8841e1350bca5d7286d7343263154b422ae3fb2ecd1e9bf0824d2d406a69dcf51d6319ca269c7cdca5855d79f8c2ce9fad3b15b6b4adf9899393c8607bcf3297fa34ef0ddaa71d933f28bcbaf9c1a148e93f09c4999d58a6c083ff6366812b19e08cf911171d7ec525eebd2794c8207c5cba10179fb8436a561541b97666ddbd3292db9c2d746aa17010a2668f090c2423e73d945c541406325b73cf4909356b56ec60fcb622befe91af8f1c7c5c5907e0d98c90d7e8fb4498660a9d3461d3cf766b9f0c70165cf45eeca68ef5b2de96db49ce35c01d12c018367d72b64694bc38c0106b468d910157d1477ba05f0d1d7c4ed69f3541bf518b5de0f85dccfbb8ac87d9581d4cd28cc2e0e56f9af85e4f4e01d44ad7593013e2fb8783c8cc6231c5e459831c2b239f3477cc84ae84b98208db9556e11f92782bd387b1dd73f1ace138dc7effc4cac5f4d0b4eadb9dbeb596804a0c95cdbaf676ac2f2cd49ea683aa1c9871e3f6599902ef3fa463429cb220c1b1860e0370bc0d592083dccd733e2d30804ef3a2536c6c8ea62f0d938ad980f6497c7c3513468f5a0a18e5ce45d8dba40986ef561ecb6205b315fd834bfa85bcc4880d906e8460bd306de6ac5eb516f9ef50b013d842bfffe5ec6473ef8aff474633b047c40b587a6fbd6a63709e06f94303637b458966f7c6df08f12da971203f992d6079a513ac1688ff4c5dd86781a1e7f7677462ce5307f07f6d65cb282f59d800dcc9bbd9c8ceb95d3b87c95ddf42969e0c435fbf0742698c3332cc4587aad49b8dfe6a2b7ed552f18557e44a6eebbf5c8870f252efac8bedcbe1ca87694e7c85dceab3709259c71ba8b54aeadb63ddf9fd75ba479c5eaa293738afc7097f56590d8b7f27178a5cfe089a07bcf570b4ac4b2ed274567fc7f49a1340f0918454da19194b620031788ec7d385417a3d906ffe64c7beac7a67178c396ff0455a337a4ed30c24f43b306280afb0f61f0e26194adad96346b2364611383e18b8d1b73bc79d092a37692bb1bc6c1537ec6c0fdf0bfffebc8d5d71f62a976f653face784885386a02063122480b8c0efc166fa24d88677b9a562735f06e21ea0ba039c0e7c6192b628f6a6040275810939d1dceef35498cece147adbfd261e3b760db5f4e2ce4a37c2bd2d1ade4b371c8bde5769df8ceb69b408540ec651136e52b276566b2c4fcfce3c543d11040a15024daf358378e3eb4b45234424c6609fdbdc6e0a60b03b3966202118b3875df59839156c2e995ec3c17228e859d7e228c236906f896b65b542d0d65f4e282874e73e90379e13908295e12c54915f6462975f770b5e27699807e28984272d78ed9b02b0e4ce9cfdd53fd2c48b6018a2af1fe7d95e56b520103ad22917ec2ab5f51a8ebd62a7ce2dc37fd4411fac2b69e0d0936c3112d9414727d60f5ce1942b56187d4f8dc7e07bbf4e81772d2d20b234e626e8a84b2988b7dd1fafaf2ae56ef5f53344287c8b726e2e03284cab69921abb90acf890216a7e3f14a658ee34e55aa1de990aabe6acc9fe3a31f4f08f57de28498f8e6f937a652c566745500206f53fa6a3b5042f1d6a233bdb563d9ca555de1b83ed70e2cb318984fa622241be4298bb5db8dacb30c08982e49428d0374bfeb56426423914b25cda9221a1ee2cbb0f41da4d5c5b9a48439951ff0583e975a770913f92ddfc3db9ab40697cb41b6c37a8f8cccc77a05762c78c8af33d2a7b9cb2048a11b47fee14b016e942ccb9bea9d50771cb1815d86ddd44e3b82b19ed182f621112ed6fa98d0b5fcc417b23b23b8dd2819fb247b8b4bd3d726ad75a2f6e3e97358e2d0f6fda21b40bf379c95efd8899daf460a188ea3194c855c3b2ea4c8f285a0f2149bb71ab8d8f4556228b3d921c6944ecd4c7881b229e294fb8cb1a8fda89e1e40d773d0d603dcb2d91a553b9720a4d2a82159be6f38aa69599d425a96e7ee993c3f60d9879791f50f43782fea88007ca47c3be3b5b8c744dd9ff6c101013e7a9e549741b81b9425a190d3cabd56c341659f285ba131378ea2fe5c508ce26be98ea5d54f1d63e08f129e1d306110d93c2470f34556e4790fbcb9875c966472cfa2c39ad798a5232703a926cc480055120fd477ea16fcc51130695437836b78fda3cf5ab6d562fe522cc987c32d8cdf1d5bc142de9b4a166be9b89cfa9f743d60802711a29273229fba2c4341f78ee304071e990d3da67102d1ff0b26ede44c72853b2823c7aa947b869075f54dcdae4d1aea59dba95f463ef81813de05e18902d23b2e81c623556500034154119a798fd0e3912ef6ffec2e782257b0cedf6f8e760dbae6778a5e9aada5c936ff5ef95f61d2082c0aa6efd156356a3d30194879319ab5673b10c3f82fa210a657e284b234c8dd958a393b89738dcd9f1fceead45c1aa5e1d5ea533542a2af46406f1f084fb6d26ddae15eb747cde2cccf372428ba79e20e4e70ccb6a3c8e2fc92e6bda7ff2927c174e4786012098b6ef470886d222d2cff18c81da468b2328d00db24b69150d75c5aa2492b162317254ef55f7357dbae3b6b1e1704f07f0b45f2ef2e7c80c0e198c4c4201beb3cecba3ed26ae188f22c6018a3f76653679368696ecdde0cc21abb5ee1a1fe0168c24aa44296102d121d3eb5a01d0e4021fab7e9d2259a38c42a82b7713f7443197daaac18cf48c1cd2ed48a43ce5b7506744fafa20442f4eda0a58f6f39acd4600a934a17603514067e4e8ee137eaac024b0df92826155fa5a9d0f8cef5beae0b6baec467a5f6092e6d891f463395d485bcb5716a0ed4d05cca6d3eb196db59a3e3f4577746c5f3b1e19da5acef2908cf2af811401de8b60ebb7d3aa47ec4f9ba9af6514b73f0659fe9bfd6f98c00d38337febeb1e550276e2cc69bb591aa2fee4e1f14389db1241f7b583474f76dd82250137a6f10b158c0cfdee8088a7ed1bb4fdedc940d0b30fe6da02c9560a2d92925844342c376eb33ddc3cdc3112a7a38fd1f51df084f1f91125fc61dcbad67290f971a5005aaec3cfb2c5a2343226a9a483b058cf2284b17b87edd12ec1bb87651036b1a783d56f0fcd3956d2ebcba2c56bb4cf2b3cec4cc19edd85fbafe5027df483efba730cb1feb98241ec573727afef84b84e846c1060ea48a4cc7e2d58dac688d32fe647b2d3f66c1f0a76739941ea855a4953fffe958d071e54e3249a032ee686b21e3f1bff53867ebbbb0d2361abc5c310feb42b2586f9f117efb3cf3fed84c74c0193631ea34991e2f5b432c8926b777e1bde6b465c69837ce0962d4ec336dd494cc4f310d1621d6c3fcfc213e10dfc7ba28053c2723e4c3993b1c39938a5688bd0aa7bb4d698488253a2899adbb60b8c452749044a626f3f06684eefb025ffd80c3376e4fcf4ae5aecf28688f2fe9d96891b550d5161c430e5a20da278b2f2f71a201f98a6c5f66e430ab7fda575c3c9879aca4a3e88d6bd1be289603e017031fa27f77deb6b3fa9d09eb8cdd66b7d6ff3a897ee63b7f3f19dd3ddf45df18ff9e2f8221478fc15fef037c4cb3835994f5dd44b2f6dea8ad97f4d6e13ebf5b4a62c3bcece1f5800275becd8228b08e627cb982cbf2ed8de00273ce91efef72d6203ac6e5b1a5d51fdf62d0133ee2af45794f01bd0c04cef3e733090255f19c5c08794482d59466956dd3bc282d2ed8a568c365da5562a210212398d4cf104f6ad7b725949d18a4af4368d96e20a541d1f249ed6752791854c029a98127c307f3e63ee439feb7d61a5cdcafd7a805df06da9a58268e3ac4bd25a29e7a3850663a2de6548a811d765086580d25289a78007cbef9db75ba45c613fa431785d0001423d9fe2030777b1170cbba0dbdd3433315535bdc2b3875b278669541bb8d4538a794041c15e4275855af6c2db96642e9be78a108d07f98b615181e369214997b88e59854c3769b6948d5fd0023441178d3909084782652d7f213fccf7471992786d13979b972cd15b0c43300f203e0794d248e8f7a769e7eb2187b60d2a9dc89507e98ff3d469ed627d6e5fdf65ec6d485f9450611e95632445c14d15cccd8506a230cc845cc1374f3cb58c9ae32a6e07983dc96130306e824cba9e5edd86ea4b01f9b3b86d4cd69a743a100b02f83c32b8e5d6afb88a3eeb7737d810f2e226cfc4e5c66c340eca17091818069e6596b2df6db324c522f32ba99a2f8f40d4296a83d85838846ad87a47e85acda5ed08ad54568a803fc983c7f60ee0c7fab13930106a08a1a1d37cc8f7a38c99b72b4f37df1a9ff5d9e4f4322e0c53edd987a50eadb6e6489615c047505f5903442ae561deed66fe224c390612dc34e22cf8e9d01845f426f4db4ed130a865116c82cb43645d9de84fbc427a1facbe55c5e16d169e8d070e4ee2a54ad2a2825d7f0744e948b33f4770464947480b2659b8c64b9a94c91da8f54b20f11e2cca89083fdc0e591e67c938dbbefb7bdaf58eb4e375d207011cdd696e3f87a002e68e7941fda4ccb7a13fe9f86b2f18554de8f0b50acbd0742f596f00d0de0cdfa3c7d9d03255bac427b9ae05cdba1ddf58d1f36349ee8845d0fbd49e4ce4094cb17878dabda7bf5f05acaacc5c9bfbd8af945f353e8b02f9d8a9b7927456b568322a39cd0b182808736f143ab7fb9ee68ac81d4617d80e46e157db56d00210f67dc554e4e59017167cb637d3eb6103f5df22513d3e5066bde93a39aa27e89ae44b28859d93955affed8ce75d0a75dd22705d0ba24b8d34f52d5f9f3d9d9fc98ac37d1bfd69da54b935e180a46214f7c07b6133fe9e3e0777bb9ca75d928739960454e27e2b8748370ad29788f33f2eaa8388b09f0f33e4643c65e062ade7b21c86cc38316431f2c4355f3a6c5bcf7ba7c7cb07f3d2d6e4cc4d7bf744cfda4e25d9297075858befec622ba6830dad4861428ad984d8cbd34143dd42068f9be98ea07ccb403342e3b88fae8c5933b494edb77d3cbf9c2befd218461cee11acd54d0eb2797800a934b908d80c5c6798adbe336b402c05f9a74508ffef89e026eb02ccebad1525eb37fba8c22105b0f06640b43feca340e0586e77ff673ccf2d7882dfe4c37dd334e4da8aa67e808cc918dcc7a90291554969744c4e1da5cdd62db615e2e60a53e27695ce64f58938d93b15c6b6344a851d07ce27e346101ca516e984a496100c0637de0c30799527fd81d7840450a6271704f6329d229e6fb7667b1a792df591bc00d4bd3403cb554bacfcf573bb655ca6e552e41aec27ad91863b73e97fcad65dde17abb865c74a16cec7970a0392ce3159f64e9547b3527656d280437c7b940cfd3c08adf11829196590bcb5189ebd5f6df2e43a80c32781192142979a6cd50d8e012d9c23909a964dcda40a826f18d94d99132f0aba9052cf54b228e878a9104cd4a06093bff6f4ada3566273e6efabf031532ede43bcca05fa8a3e9e1cdff0b7c7a9f8e72a74f9ba1d625c20ca9afb7ed9026e187284b2a38a5ae70b851f91e7db12c0d4c84eeb7f9d42e65dfdba0a3d9429d32f403369d64b3f5f088d25e8c9cb99b8b0dfc5d882613c216232fcda3ffe627136b300ab3cd1ac187d4d0b197d31a20e5dc7f935bf75568fad1d4e2afc48afbf9887a1e37b3b6e710dd55638c6ab577c0744ac411b4df427b7430a7c169cd1b321ef2ee3036d7b86c70dece958a1355b42b66ddba5bf97bdda244dded4118ed9d67c259fee3f07818e412a97679342d7dd4aaba2353aa78b23562b0490a35373b01d60e72abd7cf869e22527eb8588822bc5380c65d9b8ff4aed0565ae85d899c962e39401fd186f96a3eb118cacef4835d14477a81040a173425705410ac727a688350b397ea3051454afcd611dfde80fe28fa2f4dbe2ace3f3eb9655ddbf04e8b22291ac12fbdd9c1894369ebe0b68fc27994f1af8bb8a3c79e70dcfffb8f4b7ea025c44bf37e75d942af7486fd0acc9c72f8eea58e8c84f8b2f5067ba072791178cbafa12816e43133e50ad90ae364c601b8fd871dd488b623ddf4f86b71de15d650d847c79b61336c1a20c2322974b6e78442a3cb07d3e7ed3e85a6cf73503bca4df65fd05e9403890dc04dec9c7e607887717a9c95da51ddc24bbffa2d106d93963771988e5d0c3bd7eeb83732527f6ae4b17dcaff188ae7d340cd64b8d12d555e97cf54f931dba38f51c4cf8c723173fd33c3d9c2f7a18a2b54a08413cc0ac93b985a1ad19af3d040dd84aca72e1cad5265d90047c89d2010143f0ef09256539818eaaed7e625168027e11023f0d80b94a223fb665ae261593f41db45f6d345e635a58e90e95a25a96b1704f4b0e0f782b14ee652b003295d663fc8d1beb9810d6fdbfa5f676a7228ced99169e3ea4fd8e0bb42d814dbe66f5712b8f59037a278b9135ebf64a4b4227af64a112cca1ed8fd576fbca238c42b497605511d289e1396192cccd996e163ac828cb8218b859ee052d84fe2ff8f24f61ffd2dda24e3b7d8649a32af7ea39871771596f6134852a0af06ff1564397a12497c259b3655987dc93b499785d00d6c382c8f2ecba0e6f6bdf7bdea4abf1ca39d418223ed6420300f18751711ba6e5039fe4557f7f390f7d5e12528aba979fe10913f8c3280d9e1307e8bca69ae2b7f06118bdecc7ff8cb4c01c355314d26f7708b0636453f97f371fbf43a6d136de0ecdc17e71cb493e8c9d9dd8c62cc7738055fc0076a6170d91dd189197a7c1b8264922decbc05067235717bd92760142e728fcf4e1e42b584f366aa07d41e3d6c83d042cb535cd26f2f032d2e50cc87a7662de6e46dee28df9119463194a92e68a6fedaf8ea00c2512116aefd3bddd56052df5d2ff0f804659b0c3754f21a8d06e5f31ff50f4d1961c9dc0d0fb4c056b150d98cf6f23effb8cf38e74ae45159244d5d16801eb0b66d10aead3e62baec19626a2a6975a2d4f936cb2d9c1a85e94c7244c3b70691866e0626f98446cd4481ac12731d2e954380994ac00f877150433bf63e7ebba436dc7352efd9b6fded908de3e9c4e17a694dd08509abe91b3bd3c2e40dbbff3c4e6d9a4012a84a8f4d698517169ed14f9f50f3a7a0ad289977851d3f108d93c1821302a3ff3317cd7448d7bbb3911ddce4f60d2360fc4b5a2aeb8cce9652cb3fe229f2afde2328970c778c18e79f13106a1694ac99ce1e189bb0004b1793741452bc55e1018acbb6dde4c11effb245bcb15d0490513e07ffa00fb834f4563f9c6813bcfbd489fa5dc206e2fca0a3b6ba9701a7a98dcaf12a128ae30a5ebde4bd053cbb2433f2877769782ae5fcae5e20cc6f292a68fb59e5865f7fd2b4a9616c17b93b64a1bb9d26f68d028c6d6aad853c983c30f463daff49b9225b45361ecf14dee169a8ef21a9ec2471675bbd600d7c91905376ba90a0c5b717ddd54ac548cbe035f9665ef86383f3dbdc747b3e40fab12a07b3be8b1fd6f937ba31d98ef3f25814e7d2cec6ce764cdaccc8536344952b273b3cc07dff0a8b7b23f389afc098d2f5cc015a87d40e3431bfa2205caa1b58662e8ae0e7f26259300015d6d569c30c06ca8c1603dd41a339fe23f948f0e53427feea010f1afb3bda0711e2d8e267a3650926cd4cbf8ce230bb3e6a766fa4a7c88625b69fdf700cb61ea27521cb60a5cd306172a74f397fccc2d62ba73c1fa24bda9bff138a99b281bfdc6565ad4511f21d2c26572f20531e65b87fe1a7cab6f69394c230f3c65880460b83fd9a00102ec033101fdf5685b1b5a0724fed32ec082fbb4ebf47011002cfab55a4c022925afcaa7529e9e9d1a9826c6f3cf8c8b1e30c993481cecb8f91cfb7fff028123f210a11482b1bcb93ba6c3d5e52226705fe94b6c5762ed92d0c224db58953a4cee16a337ff3e5b9246ce919d948a660e58193dd3ee1b050e91600869941c928b2837675d2cb5b2a9b46a647650251cf0e6a8c446560a779b33eeaf415c38d649dd2dc6beacee8eee62544a433bab7e75881a9733821bf29a75a071c42fbfafa127931f5315d07689edaa8157411fe2421e0ed33665b258d0371ea16d0a00d7909ac7060f58266da350a04fa77cff12adee519b13713f79ef98430c0204a673fbb8f5560c26b81d4926770b81d7b754fcc98e83652463832504050b47d1a68e212a8cae88b4a420200eb015070e922c5b90f600b00e9f4f280d21386721b44259afb3858ac80d4a0e33cade837b3fecd63ee312b2f7e6c70d2cd0c15cf5270b51af92d2dc408a00ee84592a8bee555f056bd989b72ad1b099a449902d1b7593882c7225682072c2ebddfcf4f601ed2b5b1ebd5ec609dadb96859ffbe86ab6eba027144ae39d1040c9e17427f26461852918bb09268f75164eeb7a393624c80edfc01b3c4dd67669e973b57c4fd1b57686b158fbf75a47ead58378a155f0ffce2839a335559fc8912b95a3e7c5c322fcde814872b7eefde7e208ab6caedca11ce3f24259df7d07c27cd9b8cb4732b6bd68985fe8a75c0d53c38cd4521e7ee01356386de79d09f780417a9de86ce832bf11c3b967e45d93466fa1e37578e67613f7cc84c3f18625c5e2e4df75aa5ff8a571007322626b0a3735b37251b8739d365f2010fdcc566411018b30e43d250a66f6d07c2156a0eb2123d7839da5b620a000ef50ee35865e87d15ef5a4476c5b2b73c330b6905affb9a041b40263c81166b378f4258b6c94758583cc9e7576014416454385857b35b60aa4ce98b21d9ac222f6b5f117659a23f2f17180d7b58de055da940344994fad8778a5810b054563c36045b4906311605fd0155687ef10ac6943b6e184396354c621f6e8854689ea224709586d0724922588acb2d336b8cee10b5b854c06131f43f36ce2165de827e6a11acc69b2756c56ad5831c4babc0aa45f63b8cb03736cf44351238ddd98100dd4aeaed714f57cf93ba6e692ef141d5af13934ac977d999672c5fd082ef7633ae217023e018950b0a2e5394a03ccaa6a890597fc133a653517ac1bf7cd7d54f360833892c695f2af5e60956f6ca1f22e5b674a3a1ecaaaebd170e83505af1f7890d1f6486c6135c5abb5310fe06e056192c4aa0d530d865bcd07726038155811ac534647a60bd9f3e166519c8b329516ec680d1090684e9f3c851cec5d19e4afb8059841601c41f99415e99bc48338f302051111a5efc43792df9cb8fadcea0aaee2f61705fef54c678f6f9855a9ea58b1d1616a2da1a3c09fb11faf8790d3d7a75545e73abfbe28fdaf9264ae121e65b0649f725b940d99e1c2ea5beaadc9898e1e46a6ad35496ebc1a179b55249133b717182bc3a1dce8cf47681fee6641b2b104fe6cb21a6f7e981bc95a227f3e9bce111b06c071e20de21fae05d435a2b8e99bf574b01a128b4d73c5ed71ec4509924ed2f1af0aaf61427310d98791f1673af420892f5970b6587cad3db3c357b4bc744d6789e1ad48da11ca1f44c1887cb2c4c5960740ba41ad06cbe0ae7085fb2bb26dfa9878198e72ab78e44bf391c930428cce2ce576680cb983c9888b1205471bb4ccfb3c19a00fe8ae74005607f965c529c438f02bde7bbee4e5813fb68be85220bfafffc81ed49752df53122c1d379d54ca8e4612c2ddd7f290af8f5b20d189ffb45d7451f36793accb246b3d5535fec2243dcc6252f9420a3564a0872968321ea27c20237dd0ff991b13930dfb5ac0508ff81e8dbda8704958c9967760190003521f47fa6d1bf9b86be2f4056565af2e69ed6910884cbbb2612a7cd5e667177d0cd6962aeca0b592ad443532ae390f17783c1281b2ea1ea7ba95a0269dfbe6777bd98cf358cf33badcd7edbfa3f5d2aba1fd9115b8a62c72df21f8d5c3325ab8853df5512fb2bb6c139cae7acb6e35841d2a05b587de5a6a4bcb7be1e5e6ae33e45dcb3c747230f9c73e10264e9748e677a10c2027378a26718650d04449a31aa2163709812c7c1291aa0e8d59f0927e3d916707befa95154af9236d74d657eb85adae27198af59668670310dd4ca52c6cd374c9cc9e7d5fc9acf556d5e2600cc4b10df9da780fdfcb854ef2fdc6824cab59710b1690d97b3fad816bb4c107850df91dce7d39317a70efba8bc1224f63bf5e36b23040b16c3b89a4e85f30f1d98f5ff7e4f64ac692ff8f0010ce00e7d1b15fd299fd7b78b311a2baeeff311700d2e646076f337a4237e7a27446f9dd365000d1d41db371bec0f3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
