<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"373eba05d26c1293aff5a015e168682a458c02a88ed24d7036005476d2333a94ac4065e5b58e58721a1ec4a3dfe259863de033009db3a2a2762235df7cf35b1ab8bd72e78cebd9d868437c597eff98a4f8b0561b980d54439b7d2744b56273b5183d68a98a5f30942f88ee4b7b61b77a12b8a34d3307dbe5ae95463d56d402b4768c3c7844c65b023b6e70d6008477a866daed9db32d9701fd288181d35f816f21a5f0f3687d8c7eaf35d0e096e7560385a6681301db5820b12ddad093a096fe22e72e7ed6c965f9146e3adac3d765f23e019f1ec9ea14a43812b1ac0dfcc1649370a2fdc73d2fc82bdfd4e13339472cfd73bf68716b1325320e955019611fe8832c06509a1afc97450c32b6050bf6684b3886570d58cbe11869e092286d695377289e64e96d977e76a9a1953f6cb5117ee89b6b2409153be2705b3039c8d70181e84ca5eeb628c67014052d42ad8313591190f6a761a7abd0ee2c88dd2a3603e29d2fb5e3bf639e88bd07dff8a51da5b869f2a46c02313817441e02772fdfcfd5f804fe92a7eed3742a476cf721bf30fc70bbfdd69fb758f1d35e6db0adb61c82956eb2eb31c844e31a4b70297afccff03b0dd85520f10099e44580986200edcc6d1173005bc915da9b1fc85dfb15016ca9b09669c02626141de81381c1b999856b63903edaa24a15c6bb97b9e99455be7b1d21e5360af28d6adbe5143cee0727a219dccf26e16b827e014d721be25746076e61b102aee930581973a6206c85e3699f61e16d9b900257c751ad7a7bc9c06c5a7258d7d39cf18d46094a9c7ee33cb23aa342a9fade3c1b7973b2b31aa96450a12355566165d9dae74e1d8c6f414b713734327b972bf83dbc84d8c14a30e9dee027918c9a7fc04e9638f661faafa7d7692b674d0ca184aa06d0c1b1137d45e0e5016c055e9df69986dfbd5ea59da7edb6235ae84a618dc4050aa2d22fcf4e4490a4e724e2175a97a33fd8dc5837a487ecbb76053dd3613e053d3ad5f760a56a47bd09a10cb28133119d8731083180cb7a79288decff946aadfe235173be5e12330542b3251658d4f058ef3ab58f7028b66f16ddd55fb3d9ccb55e74f8d15c777e7d3b224722e2b9c7aa1d0ff246304a38c8b9090a6443ef015869257174419a6c36c4a1c5c0304058d8f63a3f9b42061900da128228a0a05d7f54541c1c7a999949a73d5974d578a36ec5245d209c1e652e0e39ad0ff44535e4b6faeb6158562c586d133d78f85e1a3e5064b691335044a1f9099b71348ad625e5f34c4f84d41001d965d5de1dc2dd03a75accf9496d764682bd3784fcbd311b2085eefc0b6227d44e85ea2d2cb7fb7ea76775fa1fe2aed2c3c3631ba6c54ca6d8b5095c6b61a412976fa8d68588688892fac798102da8890869c54c7b6192f6c39ff529180fbf0a248aeb02dffcf06c1779b25d12add624914313121763bd49ee098bb871c3c1ebe85fe356f53b8292809b599029d43389a4f045de9a8347b722b9f7d586fe06c25130e25209823b5ec47c7349b2a874a77bf7d470f099c8d96fff7bf94e07348d066348644635b0f23f386f49563afc50c9bf4b32e298a3ad2dbfc88a947c1de19821a0d1156289a10ddd01955077b93103e2c8c95476873490a81f9769798c64fa73c896b2c72ef50f5c859f5fe7e65d074499d80f4d49b678049d8948a0257a1a7c5ab45695d43488447cd8fd4236bedd2a496d8069d345c3752258f2893fb526fd87203054a741b84984e6e9bf46cb878ef8c8592969dbefc50e8bf672416f121778eaa558fcab3597ddbea5e58a50d8917add6ae9c77e743c2b559fd3955461416455c2f3ce04d71c9b7e54b40ca11d2e54f0a8ec6f2067a20e678c03cedb083a192f5fc2a10e40c5bfd0699d358def8ba0e95b201b3691dcda2c5199759b6d65621728aba20246713824739256deec166732a6cd1432a3fd8ede4df3579b086ced47d3c2c71a416d749e49545d76ec40e88612299ae6c682beec0c34764994057022709cf014eed0d71996c8ba48fd8e1957bffd83827bd8d43d21666ff2e097b349a8c9cef92e534658460baf823ef3dee47ac70497a8e3504e4f19ae2f5d42fa7189660d2c00bfc6a8aa677b59ac563d5b063938d4363f3b9d355d313a47076fbc54e2eb5dc6eab44bfe1b40af8dd78d6f4c43672f5dedcfa4736d8413a9698a2e4965baf3b0e03bee6c1e45c6ec31b3b17c1f10160914bc19c1a99d531da2e49e799374162e32ee0f42fc385b706ec333eeb6bd07a2f432b4ba9b198fd8aa437744a40916d25c5d331db5f32a529c9fb1554f3d4d58a7372f5248957d679b5f9d770cd653859e728c67e1afcf71082798f83c5116ed28777f8d457663ae5ac88cfd29dd0426f4aa5fd199cb24d2423f1fa6ec377369e8129abd069f3470acd8b8e6cb2e999334f79928cd9646f98488878b4e5f28c7e901320773a769576630ca128c0a8415e98fd9a9defd4a1c49eb900f7ec71ab35cc32b01478c066cdd5ba286d92e3164f7a1afad3acadba8e1a1545c696c449b16975562c2c4c06cf5f1890933c0bce90211132c0919d90b833e3f0964216eaa899132e0f5deb567ede187aef930136c40a3ca3d1ab5d14ddce2090a03061f6edcb0e13e49cd6e77a034aa6244792cb3c37a9095de642a15802c27cd7f66b37e5c249641679265952992f5eb337f94045c7b01a8e4f7dc65b07302c99cd87c3c06aef315f2538d1d66397257bc9b38e26720d4e4c8c30fab9c248569a1d4fed4db050dd947580c977facf54e600f569e6cf443cd7b673b528c1c60b125002cd72a3589d70cae250c589583131b8301f8bcf147e8a00712f62e3c61244814ef20c4f69856bea5ee23369fc7e0246e57d562699d748c7183c17a35c0259f8f907770ef7b2e4811ad412ed8eda31fa891f3684f9eaa718989a44a52db2ca463eccd00cf948f5c50bab44a7a2cac50bcb751b2f1a1287d26f602ff34a7a060087cf2d8271ecfe8f127fb2e0b0b4681f0f0c949c850f6e88a0d65ff217c3840ddcf79155ab14ddc4a55b6aa542f914ffe22af66e252bfca9550e0d283075db213f86ba155d906d8941a1c3a9403b81bec4ef1f8c4f5924b497e2218106c55116467c10a9e75b89d0d1ec5c9b0f384c8692e0b21e54376bc3ffc5301a260068a5aeb3b17763658659dffef433b36cedaec07941499b7d30904a3becc40802dca029ff262473228d096e25a0767ccd192bae0b53a40bee085619aa270ef1026cd5cdaf78280a0073b324c370821b6a919c980eb7c2d6192175bfea8a8b1065dfb481feb6c4b52a61861ba77fd6fe8df607ec7deb55d574cf3d094ab9e87e5fdaf559672568d3fe4c5a1b8ca0d6ef2a25f60f97bb0924a765ec913a32e82dfe7ea8ad50f3fc765498ae300c9ef2241b57aa5166110233f85326cf3c445f5a42ec3f8aadd153218e9ada0bd472e898361473bdd35fad22028c7c5d7e4704e2f00eb486754f6a2f6ca5cc2843d36f0d1652014240f3436df5d72695b30462fef8ca6a0d5d2ed8bfef20436f82824a49c64b45c57186c3ba9f885e69d277f39e1ddef9fb7702540bf63a3a38dedcc856233f900882a311777481094f45a416bf9d2cb79cd5ae07f7dd181e013d2aa8b7c8277a4059ba483704ad199b9fd687c5ddc0aecd9642e8886cbfa51b31a03e7562d03bd095c304543bbdc53bb46662e80073e4712457f4f1e6566f488d6dea25de3464eac75a7e54859c290c872322d6b34c4816e479e8a9c1a6433d7ed79bdf2bbc3c3ed93d5e9b74d39a915af13b2379788bc37133e9f989888d2dbf2d4c94cae5d4cad5f895252293fa22ce22b4bdab0bdaae513420846985c55acea6a4b6325fa7367d1be9b2e8dca5c25f6d15afab31d5421461dd3bdb71375259b27ce7579994e94fdb36fdb9f94e05e3e420c30f5f862c70cb2eab0b8df68bcbe711bdd9facaba2faffe72de4b9639ebb87d93e4d0f3a7a3d2bfdf5649060d767d5bf150af8d4152608ad8c10a0845a5fda5add794806cf85dc0ed97887c036510ce09914cbfac7c34ce2b33b1ff2da6cdbec3f25ed13c179e4080c217d741977d549d2cd0deaf944f0fd43339d4c8f8113563b1ffd1664828513911e24fb2b5f36c775115a20c496e2751d61344f9cb8b602bedec63797b5e8466cefd4bfe98abdcbc86146396630d1717113497817996561f4398c1f8d8cab93c06e588d81a3e7dfcff013aa3c5ac9671b735f3f42f60e925a829e0a347f14973a5caee893ed9899a0af38bd04f6cb65bc5650acb80b99129c303fbf7d3b25f6edf973d3270512dc04b3f6b4da27d033663bea51a314593ea8b710354f6009415c3fc0a606cccc45baf1893e37ceb15931a32a2a8098415bc6beffad0287a86600dd8de7a5a5b2a29336adc96a6649bc83b9a70db5b54d16eb2225d1abe5e998ecde638fba47fb20534f5e8f23feaf043b301a0add369f2e2e3cc2101ed8d60f9f5773d92a16200ad0f3c9cfbc851ceb92f5ce9cc72f1dec4ec8b0af30ad9c23ec67ab221a3957211a1b22fd108127ad35b108125abaabd6a3986fc668b92a18fe9552d61b67d1235856fefeefe24ee265b25041bb73bc1e2857d436b266259328d6e7ea4b6f8208cbb50045d161ee87b79efd7a21252819565b9b2b8cc80709e6ffa0e2c5b462b1cc3a0958963268b17461f16407fa3d0cfc1e7a6cfb20800cb3350ef588a5e40775fa68185a0f0969484870e0ee032525e1c185aab98adf245102c4b581c8df8306f447ffa3306fcfac08f5850b8a57db62c40922fc94fc44e0f18428c4dd8b448373e9c986911e95dd0dc2775705fbfaca6becd6863741711343fbaf3f1a14f0c92c36e6d268649b60939608b29d50c052a245b60a1fc28e113446a318f54a5b999ea896dba21ef2e03f32a20e63b92b07d091e0757b968d4109df73c11de6b442317bcab95b9012be4a477bb7f9b9ad8af6a0792ade5ef285f5435e166d6c8d3ee9ebf07c47d0deb2596519c797c3327b3f11bdbd43a35d3c51a9349e2415e8de02864118c1825ba362e6de557e5aa6815906033c674b7b486f5358ebe1e8ebfe1a116da2423e4377824b84100e0c4ea99c9566eed763b98155145e80b3315057c6b3c435dc91cb53d67efabe9a108ddeb082f026bc255e1fd8ff49a35248edab0cc4caa1435cdccfbe422787a2ee3c530eff8a1692e51f8000862fb8a261d458dc8b22a07c5f83b00545f62f23b33a9044f1ed48f7eb15f6c0047bec9594163206d25d8452b7ac207e4d72f0328e9ea139ce097e4d441d1f9c9b3e51ce7523ab67b8648998f23ba84bf939d39aba4c422886a063ac23bdb57fc06458da697ea6b2956c1435579cba0142b5de1b239d9699c4a7b0f21321090fcc416e312925361306f6a2fc1dd1bd0c55eb4dc6996c270d6984947c0cd351e955467ca7945562ba5876557f0b51115e0b28732659ea264a38ce9bb22cd321dcf630eb18fdde78905ebfa01674634ab2fc843723ff2c15d732b6df009bdd92c225583671a84c0dec34eee3c19850d266a5b7c29b030dc5a06180230046facd1b2f946066d9252fcd8039d9b359f50f75e63271e62d95fa7d4e55e1bb0d28d50390b9e1518333e5902347727206a10e31d55eb5824cf2b777c1a46d0967382fec9c3a84101e1d6d59bcde6c926deff1e738afa642ca06880b8159c7df77aeb665c968cebb8f8e4317de29d4cdce7f9a7aa6997df74f0cb92af444e14a7ebc90ed9088d945931aa195f381b8fed30e13684d7a9f5e75f131e81a5f8cb181f2de9b743f906be06c424f1ca5c6f8a6a1e8e7d34d11755988f176e602937c154eecabeb680dcabad0aa16c314769d40785cf984b375c83b83c7e9b507513c4963132ea807003fb5d1f4e2464c26fe1c7aa85297ae020b3e4bedf3a5cec9ee7b1366b49b0b8cae95e80bef1ea647dac74dd7be655ddbf4f746e77eacfa671dc5130164abe8eb8f6f61100bb452155592e9b4026cba519ab0c8dce204c3d475c171a2c69ecee1897a586f235d5d336f2f1b6a04fdb26dbea02d40cac55f78491ad1b7ca66da12848d0eb979260ccb8dd4ef686fb2cb34fccd148159c0135ef684156db833fb0d0c87954b3f5d34ada5c04438da9ef16d0364f7207af28e32a1ebfc15f24d43b1b871548aee43382abe6cfaa021bbb535f20e4f5458c03573af6a18f5f935a9a004675b965007cf0239dbcbe3d07b1a40ffcd3376cfef21031fd15e20c1e52e2fd1e5fe25a660cc49103682727702e8a787a71af85fe8247b0b5668a23792153463e8612b66632493e06dec21fb1568637f4e04fcfb7d796385899981204cf892306f1b14fe6cc4993ee4bd794689168534e0e01a4057b93b8333289dc84ad61483b76dc6d4603f288a68ad672398bbf12af201d8e86fc8ac391877510da279a507d248a4065e2a9326875b1de7cac7ddba91231e7ffa147e6db2e43c16d1768a8273981a522e5ebcee4fbda6ad41a862dad0d119a759f6a47ec492e31797e2058fcb2386762bafbc85c2ef2eef72271c80844dea24e2d39e5b6ef26946bc6978d802f544a3860e304635dcca14c5f62b05de6e87129757755c474462d0c9e3f075c36013ee07dc62bcb342fffb6a6394f200e4e119a384999299fbf7fac22ac360536f9951ac0677ec6ac7584458ca231d92545272fb87581966b00b30294c308c2f3c9a68eb3a880c8afeacac59229275951f38bc486321a2bab6afeaca726a9e138e9e2e3ce89cb5d25242e0557b03be08d37a203e4417af1b4a9aa89be5be032d1d38a27a8720d506ff63888bb50355cbe503e7e22961a19b41fa17bec1fa5d05b3b47b8af454880c66e4a3005e2d5cb8b591e2d53f999d89dc5bfcd96c9e669e960e638439fdd0b1bed78f31366e16ac171ac3f8c10ecabe242cef0ea3cf260cce138236c5c2d3d46737a3ae0232494085f332a003d1be6feecd3afd5711fc8e03203a98e4e8f42ebd99530a0e2d8f02517b43dfc0830cf16cbb6d439cb550d95a8a4a8995512ba3bd2332072eede89f43b99e570ebcb0e143cd76a2d019d043a608fe9ca19c5efd78e253178ed3eef10acfa4766e43d58279927bc7ce753f25c081a4753f243ed0600b786d282c71b1df0aab3ad34347609ed8704de9676d4a640c3d7950d26ea240cc2e83e333f1d1faba100cfe8043728680bb423d7b0e055e044ec5dd4e41223a9c02dbee7b90655695f9c6202d9a061ecec566a880ec8abfad2131ec3dd7f9adda37b0c1600ca3a42333a7128a61e5f1877e42d23d7d46ccc69363e58192f15cffaa4f37803eac6e9d39bba33e4a7fa6030e06f89c490c81303dde920338aaec0d6c4c63fcefc187be0394ec3ad28b3ad0c824d70234a11507776fbf2ee7269cbf68739b88901bedda547cf7054877b6cdf774a1b2a77c50d031c560046c6fabee8960e1e0e551a1d47b6bdd5fc603b80b3abeb4bc3c2af73d06a62972e09ed40bd8b931fbd17735199764a2cc72e5b1cf8c1e9fe590a64efa363486ed9335ee80b3b2ba23723ba595c7784ca82171fe1589cd9795529c9b225cd2c6a31050a9ef6ed9267bd1e43a052da86aab6894e2f23f403fab0149418d5106e2d1d5e4d5877fbff86c2c766e8494ff73e26c3f1dc6e07c8e45d490254978103f849721aef3ad4d614762fe28cae5902bb27510daf370089bdc36f8d897170ac382c7f304cbfa28dc9efbf7127c6b2903cedb6c1f2913cacc3f35fb28ba24ff143100bb801aa0d81e25813a122b7ebf102679bae6904ec9037f9f57cfd13047aed0540f28d893f4978f3c794edb80b7573605fd7131525ccee253c61a5f89df88387d4f2245acca2cf59a940a9e749dbd9624eac3d24077999d2f778b38220919fe258316922c2ff51750c430ce2a2c6ba4650df92014819eb30efa03b249c704de298a2e0db1fb5fc324c66085c1e132fbd4d84ee219462de26edda3b388f8e0d8f572f15d1ce05592713726c1dd464b846e00349ba96ed73ced77c64b19f80a53996c8d6f991215f27889c332640857d9d872104526a912afd0ec3ec2fa80fb60248a12ee12d4c9f121cab4f81b5336813ee0f0d9077b7201f64dfba579a162572f467c6aa67c03ebc20b3f27cd52f14a977fdf9be1873bf336577dd99b94c8c1d091220e91d71b0c3f628ec7297e11ae78e93dca5430ca37e1e089f2368d1ef08cb0e952a72917ec2e9c80540be40a962d92f12ec54f2bb8b0fd36849a13ad9ea39476b1116b64a713ed0bd47d984c8b4321ef45e8d51e0811945b7ea9b2106cd96be9ef8035dd25e159f5235145ea7f0c8df81124da18b57ce78b933acaf2a3789a085a54a969d3d2b9a361b350b013f4796df35a2ae09b4519e6dc5466f349aa8247f9fcf66dd9eb58081421c8c5d8868f39b916d733a27db06961adebad844bac3c9bb0c0d5c1d87830e8730b5c0e0e5ab1662d47c11fbb03e9ec99216c3cc7d070c025fd35bbbc584b7cc7444d506c6d6e27d0a4dbb0c0694801c49ca333f331175a3c8dd3ec5afc674c9b9f63b2cf3f4243172c587264abee8b1d1480a91460e09f7122d1d82b9cdbd362fbe21448acae8f3bd000f60da8710b266b63b017689bfe81177b6155464e03d92cb646d3d4eea37cdebd45a33a0b5764be8b4eb43b7f4ae424c236942b94cacf49358d6abd56da59e7739146637a550670ea8e8a85494721916149709658c856883463349b15b722d14400f971f58552b107e4dbeed61cd123c05656051f5c12a6d520f07bb67671766dceecf735377593440c9797b78a8080961c5eef0d84458a657427699b59bc243d59212fa64112ac4eeafab9e2a2df57e20e596153a16273d5b17a51a1f172a8de03a0adb4fc3aeb0b1581acf23f2c7c8a143b2f1472e566b7c8173c3f1c44f87a2f86ee064703ceb5c1ac0ae9be8346c3bb1e8dd1c0c33c25d97eaa8de4f8827bf92a1e98663498197bc27546bbeaf0d72fb0f08997e50e8aa5e33e3ac3e9a6f46d162d1801c4a6e24b607cb126cf667cecdd7c2094f89a4f348de18cf10b2c530ceea18de72e976e6d00f6457db6a7fb267bff78c4da9594ef37ad3247bd873a3bfd742d14884ccd8a21069d8458eab7412cf95b61fd0eb6683b36fa8f595e7f01ecf0ecb63ccc77e844eddbc74138309ba14ea7f50e91c3867031cf7963a1d039abf4377bd4ff6d0a9ec23d98e7f6964ebcc8a330ea60d40477720d90e5bdd2f7b3197f81f5e73acfbc2875b0f3c04cc858b14ed310e7ce61466d248d9655b391fae7c4c34e7aaf8e7dd79166e886f32d42b6973df7b851b3a97dd84dfb55f3a6e697db124327b011463f6de90b1ca0f7185cb3c0e6436a5d1abed0b7bdce58076e85e1da93a65d702f9ec51158b87e23063526cef1d30521ae47ae49c3b45b200821e7a0341ba8f4eb8b479b16b4107f48fbe9568557e1619fc3b805ef00d9d11c899f01d34533c4844407573919a03c842d383a5d38bf00f651c666093afc1db47ce4a43da3ccf43200d018f056073c278e905f15304331d4ec4527c43007af7094c75f94c536f68d746b285ccdb5cb0bfcf038e7f6047178b374880cbc2661c305a85b7e7b66a1318f9038a4c5d4f057a6809122cd86385637260e6efbd65daad64e2abcea4781e88fa30f7f327a5081f03f980fb658b0b2bf11e4f53ac319158b7fe4280ed130f5a2756fb91b68c015db364f3709b2548a35a5428944e6dc9962fe9a9ce4ef77cf1021d50b3c789d0f9ecb7a595b1187f7317270b064d3181c1aa8e6e81e02f4770fcca55077e545973969406ac8d894d2bc9863ec6bb177df8f903f44d19cd48c4b5d54926c5a7e6e1e126fe673e85fd093ffbf4d6bf448e55f18d39f2061d5cbc43626c13dc8a5e39671db2b2888f425fd5bab605586087f4ba2df2d9886c6610d3993e4142549d7da8adfa0ec728ae1516ef68b395378e2d7990259a46ceff6d546f7657528ed2b3046c547ab39c7421f6279bc3714e2a2364bb51d081cafe6c9823d6f28e717d8d71d137634b9438581c1f8515b9353b975338a1aa44033ae4f4173082aab31a41af03db588452eb5df6692a29ebb58c7765b76d60c2a82a9dc3ee5da568cb89a1086ac3f36895a91f5da03130dda57bf18f9be718094887915cb2a3187f8489890ebbd4273ec1e6efe71a120207e5cec126f0ccd811ad5777591ef775d49ccf6bcd6e509339ee9855846883baed2f0c3f18bb70e45500a48a5b349037c0a441bb4d4b44223917b26692f9dff35fd9d9688c0aa88a8b7fe58d0db1fd6b7aafbe986f8a01cca80bca94283503414a31fd56b97161823d8fa8f327665a2ef0466942106946be49fdc55f3a994fb2ce874f4c75a99bd42a1618adafb2798aed57fd638c0300c1e7843cf80526000836f862ab4ed900e91dc1ef6803b012ca09a9c9099b60ecdc6e2098e9c521629c69ede3051c0df471c6343f8501380e981095d34668d263d0ec97f4fb9cbd8fda4c76a1bf707ee5331833cd4ddad989613b73a7b15f22d45524cabc5bfaa06b3dc6ae1e6a3fc91ef4bfe826b05855c69853ea4488d5ae974448aa068e0827fac11487cc4fbd0a3e8de1492c9ce5b52db4e484a5a846ab9147a15762d0ac2c0209afda72f2cd9a00b0c33a09aeb2503c3d02b466659080ccc5689c59b99ae4b08893484f909281ebde51286625abf71c9b2e490daca5f8cf87768400594de2db303e1ebaa7211bdca809fda3b1c0698a1aa884ce13ea87e659c0e20b63cda10348128d07bcc32669bd3bdda99677af06e1b2e0f9d59ffb88badc9e60de603932d532a2dcfc578af759d7fdea916c516b00faa35cecde5ad53f9e2732f423b85614568256a18b25874ddb783830aa6a27b30930f0e00293cb85e5a44eea77c444ef58b7011c6f943bb707c797cdce11158539511dcddebcfb3884e5d48a023ea412a2c6500016b835060be4d9b3fb67b56d9a1842425cd3894832b33b890cf873b1e1fffae433e352ddbfd58bc48361af76472e8925151068a907e95b10de98ac5704eebf5949f019be6eb3e38d3843fbe31ab56e90d8a3222f4999e7476e94a3eea2487606414f7721d9492535adc04ac6dfa69468d52445dace014cf3e55c86093e8dc87669ef3f30517d1b9a9b1223d249447c2cb087f0ff2f4aeb1ec0aaf75560b8cd8751ef901192bb6b1583e035e758ed580e7f2099d7ca13f42ebac6159c671ae694853a02609fc3e7dd6548fa3574ed1bed659dc5cfc98f8b131a87d844142cdf5e4aefda6a0711f00c97c355cdf4ab2bac250a41a64e5a84722bcd2d1c8cabb40c943c57446073d7a408b762b8861b1509ce083cd3cc50e5474a1fac2dc586f57984a57908e56c218f4fa05c6d9542759a0829c8adb39dd874da0066e22b4be32a38bbfa6af8e7ecbe3ce4ce7b14217c85da0ae0851eba0467e2f68f209e952e7c23b86eda4bfad263c7922d5bfebca1a9b01cb64f723f9d24a89cad18fe126b73b9fc3885219e9ec6c8a99a487c389cd60e809a5601599b27413844aca261d5a5e3d21e0a845b93ed03bcdc7bb5bd97f9cf387dac353ae00cc4754c5e051a4afd10567712bd4a4059422f193e2bbb46a1bfb2f6577060c89d1f3951d4d961610ba3310b5e7f3ea561f09249fa58c8805b3353c738d260e321b7f5ae8f51b79421e0d7606f91c66249731ebe8a540447e2cf7a0100f1402c77571e1dd8066174402dbb5097ea6d661034e55975fab09e0d937bd7d5b07ecdb1adb1bf53a309144ed117b4f118bc9764cd9fba70b7679b573f9e79ec54040e87dc1d1fc9aa72cabdb5e01e49c599b2de35f9d124925222dde441aa7876c9cb05a9c653cfa2e815d480e6e0836ee4e54d176a9cdb8a975f75e8a5a53910ff1f2186208e3f6a9dc9155a5d24fe764956fdb29cdf73e09191f579ca93e3f7936bf3b2828a87044b66c38056fc97be40d45467a8d1364174cbe1220f0dc192199dec2d8ed8717a35d41435798fd1fd916d260d44a2927246f468572bd3494af5febdbdb7054fcd998f3330d1fa1df92a20f0957be1bf1b1ea6228c46ff2100a790d01028d84cfd7585bb4aabdbb12fd7a5c730338f92c02970d11e657c0ebcb1bbcbc1394bacd0c21d04354b9b534d620f1e6f5396179af06e9efa5b3e3d71657a71b852e32999a1d2e19b9bb3452dca867348787de255022dc127587207ec146f1fbe5667c5786f6f8065e6c429352ff07d8bdd4d6a6ccb23a3100cdbc0d99c978b7904a5c158b07005404bcbc2aa9f9c92c29ed134831457a0518b4dce3b761ee8523fe3ae453ad39c7140b9663338c3e0371acf217ad43ed3fa2681db29944355eb0ca40c9b306b3d2b8dbc6f6fde12f2b8cb8c47c774b1a68db45cc91577644cbb0472acff1db7ec0fea2127f52c3ca8570913d64c9c13fe4a7ac6067636c1019180337437f68da414c9fcbfc70fa070d30acd38026fa5cc33e96a6d033df2405f56bfb10b35940b325d4e80661b53f1b1ecf06693c2bfb86e989871cacdd6b45f07c61cd1d502871c1b20a67d6aff449741ace710934bd9672a4419abd393d66b06e60b02719fcb0b63204ee98c4c9068a6e4ae09ef56db0b1c610d7e7e69d40f026c6c50aae9e42543764413b6674cc1af0ceb1ecb2777f5f57f39994545bdf740f119466505286a8743d08998be74380ef446b75ff5bb7456cc9f385cbf57335460df5796510b2bec99fdb1402d08b2e258192ff549d683df071f40bbad54c30412381315a7b8f59c91025dab67e86bac28e3ab635c95e95e9a39244de207181cff9fbcdf85b1642d8db8202bddad474f86aa1a8e5ac95748529e010860b2f2d676133f8dbf9de552063a3c1802515d464f95bcd6b624311c3286cf12b5c1c2785a454ac3a8e750461e308bb0be695a266a9e670abcbb9e581a6289331b8bec7d80a9907c724da2c5ed02c3bec56877ccb6a7d43be7598f1f2f2abca5243377f2151f0fc5f50dfa93c9e37ff474d768d92251ad44347363d89b4311c44297535c7a7845fa5ae5719e07d5ed09dea4c2be1ab27f0c548266555749375f475d8cbc970aece3d7be6892457808a8cfcce3e593614760be2bb2548692ed6bc7bec8c4d1567128bb2242d0fff4f0caba5a0e6bb8214e743670c6f34f0c31ed43ca45665e371c503b5a1fd4f7b60770e4dbfd343372ce33a06c341a13bdeca28b65c9ed4ea2c9f1cd3bc0e04f9e0294d51729ba04ee764ac5bb6e8d58f4ddbfa0b93f7b9c868d873f87c0c42b855c3b30493b96cf551540ed5a7c987e45459c8a1f7ee6173d7293da8fd4d3babd1346a80a662108ca7b0b58a5b993a2f0a72a1745866eb5225751030eab3a99f1ae9ffeb5d57ac486c844f037485fbdf2654cafd6f7f75824f517cafc3eb31d2a08ed8b85d296b249ee4366ba8acd0a6952da0a64ce61744baaaee966f179b69a19e8bdbbaffe977f0735ce27fb588468fc79482e27a142d97a2e3d82cd13c930db329f6aef1ce4afc0c3546b4e7daf6c46e03cf1b50be79e8d468a2a85f0c9c69b1c91a0c3e9aee382dce080565fa60b2ea632572a93a6a9dc4a4337741f51c0f4c9cf5973b5bd161e2ca67b5cd60bf6d5620e5d9a29402431bad6ecfb29cba665794c4385494fc36c853757d4c1f84b9d65c6cf7fa53fae736614b4e5dfa436ee8b07a06c4d20c826b218ff152389d8d16b15d34bdeb11fc9570bd78946798f2fa760017a244f808b7da87abbc13b9d568f2edef75515519f1946844dd2eabbfa12c6feec606f0ca7c297f90b1375d5effc5334e18d426767e8e56d786e64233c9a2f4418621565082bfffc41aa0130eb254957ee9a2b13169ae7c9fe5681468583d95e3f624485c948fadcd6a495433a61aaaceb990db9468c01a4625c29ce5c0a9d676342b0196004f78fd8d53ffe4e955be90d2a63cff92e625115b8924fb39bbd06c238360e978d5b0cbe13b33e98411e9fa29e6a91da49342efb0b587fc90f91a5950da5e6f38bd873574afa2a950c5d693d866b4e511d40d3d52de42cd83e7dcea54cedf3c642e8cd88fb1cca91874db3e68cd85c2807a3f6ec185037b6fdcaefa9a4cbc923fe676ae81ca1f30dc174767ede8b683c254ef0503eb8c1c3396b9dc12261dd7954acba0c3386084af411dd93d250180a80bd30e48ea447c5fe1b929450f19213df9ecd58024bd313e3f9985c235b28e0b0eb0d944a5f5c7057b3969e05f23f0e0fca023ce0efc7187cadf58d2b15a38d958d4b9bf9429fd97edf80a46bc2cd67618e50a5882b6d3622e6f5fd7329eb0ac4d41b7f5e5095e9e56326a97b163ed26f9d86b9e37ece114b35d9f2e7481f84799e5032e6b4b3eb5050042c05b51ea4d4bf8bcf4962aae80eeb03c4911d91fd417d6ddddeb3358e5ae7c57eb24f16b1d02e3c52f14f65151fd4ca2b3d8b39c6419874701fb2ee197de740dda82a7472bfb1a7e9036266873e8dd393a19fbd64683a8fe23e30ef89efaf2a11ff0264a7c5fd5a4237f7786427bbc1603e999db4f4e321b51fd88570d081596c5363ff5a9c7f934ff21d9f02f028937bb3ad6aa37591f824ebb2105baf21eb27c62f3562bf5abe9811dc0a60c2a6f14c7fd803a6b6f485bda512f9b6b3b911625bcf1a7ebcca708ffd7d700884fcbbc170f7b39e67aae1e79fc65d3115da28f1f6a133594a7a4ca5ed727b4f7a93f95ac1b648f186fe418dc15ff0f54ce125b3467400bcd97bfb2b1b209c4e799bb0fa00a13c14aea2071ba71909d2c28d52f7b67bc90da4bab1c2c14ad54554fb1c5969119fc8e3f397df3452b5ae8b4335b7005ccb622799f9f22e6eacc69dd94f2bf03e79bea6b3b9c2e50ed0241a796255862c09af7d0ea0f5745a58f43bd7577ba4a3bd5cdac9b67ebfed7c80f14f13376458c164e22a134bbf1409b7302147993ec35ccf04da4fe2de06165b44ebe86e851b620e9198eaae77ac4424adc72a1cc1a9082c33dda8b4026cf006105a314e5fb6d22cad0c8a1d98157086f01a3d59c3ea4b370914ec0628adbec7c673d6a44b8b351e08607ee1ef8f1f88becfffbaddc6e2846105a7790a6d4cfd8342ecfc2077c8ab364569ecdc1441967e675c30df2a43f530389549d381049f50a782c0bb094ac93c73b055cd799a5f36b3c2768e08292edb668aeaef0d5b9914d73519302922dbd013ed24945438834bd4aed51241149cb92ec9928c7a54c26589a8eb1e3836023c0eef7b7b7525dd8fa8887381b3336eaf63125501869f88f2ca172dbd845d0b8dbd0f2960a60779d9dbe39b35c823935ea398ae3075372616d253302322dbf0d925f6b868970b0762546ad0b60f9a2c073e667612438984e06c5457edf1ec5bfc9ca822b67944af80d85eb67ff8c5be1b79c5860018c657f9ce0516ae0e70053dc34f7dafdfd9b819da3192afdaaf5568343f688d1b3f5023aca9ae0c3bbe0caff7eed40248b456ebc6972ddf388680348ee5dffc9967e4ee276eafa0022982a62a5dad71050d2d564e37b26cda91ff24245083d589b1387916e5de5286a46be3ee253e2db0345f8d4963fd1e97720d0cd0881025b02e6d59bce3ce44f22ca01314802d39439b65d523db619e569c4936c3128eeee8dfe8eabc9509c89dfae07c91ce3f80775640407e012a277be0ac177d17593f099b0ed4a26c651ef3ad72d940260dc03bcf57c61a6bd85a9052c490aeaf9b1e092dfd01c912a8acf38be67522e95fdce2792b751684bab8561daaea071479980c3656162f7dc373df7df8c666f4d0380f07780f44b2f9e087a66ae1d7fc33778ba6070314c2b1cc8db81c0cf95d346f0c16df12bdeb40ed619e58fc6224576c219cc36c03485c76d7dd31496136971f4790061d0681a6425290fc8477c6929d1a4fc354e585cd14dedffb3ba919fabc4c8c4510ab2c18ce9341909a7e9673e06fcbcbd27782508a4dfab56f65e9b6326d4c28dfa8bcea0023ffe41729690cce0f9e26feeadb4e1722fb6151b877e8432d4e6d50ab01b7bda7f695ba77e3fe08711dc9799084a8e8e60ed41b8c50bd1cb968e5fb319f9b024ce2dc9e91b277754f43b8a0cb3b34b167716e952b64cc8859fb618b2bb356ec66c907e8d7a137760caf83541121e029d2eaed6afccfd3f3f32ee28684c703ecbafb4b96e5a8e827329221aa492501a283a2020111cc4ed3beb50f6179174be6911c98a5ac027a0a256576b19e5ff897f6579362bb5da41f92191fc43581b1e078bd873a110275ab1ef89240777ebb280499c33bbba93f65f1b6650cb0dbe7039eb3057939df1016a970852897af063f2a5623e3859064f5f76f38b975ac2bcc2f76cc3ebaa42e5c0e1fb3b8f4e1d2d7e4a6d57836c8876fedc73bb42bb4bbbcd8d1d36c96bc2dc7c95907ae6bb6d2441b30929a0d025042f1d0a66c428d2c7fdff82e49f79cb4ef1305bd1fce1596029f414657f28895fa6f3ea7bc190589e1c071ff716c3459ec39792bc3b4686930d803c655564f418f5a0775f4acdf58601033dd3126553971c99fad85b63cee76f65873860eb3af1fc22e682f951e5f03ee97fd0814fbc90d56e68f51c98b2869b8b62df59fcd4fcf61d849e276f2b7b8f48b7abfb061794ad96aff88a637ac5b02daed46a6ba44433cf3b107c459c7b3736c45b3670b7ed9107bb2c881073e085b041947068b410ee75f5e3354765b3a78e99490bb09e9372467cdfcd362ed15cba1d776b4c0296c4e7081ac2f129b4ddba242cd9e4c6973005cf0e79541f211d90212cc5dc550a86e16725e0b3ccb5c693338dbffc328d804979c599c37fb16ccb0f71fac595985e90cd73cb153c7b5b1ad7da05a8769b7807a47d9f2a0c2961d31762bd439f27e4865343e7d0b40fe7b7444f7c8a4cad8e1bed1f60acfda766276b181e3a3f1bd17d76dad405ac8683fdad168fb0a95e8f4bd74a2813f5767589c9f14400829cc7d91f39870bf2678b2226331bdc4d6619a1d7f1ece6886530667b23d3af83049af43e20ae69fcecbe9c48bb30f44b48a149948f5c6957ef5d7d6d0bceac418a29fbf7a47154df087b3b8df3bf6f37a531c7568f13b191822f7285a8457e9bb487817ece27fb4d46fc65c84c2cfd341c7b641dc981ca36816ccbbb40b52575f8f08acd61dc6d8368a3ad5604a7fca800a8eef406516cbcbccab3e71add1d4cd417288fec036743fe89bf69c5d8798d0eaa34941deef5f4248cce8ec223a291b108ddfc337e71b346853fcc693f055699e1ab9542ea0b2423b1495337602d375422843941bd41bd44c1bc5b12a176e76eda5c3f55bb7506cf283f6c8ac14adb99568feac2adcd92d1d14c370c5629f86c33e1cdc8827282e53926c85923e3a2346f1f4d23e149d957401e954cb0503a123635ff524e942daebb48c8ed2056aa0837b79e2a3bd887ac736960859bf1e4f5d2283fd789b09327e4b5f574b28a7a23a947cef0af497f9f0ecd0b4745a46d23c579ed5b080158fe129a8b1c82f7f4a15b75ec403de974b1304e4dc194c34ecbeaf012a9ff7109ac705b47b8f356801146390d9f02e92c66419a4677a21f9d8338b68cc774ea2d8007c74a3badbf174f2f6dc62a1858c1a298fbf0b62e73e2b5165dcd09fc89842d4014b28d2e7aa44b38673832d1c3f9aaf13be2b446fdb000a5fb2443c5132c5e7fa18e6bd96c49bef5f7063465fca174d06a755a4a5c92f97611eb4243a9b5f99299b321145fd5524eed68339c6a15fbfc0942b6de35519e09844eec227398258c7b182c7d52383d02893b2f48f5de4f7810a4a7a486c121e703592e7acfce80c9d5ce6133aa3455f13c8bde9e877c3c326335a524e1a214f93361d0a39830e971b47db9f420bc5642ad10d6d2fd4ebd1426822910df97b4b818bd4eb38b515d955d4ec5e13a403ad97b14fcfa8cbb5bf655d2c5553f3bf2cd04012c50323d75d566eae783055f49708cdf39a83c2e63ad74dc9fdfe911bc13a8521343c2bbbbc9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
