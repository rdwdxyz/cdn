<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cc01b38b724228410321eaad8d05379962e3c90d6a51d57d7cffddfef39b0283f0160cc9b144bbd18d73a4d30f9f947dbd6d1ec6f1156851290c551adc624a1934d748e31fd36cb7fec9b220ce623fbb080f82d889b6a19257bdfc98bddeaab800af53d454fcdf4c8df33899679f6d5f5e44135692d1f7c52f4c255a369e4727e4190e9d170e5845a08ae65ac49da0c0e8b17cfe5dd92944d0d5b9ca9afbfcbd13bc798af211f467e6b1879929252fef908840d23d0a6dfc6832269affbbe09b181c44b2a8ddbdd01d1e26eae05f7b515a8e9a3bee32cbb21080afb97adf5fce566a32685de1bde4dd30eb21f6a1c2f7894dd1bfe8e314a520135668344e5e60a9b4e543fb46d6bd7b8337be06b92afa6a6378f2699149d1bd80356fd20b04c91a0b959d67e6e43245e167fadac6474c78d16123142cb5a48c6fee7224d27009312c68d798747a600894d707ecb73db2d73b8f39f9b908c7d604c04080292c9bae88adcb72538e25ae0db4d2d92d9807c7877773e3a12f8788d59d6ba0087768a81908afe7f8b5d780f9528cc0e91327cf404e4b4d02a0f1125768ea9e9336f3937f6a88b380c33bfadf142068dd83b760aef56ef6960aebd615262090c73dee8f6c9c0b9322adc097cfc263854590ccd800d4e2108da3441f272f45753e83bf4ecbe6278c1d52beb4b3823ba88277221c8f408fa07192329db59dfe506588fefff68daad4cfaf725bfc1b471d2c1e84ab6f14f19b40cbac6f6fafb2014201f784fabcb2641b547ead94e481f4a4142818a9f440270cf91db06c1b9673afdcc51a126b7c71deb1a288c9b13314f37c15d86680095a5f3c0c04182b4ae10a06ffddf75569cd50af1ca294cdc3c73e045f943ea21c688808f64b5c24114aca75771b14428768a25c9afb121239fe2b7f4f76a7af048189273e5a4b0a2b19c56959bf4bf2939435205fd82a8ba58773fd4b1f049a6b144529a7654b91490695157a2b07173794dae0c74249b2e2051fc5233c32dfe9a7f9831411a9cde7676c9d5a5a31e3b823e823c836921650be3293f29511c3dc213be049a969ba75d7261cff41496b13ce41f8653344dc43853184e8a590d31ff24d6a188f04ac96dda4b74914ca853c5d2306ed77f40d87ac35097ff9d4c7dbfe45a7720b5f105947245370bcf3810e20efe1c5b6d31806453953f62188514476dc531d271cd02adf66d55fc1cb6474712c951a5ee68c6081ced90cf888c0b4af2b750a4def6b1791584c2e56102881af8d1891f5cc3e711388e326b22510f5c8832c7cbc820bc83f543b5a6ca6f5ce2aa03ed40099697c16309c703b4a9f32407aaeb703eaaa37193ed6670d3843bd108124ee699e483195f60a0840f57798cad34e03c4df6bc0d91e1098e1155a2d0d0f17f724869ce916f85b679a4d3a830314a92838a9976553b33a0cd4630d22163afd7752afbd6bc788142b3fe39744bc797b62c910fa7233ba85d408847b41a5546c4f0af10f03d6161f5de4dfac4f6916c30feace83075fb3ee850b148a6760de80b86f6cc105d66b158abe094d769f6e3f422e7a3fd5ca1fac432e51728e9ab110cb86a6a99e71b9f213f1af63b568496baef3d2530e47f16e3009aa97be4e8b51148d2ed5c8fa43dd3286a8a5e4bd1a82ee21113a973e2153b29d4b4aa84756aad0e64ad31c3eff5dc77316330d4543d1bb38793c538ee9cbf3da75a93ed8f5697a79df55a3586b15d1610b9d393d708317ba5c668c59fbfe20dea8a4c5ef3e0abe049fdb18513a0d0df788b3eb24a7c63d2e7266ffdb3f876c46180927ec72cafd52587b924ef5c64de53c7e87d1b0c4f942c270884d8e59fc1d00f2cfe4f92dd4fe98dce301aefc411ab2b2425a19c1759243282412bfa71423fa78ee5ba10cf992a20c5ba38af501ea1043027d5f4c6181ac4c7d903c4be103ca56d36e6d55c2c4dbd855cb3eafadc15683e9f8fe9cfcd3bf7d972b08e9a989b5f5c1e2549713bcc6c07a7796e1f439d39bd3c45d4bf1081917c4214be2a6a9892517cdd40b728585a03bf6ba4cc3e2fb62d72975a216ce46eddb1f34ea44ba3657517404e1b8d79ebf5832d6536f53c83e6fa96da95be429a6eac874ef9823444f66a9f2eb6941ae92c4054a704b32d86f101305d5e9c9797ae5b54e8f03dcb0a7d360c5cb15cad93f20308f0d7056b798949fa0d1d138b47b47431486af8335febb9d22b1ee9777b311a3ce91440ebf8d2823e1cd6ce0fd3115314225e68e196ae4eda0a3e091ef77d67cd3f7dce8c79c44806667753c52301fad043c51ec85357d983238db44c658e339294cb3838982b4e24537208309023d5b34234f2245a0cef5c94cec9615e1275ae9f92ea88f5bae8c556ec0fbda18a225bcc9a51886787a1f6de02df083a1d5394a733c0065aaa6d16bc0a8f9633ed0b4433cf25c98960858da278721f45f56fb8d271f954d701560bb8d3309f247ddf28c75bcea267dc742c7a80dcfe21ce707a24b1d34884e4f8c11ae57ab6543704c96b4f234ad786e6abdcfdbadcdad322bec55e3db6dc447c963822333bd84c5c38ff9b3dbafde9bc0e4ed299e9a6b24c5872504426b484ee45aaa686bf33de58df3a24fffad5dfaf3c19be3401205b8f7beca599136cd8ab651e0dfd96b0463efd5cdb598f748939a41fd6c1032c016c7681829bc8e81ad08add8bcc7985293e9e64e1fe0973abe2d8134cffa829fe31a78475b8dad7d4b5f7d3df229f3d49706775b2481618a15b60c48fa8e788cc40bfccb59a1c7b2edbdbc1d331e96407f75dfa46847bd597caee49fa85ae31f9fc8278ffa9f686d995fbd689217a056b28c9642d4a823019ae5e0bb3242bd87491c4f44838cf3cf87ba57020d00f28da87a86c76488831a1f03385340ff1452951574abcb0044d7a6c72da718de2bfdf3f8684d76eeca7daa95c9c3edae831ae810dd196d64e8935e369235797e3be651f2f15fdaea5ad1130f58be172c7186292349299d6410a2faa0f2ef15b21d632904b7d108952ab81906a99f321f3ef6245dd267d01617b0ffe7f8141ab9b19ddcc983ac550e6d378728bd2667aa586c6c09159b178c8a9d1904f659824a419c0a8231cd36b59758b65b093292f0c8588e239cf16efe16ac7284852c76373bc2d9670026f2cf55cab42d5d7513ff4500c6ad8665d61436030e16cd8aa5e661e3f74effcd05a4f0e956a0fdb49757b0ffeb0eb9b2bda03ba0db86fd7a8e76d6884f2dae284ee9e502f213d3e8645a06a76c68d85d8025cf2cd1ccd23484c6bd9c2ce1bbeb78f10d71c789c89cf68b2274d57681953a29d58557534a3dfadb3cdcfc2131b60b34ef4b55bc4fffd24bf3202e72ffab590e01e72f9039cf8626f5fcae384ae6a1db81f64b88e35cdca24887e8f2f0b89ecb96df0b9025af3e0a860e3f3cbcab883100e276f619501cef9ce123d3ee81245cdcb1636f29cb37026c204b7b938efcf84aec3ec494e0738268043ff16a7a0a30a9e47fd38b4d0b2b130f1f4e3d9295b09217b56e5a387142fca84b064a278b6dc436b8e33768ad5084fce20f3e67253a99e9c47e6e2023a9ac718b2aece57012895a97761e24b83b8cfa0d1319a850ab684e5d36cf3af4f35c81efa6cca38fdb952ea405571312d342602d7df3df2adf7878fc891340901c42a319dce33490a9c5943f8fe5832eac253f5dcb550824f688fd6d2767e2a7c1c700569baeca4784a9eaf073c4f8e926141bc1894781b39d8ba02fe929ca0b228381ac488531c6cf9ad6c3ec9d768289fcdac741412a1ce729b7c401e79e14d52001c41345e08ce5fa8876d0e1364159253ec815de3429d3a86b2820167df0ec2c8a2e8331ee1b94a7521c15912d34b01ef43b3814dac644c143cb476058ac72867ed13b1b18585a1989bc0e818b39b026c72a6ee60cad0403607b43e083a15d920ca52729e93dcc63b7e2199472d5fc1020be24653e56be7878d4f8cf7a001491ca34456e4a98733ca07a256f78e52d59d9a314a4976aa2a13f00040a4b78047dbd774744729eeee742a063752a7c10fde70f977a97f4d46452562171543137ab9300680a2be41ba525ff10b18576d1cf0e29079112e0b768d75c39d3e1ba2b1eeb04542c5657c7c0b15d3cf4311611584fc3b7de67dfc534e2a0a557644407196bc922bba5e3719910d345830addb57e504cedbb692fba7b1436634a85f0cbfc93e0e77821114eda89d4bd9b170b6b3c1e7005c51ec83a8e1ea9ba8dd6845491d08aeffa6f889539d6eb2f230c9defa3db1c74b7214efedd3f981c44e29a95994a24a834d94d89901c618e588ef910eadf32cdcb05e864ede68b3bab936e09d9e57ed3f49c3ac507d76055800b8863ec2b29bd667ee319a39c3a06569b9cb7e7fef30da42b0fadb032b31beb533f9c15610aecce901a75f816a30acb856a703d5c025d4126089c3ba1fec55111b9caa623b2ed30b372b955c8df3908657a6cc0bad16b2faa3d96da135cc13f44f616a41e932c5d0b1288b10604af62092ab275cff689b0a2ee2a1d70210a393b722e38cb467f7bccf3aecae5fd57fdefb8fb45ba8828b765616c1c1cd8e7125652e154b98c369947ddaff21c66f2bcf936989cc895b75c96f24f1aa9c2c1ca7bc653c25270d9a0f7d5b3f7ec386e4330479f4ab2f6cb9cbd1e174e0b614ce828aafd8f2dba58ef68f41403af5add2e7ccd87c004d0c3c4f4d8371f1f3c6343412ba69893fb7643f0ef770c7adc750772f27688588549ee7b95c97a37cce98dc5ee47e654450e534308598c66c6beeee5dc6d47b111176195d67ed096c738944c957e94d801a1f234d9bf44f93b563b00226cc5cd1f5b4428e758c9b2da4cccba1aff0e6404b67b786488262e362b59287a711a0eb0f779146deeffb8533584ff939417129a3790ea05d4ff6e9e4a344c15cf7eb24bac26aeab3d73f36a5d16abd9d2926b32592cbd63bb194818668e3dddb7032b5910cb6ace880a8d9480c2089bf457e8263c3329d51d7f39af4669eef700a308699126a82c8f6fc1bf628703ab3628f601399302e6cbdcc846f363b44fc5385d18aa305f83f9acc02632bddb894c39d3ca77af79253cd008f4407c945fe93b37353b3b2871a1f78391e5a28eba6b0a41072cdf8bc0927e71f66f2b0794556d87f0ae4c304c407f8eeb0ce631cfb2afb8f5cd2b43c2dbfd8bbc86e7904d69b06a961d4b072055960e8ae7b35dd3e942cc2af36dc15cb5241e3d3118eead508c446f05da6944c34766763b73d03a3b4ad7e6547cbe92d1b9924a73bca77db4da69c05bf6f2f472278011fa4e61a72c483236d2101c3824ee35f10b49fbad966afc4224727b29f37882e4fcb090245bf71caa0e43b72540944ad5e7ce1c65c836224dbd8de6364a381959e7fb37c58c49fe7835c1fdac8ab4d941659680be0c26b92cc394327249367f20ea89aa9f7c5b90b79573632276c77f5ebc8a9c5b7332f0308ba208964cd7cd1d2be8f80d91246a278f8a3341cc7c2415d6853727fc66c62a992b8d720bf026783582ea853f1b187538f125ba7f1897d74434ba9da1d52cf13f459e17b3f48778a3e807c22c3bb0b399a36e83553c8c964e751deb14f40c4ffbae47a7c62892e8680a128a4ffbd893b936504ddc4210d342f3335ed2176c333de1b689ce58f547c7ff1bf3d8254787c488e1707586c23e8bccc5122ae39d9d2f18452a9224fba82f4ec65555e34faf9dd085bea1bdf6efe6086207c5663907e424508f482066a45c8dcc02e606157068b078eba101c6c72435baaed16ec81bda013ea1c75309fab7c50c527415322e433076c3f7796d7867e520b9766335ab298941a0e688a728ee449152b9be367ad6c119fd0b8f4435c0fb7e4651b12e4e66d5616ed4fa453532c4541c2f1c383b4b10580d96e77ed26130b9d1fa53d0bd9df5686dc9efe17e09459e4f12bbb017fce47067b49c9f770f560b06a5a8c43466fc812008f78632ac3022ab37956ce25420a4e2eeb901084ff8263372a14d68172460e389718db262ca74e0c6e01c3852765b39e0b39693bfeb2b163d5be99e958ad3d5321c72fe05e7349900d00159848e661d8cc0990330eb116df27002a9cd6eb74f7396db0b679c9d389a2b83411a1c0cdfdf7a1ecdb559dd16fe6cda7a1d6c978d84f1ff0160a97203571604fe444694d3cc58203639ce354ca538d6ac0bceb280514cf669d64b660d0ebba61c64fc8a32b4451a3f6a345c7ebed5bd80d6a51feccabc5b0af8408fd023656627ba194f5020cb4e4eb7ef777e5a78bb281343906b05ff732e0941d2b4a9072fa169473ee0eb4cc40adf5495de76d8033b18dbda4d36b3c2e75cb5e9c90d364dabaa687dc45e202a87e8c426954ed67736d6f2b80655aad9ec3d9a55898075329a0a9e7c3f00c47a389455c615e92a4626d54573609e4468d4fbe62b673e14a5c94475d5a0f833f112d1e07ca7e3b9f342cee4598c1810009d5908b354c463e2dfc9b3e9d990d2b3842f592fcb81737df17f40e4f48e420255e1cb41825f132d51c74b80dd015d0e74ccf19c5ecc39351def434a17f20de9727859227845bc1cfa48ed7cef47c46f849ca6b8f7d36488d88f5d0d6c6d4df1eb91f8f79d1b106e792fa1ac53edd49662fe353b8d4789aa2f171fccd5ab173e5d854c9dc23b2b8d7d0b99a64ed29086a82ff75f0f682d67973853d72ea7ebc251019e5e04680238358733ad49f95593965f8948d612bce5dd98ebc927e8cfdc32d5fe0b5db083b4338396a758555f630af89e7b234463d8e59170095310d40f3478fb1d87bdea151243b2bcd4a2445779b579fe6e4d97bfaa525abd4fc5330feac91b0e82d4501083b68c3485a7ba99133bb06e74a8eb23afbb19e2ec8abe14b0978ff114e145feffc5b4cbd1cdf81f30747e1002cdeb01ad1b078260b2f8490adbb9424141336b9fea1d6d2fcdb3325f26886841ee57d18430bf3483bae7920930cb47fb18d06a1e243e597033b8e83d268cbd1f03582d189bb9f7437ff15e5e720ffac0020e891894c4cc1ce31904cbb623819fad335ee0ac9c69f01591a436a26dbd70f321db95337a3dc82390af0b870d0d88f851ede3e69d3e20738173264b8bb4d2e8a0344ee6bdcfc27276cc23f4a3724925d791d257c76e0ec85cfae006911f48729fdcd292285167b7cb096a6d65eac22477646de37cdf214eabfa57e486213ae0ef4d5497c42fed37f7ae8953f70bbe70500db6c286303195834af54689087c789f41cb4ed2522e9312cbef641acee2fe2301786ddfb19fdc009dfa264cc76b8f63759c7433e6d80db345e115dfeb396fd90590b0216f5908d5c035391d384d371e243d33a573f2e6f5f8417b1434f3b9dd9e0f10c68aaac15c2f7f4017b7780cf7162ae951984e8279691530f477549e0f3e8af31839b2be00a975bc9c62603feeba45253b95e970147ac81ea0c2ac04c6d1177843e0e0fa3b2e064dd2a92d1f665e39f02fe2191b06a99a66f208ea9f128e0b2272aa1e0e0bab21990f78bca6458ed4ad07fa8cf10efa73f29ba3b5d9b2a0349984643a5ec20c2fa62fcdfa3ab5dc17f642e2e483f1cb9f7c0633ec6353bb461ae3c123d982d809bd86472e0f23a9db5d32c86e496dd9fae121175c0adbb2fefe4283602f6bbfbd3d65b8ecf053969ac95e72ba32425327e8bae0318a19b9e3ed9a575ad0b0a6dd2894c4998f7c0cd4badb91aed6386ed92af1598b5e1b59b569ff37295c76f4ec4dc4720ef46432889879dcd55a70fbe88fd100f98b20feaefb532ffb4283e58df27aa241bfbff7e5692fcd9034c7c580b8d4401035e44b21f22092d2417e6e6854c2cf2f605e84a965ceda0772f5fcdeef0d9c5908dddd4cdfb061090903c13ae8428e057f39bf6aa267add7b2338f5e92ec6f53f125ef8019ab7103ea6ee38e4c9af05eae244f7b393ff3b0ae87ab861cc12ff9c8efe5f7bf9836e569c6d3268bd4eac3c17718e5d9ca0b7eba322320eb4f160d037defba0209cafd842f9fb68f9d27e2862b22db2df60ffad11d495da9d35efaf53b9be6452e8efefbf8e8756e3e63779f03a74b5ad95fc77df54a7a9490c4400c2365a9fe48f84efab57e3774fa4f89580863941a26f63a0715f8695eb8b205cc429512c24ec414e79a6b6931ec84c95b6e462911e606393a7539ae9bdf68fb89363269011d5fbf44e748355fdad968918fc0a0abe1ea2edffd1dbad72307214538e42919e1ae84649271fc8aea1607f28933a80530e41e8f1c586281079286935384274e64aeaefb7baa163cf8efcbcbab0737b54ffd44bcc8cf7567dcae5afdb23a3bc55c43ac111c9f119f7da156d29ca701b8bf83430f9a01bd734afb97837a47e5a7557ed1bfe6677188ce3197d02844c6dcd5b6e05ba22fae81207b42fbf9bce3d395fb2cd6438b2a203a9fb5a03332b1b17fb3ad797b8f31b4d85250d1940d902bd98f7620a30ca7bf23345db9e757caee8f521dc58f9f215211404c62b876a47524f3d0f7c2b5151b4544182aa61dfd0828999dd7b8c6f56410b5ce423d2e1e54291d8831abfa91935fcee70ad9b7f31127dcbb2a51130f828b38c74314cb2a4aa4f6a46053ac81b04f0835318db2a7a25ca6b966282bbf27e95cd0f1ce82dbb3875c51f963a7879efa1304cba53eef82961c8d8561064798f72a6ce2e834b66cd72e9afef3ff95c966dd4c99b3f49f690c26fa86f7b346f95b7516bdcee2f2babbb31de9b25f475d40046ff3dc101558fdaaa8d45af26f7db9750c32fff5fe06c77726637b3ffa95f1fb31b0c03728f409920f93632213190cd1f534a6e0b2aedab63b82a400614cb59ab2b87973fdd78e19e2cf6f5761ea0ec4039437650eca5272900821ea7f5b4dbc6984a152fbf0b9868c26d82a4fdea2f4f9ae715af7bcb8dbd1687e1765c505db9f8450ef26539b8b2953380d6165879038b444a71f3e014756d61b474275e6c1a1e6c3cd199114d4c28820d70fe4c1738307cfc59739e11d3ba6f2598968bfd56fd26fd3cdff770ad8d36652b04fe09af85be8ff98d9bf5882413204ccba1144dc2aa5e6977135c06ded2f0fa9ae8e61ccc384d0a547a40a9b7f42392caf0e00028bfdcbe0711f91a67de216384977978e21a774ad18c56eba6c306ee36ad6ab42c1774f40ef17dbd45396ce6755977262a7386be7acf734861fd52445a48bfb45f0b5401a05138606b70fa74ea739985b79669cb385ce654ffc59bc10229f65f59f86d935131443ce98a57e733d7becead4f11ead0e55df769c4a5a3365915fbf233197b93d8242b58844cb6d910bd1701bd14874186bc3410a87aefcbf6c377f2135232abc143c1955bdef021d559ddefd3c80c488c8ba3108d9aac22105b31bc048e0c782b1c30434568312052c9b652cd85187292709e89f4d74500478827da8ba675cee7aec643272e31499bee62665f50d2b71accc24021796bd6a60433154337de8178ae7289ef04b3d921135ebfc64bd53895c6bd955099491a425f714b8efba8104ca931baae63dad7291e59d90fd5a9d898b44857ddb9ff20b02dec3d9f27c7118b22dbab1105f2eb2b12f5fc7491aba19cabfd69e6feabeb1151d6202f92b808cc3607b1dad5052d69a4889d45ec674158b0e7e2e3866a21ebcf786656b4b9a3ac05caada482cb566421a2e60317d31ee80070904cd234b489fce36dc01e7d36b4562edd48695c1b1ab1243086d30d7ab84dee257db7d42776322a2a99a2a53772daa4c2480166f4a5137d7521fc72305df63cdd3b74ecb8efcc46336f9a673e9da48f6a161b1e983b81220933ba9bdef3232c10a98d55013f76ebf445b92421788d01611ea046e4de2a6b602cdbcfd1747a4ba5de675f62f45892f3e9a5ca53a5cfdc8ec57616a05fc6f6efde272e2ff8e0c7772de324220f1b0aa84a032595d730acadc2af868e323953f56068adb21c3f8b0184df67609d53f706fbf8d31c8a432b0fcc5023e5f05f19fab571ec88b4882bb9872ef3fa76c2c66fd0850172abf672c4afe0071f871c2a72d6878a2215ac753b2734b1d3317c9cd8e67bf6baf7bec3a3b0393e911de51d8e5bf77fc1b54b0392f34fed81f49500c6b308cc1b0e662f64bf0279e1a0776d88ca218963774b8731928da84d59ab33fd529fd5e5856eef891e5394768053e4d06b2de182b66d5a55fdd00c250c688dbc8394e549592739fb5c513c295486f5f59cded92a1d5ddd93bd11ba8e018715f0e8880e43a894979158e6c75a3c1eedc41dc3c7d65b69522948cdc9792947e50c6fb019ac649633cd129b4310d7df364fce3e3148a817daeedd1f4f95d27699c13600b0ad7032e4bc0fec9924ef6079052fc52212580a8631f082c4054dc71625c359f97579937a92c28fcbefba9aa7ebf20acbd5393c21c92aa124daa81fa53bfa8aa72a7926cbfcba50ff737a37130459bd621d6c3803568eef9668de8bd63399afb81993f36a7ba01959f4e7da026b2ef90f34aa9ace225735b9f96ec5deeabc2381b4aa1559183f270636299cf82566762eaf0160cdfe08d1b47596f77dec372b894f355164cfb0652da29c8ff4a3b28505337590435a5ecf9e912d2b4c7a3e7387550395bde408cd693ab074af8cc0844a651ef560d87738a491d6bbcf55f245f73f0147ddd7e53e028913a5db981022751ff2b9b6565249515695fbbe9d06b5a99c98c537ad14d81d8f37a4313ccac3b8514b653a7452af29b335e0d547d5bf0cfa3a43d57ae2f4a9c78c545e2a5ade51dfc773c5670d840a88cf5b3fd3debf90bdedc8eeee96967fa67d459b0d0c025484fe1a44750b8b120f065109569996dee6fca2f6adea8d363745869db63203106b335cfa1a3307aeb89ba40de03284365ac04f7caed89900a0a3ebff83c26d244053f6e99fdd038293279a8feac496ae2a76decb59ef5e54e46bf5602545a22b4b03d5b122f568371fb5b97dc0786c3692853c168530a8b77aa3402b04177cc51317cdd99769d6c3e5f300a9fe62c7e2d7dbd4e79f9af8658a4e54ba6b5f92c1f350cb8572552c4bd05004691d542897a86699cb78185ad91297588c95e239f8d70e4b6dbfd457d2d38b64468aad2221db5b07534abbdd1cb6f8858d37a025060d4f1386077e1d39ed861fdf34de340852120638c05a3f031e2d5e54631649d03091ba6389f9a882a17f11610d9cf955a3c8a3839003efa3b714d1c1e7c37fa105c4447b159f32f6caf7e8e2f9ef75a157185e15f65643939451a99e90125dcbcc9e949764211c68422e377c3e22a068f0b89a472b779742afa085ae745d8a93a8b893873c6bb37c27762300bb0913bf2f84b3dc40594643a201523fafd6f059a21f118234c5899e28ec83f003b52889be37dccf80d37ef9ef923a46afef6ae4e14a392bbfd5e86f0814789e5b1a604d15a86c279c46803f56b66a1f0cc57063c7365f1b1661c0bb0ed427868ec43b5b3130218c2730cc6f5db7c5c94428223b584be969b65a40eae6e64737905ac48ab5661d91d2a028ba773928176d49adf023c81fe6417c7e63a1e16dacad818f59a93242752574e5bdc963d5a4b1bd3d972a7b579c6de8f3479b1eb94f317836aa8f77953a6a6c88a38e9b7180d65b1680fb8316083c0c120cba0c1e0bc4ad8be2ba94147a41428e69e6e8270ba4a1b5ff769377b15fbe4fa71cd50dca320d954ac99f438d7f0608a424e3ab804894c6012d2e0c485935364c16912ab653c0b19215ebde36e04ecaa8c102ae8b29be410aa98deadb65685e918b8e018b034ba4277b928fed0cb857a1ad0c64974780afe334d47cb6981b241a1cca2c472f10010eccb989754124a0abf77f8f18130eaab01cbbd9f2c67177eb96719865b3fdec4e01ebb26ab6bba4bdee27a1607dce5d9631aec605a2078b073bf7190c0e25c55fde3b912e107bf4c8ce895447e3e6e8d8e17f234bb44ebd116940cffc78aa90f0ed51a846380c4032d6b78007999454166ed98112a983e20c19ec2885a191c24811a12f6f1ad94c9d01138d363f474cd66b3a078c5b79b28e6c73fb2e2b02c90535ff4ec2bb6f3d8bcbf29045a8ed423b9aa9e941829d4b36246149d66b267f33f254db1661c20ef27faccc4f5f508258d88151cd7ddc390968252015940ca80e1fc8f1fa218a2704692ed438079cd724be7af9e9e7a3dc4d8251092ce9c8fbcaa4240033dcac44e811e9d3c25df6000b0b60bc8271856554fe4ddcfa710e91f083f00ce5e741078429b242227c0a0531a1ce10903f9abf00d81ccd809414614a54a944b32de6488051803a38c67c4dc042b63a998227227acf5cd54362253b5b52029a017667751807ecf305f8d05b0cbb2b846dd4ad480eb32d6b42d4cff86299dc66ec0c2c05ad7972f5c5cd193564c6ea6e3cdbbc4ee553ba9ce7fbac7e7a224373f898c63253a84e5849e0094ba87dacb2d6da795166f5048af8802e0ff315d3e21a3c5208cfe8c03fb92077f8e2ea94d664761673c99f6efd81e96d655228aae8bf293f09095b498103ef21f85077e13288d78e37b009c1a4e0140b9939fb53f3c0af0a4b49b5c91490ba10ace9add9fbcdd141b58fbb0f300005ad2fffd8d045c461dd4795d5e536a9b096672bc0dd2edefc1ec19911aec9655222d9e0da63fdaa2f0620e45fca18175fcc2634f989d459c50cfd26692dd4681757520d28c0d1529e71550262ec80b480a095ffcc4a2194de064a5816860baa13dcab22b91b4631d6167a419fc7d27025de2e89db1b6c4114699bff9cc8d5982d4e7898aceaa02834de85b6e5f59e66f8ee1fe906ccb3cd62ad437a26e39422f76430685c1ff70cc8c763d6fd99b38295ce035b21dd4e68a78290d41b4b3a5e584f55ef2349a63e8eb857ba2e43ef57f20a7b8ae86981604c08a821640643224cebc65fd3098d0e0ec56f07f556cf4bec5ab25444fc6bae2bd8fc221c7aada9b39a14369627da76630fddc3782bfbd148d34ca8e9e64a60fbe60a8abdcb189f8b02daf11249576e71cbd922a20e4271615a030121cd85fd5716f104b4c541db854f5ba2fe2b492298b93287020d86595a371b04b6cb95321ec78f4d541296670c4b08ad7a41235cde9cac17aae1d162123799e1ed9c1cac087411d3fa9b3d4ed1984fd8048f582bf8ba54da4f5a6c15903feb2a7b89d07005cc90a2a57632d35712ae349f060cc0b967998d902242a4def5219c2891ce61e0732f6cb67dc5afa73c985ff58ab58253d28bda1d04e2ad32ddd135582145eff615a1e9920da5a2253a1e35e490336cda23b3e12cbf7512a2e34df10a2795a5e23b8fe5095f25d25dfab9eb9d574ea32860a2f1b20055d994003028acc1ccb80e9eedbb43be00761e68ff496a832c477d7a24e6b20d648e532b17812b97397f9200f1ce77d6ad102f9e98bd8c563bb11fb207bf17d4fb682909d69b4bab9f3f9f8bfe24794a7c8ee656d637406e23a446ea550f49d97b22bf5d11b37379a89fa982b0effac59f508757840979030ebc31febaf09a72eb3fa125e235eac9951b6b3d460f0aa846ca841f5b23e818bdc4f886de6d87816926ba620d5ffcf86bd16400ea3e36a8363d0287dfb9ae93c18a8cbddaa8902669aaded03a411b6c004bb596fc3bbb9131dde2e839f348b91d504a0add4be0d7693c3c9d5cae3e0f8b87871522ce2894a89711eedd39eddae5d9dba3845b4433bc92ef5907119af7cb972f539c55c0b9cd4fc72d94122f2a34825dabb62d98f37cdb64fa17db6190d94df052f54bbda1bb5116fce8b7ca3454a86c2b23c01c9710db4c3f5aabd8995c9f0f8da013a144cf0556f6f1f43db8c5cd309a5fe91a568184542239825d62d17257c63947cd531f232cd6a3c3647ced88f53761faeaa9a03e499c71883d486f3849b62de5e9a0e8dab45ae874b8fc8af0202263944d8c39b7db2a338495c036910b6324cf2804a667c359a47cad2f10e036fda6763f69bb09b59dc53da610bb81e38b85eb72874d5463232aecd2cc5b201c346c36981dd40fb96b043d69e82697e57862344a14d87307e38d9fde2977e4a2b733f6f6010e8c604c9f02cd6b4b0ec18337069b0a02f700bfde469860dbb1a044adf967b413470a2a494381e4330fd84cb406b8a12d397766fbbb725dbe5777df744a40f51c0d2f458a194b92277d9109506d6c96cef6e0814b40b519b92a5ed15fbbdda152e8fcf543c3576b6ea851fe756f5e4972f5b45e6c2f249db44b09ede01edca79d5e3d2d5cb8e0bc49183a41c57de552471ab597811c1045dbf4beb71fcd0819cbcae501cd833a8dc74638d21b1666c22a3ef679ab9bd33ef21fe57b83df284fce28220bf4fbba5f4fe31f3ebb81c7df34a7cdcc98ceae4d63d68b88e2bfcc436be8f37e70daa2526282e2490fad1dff8d33e03cf620ce9d2cb00149931518a35b7e15401f00e0314d398f5353d5344cbc2e7b98135d9264f4dd293697b6ec40cb20564b29a71429a2309a2e823d6dce59db1f3a84307c17849c23655a7f36c42122f38fe415e149e3ccb5ec7540a3facf586654a41ab4ff4254bcf0a754df3ef9ec0d4c6a3adaf4d599f8b6ed04a140e4ea8b2be10d419fff4010959e675fd10d48d310f87bbd4cc2f1f03e3cae928d9119d1c3c06bf97d7ad8b7457a60cb2d93a73eef6f2a6ac05113b71299dc172e9dfdd5adddfe01977ac6866a75d43c651c8e4c8bb1982c9612d470f024944c9bc18f5fc5bd75e39237dafcc14a4122fdc3da7ad1b29a9eebf99b64de15585d6447d113c3da2cc7ed16883984e7cc454e968605823c6684542dccf9a82f20a2a10d90632e284f21ff3f9ace658077ea0640b944c922f915acefba06737bb14340e285790480f9d579dc683a66028c188206a03b1740fdd020256838c058f37c59f08e049d0291e1ec8221d4169fed8d1dd4873d1b0484b2be5ef418eaadd0a4f063df7b26bcf573a8ab491cc0b0d2fa5fca9bbb2dec902522ec07b280240ddb3d558591d9834f97c9c2394c2fd56c0c81853caa0b63bb61011a8be095800306d8fd7fbf18fc7594ca3ac19bf2178d4b50cfb6172fd4b70acbe1406a82455b942d913f6c5211481ff90f02e99ee855f4edfd3a2324e31de6d918eda1e4f47e6c21746357f21217af0aacfe489761dd8e499187dde811cf3d0302cdedbeab1ed4260dc697e82a2363c2f1753057e573695324ea95c2b3701d5193fddacf8343d28399971ae0ecf8f4e7b526deac6ce3915bc69a7f1452f74facef3357d79eafda020735442639f69b7bbe6ce52158446444bede7d3eefbb4f76a387f5d42056a8ed33ba641fa978a4eb1880f35fa67c40b110c8ef477b46bbc345405749c93339492d2c4a715c31361698cf0068fe1cf16f1db5e6187453ce7ba867685c6caee4473096fe58217eb0bfd67771302551a87b37033f3138e208015d55d270bb6fafe275039c1674e3e83f05341963ee00f73af9a819f5ec7c789eb38539e080f5d6645a11e0523eb8668ab658f91674e8ffd59d466ce4383ea8ee0733521a42294b20fc42936a4874705d049711125e3d47bda0175a777397fac056ed53aac62eacb4fa17d9f732aab820271df578500db157025bff2cc0842dcfd0d053755f21e61683479abdeb8438c1220659aa4fc7a0bdd84d3db87b70702cf715d666fa9bef3a4b23d48495805b4902b3b194821321d489d769bf42070b83ec72a7f4b5b57ac49bac0691425b007b10c9badeed38c5a00b1be1962f64818194e1508e366aaadd4e67e466e6ead570cb53496b6659958934e8c1f5a1b20e056aebc65124eefa13ba7f74ec04c0001250b718b85073efb79772d8e279e91ae1540ba90223ad330f8021ed7387ed38e9a9680b78b7d7ca7ee5fb903c39184bfb3116e16463f8326974b538cc681bbf15d158feeacbce2df713c5e3ecc5fe41ff68866b869b013e25ab95f490cf1379d0dc5114857508fcfbfff41970e1c27fe5feeef8094fe4857dcca45f832e874a69b8d6ae5d0bb1bdf72490268e8ec63fd314e50d71c033c54da0a608e40b2f98540f16ae50c014588e0782c299b901db608d8f467718a455665beb05585a2c4460e2302bc7305cf1b6534867ac9652b04e707e338a2094816c4c8c2e0e09fa7d16393fff5f84547ee39a740daa84574a445c7c1e7f0b3d704662c545492c8b146c3c3e714a94295ece991b65146c7f79454c38195f62706501722542175e9c7abffc96133e2a6a21e233dd64ce6b771a176c7307f8fba2bdab06a2906fb34987a24f01399ce56d5ccd522e05493ded7f09b83448d386a6e579471f0d2fa607694ac95c38bed7031146211e00083be42903194addc9d48d2a86c89378ce293a8b6d571ec877d15ec9bc1af80cddf39ef1f24b0cc821bfeb31c10afea5b39677d1bac7d059c5f64b7e40ae7c0cd571248dfeaed9f756f68b7ae4fc1a7d6e4ee0da860190d2b72b3e4ad234cadfceff5d69c24c5a37b6c39917e95c7ecff0bf1d96c67f95078b2088e5fd770a7009864ad23ba2e9858f4f12787cf880012d8b40149b71e7204aa608cda0c6900d8d7c31a53a4348a47136276ae7f49e222d11bf3d3a0146de76fa314e89eb20976886255d53ad61473033150d9189cdd2f78709b1e80e849926cb15fe15c9a8abf9ccbdd335ef1509a9400567e49dec004fa2eafc03e565bfdb6f0a8efd493a2ecb0487f6939d55a66795d4d07665f9b3bd28f35ddb91bb68740d6f5811a9cc0cc91ae5fe28788ec1fa3f5a6900bd6c00d7e9f5694a85bc5d7fbb450fa69621894053d6cb002f83168665713d204a89d13e9f54899cfdf9ad6394b0c3682628673ab30440bc35b16c4fea6c7fae07ad8450d3babb7996b7480a746d99b002a427195a5dbfc60d8b2884f3fc27a70e1b1c3831b5c25643f261612e146b845134c5c3a11c7a35db89ebd45d0f18b7ab6ce70a39e02047c84f3a7eb98d812a9f095e91470b7064fddca75037b2d77ad4f88a7d82445740668e9baef393b23792a570dd570bcdd0d73d2e431fe9d8b58c1d609a2dd82bf740b3cb1a3bd50ccdf446315b48e980e0d53cbb8cfaa6c27fafe2f2d30b139d65021f68ffdd61c4286ad68a0dca691b7c219966ab4a15907aaaffacee9f2a67c50c1282aaafd3b778b6e250ae315fa21fb741c839f234406ab0013cc10e3557cd286f6e637f412390608622223e7bfce9fb9a879b923f2e8468404eebdc483324477093171eef0de7501faf2d8b5721430c390f39e14c3eb49ecc32b7fe4563387f738cd06013f1f7da12cb596cec924d118a27b3df51d19a85d8eff169b69da0a904afc02bb34ec9a4eb7c83382b1a47975fc17d260b24ccdd4076045e2cde676d99cecc44bad80a60be739a3373f779a3924565c7fc303e57798876ea2fa241d25b7e3d0ce819f65f133ab317aac8685cf3e0706193e4ec8d9f2a9c82983d3794613d2662516ece5ae4ecf325fad3a31f9d9f1633e512a1a42c9f602ee854cbf690c926d222b94f5993afd4e2da47710f1eca39d62c7287e3c2a936b6e06339bae34e52abf52d7aef4eb283d7474428f3af71732d1a00a5ef22c8b759c3375820dc225f5680f4b6475d0db00b491cb67f23d15dc644d8d2ac87da17bed1ba72f9b70db79939c6a76d5bf7e95a51ce5865ed1eebbe46c9ad50a07124e41199eab009ba6821bc83499ff5663b0d329cae88f9f3a8c42e6898c86b8f47afc6ecefd3890c9c128a9d8a2e40e25f99dfde202311647bf44af3951ab8b08833647c86bd1cea6bdbfa06b0751b9d874ec67856a85d80537a37000239526317f033d819e7d6d06bec9bc633aed70a6e82ee646f0491d1a14f6ab404a10af4be2bf1b0138a21a8fb3a64103faf62f89ac345f9e4670037f7f9dea08765f2e17de0bbdc4d6c9ebbadea6bd3cdf1896940b2079a486709e4d62cb44ef9fe51c82ea69d6d579b1ab00884978757c25b0f3db363e333e08893425a93b86c1aa7e5f6f0ac7c27a7f77","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
