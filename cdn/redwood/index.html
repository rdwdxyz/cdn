<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e293ab0dedcd2c3c27cf4d8cce18d284889bc4f3181e4854a3ebe389bab35790759e7a98f7eb26d006a8604131183aa9302cebb47117d11b75f25ddec9af1821f2c6919e8c36da3723ed19f2e64a16dcc9dda4454e2f180282238ba1e9bda58d7a2c47d875ed763a1d83f9cef9453abdee4dd8bd48c1abbde88b10e04ca32066138a30bd4f500095bdbf218cb7083b1696921493220a113fdbb31180d2d2f1e235ac90ff41e41284464851dc8444c9376c713e3f05ecc78fbdf41b0336a1c16563c9acf8f25cb411195e9b2a3ac83e21f0976436a6c0a4a64e7656525bb8ab7b0e66fc334dc3b9cf4fa90ec9269e9a78c9a1ae2588ef0ccf426f1a33eb9bdb31460e07d25cbcc36eae54f85bb1f361b4487e295f2381f1f4cfc3f57fff2c92386aa16c2c5e8830b207ce291bc89c71085133ab2f8b04dc9a8f9dc29f1f81c9f91387f202483cf94e1a45d4027ce36f7d62a96fcf49afdd5c1307e0e843bcc01ba355b97fc82c2bf1dabb7238d864897916ba6a425dbd055a4989ea0bca8c25f023bb14ab34a3114dca09f46adcb820ba91fe886be0f3aac41f338f3e29797e5e462a83a60057bd05e9fcba72c4c0fa2c9fe8c15906090b9af8ebd91ee1f623d5ea09a76f14e4d90fc9e8aa67538aa4ae488c7e117b71ff48e610f094a48b7f3b034eca8af69059ac56094951021c8aa9becaa6c9ea823f2bab5a57fbf8758fe1856a45df3d7c726e629ac27c9c89356c11d55daa1e77dc6585d67b6fca6a3475020431029168d15d99ed9d3b416b1c6506b4ff931ae83640d0aaf4e4d01ca9d68af92cb5a3f60232ea4ee935de5917c7a36b298ccb55bc723ffc8ea974581b70abb47627a7da9dfd8069a3557808d2660ae9d1e3c11b0dd3ca248b816f5ea610e9b4200fa14581b81dfe244ed1ef62cc00d4668f890dc999d4da7002431d3d31c348729b4ffae6eb2a0240b6a8f79147df2446eb0062498477237ab84a9e300089c2142987bcb1b626718a8fba79f9ea162b61c245820db5df5d9e93f6d1d141372bd9de8e807c1f5cd32857a8e5132a0448144893e6e533d4b6a7f98105f1799962b622b449553131f0325682b4c64d0101f27a2de57bef7c323f0262735425f97bc21e7a345fab6a7e57438a61ef4ee68a0212682cbbdc0ea1fad70707f07b03b044ee6d0e2eb71dc6f0e4e3a3646c17bdefd379a0314fd538fa47554751488bfcec9615454808c3a03716d0f5fecc8037bd9492b919d8393d149ed245d94ac78248275dfc428c547668576d43719435761946c9439fc7f7f080d32794ebae65b757bd32739925454a2b14eea479e5ae8f1766be331b0d407c91b63f654b88d6f6fd7e424bd83e10b5cf0e43aeb09590e09dd800a86c5acbfc71bc6335ead1133cbf549aa81bec728dd83285bc121c4fbba4e0149c8e3b80b87f37510f16ef91df676d3e21ab086d795bf72c3d23b295db0231f65ed46859682ac0c42ffa5d59542f9a2d28c95762aa1327b94a422dccec0cbb71bf0e65c3edba59eb69335331b72e5b17b3ab2eaca8f3161df4a586dc7161911a36cd840a7e2d6b2ea1f82c168966c3f6435399dc26b4465f384d9ea27ad95deb8ba867d63f13d55a1154d4f102dd62c5aa6c5a0b4c0217be997a0230e593e388962397197c295ad38856becdde8e888fc69e7dfb85ddb46986d767a7ef37a01d55ba8241367715611d95abb422fd943071b50a9e27d6b58beff8f6bc7fe716955cfe7fce45f055b869ff13a51d75b21a15c74ae4498536d8566322b8c6d75254b1cce841c540ab70b1bba1a86a8c5d59e900996cb8f55e97c62c424500524fe598f9909fdd38dc22cabca8413d0df5e3ca4f4369c3eb5d10898c4ad5cf2682a1b98570289bc2990e9620bf8be8c780a857f5a80a449b5221fe61e3c84d3895f6315939edad37c4ffaf7bb33ee4081e67d24bee93d96d963f01dd49d28a44768ca450d6296f71e6385d14995ab2ad1e8e42da4c3598f0d94d517e7fcb4e9dc184667d532dfd8ec6ee99f1527a6c90449642e0c71e7e7f936fbbebfb9f900cf04a461bac275403eb90590b99122798894cb0c9de59a4ddfbf48d44cf31db97958138d774fe8d15e96247fb0b4055f6fb294416d61205195cb2e4bb2db5eb41a8d09c46c080e4c0b4532f54ec37089119fe4b476ebf1912cca60c4b0793c87352328a83b2f5b2054d01322a8aa29fa7121bac0c66b0f4b965e2fae6da48fdf310a2ef02440143072248ff3ce255c140258e84179ee431aa344744ab79a0b067a9567215602e931c5c69bb340c0b8789245a47a82329230db62382249be90cb5ea3cbe12274dc59d6994afc16940dbb97cb80825c2b068d780ebe3b43520a865f4c0b929f8d3fbb114554eeae93ce4cfc8b784dca8890ab0c065878735d73f6f2e6bba354d2e402056dcde2123e10c9ba602f024df5fddf870b3aae8690754275eb0b1b0575594f8ba977c06a4f34f1c2bafb8d2e5f8e84ad2e44e194c913e7b7252943a1b19a64a760a18f63a55a5cbd7a7ea570ca46a2780413dece6df4d6b27cf2e4e5ea41c7e0de60d13f57293ef2ac12e2fa285debc4661a4325207748439141168c1d7f00af6f9c7b5c5d49ebedd098afd89591bd3682fff485a93a150e674d95dd52018567e310687ebfd0fec40b345e7a343108e458ff0f2cc97a20beaf50725d00cf17e430c1a02d5ab811f83dde0c22ae656dfc3dca3a02e4c44a9f6ead8e391098aace631fcfc3fdd627d449918ef94bcc5ba2a10934512966e42a491c12d85038c38f4256215e23c48848ace0ba52d5fd96d4f469ff9104d9ff318e90262ca27e740a32088bf1397af7dc2c223a8fbab2326b339884f22595c5b632c0f88d41407e3e082d5eb83dd34c716ff131454b2f2bf7f8d9aec6285f690ebe4720a63aad59a0c247bd62eab73e9b4787672f6bc42dacfc5163130b016bb3a2e95d546ef19476e3c064fee29a46256455f1ebe644fc39c1c4818fac2bcc6baf66cf41536ba18e1928c2157453548b554dddd025920b21ab616bfc82e04133cf6f012717dadc954beaf60e674f18813854f6b8695259915c5cd2c5e5620593ffa1bd422639c7d33e591646bd0fb0f472344af7feba8309f4d618eaf89951f2fb11ac23ab23e2cb8cd85c017979dd6a9dd05f5bf75ae5d5ee1d8665423864c766a21972a6517109dc078e785957958c05a4723399c7a07058e5c95a922338ea7086ffa69b5a4205dfeee65a2182a63db26bb2ce8e561c2f9de18dbbb847cbec00611f84c9a6c9ffe2604aa2baa9208d4d5a3daa706592d66389981f35f799865ba9ba462f358b1409eed3c5ba58f1548a4a6b811a81ddc268a0f0c1a6327bfc1b20d2796b4634ac5d673606b616031bf1c4757b126548b89e56334f45275987ebb6208e5871241e9c9df649c5ea23b851284eea7222e9c523b399a0dee34b6db234e980f1d2a55121c70d5841a1d36b1b8f83a57ea53c78029a796a4d123d51dd373022ee2dd47c59ea7f613a6ada8ac3062bc701f8a9b14d89188ba7a43385cb94894a229d1fe785eae19daed76f391c8786f2b9777faef2047fa96fe1fcdcb5275a3dd62faa7e2c13ca6402b06bdd3efdd55c3649936a6a318e467cfefd195fca28007ad12f47bbec604f9e63850138a9b8e0ab7cab614e7d849545ee8b1ca403f6e17099708f4d4dd945f2ba972bce91ae63a56dad0110f9d52f0c0d0e7ed0a1924c88af5eddf259a123336549bc77ed3d2954b3b938c317ad28cb68f8e29191ea85a55a2ac710efd350fbfbd6af85ffd4f08c50b9f6ef2729fc8f00fa05b7dba89d1ceccb20ed44db6e98e23f080de25fb13a2e8ee1ab653234f7732ecb6af45c4bd29fd94bba2cd20fd94247c092869eb9b98ff7d025ab405529918f67085dc580ab056e11ed1ac6ecf1b76e51e46f1f3bb73a6923a35a69ba543bcbf17c08e5c38d66458ff54169aea130c9bd167a6da1234c5c909441447f2f01fcefb7659e87e2f061dbab6a1b8d9985373c35cb151b38da1be05af0803e2199aef0a88c40cc4ef7bae7826ac2a6c08a6987e8cff7cc01618ef3ce77f0e54935d09f9e498dfdac4a317e47dfa5d459a2e34675a9553bf68e4e01646d25205b8a7f2a29748df92dd050ddf529cf0ec29e4361d5cde07dba40b0618e95ab5268eccdc40654677bc40414faf6d7331dd974a3132d5ad6e7a3eeac2fff414ea133e01c2dbbb71bc5f35ed726327e09945131ad2dc13ed93c64c6d6ef1e2555b13cf6a03e9c0f26c7833207fbd9c20f6f706a52e7729e9e6b76f311126732204b47196d8824020b170b54b571daf793d0273775adddde10679833e207a8a322d452c7718c2dee2617f64ddf7ee1517771f9052561afa079008dabb0a9865e8af95489722af4798fa2f587680858c0e994cd080bf31075f696ee6b5a301aa38ff2caf4cba46fbddb93ec1ba36f23178f8c8151578edf6eb525c3f7285474dd6fb113defbe8c81da4adc246ebdde47f2cb4d7759d4a1e6cefd04b8400f56bd56eebfd433d2ecc4643e399d862070766af8c9ee59335a143bfd8c27bf9916c42ab0669d6b24668054e264886fcc8e05f521e5b42f756d9608f253c110ef64361f43fea95d8151261f00a25675e112b49974edbba7a5eeeeeb4ad1c634ad0da4fa9afe9c1f5aeedea486620f2b3aa3f2fb6c3f4b4ade6998dde63b373294bad6b08ba7600f007e447b495f997af4e3d6b19c208ea2433cff15ed24a61a0fa03664262c5659f8f2d3172a6079227ac2f165a09dba7759fe8c9152e023549ef49037f37a926cc6afe3f4df23cce0d29dab5388b60149448983e3d79a9d3e7a9930eeaef274b610329a2d9d7a52bd6ed4155ffbf2b7204cff535ebc91df86267d4ead6a6f53658c6c3affc9b144f4fc8ed5cc5188b45d64054036bede058ccdb7771b5daf1762c7bb58facb83822ee52a00b661617a1edcfb33cf0bb57f034a9790e49d834c09d03437d2212971da177eb1a727f01dd7a8e8fc7215bf42bab2607dbbf8a8ddec98821cc79db67d046fa6b997e734e750a2778b5154d1212fa350f8cd11286ed20074c2fe2664acaa3ce8c29a6cb364e8b3da806f2f9daef49d95deb008dbdd93f38398c95e28df6854799590e49b5af1b0bb68109404b0baa12c129f8d9aa05c41d10ce190fa6ff17cb0dd59597463a8baec0416dc674b06180d2380177adb2628b82c2c5a812ed05866d414e8b028f517ffa0c8e573a94ac9825e859860b6f158c521e579bf6439d724b49472d51d9c13a7f70b2812aee99a3e3ab58467cd7058af88981d7d9702f19d68140683b68df6a69be11d27e19f718ed0193e8df60d6ac35196d3f57bc786bcdb3c06c7b244aeeadaa66fb6616218a8a7cb54a815a3a56e0ecc24cae7bb71b35640844540996a00d9b3635787d0b7358ce76960c14b8cb7c017719bf373b07955d98b4e30b2d30485123e1b9766417441f44d5cac25aa3edbe0c5ba5a23e71d02e0de20729bcec38a21d323a5828dcc7a28dd6ec80fadc7939aa0efe2de14e1a51e9dbd15d3bc5c365450261639da547079d98f7236420144cb58e89725a7ddfb13b683861d0f6ffd48dda842e10d5848e389e445c8b07fb1134ff3984bc49eb2164fa576639a0fc0917384ddb77c81304e606a733652b48cdcdfbbe766a6d353882830db440a3a9fabc24add6df8130ac1d90dae75371a70203c4cc4d7d4649ee7f79a705183733cac6675b1bcd1683081644f72b24076dfc9f3214ed12ed35e5935f34d0dbe3a316113fc4918ed2e127a2d941b48b714a36af6a647f5ffb30632801f1f2443ddcc5c34c5d46d70830cebc028a0c79a8e0971cd547ed0d71b501a7e206433070e6d3f7c83b991b91d00eb5109f266054912324b519d1a99c2291bf505df77b8d9f1696d4c72f4b07edefe2f1e3e8c2194b4392ad60728207767c8a6254de3e933411b5e8e6263d2992973d1e397c2b97fd0c564546e315eb7c93a1ad832c2f1108c6911963b20d91f1ee2cd1c7087087a2a570b0d667d2c066e3789965a4e5b26a04c47df528881c522a3670a798932a1d07ddd571573957f31a67d0bc091c95c2a30bbfe634d4a56023905f40d2e2aa5ba8a5b11f829c1afcaeaa34e667a2bea6b86936e67661f92ee5537a7f6bcc4cc784dcd5593797dbca8d6097b7a7ef2fa9e0a93a1af6b9ee28a5adbaf292ee183359b4afa3eb3f18433b7e99969709f0bbcb84a34607513d302b43ed76871b7541b4d6d64007afdf9f0b3b31d688d057063ea0a75c728d1b3c972a89897b02d4db79a14951257fa5ce87a3183c73f531e5b1a49cb099bccbbebaf438668025dd0745e07e0f753fceab8b6557d304e14c3500b4b46290bcdb5f206407b633384eb993ae47e60c6f354b8ca1fc2b9f9212b26fad7f6c77d1937d4237f75510598009e387c3ee1114ff5fe45bddc8db9ffc66a605cdac882f75163597a0dd0b965b510fea235e0a2d839a290e1891870e8fd0528f765990b8a14c10ad51e3f5d24dda28b7f04081b21edc2c6300dd5827de6ccb4dc9535cae68d76bf3e93487827c317bb42f5fe436ad26299942fbdfbe105039a4b0c0e4bb3e055265929133f6b6dd4a2a12e562fa7ef4b32d69d8376fb530be882193cf2af01034d7ef52cd9cb15ed698b456f082529cbe1c100fcd2d8e1e6c7804f9d715543d345efb8ff690e0af4546bcf66b08b3221f8c4a5506045e36bfbe28802823caeb791699f02501543ab3b8219b0658e47f5cf0450460337bebb8dce440f26d4955337b7daf1a11788bf6dc2607f5a7b2e078010f72905c9e078919a028fd4e7e91e4bae3db79b1d9df641247a894fbf7e86195a7716c2854d7748cf8acef080a33c470ce246eee9a73e34b90961b403d095854a3f52bb6e4baaafaf19f7c8cf28f4ebe52c1400ce0eefda970b69a4f7b617ad3cce3c14dd485f0bde04e5c9024704e5e5c1941bb42793c708124ce4b09d3ea60dd65a5b1b4f406f5e1705de1e08e5324db059d012a584e6b8448b9c64cfd2ce6406dbbdce7bf50851f539d7db5435bcfa4d56c36a0c56916fa81376ec0159a3b288b5b54e37a2aab79cab156d6cc2dcab32f75bfe204a50920d026b3e80898d2d36f685bef7e70e264f284420d1ed72936dbc74ce484350a1772e0da0f758802507776dd82274a3ac0b5fe48016097a57d1ced508c1874b7abcbf9bd2a3ba229d4194adcb03183967657dfc085ca73f642eff8cbf42b057f1751db095c591190c2c89507190b9c5a80dbb21081a9ec617e28c6134700f3d158de9de7b69e081183c012a6d979792c8c8315655d5e72e082b1547a0593969c0e2d7768921053b6251678503d09a17a049c2a3a1452b084c8c17df5cf9cdac1b59a7695448938127a9422a93620c2e5df8e04c61f262fd0748801fd5520fe8d689d2d84ea0a29a4fd9ecdeb601c8e4b231b808b9b5b7bb4e244e14c7d89325d63c8162695cfb08a4d9eed3272167f7e14f431b039a634cc0ca9a6ff691802bb9b95288a5b7f342175cf4b820d46f83ae5f95ca9287fb31176c666892743ace23e204f44fcd3205ddaf16b751a1e22329a51b6969a6639e9dd06fd1b8136edd7f5adb93f43f926860e96ac51c714adf05ab88432e8c4b4ba36482d80c3fb72a1e2c14ea618040b19bb6534ff750db30a0cde60151a710528c871ac013d529ddc257041bff89759a25619f7a8d1daf8a0e5cdab0c09443c7a15cec89ee4f2f568ce084401a41f8c049e87d6efeffbcc5ced3670ee5934346ead11b5d47e5716f802bb71a2b2fc0aeb6ce2064c4b50af39c9d30436ada9620006339125f2c46f4ea4bfafff4c9a703b0b9a0ec77e7a862c46a17616daee11636bbe83cb8e5543c0c6193478256d397992728ce6729249655f98becf1342cf71d397defca2b8c0da8ead9773716e2fd97efbebf76b59fd836fb1fc1777921232706799f4d4f9e154507bcf6de778072efa40a961f9b0e560a5112dccaf2d0baaee0b6e1ad3f7bf3568fb0f4bc43b3bff2b3177333849e5518aaac02701bed774d8e898d7b1081af19d7b6758b84eed0d08d07950daa36e163938e8b64de3cf71cbad1bd539955147adc34ff7eb482ac4c8569428978f3978e5d6824df123b89b8d58ad81c872d01582d2322e9f9fa8f46dda6c419be68bc40f5c7bf0d9ac570b3edaf0208d73953a695456ff4f3c94d942c5f9ab6862b769c5265e09b94ee4d2822dd230ffe1e48672559bdb513e9b9348a677d3ba1f1438d994731f0bb6e3874a47492c64101e2af546c64411095892222deb5acfb7e10cc2aba7af01b38cd5c5745350eb507b6821c48fe8f0d0f895dcb4880d695acc6009d964a39458b7335698191a8039d89e64defe5cbcb4032b11e313597b55c6ed310859eca5cda5b0235b17333a6fc97c535a5572cc5d4ffa75f95fafba01ab31bea81cd9d34827cd3a658374a624324549e7f222c44af0c2dd9ffa2e717f1e1c73a884d6553a75f88d29a27d384143622fb369e2a86206a070b4816e7662c31bc7a744ba3a4642e20712860f5981b755eb1fcb62e22e05a3c772e637d49d75034f2080687bf225edbf1348b9b2b2f686c36d207ac61cd3d7797e3aed73c1482bbd1699246e3e7827fc0e3a44692e986655e919d99b9cd4050ee4826c8b2f2cf50d929ebda4693a26b05234594e24fc3acf6ae089985a702dc72e80bc9e27e81392cec88ca9e01694e91a8d41d02affce0db6ceea14707cdc6e0ddae7abd23d0de5c82a04af6754863bdb0210e351b2ec6086d11e455d3267742d17dc9a1861ce6a3e823134caf1208121c7b27cfb2f42cf795a81d6fd71cbb0ff78547e88d4d9c1dc95c9050329f482f38da7a718de6ceb1133a08edc74b3463509da3d5d944b4d019e083099a2e83980f6d9c541da5b66d51efa19b1149b2c5666eabebd52259f60d0b19b240cdfbb450ed6c783bfbf61710a26bb2d7a1d00619a710e84e6fcec0233a1626b520bba1291a6486a32ccd7db0c947fdade7cec9983b3317156868db46960e6d4db995c562f41bc025859425cc98d8123acef967ca2e5b713767f1e79e4407d8b2f161a3a8b646bb913299f79b9ca0da760b65c26800bf61cc2777e62f352094ea8de7ccb1346646b529d286648d61dddbb4a49a374e4573ed4c9817dd34d4afa4e9b144fe19c268a566e1db47685c33dab2b94a90a4356a637af64fd197b1f795c087254033df4c8929f24099769dc0fa2ff306dd9f895773c19de07601d667e1985fba660d327624c9dc3ab584ca5f6dd73258157600c055fb423cba8dcc10f2e5f6d66aee5c9deb5d472977415783d307bd94088d909aa01bcbed5be2b47f2e8aebde73254471e6b18e6fbcfac4c78ff41ed9cd9d3dfc78aee60b9207b6f2bc46ce81904ea026811b50a21754ec54613178f06764c35d07d8c2a497fd719bfce04fa914ad985e9e69cf2a6acfd3e2febe2d1606c30aae2b8dfa6b8adc07c40d4213f1c16ccc579f22782ed5b4cd5e3e50bd5568bd8e829a07407d4c58b6cd4557daeb42d2315ca5eab397d61d75a961dfe31dc95b2d58137a1a2d79f55275aa613ebc0ccdef6eaf141de25921aaee34744077ad8f63d8c8c2137b286f195cf301d3e3aaee42ed5f01b551f70b1a01194e0b78192a0fcd5c8e79a90a3f29a39e42fb9c6f661381b499239509750d1c2ecd74584c3d6d84c54b3678d5155cb0d80e75df8b3cec53734358cf9b667a47dc44be564c60da45fe79021d079b88ffe8abcd105d8fac58f13632b725493f152b884303c8b4f99110c45737153fb7943ff66eb6bf96cfa1e8e29e2399167fde5d039ae0be361ad25897e7d0b4fb96e23b9cb03da33c4d5f3d5f6a9e7845280571d45508c9884bb99e26142fc14cc5e940fe9bfc7171c521e767d548cd9ca81e074aae05156c28f6842dfca3c0c53e062712180723f08eb4103cbacf17db8af200c828994c423b57746790ef475c458649147d42c781c0d0b00bb8f76ed4007a6c4f4870c6045fb3f657ebb397fbba08a5404a5adde7b0e09f34b92ee065d3608f6df0842100867d41155910196ee6bb1e8e95b6b3f3b8ccf500517cfe75997106ee81a3b437f586de5f83c37d013a0aeda0588376029202f80980da0b46152b7105dc5a3677b7c54891f43fc73c3bf89eeede1afa194f7db74af9737fa946b83468b6f5ba6ff17347914a640e40ca42f1a404161fc817e015ac0992bc9a88c9cbd6a5816081de8adb512cc2e0404f619287c3896e288f4091c514e49a2b2d7efefe38332440c7e1779755f5b583d482e7b326e5bdb96cf65053f75d09d4c156c043f2a3abb5cea72e23742a846da0ea193d856298b70c76b77ab04273020bf62e2e2d94e30a0241b53c515ff135db62c40b0e3f3e2672ec4caadaf63c78b5bf52f22e988b1b08e2ca09420f7802260fe83ca0e3491bca033f9af1ff27b790f472d3076613bf17dabbf5f213d94307399670ff13383437f3d050e60a6ed86be517739839968e13d40bdd10394129d7740fa532ab3540c31a7e8dd832f8987ea048f746a90a7470981ca282cdda16c828ba9f6ed8f1994d59b8fffa80d60d0c9e5c6441461326ddd781331fbe485e15ba438ab6079f65e0337f2f54eb81cbde4e829163c1c3f4124416533cd271a8d0f1849a97635933237a250413e2494e8982e081847fa65ed1e922162357bd3aa7aafcb7fa94a641cc4af585ec4437e5886316763e68f5d22c447610c2b6026f3f1049ebaf69e8b732410c1d5b4d6d514ee5994b5150ec4f126f5afb186e7ac7abfc9d40ee2d197b1b7ffc8ca4783aad606770426d44857a1dd41764291c1c79e6e9c4bc20417f38b7f1b0d1ef6dd0129fb80e7c779ca7d07cdf21d1376ee847a11aa848f83cf019816a4cf008f4e452a2012d1416e66e324aca2c78ffd67b05494c28aed1626296d3f54de45b477e43325c010f7b67ff15e74402780beb91cf2e2a271eb722dc0007ccf3756e711c1014d3dd2c9feb830044296cffa7ed839eecc6440403db181011d993eed59adab94408386489a1a8d834d846a211ef8d1bca475270e32d6c13c3c544377a23eca9b22b1a550dc5fd9101ee177a870f7705a182ae5be287edc62748a6a846e09d6946df1da4112da91783952307af2b591b74c58e1dd157842d609c2fdd59fa2560607b72a646f93470374ba792753dc1d58ca4b0bef242de63ccbbde043f9bb7c84684fc6d8b3c0a4f51e60fd2cb5d9c0de3f88bab23503c267292ac37547dbad4c2e01e72439f34876eaa34eb436768d5c2e844e5c8a05e58838c6a073f0260c38a57600ed263dec5b0ed1ae7d21c065be6db302294c52d133a28626ef42cca32b8dd60ad284e37df059f028c9186a3704239a9078151c0dbca959c9f69a6c98bbde3590c53c999c44287515dad1e3943499d27b8ae4a8ab0d720845d320521e4f02b545e318e5bcbaedef3a08a39d324eaa434ad506e504f969fd8321f14b95d505ae3e9391b849421807b3e2a24c98ba8f4776f00d1468c52bee7d27f4253200ba1bca43fe88c6ffc6db901b95df832a578bb4c9565684ca55f3d1c9c56d0a96a719fb92567bf0927d4f493d14dbfdad332a834e0713905b4bdc49ea1d108b5df5b080d439c6de5da7c4e7a54f326f14c12476a3213f444f02e1183248ae1d9853b9264099aefe751dfbadec02c4d46e555d6fe4c0332c1187bad0c237dd697d9e76e7dfc9cf741fb5378d0494023a6498e96626c94187ecb627a9f726b3dd09084ad81867d5a2d00ce83b55a80125f6c4c209e171bd459c44c76729177e8493ace4580a81602f4d417f89497cc6af5bf4eb0d15b5973d968cfcc6794805cfef6c0db5c25e9c4eecbb63dab86936b496a339ee94e0729e97b0679f4070213efa49b5c76821a5e46bf7134633439ca8015cbc143d1816c3b3a295d6ae0b3fba88600d062a1980520a0ee5a1bf70cd932f05623022d2aa542a77ce8d0560a25473c96d56c20089283712ccc108c117fe21660684a38013f23bed133767d06f585fee982276c8574b98f8bfad478db0de2c96ac31a764b07d9bb9e7f2318a35807f14dbe62ae87a6c53273d742bfea1611600d033b6a07167aeda0eca7dbef32157b16ed795f306b4c75186fcf981f1ce5b76a0e5ca1efcaf3daa890f5d799b413e846c2ae735fa1869151b76638dff21ce3c808f0c4187ee9f5f58cc528d90401c4773f6879c60bbf0da80d4a6bf41ed9f4e4458f751191a770d9394a1eec1a4f11d90b6bea8814eef533129c2565039efaa41c6223bae82e2bcca6464079274a8e6fbeb65af5ac0275911bcf8887540c7c5a0aff36d4e6b27568ac9c7c35b7e79379b475c04e365e99d21fc2fd72061926cd2a0c5f584cedf2f96129623ec035fdae19da374d33f1fad804d2d3a362ad9444687cc13a99e4764f3accb14daaec93d082d25c17d887cedab835cfa63ec24986aea262d9a3fc3ab75eb4c9b289d612315e6c3e6f204af83c7d8503d2881c86d9f0e466fdd05f4361989d10195bc408e4e4a3ebaae852939f05db8469226f3262913f9115a83aaaebd7dcf61534c82096ce8fff953eb1c7fbd068606dea6269612d1cd92606341cfdc1372cfd8640fdb8fb604f0d931b31812d76752223aae40ed159bee2a54c0d6ddae5fee45224d56c98f0b9ffaa2b2be19197f5fc0b4aab9ac101c21ec34c7285325aa0a488b4e0442ad78ff9cddee0257b1fa36b2e7fb60543fd3b7a284182cf20f57d15c2e834d8f2f71024512b06d386cffc8398b6f044f0740fdbe079e17d0972b261c1a93abbdf4af0cfc8f7cf6ea5eef12c4935702f87ceb22f55d53c846cd8e16bd64fa764c42f77e9bf72045a2504311630e321628bc491ced98c5e3d6a6546720a318839551c22f4032a08f0d34edb1ff8a25aa65fd8787407b25d33ea24b299fa3b18ba46bcce14de0b3e27b41088190000e3af01910e6b4285fb98b882b854f9e1eb13447423eace8a8973eee14d99a510d652b47c9d55d39c9d2ed46bca445dbe1299f6ed503e90580ee4be2827b91a433b2b6186a0748034793f682f5ce0e514c1de2a4d3869f120d20bfa4783edcb759878c6ef7ec00f07017b8fc88224210238a04f623bed5ee11183069dd227e20bab1cc7f679d0adea18cc42f28f789d862a6071e48e07e9fb2a1307587128e47001a1e876309dd88a2cee812143ebf3567b8deb0646d88346e4d2696e4280fbb3bcb79ed4c61f2282d88a55221541e8186991fae4c846416944e86221f37814f77f0d471a01c7bf2be61d05ebf207633b4363ae71417de378be6755e9966033b5b3f30e26a9e45cd4b50b07d10345dbc33ff97d9751fb011bf83379e947a623bbdac6a50fce2e3fddad7aae18fe273f1a41bf956006bfb4e5c49513274cc2100b882776e9f319f2f275fc2f259b4c64cce5ba575f56e4067c4daa0a1493059ffc43d9a2a51824ce5127f4db97ac1ba0cdd814411feeb4993b48b60072d2d94271ee14208a28015aaaf091f95e5e4ee101e8b56443ccd42052c529b5b4b64e748e57e5b568e41bbaeb2f88ccfb3bccfc0091065b7cf8c1ddb6f822d5869f6ee6a0f0342e2ae7b148e4942db5732a6b4840857437a64427cb009d3b5d981c4685634fbdb3ac35c210afcb372312cc89fb37cefc7c8c397ec8282e002536bd3d920e94347489853227f7489220a5014ed8c7f157db71fc5f887d49ba8737a6bf2e005cbff94e3c5ca77c2c07d2d9a5c43f678a2a115b3ba87177e709bf823ed7cf87ff4c49759d29ffc781f8a67b1bcc18717f9e48a796f1e43f6e863dfb49ea41ecb6f6867834db9061717e24a58ddff12b300042e4e7991550390d9a798e44490fbba2834f0158193052a37a9b89453fe935c9fe9192a3acb3c755c1ec6902480aca680f68e3fd421140b21e156b614cd71115e6da1b6aa98b8e1a363b24af0e0275dc35d48cdbaf9048586e76631cd68df5307e57e891cdc88b0b15c99f1ba62492ad8d730b7a2fae2ff3a32a580be47ae4f9d98c51cdf698777afe8feaa833b46200829d1d6e8507849bda61e738ab2bd709f249d3344d23a11e7a05f654837d745df23c4236f82d10127880737974b1890908c85b94e4ffc699e8d06a97c83a11fd1449a4609a507f2d5611c1cdf1ac4e43ebfa132cf0b19d1f1574b9ad3729672fc36b9e25f0d07674be10cfaf0fa7c2deeb3c1bdd37a75a25c35e7e4d399fd1bda176b04769b9e46bfab3ba364838f09aed8971492061f52bf8f18dbf23fecc3419b74ba575c455ce82a0a39e9da9a49429ac938fa63151d444320f4acdfb84012f619c842c8d52ff1587fef35001cc260df234de7ab2fc821565b0f73d9f4508ec9471eced3c1a9decbc69513497083be17207a75870c307453ba98640e2b961c3f8accf217262fa5c865a6c17d9521595221545acc1dd3059061884eb0c719b68855bbc089ed75af22f1ec04ec9f066269df051b7706eb16ad8dbd5190c13a5d0a66cb363be726e5af0187938ff6b1a12de73d17213d92ff61313e3d2c5acbdf714e8880826eb02a5f6dc608e9d22c24b4636459ccb04667e2d4bc85a7d9c9b06cb13f7902008ebc396caee6c7e0c933bfb7cd36b2e311c34e0434786ec602a1a2e13fb254464b9b7965a76e9d7c9191056d822f2bdc1868cded4020c0ee41138ee1d057221d5a621a51f278f12b0ea94865c4afe03ada9a23b039a4143255b362c65ed458c2ddc29324998efad15c69430e8c0d5641916e40b2851a3fac7451fb5245af856a7a4081de3eb7741eb7bd97494037f901eb31fc8c6abd6f5f01a04e8082855832dcc7ccf964b6c8259b49a20a3635952a7752c98279a74ba7b08f03bbe4f0bcb7e9071e484ad122005254d1a002a704be0561bb41e16b3a36c9ae8cb64419e5bf8c7b6b0bc139eb13e94016256b795242362c7b49b7e67b5978410b891bea873842d69f3977814b7711854b5ae9e9b25aa0123e7ad0cd747011bb71a4f16d450038a9e60e01a52635e2cfe301e14c80e1cf06d813280a6a75894fc063a43102691907beb8a20078ca36ea5902497a96597f4a7eab97afc804e4043fa860be29ebab81f862916b4b6cf75454d2a175012504c1403142bdd738d11fc9479a6c5d78094d4db8837b0e311bae639d2dddbcc4314ffe003dd7731b71ac17a17e381e76f72e326334f6b730bfea039a1eeb9ac877fa3fb7f6445b1d5ff48f4356df606ca08fee4ec40a658d93cbe3a8ecd1a0339781b26ef449740da0dc0ffa9b0a7d8dc2d8b53e5c57cbae188efdb2667385add95ad7e5a50ed5780106b392131c031cf5615177d80b05d844a555258a4258261bf785c669aac5cee0ef72d52e00e621405c4ca590b437d4e10daa7577ff6874ebcc7bf4e3b46277050ffa7ad5e9966ec388e16973ac84cbc4c36d025890cd5074e3e8f9d98e8c09a26fd2d1ce877eabea07fe87b7e233c7c259bd9b782bf034d29adbd1a28641bdeae2c141bf8eedd99df000471ee3d91680a96389e7d526f4fabd05f618040bfa77cfec016cbaf6b0570bc0bba41382806717a4f49b1303c3d218fc654bf35cb3c0c3956c059c8160a83771787c99f83b91b030bf640ab1dea00e7f93ca6dbdb4ac1d94fa097e3f33c7d7ad32f33496561c19609434b288874a471d12cc89dd6d7e5147fa2007b3970795ceefb1147b8139b468ce9a283e6e954e9f50fbe82af4317728b7f9b0b99debcab67c481e645a2c009d1d1c89b83e8d37a2ad10e0c30f4b56975f937ef3c6d9bf125a8613d765d3e16292b8ecc416c2e005ef1a42ad206afd52ea402c283a8d7274ea67af10b654c0b2c86673f822935bcfe0878267fa14552a1e27e9ea81a301ff91380b9a8b393e9ea8eeb73e551130f6efb4ab98275eb8c5551de638eb1c97dab454e9f14c10fff0d5cf53cb51750a296b906df4e1cadb8ce432a2aa8ef9afeac41989ada2b4b18b0d053aa56d41f4f144567ff7fa64b68225c068243e6650885705dfeb2fe80f6a8bc28c340ff2ce2da42c30a51245ea5c8fd8578163ac64dca2b5a6a666cffed2b8aa60e9d5b85f8a3d3002b81c3e0db8232950890861b81c84a1b01b3ff457132b37947f7759eedf69312d96e5988bf22803b6cd40dbb7f3cc7ee783c188e23d2debed24e74f31aca445ce0dc0f346a2b6505f9639584cae288843c69cf9d0bdbf9ef60e795cf445972cd965a51f65352df5ec925f2d6bdc5f92f0530ba181555668861d0b9a79b2d4e85da200b7efae969d0794f78bbd0904fcf30d63f84fadbaae581967f7cf9a7e233d435f66f251f76fdef0369dcf01477495c10c75d74053fbf7baa58e21c0b8897d424fd9093382205367ea8c28c1378cf4f1b5bfc6392b476dacb545f55da26360e7f6adbc36fcc2d3075045c699def900e06873b31cb894ca6beb7b59cb64ef329ee8feae059c43c795bba9183ec11a593dc80d32e9e20ed5782a16b722246ca01145bf0541dc0570d16b4c848a8c316425c3ebc3fb7075efa5082dac83e5acea59c0d62e026d09d712f12ba1d57f93b44c7a71c4f6f29f222056ebab0efc7991a44d1a8f26287417988e65d00ef313f5db8daff2eadc76e384830bf5c385c091de392a404fa43b331ca84d1ccd6002923a81a02440dd7dfafb3d50f9106441a3959a55b1152b91f3ed0df980b8cfacaffa84b89be28c3f38da9d31f8f2b2b083df293cdbb18f05da1eedf9ff69ac0de8c9693b0954f306646173e500eba5568a88bd3f25cf88ceb403135bd686177ee9bcb19b8661cb64fe1fd3ad0c541cbb7a9017afa37935c930ca8090090280f7e079828ca288977147c54717a08064f9bbb1eb4e2d2f13b7c7ff7d35905411a56fceaa2a42232dec9d120bd620619940011d268a39e1faed37e7edc266c76a6dce0ce9bdeb7d299415f49ab3a2efcc28ed50f470f9e89a5378aaac4d60756b56682f4366d59a64377e6ac3d2223088236f35f7ef57aeb89234a883c026277b8da1d4e14bb38e059dfd7f0fe8692e26a97b06757dfd6543fb19c022f343d936338714576cc17c0feaa008244fcf2f00a74556018647ba2ab968ce570796540e29abb95b04154ecedfe9a3d41d3317e7758aa5a4b06c2c2a2716ea87151b6cb4f52302e88d38553f7dfdfbff70019c744fd0f03d3f9256edb760b7a8027724d2758ef3e7cb15f2529b14d2ec1fc74e4e73d4924e9b9bad6fc38429a26e5c9dcdfadb89b8200036af5a4cef2c946533e420da1e1eb2169024f435c1e09e3de96962f6f867bed758414bc9b5aa5bf52ba95122353159e36459f8f15e12b56cb23982fbc6fa419cf21bfe025b7743ecea38545ca9c502645fd95deb2b04905ce0990a4514f48599df532c24c7a123b39c5fff7402a79220937e24469e544da10d1edac70982c403708302a9147758746143172d2cb7f225a2a1b4cde581629798079097f3fab44838b4097de99cada1680156997cb223ab48ebf21c80447958c040b28364c954436ec820ba017dd0c0411e6d0d86c1775fd7e834a76b7b26810a4dc07b8ac5e9d725e7e1cb0a4f0021a14006635994a0ce1bcb508233335683d280a6562205834e2e55c61054b1c8efdd5ef4ab90ad19abe17bb4522e02736b9db20a56e2b8caf7161a4812782155870c30d07f805f1200f96995f60f2db3db9725aed6ef81bfc29d1069b63ef3f48fd839ef96dbeebec74e197e9553bcd4e61f7a96a1a2c94b183582a5ae6e4e9355913835e03b14f3e7696c458bb9e6e87a7ffe9242774ef17a50a63df9e81dde2190e3910d7c2d5c913a18b21d115cc4878a44f591bacab31dd2f06b385884e80b067fc34163cdebdf9270d80d504d5ad1efe53b35f6c9f5d9cdb283caa01f765714a82f1c109f3d23e0c48a45284e7c56617f6f5e9729abe72af63cd3ac222677147a3a43bbf9aff29853db3d3e039d753790d783928b84ef4df9f64","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
