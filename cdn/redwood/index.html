<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"de9c4edf3573e4588e21dd1c93dd5b98fe0479a69d99a107f5fd8d68da549d9ee014494b3eedd4c694daedf637d47d9913296a2fd8970ebef42dc99fc711b1ff9c8ed21556cbc18b5873c759bc3cbd3abeb3baf3b87ebab3277f791f1cea31543eba3b12dc4799b1bf35b1aba56ba2dc02cffd030e14bd12f1b1b78fc690e6d926b45466527dfb17e9c4a2b8eb21945cb88765ec4c9d38d4ec275808fe1638cc3f815a138f9197ead4cac03ece8486224d1104e65e1064a8800156622907a1f65c4f08990cb2f9a70af42c285f6507c3f3c784efc1860633f79cc9e505bce4a41063a4d22f8c8c0a825da9228c160b8d78d267d50adfc1c518992105ccaccfca477277a480cd708a576c66b3d5ce137b5503233acaf353d8e8e98d3cbc03fc3b08eba67ec9a11277bdd62b4c364920ea2ce818c96f76d49b66655f53c9a52c6a8fb8d00c561ad87e07eda027abea4d06a9e145d08bba3fd2e05d02791a7541fc30701a24d098087080e966827b14e39441de6c4c6736429c3a09c9f5ff7262d225eabee88d4564d140401854a790ea62848b8493b5fd0706a469667bfa39887395777628e35e027ab705ce2de654aac57f19b5a16557a6ab8476e6b5b8b4295b0807828b511d7aad1b5b5a34e384b771771c0941d157f20be4cb01d280fc0ed135a839cf58abdc1c024b293c4828da07db14f237f1d8edebe65780eb7fcab77ddab44ad5b821dfdf50cadbc75d59c96df0489a2bbce16642ea0d357f0082949e72fb7ceada09caa5a2ad7879b9b008333997783ca314888a8e700800e9fc70b5702bc741f89fc2bbe606ca66ab4adbaeefcb8fe8c2fe0ad0257f90372ae1a1f2894fd76d0a1903b531c6dcce3dcc682b9ba62c9c5654db092d7efd9642d0bd6fd3fb766b60f6806fc650ab30bcdbe01d39b83b51649b688aee0057ea8f247398489591b3a7d1dac0dd82f7f79e42672ec7711ff10148bf518d6da7c0532385003542ad1423d004695b28e8cf24093e3d6bf5c7052d7a8f30087198bb4ca254048f377519be6731c191e7ebd402aaabfb00728644f3f2359b694e51f6fc91314791e414a9a4c8772d822bb14b6189bba33c22eea8c93d975f6329a07ae6568e97643b55d4da2b21a55d361fc6089bc7aa2a04a5be49d4424be0d4bd1e972176be419dd8c90e740d656c0ba76e4de18a1a0a4090a575c118746564bf5a21ac90a97c1fa98faaf1a96275b2dc2e4f530055c58f2cd38e979c280ad656e76fdd1d83e65da637d9d7e2e22d156be2556c0e9c5da3e141128224f3b7c80ddb5a32bf525cad983afb4127688ab822b79eda84f7ff3b3af660afcd7db5309264600c017e31b212cc189e8cb72b4ccf542c74196dc27e6eb865505854843e424f52bf522937c573fed77b8b3e9816e2b6d0b551ba1b5e044e9598cf15a11b65b685c4274ddfcffbd6510863c209edbe29596263c12817fbaad78935243bd1a9acfc333ec943b2b9737f1ea1482f98be9cbc4a62e52f5cbeef39fdf34a6197746615c8f19b4bc6e7baaf8568efbcb1757718370f9b271b45990cf6db1e8d13a76701f5e0a71a5cd649624c3926e67974d833a64642c9401d96c174e61522f2acce9129f8be530de697bfbf2d605d2ceb1cf81c8025530457c16bd361af2994f195866591290e609664a904170774411db4a3f7bc47e14dda933daf9eddb356c860d675a8643dc809c02b14d1ae1d9f5715834a73c32565189ef49f4f458ed6f8991c687f052b932a06e48e069b46e12dd583a940d512967cbac1c41e90a7d4c960790508de7ea838e1ebd4eae3d5587f80d6fb9d1a719dc0cdd1c9afc7cb8fe5d5defc9d46f1d7b441722e8be7defc4355be946ac04997d4cf8ab1e88f662a3e1719734bf91911c6fd055447931ca371b96c93cfae44ada1e0b0529a7322ec6426c870078a63b5ba161431cc24a98ca9b92173733eabd2c297df13cec99f6328ad1233aec0353eb17413b3d5320ac7b9e191a800d306a5390ff13a1edc6f5504736db28d95bb8c5eeb19a6afe6ce457b5eb96616820d1e07e1d56fadcbbfb0a5526b8b586a7b29e82b0623bd0570e44794c65d588ff28861b18d86ec34e58dc0ef24ebb71a051ed831246be3e0b55ccce470fc66b47d971b033580a954cb56fa3f7b3222837aa797a540ea7559ed3322e92d95a8f6e377988fbc3405e02c37c91669789d60a76abbe21d61f57b32d8b833805d25ac00fdea49f191c30d8579feb177dfd79fe82d5fcf5492a04e813f06993a39ecfd93b7ce115a25fec8871e143f390e5248af736b966a64e0d86743d46e42fb7f07b61bfdf8742c58f166f75b15e9b34810be7b248e9afc4732e95c1d7bbea752b93d849a5838d70cee49be59cd93e18713436f0c499f0ea45b09a190a87a069049a46dc7ae51b130f4bba554934fb2fd317a2f9548dc85bcbf16c3162bd5c86369b534f7875cc6ac92ff719eb64a6cb2d228890eeb8e0bab0f9f6019a1aa7319d889a4b51d5a249c2e05e40338982d5f3014cf9e129c166c9044eaad9e437c050f53787b73990fb3a084ec758240f349b5b858fb0df2696918371f43d593067d7f00dad0d538cacc3badfc1ece5b7d68ae332776516d8365ccc86cff0f6d7122a62871980b9b02761440c24499c429be9f8871972818e5188de11392cbe88693e10c33dacd8fcb26a7121345c31b51eb7b8c3ab59b8850f892ed3bd918d23cbdc1f9a78ea1c83e7e2d1784fb7c46221a86f9c8eab39ae481f2ac3eb33984da9f955f535cd024dbaa40b170bc9b84d6bdf6c9d65581465a8310cf82726fa1bb1fdb67d14d9e7ac55036175e3876156eb02233f33ecaa57d1454646fd7b54682dd7c5f0d0162db4b286ab432b96e6228538f0180290f28640bd77ddb5f4bf76fe3379dc71271e35bfa8604e791d204046a4031620739fabe65425cc83f6703cfb2e520260b58ac587cf3fdf515cdb17eb74d2a0cb841b5f1d533d424a26a54043d609ae92be4d0963ed86de5fc3d69262a14e375bec11dbf7cf3eeec90dea183ba87998ef355b760f908acbe999e1ae66f065ff4cd189a8d192d2bf9d1b66d3a54c72890a0b1b1b57396214ee50eb05564ba4189659b72edf43524d858823fbff809aca33a1047173310c4a1d96a59b83ce7e71d4b0d355fb78e63be6705469456fb83db8826f7ebf5eb4b6c03b9cf36c51bf12f1a2080aeaf021237128b9a4927a138af4a9354e8589639590e08945b3bcac20d94c6e4feafd8dec06e6e3bd7c569a31c2e3d610e2f0cdd3e883744db8f5b4f7705f33d8a232bcca9e7ffe10029aaa109de32144b7c79940abaeceb52c899b41161e73760ad8c703cd947bfdc1a219e5289dc2a1368555001259a494f321a73b6ce28724fac1d0779e349f06915dc6f4ee3a8ba4585a27cbfe11b462dc1161569e537ec8a17b91557dde491f8c47fc52028d9012cbf9ca6fdb849d1d12d63a505d28796858210afaee3daafce7600f78ae91692dfd93f30a90114c653d228b651f9202caf88371cae2ec0057ab2960a18fe937231ad241f9a19d09d8375927550cef92a95475599a67585c127e7acea89fd580840b7360508b8e83c644228c25cd3b41b26b23affb025f5b0775a2cf93fb7f118be51c0a524c5793c0d076dbd24249e4677327edcc8f98cb8b7cf83c76ae4efe6a7d2cf88a7b7e3131f3ecb5d18b7a65969519bd53666f45252b0e6bdf3dd06be2dec989774c3e904be0ae3f1412f919c265471cee4dc95aacfe08824fe4a76ae3a0b5d8be4fefe6c6617233b1a46cf156e897fc9c70a053100eb5bb37bad4c36cff38f9a09a5c4f6101ae1e72460a005eb7b3f03abdeb33ea671203b1c857e5cc0973ce4f0bfbf0408c1ceca03fdc66915ee2bb0d081cd49f77399c9bd875808ce58010f2f61656e54d69e3ebc2a82f7606f1408ccde99a1c7ae3eb0448f8a0e113d172f5afc738721ca76d0fa6d92e71b1b542056bc98e37ceb64b8c1e09028fa3a57d2f1c4c38d088b4c6da2c51197280f9698146c02a59bc5d4c2990231456c86bd2636869f23d9bbd3315be8f6d7ab210b97deb966738e5d124bd1026fd7dc939b5e0c653b561431fd625c7a71934baae7eeed87a2a9630b5d119c42d07f1f871dc30ed8e3bf60268edb4772cf036e094917ad4eb645fd6caea5a50f483cac5d832a765acc19af98c0b0277896d221682f89196095d40fb5c04f18e5209dcfed5e4a4b6c96511aaefc216afa568770c2737362e24fff64787f6732710cd454177d3486663a09897adc51a69e2bf4bac0a3878fa92fd2c242b10f47664982b6641ae59d2665774fd9641eebde33b5217570b89729024afba8e41aa9b946ea9aa1725ceaedd77989975efeeaac4717d685dc818a2668b663aee867762c5c29c18e62d274ad605a77c6da1e112f6e77c747ceb62329489c29cd62d8668583061c3846d67cb9e67227f4596fc45bb921e366f8725942a1565516724ab78e67238797b844e40ec91484402438900d681a55a9461e28f29aea71646384dfe7ff06c954f0aa3d4c0265555bacf2c2c6b73d50a8ea95c202e1c6a643915707aa19a3e062d5cfe0baeea2238731c92d8f37966d97e7c6959bbd02fc4df6c1078b691ece8813c67a6eb8623ed6a09b5e0802cd38ecf4afd36ab7308714a83a2bec0022c11b4e7d3cef0e93f3c3dfb1b7e0e33bb1c97dc7b16bb70fd2abe51255f86143c188b0f7762b6bdde2de486c24730f23d83af2571ff8feb29256a9c0adad59899eeae3b3c57be4f250da387ec84272a3d3a859b84808f2799f0781291f6a99386ecfd6e0a2c887b8efc7154b8084ec54601a96a593fe2152aabf35cb657886ad31a6f383bb45b5b56044699b6f6564b45296508e4ef3b3c7e21b9c1005d3fbabb36e2d68446c7f9adcde7ec7aa0899426404d57ba3ee9578cf3185b264f48b42e50667147c70a247b44aba37cfaea3cad2525f3feb1a0ee570c650104eee41057f9b8974c9a807a8b2ad800557e067f8ed9596a4c0492dbcff9a324f09e3937ee3c92e97479ddef588becf100c685bff347a875fabe92a9357f9e6279f828247155d5352b0ca05cfe4cb9e88298e378717db7431a305cf88dc7a17ffaa905e22cdfd3e864916a708b7b93bba6d95ed7d0b876d1a9e9616ca36f38dc91a60b06c99f87f89e8b96d0db3cad9d2cab075accc0505bbd516c68821bfba0547fec060e4cff641ef49357c288237c8f1deac896f5d661d075d60bfdc92f5528e3265ce0a1bf1b9efe5e269e6bdd87c350fb347193ed3b1af9587e277bab429b0df733ed0c289f225fd5c947109fb082d5c4b9995be8c68b8370f60dc92c3fe446688dac5ed768b98885f6a7be0d31f2771d028a211b7bfd10e95ac701c574db2deecb77434a80bd927c6ab681faa40b6f5e606cd9a43f920dcdbb948dd561c1c53023e2249f3d12c72472bfd1aa0c53a459e529eb72c1e05b824c1a5cc476b18ac53d9950fe663611fb117cb26bbc60fc89f9817cc43aa56da9680ec3eeb09eafd36db155773784a9b482a3d40be8a0d831de42ae4755b71fffb2682e39259030ad156b124976a0adadbb04e1bc1ed7098f14fa095abe1a2d57ec2ef8eacb232c3ada1c5f098f80d078f36d0744cdbe04a7d89c1e4ccab287a07e3e9bfc532802f297d23eb609488c7877375db673b20eb2a63939c748abfd340022c093ff0c2ff49efe96d43cad3c43edf05fe971fdd61dae78d6eb12c890b145ce166d99f8eb79a75bb7b8a3de5ab6960cc1e28d00518c6fedbc42a3c42f2097de045f1b109598a0956190b1e0916b98d5a474b14e04f49de7d4b8ea8e647df87b7eaecf9460dfeecab00ef90b55e0a6728233f1169d64474a7c345dd48d86e58f3d6513e70ab2afac0eb1c59d91da28b0895815b57352db256eb22078079cba1b30e23357c6203f5f7e158e72b7ead9f0592b6a65ea943799ed938e85d8e27525b875811248830fd3865440368b7cf4be7aca81c6d6ba5f43840707978445e040695bb217a62742237c1617fff64ef32083e929448a7597072779449cb389b708fb5653a8be6e4e831530f8a0bfd7fe3d4501c4a8e261595dbbcca936cb5e37628a3ac1d91f58733ca916c8570373029f200843af2d608c480d500d4a9acd4f9daae6124f781ff2cab1090521cd9b87190eb39f2b34e84bef62b2b444d52c96d8bde00be3f2f432ade0a52483b65042b93cc1fc77b7bc5ee9519d0526a294d0930127baf143b4db2d3d0f8b877ce8a13ba688f605a8787cf5fb8920a6cb0e27c17b79f56c22dc04ed11619f20355ec53568313288a323a3e5e85b6302886a91a6f11a39e50c8a569f2b35cb8c801e18419aa13ed84fe2e1567fbc2f09fdfc9cab1ec847394b9d74fca76bd0801a90ef160b1bbd735cab9285f8add5c86f3d993022df993a1e47608b81d06d02ad993d3e54898d0b0c76029ad9e43172fb9032da65cd7e015b64dc11a0591e2dfc94914748c12a7c3c14b0d2e2d02aeb1d41db5416331f3d6eecadc63785995191f88d00c1e1fc5aa1f57362456b6d43ec1f44128cd9590e1377a382ddf8b3e9a89baa72d37135ec843ce8e5b3fbe40a4e42db386884a1a83886c547d2b7cc10d48af79c1d9eeaa711c84c95f86916cca5b3603eec538cb094d86d18730fa68044bb04f3cd7be13cd6caab53f7cc40ce756dd92809bab364a983a78d441d5500da74701e8a7e33532c3e950d6d87d2f0d5170ce2d6c7bb89ec28ea02cacabcde03bdf38fe49c4763973797605f4e1b2ef2a1d69ea7baa7eb5cab58d12774754990c876396211c78cc5cbdfd19e1b2bad4cf4b9854e51bcdb933cc823f4f0ecde4dba587f56168b6d5d0f490bab51dd0961999c9d2c14fffbcd1ea50c46a37f2ef8728624c1aa6dd3767423a4b4a53a2ecdd921239a84b23e781790f1be9c52811cbfad9452ba791432036480dfd043c60bc3d1fa832bd39571b3aa515de1c78341935a433f5fd09991e1cd10f2692a9b92da227bf04d0e18e36e84f9a2cbc87df9a4397720676836083f860e68298900e540a66a1f4468e740dbf079e00987e35347a158407a10c1db5122549d013f6f0b20a80058d129866a48d74434aac68c8aa569ca5fb28916791875ad59eb17e0f9ab5dbe4f21b66d6f1c3a9bd281b50a13e75e9a5e9cb9920c11083d3fb25562d7b7991479ef13c862ed99303ea51111c91f9674340b52791e00b1c06cc6b14b917e18183d373b06a288435d79536f48176da8bb0e1205c9fc6b14013c099836ba488f4dd892f4cff2076f7144eb4a1426ba0cea93d1f4fe394db8f9270677c9cc4694b36519fd35f7c24c18b1ea461206981acc3657f6502deb292ecfb348ae500e1ff1d791d2dfbaf96a7285bd436dde512b2fc0dfe10a70f0933288598d978b4bf16ef661905d84d10cd759efddb03e2d5c76ac4fa48492115f896771159a44630c8bd4fd6b65ac4d1abf532094ec9156ee3f2475b803c2a5831f88daf69aaf774fcefa53c0b6797f2ad3a1038c1c2532b14780c89fec9f65003d876a26b387b09e12d4ffed8f011644a1a6dfcd6b539606bbcaff506ddf1b36c143f95f3daf2e0f8c72e00f2336bc2fa54139f9fe78068d0cedb20e0c89cb13916b6ffce961fe879e614633379af941a0162999d7b731aaf5fce5c59da04a6dcdb3934fea24fc9f71d36294a0b23f24b52dfcf7cdcafc0c23b968ca3b39cd76a700831f358a4267a45bff9b305b2b81291265f849a4f798f52022544efcee3c34961f7c98c1584902ec0be4192cd0fd73d56dae9fe4e72aca798d4880464bc4182809e1d36daffb5ff3e9e00955d040dc13cadfff38d6d09305307377312f0ff6ec92faa0c5b827ba4e255e8cf91e8c529607f62d7ab4b5e893b1a3ac279f238bb65f4573d99b36003912423865a51f260e63e19e5a2b57f66c4075fef4d5f97fef51ac55483a746a54c040df897f434a5542499a7caf04f1fd3af564c7abd34143d1f9f9c0b251dbcbb053635f88d1913dfa4a82de821aa3c6b316d99c878eca066516842a606a82785c12b74cbc67f99bf5ef7db5c4f074ef741e697486aa229f6915546eaae08a4870723b4472ebc4c23d7602111f5a00d06027c14fb172a785dc6b1c6c5528efd80f574aa1e33a4baadf09fb35cdb3202531853db8415a07cd8c5d1336bc31558b6291512d12e10fd1c48e8d023566b76d5bb152e63dd08f88866debc87261c4fd4393e4343981fd37ebe75fb29160c4a03cb66db6651f33afcf8b81fb959f5d5c79367c7596038c419989006e9a44bdc36b3ead94b11bcb669c78c8c242c9c85e17712f9b53044c1092793bde59bc7fa3ea0e77588b99bad3a038a5ed6f113e850d5557b9435b957b923fca4904420333ecfa4ed3e99564e7228c621f793cb9258a21c0df168bea0fcb70450f424c9d244afa94b69d1b684f6132aec9dcbf61b9a28f8b788061e6ed61e86472777fe6c42facefeb657adc3312be02a6082b8116adbd7972fbc7209c4480e165c760cde79dcaee273e1ed63ddc499a115f6e38d16bfa0f0fe60f45147bc36bb0ffbd728de12406cfc33547736551624ef8444752aad2563d05a493ea30c9973b83fe8e15b72afc60f10e34fe4b9d531749fa62feafb5f4803b000a53d6badb169e79f55d2c2b8fa145d9b1b9100a3813c8cc90b7d57aaed294198968c62ca7d06e6ba0c1cec1a4a8d5a6d54a78584636fd490665f413b99f385c146aebf5b519bf1a88ee7e966f257f391a0bce9cb33924429fd98c68108d7b7d5c18c719ee5afb28c2a20b910cac8d920730c2bfcef6e1871b2c0a1d57d80006919055ef43dd9df7bc029654bbc7b5644b794efcb2473ba93335a06707d6caeef0ff0240d036f1e6e41bb9742a19545fca2c2993cf10bd4f05b80622124a27ae8354172f53e738500b5276fdfa1d5d099188b07c3ce987aa26f08338c26011fc7b09bf9c25b37eca7bfafef1de037c784c3a75149c4f52529f298c17da38e494d3e89f0ba619a297c27b4ea602f175f88692102492b36c208e332af887b2308497edba8052c67901e81c933eb22586d94989bd8ad25922a92ef31af19d1c5f8b5bca4d4dd7fd4619c6fcfd383aa10dc0d8031702309f23cc449dd6aa19c57b4933f8e5e4b783324279f2fe452107eb682e18a6fa7ca4a0e68ddbbdcc4942081676d3e0cf8937c7193b7f7aba8ad46904e57622dbecf0c1105364df11ee9e4a05976c2afdfd6995e103c463c00c13aad07526e880f2fbc4948cd8bc6a2b00a3859ac7a08a7526550a339ceb44494341778e337727c41b6cdf38a70dbf06a4c8094514cdcc022996b197b323705728b2debc960fa51176644ecd8bee6059206fa65f117edc118f423ec03cd695d3cdb5e8145b73fb13d8c295314daac067fcf3fd9b70b05b676b93373bc82713292cb803feeb584b9fd19d7f13749275d70e6cbee2a327d2cf36037c5e80237acab6d501209962f5163c827a34dc71df447e72e7959f3f1531af3b7ef05f599a96d80631bea320754a0c8f06f8e97505c3f7a1615be8ce616450ee9eaea3503e139f1e6445d9ddfc235420f5a44ac24a413496b9fed5cd64e5a3cbbb24aa3eca497a236d56846af4f12e3ca55da2c7489c969cfde8016f9c6cb88871339fe2a8031c9e59d46848554186297321772e9bf999b86d1ec656ca54778889e4bfed8534b5be7aec28d943b8e24ffbee93d92f9e45abd5fbf41d363e4c5a09da7846c84fce77323e0b9a2cfb7995a6816d42b4c8fd9a8f844a5e43f3c0a2cda5b58b29db915292d650c4802b140e6ff51d0d9c8ebe9be0a67e8e6d7d18281c2da855889a420b28374b166a10ae79693a14e8a138a417f2a0b6f696c05259f3a484a5113d7d5f1871defc22181b85064e672a08a35e57cb109492263cf9a148e48db43143a8a344dc521ada343d5d45a36e14a87b8037c1c6c1c7d8789c0b7efc5f71f20db5e64c5529a268ac25c9984629812ed3a4de959c4a25943d5ad05aa5acf3b2b448ef06d6952bf8464f282f967a0552d2d92d9a3f5679e91ba72f45aa8ef8ef886bcd6cbd35a8be694fab7a41ae44bb3bd620dd2118c74c8739f27c8ba5d764e50d2307a515d8e2a9cbe8b25723048641c9e59633d9d5e65120f78894afeaa4f86565c86f8bc6a24e5e1786c759fa368c0f8a2c1f7e30ea4b0fdbc0bcbd0e99629d4998cc5207debc559c55e668dd57650033e17942d28a43925b52b59cf569f7bd8e6a02ec6cadff3f86264ab6286fc88e4e714428d8818345e0ba78c6e7215303c33318f982da67173b1397d664fe9619796b7c981d4a088da0caf036e5254bbd6e49b567ff049071a3cd78928d4fcf67e1de7c803a9d11ecc4b9314bb3f4f4c9ffda799f1adba5c9a8b0acfb204f9bafb50f9f07936d046781b949f751db24e030e630a4aff2599d3e4142f0cd7b2585d91081884e6bea2317b6176af4335360c53eb2349c55d4f76c5dd4558508a0ea008f992123777ab1a7c7139b35e454624e4353f4f3093648b13eb00fda4baeedda752e16881c6cd51ada06daf49a1e12f2f6a5ba111743af8946de5bc0ff86f483351e968c319a11d81c566f644e2949e9880088ceeb0147b2e19d4d31bf6f9c6517f229e9ee4dd53741a9fc072d8353755472862f2a1ae3968245124c3b6f3e8fa2ac105a8451b5955d3b932f36e56764be527382bc93c757983bccb5295041b0af6f3df49dc155149b1a05f00d2182f2e34a8565efe127ca797ae2e1e51fe67c461a67d643fb05cbabee620d740fd0b8b82aeb4229a3c3c915521db2c10d91b3fddf26e1ef36d7c2186d20462251384a728c6978f3d5722ffc215d661e5dbcd0dfb0598f93194252dac69c7c1228ba1d8ec2cd1d237ff111d717b2bb321e88b1f76ee9e4867f7df4825927685b9d30cf316bdfe29855f7f8eecf7e8317e43d437f763e3c8c51bbd4572a00f61fb58c052761007da9abe6b4f3346f88623538b31c6ca94c4376e18aeec1f0f0f361830f7c736261b196629acc16d38336b4785ad1af37007e5136adaaf30cb4a2a8e482e4314229e5a0df58ab1180a0198577eddd8949f615611d061106d559ffd2bce5563c198a2f6ac894a960ecc518ed786a1ad23b90585c132ff6d09c81b979c6fb085346961d21d6408a5fe6174652e3728c8b6581c05c5d55ba3cc677dd0999a4c50f6884d114d8419a6654d4114b6355b6d0070b8090f07fe93a58b1756cea89535bab13e3034971e44720e616f87539723af2c644be867b9f851774641ec7b941cd82d7707ae6130433b0b5d8daad39de72627a943e6bb000e057cefcc77bb15f3dd2ac6b4c0d767ab24dbf8e1cfcb58d57370a0ff8bad9e58246ce1fffb039310672997e292aa82e7a5df06a25b184ef35b265d6803c6ea4818ae53cb7511ed89dd2877a52c02d2a1d7c2a2dc2b83d3a35efeba29cd76e14c8a04737c7da4e1ccfa7c46c7fd0612d00d304a6d8bf272aa559a1e1c8253d7c9d9308778ac482df99ce056c38b7a54fb878d0edc3ab0db34bff03ed66b45596a8794716cbd88fc55f98b65a193509352a2606cbeceef9c7d1b21f17154c69d45797307172c463ba312eb97848cdb6cf060afabb09313960a193a0fa163220ad654d00338a9c55908c1da84ccf391681a80044445d23cb3d03509677000b4e1c65f78700285d38d2741a7bf9099c1e923337abe5bd4a6656dbe92eca55a572778f81aca79f556d9a7a6dc83d62e136255057c6b43aa1e44a8beb6e4e6e302f4434d5ae97096dc18f09c02b6c9be349423e425a40e0cbb9015febd6c97a5973c5185c9d669a5897900fc052a9f5f002cead57953310ceb580c9ce1ffcf1de3fb45929d3251f5756062f15b9e9aafc2f30f08db2f4f3286ca7453b73cebed7af42778c7e54d90cb32a462c0b25057419926c9bd86c4816256dd8263c8bc7f8c70887e23b87e6ae1e48748677d3c3ffee9d8d56a3221c508e08d3bc24b71ca1fe7b8bc1904604cce985f64b865e9ea80855bad206e51dae21f3f6e7892944810b2c54dfc4ba7a4e5ad81f1095c1287bc377763d52aa33f4cf88eee51e68b43e063e650d291f385cda834bbda4d706105849543e4c84e1dc15f2069fc68f4fef3200c56d2315c1cd244f8335c105c2f6edf666ca5a8216c25e8d5e52ae8b71cc6eba813277c934c8790fb9cfa5719eb876b97f0eea7d562b6e1b462c8dcc2dd463c253665a2e2f89ba5272404f8061aad8070288b3f35c8195ccb868fe8934f87107c2d33f71fcdd3fe1b84beefec7823d1681b693de91db6a8b0cd7cf28bb535cdb774f7a5f4b83e8f69de1c521e85f55abd9e636ab2c7ebfb33f59c8a2de3d9081b589d761af8a813a9d08041e92d0f18d6e09e68a3aa9d9816086fc53db5cc6557f43450da71f1e225712678c38ec393ba8ce842b54f19e93ce7c1d2be2cb64737111a2241f0c7e760b4d73231f2e0546ace65aaabf2ee3d173323bd3bf6ccb27d8ec58d4f9cca6be33243fa55077579da9f1c673690921d9b8653366175ff3ac144b51a90e000c0f8ac462ec6120e69cc2d5904ac5019318abc8911ea780762e87e0923e417e14dfd0d6f29b53a19fc05686442faa253f38f169b8237c58be1d2acf094f4b4dc28e42c6c064b431948f33d9c2faeced11be2df34b54a3881df99bfb07d98eb5963db9f84d24740b2675643b5189e31f11784402b894b92208d79e0b37efd30e045551c30198b905231d2fcd7bbd2ab9593d2fdd54c57537ce96ca775b37436c5cfea43070a067f23563989bee6aca41b9e9e18726861cc415b77de320b251e3586ea5573112678dc9508d610e4b014eca473c2fbffcf9394e775b3dacdad2ab3ccedfd52c844cfedbc9376e71859d4064a865b4496609214a7f69fb5f207075b1d824caa565220c5cb545357230c181f0d220be74e8f8bee9a9bd0bd6469ef6bb61eee2380f7304f2b67b906323f44e0b24e91dc5ca6deb504f06b593ae48d06f43bf45312a3bbd6fd6e66f94edf29ae8524f194a8a95152ee14012bde6cdd66d07f3ebd1540539e358d1fd220f58edacc5b71e8af5ce1074d16a71505d09c97d383fea689f74fac1caca51bdc930219517eb3e102a946a60ae3e60a5e53ef498183cb323cb4654097387bddfbd6a553cb8cd5a67c07ac1877a89ec094d76a9546dd6d0d0fb1d73a00e0ed03ea92926b9051f522d43dc9d91be47ea69a4d44518ce1b95e3b7619356cac3194ac4654e466a5000680a08e5bed98def87c566f240d6f52aadabfa5814f7fdb6edd936d579164e0c7692ba0014cae1e80e3664e15053f6784c7840672a961877bbf38c92d6dc6c0e50e941e27fb1554f33e01dc46ecc206d3ef02a5b7cdf29b723bddd24fc05b780813c13cef3e3e585a23ff5cc64e3f41b1824a06ed0711904a8bd11d17a81deba8878c19c0d620d4e4998962695e71a92e68890c86ce38bb1c30ef7874f6a818cc964360601298e346b8fa10ee25b27cc8de178cd720b973d23f80d1cc49dcbd9abbd5d4af5a704f8c72d73e56cb6fe1d4eed51149c3a0fb1bf0128c208baab784e9ecb247a47c85bf4b6d67a7f4f83043aefca97471ea4dfd4f0014a3e727991a4f0d2b1275b94f5e83e69c42e46ee6e11227b9f8767e0c4836c9f95303b55036b92ba6edc6a4f220fe7df9d1bac97faa693de5056c322d0f4947e578e3f26bc83d7bcfa9bf1df0d11cc51662a16a32b2b8cea026139f0ebf09e9e0a404e7ac369fda6577d7af32788768a5f085610aa851d49b0b21f5b5b530331f8d6f95ecd9bc3847f1c5cd430f914c21f5551a5c518e1d4324f03420c9f771c9c8db003f3a5713cf2369642261a1d4bb6aaf610f227e9dd425c2f3307b0c3d1fb288f23db7e5a67e5539ceafd9e92a6e91fdef16fdaddcc2f85dc7a92c212ad9c176db6b152dd4db120c164765450ce8397ba9629dd0e06bee865d1d7f27ad2bdc947d92a14a8f467a9ec3f97b791da0150719011cebcb7e263b396c557c083415b6f637ba62c94b5789859e0be2d85b28ed26341ff5fd9b2fde91370ebce9675bf374662f38c3bf4befbd082edd77cc2d7da16c2684e3861118ce8d0c72c0f66246d05bd121eed607a4b6dd8f64fcc74ce2d648cff5bcec93b5aca884a9493dfbbf771187db89369af9f7ea256ca71d831b91630ce03a8ee611adf6ee88b7ab7a3c10cfda3d2d67286903d2c200048805e747e9ecc3e45fba40f99ce57c1b94b6098f5c4e9baad4d49ac6bc4e35683808b58f524c6a7981ed8c69eceec24b2662965468df119f6fdeaeaf19f7cb0c71a3dad93a634f5e5bfc17b283364d13517dbaf1293ffdfeee81ee0be5606cd074b72e822a6ea6e1b52c60aac9127a524d37b78a6c2bcff49d4b81b4631b3f71a2138d4b190882e51e4b8c594669f8ef2f8af0d5ece94f9005ff59da5a3ec7d56a2aa8b0a4997ddfe30beb135ab213e1b9521683c93bc2e9f2debc53271e17c57f99e11fe43668520ac761f375bc4127b3bc470f23a39daaa523f9298befa999aadb1edf98400fb3d018d17d4c0416548d0bdd812a90982ed5cf127ca8e9c0dededa23e69eeb9494038ab14a9aea67bffba21b637d5946d42369dcc1d43953427e99581dfb326455bb3d6e9396ac6e6fc3644479328763898cf04c96191cb4fc5eb8367b82eff068b7334c766cad37faf16d9b0270a8fbfe2b4b88ba517f7da5fdb8421f4ab32f2804039c2cdeaddf622c456f74da9087d7a5702bf8e5e964c06d17e51856782fa1cef3de537e44864d1a95eb201ad6215e03adfcc32ba8c3728e4949bb22e431d05ec6a94ced2a39518d00f76de945bf0d87b9ca2eaea57fb2183031abc53092be1be3b17c369cbc4c028e1857fdfc2f28c4dca6e8b956b05e381c7111b89fb8fbb4d27eab504c258184e4e083578199e4cf37a8fe3188c279a6122b60f4e67031aa77bb979cf079dc64695704e893434519c2d7650f9f054338a3ccd620e86cef581e4ae18e1532aa86d7a4653c7b11d8edb82a721c67e219b23a909349781cd6f29876c3c4fdf4c8a3958ce9bb9c795278897ec3fcebdd399894fc879e4b1080a459546c9b5c3d43fd283f64530581e2109be50d7a10c5ae36740831449fda54fabd1f7023e634eeff6f3108376b322278ba98d84e7957d0663e05d04475de2f303249e31c190a6108c3258431952cde4cb1b4cc0275ecc89de547f3732ca29104fad150a64992c445ccea2a59d22f36ecdbf48f6154867648c963db7370991308b905f88f8fe5b6e24c3d465e4999fab126e8b74d1a5406142332fb063467c0285f96563396f9f93c8b6387be3640a3b6c8d7e6a84182904d736cd190e6cf3bb76fca8bb48ef02743e6d629751ce636bcc1116e68d11da8f17f9a8f6b2d6c99c49af3ba94d473ff061bf8a675dfcfa654ac5569bbb32b2b510fee39d9a8f658b8295d55fd363ba31bfb5d68ea36b0a8457a264f957c7c4e03bbe88158e4de2a23aa2ae78d2c08584f89ece793a00fb58b5fa869f186f31b7f0db96fd8383da426958de1f2495d9dc031f33ed723804146d4c38c534083ca58b25f6fdf9e450739273a593d238f0cade799e48978b3bd52831a0b690d7a67617c39a644a3bc42a8c7abd46e6503fbfadbd2eef9f2bcd6d886cc8c48515c39faabae4504a3882920966bed69c6ca9f6e8b189af023d8ebf8a1891e8ef9ec5340b51b751dc445678a51e19432bd63bf58a065cf6cac1ceb75cb1b6768266b2f4f11edfa7ef97a250c34685f1525a5b6dfc949da362c49bfc11f558dd248d641cc477f53808bf2f2fb26896d5a861cdf2a6a1137f3b274da77bb80d79758b3064cffe7fc63f9abd55e0b8cf2d58cc484fc323ed31343891a146d897e89e203f2960f1662ece6fa57d1b469aae975ea8a63de34e9e921e215c815c23d5b8eb5f5902866863ec146a2e32de15866cebb67428e788c06c51f5e57da72db980facf8b2fe0b36dc4fc4fb114fccd5a3976e637442d719b7366b1874b625468800b5b84f5a98dbeb940428f99decddcb7f6c7f17c27ea3e0670051ce44fc04f0c1992fb64aabe46358796502b9660d56551f3973f1f6009bb99fe68dcb3458387ab867ba3f69779fad6377952f07eb71508f4fedc482546c9fd7d0a26fea2de5e4de2ba3ca20bf04e8d86d9897f29256a82bb6c3e739cb19acd9a4b44857c3e25b2ba9084ee7bb369f0570a5940c185111a279359165ce7620a526cf3c47c168f0964815ca4843b454491648745941a9dab8d75341c05d2d2d3490849b639a7db6768ae84b26c6608f9f2fcf85f5271c3408d57d3ab0c8c6e36e7d601c5f7625831ac22f2e14d648999e0119831dc423870b44ff110bbd7654b6ba447889619f2160f802e864d70252faeba61e6cf209c77a6a7d494f1acf6b60627906176af0b2a16d61a3abb13391b9c55c9a2f9ea634604d948dbca28c4cddb04b77085714e2c2de20dc44b8c9bcb5c57724b4a18f15658af0866ee665a69365b4d03dd617430b4d3c836b88bdfc4867a196ba9a82c827abb6ebb2693f175a13924294b5afd04e1ca8a8ffd77cc39ddf2065477f37707384d88077ade4d6e11cb462f7bd3550d2c0f53434fd0b2b77e6605e313f18ad8efc35f86b2848cb562f87bf282bf9748023b0b890d45e3c652f54d04f9ff0975a62cd18eafcac1e6c78359ab97e4b9a1b6fb2574dfc6bbbc04c93b63aa575d401feee87e2ecba3fa4076b646dc188200a4622c5704d66c8f75d4e06de12c6ff923811c29052c56868b1adb3d922dd9a2463ccb398b0b40393e0d8d6f2a596fcb937a5772a44cc6734017c7cab5cf77ca839afb8e9435bcc4742475bf827e0e8eca2f5accd30c6529095a3426ccc6d4a9ce60e4e0b954233ea71f8e10d8dd3a7124391120bc050e1392e14017d7ea78f125f67abd23f969f0de8c3bf70c20d92d781ad83970a4716ae5b345b8e0e63cdab5cd114981631af7c4a5e4b4ec2cbb3ad3236826be930c37edc98508b8dc2a6421ddd7da65ea05d154b1938eaa5ddafc5099832841fb3d119a7d1ef37c872ab4003eadfefb6c70fa4d142591a84b94ca8061fdfbb93d06c7619398b3d52b079025a8ce66ac1e1a5ce545a562e8d16daf6d6f58a33abb55160fb5ceec58d1c7ef78c96d1405b3e30f5a89a9d4d01efd57cfc4398203637646fd845c66c586f983522f42bcbafdce894d5aa30d9332ac0fc65fa933f5c1a4cbf36c52b5e3c784cffd290add7eff73b5f6bcf7df25bc8f55dbda470ef948a6437919a17f506b74bdd728438d0e4f9f0736b4fb1a0a09ddd845c1de81134f5a318ca891cd177229db4942d2f35b1272d6e6ef1090785dce2a110cee3e4d4697360bd509a79fc94a8858db9eacf276893b77e4a8287116a8f40dfa19fe675f7236083ecdad4f9c4334c5e51fa53a2164765783b52deddf981c7689a175cabbac7b19020c27d07d25e83233289e965cd984a8ddbbc14b08d2124497b8bc8f94e4adccd175647bd34b787f10155bab5db558d0b0052c396af72edc5936ef74d57b619de80388fbe163d95e360309d84219158c715fdcaeec081b30abf969dbc639a1fd2f8cd68889f37e683f503f73868dc2f774e4d2b32ca6dbe59fa72c462ef85eaa90630bfefce583f5cdc7789bbd63174d3743fffb1bd17d632e7cdf1dac6c298174f142acf96cb2b9ca1c5d01e46f5d5e64cef646b382febd993b7544436a8453cff17488549c3cc949f4da78d3e311b9e1c05ceaafc4aad24a5cfdcb24a9a1795deba0e699a948668d752961af241edfe0f5a78dbf9eb0a83c1552ae3fada345afcb9d672652eddfa46992535a603571072604cce530e01078c1b96b4572a64d15b5463c9d57edfcc5ed06046048c8e7bf82baa0179cba9a069cab677241c9c1f3c1e73d18e666c50f8dc11eb888e8c0f464fab763b95d957784da3d36f92b456da7348eafa029f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
