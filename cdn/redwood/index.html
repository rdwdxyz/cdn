<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5f557d7ac7675cdefe8976e2e2171a7f162f6fae43ea26635f08a1f5fbf57cb296a479f5606571fa8049c3df620010d0c9684e0a571186e7ac8b303f85e50b3fffb34c7fc67cab10151221e792a583a7274c3bd65c00357b266f030984a666df757a9b04b0eaec43ef344c3f0f9762dc41daa74d935ff41b0bc2e2255a39f1246bcbf4c91178bb10fbbf052e43a12ad93d8e813f1cfed693075e1e40df3b9aa45a0c25f8c64d6e4b898e4bc16c4671f027d5256ed3f9056c28c9bfd6b27d5a6ecc69a6948c0114685253646641edf5d456401519b2698a16a592b8301bd7542370442f660cabf586267c00bb32890691d59641afa5e648a7f36194f9bf068f7defd14b9e94eead2c95995490397e07507eef8b7f864fc64be8b899a03bd21ef94c563b1fa2ccae94b7317ac478f874346157e924c34f32ff24cb0c9b354cba4d1a5ab6bb1f0bc0589526b4b1f196dcfc2ff2f9edbec29f2609f7666cdbeb97db34d59b068e75ecb7c8e576a75da7640a7360769079106d6dcc63c752412e942f496e218844a454d75ce64dafec0e37494614bc908d50ff384f17c7f76f5ce47c49969d9c307994a4dfb6ebe872c95b019eb70f09e02a70a722d53380e70f0e6ac09ada285cd3148870c4859e90020766e89f260945ae1b185f682724628ce08b00a714f9aa23b4b6a74ec9bd3fb8eb047767bbcddccad5db9d5e2357f91f5603189062e1fb847cfe2d478cbe424f5282521285a3f78ea4c245cbda904c2dc9b8ca7fef40464f18d0964a9ff2c53a05b2b6a7a542ffd87ab36f35cdbe4f9375d6d146ceb796fafdb602d144bf3771da5f2a9a9177baef399738148abf4b79846fddab9af75d016e92a30419a76762c03ae95a082cff6900e7421ee14b02ec75f1ad3c5d50ffcdf58abb2bdbcaff2e2ea8556388dd2ba20ad0a9dca483a03000e4f14f3810d130fbd5353029d750fc3b803ca2810db0d449db0fdad548e54c2fae97ef2634865b78626b1d6bb554b7317c2acb0b6a61ab7753ae467e16f13417734c69b988f3e9e9858dbe8633befa94d374ce259c6b336251f5501ae062808c6f3c2cbc77eaa14b61be0abebf31bfc108727e34767052abd4b26010323d91e8f7e04c5d72809169a6a93293ce2e34adb05a448e15e8c0af0117bd36df407bcca04999c00952b456d9d1312f2f7f40fc345bfa5a1bb1f57402825826cccb0ad49743685f9d4536025176edef3e571f35933a6a83771314535c11fff1d2cd4517928f5ddefd5b8a93bab6b3ea6279d03535e6ad2e0887fa3e42c6ae73708c693e22719d7405e612294bfb1e27473745ee81b7bcc3761071a02d733cdf2b9ce7ce800e133e67f9b489812d54d7d1ea2c8ff46c6b53d7baec6a6f24a846ef26b624fbc5da1fb771baeb53435fd88cd5e59c85ba8193e5fd425162006d5317c2f7745a44fecac288151c66270ad3bf623723ec74a03d1008c8ee2fbd248f98434e576299e1c0e3b041a1cc7452c22dd06e2f76b8628c0499a3cc4c43f5fe444ad59b8fb8a005e65e0b3f4cfe44640a41ae9ec59a6b32eca97f9bbc2560a4142c926949724713738510e33a3c420a44dc413680ed8caa46605a478bf00a8f0f3483604bbe43bdad06b598f69007289322ddc605c53b9e732322ff36f98acb859d503ece4d480d3612703bdc639a52a3796204254684cbd6a9a047b26edb6c401527ecc73c8cc408ff78f8f69272f43502d1171f16cf7312624da6c13486814aad84c273c3bea3e0100750bb1171a10532ccd745f82cf4518d2d7b606b9de2b493caa941b402a3b3547b0b5e1b6ec333963345a2f5b40859fed54f3a15acfd0720871731fdc4548f47e76ea136ce74e6e35c949fd6228fa2cc0b9b99c4e8affc0f3e297a2743cb2ca905f0258d17828379b230e4b9601e08d6f0fd428a02bb2137bd41f00bde5336492903421908073293398f3df8c4a2604292918237fed65e626e5e7070b48980fcccaad7e97f8f46ae2438abc4119af7e67cda5722ac331d2669048676cd74ef269f60f51a1d42658902a007d6240b09f26d4bc80b33b46222bcf159193139ecfb04ba3f666452f33b2479390c7f3075a474d4ecd532351bab8a71d1330f6b7ab35a72b8ce471d8ba713103b38f96e21397f3638e00e478e7980cadcce7a031d29411976503e0924ca33eed8921a804d259454698b003d0e3ff33567d9e39b786558812e311032006024afa53ea87aafa9382ec39993ac33d9d3f26d1dbe882d1cb23b83eee2983a56a875f202c737c34d0f58e42b2f1c7d79596aa2c68bba792fd24f6370a4cd7b82725ac46d799be55b61311fe2d0610c0570c14af654f38d9bc4615218063cbd064ab06d4878fc0c27d00074ea741b3306841daa8c2f1da7d55897f02ca83a5e8cc8bf145ce44ed47dfbd517fd2ee4db5a52f8c61e940f4e9e9aad1c0c9648a8c629bbb9fd293959f316d12a82a7e5e50945dd117c3a1509ef4053f98b90ac5425e5d9d849ab2f560fae63cf2e8c7277230d510e75ef8ef6212cb0a5e99a08d08715f26ac661bfea1ed8df65291ebeef16475679fb0a4d6add79d2e04642ba47b1d299830fb84af93abf7c1e3195375910e2e0652b12fb3c70e02ea84ee895a609aa4e93cefae3ab73a500796e932d3a5a25089811b1ad4eb762c1cfa9484d655534dbe04018d9dc1108a20e30b28611867c43da32ea0ad4cbce6e2450714156d163a04c93120a047dc0575859729db5173ff90a831f57730020d55d64d379e56c43565f9def55859874e884092f869d701991dd4e5c44952569581c0e7da17384f6c05ecea71c2adbb3fd81f1f4c4607f68c5b67fd39581b6954e795238e2a16fe62ac8c325dac075182f9a868bc5194871c413c23170c91dc9cd61846291836dc9bcb05da31bfa45c9a38212031ea486aa25718dda3ca050b7dc720f50fc81910a5fafc18c0c138c51deb2c5bbe6a4958105049e4c0940dc39c45b290b692b836e71b2f2b94868603c5f36ad74ad71cf138cbd2483b280b8a548c4a669656ab04a3885f4fb6a89aae574bb59e602f9eed042adc5c57bbed95b1be4b278d7667e989c1156db7f73101a7200a80ec25c8d4f637820fd3c7aec449518cba9c012f297c63106ae6e90ad5d5429e224f84ad5c681118dd82d7c8215f1305d1db93935d498b0162d2e372fed20804ee0c83f7c2f4715b1049278d61f7cde6784a316824bda34f9d8a48d8b324d1fe104f385fcc22aedd36c4993b5b812c152451d98e22403196dc9dfa756f767cb5fb08adc2faf1435e26aa92a8d4fba49ca2f3fc0ee6bb222ac88c56d9629b35da70ea7c60d36a1536a1fd873a838ac378b241d1d1dc31f1670f62aa0d7f0bec7a71b441f194ee76a035bebf886377efe70f5e923b80f08222074b1ae791f9b9988b33fdaff2f89a5202c2d9138abd478dd295ab92f17de584da0a71c58b4c1cdfb911337f3a016209ca346f44c0bb52df0100b953a94554d3b02aa4bffe6a6c3f8645468dc068ece98ed85830aa923dc5c5cad0dff580eaa32f261ecb8368b4213ab4fb0284da7195db70fb5422289379ed77f5088b3ccbbc1e1f5e5f793221273f4be17fc8d145a437ccc40d49a8b1d99afcdb64eb71fd497029a0dabd811cca2c063cbd005f00cd2fd4149cc75546f3609f2dea269d3020445c2c29d5eecada987316bba9d42e08e9dd8bb625cbc1ecfc3f72925606ccc8fbae7531e01e3f2b40a29aefe99bf8becb806fc58965bb938910b9f8da5c6e14dd15850814f0aac9e91e16d242666b24e56311fda1b62a0ae346f68a774e000ef3b3d1b3a73d29244090427b78de6aec4745bc4b2929221901e85eb47a1459d892bd0bdbc03be94f1a0abac376c3ce00c73d942be8703f451258ae611deb9cc0a75f2a0cef07fef55c0a7ce3b78a115250bb70d4096067c2f6dd76765cfde3527f9e353e016e9252af3bdd8e2eaa141db223c78e0f66a8a6878327ef8e99fca5dcee4d34ad07ce463d826355f2644f54fdb430c3fb73b06d8be2b30ed4f8a3c578efceb32dd236218bf7876af9007be8ba5b97bacf842f2bcec7ccd3cc05aba46b22adac347fccb83bcc15a9f93aa784135dcf2810419a6154fde6cfe5a88c528f665e31787fe7b9e73dbb777b5396283a69eae325d1330c6ebda381f41ab747079b3677490667937599531936fdb67cfb829b1b113e4dae907e29e43027c93d7dc0efd725964a849e72139cd8e1d8c8e596b9e39940b72855455f960053de1686b8cb20561b82fa7b10fd8ac84e0e4276512b5ba643e51c9d1d6313a34f3169bee714e44af7f45aea881309fc451743c9c622b4d8282d9e35c35a57bf8c864464c2ab60edca4b6c0a9144f30e67b48cabd38df426a4888fdec8fb95936494001d722ecd8866b37fd0efbd628f826d8298334207c7c330d051a0892c97a72224ad56bea05b02ab40d211a2e601847dbd5fac0c6d65569209f1aac8b69b7cfe0e7c94d39ac17c23ca66b11f13355d25c5d2a3b943d7b6a674eda2d6b54e003c74f892d1ef2eed849489d34c2388716abb2e8f4a9699236e8f71f1c47dcc57fcf79305fa2b694457eeeddadccf3c255a1b676aed4b2cb165920396cc25c8304d35d56d4735529b725c33670a3f9d526d7f86978e8631173838e62906e8c9a87d48153f79bc86e63f6a0ba1ddd3f7937c675693badde2c9ac689f26414235d804abdd73943234772efb78662823afd98ee114910584b9de0c7468321ff3756436709c953d4ff0c77ea64830055767cd392737b5fb221e8bcd43ef31e9f6bbcb52ec889f00453a57c545c38300f0908cc2bc6d8964cd2104f7c4ac1d5e5169667fb59aaa79bd99f84b7d11de62fb9eaeece20e2d3431fd8170a2ec11bc0b38a3559055c9559accb9dce8840f1ca135c06ae264fdf4b9e8f5d751729a4aed3e4a006b7a2df12a96bee579460e2bb69ac3b2fd86fec65c7e1211417b3fa5aa5d8b7d5f220db502005fba4a08e3cb5b561afbddc0ae158bb23c6a7072d86c7b0b525c09c368f6adefdccd8eba4c5c535fe5e9eeef28a99d993a782947cdffba12554c458f2572c94fa46741a2580b6db34d3c694790fa999fd2574449ebbabce408b40c98f0a262638b9412fae770de349e5f7843518b4208e1bc2889dcb3540e37d49a9271d70c6222ca808171ea5f8ae1a286c7036ed68d8cf5a8b71d92129d6652ded4a16768290176e00461d199b6956d35a153b12f56535f6ac451344647eef6dc8fb5cf8f659aa82c2a7e359a9b95a8dc991ad5242da93574a49c3982ac20294d9350aab888f38660b39b76d0b81312e0941cce840e74b469fe84c63b101e302ed03dc77c9f116dab8eedfa3de33937f53fafa84d5ede4e86b977a80f5d5c0395913bf3b838c17e4067df3bd69e95596c5f78892ffafcabe969630610283bd87da62da66a5946db5725c1e7e94f3a62b77449403b9c98922e93ef2d1f66b60add1cc7f206d4eaa1fee20f513edf20007ce8050a54bc163c082813e16f87dba81f6039b4f8099d347f95b5152603e71c427115f8bcb87788a7f116c5cc93db5b82f4cf51d62f24e6688be1d804eb807b5042963f097ecac9af2d2de1998f8dd79bb1ec14f8438d213356660d071d09d0aee77377d5e88832bf91c1cacd17ae588f335516e07eeb669e23973dfa87dae4bb0e1cc145508de1bcb32d63826bbf532e0479c1db309d4eabd7bd8eba8b2dd2210e66dc4fca04abfb75eb5b87b821968b526d228effc3eed83b9b3fa219afe48c6704e9af3e0e7438ef9bb3793a76fcb6a180dc176ca5ab6c66e87ac29b977eef7bd21c16b208af854dec299c99ec81980a1d1e46e2e548fe9c6c556a5084859754a1f00cce7d9530882503a028b646faf4d206ede6b1d5295ae1fe1ee947e2a993432f6f1eb61c3d341a3c414b20e5767d6c74a88d8128c2615875cf22306a51f91efb6b47dc0a6d5e3f2f9921fbfc50999f6b0791919ff81651c00bef08074d3abb7131f27d336041571a31864b43d9d15c87f696785d08a32cacc609e8751332b57e083bd76ccb29b09334c64282f22c18af4492504da32b74a4d4b696ba7bdcdb144eb71a2891f61244be97e480d5d33579a97629ef62e7caa0d578204780b76ec2aa5ceaf08112378d7cc7cbfba5bef7262e2ec125c0d9039f6c9327a95a0a23ca1a22c854b61c89fc4730dd8d11ae7ed8f4ea81de7312e7e179f9723062cd98acaac223d7054f58eef0d8bc23f02675eafa862ff07140e9725dd0a68dfc050ba40128cbfd1d93ad1493e360c60db7544edb3947d83e39417a88ed8ab7f7ee5bae564d2bb6093e6705cc80d1392056bbd42cfb43ece78705e685796fab8ac3b8d909d882c29ff385b23e5701e26b8cb113b91096bc4dd98eb210468f0dbc8c4d23f3e749d2a8d5f6636b38112610dd70d5b0cd747bbb188e2e5e4e4d653f0484d1f23be3fa154e4744fb8d5949437e1af894f75211bf2d39429f98c37fb3971618eca3df6178663a76160eb18a2d3225a8945d980eddac44a1f29ed337aa2218a9743f53929b33537e8068a20e8a2f475c5478e93310ba3b412782c1080d9803310f6dc455d2272afe2bb1e24e238799e53c926f3c6e9e3abe1a7cde03f64f6b4b6124882af305b9e65c9b04cecd942a172b39f7a5f11b1ca97fa81b5226e9c3a727e6e1408e103c919423723073bd1dd3669431f763e9e5ee03756726d63441eeaf7e6aa189ecc177c6cf847621283ae570a94cc69aa1c44db8e73222aa32fa7185c4b814354a04a1ccea76e043a14f1baec15ace03a4bf31c26ffaf913b8bdd518dec860229c18cfc25a247cc0f737d1dccf242e54e7a3d242e8657a47b374bcd58274751410b649fb27758c98bbecfbac111c4ac7605172ecf4ffbab36a155b295c4940c08989b265bfb9d916a86c7b0bca21363a9793f84c1864ada8cabfaf2e8957ed61e5edbebe9f348539d3bf2e00672c9a15d32b58074e914f328337d29b27684d15552e531a6d2d230d420bfbc816370dfe1adde1549611ac0588ba0451d078b7492ef84b5f16dbf0c5d7bc37658090398e085863a45fc99459811f66f38eff8e71868b702f2e3a121664c7d3cac087cf33ec4bed3dfacb064de0e60944827e09fe0c6c1680125bb1d0ba5be40913adadfaf9d28fe2ce651bbe0029514b666a345172faf92cc4a85c45e0ede8a473c0d5cf36f6cc5a31d8ecd896c358a9d25dc177620ad48361940b249d80ae8f9b0fd7bee16110c09f51d236eda72e1a4d76c167f68eec0e25a081ebd86579eb94ba6c4669db59eaec5eb4ba371efd4099ac0166438005637d8ea9a0252cfbb71ecf1404457e6ca24d5bdb9eb768f3f4bd785be2169610bc1627f30fa0e70abd7ce045ab46f9f90440ad43feee5fdb8da32f7a57be63ff855ea7114a6c744b96475a533d5d65616f082d2972ee00af94c85c551a3278013570c536b42a0e702ed17f796cf9f4ca1c59d3302ed0c0e3ef6cab6b1771b244514aae051303076a21aa8dd83c8bc0942148914bda356b16e4b1c2a95bd3bddccb4088f56a70770f5f8fc012f6712af07ed9a0bbf7d886d405f952cd2d8d1a243c1e07e12fe36ba3b318902581e3416e883c4683d771fb6bf257174f7233452a4686ca67d084712e1a86beb92b07c5655546af7c3f31aaa301d9f8baf09fd065e53eae0e61b400d77ee3a2ac08b874ebda45b99b881facb84d710190746b25ae598637db6e78ff37ff0db934e42dcb5b68db81dbe1c02322e881e9218cc7811e634e91427e403c97ea890e37a12db888a0d043861389da2a1dd7f48c9158ece6353805a1665d735ea47d9de7045585e9699e948680752e84d4f8ef801e1f81ede284aff147ea4d6155793d4af08a87457a045b9d60e27b4b9637404a843fb4417126f943d801489b095eb49eb5de6679aef0ed046424796e3e4205a6028efa34460bb63ce89d45216fecdc15e754a1878228ecc201a5f6496a6dac2d3b521ab4b113baa24a9b89daaf02c065a0ec44183f58e3fe8254697f61c54c3746dec8a5036fcfc33b8cd47a715855dc736ab62437282df698aa9275ecb29c35429443c4bbc1a88838f48aef33460cc739d42b6ab3dc47af82a57542642fb2aef0f7adaa116ff5d58d1a935c438ace5b4e0e89131db1f30893d519939bf0bae7b4f2bcbb5e718e3bf378fa7058fd8087ee65e0d6b2fcd46aefe19d9ed73c0cbaf06cca69423e7a0c0d88e464b45b3a6f221963c0d2fb170d34465f79f8f5193bd6453218eda482ce6e5d56b849db4f953c8cfd7b286e9388b0f1369c81d44c3d6ff0c684c1b6b93a0224a88c780baee9fa4fbbbbb0404bb1749bce06e1e9ec96181be24816b1b9f3612b5cc407e447ccf238682dfc633e60c6b7bcff7982d431f557a3e7860e94de8129eeb5c49a2ca3786d76a8ba303fd04ef4da355b3f57e25f9c2ddb1634a42231450025eab3bcddc8e006094ac2255de3af7ba0a7d2b2ce855029be9e9b4b2927b9ba0f71064d24bd1235578f827c7bc9277769bfab20fc84ad1a06b48b5c26f80f632757b366caabf53f2b22526323f122ded07135331ec98c24d12d84c8a4ce0260b6e8ac01ade9406b4188e4d9e58fe02c6e5f229b6f95ebccf4d7e828bb0c091e1221251caa9d4f1dc45d3ef37d77606fac223db5c1ca47a59144c1807759089a9fdc4f38c98c49546f7257a182f37ce1bb0f6b5313398cda930494f0fd25574ad4d677688c9b2c101ff13b0eccfdad5745b1a2d460fb7f454320fb1ce3ee17c97dc70c0817eaab244eb8eca4fc36a649a3632b17bf215a3e50f34df5e0bc00815c3a2584fe20082c3ea14869b087837648fff7b6717b929c76a6505abbf08ce5a9936e5231262de9e0add71dbfc4414d5b5f781747eb7356346b5ab9d16cf1d12f4733472e1972adeabf4f32d383b3832c6e2b6fc34016ee23e73bf0a29c61b48fca8b23757fddfe950aabc2ffda72150b40cf8ee68013019f0e10ddebabc348795a5ebf77022549cb91256d14ed2c33381c10d3eafe18b0b0bb165a6e9992685361d423f207232b33365abd34d90f63e0c083354fc43a2e70c2f290f081f19f680eebf81b832ae69f1c6be3a090a269496a187edb113ba5918635c6151ba7ec9f1cb717098850ff8e5d1e7d9e75b252f09a04d2f5b6828af1e4474a0ab757589e9ec55e7ac7c3e99ff9485fadc8ce1afcb33b3f06c25c958543e8cd8bc925254803de7a4a4dc0fddd21252579d44ae2f62f16a94d4041ebc3f483c4f401348280a70284398343c7aa4d77eb1dbc296fbc9c13ab3a43ce01425d91c0566e664d398017cc383afdb7c0133d066131fc0a09ee350876442a6d4e6f7fe9c8a844ed55cced8583ea98bb208bc8517fdc6e2da9a02d86297ab90f9c2e4338cbb41b608a138664ba78f71073333d4c51a5f0109fee3d86f7dbbee9f87df54959210d8a7981541a2fdeeda3a49ac84035db3b53771837c85a8f54e3e3e05cd2d31f0944d2dbe951f63e97a9627c3a8764e3f4aff7b0592ba728d4844e44955cf8c12bcad964e2b314981b47f29f5d28afd0087e735a8534341f7ee141fb4908a02cc2b81d9634c0371c21f06fa459e54146885e9a2b1ce7711967d34240c4c3539ce0345baa146c9a65f89df4e9cba473c41789b284b88a44bce742793adb7e3cbe4f8ee6b140f2c684e3f5552b807646eafe92cb1b6815a94ba67779b0d7bcde46b70f11028a6f39736b4e28cbe55323465e6de6131700efe03cc3ddc73281126cb3ccc4e4aaa7b9d645e14680832fec407c3ca04ad3527f894d4297acb193cc8d8864f2ee3fa8d1847085552d16ec200be684de80885444efb9d6670c83a424860d54befb635de27d26a9e8fa23d323ad2194153e873533b80aa1072266bf394d111c602d626bf81d3596326105b7473e6d59a554a9f75ff3cbd613d813b65ce1bffe7ec92ddbe086c46c2dc184bb6b67cbc9a393e72ed11f5516279ea61f412a1e33d4d1a45c5e852ce96613306bb850fd0cd9077ca6b965675b67e822195c7723a6592e8e6d29eac0edabec6f2c4ad2f9b32534f3d62c144e20b8388cbf90b3610ce127699d44c097ab6639f2d343c9e3c46a296f956f371de295a725b28c60078a2486ad503d069538a4c1a793e41f7c5bd18ba4c0d75608bfa7c4755e3a1b5fd1c6b2e6042c1adb5f1cda32ae12519aeff932a9a8e3a5affebf04d2b54389fc61ab7dfb7544816ca9d438c6a29a254590298de4febf6c1ab86a1ac7fa6c0177fc014742e04d8b9422fbe7ccdda0ff8e9fe7d03d2a056ac3d884da9e0d548675279b43299ddce290829fd49e5edd6cdde019f38517959eb31b8b841bde184d78c4f9e8c0ca646fadfa83bd22a787d787cc5e98ba3dd5e0458099cb975d62cd4ac7e40dd16e65729af8e9c667617bed64678037feba02eb9268227f9fa026801d98d8518a0e407a43de89197b2a31c4f87b912ba05f533651879405f75faefb6197e1bff0db72793b55e8dc5cafa30b99ece0a2e2bb6c23be791a1ad9c590b2e57248bcd2dff514269b982a96ebfd9fa87f500a0bd7c000cf854e3362541dd74fb934d2cd2c77840b40407f91c78d9766fc5c67dd3a58b4748422a57a88b37b14224c544ee0c126b1225c04121927d2fb4c99720311821ca381d89c228ce2fa839655ea5094c2e9f61101b1d6997d9e7961e9c100dbf6153e2e8647bf95e0e2771df21ccd5899b15e12cd8a23e3e4289981ecb4f59a6dc8c75be9fcf14902368fadcb571660a38662ce6fef00935b609fbc6d48d15d70f9016b224f478bf17c832ca93304e863d73f22ff8c827ef7a3fae6555529392f76d4ad4ee900bb38ff44479bf5080778ba5e5092a09b7523d84b877e5a70ebbff831089d8f494b95c5def7e6d07100829e251908f9bcda0372fd98bfd3d03b8ba871af9dff2167ae56979abf7ca962ed865bf65e9ba36cf77237aa5607c22ee8e886f56aa1f6d22b64c1c97ded20075589b9860fe32f4f2c08ed4d42b52b36e08cccc622e8b0f620e136f09786dca93a7dc0d2a29dd57abe139575277ec7d7833587129a1faeeb60910acbc08085633953588bd58c01f60cf8e16adb3a3927d5bd8cb7089d1a9ec3d4377af77d4a7f27df0980dbdb536b04961195ab95c9ae97ddb083e4c5df437ae5066e8f0803a71cd5879298f14ef1f33ae673cc249834bb6abe263289ae1044be354f1492190647eb03aea52c56ae16a66f123d9027ae41f674279cb837ece09aaae893906a564d84ce2c9e881288205234819c0ee37759b2ea6865a50185f43f8e6fc5e4b0d6e7fe506624754b8e91c5636beb62f45f4dc584cedd0817d8241c6545714caf9722ebb417f5acab6bfcd60c2d5a0b63dcbc5c431b61362545f03cffda18f99417e905163b50fb514d41dfd0d8efd47e5f22833e7ab87592a28ed88095b072d18d3e6f19d8c72b96dabf92b4cea871ffce998bfe83bd615ca8671305f73f1af7a2c2b0a5d77ab7f4b9d6495f8587fda5131a321ee75db25f6adc7fed4baebd38f5900ca77d786a1c173b54d0ea096c8fb388af81b06af8a7aa5bf45a75e9a421631a896d74e7b4fbafaec952eea4cfc99b382160adff93e0da03d0b3367574105e21153bf70b2f78cbda77d50c93f82f3e006bdd172db7c09ff2013d4147178ddccadf6264d6d33d8927429833a1512694e67ea84f9f6f4ecb5ecfb55c491abb473f9f8764b7730add83374c3ddeb10d933d7660a16926ee7b8a97e412962a9716bb9f15701644e6aa71571b8ce73f9a537efd5018ec29c25f4a1b76df60351f5372d9de2e3a6367d9ae1f4bf1b0ee015e2116ca9f0e7ec374fdbef3ece3a183f74d976b27c2cf45dce49af1847a46a935cf84cc138df7ce5085862cf49831141cf2a5db3c5f2f8ed865470e12332af6ecf8f7bd31ca27834cdfd0fc4a1ab7924f4d341e021a133741e238331323633755b3c01ecc7f3d61a08b943d86c5f9af1b738f3142523463b59934b043e93e55f6b3790264dea58592672a1808d46565db1505e92038914097b1872af75e145afdaf874987d8eb7f7d9611017542d6f75fad2dac891afc5fc8372c89a16bcfb62706aa6057c479ab55ebfade3c50ce4698c8d6c98c40bad68a2606fbd6021ff90cfdb8ad3a6ceb3cd00ebae0edfa041a6ed24e8424487a569662a5ce041553bc553886b9d2dcf12738e2607e7eae9a1b3164331b227c7f310626e064ef0ecfd2d275420b1551fbafe101eda077e11a105bf884a6798044b9e51284b8ca0d85d359f8f8475f3421d15fe6e3fb0f4e7059767625e53cc5c58fc8cd2f745a782eb8db0e71c38ce0fe4a315c0533ad6b0b279b39c682a9653206d1f079a0b97a709a8c9c5ee025bd1b0c33195531d010861a98b5f7c330a8c0ea41147248539ef8f28d26da33b6ee0dfbf386b252d6cd976d0a90d18154a94bfd5dccbd4356244496659a4a94bf7385ee57923b016a9cafe79cdff2825043f0dd234a021dafa5129209d15007a4cbe73b3e2c7fcec0bd6b99ee8681e5d6a8a49b13c0bef0a3504bd0cc2641ac9743d9c8ffe83369a6b1efa22b5fc86b39b33cad642c94cf9b93c37da8c4ff49d7782cd5afba358b4977146062d061c4ce6c96182971bb9d1b8d5a757dd8466c7a5bf620c785a8d1f0af86a9d97d9138fe23fcd92f7d376daf4082317c8368408b63a7c6e42f4bc69ab7ee9922b5c4c8dfe8e0d5e063ee1d3b6125c6346a8c94de96d531c90f25a661c938f774015d56c7a1ea979bfe8b4ac5ee7deda283ada01666b93b421603398e9f7f0ce05be29808b2971bd9e43d68a0ce768bd805004efd1a1f01c1f78a17280c771e46dc5cf8f3b8601247e263a009d1d04295e6fdcfe173d2488c472a88f1e88bd6e4eb22fb13734fb120955105a25e20b21cc4a0996b20acdac87c82b39c41ecc03712e9978a9e7923d969ec640a587ae7624b63b2f3cdb17ac6857815f9ed90d5a80d65f7229424ff065cac1bbefb0e5219b3b26f2734b5219eab266e085c2663f5764921846fe53ceff205bc9bbe1b32201f0c5d90ef1900ab89ddd7187e0096bf38dec89674fb3ef5ba889e6a3aabf2ecdce0fc4db2d0da76d306b21b66340ccda0fac4a7aae28972369937ca2cc4c608771a03a99de8b93adba029411ccb57f6737651ce445d0a0082d013ff74dfd42a97c9275440e57dd7c76f786a73b7555d7946f151a9284a201e3da8231649bafa619e47d61968770ef7feee79b01437762bebe29fb9e9715b969c5871e6b90d71da752de9b02fd2b86c69721a7f903720f962f0e8fd48497732b8ffdb316b794724c476c0d47ce24491cb19a22e70d6bdc5fd508b26815de5ca4d41cd46733cb36584d89d1f393f0898ea3a080fafae348195b30c8bd2382d896c6aa8b65ab3c6ca5f69c37003bc42f43f819e1bcaa3892694684bd44ec3f8fffb9def8f990fc27ce927851e2ecbfae4311b286041a94abd87b2f57fd372b704772597afe6e52002480e351357d5eb2a694e132676e1cb0540c65ab10936e600ee2d708a1c0256fcb9295de118e1e89387a8fac54b9d330325208899e7fcdc1ab1791b3b419b9e85fcef1bdc1920acbcb113b84dc2c69aea192be6bf21795c33b9b65c66cb038574e278c728942b2bd8bd6df9619ffb4edcf487261cfe18891b4f871f833e2025532f61a4af0f1aa5a219d45f6e45d466813301b7e04b2d16d03f9d97dd4836e358844ca11b0084add133297b2a2bd145b1cfd2af32164796055c776cc076099adc480e7111aea06223a48ba36c4a092cb39d0215ad8f83fa2656f0634db05d3ebd9c709c401e37ab1d2a58a7927fa606b836a6223596f6017a7b5efcc8825a71b5e52332ec5ab75d14f915cba1781ebbf9b75490e9c1d4e95240b8eea6b3ca683482596b84e46261c7e86c5f0718bee2b5815557c2e28a7662c9283e93cd17ef22a72ca4cbdbc327ae6f7eaba1e0d797fed1b341dbce4b50ee8e65288063ba96f33733b94079220fb8f4fe8fb75c257b82d5fbf06608ac47a1cef0f2a51d763c99286a57e7538de3884180167b8f8b283b0c4fe1d1ebde4cfc219e4eb9bae728d71eee4299e80c06e286a72df14872c53472e5c966dd07ee9c2b6eddbd0e631a468432a25ae24e9de90ad60a61aaad6ff5b3dc6a79fd9f4ad3414e99d875a25c82f66ea5a207b94df908d9f18c63d9f72a012647813cd39dc55ac1ec20206e424ef481e8ada87e758eb9593c34f78125b56ccfc1a92b277285bc68218dcd77326cbc05ebdce61af0bb9a01cbd1175c7f4d7931eb898b2def83fbdb63ad16ecc796a4cbd62c14a78636db5cdda6d4cfccc05eb1bd55cc09bb74b8c86d478edd392187d7634ae1a35f939053a2764c4116040c849dc736f7096b457ee5afae2ec9bf8527cf6a62c5381285bef68c5338ea3d2ee11d0b482ce51172238049b32f6ee4aec55e019bed41264e2615f5a519e929466af08583c700db9f1a5bf9150f802393eaf48340b2a10d1a3354c8b73d5ce33f8f79c54d5daa88815400e4f48d9718ffc7a689f962def4726eec27176258d70a6bcc1e532763f6e9b5a5d22fed14163dd7996b8bb2d7b409ac442a46977cf80c30023169ddee5bb32c9ad4caf07af98ddf040078aed0ca9622b0f63d4bc6f285cc25982620f3ec5aa0eb091aeecee820b94ceef6e6f93209a3ac402d6d275705d7a588e5d9636be7fc3f4c13e25bfbd9f9573b56ab4d5218b92b7d3379b1762aaa2fe60171dbe57e26013135c1916bca49086b977307528addc365c1c63ccceaee79adb563eca289120a6ff828c493896c4b23777e97f77aa6068b247a9b0101efb52e431d47fa2cbfb8361395d0a8fec6886c6c45c16694c43cb9d4b7cdf7f67c0ec6c6607e26fcfb84e4077f9c7fb8d43ec2fdd6ced7c3210a9043a243206e0fa15dc9ef28469dd570d5263883cef7109bf64417c1eb6cc349b39d8a5abff8e4a3b5d67a230773ac0cf79593ecae86713107728898a1be4afdb9a5d3548343c651b631564dd86814ed46506b17f58765a500cc0597f9e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
