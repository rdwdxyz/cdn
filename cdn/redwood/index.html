<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"564761527e5e46115130e528ba8d595c9b23bd2f931e57d7352b8d25ca0b7eaa26ce3a2c02660089c5a80947b98ef60f0077c697c1eb7ee0d698f4e9c9f80fda8c228f7e7d31d5524bdd6b8d91cc7555c809814da0cc006d7102d3b997fd5568c7a50a23c23051b862bb872a44394c10093ed78f100e5b3e99112ca68531c1b5cf945184f4e0aa189ebf86cc67e6549e34b0d54265dc6c175bf6e30f172cbc74e7168dd308dcadb5bbf00f696908d4d65444d44259aa50354b0022f23ed8f1d4f1004bd446c85cf30856006f8059f81fe8f401a54ae560cf7dd7341dcdf9963255953200d06474b36a72b5774d860109ea025d3ccb22febb3fb728103e2402cb1896dc4cb4aeae17b4425e58097f3ba9c1b203b77f8d93d720c3a7f52327eafe338e7bb6ed8be433b897190c5d5a5b63ea0fc4409c023359ad1bbb3bc79ed6954c328506faca4d8a04409a1fe65950ec35ea826766d58ea38e5735842bc48c7e2fa714a66dea131174e81666043e3935e92b945acfb9787b8d2176c338bdb5ee901c57f097b6221d6cf9d77021c46fb1de44008dab0666cf4cc8591bd915d5534bc679e5d60feb6f2eb01e8b9282b1c5f6ca1163701810434e2765bc7fec7eacae72ac49708e1a809dcaaacaca1680f96420cc94c831c3ae6d9d3591e11574a2938a15e0bfaea85dcd4dfb55075ab2502c2e53b155f4a7a45ee07b9f031e39434ad4207e89215a29e71432f80d828940cbbaa6cf8cac21cf2540f0a5500f79e846af73e941d2cd7d31da7e7f61128b68a78352049209098538b1dc4ee60d0f3acc8ae19ec93ab1b9dbfd07f19e98eef09ea386260ae87385b2a100925c12f959ae8c704a1f155215816fda2d69fe5d85f22b1d116a1d818c9c4557529e2d8b2ec6180df83b625f0e67f89319acf0eeb9d99446ed58627bcf0073c19881ea90cfe9adc0aa34cbe47155f02af10c89d35bf1d08c7edfe62118762a2704e6657385a22a2472a2de372286558fb762baa5672f74cdbb69dae63954cae9695553d3910cf9a18640c42f01d17fb5004888ea61e1130f0e5f73e6dc36521fe975ea7e96128253c9c7da4cd0f5d4627023c4df80c9c83997bd5d16bd724d2231045405f5774f3e714644d7851c5ad993794fea073007470c6e622ab51f42c073c1b240de5be197fd51748a34533764aabc98f4a20375b93fce964369cddc98f5ea5919dad63ba72776b99e8299ac19257e1ee6740017d8586b51fcb433c846f6e776958c5ae959fe3a319496290c497a120ea4b9582416bf05931e0fd4c07b34b688961b4a2dd58f9806e00da41503e40d9a12d07866f89a094fe5039ef56be339c5968b19c28ec065222a1eb3212769e7d6322918203e9321a181ca319f98fda848ea4cdf0e231d879c575cfa852327396a5474f5a2c47508f5a542132d31041ef76f29d524db7dfc9b24ecc7c650cb2820fe3b046ba60c8476ce861f75ea4812c5b509225b571950cc6d476c2b9f7ad50ab0df98eff85f3705b7eef7b4beef68ef22446ef81c1b955eaba0377f626f5ed8364268ebeb718c84730cb04f859c58cde32c5fe200107498995cc4567b7482b192f25e076703d8b9dfa651273e3ab2d37e81c4363ab83ba351b87ee410a539416aee45d281c388c7d5b03f53f9e7754c1cb78a447ee3a6aced51dfa1d1e1d8c3168a4f703d4ed0cf5669e6f63c6d09ca2587057116b2ae11d98aaf46bbcf43a1cfa05c8eb1d1253ba19ce8aa762e578f03b4052cff49ab0a6330491abc7ebdeabc08010a5051a0964c432fbfceb2f2b9651f36003c92e3a85c4d9bf43bd64c366ec961051d93c71b9da533b35dff5a3eff14340e3664f1d8c43706f4404b76e8adb86a19e5aac58bfa998ef6ddb37026477d9ca37ab0a0ec7b4d3f9f2fe62c7d3567fb621337a3c8022840213ec3f563d9cda02a8eb1ebe337048204d06c03aa291b6143911b54a5073cbc94eadf16e1db7c7727ecab4cf7b83dfcfe670d18e08ec48c76d9d6269424d06999b5bf88e0f50cde249eb97443fe40cf84c1d408daed117fcc0a29e7cfb4ccaa136cf0823d799914df46a8d435ebe2f0ff7f0544fe12d9a2719e4de5e3b3dc0e3772cf411ecbbaf7cc77a158e48227eeca0bb00df8857dc8e0f985de4536c6e09a770ab0800808da7dfc948d57ecfc0f636075e2a65c81779a77e1284e8f6ac01e69af42cc797d24d97cd937f6a8daffecff0183ae88ec8caafdca48bb1366d118599a5e693ef44ed97a4d7cd6be108517d3739fd3e8673b2dfb853b26bdd1c380638f49ed3ece145ee8c548099d0b92a1440f3e2b0fc179cd941009dc0b86dabd8f4ad3abbb5cad2a3396312d79d2912692efb0e6431ca9e1c31d70df336d9b0544d35c605dc6c66622bf6ff14e96e6c3ab49425cac2e806090feb67b7fc9ab8d289fa68420c549f94a52352b92d7513de92e6af3b07089f804feb7a4f3ae0bdea8dfa3aba3ad5c8ac3faa5a128c85856562d638eda49289eecd2eec06494805f15e8f52c767596c9bf1b860c6675153320305e316b85b5a96f88e178c07f8f2486f85c22c3df9f19b6357c1c425c688aa572a76573ae657cc91f3a6275a4a753b98d5b63bbb929f10e3b7bc463108edb604cd72c78ab227efaca364fe58d7bb668195ba5c163db6123673b48017ec9d31a1ac0fcd0e860520eccd451355e1cf86b02a9de6c9bd3ca3d64535823e2a64b844fe1dfe752f593ffe0935e50a7a41015f8dcfa2cf291e19c69d53dfe421663be3fae2d31ce2add503f9285e1fab1f627be3566e949c2e2d6929a9f8ed3259628aa7bd6fcb2058e99f5d3945a1dad316924f101d82df9dd78c4a6b7bc8ed2dce81fd12982a5f335826bb5b6156e83dc7f3510a818694a700ad1f2f6afb261ef11eea1c332359d30428a811a52f1a5df700096a3c3b15f84b67ab71c5ca76d0db9f6fa076fc105e2426d51b0459a1cd56e1d5aab4f518332d3c7a8f1b5e78635165033ea591414e94be6e404801e32713aa3d5ef5568d5a2e7fcb0378a27e88c79daef7f3c9f92ce5eabd3391770e7a55293420364e97bbf61cc81c3a4b91e4e68fe5f5fee058c373f14a1392251e8eb0cee255875222e4391455f1df932bbb3a14d36a3c61cf7ae9d77b075e0633ffe6153719ab647cd1f853f128935681d97a7df913870142bdcd4b9100303b064fe0afffced69795a51461d5984d82c2b62cf43164393d7986dc7eaacebf101cd03333ae45e53ccae702188c1f03a751c7d849efe5849d1a3518cd5537ffe33da668b2dc1cc4bcee30371c4e04be7775011ceeb51e0c75b7414ac26634045f21933ecd78a510994aa25d9f137a00fdedf0671c1df956ca91d816bc1a9d09771b370f3543191d75e1efc32aecc5789655df3acffc8694382b7be1e50ef3252dd416987017e1ace04cd8c89de04baa9b96655f0f2a9a856a4cc10d19ba0580e79b0a19bc6e77673150e1ae5ba07a61c7e9f5caf4ab0c334730b90d6ac4353e1fb7f06b22269dd5febefd6d32674903c2e83b3071faa87f83b2c18b46f2078ac9e5c3a467bb204e50d472eaccec329705b8bd21d82762c4a14a18c23fe339260e0ed323cdf03486c30520f3db8fac6f85ced63329e260ee8c31cbbdf48a7ba0a5bb040c07003ff53328194a1f1f88af0eea0b0e374304db8c8e9516eef008b8baa9774ec69fa7952e3b392cdce38d5e6f2e03439093338ec8c9a60e2bb14d5ac5fba1b5d0da0ab7e46faa1a2cab3e59d740ea3391c19e0d60112f313394e484fec6fe8d440b761e8192818565649b54fedc9099f20bde35ab88c107c9769e83b00ca1cbf687c73ce1ad58ef2631edcc683e2e210c52f46d54aa1116fc84b9161464f280a813c66ac108fe00b6cf2a90c1a259af79b4446e3306a224c8c86bdba1f70a9b71f1de943be377ef41dbf88632a05a0f8d9bf496fe87001e359511dab58ff44ddbfdc49f29691cb83f10646cc6d9d3b73ec48472298ba1d578df3069c34c73816284233fd0df2612f473ac1320679524102abeb88db41508cc7fb644627db0ec07488810eddf3b309510195ef8da138f8ee637f79f29fe12a4a0ed56a93c71f6daa31a44e03532fcb4f20d0d0c91e6271000446bb0112c061c30e4d326658cf1fa454bca8ed472ac4f309e7d04078bc242346003788ed691d2e4f890950ababe671994e3b7988b4c754960be5fa19cbb4348376cf9962c3acbefc3eeb555d27cb086e54e57d559e1c9063096cb51f064714d881815f0fb675d96687fc823214af88498a78b39e9db7887b9f1998721aa6d2f0061337d4d9d628bc3409e7f93485246332b6c1df62dcbc9d2b56589a1602e1095ba2e8216708dd3ae93a596da885239b21446551c9d4c8124bcbe28a947d07202343a2dfecb831fd3b5b0aa313a08798579be6395f81a6abf0248299208bf29aa5840911107e31dee46c0cb5bec62d209bf7bfbf981801d436233e98a45bb20b69f40263c9cc12965d179eb8fb29a581bc0afffc647676de4bc3eca5bdaea8077fe4b1f819d8d6037b76fa329a3e19a760009655cf5a5304d8f82c094f38fe2f258bb5ecabf04b7f97a86c29b8a2f823cb2a44569cd60cc23786c3c204df740bdd50ec6bc518aa612bac1d3294d52f50ebe39238bca544fbc6f59aea439e83310100f81927d705d18d47ac66d78efcff0ef5999400735ade134bd7a499409ab3b98ed2deb63230f4c5383a64176df7f8fcb0b87562d0101e050eeb2dda212ab162f2b14f43e062a6529fb743f846ed8811de328f25ae803e2297cc0c75d9bceecdab3beb0ab6f3424d9f68bc25c655517a77a427188db472b364f3971c917d9c8977bcc6aff9bb90fb4b90195befc27d39659a1bb13e2d1497e3822a63edefbcbd94c8cfa72bdae28702c409dd3dd0b6ae17b6099ecfd29000063739396fb8b6910324c20f7d2f96f1a75b0419583bda70eca70e961d181b1b40e70e067a853ec908c047a4aaed4d7346f9f5c87e81ec2552da9b3cde8d45eb9b4e594b818e6d17ec430fd78816c2426ed5e86312ed83231cd5dd2d3d5041d4bb74dcbe04b003f8298fa432e45a4650bb8b11ff65feec58b0c6ce5f6569c3933c586d1630e0f739642d32aad05475d28bed394bad01b2f98cf85d9fbd9c094c9185a618b1c7dd1a09427595755d03dd48791940d73a4381a470a51854c1c2cab7bf83f36a21e2c8526692eba93d021c43bbfe26b02c6c527004ade9434eabc19e9c5015a173f1302372b5cb1f2ed0459a1ea1d562336edccde8dc2533af25392bcb6f73e87f9881c5de7cb9a86c5eb3ea8d6f3612ddb4a762d51ba82703ea83e5e1f9f3c6a27029bedfcd4aa5f184b863fc21bb36391db1fad0401abc9f1d8d76a834f5d0b03515f301764fdc0d4a812201a6b74bc712f7fcea695fa9a18fec1a4acf1315fd5506334bccad4d24340af1edee948c1969d125c3b8e365e621ffe1ac5f0d2eb6b8cf13b4698d14610dd62996b401dbab92e7c0ad517474c70e4af5a64f03e0526fbc0452b6274c3dc600ae0f0c68a7bfd2ec52840305f77170d19121a8b3b3b35f2a97fd05468a63e211a6104dfcc136de5b8169fc15aec1438b8ab8a5fe9e821c26cf8dd9b475e084e57bb484e899c8fa31d0d54cc913b1f94ff12e882300b64cb656bf6ade61fb951ac53f375e89b53c174f154ca57c43645f09a3b2eaeb36060fc3a2837492c5eae3f4d981fb2d7bc71cb7c877e98a4e1bb22289e51596a24d96ef8221a14017409b8b353943b2579fd13881dcf6ab9d8e6b7b80d7e0f50f097fa4461121a56a8716a3726e1aad05d80e537ab83cc0b5e6c01798629a58e8c0525d682b0d96356e9f2021e21c0c01ae53256e2c559cbbe73605b8673a7273b2f43aa7279cd6bf8edeb5f9decc4901df78ad86266e419e7a3536055c21b16b72ed829696bd3fd46b7b37cab4d5a16e6999e927f9f90d5b7d6f9b01282226c9f837c74cca06e3c3367337758b527a142a60429c1f9aff215223beb582418805d4087742de447328cb5615ad2e1f15765fa1a4ec9dacb9ae969fa9a2a7707f05a5f13e391b32ad3e7d65520dc7d113453e1b548b9509718579bc0ac79f310d4ae0a6840e4e321d92c43d6c1581e03503ddb88ce0ac2bb4099a4b5f620c1661d4c07f3f7eb06bf470d8338eb6a177fc2d6cc77a6750d623b0416fa3bcd365fdb7bef445dcb20ce38113714ce8d38ec846b4e2758c160824e4cde146a46072a31df0b7983460d57650f5b834736b2385e9f25bc569b0bc458418b5c74e533141cb3d042c1d5d68ea4a53d3137ddd3052e8d0253237a3bb165316894be81de52de6848849f424dd9ef96af97c7aec28f75ff73ccb8786d35abefe8b52a9df3c00754e57358f8ccc6635275870e64e0fe2948671dd94895a57360fea705c40251fdc50b53c1a7a535468f40ca8c4ee0e9b4a2c61f80bf039bd166ea30719a99cc9fb4b031ccab76c0e80cfb5cd7dd97e900db9e66ce288befb8e6d91a90dd110a4b62f123b1b483cd81eedce49f9ea4353f4869b6c14da4354c0f80a7d9c25a0fceafa85380b9341bdbf31545e88f685eef6bcdc03e485d8dd4ca6c682362541dede10b564c0803a6831fdced9a4ece0728d0f692eac630400d2824d490ccb4253b478608766d3de11b9f5a55589d53531f0a5ffb600c5ff18f84f2b4f7d98cb549ce787de04b4a262952c7e78b2bb73cff5a5ae89975d1f948b6184985d8de1eb9238023abdded12f53f04c6ceedd57f62efbb2c77ee1e3eaf0945a86a87bf28d88fa22bec29c322d9c7eb7cb511ec2dcc8c2592aba3149e61740bcfaaa20c07f463426c33d951132f14eb30b36dddf0bb34fa31e09463a2b1e5680ad4c6fb2bc13621b053d9719ca1a55d88d5af40756ebc8cd90d5e2d156c835492b7697e96d47bf58b3c8431bf1be687b2cf49d1e3dedf8b6740534d2ee85dc3a357136de591921f4ad2310689c924f3706595352ccdb9e75f78baa6a77a21c907522461badae0589fa6dedff0ba218169937626b2c8f69115fd820ceb68d3ecca39b899ec346c42c06db4f8c8e67413c6c99c4335ab0b397da96230892ce67e4172f6f65192220b809a97f5e0095d7db7e1c5c2f6833e8f131338854f17067c9b399eea16ae4a2a3366fd8957b1679bf4217c0161383e4342eb77830e54d5261036e47228e519b78c8f0883a38b3014cb38f480809c5db37ba81b81ec17d545ea07e7718b753f9f1aa6d6ae57d757e10b8261486063e8ef9582a309c2c17a5bbce0d83b08f9a296f7e4ab69ff582214ad4b5fd931b6a90c426089c695c918c6cd5cf8d465fc6e6956ccda6d8b62a46e41fd1b1c93cedc12cb980e30594ed5d36c641625f05ad8e0d8c5651820940b5105bee03f652f20dc969c078366fcf5d4a0096c0ef41272e9cbed2d95137761535cfdf2285832378ce82073a3f2f8eac682ffbcc7a10dedbdb7e3045e2af6a0fbbf180a208a0adfe2046e41b05b9b97beba9c786ecf1f36672172146cb9a09da1b1bfc4978a4a56ed3d98546f956eb97eb6de5c3396b1cf77dfa957df53d1931a24cb3a206c1d5c4e035c991ce559ff0d6a7b7dfb89817b93ac207b48d1c385a6dcd27165803a44e1196b032995c97405eb2a6df9602cbf36df5679e05c85e2b31ed3d83e5d14b7324a689ce5a9c9991aa115d084adecbf884d50d6b350a826d949144c483547b54ba393e171217dd769824620051ac7dcf2815ffe47c481c53a57c5acf94488348d552b4d8e82622fad073a5603ab23eaf8bfafcd162f07f9b08ac87e6cb38b71c960fb52de00be4aabdfacb64fe91e823b0ecbcdc30dea11395807e74f414a5fed491a3d4781323b423c0db71a912dfa06153dc3781ae8ea9ef297df0ee231529412de712b96d8b7152c5379db466d304d551428cf3a7923e8563a23291af04e492f58d9809cd36b4e363fdacd0eac11110ae70c09e23f509caa7e8e8f2d66d2d4c6a44c493c39692d657b8110428533b019b309a891e49adfd8128e0427ca109c1d5586a1f5921826167d3199948efa181924d16d337856a491c8c06dd80976930c0a522f80b0fccbd8be462c12e358eb8cbd48791ee5360943a83b41a75d654b80f2c61864ffd646f1270f08550baaab00f7728f20c590b3f4457386ead387b21360cbf1a72473f4f9ac260b955567a60c15ee72ec00a6f373e21cdca0489b1c3a06f073f4a6442ef5d661f9a1b8d18bbf0a84f6864bb2e426b0f464e5007e221d9e62eb172216e16f0f469b59de35f64732c793a3a664f72d5d0728827a19050af52529aba6ff9fc55362cbb4c9df7cd559697e07c1d7ebad866765489f801d22dca06272b5e46c52f6053a1e5b1aab44af3efe83851abb8444f34e85066fe7e6fa7bbf7cc64733e0927405a3a426fd29070df0151d6c80d7d29144b513fca4d21143870e227253fb6f020d14942622141002897bff18d3bddeb283129cc0f88616d61ec64085a3d02d97ed2aa09748548b874ecf8584d4d3f45fba43642dd964069878cf734b1aa179e92c0bc800c7866cecf8f7ed25e2a26f15a0fad767866344d63fae834290d40ce8316b844e273c8c82c589b031ec74ee3f904904f5fed4ba716abb0eb8d96f3555d860832a35144ac0b3a4c161efe227deb951d7715376bb7a48c071c91e3e3711a871fc756350c247177fa74169b4010f75acf1232cb01890a5cfc1df02a7fe229d7fe6e9f36028c251b1f9c28a123996a66e8e87bcc3e8607ef188e99704bc02f94f1a8f993d56cc1a7572034f8359a1e5dc8a65648cea9dd71c0fc0402f1c9e976fa556e9c6ffd9951739751deddc3ed8fe73b7c043eecbdf3c722f6fbbad3fa393d85e0ce5333c73508ef282415186e56258db39d418b0f4a243964319607909ad3a457bd44767037a98962e9fe35edec4d707b9ef9cf082f9f03493199e54abc42d0e63dba45ac46703f501ca33aec18c47a24c5b3f327d35200db086a63e53ab1fc53213235f3c85c1dbbb894405a5862b20f7a5fd0e029499941316f1ec4b6a682a5feae1cef7f151c1f6d4ba9df4aabf6e2817154069332a786bddcd92c8ad9b27d551f4c31ff1709151eb870a118b6c5d897f7db06d8a49deb0c20d60569f979199830eaeefe9fded4ae52a2c870497835901629bde89000380a5a3a2db113d5b321054dd8c2c15b088f509b91a86526105a32ca4529c2b0eac6c6fbaa30c0441169c8da1cfee9b570667c2b902d39d4497f6128dd7e3660ba7fc71cfec8169fbd1f30d71b066dc581d929e8599317329077e721bb0012f48a0d98bb1b75dc670601bb384cf52a20fbf5fc1c2bf77dc47fd50017b38bdc917558d968185a8828ddc4090814843f436a07fa9c70ddfc0899a492ee13f1e944eba9686844c7046831656ba7e3f42704f7475aa83543d71e4023da12a237ea2d146871f4e59a0241c7cfff20e0b432d353562093429e463d79d61b4cb99bce1f5efde2e65bc6bf80eaadae3bde3d0324f5f2d037b358491e4ce9b48829abd9738d6f0b5a3a6994cf4a842b65e1c706cbde8bd2b037008780a0ada349bb55924bd16636e072a196759574d637f5297d9c6cf64be065c8e862114cdd33817c79794156e871d99014fb9d6aeebb97d177dcf72bc7771132eeb030506da60f84ac30532901a695c485ad34bb4923e09da86c3b00feaefddf47629a4d21daf8864716a0131c3b1fafe572f3cb8c3c90af677dca915051977fde5467102627bfc148052f78190ae81f70671dfed32d6182e2e3dbce28e47a64946a4a4f9a79e7a02c58730c531dac3c80924468099a0d96238727cf228136dea3bec150f820538ab4eb7ba3f254c1352a5426395b8a636a7a7a3f0202d4a677605e41508f6a9aa20b5c39266dcd34d70bb1e19e61ae12c12767e6c9a8c23fec1f5a63ac46965f5102a08182d6d4df469b9febd422168972d26d9c1ce81824470db5007cc202d350ee90aea7f22fee77c241a7529a17761923103d48e5cc23b7c136ab1f169bb38f6b12906c2c53fbac937517716d075ca4ca6e97a83aab0c9d1cd65c26a97571f2ad4719d404fd4e4dfcba1c8d68556cb441e919de4c1ed59c7fe0ae64ea24ea8812c3ed836c7af120c7ef737f3ea26621e35b7bc7de6f19f2bd10ce408238b316bb3d24fefebbb08e9d1d0cf7ef22053cc04f8e1dfa733b3b77370da8d732e3859e1743c3b0cad5e77a11e592a0c01bee263e4f676973e4230b53d74cb13f79501ebccdfd2994977059a7bda14ffa009e1a192e6e5df0bde0b9ea40f71be52dc3367cd190eef7b626fec21a0460ee55fc81ea214151ded4b8a3fe92da203877e4b916a32cb76c3584b3e01731b6654f3c0431d02ab2caea6704ee5fb199773fa6f0bde3670c8576be7b6201fb3e18fe6ddcf0e9c4593a35fd2a45a14f14acef4902007fe7daac558a8365d262ec31b972d3f6d35b1aeb27f7e74e9351006e973599af80926db4d7769ac363621f936dded6eacdb0c1fcde84f24e8da0e53b928ac23ad10bf9e2c1f5deec2a6dfd9242a3790457da93572c66af81c155b2690595bdd710ade1087f1c3ced0bba6c2e88cbb1fa9cd218fa4676afdc6c767c2919179c3a8e3e37041f5c3913d5f48bc916721f1c03b9d931aae7a10fa5f4d87b76a6100ec481cd90973780cf131044c4a50ede15226189133b866af19b24633e88c9ec00b8557a17691d8ce67d2fe907db2df84d08e4f0cc13df7de70e7ae1ada6a37d04d52cbe20359f0a46cec9b363a03794fffda1c9445f356525bcad2616138bdd4fa83950db4240d3c6fa618f84f3875e881c10ad51ef63d613d722fbced2c798ed84daf994e03b1256c322797a64285628fb11f0a26ee39d6710941ddb6990cb138fd63c1a0d705b9aeda3e477567bea28ffa50ffeebff27c4a612e089d222ae71ed2d910ab5c46adce3c061400319ed39fa45e4042c4f0c397c8ba9c290724a1bdb724195c04f3c5cdc81f1b1062ab679b227768a981e315837354d32501d2e69d092822a9f6b99e1d5aec4d5ccb9b1d490c4aa07fa50647b7c6334b378954220e20acb2940277f38ef4b84d8eddc0cc7da2136de95b76aff3b996c2653b6ab5a6df085cbf32fb0f848819fcd9c3972fe687cfe3bfb7004d56dbc29b08def4c2a83f0f1f1201ad6624410c0307bbdf47d624e36198f4d772c3a37c1647af38bc47a9d4dbbfe9c33fcee0f37f6697d9dcc000928577220ccd4c4958f21da8590c1c8fd9ee4cc57a59cbe8b02a14412a1574bc27e30e37ac8027085dbe710bb43706748e57e77c43629ada81ea05e07d2ad522d12aea7b3131f1f46aa04139774d90d061c1e1138ecc48174356876b8df225e65dac8151b75f704c785b509cc42c04106d752491e6d4b5b5769be1882585478ca5dc59c4ef424f9a5b5a947c290785932c2d04914497cf470dae29442c1c887d46fdd755bdfff20d01b13f0230ed0e616473cf2daf03b23207c7e6351a0c49dc209f0a5d0535ae9553f3c7392a57f4fca6d51a0cfc254e1f31d97fbb0637373233d10e947b1f4afaed284453b8da959d7899d81f4416b03addb7400f7f06c1ee04fa3bd35fe30d3aa1c3442ce459a23b581c47d05435d0ba9a6b41b758e4d5d7ef74813ac3d4e98a89a1fd78e9fffa538b7017ff2798565b725152dd6e2017709f7ac80a0130e5ca2a0701ca5a8884c9ccf4cc78254e7ee0250f9400e68b433b6ce3446ec7ba0c66014a6d1b2e41e0e7dc435a7af6e0be655881c78f4f10fac01083577e659da98a704613c35b80044a52d92c24296deb2a8690a2562b416a6effadcb091db4b8702b19036f41ea71f5b1e75d96ccfb5601aa29d20ea001011114928d830a87cf7a1d5bed672ecffc540ab30f1c814c1f96eabbd538ff2ee8248ccaeeaee38e935f19b8eee31a94a438d9380779aa16aa54cd7fe715e50c34133d5c675e82e43fbb9264141c3a092f06eaf36e4f84691a5106a7ac5640f85f40d19833b688b2556b289dcb558eec5338552ae9b31b1e867789410d9ec6bb7acd8dc1c1ad9936a214ce172e808f7726afc44b06cd7da846b9a93ef950c863cc2ddff5e3511159e84d4f26c9e5d2d8c4e39de1c0376e6f56782508ec1d3107ce9b949d3884c2b2d82a5e3581143cae8781b48bcfe2dccfb5903b6a7f13353bcaf8d08917f2bc17b5b402fa7e50e8377d037bcec6d1a6afe59b0a98692feb79342a8dd7ad3e05343f1430a34939576d49caf0852beb82d791ef0bba707fc9ae78abfb023b0afcef5bf3f9888697a80252d80fe689a51b2a5e55fe15e20bae033a89dc49bfbabf12a7ce60a59e3f0b2419786f58cba08cdbbef9394af89754f4efb5d2c3d8693f9007c95306fcf16cfc4c0e39776413b9a587dbd1632da4bb5486dc4ef86b171c2e85c850c6d39e5dcc43d59083e421e7e1aef6848eff646667a92be6ee5496f131fd4ded8442ff73f5222cea02ee5aaa8021cd129dc80026ff3f4e2539804cb687d8ff595aeca5e98177b42e9fdc654bbcf551dd6e452be9d95a91081f9a9d0560569a5c1ca210a13b6e9df5423d9abbefda87869a2cef17037fad7bd0b19ffe957990076a77cb3f83f6ebcf3157ea547f79296377334dcadfe4f74cc797c47ee79c15dcbf26e4eba05b5e5c185e9e823f722fe2c5b4d727185b5ab74d63bc43e477c1c081f7034305959bf9131a928ada4bfdc6fcaca9af44f939544d0c40bbc845415bce28280d831bfe9eccf5235831b5e5a7b1b8ffddbc913fc0d5ecc7c9b87b66a7ba93f9980c20d3e2954391b287c6d65246bea969334194cb846dcee432c566a06ed486305904fb2c79bc5a323e861ab06aedfdc9712ccc794686aa0070e72c46f999f9394f75a4031415eba121851f72b2c8be22cd8f518360a4806b65961fdb1f66dbd04e9052d9ed91456cf7b2759c60098d8d8296c08bbbbef326b962c4f16002bca9328e07577e927f10ab4e17187d12c9b1ae757b0081fb9e4d25423fd8450f5134f86a0f428e8c72efa2d18662254ee409e6eb7b45e72400f6dbbd30d8609d5539617b25df8866139c12360018728341a32ff0da057037877fa53eb0d7a31fdc3567e13502e896431340645e971c43c33671f317c1baa5412359d489803cdf3a3de165ed0173465d3de92f6ce352a5cc41b13d0fb60823141b63dd25196a8df7331b5cdc232c5dd482ea651b7c774a9840154552a3375d261286f4a48b6d68cb3b1084d81b3c255782c1c0d05b19155d633544303f0d51a1c01b4f12eea43c9b10c447f36fac08f199812a5ff26f842172571eda2546e2d1d79c9a347fd1ce82c39dbfcd05d536ea800b5001dc25e0dcde76b2549a3d87535d1450071c390da5a18013c771915ab8a61863f1360739617b04416743bf16303dcb3e44ba8c7d94e9a1c93003a488641c3e38457bb1510c3a8a2b35acf23091a94f4689b0a704b2f9e5257024cd2d9ec3482c15081160f457165027b1b8152cfbbfe63d76be3df2903f99ffdfa9637687db2a2c63201ee8e9ae5a70a088adcc67daecd8fa140f97f2b9a56188ffb4be6f7c38aac700232074d4d2aff798130f8ee48e6c5191cf8042dbbe575dde320a86cee77d56ef075cfa43c4a44482432939a6c8780bfffb8157433f5e0007dd798e73e586b8b2ce2cab799fa6081dd4bddda2c66f3c11bec01b2aabc67ce24dbfc1b2d1395f14a166d20b697658ee76fb6f159d31cf803b6e2d9c49d6bf3ff503b2bfeeb6162d9a640899689d5c16d6c1703d4953402b0f64b70f93a56bfc56a34779b2203dced7a7e8416433a4f059a9aeb07723f9a823c316504d59ad59a96286474286746f1f542cecf0bbcbfebf16cf9a4fdc5b2bfcda71fe0e7095d1030194f25ea29449196ae349717f19f649702b665f8ece166797ceae8431567beac44ecc3dd66c1b6fc5739e820a819dcc161c19eeb356863a6353f8aa3147b9db076f335d7e6185e5710a7cb7411f24a811391667b25fdcf647eac7a69f4128ceec4ee5981fe4f1a4bc2dfb00e1104b4e0bd99fcb9cfdcce2ec929be7d88342dbe93330dbddb8d1d8f52b706d2ef3c3fa52f499a39946eeeb58d58aff01a1a8cf3f9655471777c8ca47dd7fae9b5c83a71bb9ed81cbdb39001887bd91978a52d1a64b6df5182a0d840d6d73f55c0a9e4791fa6cbe5f6299b6bf1b32b56ead7f1cefc037c827e6aa6a697bf2145cfdeac324427cb95dd82ad93706af2d9a487b2a914d96633b541c5cba77b450b2201fb7a251a7514997c8c2e4ed4b7676bc7dca0be0d1c16fb7cfbdd680835c145083dede3c9758826efb4b4282676a545c1e93243c4581728727a298aa601d05be1543f9063dc22d73a34d796df58c5012e5708e9e16ec636593f57f264dc0c7fd71612124f81f523b51a0d9a7a9f6070abfedd05450c2993a0b65ff7089e5ac892dafc5e7accb881918536a7799dbc596c60978ceaa6d7817b17521f4a49e1add79816a2f3088a183ff8dd58741c35e5d5af4ad58ad25c06742fc6c5516d2df9ba7492736632e8ebbcb1860a8f82991a90b168ec6024ea96cd941c5b003e3cbc331566d19378a4c36d0f4fcd0367efac156e70b0228edb6100b17d0d1774d1dfe92c5c6ae85a07a65658f140b2edb3da5d7835fc3f03374ff5c7da22334f009cc641288a4c196ebfefa278746663c2a68c3ea986154d9846a04b9f5ba0c5f59aee2ec489e4cb010f92ef09ecbc7fe356dce7c93cf82695e62ef6ac16d24cb8d9a2face177dd6dde3a786e7146d7872e42dc000e2f4a636ff7ead5593188433f8271a3ed98720c237b8763fab47c2d7fee5398b895c006fec56e77089a58efc34b24f335145e79e0811beaf5daa1ed8718d1bddca48ac4f5f3e0f821d32fb78aa48b86329beeac7a26bca61dab5c950ac246b987323d393055e2cf33409317dba61e36f477a94b4d8d557668567ada48e6bc37297e83ac051251cb2b3d6ecfed9f27844e825437a91205ad7d1a6c55068b29d826d93f02e9c427a000d942609cad0504ca8963ad10f10c636720d9c138cf187dfa59efdb81230cd28fa088ce3086096c4591ed16c3f16ea02416c2e5ea905900b1ecd27fdbc9c8fbc455ab5e96caed3240af7832468e2639a0095e5d408e983fc66f6957c8722f4686e4ce7d5e657f21cc8091e7ec26dcabdfa1cead1d288d78dd814c8440a5d2b5f4f8d58a4ca8467f184a2c4b3b5b9b7551d413b97672d12797d679c2ef8478347247e85177e9a22be11fabbc044ea833836cef56f57bd0c91872722e34423e38c8a744fb0a5bb1fba021106b7b2216aaf30890da2395d6f0a173ab0e4a32421040b5c0080e7c8d69449210bb846c3a3b780ae50ec31f62a76de61ff24dc2de60f5a750a3d587c68717aa884a0c99b438dc48d8ce62a6743db026547d9e0b7485c136106f59323b37fb5ce682c7d1ef83677f50a4f42731c5cda0fa0bd54080dd49f731ca4dcee7848227f28be56c56751930e97a884602fb65da34f5fdad957c76adce4a45b2d67bcbdcab661cbcebb646d9b37a2096823dd2efec04073127322e1519880c9ebf0cc588a62a7388ecc1d5bb82e56f77744e7e16bffde409c1d5c400b737fc09786c2480c256b1a2d768e59ceab7f089cb8a48e9e42b541feacbd8068b2d3b0a0f2b29f067168f0b0794907776f8c712cc34b2e08196a4c1734daadc8fbe88af259b2b4b526ee71068184cf333d0b60e917e3101e0db1ddd935d308efeabb7d852f9875959260b9698c88764e7c5a446e77bd8fb0f46d30dacd3167425f1bd7892fcfb7e87bf3328f1c5e511561619d20d0fc87dbec2739f575c5de91c44881b375b112fc1680703bd879b91e026517f396eef9cae2b69e70389df9b51a48100258c847e14fff3e894743407cf2b4df66d1043ef4a297e0638cad2327c769f3a8e189e2e4875a922761355fc4d49d59f27952d256806f72b6d2f6fec846de3be6450f50ce903a7d22029ff0662d620ffe61f13586f666b0f7ea817404e25f812c04db8b7ff5bd51a8288d99439b8229ca8cf1135ca12e6c9790ca3e73e86e90e44633b546eab5825416c2ff585a711988c8b41af5f2cfc1a208d4e430ce7d5415fa930eee3919e71f20188a65f5e1a9642041852ce73fc547c5bf2fe0193d2dd6f29b61afb6cdd072fbe5d06ad89b9ed1a950797c835ff8a7424cc1054d13e89f33b85d34ad3995d0c66d8fc467700afc05493ca598bbf63619391849747be856d176dac8a71e2bebccb1cf791ec74d68d5337bbd3e48bcf21c0af95f174c60f4a3b5cafd22542c0bd617efd4552e4764446da7500ca05cd645ac552f2a5de444df7757b1cc425504af88c06585989eef063572bb9ee0a79f5ad55d730305fff641fab6e0c1fdeeff1e02b18cc51fc3acb352cf5163a857411e3d3f1249fcc2c53f07b32c56c73c94cacfc61f84cf1a89ce901195b2dc28cc600d5f38aaa680083526720dd81d573314cb50867a6df2ec1c50b38e181985ee29509fa22fd7892c9d89dfcb899f37779fbcfef713749d778e5edebf6b0bd19abbf1580fab12209b3c258247b58ca281c72852d66abceffc11c6d38ac4ea006057c6249123660596fbfd82a1704a7b95cfb3ccf0f9701a4f9462a110f219472121750b90bd5accf49f6a6e183832da60df030a046e7649c63ce7eb694f8b86527ab6648478e957bedc9447229777f5ea823d4b6bcde9140c97bff901f72eee62c71e3f9c560fd52c40f21111a3b8b580fbecaf19f074083524218f76bf61fd651c2a81e088934edb0538cf9304c8594764b3ff52fba22708cd8083bd74f650fa50ac05ea3d39e4547d0bf35ae17ce0de8ebd008a79d718071a32cd0eee0622317af3b7d4d1d357ff95c56bfbe08a40d6e8e7246d0e4a0955ef026851ea29698e4d40c2f8629d4cf1f634b79e900b48d1a3d57e1405ee03c0d877121df8d1094563cb6e218ddccfb6f76393984dab9b7d37c7fad8d56b61a92b4a839a182f7cbf5500fb114e14f959df631a9b9da93887dcce2f1aef475456f89d1f68d377385d314fa14898acf990d1ff778ff657eacf26c1fb356e4be6349116c6d78c25afe0f3cca940fefd8343ac133fa6d4a3d283d6a992b99bff8c71606689c5ab8e0188f0d3236dbd27c9e44999c4d66b6dc61b1ae677e6eea8c36a3dc7a041223c32de6cfcebb1a6657dd39e772098263d194dee00567726405131eef5bb9735dcc9a64ca53e64c1d339f07f9c6600c2225038ec0a1219e29d9937dfe24662cbc0cbf183b64802e4e30167ef215fea553ca311f3f110e2b2e996356a6b20b3116f77bf271ba57e0dfb043fc9f99d473d2d5ba8ac9798fc5d143f0271e08ffe80cd996f7b1fff080dbb91b992ec2e3d0470e24becab7356412b933d7689c8c781bf6fa49acc053e9d03af3a092558f802eec6c0be35f5c6b2683efaeec9cd6b6f88a93686c835531539900acda8447200a65c451a461beab656a550e42b39af410826acee7fac7ea6906a3886b585277b5b4344678559afc06fb7f15a97e82b5db7d26c4a248f2ef22a42281ddf1b65ba5993f2a0b9427f9d58fb7881e67836ace950ed68be70c41a43520dc9f19c7fc851e073c5aa8e13fd0976629f76b8c3dbbe283d2407448f9e957b216db09d9e47c248a08ed35674412c31b2a83a1f63dbdf7eb3ac683bf3caa9745df443a9647fc39ba71399a2db2c3fed14b2b5df18f974c74280d323e8e6585c2b2a6e6a7da85ebb50d7fefe2a3f80130b40b71ab7867322cc6d0d1331713408cbd968cfc85e60d7b899f74171cc7f5ea9b9f32c2a6f58a32d8276f69333d2c5b54360f8ead147cb58b8f3894cf09afa8a5254a7897a9922760012f7121cb6d8b6127e948bf945a2e8b18aea5a9d74bd98f7b057abf541b3d07aced252f8a63b2b2f893232db4c0bec3f71f1381e85c694ccc10ca1f788feb8db76dc0b5699840b14160fea733738ded1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
