<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c0aa9bcd486f9326a4417e5b5a2b75ff9060e57ddf7633169cb04d0ca78f20cb222738cefa251107f4dab68cfe3881259fe2493386980692fa501fbb5799b61040cd0052a54b23c5d9d119397446779ff0489361d5c8ff68ec742ae537ad725933b6d75a5aaa280703addba528ab67e75d2b461d72f9631ed013e3d3fb031281d153da64ec3cd9f0e8891747ce4d673a13e2373e3c226d20b831116394e1839efe55f23d8fc8faf1509917d5f1e85efcdcd2dc65be92f7691f4b8087d83a1e774002032be8dd3356145dc35ff047ade547d1cddd6782e85907bd1067d226f1ddbf7f8630010e19bd961b2077baceff2dd95aafbc955de5a247a7c6cfbc59abcbca7fefb567f6b9e6a48a03a92ef615659e85d1ff8a91db423231145cf2d939963e13ca65afd88aeb8b9f168844a17447793fa36eb2e7b140cb3b6681a7e045ed3a6fa130c256caca58ec476a2c54c75e8429cbe224931c2ab1082e457aa6020884b03e31cc2e7ce04e3ea149c29373fe203dafa986d5567c694f148198c8deafe6f4c9e026985c6b8281e18ad9a65ea6a740413fb096f491b53466276ba10c51dc76f02da2ffbd78da9d98ad1d849feb457c44a28db563cf388f9fa81125253f9057ecde539887cad795609eae1eb3fc9c02592c23686c5cf155c9cb25d52800c2ea318db03a7519358af6ed6979cbf94e1f2a9771ef54ee2070b50665d545f6dfe7d2939ada4c1149d1322b104eda3e65b822a81cef47e590ad12101a474ab26286858e512cf256c0ef3fb700a87afc7e9dd54af7b9e82ef506f063252d78a748a4f2f8abc53c5fca70d93d30c9e2b42d4564b7ddf57dac8408a9afa33017381bdf6b7455ca521c3f15c60bd9be7a63bd442e597f725f7211e69fffbeb4e9e173b435fe890f99078b67dc20356192b6d59c5f9114e854e0690dcb3b31bde032ef57f8adb58280b70f7c35b72c33e99a4ed74db7b7796a72659dc695d134ae16a957f2d24e3b2a618e6d54460aaadb5706575d8f47781b38b8fbbb902f335e790305814b86b623a6d6966cad81a749d546a3bc83df9b0b8e43b50228797b602399a73b61094d4fcc4ab99501f7acc725b73d200b01062152cdd3e25f1761a10fe20d4eae0fc77bb6a1ea2126d696a4ebf2abf9d861c6bb9dca7977c2b1d5d3332aaa793e9fb082f03b3cbc538d1233707fe7d73b4bac2de2dad580201387e45da9ed7150f89ca9f0a4963abf663b401919c1d4fb613bfde73e02574126dd802d1df58a9dd599489689588f821c250dc333123bea2b23bbd775cc81eca9d751378f8d0421685c1dc98a87ebe641eb208186278cce52004ca316604cd3aa25a2fcf4d3d2dc871daf164d2ee5f26aa63596381bacc09b90b73e3300f0021a785a8088a97369a63c20a11c676c66c31377d5133ac515c134f22c13da5fecbbfcb542834f0af0466b7e65a93a609404b67488f35b88e76b90dd8554756fc00113fb92cf556132fb8b6b68539defcd78a4b8e78fe29a7fe07a49908505356c7dc604eaba5dd1f1bb2f8d85f1e64abd7ef078b480d9c9166bc972dfbb7abfaf4093fe65220a97bfc6830d66d5d6e148ee77603f3c49c21059e9dcc214b9715c28903610a32ace07d8b331002c72c5aa79346fbab9f55b12f00378f860e1ce81deef69dbeb8bb01fd2666935851b03d1ad6fd2f6ec839bbe80e5efc1209aa66de0acd4084841f0528047dde304bc52561d14d1a48091a5ba61bf914169d021821d093914bd3a3977e0d1398d2885d0f09c9bd053cff7677c88728bc2831fe5e18e4ccdd9d83e45603f8aeab0736f85d6f59f822f754d09bd0dce20b74ba260e57bf42b9eb255cda7a0f5337b97953311611908c8c22e9af5a0eee1fe665c388f87151beab32c1a21eaf5d2735d57cb564f3b3bb5bef87da1da1ca56b602cffa167964fb47b669b628bb9bea2228739120c5901a5649bbfe674365eca9533a59f02c9c5af1bde3e86b18680a33461cb6e17d26539cd1a9c9d3f2c37f4827e61d2a0dde142bc299cfe08612e0ed61812e6c511a580d66ea2144c8c987883f6b0f64b77cf6218cb1d2ca38435c9f1cb813e1cdf2fbb1bcca5f3d68121615f1969f751f39f16b3dcd9fd3069ca91f0da13edaa1862c0d0c98948d29153f63058af156a4280f7855c90224271ba04feedd3d77134e69a1ac671b81d70c0f84f61cb6e9122d0b88ef886c440873b2e72667d4ba11a5eca44b829959d23e958c1517693018b48607d45bbb58be1cb7ea0b1d96d433322cecff133a3550de59ff6dbf670dcceddea5b0572ef85065ea4178ccf0d24a904a15e9824320409fe348bdce1a7ed8783f1fa324d67e5c08da0650819a1ac3663d2b7bb1c8a7df1b0d4c9eef23d5560187c1e943c3052db5a7e34acda974fa48a183fb78a9d1b7efa20f4885dbf9a2f6b6363ba0a7bd26976d4cadde5b39ba8a61fd07d109894a6dcf2e7f74213a7990404e9168959b130e927314567f0eba706a4451a8946134a53e9239639e480bd6a32edbed37ac4200c0920fae7b6f98b35f8983998604cdeda7f15a489a652585b3221f25227759623bdb0a819d2168387df73b2bf68d19878a5f2ee6f94433817f0d2de6bb5978ef942142e3d34644256ad11237d3c2cad855adabb784ec4e83d67e01e70354c5e580c7dc4d370c8a69aa0f166fcf402837a184993b7cb46d5c82d6ac02781ed6abc20cb9b53fe28ab2b77e3fbb51b5779b9ffd76f9db8b1eceb9b94ed37175e35f193d7914f62f209a357474f00a81e39f00b91ed6c95ec4e98ee7c7552496c321a4e1d61d5d465f64f1b020d879c336029a2f6caf184ab04c39b41c6387570d9316f67d03b8e53938824b457806e14a3d572a25f2d85dade490cd9e086afe7c9253d1793496469d47a8093b89628006fef04e1d2fbeefbb272807950cee6f0a751d8db736807515eaa6fc823f41bac11cf6b30291afa160efcd5844eba16aeaccc802552d062afb5b8c06919c0e8bf219c5e673dd16577f2fc36f14534d1e919a187a7d8f528170ce04db941ace465f079a070f3b3bfbee4640e49cc701e8d6b9c5777cd77395c394ea3a629a28612c03f5073d54c38577974a188961446d60817a5775a4752c797ff9469964ec8b712305aafc9eb1160d38ec0458e50d58411dfad1a7fbb87dbe59ba3cf6588d610dd9c7fed6822cdb31b0df39d77dc5a648a07c6c6f65e037297eb6cdcd8bf364fa495af01205f310fb1f26e18313a62c0b07c0474c3a3b1adb844ef524aee3d6d0f4521ab56396baedba2b3cb73e326859d91261524c8d7d048f0865990ed575d3e4f9a358a9b262a564b10aa2e3b1bb47db19e77638aec17af91baeb97be53a8b893fc52c3c6cd6e1ff9da4b05cbc19a2f517b9d0cdd6f7570764fe17094167cdb61513113d4d2344d1897b0316b606c8468b9ed159858cd76016e39fd2cbe240cc7cd06f808f4e9fb055c260004a9c53818db2fcafaae79cc0d9f2cde9071263fcaac4f0244afbddc8ea152d829630c03e3fce7ac8a66ea140476cf4ca28548df17dd5add9b72af6fb777c7cb85906496d6af3c255da3781ba188138ebdce664143e9d06ca95858569275dd3457055552e95b2b61d0242164834ae4a790d0da75a5b542718bd85c4f46a934f94abcc541a6b00f2620ef06e4896d23318bea233289d1fc02b524998a4aab621f8dceaadeeb1015a185a2844c6b88feaaff2f16029d9dfb449adc57302e1b287ac88ed1ad52223c4a57d8fdce2f6b4cd27376adbd805637e3ef7b525a59edb01709d293d5e1931ece62845265e7b5e974cc67a0868e46a9d9bcc5f0e30054a2903282f7274b7e76fa1675ec430ee0c105e5254627240a1e05b386c40cc7ba9aa7afec2e03ec2be21f49ebed3bf07feeb4df5bb3619689329f202b3ed647ea9b252bef86edd3c7df24a21f48358f40393718feff8d065d0a56588c340859c6029d1b21f7da2824ba738b85a3a5ae61f2d4053bde9dccb0d0ecc22dbe1e8373835748a60bb3c159cafe75096f03cfaa81273f72864fdcd23836065c3956c40dbc04c9668f206c8d15920a4a24911e3f05d34308462cd17ccef10f983db981030e3a028f53450479fc0911cde897f6ba3e46dbd9a07c9a580c927b34379ac7d39cac1db8960e5eea3268fa027a87b8597befb4f49634ca1a9e632adacfc121061b485844efe38055e35b380ccded51098c2d345d44e31c458772538b3170e5ac7ee5ec808d5fb47a83ee1ca8f5b18f2383a06f2fa04c37cb258e23781948faba53d54d81320c6eac60c26a684072a7c9c9cf10fdb7c4b4a1a2fb07032f8dff510661f736c20242036c1ea574c89eef6c40e9303a1c52756d1e3073126682e36faea61abcd5205e8f9d2f9f3e655fcd13785b94b88c2b013e8533639d8877690485249b6cd719a5e1b5ac9aabd6bbaffad945cf96b20b30fd137f17567aac20734b0d8f6526e9818198aaf6a5355e4d945cab4e9db5b501958d5fa5348c504af776965a7c0bf8f6c4154145b9996ffe156f0e61773d25a2bac40b88bc8540e185e53c9985dc5e75e4ce49e5b469be35e486a6e125776ac41dcd2c2d782b017cbbde9d8bcd723e689822f8e7d82e1211a909e49fee2bd2bd6dffb7d127d1ced44c2fb839301d3bc024621e9fc41461ab9142b6d7b7c65b961f1e99897d904593880396d7e268910a4e70c66e4861273c11902f753882af09293d458cb3a710c54dcdc79be0770166820ea2b5de326b7f274a9e6419c074d4328652f992a361f625fe55e78792d92f2e3bcdfa5175741a94a6a406ddf901a68860e0f348886cfe78703c442f7660c3fe80adebea5fd027b51735ccc4792d69011bb83d7e7a407c9e3d2c8560bc8828c1a5842016df3ce0e4a22679013dbdd8186d8a8d07ae170336871a96ffd6c681162d433ababa98cd3c57182162e479c71d1f22050225f7cc635139db1d5765a163f2d76072feb63bbe27375f906c89a6c2209bf474ea36ca98cca7964451adf69ebce61cdad5b32e9ba055432d960e9ff229983a5ef4e4e3ef3ba228fc5bad546b593371351270a82c3994cbd306829fa413eb38b66771123e184d3b46176575828b9bef7440be5cab7983ba7124d06bb7c65e3f263509062a66f63356ac6c7598866363f1adac6b1dd892be9ee947e266fde284717bdffe9c9759febd6f21ac8a875b5187d0c15d541b6d56a8d08e6bd41e31ceca92789d48ba5bb4324c955d89997857ad8f577b9dcf1fd9f4aff0ac00c2abb7ff69334304b29620684475d0368c8c244cdfc052c1f1478b1cb2c41281a34124eea718425cf9126f708e1645062f8956f98545b2278be23ac565062c6d22a3139e0ee5fa47de67836268f2a9e55f06d4c73b4873d59babd5be455b6f43fb1ba9f7724235b10124496a55059139460c2ac422c23bbc1bd8086812497776309fdc16083c81d2656aa9a6783ed47b3a4cf06519358c5d9e6ae6aff3fd2093c8869507d041575156ac7189de7812465381c39a462ec786a7b13e976e92a4760d616de91c9a7baa790c0149113d9a27e628e5b71e1c79260be51174fb1f91c31785ba31064ee072aa9bcbf9c1da81aebca6fb04d4c9038a439ab2f3b7504202e786a31e4d5544d5c6a5249ecca5a68f835a0f06dda9e010d7275bdb441c0a70eeb2f5166a686e8db7a945225a55409f8742ef606697939b81ac0ea5f70447e7b48132712ac771520d4801e83c6c09e6ff621e54450bbe72159c0e3770ec04ad092b1db2bdbf8ac6e666bdc06b2072fdd7ec2c2c6c4112f3c833144130b2707c31aa75415043c66910051dcc13dda08ed1bdc492697c7b1c512de4f343d30aeb976c77fc2e200c04af0a10bc1cb1f5e171ee51449c90c1087b4d72b4f6912dce18906432e10fd4e9d2a79cb2e267121249292035d4f615dcf86e680a661402217e5d4ad1826f003516da52d3d029af9b8a38fed76af2876803629c946bf589738e2d9f61f89fc0c3071dfa47aba318a9d615b05af70e9cf0b319a19589c573a7615c2363497b4b7a51e8147ab7253bddabec437622c37fd737af5216fc86e10fdfbba283aedc50f3618bde268ad5fc3e2bc03646cfd5cb60f09eba59d6ffcda9de110575da537d6237ba5f4f68d614d460dec8afae01d0837d9bad448b2922925d61fd12d91f64196e903719fbf9034f3df0bbc2169583ce6c4fb3e2c387dea8f26dc7b433501074a0792486f36a1e23d8e24b06b620bb1266dfcc75bc8ad24ff1b804bed239d547cfd86a7a175677b2561d4df9856b923f7323db1025faaa5407fef3901e00f9268883a347bfa9bb3af3edfabc20a5acc0ad7e000ebaada7e0ecb16f714c4dc83e0861cec4594381a34bc940a66f193047b053b00b3c29696b3aaa2e078dbd3faddc6d4e1c81c53c8ff1f0128076a750d886541919ee019a46f202eba7ca4347b51d0870eb32bb9b3011641b4c3778fdfa9f73d1b804556a01f813583bebdc2938a96f284088750d6f000fd1f9e565f76d4f6861d7bf2d21d84f4cbe759798a208374271debf93ce013cc919ba4db8a23228318274b4faa9a9682706cf20b20c542d03a5ede75d4e4b179b84ef02fba24572a5bd8d19689da4d7fc53582f1aa7539975aefe1a7ef4d65f9c37377b1d1e6337084602d48736297d00cff02bd5c41aa4720e35785a8af9b281d019436bc875fe0cdfa4efb96b7ed1f2cc63089fc03fd879be532a358b35e5149961a9eb0673dffa611e63d5fcb15fd29ba797bf279185e7879564f504ec293ac430808d5e3483094d3380dfdd9b74dd4e7c4a5b6a14ddca45dc5266068cf519d634853c8df4b05617cff0508641c72a48a7f52dccf46ccaeaf5369033b3c793ee53b70a6710c5f5c25e04df2f70205017d8dbf4fd41b0645ff8d35ae0c98906a925fdb531d5a8cd5c7a12c5a5164e95b29994b3163b71602b5f611078a360454c4ac8c8246d12e2ff15e060ddf329fcb074549b2a330ce424ba660f91b6dd94e1589f17b75132287ad76fb7a2e6d31d72f34b82b3fa3d89d2d0acd8ddab1e894d1ccc57907ca691f9c78fc168c36fa398783ad4d2f8ceb783a599754ecf492cb50cec3ac936ed91542438287c108e6bf38c32226022a7024e50456ccb0ef57f7602ccd8a3c3802d577d39a3f332f6c5719321c4cec7dd2d154ec234b7799514244c85cd3e6bba63e2706d6fd6135f76f7c7d76accc5f111ed4e99395672569978d697f70bb27ef9b0de09f3720b9177b5188a967aefe35102fdf73e79b655f14afc1531464c5587853180275e7c2cbbee035c0d64b29329e75c4045fabe92e3a1c6f60482bf10391fd20d4df2555ddc0e9f9642791864fa1a327d0dbccd9345c297894cb31d0a7e1518d5638b07a1c0d5bd59560ae77f19231308139b2bf624d224e5c340d815f5a2e9697a6f58cb737849bde4828a24ea83002cc6d9d416b8ae9296d0ff5905feba61d315da2957348e8bb8025463bed49ddacfc2d61274e9845430ba19d7861f743981a36a82d7b73858c41509f3c1844c5631d96e633a4cddfc3adc2390c272116b8c0005a30d58e6b158b490b5db24fc5c10b549a11d1479dfa3ffdc6575d8d46ccae1f9581bf706b2aaca3785e3339a0cdb2ded4aeb08106c3421770c070d8cc345b5dd7893a9ccbaa59bf7847248023c239fca72f7d986be8d56ccc7d67e1527e5d9d781e0828122bbee24f256e48b3982e767092035126b0f6ae358c0313eb54589985e8f6772acac675683417ddd2663894f0d5153343539b494682259f227cadc0a0cdfaf905cf3d63001271123d6516247365e71d1bd3f3aa71b4e9b3a80ea62309634c2a533cc7b9c4121b0c34254f7a820c42577d4b836f0a162fe03c89026ea46e6031efb1aa41c47f5806e043abe5fcc63321d62f0962f8859b621fa10d02c5c1360785e2b35a031af8f0dace5b45c329e63074df392c57181e55523a6fb00c04486981c6db2134b35650d6aeb9ecb7e7ba94d3deac5f575fd66b4eb2dc5e9dbf5a9f8981af14e1d80d586f623391270d539ee78834c9e2e09f5883d4980cd40a70f582fb93bed10c21d45a5382998679ab2b21f9d5c326dc3a4401760e4c0769eb1746ebd55abefd862d4a960dd184c9c08bb4069aca680416e057d10c3335d1c6be17fffe04a338252494a6996f26f5365cc446f0ac8a59905f0668ae0f50d58b447f2ae79bf39ec974764288f02ad6f5287cb95582e01366843eb112ca5a32f8489e9bcf14a4296f067cb6bc56e390494a8eabb58be9908107d95dc6b80b743c49ea6b03c910c12eaf238c2541bebce5b3ab1586695826209d2cccb560eb06c0d079d339bff7aa23bd481cd057f06d1d4a5bd769360d9b709e5cdb0fc04b3a01a9720daf7fed6128e8755d765b42bd6cfd852c65e67bb44ba439c8bae3da583074bf24039363f1ab32cce45d1afa1ee9ec095812f6dd571f445cbd22bf7df348f428ad9146f33455376535e5808cdbab28c2fb843a7c02e3f7826a7478c9ad41ac4a965e39daf59557d928c75ad184c14ae5216159df92819bc587d98ee255d172345d85f5a4f61e7d6de36f908412144b958ae9ba319fc58ff3d34ecaffeea5d16e5c5f6da4294a669ff5b15b855b54b038cc383f945003e4c5d93913d5e0d354e18977c4c951ff22203e7aaa9ccb5364857638ee2c95ac3429b1fe933d2e8c17c354b7430a74dcd53c8f45f6e5dfcc154c3c3a1948360ac478ceed38bb37a83e81bd5dd3865b0a6c4823c62c51dbc7e7e269c3484edf84e3468bd4a55dbca2844d31f03564cf318e72d34d7a14b5152ae0569b69516b4e79472110226ee30bef913e84ea9cf29c6e7028f9bac7c01ffdadf86b85ab8731571fbbdad432cb3df4eb264ed0fb028a27c739889a5afb853583305cfd907b8857997f5f6f9df897ce23d8019fe7dfc22cae2b1c430a9d44bcfb200db4426a37519cece98ef789e67b8ae399a14d3bcf8b4b4063840ec6193dc834c4d6e3eb7649cacc8244fc44f866dd50ed4dd21a30f5c7fe132af3c62909fbecdc0a9e8dad4538035e47cb25da181d7f72e41ef8e3a042620484c3a386767a63be05dc2799b40a27d19aa4cc3b047cb34b683bb6ee03bb66ee9eae657fc8a0a7c91f261f7c5f180c991d11e952cb7754169ef6a34ebb7971fad74f8faf150e9b4a1d22e15dec76aa2de55879c76f1c7a2e2e75b6a90c6451dacfbc88b9258af366c07870c4da7976d8b90bbdd10c57783d02dbd35d082581dc384866e469a9d42fa58c1c33238d057044e42974fab6c1469d7020b1616abf4db2abf13366091aef3400ad40e10c5ff2f820b729ab8c2ec08df292f0f4cbfeaf91e6917d3ce46400fa26c503ff52e702f86ea137530b98f0150702f43cdfaa0fa40c65623f679e332c3622cbd1dd86d79d1e90a63a358867a4043371a6e54835a9be18c17cf0c990bb0cf46fec2fc991dab4e31c0c59530d14f04f7b85cb829b12ebf59d87ad089120435b363ac7b07a9cec5323a3afdb8f80cce9e9b4583b088af7aa6acfe991cad2689bab0abb6bc32ef5c35e04e01c10e084dab8217529011cec2df49024cb4cdace76441f7b3310097ee250a215fefbc135ce53d55ebf82dd18f210fda085d8709da370eafd5e003acfe534e8d4f9975a645d9cf8e4948c2a9734cb640b4ece511e71c95d23d5fc1ef510abcfe922bcb012866a2227fce03eaa9cfc73065dbe8fa038872d1efe98cdca6e8b379ef14224e454d0e5e5f41001e229d8ab621faec9f340f6a0568ea89571f81307c8b7af6845867c12dfd17dde03bae15cf39c825ea9c4ddb8cbb2edecd45021e3e1374f76b8abf4765f24984627b3f8c5874dc74def3094b6814dd90f6dab97c2eb56a54c8570cee0feba27569da2a8151044307b20fe46361d930be6adfefee9299de9502ff4a8424a38a6aab8c19b24c6ec7b0d8dd370556a0d95109d35c35971241533874cfcfe8a0e2df06dc7d08d8a271be234f84bab02197bb047b7abee50b045feb658a439b82cd02215ae6290080cb5aee1c33c6ab627a3120476115a060a90c061acc71de595c1fef58ab557f4e918e2ca575cb35ba142d4407f1f220068165485c8d8070d92b4f2973234949899f5b2e337a4569f52a14978d24aac60513bd3bf95810428925387f2bfe4f9e311d84beba315ea96858407851b1fda7e7176f1f7e61bebcff7a28e1ccf5143608099965eb8756625c4fcfaad571ed4eea3860ca3e97bd5ff4495ec06f865a16810219383d95cc321d754a2fcfb95a9d39a636cce288e45f7057791b29351a10144814d0a75f97c3929a4ebc47355e2fad7463f5672e378c6deb695a57256a050409532b831ac5ed778d02db1f6ec21b3bca18b2625a89468d6a4b5782284a817389b70982bd2dab8b739107c59ecf95680fb1cdff74cb40af1c406ae2b01cf2493628a2ce7d30f02e74cf3ecae2494688659b5bc3d11e69a7c4fa9fd1670c272b43e630918f9e7cba612786ab4afb1f881a13bddcd5d8195c40a6277474f90819e3d2e1b51879d609531edf4ea909d3719ae23a499f5ca8d2c3eeb30e8a7ae8b9d8be9290285c7d3aaa19a651938b2f297efd64ae1ae34a20cc5f16202cfc17a7d76e926b9c99818e0de67594becaf1120a9665403bd8aca8a4083b3116a91581a7b4a4e64ab92a4c00c2f47e0492f9f9383310c0184255df8746029def4ef0dba0e650b09737579e017c3d1ab3b559d62b13d220a1ebbd9bf684153520241539579a0c828b61cfbe0cd2a4d01b06515867a32ef79b119ae0fcb7d135180ad156cccdb449ed8adc355635c948def9ca860ad69ecd902203b9f37feebd6648e9e0d8e18968f3c5de8139a1ffa9fa9bcba42067d181e0bd4c8e75ef406daf8b6c3cb0f85962a091819577700c0b1b57df723b3091e6ec018626fc66f292bc46b382653c56021edde9ae391f31288fdd0c4547c2db7a1e3b6f0ac35c7060b14ceb12ba53f2740cc25f1151e5d4b9813807b0672652b211790202296c0ba2caa6727e3b47860d82d308825c9d931cd53dc70829c348e9d748e6efc5887f2740562c15a4269d524b618e1742591366453a1267976bf6be521e4e1d521f8b0fa08c920f03074655ffa5ef5caa9d0ecd4880963617be30d135409cb136ff98538ef8e6e2a61d24741088c78d438e71a75176b19e861be19674b42c32c6d87703eb19a444505b9fe2802bfde5bdfa9dcec173b23095c0c68b14ce45fbc581e93e11ac81507b361f35e75cf313037bd75abad587ed8a2f6622f7a9fc21bc72449f04dc50ace318f1e775b972653a86f04f2f7f39455b3394fa7e9019a84ffe8b2de0189333fee1729dbbe83308466c1f25c8f51b61a9065dede3fdad6275788a429ee75adce14af0f3214a57ca599b87b3c49c58230ca4b6c519bd6c24ef1ded01185141e6a035404ae19084ee6629886211992eaa423a52f23973c1a91d78bbe2b0f1a2642f3bcf329674ff9675ef8121d68594e9ba9849999b84aa02fa02320561a50401d350b9bbae58512e5049798983a3df03a196ee32bf4e522e1ed7e7e4b15aec7f91960c020fbb5802f94f05cb229f00a3f814585903ea45727196edd1fac10bf05fc6311f6df39a5ac27fd686a7b389ad2a94c0f31200dfeaafee368e7a28a15839dbac1643e6da3581f3807658c8f3db116c329d3d15d2d8cc722b430bab72bd4b22c541a276f7463e83e57f71e4925ac80226fca25036a83d6450fc7f631c0f62d6dd306a5455b92d8ede29ee7c89f065977b36fa5722c5f8176d0e0f43e271d24bff99bea0dc6c7f00ab759526eff26046a2b16f9cb8589496eda5c8f103051f7ce2e53e529509f7621bd5848ddcdd9382e248d3f2f501d3c62bc64e9f807e91d33cae01777933093764d62ee3af6fc1598bd23ff431bd3a291cd9ff95926f0470bc7c7e4c7eef5e6901029b0888d7f2099a43fc4cd3d9db10aa94eaea01224139a7d91c36bc49d496f79bbb6ba790a4c959f13ebcc140703dc97ace6ee10205e636106e97ce9b17641ae803f742b9ea4e6c207643500f657b6f0d5755cb4806817622b2e19eec68b0825f1144b1b8f195f27cd31d0c566d38306f7563abd3473659c14c65b614937ada8782f394872dda3160d31d8eea75ec56d5b9e0f0304a4e2c714c80208a224d5e000f4e1bb416fe3659c7e21c5531ee97c871aa61819efa50329e82f9c753762d5387b65816a74e8e0b4454ab1fe28a434dd9892738b23943bdb4d66c610787dda5889963a41d620458387cf5586616447eac5a1a97b439be494301ca891d157bb0fae2115556562006907c9607199b5fc5ef8a2ebe09a398376437408c1bf26fd5df48acdc6e125d5a562c4a09af391493e6508dc7dd1076a9139530e80000ee2047ea5d9750e9017e2eb2005cea88d41e86a46b70b4943c8824762a03e965a74c6bef76d11ace98763661d31403cd70218f63e2d09921042987a076c32bb690c3d30b83ff579088ce68c4d55b0f12bb07a3f70b6e576d9ed42946981d983afd934e3f00e9b1de33ed039e67644f9bfb5cae985ea4348a3390c21069bd2b7a157e491435599958af3be670eb63ed2988a5012c0d7dbde8bf17a9b9fb110736ba6a542fc6743b7c5eeccc6a8c884d4af23fac3b34f258680398b2eb62c3570e2d6e22a828517fbc0d0a7a8b768fabfde63581dfa36fcbe71cc466455173f5e63727949bb7e79e94205eb13e449301a3570e3de27ff711c22aac00f42ff252f4189d3e1e9edd4f664049989ab7fc698c746d11c53e135921ceaf61518e89d323c987c5bc2b3ab8e21c14af8712383c0c59a57bee6fe3e65c714a0f1e284188f5d6119d1e2c64de6e49c670f3e98573d856b2f0c1c4534395306b268f05e334d1a5c5fc3121f3cd6c28bad27544a15a6f290ccfdf3e52036c21386b450086c6144c679c0347ffa5dd9d33f5e0bb29a3db1f8f1f37b9bcc969131b709341e43a8e4cd3817415621d192d8d5a875ca60e42dc5231fc68de67dcc8314fe1c9c00791c3806c9d889db5b66254baa17c00383d91cb40372901b5ff7ede9c4f160006aa6a6f7820f3f08c3e090da3f25d4cd5601c55716860f36533d76846a67af4ad6cc81184e9af43ed11bb99918e93a21f31f6d36b3da0d605b89418212a116b0d6001ca5cf7ed38bb3e431b4bb0a9939e14df4c9679fd88f546378f9ebfec71d730bdc6316d5cc3d3852be72576237c318a6cd642e6d0c103f277e5ec4dd90a2fdba2d49e9587585f32d04cbe1b1db31913aeb0784c2e21553e86cbb7201d5821533d266c68074af8b30f450d01ae3842d22b18f5bdde2640fd181e01fb633fc66dbf13f045a8e137fde41ef78bf41c27fa0d14b243669aae89164bc2643db117eac3cc8d77e31d76f6ae332c952b1d10cd7420b382e94c7937cbe24e6282c3cc226f0b44e6eabcf051ccb4936b9f496042791c047c71deb1561934ccbab1e8cf903a9c3a2fa7b5714c17a80bf49278a0b88d87ade9b25f6e67cc043afe9cdebb84dad3285cacedf67b82ff256528ea14a3a0400e0264948d079ca4958456c2fc00c8f3fd8656039f1be4ea33814d1aef49497dacef4c5c38790b7801e44bbe523060bfb7b521d2c1a5198c88fae819e74860555373d4129e93b593941c811325071ac11524461c0bd9998b05426560aeec42a4a82578b8930c406fc9051b0ffd4ec9bb19088324e8bd7822cb124d17f8bbe19ea0c5565c66cb12efe806ab24c6660bb248f3ad32a9dcc9099b3df436f60114a9098381801c14105cbea0df3fbc76c6d516a08c01f4c175645e85bf472b2d7c13b5769491c55cb3e9f290f1184c145a3c60d754c6de2476fdd7a7609bcc55672b2ff73e4841e0efa1dad72d21673e72d6a4a67b29d7bf11592468dc08fc1624aac88d3614e5082384477acb2196f49a357ebcb6f6d21661c168335f338dda338a45901b89c4d1176275cd7b4f1a846c3d3726b69e8be0ff5d677699bb5807f778e7ceb6e6b4fd4e6511e2871b80cc78e5bf7844e96f33fa3e90ea04df9f3dc6187c5c6f78c29af356c72607f7666bd1c96d1193291f7e9f162d1e140c0c1aa70a3d923ed22072e48b3b95a3d4645ea450c565d2af92457ab7f4616c886533cde467535b97a5629f05c076127d62b095ed9ab339564ebe660c64327fdbb1f0fcfdf5461e2bf80448237f49b407ee536ce725710e0871b7e7802e5e0062d10e8404c555f3112ec9acb92b58be2dec3190c39454e9e9125dd08888481e4443397784946690a84c62f7059c66f093c85444c98cba64f2fd418f5799fa2f465b663e7b514b895c2d7882dd6b2626a60859ee1730617edd7ec1dccd4248e8a0f103ba1033cfa3c9b2df44de78e3b5de92de98ef6bce557b4dba871f8ac7e7d28506f61c86ed835a932718d0e7fd9c92d23912b476bb056774275a56a3c421409d06579da42a6685e15caab400311ab2fb07c49d89a42e613361dbb7ad7b57dc3c82e61d3ba0233d707ee123a44844e35d5abdb14c0bb5acda97b0133875267f26a8af6791280865c6c9a0162c5c61b247233ad103c1ca251c9a9620bcde90e50d5e8170970f213059bb7bd100b096abd67264e6cf0381def2e538b45e4fe37cdc7f7846a0e3d8aa2042309f9a8301ec55ed5e90eac209517f2ea9fb4744e002f7d9203e2914aaf6ff287855ce77fda5a275dc04bf0a279d68e2af72dd86565aade0c986df339ea87d99951efaa633f7d650c9aaee405991a3bc6b39776100de9a6c5839c0530a52cc25660ee4402e0a572d8aeb649aa77d9af279a7412261c71e41fb65f09a3148c381c80c35cc767caa508f761ec9e73029647e5f1061f98fa8d2f175cd814fac2feb36f1e5280d823680e4eaadceb6651d4d5ff751867da98d1496eb22a35df485d0d880f9519484b35d26686e86181a784c4a5ee35dd40a674fd332c3208fa7199cee733b6d99c5a77008a438030e11de09e81bd2cdcf0e4f0cf388008cf908101516d97bc3f0a50694a689ccb0eb6be8e8d2a1505e5fe129ebd53c28b65a7d882bc06a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
