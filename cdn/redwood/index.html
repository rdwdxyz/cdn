<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ed5878c7e67761d604c1dc5666ef8831af8cd898b2a5c9cea8b83c2cc677be4ffe9ec56e61b7941c56b32b9ffcd307c05e09a77aa463185be1d1f06d374a08e34346b753ef173d42a346d83c057a776e9f149bb6d35e89dbb8a26fc7d22207bad9dcf523974f11412470f681bdc4df419d8e08d2657d820ccdb6bf1758af679707f154866d133975c6ff53b53761f600461fecaa8e629cc1c93f47fe5b0fd6b88b8bc23ce56e8324e4c52e5c06f7f2e4b744ca152a974495d08ae215512dc3ce7ee8220e04134d8ee453cd6fa33e5332860bc6b850b6eb1b96e77a795c4a522231732a4568f45be5ed098ee55d17f5206e3e8ee3f3633093ed4ebe9c501b479a0bd982dd59b6a1a5454b23df24c4e0e7edeee7cb51ee14767bddc8489cb8f11f72aa845c0340fbedfd3d9d1c8f664a7b7d9a557cc5b94b79688bea92a1f150599221d4de1f8812dab9fe5c2d2a3c14dcb7797aa9da719550b640f104dec264cddce4458a4770796a3015e81ead271e36c3bb28f4c0de9e8e7335dfc7fb30db2bb84c45885c3ff0114b7a2b48aa4108b938e06d7a4d45a2e49102e05e4ef01c398d398b868b2c56d8379c41ec3410f477d0c409239a34185857f5c4dc2f11d5a5d7216ccb52f968c0e6c82b74bedb33211273f29cfcaa3735ca6455b65502bca8e348de8216ccac7e475912a3b49fd4e943ea8eef3bc674efcd1ffaf3852495ce57451b76eb77f61aa0e37281c34c85fd39ac9539acfbfa3c5c199059e94be6ee071fc0dd00c7e844e0ffc1c942c42a1e27d87886c266486ba4900b2073787308cd139a98efc48e6e2e3318fb84e32771cc50a1a2d1468a30b80e8596a39cd17fb6b5c17053e1ddd23e2b517a0d570e149787a6f127e2cf101c80f86380be5cc07f8bb03f49ece36c98161eebba4fe17d3ad29050caaa7992908afaf1e5fd93dba29022865fef4b9683da0f7e2c7d225bdde670bc8c5d81e37201e3971eaafdc11475cfbff7883f3384fc29db42cbe1b622b566ca6858a1a06c3ce48356324108eb6dfb5e59e7c07fd2555660fbe682ee2191cf8b44dd63c622fc520e763e12d3d7787f1e3f346ea0979265f8ddcdd75b3c2681e6b20bf10282625cafe4cea05d9508d1d50389d10c2c1b941bbb65bd6fa9d023fe54ff8281e580dc8e6a1df8881cbae012c4584f9f73eaa02c5d4a7cce2384237a797ed12864dd6d1a404afd98dffe78b16788e1159454054a83caec70dd2c3dae3bb48d7a6bb0f5847c4e321cac96cd0e985b57a3f3eafdc0a13a790f085460ccccb627a471919158b89853ed9b5acb92750922dab3163ad31d8a0a89ad21c9aacb8fe1e3bffc3bf8a1798e8c0b81c87ce297134a89917c3d3073e187fa2a2c732b7335d43f3b8c71391ce71ea05a7a404f97f83dd238691ba7f5263c5ada95b15ec644dcd54d78caa44159ee16230c7249dabd401de83fedd4f8f88e12b7fa1af1f01ba18505364aeb46443674d598bc76f24ae054a7dd02004487ddce3bf91b420e188f56e0b5833ce138786be3cfdc9606eb66a4a33f4039a0b9381ede681b6aefe77d1faafa85710b8999be8c67284844f2a9e65aa0a82b1b8cf5f35764077775a2bf0cc351c308d182776d5dd877acd0d1d2ac55f3dba40226537a5b9202f9ebf194e12b9b2a48aa7f84d38ff0fb999408146d1cebfd8a3a727207728099ab7f491f9445bf04b66253b8979b53b34e93945dab66fc69c2d5862f929a56e8e56c76997647fafa06c3a87def3253678d2b2fa457ff9db9d0a625e001843f353893fab3cbe2bcf39bcb8af28a4f9a3b16a8c6234149755d92be514111a546e11377a006dd1999326f4b58f97f28ab171de6106da50d586ef5382c2e1d48483421c8fa65b5284f0c92eb8b188094fa2bd0ac38cf649ad3c6008c60a85f0527038f4baf758fb1eba826a0e6b49e9248d9f90061a859d5b329a714f1c91e11852394f9107548dc099be72a84c9942a993f97c602afd5c4ec5052519684bab7f6d4389a6f59e7dfe154c6273fdeb3a558005369f3e345984e70efbf44d40eb7660f43e56078f5be0373d45884a259d8e27b1ffaf748623006e1f06b82cc2f7cbfc3ca9f1c4bf5431f008cd1688ced169a6cf091bda4ebc9443d811c5c5cbdbe3fd2dda1f9907428be73ef52efb6418925f7bf3cbaecebe4d806c0b1a058a0cbaeab6fdf8f0f4a4de0a5406585289d733b1e6845ea6596e1f5db07de1c5d669e3e69bcbdf40abb65af043c8d0c5b11da9acc6e5667819d86aaea04c2442e0a6673b57f7d2d01f3e7cdd22e63492ea6121a14f64f0d27f5502e5f043bc304688f0be3df0380547a2f5902ebc1a75050588a2077c8962a4385202f09ea372bdf9259b2c0e4435b880d4c785e52a99a5b07196aee7ac173a152802d87611c3ebcf0f091fd9e3353af05ecdd5a75b718699ee9e4d4fc4b1743602ba101dc79b2c32c0327dd62d817be3a819ce8d101c0d8bc65f25a8c316fdac3f72ab43879c1e488417bdf546cd778050ecf6540ddc5d737add487a77d7b70388bb84c79238f6054bccb449c3603becfa898deb4fb067c29a039ff696e651268dc520c3be431edbfd9db51be1db0d871a0c59e26fbde208b49add94ffebd6028725a0ac2e0e9df2b7a8d79c5cf0e67a5729ed2628b25eaff5e203c39ddacf9959226b36bd728156f3b5de9566deb990f80b878869be322e01b1131b3781da573d43c18c24cd73ad6ca6b0a34657b561f80d419e7495768eca28c5da928466c6808881b67345554f5913435dfaf2dcb8e9b9b476271cde5745af739c2caf52db65017c98dee553bc506d7c3e1ac1a66f71c3a9fb091d2e80a6b1bc5ca50ac5a262cdc1eb95f6b8d00b6f2e7bde0726cabe27df066808d565f7f9313a8879efcaa62efae0388d958623310ce92b00fc30db37999983473608f76f208c8467d8c5a16df0bbcb12a559b4ce555af854648a764dc51a803063f88e342070ec261d27b6d8234616a88475fce3bcd140b478dbd6715ac09390e2f695c9be9d3055c79beacd430c072086839f53866e1150dee8d50867fa8f97535a8e42223d12128f0384e1d3fe693dac3947b87214ed1e8901acb951e105e8275d224c3024929ebe61a155ff6a10e8636e4f46c5ae0a0412a4824dc8d819fc9566df5b824d2d9b38d43cffadbb31707a66ef4fda1f5f21595be12e46e6b3c53a5e49ee3889d6fbacd848a0f58f0e841890f6601c9ee8eba6e788a534e3d5b7d0a7464f8375d25c5aead02e8a8fe89190bc0e9a7ba5d940371ea7f5e64131404c0e7f959bd36186dc88d4cd021195206e16365c3e5b6f52aa0f474d1925ce5bf74ddb1fcf2a90d3b8eb05748e60ded1cb5245d96973f5cd3398f5cd283b636c529c9d5898c0890e6075634078f101eaf5169f7465876915ec18ca1f70016ff033c2509ec0f43bd915c032698d7fd70cbbfb788b9e56f2bf776945cf2d3c2eb56cc917ec5c06eb769e7664fc19c2707133d8d62d465fed576b00b778f215a64a32d8062f5139b0b07fddb2920ceea15880e61e3e99c4001c94cfb0f6d4d3cc4d573780678783efc2490201f4c95bab9498b45eec38baf83580a47879b7a074b0bd3bc13600be1b5b214c555d1407104ae01c3984abf6311c7bda7802567016924f52b5c93a25e42486329203f02836bd7ccf341e532ebe202bf8347c0fac2330a12e31db01885f249eb95f56cf6eabf7fa37b67fe5cd669686d8b91b7d3e60aeef1772bc48e3f79a02a1f172b2d6192186ab450543b3a3c8aed28d2b01866a2739c222b7a162554793a2d6dcf37d8cb54b1eeed0d1380d2630eac44dbd8d8726f9c11f9225fc28d84027a371b7e6de6fbc73f3e567e49f5018d6fe292ceebc55406668b10a162d8a82c31019e4524074857051f041c509e62a202f49cffff87f061c2212f106a6e093ae95f0f9b3509a1a0b21fbf47c2a9b0238928550ce0adfe0de323d0790beb5a500b2ffb2ef0e9a6f0d76e5118ac621ccf3d724dc2c7fc23e1e66e97f6b32192a61e950427465fe1fc69774debdbe4b1eb182cce306f1591124c3a21dae7942cd56713cc3a0c84f3b3150eadd9ff478faba554ca13760d3f87e4fba3af1b08616a871d6d2bea54b2df7526f47c5ff890da6cdf475294f8b25e5bb0e689a7de6aa12a5882afbd7d82b9b6a2bdb4fe92f176f4818a4e99fda4f9e0074e6df90a1d1302b9d8d078a46fb504e313c3131fbf521a7db9595473ccdf7d473532d7a91415faf88825320daa1e11017d8fc4739853f461db16e9fd67a2c42a89e4b939d654e49de8e1822904e3b0aaf25ab26ab5f55faf3d6c3aeecb187b41fc5fdc3359c69a918c5ec9e1afb017a77b8136444cefce5304f39b1cfc9f381c13b65e455c182cd1c1f969c09a92a8d09f1fa8aa9263597bcbc307a2b7251d814626d1ae0654777c3187564da0e83894382edc7bfe17001e4007fc778012f2f40b3e045b3185cb85e408e18a9016e58f9aab807369e766b1a25a4bc5c0a04987552727ac9ac5db9ad77c4f2d408507cd9f78f143298906e4a28faf950d913f088e6456164ab33ecbfec9b49af591574f08487e081391a77cee2bbe0db0bd69728006c428ad7ada596af1015072ee41ce4062347e4804acb3febe60b5ccceb0487bdd486f6a8d011b123dd6ef79b771517916e298dfe6e00d00f2e9880d38edc1fc54766dccfccc6eefed62aafb1fd68a3419716a25c14631ae367a50b84c9075fd20ce2d694b817a9f0c1d9e75f24fde8af6907e93ca52832068c0414d7867d6f65d94126ef9c1408226531345e606cc09a3e6e38317ff82871c7a9a4545883b362e879d487ed54fd96b3e80e89c84d1f3480ff189365c3547fb57a98d4d0036bf78f7362504685eea04d8a5af376685809eb2d30d65719b65d0fe3b579b859bfe371955cbd615fed05726eb3f53f10fb7c18f491eef3ff8d6d9d943aff516881b629b961d7a94819c0f4e30e5fc2d7a8c52d0bdbbc23f3ed1084735591706f7f6ceeb17c274c055afc5f86a055e9b729fbed1200f1cac9c82c21d6106205fb2739155dab5ce94e00a839a36b6a11ff2c485569aa17cc7c432898ec59e0774b3c5587529925c7234f01515642678f548b0b8c15a6271a548a88b610567d91e11b5ddc0705f6c0b59b560c5931ee8bec6e5a51c623f1f70802fc924fc303f06ea4c28575db0801da3eec356c77791ef046bca914ca13436dc84b949ae3fe1729585dc738f49a2b5d53d22bb52925ef5202240429cbb6ccbaf5c48e35ddec546954443f03b18706bf8de4f1a962f85ed50947faaa9a6435d4cf2d1a68bac7dbafbd2daeb0396b51cb7b9d683b301becc03586929e9ff33745b30b4d4a1ddde16567925a90ce9506277179be3f171746f2a4df4872a8132ee3e64cec28974b4fab93ac2da207e2a6fb233fabd6ba85ff89f1ba618b6be5a8040ac7710117655b9b9c78fcc01c56f64e30f7e50e3dfedd5cad51ecfb7ff2c48cd5aa0744de64ee5e9b8a1d835d1946646640a9edd43e5366882c435b70a36ebf836c7db654862b47e65daaab67e3de65160ed2de21cc0e9e1ad9730b9891584ea68347d59f770522c119dcc84804350883c9173a9bade0b9da3b65c59b4add996e70deff457373f2c8ef4ca6cc8f20a5b050edb6817d067e79f2b377f62bbdcf39009eaa7c1a7b230564624c8f03f574ce0898028ed229b921a2c613b531a57be39f92496a27f5d4dbe4a375eba24594d737b3cc50d1ad4d6fc90c21dafc3fbdc7941385727c09c7d70866690cdefcf2e3c5d6d48baf14a1b76d4147035bda200ef13974d35aefa346fa77645a50fdd942b03bfc2abdb430c05f54f4889a84b7a4bad8a77fde4981fc7805e8a10a483ecf249dbf5d730a12130bc82517d436dfe921b237e2ab58ba0c9b0fcc592d66c2f807198cbe4c8668fe49f11f74c9858a3646b80a1b93ae3b8880ea5ce49855dd385524a6d2cc031405f7856cef98164fae31fe2b395b1af651f83baf7ca03b2b309d425f139d12dfb6e54ce1be538733e7946b739d8de105c6794cadaf1e440a3395a124d9d8174a84e08f871c62b7458628ca2f31930906122e03932d6ee121338fb9c26e2211d214a36bc095a7def599d6727cbb9f3df6ed5dccca29d96d79c69c5dc32fbadfad908af3fc321b310c35308a0ef7bc36f434398bb8de81f2004e1a1602c6e8f9d1ed101b283ceb7ad011490a8cd50e3f97c4543e5dc30b320cf088646a03f1f1864fdb7d35ea57a362c132dc027663edd2924951f8735e3e99c84fab83db6f6abcdb90093b56c4fa9e4b38a3897fd23b2d34e40c38d376d3edbef3c1144cee57e6f4c0a96a3e8adecb6bf19ee59e664824a4f300711df87d6c89d0cf3c03ef32498b0e576305b509eca5d1d4ac298e882f9a2e2a1cd32c57301612f8a69ef1cc463e1e5a89e22c7533a870bf5583c908564f3e7bdbfb636b2becf5539e3be31906316eb542243263e7d492f38a6d95db14d73020b6d5429a6119d8346c68595feecf19f47c4c27c4ec0bf1b0288fdf15dcc0e21b6215d9dcc368ed5bb7d7c02a1e60a6ea709b1a0c3f11e6b995a487cbf558dc0559155e713449115abffc48da9e084a8c1c0f5d8f0104fb6ca3e9d2c5e3d12b89c7e28cc64989bc608edc9acdb6abec06196bfb8fd55a529f21da93e0de3371fc8126b81725ef10c0cfe14aa599911b0c3d943dd154b75175619d3474d0cd138f5f124aaf7241fc61559997eab1e7e31c9eceb6f29c9829b8148942799339e79fc43deba04f99a67bfbac6c95a0a3131a6fef9f9d901109881ba484bd50533312685dc4a4bf6d4066abdecde94760339e924801f61dd97e9f9b9aeaa43e405a0811ddea8c9b5bd88302a340a3664a257d8578551e8c55fd4133810e92addce86e022d01f0ce5aa3958ec5edc0f3940e306d77e75bff24e4f1d5f16d875bea6d53e9c6b579f313b418498a6712087d37d82eadbb234dfebe85dee58c177014597288b523652869d9dbc95c2e97b1a9dbc1e2b60d3c70f25414f9eb0d5f7ad2fa12323288b680a9b38276e678bf37dda4a390059c7899fc630dd6da0c6aee6f06e7df39299462a8eb8e9030a93ec55b374a630bd833ec54ad2b859dafdb35fbaedfe0d7794b2c2faf6e1d242cfd36ef0c13203b86fb8a3d93d9ac4c70e8aa05ed8098b1219dd307a4161e0c651db7c4fe3c8be9ac985ac5211b77463ebcde893eb5fb94d200b7ce77d2a4aa71acb70368b2ede507c3f86a545ff9c3479eeec68d9a8406df1133a680f784f8734feae4877223933acec2f046741226550bc61ca32f9241fb34817c86f38be30a4f323cd048aee96e4fcad842727a951da9e1000d705fcad190458118481195bc6f5aaf8f65d97c0dcd2127cc13dfbfedc73c8c3be0ef53d6590b501643bd24390ddc9f4f7de8adb56e83f8142f317b77c3733191136776a2af1b325e7637c1b73b7b18045b3c198689825496f21722a1fd71b2063f570557f118f896fc9facf175ba15d4c1fd6ef25b8abc2aa460fd0516b020477d3aac301079f37e91a55006358d9679aa07e6fcc15b080f982508f72f42a6c83ad76cf1cc939df9eb54931bf1bf77b641dfdf69b884061e1f16876ab586a4945d6ee317cfeb86a95090264c5a40da9d0094256ac8f52f0dfee5a07c7682928e12a727403ff126fb83718f2436f653b6a35a26b57648cf8b532df561674594c92dbf96020e96dedc5deb8715dc2d16ce65424f915dbe841249f5d15b8f9a4a6c23da6c73f6359ac6ed8e78bfbc9d3ba833d8503ddf080cbeb68cac99ee06f46c3ddd76721ebd3c5ab5a7f0a03dac74158f7d89d1097f79c947d5474a0234fa75e61e9c63994c9a17847c507fc8e5355fe3254ba7ed22f22d928883948c68a4dde029b6c8caf2b6672e96a6d7530f290905bb3528ba1f3071f77ced88fdc538332b045189e50b1506471dbe83cc7d50d5f2cbb4b5fa43ffc84194a57ea3076cfacc52e84e41d1db76bee46f743810b27dc4d3910ab5ded9053a0160e00c1506360ccdbfdf7522376c9a4a9b96cecbdffd80a969455bbbe9103d11571794318a03a29a531814069a01d40b1260cc9934c8c5e40acb06fc6cb5b43ee80e68beaea2747c7de8ff7c55e87f943e248509db934580be86754def76a519eb0f48bbdd1f3d16db5c45ed7a67c97053284b27576666a7be7ae0cf0cc523632dfa5f598b3d887334711ab298b152f919af16fbb67cb18db17f815cfbea8a63cfce5845938ead057ba28b3108065f13061d2f6204761164c865ec98bb8486f4799fdddf630399250f3231cdfa4cc7db92610066c506f6a6de6486189730465e9fc9da849a3e49d53ac32ef6b067e19f11e3d1ce45696c53033447f1b3ab85442bf3b147ad1b095765aa5a511ad8d8b2b2a7254f9099b6695b88ab0f22a97543bd3e33de3012e87e5482489ba91f761566462d19513865a378f76b061eb75f62aeeb26b1d54b8d569ac95f3cccf324828b6998c86ef37bdbe0d421bb4708036626861fc02ee2a68c320335fd10fc398fe9b42d7d95c4e4daf6a0ca83722fc61e9919c600e8cfbd012c99b561dd024e42e64b437e8b6a124b9d42d29a448219926b741f9801b25fbaad3fe2862527c9e1da1988d3ad4a4795b3fa4edd7b09e880862c3a9b143b5ed11c927e91555ebf5d8d174fdd37c0320dc9887fd6aa030dfe18c6562e733386e308c0d2f0c5e68ef35cd4aae03cf6f49290659f27fd15ddf75a1703b9a2ede125ceeec6bd142ab7bf33338f1215d6ebefff9a7a1bf9ec8d5fd9fd79e8280f6eda8ced1f5cd889b7f2199eb135f39fc5424e076e0cb3aa7e107eb389daae138a53ce6cbf64ef3b75291c2de8423103164da2870c89fd6aa099da296f160c42748c51634732f93a5b933712666e95d710530fbb9ad8edcb6f66a15d92bcdf9723c395f9464234cdb8c1c7a6567032b34d7ceecc6039e682b94f8922082017eef98e11768f0348727a0d3045008e0727b1584a6441bd26bbe5e47a56e60dc6a3fabb3a144f2d91fd742c5ad3585acb5d0c1de724e9ffc7d0099e17650f336189c787bf5008641eddcc333e042e141efa03361b050fb841dee55bfe3c4b9925ee101986e9b0d88053838b68c1b64e457c41443d4d8b5cd08742df5568bf3ba485e574d1e80177a1ddeee0eb06e4d0253a792733d4d1e9b0e3785a5784cf875c440eeae20ad4ad6af23a89bc4d60ba7895a18b722554dac08e8dccc41db7c27f3b520a53b24911cf4f695aa0858e6e4624c9be78ecaf91ee801d573c026e96cb47f6d8850f5c242032c580a5f6ba28de17327eed4b1c4fe72f88dd374f02a37ff4319965da22ae0c428a6848f44d460f189d27cc4ae7ceda2a94377748f5b23d8476e15815f76b54ee998d47b2d298ec7527f19a2d35bc6e0b2fbba9ec57cf365f284ec4702bd64b95741896a266d373906fa4aabc1b77e2493751d1aa029e1026cb1d26ea475ba04e992439f1a2eead580a8ebc0829c9330fb88df34f81f3809d6243b6c87327f92d2b6669b57301a014af6de592fb6ed25b9704f2af9bfd1cdcaafd778a4f3efd7c2d4f964776ef33a134997a3286240b924bfdd35f1d440f1f9ba8f19c3ad4a8d7b6f2aacb19f694968e7f595d3d13465bac58d5cc2f2f1284122b3fc66bff619b07dc968a3b917b54402156c0f0ee500a80ae275f6d6f20ffff2b2192c114024c5258df5ca5232dba44b45346616b3165de29dd2aaec9e42456456847588c94f596f9974b578285b2a600413ae842804fce79b1769282c45b9b392ac7d91e503c901d44c8a27b009e8d6b4e2438641c523aec6931cf68f789f7906e656dc2403a09eee636b7b86e6e4ecb1499806ee34b7a58517c6c80b019ad24fa8828ea29e4138afcb8e31e4f5d3be345e7be6c845e47c2c00b37f418512d9faf77ed1df12719a78a8cce7e8d54fdab66e08b3b47054884e0fa1dc01aa74c0ca4d122a4207bef37610b9fd4a7d429b56db47246aca61c306accae7412fa80f56256e90a4b636ec82a1034ed568371e0b21629da06a15edabdfdd02e5644db993b7744bd9aed1034cbb5d8bc802cd54e995a555dd07b135e89c4b6e3d2c0f9896d70e1c98a05b8346625c5224a410a82d01e88a7f92fdf5dc5627b473e58979c72bdba2a30676e29669bb56475888495869dce177b04f4ff975084cc32d2edccc53892237f8e0dd01dbfd6a301b67548361a14a1c6c25012e583a5af63617901cea0dfc3f12695426510dd0823d7217df311c9551d90f20101bc9afcc4b758fc4a74d59e4b158abc45284b97361448d4fabbdacfc85ed4609999903e320336f2b2e3816d80fdbd3563cd991805e18ab4a32c0c46b9e3f36b38469fc6fe48413bbfcdcd89924730445d640c32933f7dbac983fc06ddbc62c2c6f636d25d34ee6dfb472959182df757904294effdce4a475284a62c2913191787e9302462f57ac862e55ba65d5178958a1a20dc53b2c52a68d06da5d9602cc168ab5298dd351e8e30b18263787625f2f19ce4088c79f3c2f92ea60c50f1d4cb7ae7fd74c79db9e3fec1243c354862408cae6fda9c860d2558b0c661db45aa914935a26c7d6aa1a699cc1183100d46dfab626ca4f3c3af309561b1b3c299af9cbbcca48c1b3ae1ddc7b644e051ac8416bae5b5fc7b29c8b4f8cd3247d38d814b5271401bc28184fa16547880e1788af61b57b0dd311b68c948c428fefe466674d1b7654993937d10e43f5141ae9dea5f37740472ef051a8039ad127fc2ce02106b2e5331033908055a8edf02a2b5cd2c7fed32e799c6a3b404ff3b358349942752f3afc89f70e3aa0bdcf16133ecbdb7df13f22494e55a10e4bb3e9a2a36db260ba5b0f8d506dbc13b0937f027eebd08c13b8f5def387a4a7fb8e1ea56fbe6ff7c1ccb588f88d1ee24313df2660f948cceee847eefc7a8aad4b0ac3466af1d5da9f7dc43f3889d8a809c5e4765e3f7537a86ff05fafdfd0493d9ce3b5b56f8c5fff9764f26cc75e84a245c0427815c462ca366e79abb76a9ee2cae16ddad0192c5fa0d939c417ef2c82f43f454751bacf3cc4a00bd25e0502a48d7578ffe1d6761bd5d4b321f21f94f2572e7e72b402d8932189809a93f2e91286e8a20587697147c4f95f1542ef74b39c559455db83a6774c11c7638469932d417d84ee5cb024543e15665197e4394f5f8054c0b9d6121421729725b0a2b3500775b47364ded5de26a7113e3c75b253f7aeff5207282c66dc2bd0c9cc0bc6a18f8d88715bfae2c1bd130774400835c72e1885053fe1567b5995986f0cf1320da69814c5552c585d8ee37cee4ded8d1d646345c93b38f11a0cc2e3f1f5d6dca0fafa6f30001c3e55584b4f0e4a21f8b66d27dbc279af35d70dc150af6026d706843d3ac6e1006c16b0bde32e42520474f0461ee05eec3007c1dd189589b794eee2d8521d84e9598efd3c7bd3b49059287ea9db64b8ee466151276ae65bd3384ebf317a971c642ab47e29d78dd9973f0b1dd3f6eaeddf04bf352dbd279fbc83f5932261dfdbc6ded57aaef1c0edc17df468fc1cd8350dabcf289a6d79d9a683cf9c1549967353ad2064a584b7224ae4b2f3f461656f16118304d36dd0c443fa2bfa18b2d7a2c877f92b1b003f7c3d3a563ee08cc7637042a7754630fc60b3c072d148edbee1574836983388be7d77fd824c9fd485c4a7ad7f4c79cb687778ea55b59b33e0886b5fa5f987ca68407f7fe7d5ae5205f2f0f2b0ed36631bb2409b21a54e95ee3e0d0939d3c4fec8372f48da432bc39e2d9128ec516e9afce2a0fc22a32549fa1c0618b8d2cb3793c13bd94cc1c03d770e994edd186f14bcec256b8c2d9432d2370405712bd7b4ceba29959b864ee64a3bfd116ee2fdb1384d3bc4a7cd318cd05c6da6a28494575cc18973d25ced3b06dc69dec4fad9b0885e8a554783b4331ffbcbe3075c7c206272eeec7a8d00df465a3282c01a1a7306a9b5964457b94e4ab6a1089764b577a590868912f898c47773a2e3a244df2d02439ecd935c8cf299016fae54f088558c1cc38ca290662bb60f5f94e93bee59cfb6b9197f7d3d06a89e44619f37cbc4ad62e8c91113822373d777bfe9b2f8ba19ff170cc2545c83e40486c374f1816685d6ed19589fa079f22e722848a51fb3717761940c4e5107c5a8065c626ba97d8bc8364c7cbba7c11f8906feddb0ca8f9961130e4e7c9e64834b47b18da54b82f22272c9c058a8c6a292b6737149c413b84c2a91dca8b6d82cb4f1b98a6145762bd606d84affa8faad71a4abffd99b6f7fa5f15d6a17b9633206720959a519d96d3e622ddac96d7dabd8d096c68839c8140cfc1494558e47e2c25513c036f03c436c312cfa7b7edcf853809899061faa1fb9670f0bb87f3f0715ab7036b0aed25a564261ef7466b1dc5a9a9da9aeca18249a26f98f39425e65e9367a7f5a28724ac02420726d8e07e6e389b550598d16b69d8bd64d143511773021cdec00683d0075f6747e01bfd8830720268d1774af4e85e9eae8d3e34fdcd554c59793b2178696484f42244051a8abe8c7630a70428c18479c45ab3d10fd97af0a325ba9a82f601007c03277fcc8ee3a585277b313d0e0ad38d52ae5d81c94c3ad3ef4f815757dd5ee109cb8d39422e9e3d3ba151ef43a0c0ef01835e7ead3fd167f88f267c206371908bb1c8451f9dc6c01e95b02ee1cf540fa92e996647de72c3a8f7e3d6fe5175e3a511182dc8c073937cba6d45d90c05afecc68c0cb4b44624fceb77275d3ad5c77a0124315040c63226b71996a61028c6dfe434d29de74522c0acefb2ac3a8bdb425ce8e9a8d45654e9895fbc0f9b7b22c624efeaed818dfa240ab9d4ce5526b6ab5ff2e4aa4f66738c4e7651902317ff473fff6a4995221dc89377305a13ecfce7d93dafeff681c59b6329d850b36e488a07037031026fdfca4e9425b10f9f74f5d220c1d0a8fb009eb9a9f8ecf7cabfd4f534e6bd0b8f1038264403f483d713f6a0a842cb038b5971a135c811ad7819e132d491596f0ad7b83d4d82e53eb84afd694ffda5bd0e26865f278c2f8a178fe6ce0722625966cc60a622a80e3fabc1f59e97733737311e31f74fcc7b6cb1fab4b9acb5c44e2b95cae53658fdc7f05f30fddb44b431acc69ba55964481a84e0d6bb28e31decc37da625a7b70b8e27bcd20ae5d40b1f2d3cf0bfbd9941f3f0f367bb39c2adbee4c5337a498169948642fdc11247d3e8388dee4e797e39ae0be8f9ef0ac70da3a84d14f13b47eb58ddaa7422c44240841b5a7fbb65fb02dd8086ed1fa7e27b5bd93e9874bbf28c8fd74359083e7420a3b73c761f7697598c4357a230525ca0a5de9780d3684105b92fc83b673f407bac031c7fc42fa4c365ca10f4cdd8979b47f74a95bde838a86a9710b6e6a57294071104ee5bdcdc99de401139ef46a2b1d3faadc7d90574435681cd092c1b1fb064b0cfb7fbfa68d139e152afc83ce8ab66b68576226ad6fc88fc7643d33d92409f7ee0ecc2f9b03d897d663c2f7ef332cc9d2876edac2b38728678101369ccad013572cbc07f0fca56df30bc2c42de906dc3a82970bf06ff2e64d911da0dc0b0b145c0cf98ba4e66d682c7d01f9d93e58f5fe66963253951969afb417e7d75cf70f199cfc3909e1dffdc56cc3c44912f12630b2a086e20b266ff9f3a83c1dbfd642eacf43e4d286d3228e84a8b2a0b2742f8dd73ac7a0538ea590e417c78d98e8e0c3375ab3410f2315c9809b7b74bc17452d25d6352a98c5e4aaeb3af0ebee44c788dbf526888f88602dac4b9094845f825716b70ea156c2b6856b6ebf89ff9fb3bb868c208156ac34291f269ea6eeb23ba01662e88a0043ac8f2d4144c8444bfe1e900fcdf2d4993109a200af20cb94485e949c8e4ba04eabf13f2394e756b1cd1986de9daff7ce9e72703d54156058eb9c9ae391b39dff458e376b3391bb9e5577943436280c385179879ed2e552471989c5db8902ba6850ac50da69224243d261b020722a207f269ae6fcfeb86c788ecd13733b0f718be9387fcda5f843adeb1692d4a440e25ebb85258ee0ad961ecb1600c3601adb04d8c16fb1bcb9e378b30a6ab4acf116640293b40f697b9967bca9a7b52406dca3bf4dae3bf7d08b6a396d24c14ca90116e05b5dce0bc1521092bfa313e478a600844a38417700716938b4cbec4040f6e72d8226f1958cbd2a3fe95c4fb3c16290fb7e94aff5e41f3d4db120ee41ed84d57ea07817eef978fd2ca970173b7e943e383c67dbfbfaa1c14356f4c4058e6857a83c11244824d445231e10a5b39ef7ab5f95cef7204c1c6f3b6b37d9a23a17bc5ec39af39073b2a1b247e36052340c5055eff6ca4fc64b2034ccb5ba08ebab3b911e66e70afa6ffeed8cc0c921bbe0b7aa08761d4269c7902af785a15d172d2133cf253f1d3631ab0f579d9b7ad59d3663ec04de51c674c1e760311fe620888977878e20b7c75adfa9da25caf04a1b513a5257a2505b62db6a949aa15469e1bd0411c2bbbc8119224c7283277fdb7144595ddc5e74103b8475c400985a2aba084b3e0683ec9e4f37ab8e71f202b875af901262902968a29decf243302f93679e42e4e7a8f96d3f20095f1086896ac5c06924626db3183c9402a0b2d7e6e660c5473f5163a14200a40fc279c19a3c1860ca88afc387eef7db484595da6f7efdb0b856bd1866e976a45d2b5388fc5e0ca453815e98b62d1e45a2341e48adfff215d7822519714005eb9ddda4409fc70593f850762e327eb13377f543e02b6bc677f77be2928793323c9835b9814121e3d0005e8aa6220f0cba829f6a0cfd064c063edc314b8dcdf753766156cfd9872a725d29b597a9e22c08bc426891448e0e5447fb41c6c3f483651b775e160ba4cfb7727cfaa94f1f1273561455da932f00c941f51107a2c4212c1f54112fbd3b0635cf5852f304c5b7bb38a9bad0891f6ee36ff60589d2f9c693f5eac9ed06c226c2a0ca5a113f2984daf157f40a25134e1f70252e95afcfdc6a80d06dbc9ad41e6359fb87659c62ff156ed7ca4107083b971587d617e09ef92862c5c427f62c4efcbb7124dce7edd4fc00133a12bf3e0e00bdcd5f2a335320594ea852532b440b373d90223becca2ff434bc791027e54446c6fb23a29fe750bb2b7baa2a821f85ef8d517d0089f8d6d74da49afdb44fb4b7d32e383fa3f6146979d30e84dc218c4e5f473911836fb303f24fac9a7aac0346e2a0a121b70cf7ec01783913c48b3d6e610bda73a4f7f6ffa0952a9592b5f36af14667b2c17e056d8fd92b022ee9676f217eb2beb7d2d8c6b276b35142a9df547a817d9f135695b991e29e8ad4e2643d89a238492dd8376f1b2c17121009b573c27101789d22cd666e0671f726bd5e27cdebae765f99a8e5801d3618fb528e7a2bdebcd1e7dc1104dd54e16e4e7c4ac7a6e0ed0433943ddb8e03b23b5961b7af8e95ffab0e640631f25ef5976b46b390e51b0c7d08d36d19fbdf39a035b927ea3a6c1610bc31fe3e00c7e359043917fd8566336149f52558a963479134d5320fd79725901a0df73412c997a1b346c30e4a9b517f72cee1d838a09b21733bb9914c5f89d07092ff9ad92d0a4931cc42051a2f8c7181078874fe36c244706da4b590019c7cc1cc97429710dce02692931a5085a56035dc23d338eb886724bfc0efbb609650626f92d15071c79fb74dd9a357bfabd61ca73060fff4b99d5ce97fa4d0d2a0a559bd14e4641d2e1f9ddad3041f2d607bf9fa65a8ce4ab76e156a704b8bf594177fde10fde00934eaef2bf1f2c2cc660d5b6940628ca4563d73544f9b793038da0994f9b9cc794e71baba68cd0e89755091f0feb00fa5326080a28bf00e96dde18b2e7130a4f9fbd77a9819db370d402be08a8b7d67fa4a69d1fe1b2cdd4cabafb7e4898ccae4e2428b20b14531cb27af253e1fd6d0969eb8e176ba50e2f19f5ba7d499503a9b3379ab3f70f179c5463707201e6f7ff4b16c7eb2af0f9e7e586c617203047919b7203fb9400b290c7901b8e5ab65cadab28fb75ddc2c5bd15a3dd75487dd7079f880149f68a1482f3946ed62bdf53285e4aef45094e34a862374efc42a58e04db68e711989f4d5c7af952342930e6cffbaf8c95d00548489f056e0846ee417a9035035c92995e5f28a24454d13c44c842713293e3a671d1d2b6e55959fe9659aa14a0d989bd9470e6a21ab52aed684f41b5b6d2e0752f1e3d9e37bd4bc52602d912746f9686fa487b1c4ffebd0d38ab0012e7053711dfa1ee9791da5ea950b4c01a7c2e52b2e259216b56b5c996f62a2ccb45487673929013c5654dbdd0b98f7977ccbfa5febda65b1746a9006873abba279359c44592800003c20efdf107d034c6a99880d03fe7758da18b40303ac222a18315bd195cf4b7875216f36a3242d342b4fbf04cf769f56156831cc34d2ae8a8350d59d7290c338f8847c0e89fdea163d2a73ad67dcd7341b822ce717a3f570d72d61ad5f10a7c41131ee02a8e67165d1539b370f7514259601effd664d42da02929dab7fcb8084a2868813be2c45f8e82a3dda22e122a57c4779bbde56e95bdebf69447d2deff73b8b03fd8508f84d3abda916e33b57648c05b8cb64bd800e6fcda89f6e74929e96698193f9adcbb9618b4af2066c40577f7fc4b65952b7f6a5d513a8fe31659c694106a06b23426493836181212c6bd1b267022cdee485240fc385d67c5e0d0e54f2651bda4d258042e3a22324cfed6bbadbf668c7a3ce7357ee77ba08d311362b262e442c39d880d76346b26285a406b4a4a1e30289261987837343dfb49877479dda06bab6ea9757491a1ef5ff73a63784e78144c870fb269166d7bfca2326d8e70b7fb9d1f823dcdf4e81f335a01a1f30d314ac88537e36e6abc555e4983f4f945203ea0aa5424a74594d905bf4174058d2eb10270cc821f37852514968644ea7173b18459211d80f7c58d1cfe52b9e1271a0fc92c482b194d59313e38df97fc002326dfa3975322a1cf670c023b75724bab2c925b39f010be4a5b93a164110d85292c6c46f3a2973e8de1163b3af6a9a9ad9d9abf4469d588daf75d46573ebb4daaa0c1ba1507db9038abee536a0a56422aadb8a1f6f27362d594a47652837bc5ec7ae7e503d242ee36541e013836add67d1900fdd242b78bdcb8bf511438c9cd6435c4abdf93d5eeee00e9018a0812fe1f08e13c5e6fbcfab63a58c7b6ccbaa184d315c0c44db4fcc8a7b066a035210e30d988d5d80e57b80629da6aace6acfae854ecb554734c52e0dfe6882beb8ba83f7df81bd0bec17a3c504b247fcce47db6d68b0726b8815235912efc884a798f3edb726a645f7e844a65872126afa8b79ef82dd8e3e89eb2b687df878af9ec48287a280eea95f2b3d5a6aac70a882720aaf6d3a7c1471bc6655ebd82ea03a03cc4aca72cf8d920243c61e32c1da3adf9a48cf8dc615d5026fe5fd6b0f411dbf8824ce99ce070b709ca2aeeb36a2d2445b014984ff42add5e383f300ff2a044c0159cd551f7b69ddffebf48e6e6b57419975c5661132ce538ae762b344ef7c8e942f1e04d6a01541446ee2e56af83dd6bdd4c1e143c8ff89acef6db0d19c2933d775dd99f36c58262a398d3ac6e3d93084316f2e9ac86dfd43323ea1cdcc6d57258134a48a633d9f1c699738c4eed1dcb4b7768c1f83dfa3cafb84f473ccd0852921863d22eeedf618f135151737b621d2eec4533b7c1ee4dcbafd930ee059bfc6c8f77b563751692a1024bdf47098998d2344a9519cd6cb41a3c899a1ca3d59597f0556f493bc78545095bb466c590c3adef423f268737e3e7d1d205ec341bdbb4f701555077339e416c23718ab8ffb0bc9d7ce331f9c0f5efdd4f3050a2bd37b21398d2137980b66cdea3b179795e8ea26dd4af091f5552dae26422224e1e650458734cfc90656ab307f7fbfbb8a8f553bd927f18","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
