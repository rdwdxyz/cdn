<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"50075bf5fa56d8b3352344bb542c7d971db61f0d215153f2c3b46dfe409598ced0baca142dfd12ce3d796b7c641bc6865353160394c4252061a337ae44a2deb2b0fac84e0c9f675dbdc50975b70b30bafebe89d39591f60ce9e45f812b8ff41af601f1bd12f845428a30d089c6235a7649e95b354c09f6fe1d7c29fdcea54b5f4f24dc2c487cb6312cb770e35515786bf1efc32511918362e30f395e0adb0bb9c005bf7fa88c5e097c3b428f66314b71325b4eed363506cd4f918b9407d76adad8b84e517d73e740d25246450aaae0e10af7108d6985d317f1003f663bdb937690efb0b24b90e563bbf6ca8332084a9dd2f84c25ad21d0825981f6d031b589d3792d7bff1b6370db11c67b8db8bf6559afe6cb481ef45a65e70888460a56b9f5e95619f08ab7a35af2a3c7d6c259f789ab07796a9cbd496c1f99a9a9c2403637c8e77d721f8da7e9fbe8d81088d99683d4444cc864f57d783b2486066061470181a45a3d73b9640aefdf9ad6f6f1e52a93ddca1173a7e07d9b5fee84c1f4c27d0cd263993669b39b961727c70b91829ec9da8e3d837ab1e2d1d7051c37eb02a725c434277e36fe699d4b407946507a9cb6f69c2bc0e7ddcd1fcf60088a9b6d879b17413945c1db0b77134de5beab7444d4e52e161fe4fb361cefb933cac2a8265e7638b75f4b31e6a3c21438010e8eae33e91ef8df5972c82b7a662df130d461134368f2e6decdde24af4faf4a05d2b9e167486a722b359115946f2c56630eb3d20c3be21198e84fd9344a37f4c408d9aaf4addf76ab32893634724a77ff56aac4d9479b47d60801ff26dbffc4233feb014f093c57abc978461797f63224b4a34261c358ff1c91983636b3ea57015865a9f5149bec0308d17e6157b5d4f00f90dee1acfb7e259ad21b4e030fcd4238eda5f31386b1e5826283d528e57c6a894885592b3f4a24ee7a72f8e6f5c79075dd71f6f09101fc36f1dc853b2b7e2c5c283312f77c4d8fc8d0285047c3e1e6404f32b95bd64d340ebcc651a6033d68596cd1e20de43743463cc4288bf340f3c52d22f039ddcb9e3dec444523a4b5d5c83b6b22c5dad5332fc588c634e5e8274a371a5ed5bd48b7b2c9f84cc549745cfe74703679cf462b042ba4288214f61af047be635877debfff13a7dd1b117eb6cb01a4176f9d9815d5ae26a128c736418a07d0c94f76c2e67f2e14c2c4e8719bfdbc8bf1fc4b30288b97d598429e819aea4dddd368ffcfc009dab3575110f2056c58995121019dae807ae5f8bc6f9a44976683b4cbf7d9595f1dba3e83e12bd46006ffa907696cb23a0533b346a93b17f4f249a8e81b34bc9b2bb5215d3a4b5b43223bc963d2b70ff083c091dbfb2b34fbcbadde6e3100d69a8279d3dd15af1448352a67df235de03e0db4138dd87fb9a4e4b686649537dfde3629cf54e66dbbb5c29bc6742ff0c8ab30b4d8e1b14a758a88b6f8311e5fae752baeaf911751587263ae60d1833f82868c6c39bd3ef15ece23c0d977c7e6b233f36f1b9d22412d570b4c06678e3b5c72b6a5f7466b68b9e23d7deaac3b48faa9a758f57ffd3cb07230414e8e4a24ae78a8252e830d08b8040655bb62c04db0f663abe898a871ae3f00211b1a7492705c03e9d3842902d212da613717e4bf67afea1d1acd92675fa87f2a2bf2a1a320d0b19a637729d56afead6518a42e4d2ac2e7b5abe0e8622f6068a3c892b783144d97dd5a1bf2a88e23b414918a485197cfa3cc8c66c2742398362446dcc1b5a29a16eb844b232441d15a115bb072ad2052276430892b5beaa6b30ea84017223ad76a7db959bfaad9402c089e9ce51af7ea325837c72b2004144cd287a8fa9eb78387e5e02bfd9ac9724c13e96eeb67c145e80157dede6c6efa467e251365e0818288f26e0d4926941df3bb8f4f70f55915777465b4337b9dc4a4672f16fd0060e7b664a029c3a937997fb1be0c2467c42b061ce96052d038108d43d9f23c64e2dcf623137bd55de2356bb4e00d2557da423c21ae34f1b3431dab41a711de0ad65ccbe79ea1a21429e2e824ea044f0ce223d498cf9135b32dde737142cfef25bb5422ec4f6ec082b8fded231af39dcb615d99b0aa71bbe2497f6d3a016a2c3c270f24925ed7025ff16bc009b5f76018282be00eb999bd949fb7d70a7510032fc962513eacd832c890681a2169d820c96d24fa83c165952aba009e6743ebcaa5130f0f5d78af2d3aec2e51d75814b34d2dbdee7522ce0f6a40220266fce580fa6e47ab0ceaeaec95f8b86a3b637de2e4312a54ac02200cf357d534ef715eec3a93ea8ff9792d0b6b293c0cbf254342b6c96892fe9299d43c4eac2c6d130be5d063af8ab52b2c22c632d1985877cfa18bf225a15b06015ad56868337c7d96dd6496cba762d585214284bce57cb5a1d0e20ecb21d86c829b8a0e48c38974990772b48ce64255f5a04cfb80b07fe3c990ec43df1b304f16859a6e790c20dc937d9c131a387d0ee8727ce5e9b1d0bafd694a602283867dd6b6b8db81e9c81dcc119d9b7cd4b1bed5330fbb7bdee129330de57be0e2531e7278da674d3190efa1dc732afc5830f12e3733c24b7975f6a039eb6ae17e9052b4e32e7a2efd18454223c2ffb2448f69051474436bb2c27a0be163c6b3b3888c473772bc32acfafe82309f5fd4c01883e92f860dea8bf00f9e017ef45cded8d21b19e5f2f44db5e8e19d9466f5c311c89d51480ab08692899ceb86971c5753efdab29d5acc1b39eefba48378d9d3fc12db4e3416091dafdd2f5aea74ac3db5fcda3dc808b22b276eb0bbb65ab013ac9f0bf4d85ebc674ec27e75d1e8957162367c687cc5f3f82774887d362120345dafe2b09947b1f007abf4ab1f19bb59c628325de5ba96f97ab7080aa70bb482d3048b46ef7e4f2791e579226e579bafe79b74c61e7d6162c6fafe71f31dd3e9a8fc4ad854956f6bf8ba503cb7b82c9df854cdcfcb5e3e0de1cb87480f776b48237f068869e484f795ed6b8c7fe176df7d563c122e3e0da50ca7f945da84e13bf44159783c2813e64d87f7c289bfbef0e15bd55b2ea90717308ff334094082ad489ea1e51cebca695803ec2aa62782589adf5cdf814d2b0aef7860de0b911fa8067d34067509e1e9c5692f2362d6c35751646914770c84a15691255e7f71bdba2658fd6c3f0c0603d5d2607409f1555fd0c9b3543926d9c2c25668a868263bdc0862f4fef7031c206aebea4051cb20b495664e444bae0ccd21c4d7a7381c5e035c5d314b003080373db38a17f8eb124600314fad7e4d5b5de3d1aa74b2eacdccc19deb3dd568fd4566e1a5ee3eabda8278ef41b8128b6f8e828f51e12e0a3a83340c4495b24831c71cada15a64afce1bc3e74c57d7cb7074d2bca6fa746ec2edad1720a3c486ff38dabe39728b76f790a08f174a9ac6ea67f8c6c2ebc42064021bbf4d5174c0f30904b91d50d56fa86efad34e19944ded7558a5c243fc8c0685a5f64d725cf0c66af89108690a85bf17e7ede9ada36fdec003626900a4bb41b57b2257c6f920f2412a4a840a1350ba349deb5b28cbc5e52901f5933b3089a16f62a33676756ede3a5d40012c7d17827a6e28c7f132e7656fb342a72ea2250b653e0663a8151362fdc1f892d3fa5eb0a47eda5b5337b7cf43856dd439bc495278277b43f43bc65bd2b2e3be1027974c04277826d0bf4a5a8f04832ff846a375c6d0da5e81ddecfe1bbf8418ea2baff240f97eab03c61e1b870c609273c981885d1f6dee93c12717b8000646eb3c34969687ad7f9fa9b9d6b2abf64816084a7856fa93127ffb516488dcddf6c58b53de386298a90c5d45215603fb659a92286fc92660cbb25d8cb806be914511dd107a193b5818556519cadf5b1179f85411a687b9c0d6519177d9e48ae205c0cfb0bd4634c2032e64d7c35adfb6fe0487f8ab33068ee2073519dd0eecb7315240231bd7737ca17eb6a7c002728900f1130c96c7b1453f478f8250a2fbddeebecbfbd41f44f7357594a5c676829ed1aa53d34f8375674e46c1774ff3763b068749d5699ac149bb0ebe6349546339d738a61becd93d55c3023cb9c8d197de0fc54befd2d8363db8820ec7bea626e0e4b216be524e3477c29cc9e2ff905b3cc43be4cab25299b25b1c1e67e9351ae336ae7231825f5296605797bf1a8bfb99dd919e27bfaa6d0ca63e72423b4b38a0a71b01e09ee7815d43b20c8b413e7aa823e60ace53685c78f67b5ff815e7ea4608d6b193f923ebf6861a2c4b3ba8aef5dc9186e19ebb456df96d62e5b4fed5b22b77b78ab92badf2aff7c385bd99754af7393af090b5c086bf9a29a6362b56d816d631390539bdd386f14dbd8ffb3a6c63676072324b066ba3afd5ff6cbd32be26499be2e6b557311fbfcfdb66d8b10af66a5bd4fb20c4256c6e6ae129d81c588e665e56c8227794c662b9625ee2dc0b3a2002a84cfcfe7a1991cb81bed407436d2e8c704feaf1cc1cbaada98790ae4dc556d105fcfc3eac197f87ffc2018ccc52b3dacae69aae642508af67a32806c880dd43451367d3a01bb1774c1ddd4d7d928a08cd13c050d05cf7d96a14fc1a5318f5753ff062fd1417b453bdeaa11ecbc288c5141173b741cd0915d5fc3e4e68f3ab215e9c5bc1259b66b6e1c72b22f92786c37d0da530edef6537eeeda5d2579c60c40cce3794ad678cb6281e824d1454ff7d57e7b03a669062210f417c19f97b7c41736133a2df84be8659da0f2aeb4efa300de89ae6713b6731de9f1381a3f46554b670df345e260bae381c56ab8bed2e15acb5fb053c9ff568822d8cdf167135f2d53390d9b9696962678d2c6815a2177eb5364f4c7e88105db11835b93434dce984bb548558fcbad3944f6ee92bc61e9c4b387cff3e963305dae4301a3e84393292dc6066ba2b16976e013b22331e962fe2f2302745a33b9109f964860c275a833acf405f8b860ff2da0be274be7e6787841d6b0eeb3aab40327e9c92a4336529361c7f4b66fd316cbe465be8d81cb28bb3682d147bd032b6de81b98703173c71b2946f3527bf78b2a7fc275d60e1aab65a9822a772c398307759d81db182584a9db47b0a88b931d67b4cf085c1b712381f0c8593953ff10459f9ed4fab51c264f2ca902069b8656582c5b11901848cd65833d4b85f6ed4cbf4957fd69afa0902d99a0653fd03d9065bfd7f603618244e76d1575abb12216a97d6a308b0773b4588c856607e61fe2b736d1133b74e3ea83c9550ed1bab283ed5ce996b3a48b6da821284cdafed9f0d36ed46af14bc46dbcaf227d9eb70c989b50af7a19bebc4f1b629a9367a0ce1c2bb2806f87e9ce5a8abc8a9e9d397837c1cdfa9cf41680506b1f850011e36017e3f1e127c14c4b1df8ec8caf6fb4c7f624475547fd0e70b5bae38e29b1a7d960196edf0bb0a3d1b26baf726a585b331ce5934a59681cad839384362e61664b87ade76f80146e2d7d108074a5faeb274cbeae61e1871aa1771d83f60cb6e4ba7dab7654ade9a7026cf4cbd83e0caa2de4334216bf69b44f37dc721f67e13fc0aa516bbf47076d8866f6825567686863ffeef0ef8bf235048a6fe97681b076ed97440fc2bdceacb9df29defc1f8abbaaea53b39d2192fa3c8b6be221b3abfe24c5b1730a9cb95a370a0fcb2d046019a525a9ff35bfc2d1f35a1b04069b6ca44d2d58274ff8ee042513e106223b4307e98d375e1c6e558a43ac04cfc933018c91c3dedf982b4b5af0a1ac52aaa30c197f05b8c6808853c61bb6d39c0b2b3060a8bcb161d33e6a40d1b58e5cc334cba86316ec3e675c806f9b7a388f3488b1c004bc15b65e607d0db2699f65531932adb40014268fb4a9f43690debc458cdde4be8e73e3dbc08c46485e797145111ec2a0e737091a9f97f35808fe79b3e54def542204c52dc29a0cbbfd79f2d25cf5c0d8cc88b7b4c67b5a8dcb1ab5bded31d38f1d0a917a482239025bc790aea3765e40ec7b8098a95f202988501777d28d4211ee7f2c69c9890f2bde26ed11f0ceb85c3db81d8773ecff6809a66a8a98357fcab08b0b6c303be4d4a85df031397b45698d8a04fa528b3062268acabf0c627cd0ba5f2dad6505b14f7e56bf878db596f650a6b37e1283cd90340bda5a610d508fc8574b0e15bff09e34d3696363bd6671d006814574161da4bdc6069253925bc5ef77be476544cde6880b8830084420066cab9b081dff758ed551098069029b68e961a64c0a155b55d1b8ddcb844ec2ae09ecad4103815f77a4226df3fe853b1511427afd1ffcf46163403b9b80cb609c9179ba047dbac0a17f692e8b6f5df9812cce2579f3e22bf6d8bdb7e8729ea7e4c6cbc190b532e44479ddb6393fa89a321dedab5484c896f339edbe0beaaec01efc1a20d8bba831c60e63efd7ea616a1154d6b52a7f6e238f004c2e268f8ba2ea64a055c792b6690b20077e14d4c9dbd12a8b82fa8c0f7394095d57c461d2696cdf01519dba80986811f77bb812bd39cef9730d1258b9c002e2e3585a6e8c7e0805e1be67c847b8191de909fb3416b4b657ac57d4946388ba6e129441423a3c5808b5d9d2208ab90086511775eaf996ad6f603a3c73f50e10d7fd780fa6fe3280c66cc6614178596a506fc7dba7f47eba51be1b86cf94c50d7e7dd3316334444f76b2fe612843e70f0620bf688d90aef2758d5cc226b1dee7b3841c6863916b406157bdf6b262aba511f135fb6a11320c5417bab6db584ae1f3218baa3a460af846af282c3d7865dcd003f841f8f9ddc4f55c7ab907d48b7bdf1df149feb640f5d00cb0a0fcccb1875fca74a4745e1a0cf2a355215bf0487446fa0e439d3ed31aaf57055c25cf15000922a37daea07509beef022f5c71c0964c94e85d268082431c8061af0bcdaef58e81f9db099855a1f87b1e8e7eb478f90ac9c759c96a228b6210fb68b080b8a7ff8a83412fb5be3648b4aeba07eafb90f6993c30594abf3b4a94de9970febb4f25babd2b2cf55264e463a1fbc3e406fee01afe3749c042d968df43934e997079d894805afe8a52ab636203526d8ecb76d941ed89778b89444aa19500e0bcecd31e45718d8417cb22dcd4c358905f792916723e4ab347a715fd3c155a6943c258f737ed5cf51c73285b73551934fc91a4140cfedf22af856c7edc156a8d62a18282eef8faf207625a591251c916d18b906813395119d28a95414b48062903d1959eee3a2e6f98711984bcd3f21de4936a24bf31ead139fb6e97cea100b1b8a125675f9b82b76ebc70cf6781e6ba5da21989e5dae82bec18def7eb36575b651dde2b7de18d9ccc8d526ee636bfb76f7af2b616f537bcdfa85e187b4828f72b4bd372ff3a2cb91c8e086510cbd92ff542bc086a4b7d221818f8d9eca0273729d8feab9cf77fbe051e5564f3037f46d19e0093e3e2c5bc2ced53fe11e07ba2c82a212e86df0174d23ac1c2fa5a26e77003e16eb87d49f2fdf15d7dc809225abc85c6833ea5fd82f94e6a6f496fb34785f43bba0d2e3f01ab938cab0b04ee70aaffa21f481e6a045c56f601b948f40d4e950d23e6a1d80591a8c0907c7901e0608ef5e684fa288e00f888a2e2f2455b4e19f3f4450333cf404e173ecb83eb07c18603da7bbc4c24912d731b9e454f51054ee849e54b216e26cd545205e780c175650b426e444ade1c573e729359b944f827a7838a9e99fc03d564d7561649d87f7d737d288f4150b5f9b1b21809efa1506019cd0538ae961ef112b7687330897ce1dd5b89b491f1b228fad2458f5818043495fb051cc4da7b9cfa0ebdea07bba29fc8bccc800917eb161a2e6541e44c88e4f6d85e6922f833dcb5ef66d655913d047f03655adad3173d37574308ca55ede8b7f6d6e97610c5714f6c4ee1b061b49a3f85ce877080a7084b7e0a860fef76a6c45cf50816f1547a96c4eae7e0611add54b52de8f33ead46d4ef6839cbcdebe3311b1207eaff3259799c225bd4258f99bc957510347990f67a443519772545d93c60be2ff6608b55bcced74962ebf6819bd6a114bd2f335d2ab1991feb0acd902f036fee6620e0d6eeadfac568a44bcac4d0e5fcd0ae885ea3e2b0ed51cc855ac872e85be1f7ff7ce70190815b7226aef12d38a3ea33cbefd1c7cc3b32856e633a162ee3464be8531214c585305d4fcedd3f3eb95b0e46be3bc2d43b43b60a028265bce50a25d702ea9693d6bff80f741df1c9df2bcc6d223d3caa5217735a45cd5ec1c40c730d13f4d5c4b95ed48f678da7211cbd8b9519674c882c4741ba94fc4c7c49d2efd1e0f7ddfafaf49cbc22dd97fe61c92c17b28ef229f0001f3c046c1f3004a0252a21c953d5fa113e8b90e0661549beabee2ca57717c72cf9d8b4c2eea902e5c47c607ea3f712b1dbb436da91c26d9ff73a5176dbc49f2aa4606159b745e61b1c5f53c6a257c5700b665f8c1f8d9a6ccdce11041900d05cab9a4e037eea643630fb165190f6d7d4e8610099de146ef922b9817c85dea09b0e6110f3ec9de9fc579113e411a8ae50b17a49af7c54bcc8026b36600027817cf6eb5de81261f0e01dadf80ed53f9953ba2a7b649bb57a07d541fc97e9c06f5cba50bdd10dfc0b78e7011040daf43e56e4a57214d63f28c1351ddd1d1265b98a370c0e55048919a98ac157a3806c74e187aea1c890fe818a3896e5128ca0b2eaab2a9ac95df0f29e725b487db3b296b37187d0f751de94f970a5cb116b010d317f52bceb7fd10a2cd83886b1d17d22dde7b5a59cf5849402d7474a2088bc4f3a0ae92d2ac79e54196d785772718df50c32f6ade1c43699420ac4683720ab1c0ed532ab89cb1bac7d3a15bbad1d4366a65848ef82838b3df71c813c0320427a955bb9c8a72cbb524388eaa1c9c31f31c919cab4211e30abbe6f4bd154c5715fc4e2ec6c4377ca853e418bceb811bcb240f4fd4e24497cf1abe242252e03fa5b0336e175611066548b87ce495ad7d3c8de1ee43531eed869e861b2aa10a9a9648fb0ecea4cc92ba0a23bcd49d39c558cd674c1686c096dbc751ef5206d8f53d7dad0accd7c87f31e408035262a82a4ed42108631f1860f4e8ec711c4d6c6c0a256f4429ff84696b202b1f4f8ff73b6eb263e0dacf59ebd942d50e65d99003819918163ef6148040298e8dc75c10b84a2e14253bb857e45e3191baec7d4b2be0fbe635c1d63cc62f2964b6b023dacf37278498e791b6867d38e01731b005f018054ebd7b81280949c80301b63cb7c814a7b87d1eabbd5eb52d36887b9c11a568e367eb4e2698f808842ee77222d23f5816d64557656b1b7ad02a2afae0a520743ec40003e0a193258d350060b247b2eca22e89af16b09b36bb903e7a974fd953c45ffa483b69d7f58a8a1ad7b978212674344131ba0ecc6d2222e8284ad75000b9c251d146d5b89d6fa74f97dc3b92354a458f552d09f654ec3e05308c79015ae6e25952d1c5ddf09592a52c4cc57d8945e7fa2bc30430db2c48e517be11d3397f9068bb1adfb54b326660003d1bc39eada21827eb212e34c6579277f20c6292806cc83296559e179ae3dba614c4e7c15f5d81c840716921f46d616dff32fa070e664b0fe79cd7dcb7dc8d8e4ce04685727b440863891834de9a61b3723021ab46be3c17e67eeade5f6a0e80ff044a27715a4d00c60e0f050e9519cac6272432af19b600bb5bf790a698501761d4c4286bcd1844ffe8c1df740739478f84a89855faa0ca813e1e295d34c706fe95faa13d287a1bd583f42018e9608b80b057af9bd165cf5372c06e3d303b4e9263c4c2bee9ed6801c4e6c1c6362cfb6621216dde31713e44a865b92b9f61296ff1907775632c80ff40ef6c363898ff4465e9d86ab90cc2690e20a834386f57cce5b15c7fbef22101c1e3a82c0432ce81d7aa78c2f7fa415f55e36770b44c652f957cb3b6a3c35e7bf49cf2125140d7ac68cd31c3a5028b8dab0791fec4a440224276a882f05b086c22ec1ec5978f2b5d9a596b610bf45bf3147eaa2f0025592d23e60c53ca6245d54eec1595d16f991857eebcfd11e3820b8219f69b0e51c87583fb5a535939cea148c4701945c91efa231b8b1f33d9bd15b1197b14b5c621c2f70f567dd125655a1895fd232487790c584628bd5697490ce85bf74d51171182f3d78e579da6b1d1b6992dd1fd71aa76e16ab3b69905e36126d846a20f420b4a3475361a63432ab3ce012dae0244df21f44085e40bcd79b74907a14366a263c5c68654d57dbab97e7b65d43c06e20b8fd2b211507e4cef4b3a796f10fffe3903f854657c8bb92c98a0f15966ba70147cb90e63e08ae0f2c97d760d028b7e41d5e6dc39eb87104554d3c197bbdb12b8951318192a4f8110d55f36aef9824f455c0ffebb1d90a6abc640df9e63fd890691a75e6224fb0301003a269f24c42c98c8bfb163f951b0f0918c92d45e3b258b7bb1786188c53968e7131b58cf7b7ef0be0070fbd4fd886dabdb324d5a775e66e0da6e7f4b0dd69fd4e538af244fcd523b85b4b84a9a092685f89202beae757760bff253135c0c617f16a9f536a2123332bab1ce9ce8bd1ff61a958bbc73840bb617a1e8fa1695295fb1dfc1fbd173375d15a18e051a3c93715e5cd970e4f1a63cdbe48dc9a8d1ce314a26a7081b9f57ced0f5b27dc20b0dd1cbcaad9767088c82b6f04873bc83c461c2ffce03eceb7135dc898e4ac64b8e51c0dd0c646dd470dc9e73bd4e142e99960cff9d5de8cfa8e8fa5b49c56e729b68e5f1110bf426d014d050918a3c4daea48c7789c78e1f1edb2d5b1e1aaccfaa25a689367989c5d14fba95a73e764d91a5ba8fc4e7f73cf6022f3d68ef0d133498374d3d6c076d955becded8d89dbd532ad66982c37206e2d090db6b9f31f9aead9cbfb1de45ee102d17056a886457617e11f98aac80a106f42f91874a0ecd1e076ddfe448a9644ec62ebbc273250cd2f5424ba432290d86dc3839f2628e9af4f72f62a273bb6b984e48d088b73e484b23c304823a4aac0a584bf256a20e066da8707ade1f9698a85d0e0546f2e8be1152948e407e458a38ff9d50622db2926e3f4c6088ab8b1d84bc235beed7c94ee2fcedca7e81644a13a1b7b1923c0cfecaf52d4dcf88e7f99ad4865fd44367c2298ee20739b3e870ff871b9233c382bc9c964406b1e244508e0db14297aa59a8114d7862d16c30628da16830d08863a995f8637f3a7f4e72c7e0ffe080067ee5bf22bc92e771d60cc2101b3bdf6e7b073018197eb810dd56a10bfa996e6fdda24ae5cbdc3a7ac528616f59a5f38db50698a253fd024d5e578cdfe7fb917507498b6d86f58e14ba1ebce1768e32772358abff3c86bed45474e1ca34489ba455f2d67d9a10665982bea6aa2f6095e665d5860636403eaa13d337d11bb5cbfb91aeb593390e288b9d8d64c3f24d0d793f317856cec5f6f69ecd5044384dd677a5bc00849b9c95c66c489bf6609054d35564108d0e62047f74c747e031aa15cb92fde15236dbd1ef0c53ef4e36b2c9eb0edde150b70445a8dbb0a74216c8e159639bb5400d9eea75a6650b2adf8de2484bdf1f04985183e5252e6c8d62320f0bc3bbf943d298302587080ca68f7adad237249d0bc3a594fc138f3d62ddf279aa0d2b7f6e33cefd59eaf6e84c0b384efc4e50e33b585ced2af2ede79d405597aecfb146d8b527d6e20d19d2e1ea25bc832af85560f4eeff0e46358dca7b487ae37740101eadeaf2c7b2b34d151fa4da23522b273ac1ad25bdbacd8b1f88eb75ad983e9e085e76f7cecc0ec58614494f7af55cdfb34887f00778f5ff437354ca90ee7b6a8726ad47ebc72d22ad1ae945017b362f29c8d75686ec9783bc1170ff77f3f033a5f7a32b189403ee94cf230f9ef6ac7e500c76878bc721f6ce832d0728386f1e1a9c0f718f9b54ad5a3fb06a53db290c2a2350497da8f6d5fdfe4fcadf71b450db56e45fb963ca94c5296300f01f0c73a119925b26f9e789de10789ae8085e7fb8ab863b4697f033ff8f7b4fbe2c08c69217052aa14dba02e0c84229742b5dc8faffe41a2c18b1634162671e2a04d25875eed33075cc83743c6e57b16ac4763ca55fff997e1f2f9be9f102037fdd13ab2bdcdcb3a93cc8a1f6636853a8e88cc199d05d6ccc3f928530292b9ac02b3f6b7f5d31638cc3e1a3e2a0b27ffc8415e7ec1ddab4e9da81fe31f02f2b4d18f04cb03351dc6c5ff93877f32bd202ad0d1e5bb04165c6857ff857cf59a55ef38603cbea18b7bf76a0f44a0be2cf82fff99010bf249dcc9c88ea92caea5cb27219e1173d882e633a0551f0fa14f98820f771ca4331b3e6e2d68cc852c36dc042498d7c7b6e6dcfe73c17db9800db39993547abdc4f42b0d93ff3328e8837df557dec91762bba0e5fbd968c835ecf408d904f9834850d2a84e9034d90539221045c312a86b28228428c59f2dbe74c63db1cc55723cc4c414175d6046c8bbe4912a1945a42a41aa54feb4adefa5280a01be9d3c7c6c601994f50e046026f0a669ca9effc651302f7b1324e0470f05fd35a3798412fe76fc02f1802313f14c1902e05054a6cbed288aabab272afc316aece54c48519be16e70fa44b03464ee3a54e2362bec42f36ea0f46c44e18f20b221215492993f3777815a7eb67bd8e1e1ab975309132c2a84fc69179a61a2d61d19f1c5b765756885c9786c932dba0c0d10b0fbac3bd684b0c82823e22848330fe49f91c706c5c464857c09e3aacc0217d8486d9370f1047980f3591717640fdcd329161f05974b933795d887f9256212eb1fdea6a59fbbf11ade8f471cad03e54f6a51c5ad7e425cfdecdb220186528e94f5d51933590ae6771795aa5ff50ed89956336dc59f5a20e5c4c6858fc11f6368c8b7eec5807416f3cc48f225c05812545eee8bb897a0b7a83876a3f556a7a6ee09aad6ca5e2a2405436cb72342aa9ba1696754bb2f2c32f99fe5c4c0cfc46bb2f311221ca3aa3def2e312360107f5aa9c9086cfdc9af0b7696d047542ddc70234d260e80b93d47c793c4262731c309f149c60ddf74114214876fcdc0aae3963ed4d7822c5a2aa20979c439bf3dca675c25cb68816c9410d8639267d532d2310e73c61669841b511a05733984909f5ad7c36c51d8f871ad1ab2b955daa9a097ca0a4ffabdbbd1ee0b099305711a85743499c4b625ede91501abda03e8dde62f2b3c342582ae9b47f5b3c5273978c78e5d9741e40dd46e1cd18eea8a97f6bea32bde2b0948e54d06c1e1abdb8a8a6726c64c8d6c26fa88d5ea7ee1018317e26f517d8fc797484b98f7543e4cc631374aa7b85dff8b983544fe246601509f5a233c11f2e251d1bc741e18663113f2c7ce391f1e0e39d793987213c86c62c92b9e5102fcfba07307622fe7e410bb9eca5eaa6cb09ee869b2b9d1fe05b87a03b51fc8346f06ed00d4d7ae10a214932208292d4860f5674b18143aa6b714df56824974e0f41f3645794df8917b320ddff84a47e9d39d22d0caf3b6870f6cae0834c6f2216c602629a161264c56b4e73e916dfc0739dc99c320a7a8dfd0b79d68597c78a257d91d908ec158800d45848f090f1a672c4930a559a3060f2e9cd1ba5c144fdb5df024e23ed52ba3c1b8ee56f716420c3ab6581a568eff93ebbe0105d06075eff5a5885cfcf828bcb754452e3561391de68d3218ff416be4b179f7dda33c0cb82a7cbe1bed4aef08e2d86b59b5333a578096a59dfb2c6700912794ece9c5dbf3584781d29a1d80f85e6f63e7997b327ed8017de7fd4bc0fb7b9b4c685b1707a5f4e7b1a655adf4d13e229049ccb985e9936c0d2ad6c7b2f3ee1f58e3ba21e7f82f2693b45a54601d59dba833a1e7ed3257fef9bbc9cbbebd50ecf879e858480881aaaef81d79cdd9211ab5beb7394cab85b9702a5ffe0c34b7685b8e224ec1a01aa8b60c76797b5935736c93b948f78c5c935fa8155129551d672fd013851eff576f60d5c500e1c0cbc7ee58e9c7fef32d00cdc39b402f8df9368b9ff4c8ef221eb80d43ac5efd3b9c9c4fa150270b24186564fd41f64c65b4e49f2fce617c248aae4a0d854af755135957a24a02dd38c725a7e3d8809e5744cd38e23efde17cb5d76f0f41c824c9b6faf06c4ac025942cbc39a96d0aeb387fb85ecec2365cadaa4da5d462166eb15a3f4cf9a3b1077b74fbd1f79734eebcee8a065b8cd8c3ad7f9be82ba4c3471f90250dfc007d5a1403cb7692817584a071f33fc9086a09fbb94472a7e7dbd870d8098f88f9be766507841acf85e6499d9f251f0a05237f99d29475a2bbef2781d014f6440df81e9ec0ac56b61944822fa64c08c196e43256609389429ff0d668f1b34749c6de89227772f2b9704a1809d08c33b9e202bce1973561270f56bda493101935d8840c1c0702a23e0f2457725009246d35e57888034b5c0411979b9317fef0a51137fe7c0c6c377617351ff4c37c273ad21a0c8915f21216ddb9d2228c7443a437e4a6fe7f51e9559706e7c6cf783b3fbcc6b94484690c09414115f362d62fe6be77e2a21bfb723a4f767cc5356003fb573efd7fabb036da25d0e92a1643af0121261cc61b9c74e87f369cdd1d6ddbe879d07bf668d2abc2b7c4c492474e5da88d94fc1cd7493bbe8e8ac76a174eee6293361e10de912e16d589bd6e18945940eaa14db7dbbc25f6028791195b0da5bf208fb2989e9d08933e828aefc750236f6c508c3110acbfbe79b0a3b91a32fc9e14c4620895fd054bdb4e0c3cfab81cc4221cb8472f648f9c43dfa572c3aa1adc6dd54e5b082366fbf5705aff685a0fd157e1065cceb55eacec90519f214c4a5fb27b0da7f34dd21e5c704e78bca73197c9a6ca23ff2d2422e54d32293856a4fc853cd7c1a87fb7edf0b4a1168be09843e0ced921a11b2f7c50828ac8e73ff0d099b7dbcd83118d5fcef2a476fc54990433ab2a2fe1fbb6f6cb6c0ccc3ab6e3e243d7db2f49b4a30322a2de9c1604359336b9d15c2d44ec7d725acbaeb008df54fee6437d162636ca983522ce17f312c3b2602c8a361127c6f3ebe0f8119b178536673305ba809e3449fdc87a68b394e02f47636dcc27b6ac8729a8714f503e2dc025339f67aef1aec401cb36a28f18b289631d275e70995c953a1710e77d59479cb171331bd312a44361cad8d5574eec0f4d1f2c8ba3a6e4b0114bb2061c9690718b8cbe38e0a45b0296bef3ba18dd786826c07214be3861a12ed33b36df91e6a363ed413849fe19e2bd68190eeb7ecc2a5c91c31eb463cfcac361743c4e88198d1e36a025fa0e4d2ca9dfb1ebf52cd67cba7e28baac3d0ad9d11e4a5717d7b9dbfa67f91015bea8d857be03d25dddd1d1ac8052d414dd1068a2ddda7a381e8c41513f12f6649a8250219a92f20e993f150d98d6fe06c2cb802240e67df00303c2e57f3c3b6918262e631e1055a0d1f204f81f971ee79b520a6972c997b10af3b5803051e5b4d0c2bd95378415cecd9cde8b70d948a1a21e2f60821ba235d956b0568d9eca1278542f82b79ed983c993c4e61cdc26f9b4182e0315bb9f3bd2d3a3791bdaed413ed94744e4a49b4e49912f59954fd487f6fa6048cba4772f1165b13f850101be55023ff1c48ebd75d559b966a34dfe0227eaa27f1c5be920859a4ab249d8c45782b797c6333a77bc5af61c4be230e5dbc12e25a7ca1fb4242569f63736029883e3d80cb453c96ec4aacfd228be7f3584b87697ede424f485ee556b6fcbe47d91664e1f6acf31886dd5b93e35a09275549c2b6891b3bd993901eb9ff3bc9d07f7786c2bc1b6d621c3f8dae72ecc39673ead4218e5ac3571f649597e98b09b9e5be949bf48d7cf7a0134bcd6662b83ad1c6211065c65ef82111d82546245ec248f2f90751006a1f65ef1c5e193b2bd87e861da0e5793e090045d8294b4c9e8183c4899c5ea6ec8bcd6927f0b412959ed72a16197a317323464f756f6221b5f75a9618fd5b9acc5b318319eb575e76aa46bf4abf7e96ce146e4964278c26c90688bb883e26bf13af7b25a3d7e2181393f1ce5a9eddc5e6480dfa4de8a7d0b8b86ffc5b139d2ba36ec45dc388f41b6cae5d3198362ad81d0e7c114c20ef909313596b59993c29040e20ca7f14b1a35f43c3ddc4679e8314c74fac745bf9cf06d9d292addb930dbe8b1bbeb3169ea6bb8e38e82b24b33c725dbf9246299cb26e676020d4136728d10a5320c6f2f8139bb97dea439f4d4a5587377a3c0dbb3b0d1bc3be766745a3b506e371898ca55529359d086fafe126e2a6a76d2b737e28e155af8aeb7b0a2b0fcb3bf54036562e272166d6c4e472864d3a04474892ddd1230b1f5191f21217cf185fe7cb7cb885459dc5f3e013493b1f75d19f83efd79dc841144eba26ef6e3163fd21afdfee65eb491f7cf6874658f4358dd6f3e57318e1ff3122f04f21f1235b34df4a79565af1f1ed0c3d47aac6d2985bac42b3fb9ecaa952ed57107d46ac6e791a1063439df02b109775d1a435c3c0adcb93d0822a65ace60440026604fca70f1fbb5070122ffbc4cc5a5cae0f91eab5fa5c76728b76533c211d12923b4996254672807a0bc447b42d1e86b8548b1a4c1c499c2ebf6568fc0ec0f333d33e46fbf2a8f69eb3fde9f62e4277dccede09f6633f0c7071a193d041969e584f25d8b4bbc5170ff1b0252e0ede7122b66e27586ea34ee6941957f9dfff0a1ede841d1797188f08e31500d237bba45d9ff107e49559c910f3e6c289da8c0f46cbab50d54fc5a41a17ae59505b8d94b0ca5f99648298434b858705b20613d78af30d96bf41ff092f05d141d02a349ea699fe4802bf5bcfbef3f6cf5756516cd48a763588e7458bd184a8da5cb912b42c54e48bec423d49a9323178b54d22e4fef35a75df770a5f02315d1ae5c0d62928e5171d94c53842f5393dc4e571d26b86094ebb815373b112c23a1b5d4c1952f8efb122bb655a8545a1b70b3bce2b79dee336894410b5fabaee980c073fda6e64a54e70a9d1ad72c2b71bc39bc7c3f4068116c9aeb741b6c7200466615506f72e65658ca06a14f5f2cd2123d2d09f66101adb1c58d3e5e468ac070f3dcb84a704d611b7b150e93a8a8b4016df63b7e1981619ee81a11f36691638dc6a24f91ccf2dc5f269275fee16257a3f81a583772996642656f0a856a527a57e0c476330573cb895ad791f1332b2048d60d69fa47eea2475700db2a733719bc979e475b2e207be5fffec233c5dc61e501857b7c6339af15e2bd6e63a81b40269ae0624c702661dac486d260a6acd4a42f19a871c599b5121047a7debcbf6c448c1a8d2db6008f969227852ffbec651f8221cdf926dd5f8049fc434e13d7685e5cbcdaf3c2a93e2aa432fb59c5e0dcc5f28bf0e32976aec1985f1fc09134f3f27563a034e3b37006b8fb8e35ce107ebec3ee304ae7b6170852e811dfc73b4078ea6c0785a8032848bff729d01b5b6f451cd1f84c98e262316e6b61588a1d22e2da6287505afbbf80f65d2363d5b3e7a8dc59fce75c2b4bd10ed1acfe9591ea9fc0aa022b9d293685b9dff40f8a245bc9f978034df11900fe9c7d8a1db0e7aa1cc28c76abb69aa1f56cc92e4415ca3cf5cb3798b6f42c18d8c9676cce4d751b086d9633d01c78107d02d34c9d809f465a23612d4b5370100612972ebf0ad95ed425646d607ffc99dc04b423ee4ddffafd8c54a70dedbab3d807a9d2e1ba09ed75918e8db372c9ef646819e3de82f13516de04517026771bdce54d360b87ac4ab0e54bd4a4317074e6873506702c6695ccb7b20bfc55db04929585ebbc3f20d98df0c57a3114e36d06a9a95d659c789614c6b63091958faa1e190077194242df02ee66120cbf6d5de61e97d78fa242e03e141ab2b734420bb94473cf0afe42d45a0ab7f43c8c55c261309195589b5684e4fce0e47078fd81d0d0b5ddece216856709233fa4a8c5f3230f2cb2077b2e8ecc62717dee4b00409edb202bab579e20a186a3a95343f790c3cbec7cf4fb254ce6493c2bd31beb395f6e75d376ae3d8ce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
