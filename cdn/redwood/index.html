<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"30c0cdb65617f73bc9dd24d82f1b18dbe51606053eb2c26b79bee569eba893283e3096755ccdb7df18a200ca7b93cfbec67df8cef7d18eb3d24dba55899707c846bd340708de08a7b52899c7b24f1b96fb84ac408cc29d1a249bb286af3a7364969741a98c3f4e4504d808809265d17bc5903c29f66455c0eab6c99b5049cf58def3745b037ac4e7180be6247372cf2851e35a8a759ee30b59f84d167d719143560f4d8b3ec85ffa0471b6319c69ca1c878eabd0235258b9657e5e2fcccf0db53e80005e2b84f42ea623118e39d235aebbe3d7b5770e5b44291cb33c5c8365ee94d71ff5b4372d3adc98b2c41ed1ba0cc50d0c85e23035bc1347c01ae0854f484d66ba4a7970c76b923a4cffd19e43e333636510e96dc87ced959c69140b2525757ff04bd2f1b205ce0423dd6e86494ad97edf6a4189caf8a7864d2ea244bbaebee45adc66c1fd988bd0b7bcc204d4c3b34a19c687fc399a9c2b114612fe4c30e7716e3e923b5108f41b56886e6d97a7dac4f3b29240419ce052898463c436c4ba3d073c0e80d6b6c319faba8748612a13da871bf7099e537786a4b05bd9bd9850889c44fdda44018c4c1b297fb5603d1d4a3dcd67b4c7c0966b8c89bac4d1df54f5551e800829b00d2f0192de4431c197806f58ebd445bc6b7459f755b8215e67793bed532b6e8dcc21e8b27fdf29a92d1aa7610770a20cd24e2adea7874a536b344d7a1d3fd124988c775a9170a2295fd22d7990148fa48139e07ac657def0199a9c97177075084891c9381db8b4fdb5529fc91aa60c993bbbbb79a2f18862274d7b2c5d104ff91fe347c0a7e3a4998828de4441307757377476ece5b2461f931bbefc9c5a311e8370b3afea476025ccdd27c9c74156602117bbe67f585bf91233b199d84f0740f64f8962a95b38cdedf85a71c20cde3febfef87cebd081923b452adecd903b7c319566382a750b8a50a7b7c0767b8dcd61a1b2b1afd7684502f9867325a59b675361a80d3e89612b946b8f363b4520200856ecfa1241405527ba4647ad6eeffa4920aaaef7c91118d0df908e466537cc006ecf2fda5cf9dc766360bda9cc53f4d982fe6ea8da601288b4ea11d09d8c72830cced531f706d2b84497e29d0549089a11851d236f199905521c26a1a9a8ac33eb32d90a99a40d91c67024e87c90d5bb7609f7a7888ba3ab65060ba05fe3324ca6726c682806779e393ead741d18d5625fd9cac62e06c5b79ca5c81a7950e999433522487cadfa727d30830fda9dd28a14c5bd8235bbb5bfd479be42088dc12e68564f6a14263e281058c6130e69357a5daf7d158042b1a2bd481ed67c3a2869fa541a146bc6c3c4832c92424b6f438ed502cf0834d500ecdbe9374148d7dfa3685fab4d4b69d0c914f6522ebf2072c084a890c277811438d2bb61468010dd76bbe9bea4fbe4cc04f239c4e534aca8d28dec100a1752e3d2942cfae22887cc5b6cd6d5a17b972725acdf61ece4fbd5bdf40346dd6c64e431c480d31cf4dea8362cce15bda44baa89002f4dd8a92c6dd464b0e6de4a1ada9a9558a56c8bc4e063bd4b115230d3c5015b14b4e027e63d9f2f340176e8bbdbeb4af42efa556f121166948bf59722eabf7bac81e124433eb88ec36221105be315c86040435769153c8ba47dd089348b0cd36bcd06eee264c738c77b381538d468447ec80477e1f9ff8f7d211884000e44e2d4bf51d0112a91cb3a5d615598beeee9298151d14cb7bb6e8fa41769e55f3a2ce554e06820f6f4389c9ba9e7a1aa743bd21a127a30aec6d175debfeb840055773a67e4554aa5eec0eaac050150cc0a013b62808dcae1aef1e1a76ca2f6b685a8fd25000a403fb9af9ebe1cfba4a2e06de35befed72ab6a4e66f576a81298dc37cfe3325d911351af30842f68066f24bf2fdd11a67e6d3f3e48f04014e8fc33794e523ccef0918f27b62d9808ea1b7d0e0f10c0dda11791dc7c1d12cc2f95c7226440b76d3297f1e25f64199142d08f1dd6aafd5cd8fa1ec3949b315f11b1c3df21edaf2343c005ab86bd2d3005553a1f1aabe8cce6a860b768e2189b321ac017625b03db5ea8736e00af3cadd0622c1c1a58f7fbc5f24031f7f11e8a27afa006522cbd659e48f82ec4d15858aa51d2c31ab0f16b46d2b5efc04556b068e3934cf5d753d1870cb16292cb97facfea9d892f63572dee849d3b477e65a63e247e51156b5709800ed2598bf598c40bb07d52c8ceec00e9c2881b876142ad1d7883eb9cf3a43d3370595558ba32ff5c824b52fe20c99216c0e8fafa0053648d12f85fac87c62b6266e1532858c61d49a234abf04960b2279337212523b9ca77d8b5c63e57177bc9ac715a71421a165bc9f3a945d1f72ba8459b19b4274159d6947ed97d10ec40ce5d269182019df58c1be8de9cd7c0ed8b4770c8ba345f8c73dba39185e21cc50373245dd269ae24dd97424dcbeb1917cb809fdcf53cbf90e7edb0bedd31d919cc5dd230eafab68e461c5e21dfeec52f87d126643e64d5ddb2e9dfa8ee6bad6fa27d5fb33655f755d185acebe0b3de515d63f5d52267af843ad763860d684e2fe28f350d253775ce7b8529fcfbaf9b7f95efe40db03ec5edd265aa3e5c0f2d604cee0bf9643820937622f25f8575a32e27fb5d4812655b2c69c041b8b179d6a655ffce914113124d3af7b73edf603e1cff272b0549f09927ba0017b6db0305aacb02e9f5c725324d36d2bc5b2250b0e51dd591c23de8316ae7fa29a1f984392a26ac1befef0f30d9c049a1975c7aff1ce25474822354c9c23ed8381232be559f1af3430671f0ebcd68d0ae12c56ab40115171b0068733984a9a39d3035e7e02ca72e0c3f253824adcc22f74f689117107b5a2e75edf518cbc54880dc39437a05003b25770a6c5627ff0cb905727979fbcf22876b8e39e581f1e607f583244670b90aa0b7d007a0ed46604f93d0b7c4e7bc3904f4ab3d7a069e0c3207ff7f7c55501af4f9545e2dc7c89a967b2d7f805d119d34680779ac622c374a59cb2882a50a970e397026bc87296b8ff396cc5e53d9b0068679fe5e421698d3000256da91c9ea00c17a0027af911e1973182bdf073752f396f4d816593538ad6adcd90bce3b8037ac574a2d1b5b6e3c4de34e3709fc352c85d54c59303a9925677f9adf6cd706cc7be5d2bdaacfb3cd74bf46356a3214033099149ef409d5cdaee5248266f66cbaa4cb69d93d34f0ba4745fbb49d55efc346d8ff2884f18a56a8c6bea549b6844a891682dc2b1d3bd295f5071b48d8c05403e8259f4a52e3bb9f0ea201f5dd6664ab18e95ba60df813e9c07dda959998c453b610591c3998947a92b345a67b2551514c74659ad4620677ab6aa8970e93ea6ee0f132d652b1de21b93891e4a1b3487165974d7a7774d2e006d8b01b5a9e899c17c570971b925c1e5d51a7c15af8d72502a6f37813bfaf7e23e129069a05330a94b174ed05bf8f5dd35ee998ecddd2a830b55b0c6636a21bdd8ea0277e2a04757f7026234e2844504cbfc399426a74f8369ec33d67e71d9719ca0ce3094d2fb6697f754756f47623d0f84e5bd278bd9cb3f53ef00cfc71ac76c1415b9c0467638d8025bf7a51584b3af9d0e1b02596de6cc6ee4e7a3b200f77268cd15d6279520230ce6d8ee71d7ed942e2944ec79fc3abb054d81fcdc1d8c391361f354a55902f70d1a239fb13ccf139f9ad219f2a4608974d3c9c65ee31adb31237effa42922aabc4f73d00a75f9ae8ea98da6b193e803d3241c1fb7d175627a61cbb199910f7b36b873c8a2864593aa57f189550480ee2652e9d476490646965532caa9cef46d17aabfc90918eb89b487542e6230c69f6d9d886b8029c34989e142bce906838f673504cad2a59a08f28149958e6837e7b80be4f2574278f334bf9db71f84c05eb9b82d503a9d0459e0bcd70efe091df0cb2d7137a2f1d71213a8f4046d0e09c25d364ec039226e9f9bc12429cff35ca13752e37aad2ee403f7189a2c458f170a9deb1aab9aceb877cd67029e7dfc4d8e9deb317c1d87a5fc83a33933e492bf3299b813ed74e443c15359f358ec44e0a69888a19cfa94b976c523429518dcc72d6401d6866f1a4e519494f082e3074672977bf6cc5041670cc514c0b48c97e39e0a656f64fe8f1f9f3d7def32895b437676e6cfd524c3b04f9c2896c78fcbcb76155d324f665659e35557778bb518ff9341032799d3aa71b38825c82bb78908f8cbc797f96e0397160ac9f1849bbbb3d49440648262a70c05b69a07d7de2376618b767bf1e80665917bb817763280c14f46e44b43e3e0c058c1799226760ec14f00712afcd27af9f892db6e58d5daa159748abdfda03a118d1f2c24b56114cdee6e93ec8a565174422feabe5a7040d0d125526f583efe4e3bf20254cc240d6cc282c9025a687ad48ed5ae5275b864bb0009f9cd8a966163c06d4d99bd7d63f2cef4e986e60c85ceb8fa87b8a6e2edfad54b63a2305f81e5ed21a23c95bf6434de49aa5c5b58f71c39309cdd4ed073d171ca0c9e48a25465ed65fdae988093ad4f6f9acccdc4bc3936a923523838bdad503d7d3f8f12f7ac2cc4916afcea1c8587986422e3461048dc4d5bd8c64a2f5649be921f8684ac51e45d295e35e604d0955c0f4e3b3dfb86acec06295e5bbf8c3e7502bd492f2a21eebf69c391af08e8ec84dc4e46ea31c8d9a6ce9e27e2253ac5b223257104380dffea04b59421a341944648632af0254f29ed339f5721597cf3e1aa0fe07d4ffe50db00072edf6dfad82f1713436a52b52f8a6c665fa01a1edcdd58ba68fa5d470f6e61675e7409a86fcdc54764652337e75518d9a1c8cef2f48fdd3b4022500ebb88ddd948ef9455b75f9da28bafe084670e5e07e82ed29b7bfecb4569aa73f8c3255cc152e3a1d573c06e517aa3c1296a0ee595ff7a708a00d8bc12309c2f071459cc69d6035b77f73d727f85459a5d8c6b7410e9c360e60074bbf637a9b24d75aebb3b1ac5aa5afe6889cb3b0691517e78fa174a366685f387dcdb0e177b83cb7637a92afac1ebbf527ec089874d28ce97f9e05bf67f63ae05a841da6cdcd9eec810bd10a053b02ef8c30884d3d6d84fe9a790c4c6077d21bacb9c306464cfcead1570ee84940822e4e8bd745f0ac49372fa4612bdbae8d4e269428d8c0718472b70cd8354d7c23fcd20f5da499dab6836afa0596bd645d7643f1d5fa3d688bcd24976a69581c8f5a183fceb2056d2b6e9f28dbecca248779c08e833ab4453bfcd632f67aced53a86ce49465699195ea474e36221403c6b21892413dfa27c313478e76c92140ee4dd588313dd79b83b6bcef85323654e4c06e46fb5ddedf3576bce45132ad1f01620eacf4fe19c7cc773eb612392c6212c5f0fe784dcb3d595fd737662ac97e5abee793882047662de9fb478e47aee81467ac5552fc53f9b6c8826518a6f392ed4004d47f3c6e65c58e8a2657af7342bfa2619e15893a0dfc972e87e53f4ec6e3a3873736e8dc27ecfe9d751cfd31c1f3263322c00406878e6a2663093a5f0d50d080a29853b98db06a238d9a9763246df121b8a04639aa77f9095992c0da2b2cd8417b89969b308d59e91248f17dceb33a9e5e166d746333156a6a3c4462739a6a65cc50de603cd739077c52267734d0bd078890c6a5dd228b07fc98dc1adae053c80c5e263300f9acb8f152b9786a7fd72fa76a7a5d112d714d96423f5ad3d219eb4949b56978d64a4f8b2937822764da573ca116b10b7ac6784c4b10e0a5c3be9d96c7e5e4f092e61944400591832f53c881f28e0aed1cf6ad452baf49f57aec4ec0d1c0c32b5a9a9aa4c94c7ba7abd4a3d55cb4c8032881493ac1086c2d866a5a774ac5cf237c6ea98e7288c821cc3f5c919f0e625a167c37f9bf74531cc56f094aca3c5a29dab3c248b12d7a166080930ea67f14b1c5604a6d63ac61ea19a425c6dc3a7741133eb79ff40f25a2b90e750da1972607a296511d000c9ec51c7c28e17bccd2f4b0abaa207c7fd33c22a901f766ea940f677681850d4adf68f40fbcb02c50a2ec7c7416ab46eddff1c42735e653396a02faf9951290bbbcb3a9467f4c3dab93766b4628ee1b862df4880fed6912954e79e9daa60ab8dba77469e94fcf8fdc9923d61358694addf9e0b7498169c4736264356af486e4ef3b6ba48b0204ae335f8d3cb808d78ef4e2d77e442ce79989add3480400dbf16bdce7197ffebcc4839bc75f447939a26d0ec7684715cf43542cf24d3a47c7413261104bc13153beb7c900970a318c8bdb2f79857134013f7b33d835f8dbd9ab4d7eb52038ea68e4dd0ce58968ad43ee4232ab3ed792e8f719072fe4bf11132fdc320ae1582cd4d2569e5178ad7ed481053aec87f3aa54a3116aeb7a146bb1c93120da268bfcc844f1497b32a048a2c76262222a426f36f537ed3ad456c1c07a1843836a09281fb975230dcf076356fb2a823417cf1a6fb0b3bce69c1ad4a70f5f90952499ab67bac230b14209cc900685141524f58203cb9e4e8ebdbc064de9e7b7d91e33a1b5fcd27f4080b16050036d985097d24556d17995f25c4eff5984c9c1c1658c97b84fec1ed5b7c7ec2d4996c6e67e5f7c106d1cf0de1153a65ffc60f6028872e1c344175d453eae7b0dd81c4d372857688a765b86150a7dcf9913750dafd17a6cfc02bb5415721b76f6660cf181520e4c4aa1ab3fb329395ee2d93cba6bd187ac1bca32894dfbd4e5c472bfe02cf2fb16eb178da880432c1546d3e05cd809310e78da09c4d71cbd09b631156b9afc4d52adc8c6297a65a4d953427e8c8ec5f125fb9ecfe22bb6ed192a3cd4101c94284446e06b1fd293db65b069a34d76e2c5c2af027fd647fe3230e6f4566c02cba96e541fb41a2bda3308028596ed9670e3abcd16fd76561cecd957af0789528caa15b35006e38f3931ad4f1d65404af884f3031ffd0e165dc9c75f375039db313bd856f9aaa1459269fca3c6d672c0939a9ca25301d9da5dca547e5932d48509fdb25d561e5e4e8edc12a871875d3f62149e6e92020331ed597a9390b93bd53a15a9a60b0b19b306b2a44a4b349d3438f8557d40acebd78031bd5c19129e7dcc482d7be9846ea6d02d380de4bcc47b97e1c3f244862a116a7b5e8af20cdc893d5298d622a4473a6512334eb3e38b5ded9b64c8c35f91b98545a456b03ce3e5763bc4a52a66fa6899e4f0fd34e9115a7060c9e409fb69805fc384339ec1fcc3d02cd75f81d708a02d4d0af5fe14fb234d126a232827543e37707fa36d56a891fe8d040e4568037db03638ed8bc47dafea66f4e67225b0f4a4dbcf9d41bfa57de9198b4028de2b167fe0f1d0f163d312acbfeccf5debe8d6fb1e219f2718a3e20263eb88a3a6b28000454d8a90281cfb5dfa3c2c39b3c946a9d367684f029adc5272373f8c5766f7ed20cb553c683fe12f0a9834af4bc93abfca83715b9ce9577a6248ace39a57928a9765dbf5b50c6615986ac7180a4c968d063ef5f62d8f159c7bb47b2e8e1694da2a0c611c9d6341b1ccf15abf6fdaa33cc0385b885dedf3050e7c585a8bd8546b48af78c5ecd0ddeb2c61223683838b8a75b6b854123a297a4bfb1e0bfc934b392f04f3a09b85b3f86332963f5bfed2f6ed8dded4273f394afce7e1c2ebca035dcc0affb11e54d44584fb7d37ca82b864a0ecfa90cafefb5251d9593414250df22cd77e0623bfb33daa6091605e638555a1dd2477ad27de83a13f02d999711d3f93dddfdb92995a7ea714ac62b411267ec75710c71d49947796474670b77e53c0e3a5ac063597c0a411b96a7e7fc1e1a8ac071ee843e9fa177600f28d88ffc37084eb8f878d4d62204478064e97099ad3c00390ed21f349757f0fee2393dfc57dd64344c9029b5f07262bd4efc044f255cb108b42506a1fc3de93d97e9d1be5be540f4957eccad6af1752a1b86b77915ff1e83ffdbfb473d750e20e39fdec78f3ca778ff1b1da01e98cec76b266ced4eafc10b7ca780070958ca166b24e8c1a13e8bc2f7f14874fe4724bfd07bf030f877a01c22d63c54a09e6e7a304400c60aceb6c4229a8089dc112802c917187ddfa7878c4087cf26117a91d76a0ed921bc9dcf6fa577e8ab10cce3f635221c21fce4d70e778561e87a6e8576b47d97305ac6837ee39019ce9f9e5d2c944797b6938b3af2c651cf3463b15f5c8e6d48c22bc9545c68e4baf76af40595fcaeac41c21c40cadb7d36617f48951c7e47a93ae9b6d059ce7eb07178469979d83bf2d3b3844ff72d445a78a1277825379331f68dfd8c428306dc43550fd93a94f35950e59d070f2d7a24269744ed050585327d4edf7a782460a731db09ca5c3bdcf9fafcc48428478e227ada27594d99a8f874867d4bbb5fdcce705cccc1f4b00cfc873fd1b6003f25a2aaaf7e2ac8fc989cf036747948e2acb338e7d06845869c97dbdda3c52afc21decbda0ff8b1a5a66599ffb98772e689273e974f934e447d8f346e250f5be651c219a9fc37eb72385030130d6910f53a82e1f263e406e861e993ef8b460a91277a4136d31029f4d5390b01a1bddb8cbe0094551d80ed1e629a653a9e18b6c0b4b8da2b97222e4968a2bac530c14c4da253bf97ed1bb9809f886f47724d72c585b742490081e0168dc616f7824f9793b43d3cf0da1b26178ddd7f0d1dcd79030fe0d3e484126f3dbe9773ac3ffab1332cca1f09700cf371d671e605d3ec7832bcd77c2176641348f600f4839a33019046a6dfdc25eb7dba372b5ab50bc51c2e75d991056ec35d97dd256a8dbdf6f96d37c9f0e9507b0a69812eb41ad08c25fce8055e7c9e3f401cf9cd8b629695fa3542b6f6ecf15f0db19975d9ebe7c85af17f53d2e284a1d3e63ac41032a698017b5a4b65aabdd0f826b6c494d1183957c70d9cd10f53a077956697bae5bda993b9a55c205896a55c821eaf53e32a87d2d82172e1cfe27cb53c8fb8cf254070418b5e88ae4028dbdae734ab521d29c487dc2c333ce790a119c7ba5f0b5bd27518f4d596809671f481b12f479472c107267a0e46a75a54bd2611ed88dcc0e9b1eb6adf1276da2374f8b5a1bd96d28bd8626c15e57f178693f9cacc804017a01832ffc965612ab4ea368c83ec9ffc33451747cdef1a069090843941becafd4ed2be00da3e440b85b5d7944309ff687c444fcf9502f8bf676c17c6a80d32d116ca51d09e6c6637b64fc3215a95e446f19bfc9855ea023eb04b1f49db372004b1e09fa53c0d54ec5796d3b6514c1ada2d0a262dca8d7ef120e874c0c76badfb518b1268aa22ba37404d1e41d0979f52a697ac44c4cec4a27dda91537ba7bffbacc87489b478fe87425616a6d0c305ba5eb7cee01b93c94f430565524a8a1bfa11f267623af554b73385378218b1e754c304d5c1e5a8f9b8c28e2cdef84e342fa061d410fb155be0355417ea05bcba9cf16e13991749a3e510aac02d0a5473ceddd43c1e31eba629f2435b221d2f02f8a35c861e4d295e837dddd21754cdae039cc37ee64a6ea2eb7d62268c9cf80d3aea324dd8abd00bce853b58fc5d1aafc54e9f3d67f4952f6bfe39c05ec733a00ba10c26df9bd8bdd09347360719526d5845b0c2a9104b5e80583cbcbf10dde7e160d91cc421d296d8fc16b0cfcf2a3c11cfdda11186854cea64d63697e9d997404c04f5eb5b730d952e05f9b9c5ef6030e94c1e6d3d3af8d35aea7ec2e06f374d1cac4aed849eda099157d3f95f39683010a3aab8e39687957c4718ea048e02a89cc382423c24544d1364f46ae27c5d6b338916604994331312c99637140f0d2aa0ffd4ed2186738b1aa0d61a5f4b6bfa02beae6619c0d4bad0cbfadd7129f782b7ada175c56baa9218777efab3b655ee5b9fb54a4e143ed6d3ada480225e26ed59d6e0fd4751a10d934748c21ab0d266b67c99602e12ecc6d6acd10b7a51b480647c59a3d314c215e4a47c5c9d8598587cd581bd433295f0557a5ffd6d6f67d4e7cb7de1c6c180b3fab71ac6c10a4661e917449292942148468d9665f015f5d7aad74a5aa9e9c0f87e3782332e1318b24051586a637518a014dae8df1dac3c4417312f5592ad03a8d5b3cd28ba85e6f8f7c6a089e2aec501ad0ec25b8362b047f4dcc18781ca5f90fbb474c4b9187813dbf8e8a573883568b4b0bc83775a49da06115b19f7d9f489c5bb99b80793c114b887c40aea523d1eefc1c1fc9dbf71d5afc70aabc4865b935359d8fcc29656a193e713c72ff255ad4c02f1381835b985f18d056400af2f28ba21d2196a6f595248fbb246d4272c1907ade23d9403cd7e3d1bdc5e93d9121874975b7b445bcd7b4b8a1feafa77e76b2bf64fd87903f4a2a6e2b333971ad9486c8899ae34f1cfb4f545ad147e7af185bd09523384ae6e3da00f14e44a3bf414fc69013c2e70c716c38eb9b08a5204060d17a3c2f10ec912026eac62df8d14dd872e0cc4ff4e823bb2cb2eef75ba50e9a80b944d52eb25b7ca514708584991b86b822635d4567eaf27f297663e694894cc4740ef6377b06c23bbfe77028943842e8cb5af2e483f502cdad0aea2eccf050bb9ed20feacff35fedb6a73a5115f5115519569831269580fe4131c5c73ece1a84a3c91becb5f111107d43c36fb36bbbda253cd436addd0524b499306995415dca119f7b29a0b25ad9036857608541c9792c7be47be80b26d3a8ed2277fb4fad37fa7bf9ae58f4a65539b6c14b7062c5db08316b25c6fe97c7d77ae0f43cd97cf80d4ed6da63fc418ae02bf4f1e0796693125f9c3c52d531c176fd6f65188e9de9fe255f1159d24cbe7ad30c39cc29dca690b8a60e9f0bfb08afcd624056cd8c070904a71aecacdcdb0c1e157e74d2ef85db1149a8d146d35ac628e05c53d099dc8165f2ed466ad74cd1eba59ae1bdcbdb8969b71b52a1997b2039a47171e004e97fcc9ecbc7b890dd2987518021ef14d655908af4a86ff0c751bff45242fa67c4f4bc77a36b36a54e79d12185c528154f403da51df608d83d873fb86b498aed1878beaa91afdfed8d78cf5cd18741dbe0576c93e674d9d02eea81b739ef2f6a2665cfd3904b74508e0c056f174ef3442aeda9d86630fbd6ebb14b2eefcd5ade8a602ec8447953da6dd27dff00df336773bcc58c571c35c7344647c063de060b90141a5dd5952f3c0fe09840fe94c787883cdf0d261b2a9cfa926b49c6a2d184fbb1f9bb75dd588ce645a982ce430b16628089d3ff052357e35977562a7f6cdd7fe22fe3240c44c25c823eebb1af3eb97ae8b680b4b6b76f25da8977d42e826380c37db0ee0265797b72a1dd994f5c1167a8318bb90fd4d62ae74bd6a96459deefb77a900e786a71314cf30dfb270f7b0e7fad535a091dacd832cc81739b204935d8b59a18135d01ed2a665ea88210e95367c77bbe9b0cf8d8e914ca0808198c8d920c5b46eb27cdab595d1207d6f45e3fe1442ded870bdd20015ae89e0677cec1ddae004fbfa239b7a0da178892c4ffdc99ca12053cef193454a11326fadc07a110c30f161cf09bb4094b7245fbf109c8a0b11574be8dc5e28a8812097e620e9f310af78514b9782c1e4d45b86cb01ae8081b79bad78c9ce02c292141a824af7624160f05c53dd5034f28f7696b243a9cfb0c62065a0a1c66f755d0117a3c4b17bf0d4d72c077973748775989163f111cb6e46ceba0efcb4210b12a0cb534309e8929412ae00274c75be20c6e6ff612a8737a675bec293df9efc569d6bd2f79ddf42ffc23595a88beb29240b5e9f62254ae4357d2d85678749a23bf921454df282fcaed83dbf2c23ad348cb6fb79b224b0c6c234fc6f1e0fb4fcbeac3f5491b18c916b6c647f2e9827f2d48fdd812922686008f41f318652580bda2ab8a01781012f0893abfc1073e6f909b3d1e341f275154c7833a2924ab1be6b445ba146c1da3be9325bb1a3f4e89056bffe0dd90daef12c6cffd27286783c0e74c1c246e1b3113418919b4e753d7c334c2f9bc18354d60774f40e7d477a31461003f6aa6d782f96df446e4f435ab00f632e4c064ac2bf57d2b9af3a2541c8e6744b40b898f1664650d3c74f04b6c4a43ed1b5315799594179f061c9aa996881c03ade76665a74fcf50a6060478a33c1f8724a1bd782adb03674f83e18e8f6f842e440a734ea155c3c97e6d5f81d8789f2ece7c2a60d0e68f39d046286194d37ef3e3dea8b3d110f37f952ca7dc1ea12d321a697c16354b306765a1a320723b409faa3f97ac4c666fb75b82c488aa43c67d2b34a5d11b645c14ff5436a53be448826f03a15557f3a169c237b4fe14ca428891424571dfa7bfbb93009c02bbf2feeb948647561706540d825c6744fa293a4c5e8953babccd7603a7c415eee5e1b6fcb3fb7b5029b8971d7321e3338e079240fc4334beaeb9e86f89026ee786cb455f96966ccc7a4f3551832adcbe3a1c320d311ca0b88a2ab63d5d1e8b6308a81d1de0df1831a3f2705c3174349349deb40363bf574af20c1038dd1caf98c296ea318789db50a45116bf8737496ae7fdd785bc37d17f9eb83f0d16c9128c5808d54806dcbfe700e376c1af7899a33b5017ad5c3b335cf880cac0d2d3c8e8c35f2e9b4dd715d6aaba8ee92d12231b2b27a07ff66665373a4370413b6be1a76b7cc23ffe79dfbd05425046e2e322dfedee71dff1ab5e29cda9507d86d3c194cdb619fd037e4cf21b086b34c6d1df8b0b593d4c4da4ccc41f14d93611d882b053fb6fd9e266f99dd8889950de9bc22e365b46e3f283a65658f4bf8714b9dceca6d4ffbe788de83ec184dc4db8cd9c092d2d922f56d284c6a806d46712857a968d97fca324a3a2749b2612a72f4b21d852127d2d4e9a98ce0df3ca8f17b64095b66a8b62bc3fc28cff1d25ff2d4b0c61b0711f4409e4a083bc9fe05ef2192be8bf804ad02e047c59df266fe59d523cf28bc284167e95d97dd2100c0051571f919678fa0091ddc1304a387983cdd6e31d7505756148b87df15535e3569be0a7973b192ca46c5189e9086dcee5c2f33f7ef19c32a0e9470f20dcad6f38be8f9fd820b1464e8caef1796aae3ace53870cbee45540fe48ce3550cacf7d7dcced0af8cc4b0097a43be003f08423d54c091439ee31d606a9ca4bbcbb2b8e85be6ada63381eed28c1a0e00e3a5aa6965429ed9c8eb5fd8d0de85fcdd8c278f37d915eaf57939de135e4c998089ee2b42602c5abc56e35e69368092ec7ecfc57029b5d55e41d4f3122324996b3c5465e17f1859125f648623c8dcf7420a51549588cf094229f466fefa5886da000f992acdfa8e15b21d6cd7b9cded33dee06f3ebfc5e8fd38fe04a109812c39c2f7738fc5b728f6509194bda5976941bc6570e3eb85d8064d224c7b4238d8402571abe4d04f67bd25dc29ba4d0769e30931b431d6f8e4decfbb0bee9c617d52545cbef87a92640909cf01f4c769745f8319ee70372bfff5cc99d36053e2bc4724070df4a09542b2d7b85c9208270085e490d0f0dfcdb14118dee0a594fed00e591e5b31771d065d78919f67d44d2a1c1419f5ab5b55eed4c1397162b2eb140593934ffc80b798c72bd6adfba7442c0e6d3bd846e416d5aebe7aef827f2f198ba8e412723e1d01d4a69c7cd7f1ad7574bd3f7f3d0d5ca5863532794b6109eb952a766a539153c0c30a1189acde0d5808c5fee2f35d91b99d50e90414edf67ea9fd795113962037e5f11f602689a2afb500df7baaea3f827964b488577616cd5ac15931fd9a1b76e373e814b1c40bb04463239d5359e36f9e401e8196dd8117161e536560e7d6f817ccca4be4d8c8f40a57666d3a4b9da837837b9b79f83373cdf2609b4dc37e3d76ab776f0c05a01e5653fb4c7ec01adee7e013a4b154fa1e83e8f1c1e314e7ef1f57fa88049676c63fe683315f991a6d12e88498567906a4d65eb98eb6d201d1000351a6b44cfe2e066ec37508ef5a1b43b070b1fb50c1824c6867126a864e26eb41ad4b59c425987e75c09d339541514befa716d9a6369e140af62c01592018f3f4538aee330ef0a984b3a1fd2057a3e073ea1639f56176ecdd735bf47c05b77a755306edfd8b7fd310af3e3503c03c280b51c63887a2dcc2a1f4952cfcce71497c98e99281dc8667126c026d52f453bdc89a4e0bfb25966f2635326c4727ecbfdacd3fec5213371c64658ac81f64c04d77d70fc102788fa8a83069ffc77245c038513d10282966ecd2cb4aa94340ad796fea93ff19728dbce9e1f0f1b8985a45fce8d265f6b5ecb457d82fe6a826723c93d32172dbc38f48c9acb855b6d6781eac751bf669f857d8e7ca778a8cc94140079267d3d5fb2fc5b648fe1e07e42b35dd357f307e6c537bedb0e9ab69436dad554d379f85e6c990270bb8f7aa4d35f5d72a5642b0ad4b315a6baf23a8bb65cb157167c768556a912dec1c5d3b7caf9cc178c85babe39e056af56dc6b4253a22772589b2a20e5847be7f0390e40e9d42017a55879966e5c8aac8dd62414e4b3a267baec463a62287d8db5b6ac07a9ef0ad2c5359da525549817a7bcaedcbfc095e6ff1b0cdb9509f2b609b3365b6baca1eae2be3009868bb4ab8fa59d5b82c537f6a6ea206c62837bad61435d0eee9e5ac3083bed2c95d5028e3feca24cdec9721643097a9f52448ce1147f28305539ee439a35e0b8d34b0bd9056abedf97846dcf0d5d3a92f1dd16c8dbde9244f09cf957de42212202f87bf3f8d55870650e6a2eb3df2595246847c5adf11dd310e7e47b1678f7fbf8b6ed070918ddf73f1924692c3c8571d4f01c5ef9b1300cf1746007356fc5437c87667e91a4d6d0a4f9353fff79f48bb87d12cf0938f04922afc12b3229cdce71c016d21a2eb1e3252a39fc69418f8b2c1dffd0c83056064be2d57e81c4c61d85f6598eaa7be743a3d8814337a9f9edc2edc2d73917b1a818d461d949faa1a6b039de8e15985f67c4fe151e3a045f13700ebe79e858f8e6b1fd2a43375bea9f47785c54f62ea2f494f0e815ba314bf1c67d5dce2114440d839041200d9c8d39616a8f3d207ba65f0d563a7794b9599b98b288d86f88d62c2cfd6134c73e397d8af437c2a8347db3625c00c109639f87df8fd64b12b3a6ad392cce1218964a118d449b37161b3085fd062bdbae714dd7e5d645700ed0cf6f964b29a5ee4fd291ff78a63d740d996312a83d2d821cd59bb7db76eb380beaed000bb65c70de568a1fb597d8e8bfdebe0d04f56d4cd14a87844e6226291b86879829029ba6d313217db1bf046ec47b5ee8033290aecdb9548a903cd70e721952b74c85857743b7210923785076c377001fd9437e2933b02267b392850d4c83f8cbabee10fd3f5f66f79f9dd85edc0ea65567f22d188cfe624c9a41e836c5438f174adfc46ae47483eab510a17b64c8e8b59dc1467a9241ccff8878b32c31c6a5204727ec1dda1ab7cefb825afad28345c5921cc09d795eabd915ee1fa0697088b76a08589291fee1da553cf001ea5f3bf960443003af8dcf5009d54df40dde597d415f908f4cb795cb4bcfac7b86c380edc1b587e0ec8d3af3a7eafbef9f23018b29e301c4cab8259ea367b10f90643f789fb0042f7ed4403e9438a0ccb49679064550259577f5783ed749ac579f2a74db17fb34894add8cbabb368ad5eb050d214cb33757506b9658f15f976304b208b3122fee720278e2d1be2f13a78d0aec46236a8102e1d3ab2910548aff2180ebd3088123481863d880acbef35ca3865e64feeb5fbb7eac5e76d884a2db7d6b1c4e7d12d9dcc8c319bb442b812e4fb215e5ef59693e63b30c9ee783d740f1c832c4dd3c2bd63aaf7f645d35ee56881fceb5715411376c48a71bdf45da4599925a676aed5437e1570c3f23c67666aef4d8a07b059d9bd97b05625408ca84556f45218f6bf2403cc4240d583c4c4c306242bf7af2655e805bcdab7cee3be36580fc02917a30da5497dfd3efc3057ca769d6c4c07ed47383424291c84825094a1bd94ddd4972ea3a6d07c0e2bede50a5c943c68307ed7e4d6ec6daa1f4a546da72cdae1324ef217c623261b054bd578f8a0976426ce372325436158c3c7859a63718ca1391c46a8996c36d8ddbdff392f33a35f564ae89e71b17c99ecb91d7597536994ac1a661785464f351347350168a567d4d6d277dd3f3bce5dea8b637512a54f5168ee788abc05d229dc286a14704c563940e0a39d22765141360f616825b6f69de0648b847a8b27352d8fb8b9fee524a437f2ced5f1d48111044a3eb7028a2c7a2873a5974a79a55caf81d92c6dfae0d71692f260fe7bcb655179272da0cc7e7f5eacecf16a928d99a004261389bc5f67eea802a402c375cdb95836e74acebeab5dbe3ddaab594b690d49574f1c5a8af76a71d9a33aeccf5b0ee873da3ae99d2f116faa0ec85d64230ac0b6507fbcd7d0989bf549f0e0abf66d67c7e25a7dc19c4b4bcf6c9be2a94b62128f087fe52e11533c30224be9f6b925dff00f7464ce784b2730d494c2bb695543e7fd48542ebc7b9b4656a39c1db6fd8d3302ad6a4644803531d29b86c1358d5255c09d37fd3dc4d0983a98750cab78a8e934dac048ddea738aed49eb445783a22d2971fb7e6407f4ed167be8a3148077803b36e74a40f156bfc8012a2976c3de4660176f4952182858c7dc45c70b5eb89ad8fbaa82747333152fdc64481a0f3f6a4e240b6ff3bda82ca19a2604ad1fb6773c86f26b138d1d5da4e0365c8f2a0854dc99dfa42f1fc4e44495800b7608b5a3bfc1b61afe5df8b2f0b758c77ce83345006d2e333892a5f9372f4142a92c75237949512910721227fd8e54651b7db48d0b30305102ad4c17d83ef2a4a7819c8578ed1962bccc7ab433da1979133e390f27b6bb4f3150feebd5ddbe23b354dbb89dc5b4f924b8c89c7732d289b52924432437a5a128a0404c1a94e83dde01c23e54acd0323c1a1ab03f3305f4d8db2dbd9c6f10f5bb5ffca88fee9e6cd09170e74a796257bdc2fed4e3fb30c0413034b2ff39e66d05f1744be377ad6830a0afa5ecde1ec85d1b14e4aa0bd998bc2073f6464bff5b532d15aa6865f468fe60e5b3734d4b9c6b5e3d5297abcc28accc2c0a82bbb385157762476d4124642f565646f3b89df33026d8a3a7205a514e599c7a9c2bafff29c18ee6fc4f978a7956b813615c72bbe49be0eab3a13905125cc272b66b6d74cf7392f958cdda7c6dd1fc5678fd545ec26ca11ebb1fa0d704cb3869371edba3ffca24fd3daa87857983c8f966333478dcd069c7b19e0837561cbc6cf51bfd93dcb7b5680b257bb5994fc054e798549ae0b631d73cbf6298336c3a25671e52c056eafe2ace17c707284348652a858a7181c6649e49043d6dc66bfadfd17d736fdcc7776e240949cf480863cba0d41cdd997216776972299e6c920994caaa881df582f5e99f5364fe6dcc5e72fc25340228419465fecb14fa54a64d1d51aecf3e466876c116bd6c2add380c04467742ff591eeafcc53f9804231bdc8ec73dffe9858be36af53e33630060bd8937ac5a8e65ad32cb2c5a657015d8d605da258da9f2ab8fc1bac8ddb74540a566f6eeee04f7c7214aaddf5346cf41dee604ae99c244f19d8e8ab4e7206a5347ac70574099ae5c5244ac0c37780500b6ccf4da86bc5fbdf607872cc743850fa30cd1df12e0dff1b69f8b08f58aea4f7ccdf78714bd47495b9511087f83f1191c04e227432c30222b842dd272d9a4a908dfcdcd733defe14cafb711df175a9e40eb56ab33f8804ee5bb9a57b326d70af458dd441c57bd21350ffb794c90bdfaacce571f3d3e3182c42c6af1c7cdcc0e0f021943098b2952dbef2b445b485a567a15fb4460d589c288674eb484ffeda71b2f187b04930c8a485076c797edac23d012742658c8ba29bf170b8a8eac147a492b1aaa7454956fca6480c0a13668a62368758507dfd82d7edfbcf9c993163a50a330fe59580ecb8cee2c8e9798b708fad86e6bc9dbf23ad55c63d9366284beeb664038","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
