<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"22712f8c357b341461db87794b9218a30141c8303b591e38922f2524238f103e48c263670a7ed8cfd8f0170cada8d3168148332989f17395c82b5203d190b29e30b5ca0027dd5ebb86cd8cde31d098571b12962fcf073e7c862cf78cd42db672e4272563b551098a1ea66f33c01cee03f8b87c96128430d78c1511ca93d036d4ce61151dcb58d34d8dd5a9a46469862d85676564d4233f0bc80431b29fa0e33ce999666180271495698cd27245297132d114b2fd0e3b5cc1e11e4e1dbd851536e647ff57f967567a0b4d149e67ac53689286f69d0643b48fc34a102324ace8b66e12fb22c309302892ba55b96b430db39b5eebb171cad36409e95a1cd418d8e538cfffc2eaa77b6918a6d01c6c9511e09114a4dfac30e4841641c4d756d1116b3f7a36c5365e13c499e9d4593763327e8861e656913d35b6afed48184fabe15608b83e28e8fcaaabe3c2a721cc71101fb1c763508226373fb63311705f4407c29a688438df6d1221b7b6032ab2843cf6ed498bc940b18005213039ccd1fdd686d4bc777da66a5089cca56a7cf5a8f5167f19f295298ad6e2c349392fbef0a69e155e9b4113deef2780c2ae47f30248b7e17877fa7573f53bd080c39a25155f60ac82b5e4109a22df47d5672fc8c762eb1145fb9be8ca13b56f797a2387c606f861567d5e46dd9dc0fefb5bbb84f96d167e96babd89b29c53b2df9929cb3d55c6a38f199021e2961c501962b3eb1daa2917b22a257c86919da801962b7dcef6e141a917c418f344b1818f54030d997e3a12aedd1b7eba5db7aca1922006b0f4664417f8f013284d541b6afbe92e608130460d3da1fdacbddec48594573209205a0b8cb1aabe3e6b6c8cf81af72cfe5ff1622f901f695a7e7146ddb9c411611931ee0ee908726d2ab159a6999b6cd24180c512dffc9c4ffa55c6400d30f69c179824b5b7eb613deb0b92845e996781754d906f36715b1a86540a4e23564f80a33fb8f8ba2fc87b0b2f5f25f5e246fd1bb69542760ebf52f5e7bc4c4419c75497a625463794325d316d9104f87b3947f646e6a0deef12875d65b343fe9d19306adb21a7d367f55780e49d726c76d73ab98f3b5ae43007d7564e7909d4322370b7b0c66842a6d8dc3821337044b535634e6a30d3f1b9c51a0d72d2625be54b641cd2ffedc63e831f262c752aec7bb770cee9abd5c9091087d99511b6e354e13a7e8688fa672d636acda09ba5c71a9d5b573349798e3773dc009354c019fd4acf4d8f38afabcf7f96d44a4a8228720dfd80d2dea3cdbb8811c50f8e8954f381338a8289c68328207e147f16d564e86bc274a152814d7f74138edc9ca9cdd0a95fbfb5ad28c048b61e64577ca1d6d7c1aeb57a88eed6af0da72d7acebc3b17caaaaafa08cefe946e265b8d5dad48d3044539e80a8b4040c9cc6991be8b01545dde68aa588d0954cd973072d27490ea978e00a3c713259f500df3820305a718b65f7414065c0b0ba674931b80fa0ddb569186d64b4d97a633da0a19285b0a976593e52d4f5aeac9d311d0a00e281054e0db5b2ba4e6b203312eaa45eee44144b546c5b633aba9a43334eec6ddd28f55b41f13affb1dd5078479158c79d7af009da3ed2430d9459a29f97518e13ccca71313dcc5f8f48bc16fd710c6527e8a8fcb15a169055d9a21fa8151d5093af9ce84fe650810a7ca2085b90a16f126c10d62d982f2a08caeeebd524a771d2dbb2f49767f9dcd2b67afeeb0a870ce083161a3d5c2ecc3c270450e5fbb56b733a998ed5e4a36de51516881464416b374da52fa84f2999c5aec2cb104158320e1b8dc1ac9608f6234303bb733f98d8d79effe281ea986bc7c4955324575f9a3c0f323c0f0205d616dbdb1cd31af0302e1f2ff82ee41bb4041949f09f61743b8634a76f94617a1386904ae48296db4d562a98e41b4fbd1d31064f9300d1d4efec6f4842139e31e8f15ff8566486a88a5c4f2565f617eb1de9ebd25381fedb8955574922d1622b5e23dd79582acdab55c7c88d08d14a692aa4a96212f4f2cd43cfa6eceb7f6c10d611f4fc065a89c9cbf28d16a7483a35c3e48784835b7218bd5db574b774ff81ff8f84c1a36f27996bdd5b68264061a225dab42565c71df1a892f56b18c6ec7520e568e64d2e10bd2ddabfdd8d3ec1c43eda27281009b116e0c51662ed55cce5a829bab4a574f2c3e760da64d5e252a7628a9158b455fcb7e4425f87a657306b8614dfd44f0279039274f43f7379a90f156acf7231a3d3400e8fdb9330d5ee07a9b11b3b0756bcf6fbd539d17183d4132af31dcf861e414543151152fd347bc9afb4651718af6f58aee5e44fd274854135f4e7d8ad09e8dff86840d0683c623c7c900d6d0a810d6b30a82eb34f8bd69480851b4e107512ecbfe8ed1d313e3693b190790964b60045e9842475dcae965c5b0ffa192350e2b26fef822ffc03a8dc1c433af1579a38f34ac6cf3079f44e0d06a79868878de4510309099819386ce40b65a1bf17989b4bea9f6cfc290cafec2a67e8574a2a7f18530e74524c526f7b249113ee38fc299480de8669168a9b01afd7e3c3dc3e4ad2faeabddc8eee3aecee7d2fa47844bc6febe6d935a7bd8041229a5b303e5a1d07b64a2c3d00d489ee1fb837673cb715dd953026cb617fde84776cb117979f9c424691f57ac5c881c8684618d4980e10980b16c86bd3a8b8c80db56b94ca1a25e4b93ee7839062796ef59a1a59f262f77b2cbfbf43adfd808d76ea97c547d59f4b42cfa2b45d883a4af17219d6736af5ca847aeb0b3fa72866b48b66e74de4a7e32f76c9cfb962d70929b03e748da3ea23e5ef56b9fa9cc3ca9e053d9beb0b1cf86d7d59e48aeb7b3d5c4348ab8b12db6b9ea601fc2c6181ce39aa2844e82d97105edf62c7a83bbdfc05e6463cee0ab2e1efbbc525a9f00db5c5cfdba64e0c6590519ec0a252df79da9ecf7e97e027d0f1b8ed106011bc17eefed5d6ef198c7866c5091ac74b314d168d5d2aba8dc93dee46c85df9bf3f02ca91239ac419073e94653b0bb7cd9f8d660d6af8949415694fe05d6e065ea75af32970727c7ea0972e4811d55ac79181d3d4e6fb434a6640ce445e4275228bcf52bf8812281c77bf51d82f5728bda867622b2aef9c3d5bb86ba9b3a2332d072947c997ca79811620d5d0718a2ab12c67aed9121e63d13d68a5c4cb3f48ab88dab384188184a243bdc942cdf87a1bf8fe007ed21a5cd9ae3818e8c23054b242961f20ce9ae1a7f736c3c2439ff6de8f2f9f11b3f95c17d1dc767c51e217165b05674ac1e837d77f8f42dd81a2bb944fae621ed549de6495ad96a98d42855d9bf8277af8c36f3e1aadc75b7d42c53006c1564a77ef515997bb6525410dafc08bac32d6b9b2c5c93d4f7a24a536e45579ddbb5f0ac53dd02edfdee5e596fd90afc25f1d2dedb23dd97dcbd244db6693230002836c909e9f0bc338caca5000ccbd18df91bce0f7023917d903757b378cc93c658724ede7badae2fa4a3c774a9de4ddc98e5c11c31e237650a266e38dd808937e330e8572eaf726ffe558091c2c247fa82766f3df45115578f11fa1879a8a9ac05a76e768b89bba2f86bd60cc6c7b2f5983ebf5e16b95164ccc6f234f45ca995f89560251c16bd6b0408fd015ce40f0004836063e740b0abd73e704599f46ca3c1f88d6a9e76d4d6ef2c8a25f58f9bcfbf17e1b508c6be2269dc9598f4b4362d2f670050dff1800cf21b50584fef3409f00e795639bf399bb00e401103174b4f035eeb883ed5ed9911cc42108a26690483494e65c678e22a35e3166729c98ff360871182905f6d766684967bba6f3386c3732972b1a87375d87df41d83cccb0e2c732c312f83e11f97074fed6a47463a492df8ed45c50d3137694253271ba79e1055b49d9f47a4c516c81faed53bc617c0438972d5dfe6a68e64bbc68c287022bccafa329105462b3314d6a02a91c8c90b5efddb7a86bfb34ba95c01c844d9f039844a6d925b7a65480fbfb67e659161a44aa144f0fe9df09803837b840c385be4a7c20fd68f10ff5870d3193b798b0a0121123c61b51df023ec1569f489d44595e982fe27829a492dd73ff191d64ebe1f02c37b1942d18517708696f1f0bf9b5979ff51f7f70b11880ee1f625f26a83217d51fca585a410e2ff86bf5c7f1f4779a09f44b832b2065b74adb3d8c3dc6e1acac41a3faf3c3d3dbe1a23cd7284ffa5af8ff57b1cf6c80f24fe57884e06ac45f2cbf6eb7c74c8afa563831408b9893fbf78c5fd5b62c77af4d66a8a9b1c9f77e0f30dac5d9c61b4238977471428547f6d9fc50dbdf73a642c2bf7517a0937fc9a6d6a8294eeff2a50b22f27e82aa0794bc7d1b22a5ef18003069d5f0ef69d2ef2c6f5e7d9e99c76b865b1195659729e2276522e78338c61133a1f041967ee32b2497525473740979b666cc6e6005eb8ff2daa218ccf32bb51ea03a6fb8b1bdb95394d51f5ee8d7b2d3bdb5e03d073dc683b51b7a4a3344163d92128cd2bcf56c26759fd9ac0457cf13b02b27ab1dfb4464c894f1fb229f6459a40f7b87388779e70276c04860615190663dd6c21fdf190bfb84452082f86c32e4441c9473dfed55ff7d01ac2aacafbe23618e86be06fd3b69ac5f1477f7ecaf6520ac8877a38991799590732de0d192104199cb87856431c554306906ea16965d6fd079ef4344086a0022b33ba8049bd5d28cbefbbbe2426df07256f42a46e0ffb3054a110ea914e8b0ba7676d22d589159d18d53b89c8ec467fd85b32d779d33322861e0958d3716b12ae802e810a9231696cc393e6c35c458ae2c755103efdcd89bd22690584024a7f048b34080ebb034afeedaa7b48eea5300ac9b53d15677e93fcac852dccecdb9f480f5b9bab0ac7669d69f1e5ada9f55070c2dc383edd6cd3bfbfe584eedc23070911bbe1c81012b2e9d1d4a28bff5601fc8fbfb6d2f1119f5b962372437abe91cd5e9841ab2c57e5f561973a45983e143d06ba057f19fd3b729dd964ef0e88e3c3a555c72860d68d2bc63a20ca2b316a994a2868f39b334063f7138a9ecf39ab284902d001043eb088c0fb59098fc3dd348760d6ec97308cd550a5f1e5e2697c8bf472c35a6c48ffbfbb7c0bd21f889e0e342f20077e9a6cbfee26cd779dbe1f233e6f085570e2efe2229d7a7c620a6f77d95474a0f644f5b04ebe0106586387ae9b011183d2ebec4c570caf66be1687a16298a3823221cc4adcb886f7f198326a0112475154ac052e490280160b833d54e9d2a04c690c85d463304ff2ef8218c4e23fb661df01e633ab351cc0d08b1fe4397e5387af495ec790c0c136799c938612bb346805d3256d15e2740876ba7cdf38e16b1dc57bd7d1d3da7062737815e2ed54bc9622b46e63a00d4b7ede46b1a590248e4a4877a2f955cf9873cbf131635338df3862d78348397717e3f05710a3006ae1e9c569e038fb49fd3dace70a73009e884eb5cddfedf49f7ce4bdc39c904d40eac885762b5edcba7c1c671661790eb270ac3d43bbdbc7ae239335f659fc89b60a6a2abb4bc204b4de278bf89919b826f3ebecb0214104b3165ae4dd1f4286c63e7233304776c5df6045843af6447b8c45af7f2767f4c98e138c69ac3ab6e3add970531ceda5ef3843153e691335c22d8d790ba9c6c5ecafad4a0148099f8ba6defb9d748026c975eeb2a284c6f2dd239ec9e44a9800b8afd4fc7de06c88d675c782b2bdb9ef93554b36b80a6204e6d99f0184adc0de8d292534e03eb6c6fa33be5ca1516a9d10873d1d98ce9d82570c0b7c6db5b7338074df3941d4a131a27b41dc91b2acfca0eafc950c63f24ae55bbbfcb1c35c0106198c5ae6b1d9224128b18c8c55569f0a11a13558c9ea594bf6c8a5aa94cd5a5c6a126aa7cb1af91e6dc9ad388cafa306bbdee92335fb9accfb46e8521bdf1544cecd6b389e83a62c9cd19ba5fa898b21a08e7c0d853cafb70c4798ba9ded3a285cfd652d574c4d9c66cc4e5019a37acd5b774d1a7f7437c068a9b40b92580f6bbf1148720bfb6437b4fa98b1dbde452ed9f4272fd960f73ca19a25dea9c95313a843ee5f04ddead0b590b8a7bafe91189ca54a7512c9bc1db0e373d52101561cb108e13ddce878732dba9758e17a68ce85f80fbf3605a94913d5ef55a07716e027b6165840483f4583a2ecde98886254344137bd7dec88824b19535d35b592a863c1d9661f1707426983889b4e43531d903b3215ee9dc47271ed4df24ad2eb9795c7481ad32f99c1dd0777f273c2d9d0eb243aa2e13d1fa1c1303dc39d85c9e20851a6d96c99f5f0a117a2bec3c4db08c3dd3c83a3e86c15fc7ceac7c2fd2da8cb2c816000fdcf00ec61a18b0f61119759c84ad2de69172bf8a4a342c42a01e70d7bb17fcdf50fe45dcf496b705d2adb04c0d32a6bb03fbb267cc5ac53f5bffdfd14c44285c485d310caf31510393e4de0d20b63f9dee53b5473c45bd14945d8ac393cf1b7e22109a1de3536c0411354aef0c6f49c1afc620f9d6ee85621f134aee6189101e4c382cecaee24a6745b029b78afc76e8a6a53466f795b62997ad751f4524edf656845be3892583f0111b3dc0b0f957d8dbb670bf4c6c8615755ce2bfbe115e9fd6cb1f64c1ead7272663c0cec23c28d5e323bc79da74dd079e06f10eabb1a86b2f8cd8674edf01a7bf256ee01a5a72186a82dadcdfb6b7ccc58620ad0ce7ab683bdd0d0c6e8bb9be079dce85621419d7a8288c04e0a22e1ddf1d63edb6b90b93b15036e2f38c50e1b52eb2df77437d4b697308b0ec2536b07e43528e55b0528c51d0b7d6c73680f33d20be1fe0f7a0122d68f99b0cf471dd0c4299a63031886e36b7abe6fc7cede1e2af25a074d00ac3e4b1d5c8731c35080cb9768ccb8005e559164d7febac3bcd28b2e65d7d930e7763f15415b6a3809befcfc26d7d9175ace00a63c88956c36379e16b8872a2d498674e6afd618ed8d910d360b5f79767acde536d0b358a64c7449b90007a47543e45030d76b4b38d41a12445f0c8fb4bf59604115ddf720ce0a764f3291af8009a7ae36ca0dabfe249200d4032f97958495a6dfbb60d75587141e28c3a12d3576d20eab97199096c3f6b388ae5a0b56a408989b6096d9e3f9d5b5c1634419beaedf319e5171a891a051a9f97460f0243933ef65a641b23e90ccc71f5aeb621c4e4fa14b88a0732ae55ddeac829777431a02beef0b956b4e956e2eaa760f84e3644cea11acd06834e4260596021affe4ae2c6b0f72a0529e1597bfa288343847e609e3bf51877ec5f193ec460cb01192e4db4c9fbbfadc8237af2dabe98c24fe3633956d1e36a1ca5bbd9a7e3840f3cf97f6af7c4198b9c1b63ca5f52e38cc0667a6e3ec644baa8b4f1de41b1401dec3228f5f577b50c341732a8f0116db3efbfb6bbf6b9547104ac7907885c21fed0dcebb7a92081409f64c010794df91d9af60012e1686aff4b6c07707c692c117aa8a3ba76ae0dbc6f148fd17fd35a7ea4960f000ddd7c82ed8f27bd204ebb8eb7948ec3fe40b3dfc0131ae38dad79a79a76293dfa6f89394510c4bdcd586e6bc830d3a911754d68c35219bee63ec093f45601a643bf051d996fd12fabf81088e63021f6a65ca08f93e8e9b0814791c81ed8a44267c9a7d760980c94b88505ac7080a9c76a5e6d93ce773aca80d8c685d0f85eeeb3fffa760811757d1c728128a4ed554ad96a22793d92ec1ce1341f8b1c3dd1e3a77ba6d1ede8c3cc09b4ca27cd3219ec31026b67196a7600ac34a3ac9be2ced6ddddbea75d04ee17a34f78f51bc7a19ffedb53a514cd20665a05c0d57c5370a7f61a99b966096e2e1f7ea0e455558c787a1eacf840dfd64684c52c95a2c0a0285811bc2d02a69245f304f136c0dcf055353903e7dee083a8ad401f5da16b7ca0f4b356b9ee1eee2e6cb37bc8ea21efdf2ca101f0ce2d886e6556da13f12e31601ca9bda2a8911f5ae624d6805bac071dcf096158cac5f9446d987094e8a7bc0bf159a2b602585ac02b98ca93a71cb18a1694af6efb97a705d79b7a85eff67bab8acbf606bf53f654a9aef0df15e0f3316474466e1b34717cd02beecdccfd0912a9b56b411e71158500149f3fd6fc047a5fc1afd1d805f4b742d47aa0132efb29c89e19c2333032012f07bd3571552a2e4172800072aa87bdf16174d7ec8c821899284d0ce86f338376a2e2c7275770162a2c1a68d163230205543af2a4a83769e780c83fa7a627809bc0072e59eb9802d025cb267eab7b83b622f10b23e3164b99cf77fd89df43a485ecc14a8be55406a720eccfc533287cba55e523b85bab4f4dba016d0129d870e2b3754053e0b00a9a5074f0c420c6f4f1dfaba607106244b955e293eb99de3fe77415c89edc50e036b33019f586fb0d9567a97bb9557128d42c16efd99ecab7789e7a3ddec99de1c031e473cdf41c5d3de6cfa0e5509fa6e118cfc6e141317d754939a6e9f94fce384c0b607c7c39f12eafd4de341f83211daad4434384a965603d5e5016c3fddf004dc7a9b6fbbc84932bd2c69bec5ce1d2ada6f824addb409411e9c09110088d2cf273a257666f0adc9400a2ea0c0644a1ae1eecb71b6be81e8683f4f2c796a2d469d8fb460c7d616e692a39d1808d4c87f23eb99bddf689ccdd1e61836c0ad08afc15c3723822c5e78839cc982c4d473f6fbb4c757b4a8cac51589bb87bcf7a83e3bdd077944df65dfb6c207fcdc3697fdec9c98c749be5981b284eea380a68ec960a2d01fa2288e33ae96d2d40f2251e033dc30a2c0a9ee525a90c71c78291e387f55959127dec40dad3d95df49921bc162ca1b0183213517da7abb5f28df14fc18f3bcd8b7b15bd6ebfbfdd8a47f4c9bed735d9affa368263efd33328be0668e5f7eac18aa9dffd61984f57ccb36bae725484d7eeb3b1cce535104d037a1cd3c1c954b5cdf4f8947c2aea9e9900628df104366d312fa55d0c55ce98bf223c5e9fe34f389b6c190e81e05fa2b0bd3dacaac2714eb498d70d38eaa665565b8bbfa9d81b4f17b7e5d97ce513c1b7c24f532742d568751f9f3f0ca6448c4716df21fefe78ac5dc8241fae029dd3b2e17cf5ed30038e76c5605705e8bdb8995e3644eeb830ca7e71f62671c42a8dd6155b226cedc7dd918c12a7063d2508633042883ec4e418b4d1b8b5a195b059d77a6699e23e4acf1b86714404e11134f50c5bc2ca87d6727d4ca34cff012a79f0d036068d711229dcccaf0c105b99950b309877394f646ee24255ef669ae0647489de2de53285b823bb8536ea50b9cf088e34e7e87bee79a4f3279c429e78b3ba4cf1131c333c766d125bf4e34831826a763fa57b1d62af56be247382653b33359fb2344a23181b6f329910a7b2e655e4ce1799cdc2f20e04c736e1a6fb498b363b747765dfbdcb29ed886af37e9c78d20767dbe6c2ab7c1c39d5d0c825bb811a7689e74a58614b1dd9fcea5985c42bf53eae3523c83f8fabe7496969293d84569d9c475b5b91b859e61bb05a6f0df05d45ffcb686196c48f803eab1586d8a3313af8811d692e1800fcbfb844daeea4b53073c50ede686b02b669543b360586039c62aeeab23b4cc0932c2d56f99dffbd5391094d690b70f4d19e4652842f47b7625c2769996a21cb47e251ebea8d1726eb6b8a3a689fd49c9372aa5c04dbc5535ba61addbe0fd5826b2919c9760f0091da17ec00683f3d6b0d4c12d846e75d92cec7349146c1b454bb9d858225b0c030fbf23e7b891ef0250e0a28624397c616307f0be2ab81265ce428c0a66b6e631189d2c0d79b89efed75bc323cfbb2cbb8f2e5e4d35f5ec0f8e0c8a909f66c0e5e722b1ce3004f4d24954ed6dded50f72f0fbc00d804b9b46a133a31061eca6ce7c845f0f719a40f011d79d4919baa671e67a4886536d6c62e187bbe0fbde1ce32a4e153bab3cc51154927ba08dd2ca153cd3330f8489a31f2670594cdbac00157440591d1a18fd1d9d62bef41fded3f961e58a2db550e3719db4fc1a08c8240c2e948a889f364e2a26b54a04668c41c4a1e5c0bca192a01d9f190bc9f60ddcc6fca2b32f0a49496b7a13ab980ca896451e13cbf1812cbe541ae91a19c4a0f928c6d98ae222f5a9bc675a1d3eeb7b6fd6813ef46a0d12d7242c25e2ddf608bfe4d2198541536fe9d86ae4c07e2328a23c1858d9676d324712dabe0bb90d2b01b922aebd846b89104a45bf2b4ab577c056f58c51dc0df9cdc1518945b04fb39fd947fa8ff623b7d81c2f3c472d186358bc5b48282619baedbcca9c39d44cedd7474ef00511888d6768af6446db78bfe84f677bee13d08c2d28395ed49ce9233158899b3cd1126ec718fa3be796198778e509beae304bce12d494aac22481ff734eb45340083f8d807a5d471c04b26190a68cf7d5d93b9d63555a2cf2f28e07d1f68a524fc26ecc7de1e71b05576f16a5281ad212853aef08fd551524acd88b7682506034be26d98423e65bbb5dffd79562097a364aee0076fe78139170b4af8106119a6772373a939014f26eae993b8761bf482a0fc3d7863940ead5b9e2b6a104d117ce4cd902b60ecbb4301aac0076cc6f169e867846f05c69c606950396c22c042dbe76193495dbc1027358637d8bccdab6904309d36d332ab0d5390b7e4112d372d6c8292ca27f9d435d0031e3a79f97478ed75432101d955971c277fe8c72d9180e79b39cab327ec36a9e175dae156796e10cb8cd248be80bf2eeacf22c8440b38d2b054e23abb0fc1e4a0dff6a6c3a19345769b33cec74e3c2d2d2ac46b2b9cbf0c6e220a5796d8ad7d835aec54864c7354d5c7c0b8e5eaf39126f10a29104c5102c94e66a839c21b6acde2991ca6d3c9faadc5a2b230c6e1358043b4b6377cf5f3a0a785a165a2834a9b4c7e863e29e7fa6161b6f5713000bc4dbd45ecb61bb66504146350985bc41fde1b15961f34168e746716ceac935433ddccdf8b4774135b60a2dbc2e50b9d99af53c607def100dfdb23c5d05689b2dd2d259612f65cf433cb1fc7d5ad090bf96c0e7c88ee5a9241e5d7327056cf707a1f38e38c468eb2e75a99e27b9729c84026ec7f641c4f5099765c0a5c0e016fec3b0f185bea2d42afe3fca4cb502552492e9b20477bc881f5c36004c513008e1ae9735f9488116303e012c9cda0b1eeff0bd20c43aac32ae2bcd11f60b11734e307cd7a092f3ade13f5322dc116267a28ee9d8514dd8b6bb6640f7273b931a8585a2fffdb2b7f8efd27c55c104b106d9faf1c9967108639afa56407a168f468232c617c136cb2a909c906823978049d40380c7af263661c19c0cb9eff6ef979fef9800a9beaa9164f66e7d23e01648e3c3294b7f2720de62a1a348477faf88257c55da77ee0fd192304c4807ccd3df008f08fcdf0db5606d3c1ca183333265026c8de4cab7985c3751bf191a58cd7e0dd391821d69ff0168d5544f66e2b2bedde51226caff9651aa43c3989df6d172ef55ebc9160e224b5af0c67448a95e5398a86f296e5fb908d0c0a0b3e5de4af4098f2e551f5cfafc2d4608b035d006f6486a50a3cf284fb5f880f436542d5563ad823ff0815374bdfc39b7aa31eca2139556c17b943f12bf5ebca7794244dff324ece6b85d4fbbb4547ccdbeefe381acf284a6fa51ca35933fd9e1cf8e714c22aa000a92848991b51ba46849b9400145022f31156fe1399c43422eb39ae1522593ec1f2c367d45f360b07b130b3b8d55fab18c1b6632cad2243fea384ecb1b1d16cf03de1cc81a73269defb4f7d6483597ca5e8da27104cb6dc35866aa053688e26a200b93781ed09eacb91d5cb464f7db0e0bbceff8a7656b365b0f9ef1f9679a14ea4cd5e36a593caae806666a04a34d2e2343ab89ccb6ecf486f7bca553f4098a7e0c9846f65b470718bc3c0721b4b6066cd466daa64a24666ff2e88217516dbd05012839e9dc82db6d6b27c814fa4e99008a281f37c6fc2c0cdaa626604c46b2d2284e3760470ae791e79e7be15b32b59b5c5e5ff0d8904140cb5ec29d931929ac10c8132c4eb97f45381116fafc9fa5492e1920897cba33db8b84b9dd265098500017706851a67ae7a6057d9415647b4294b519871d315c82980070a7d78e5787d7b17cb2486ba897572e6df893f1c363d7eaf02409ad639f85cca5bccc4bebe7924ec1460b4d1b40bc6e7bf2f0785fc109d2b03609f80ac15878d2413565c53b61066ec096ae041ccb3fcc0129eac5680827e047507f57f577dbf515870e59079a4d9cc9d7907e665dba600e6c08acbb224a7752781cb19a86057670a5df53e107c60dbbc32f6eb55f4570d2b9fa599a7447c82c2443f803a5746e11b9257f80181dcff5e0d7763aa9e0b14f6f4229303d84fc4fcbb293c16327f355ba12d2462ea5f5280eb3d963c97c3ce3a939cade4a6138f41e4439e83727611f54881820a02763d736e69b8fd0f80461f90c7c114624be72421b102ac0c26be58ef75e686204da4dae02fa5fae637b73c7735ed6e6dd0ad234077dfa6ae2821cf04ae58f95f7763ab865cf72ae86769ab013913b117e3d2648daad840128a18b17837ea3611ea2ce64e89ac1be8f843159241541b6269458a0fc2aa880edc71b50b559e32089b7daa02a0b2f0ffb2ddc30c62e421fb1b8c03eedb9bbda0b7f65a100fea61b924595a07e229fd6733b8881302c214294081f2eee23416bc2729ba67120d045209bcb44dc7edb4c628693792a9dc115a57c1aa10fc6b461996cf609fe7c5c7ff72877df9fc7cc5e209749021fb0881c7d50786d2cb216fa8e9c0e95b21aec81e747486585b093183165897186b67bbc25273dd16bf706a2b41c34667410f8f72ca379005304f57680703f671be82833878f4dd2da0d681bf4cbee681dd2b52c4039b6c9fc517bd12c5802395ca4506408e0d3478814aa66154742d7805a0e2b8e2752d78ba902188ed25f3c995f429d4cc01deb855b27adfb4c1d7c8025bd728a742eb61b8f9ae1d2264789ed1cf0364e5dd880be8e8abe69b2c84f4d08317e13a48169dd2cf63bb7352311e748f2c81e33e2304c15a6fff58c11089e3c3a4db10c0076c71cc06b2d5337813b99f0afbd8852b93d53de925d1f94ba62a65aba5c75d359ccc2d5ba64fd9a827cd32b4ee8dbdd1e29823a99297784a96712f7345cc11e662165162a6bd22b3e562262c5749aac5a946f3485deca743e7213ad54eec2a1211054f91dadb40942bed4886e5487798884b76c25bbb17c64340f87d87ffa4aa0237345a6af87d152d3b1688459b5b155db27b277c7f7abee4b9f59ae47a5a8d7d7b5f774fc451a5b0d7c2e3a9e95287118bb17477241ac15b037245fef4a29db18828e8c1ec7fa9a182978073bf5976aeca0634f5f8b91859be58a26a89c750be496cc41c5433e67ce8488217ba5d62be767d868cb3bbf5c31132a7d1d833bce08c20819234606ccffb7d3de2cbab4f7735ce5c8932c67154679c3a9ba1a6da4f91dd49802554910368c04b75de8ce6ccd0e68e8f66a8d1df36b4539f33ed26b402016a0e1253ee671a55081d67de765cbcdc75b956019ef6f55439ccadda1d2b6403ee08b9f2c62b6bcd539a71ac5d8088cfbb013769c7e0452b68b85c145d61bece7d279f16190a825231e10f1410a382e81ea723e1501c064945535b5b75855d81da5cc6b982d40f5c8333ff0ecbe5b7d95585f66271b3c2a3515538371b4ba47a9eb0b054d807dd68351895da2ce9408831bd25725f415cd01e0975def4f748baa4d2a132b64c414af25dfa55d619801dcc929a8280737fcaeb1e31ca35038f0a6a29c8b4f7d9478a60c73c55f0e5e578f8d399b121bd1a599fd09a507ba6b34ea8a199d4504f524cd1b01c1d2997c1c9d8b9fd915ef1628363cef73f9f56c4046cb31f16c0d1cf4c4e16c8ce8651d1b1b0f8a10fb335488a32737d0c70b99b8c1ca417ad960d889352249c0818a0b7944741cfc0617764d4936ac74b74c7c6fea3fff4bc87ae8ef98aeddcabc037493a2e0f1eee19c62151d319292683b4b8bc935c19685a08a49388c5c434e38c606cbd45b52fdffa8f66c6aeb2b2dea394f42859d66c8d5c8196f284f45bbd992f6b5acc8cd4edb57bdb943fa57d0439f509d8c84dca8d1f0fb6540891e6a39351a1c91eb4ee315535018e184b198455fc11bcd8325b3d7762d017e3bb6bd957f6bfc5d9b80b8d713f7488336c35ae97710f050dcfc681a1da24c55849cdd65d0b3d2a1c9b640071623f63db42c95a9b57439f296c222fcfd3a2412e231aaafbbc58cff7a8e267d51f7eee2abfe81302fd0e2a62a3c2dfa22d8c75fd58458b835c05f1c72cbf881fba2736bc99ca876ba9c2003e4ebc39b27c16142d14d3676a0dc85c0d4bae31f4050b3e8fff449a5e6cd6c2d86e776f8f705472a8df816c3db91d9c9dff4990cb446776d173e188aa7886d61acfcc34973075054eeb95a5ffac7d10c5e0062ea4a7643a4eacc2cc93a2c8000f648e929c45892b78c5a45ceeb872e122e6cd9f0d50557417a64465075ec5dc4e0c8c532555a626994d60590b04c94a4534f3b2377b7c87a3ae993075cf76f4b1af97fdb3f57b50e1eb69fc51fd01007e14d7c56792a05b9784a414df96f1de93efdd3fa1c98efee4aaa4aa215860b4326a77c3f4543a8337c17b32ee0a2c1e8542e93cf3c32d5c2070ca243c291584c860805ac1a01fbe8caa30bae781888f13ad2eae44be07e44a72d92bdee52e4fcf193b44009a38c0cd1d901e58c83d490325fbcd76b4338669ae94463769bf2fb5b8691a84c2f8c14b02960eda978f3417e63e848f71918197c4531db2fba1615ab16ce831b2911e077cffeb6882faf7dca0d6d44eb049d0833f5f9ee5068cab9bb28aee0f0c4e362234cbf08086cd209b295b5b417295dced1fedb5e8d82c16d2ea848f08d03f0c96478529b01e2a307af4ba908d8013b5bc258c7418a6227583d8bf91984c2a62354a3c53241c3600227f6f931c2bcf6ca79a6228ff75fddc96bb596c5b2ad7efba04369accda5c8dee98dc8fec3cb8003b73939140ed7aa0fe6399d6e064ab09f6b928d3c138f0f57104697a508c0e0242ce54e73a2d3a2529d47e2f9426554ddb26a6495a9e3e734b1b70a023cc20de87a6b73dafb8e3bd9578231180627940b2c3e2637b11bb2ff78ffaf1473485435cb5537a75e8ac8a9cb9848695aef09639441f82486990daea65f6df73926d2650e247b17e25543d741b6b84100ad52383c3f498bb41887079c5f31bb653fbe6cdd6ebc5a1b1e58a30e5d77409ba0ea14415ec200b99ba9c89b9297ce4e844f1fa547bc78d3d650d182398c6d4abd93044e6bafee2f724c70233bd7f76127199cdf518463f71e1d189f214ba1c3aef9d3d27e1076d5d77ee99f969bd874f553a48feb1db86af2c898092cbd46f4c8b77407ff8a3224ec6f756536bcc8e734264869dc390849956473a3227a63a17261b35910df67fae81cec03548239c290790f7ce809ce9550efce62e6ffa37292d43f636309d81d9e91a21167ecaf259bc5b5bd8c36bf0ba46592a1d81a2920b34104238ed295e91b5821c110a6293406894f06742c72ba3f05d4ed1e538fd3b73da2b0cf943547ba4a53dbe6ee168d274fd84afe366ac53a1f7537fed7bfe63919ca3377c9a12c1ca4ae331f714402856d5eb5ec912ab4bb7a0c8b0cd8a97855b4deb87c6031a1f21cfb7f8c71e2bd900e46507bc16f7d3583d7d7777580648eeeb03b1d3e04afd97cf0f6ef4253eab3d225f59178c902aa71217f13b0b8e38a173e375fba5c6afc20f0d3977898c077aa7e760d97767dcf6506173ff11e6d05130b7e013c8d966139e957a14a6a8ad599ad9d761ab6507d8e676785fff38c21efafcf44691f7405bb6218484e95217dced6166c9013ac22449d0485a74b144ffb23fdc1230435b5deca3bb0fe331065dd18a6e4bdefb29978fdc991b4fdb96786b8d6782ac99b4268d548878c52904fb269ce53c18808f1daa7edef2005c1fbd8729f3a6b8c2d09cd30b5e6953979473d39cd51bce2a8e4dcb0a248013f5d3a370faad73199427ddb87f883250e7d4031183d5d172de6c0c3af0dac3ee794606bda7955ca2c0c8536e677020de946288f49ad246f2b2540cf565941706ce784f6e5f2db66fcd366933cb5356aafd71024ce2f71ec9bded236efaba9dd4774c2c2d4f557ba6a52d3771d4516bacc3ac15cfe5090767ddd46064c5a9b5d330ee920fdc4ea6a7a4f4f53c15df34f509922b8a831231432c463bcec4ecebf8372fcd2eeea2abdc71908a04ce0863d1fbf94ff2f3f78f0fc984ce3989a4e4c75fc023cb721e68694c6dd88ecb4a4e222dc8283c2ed3ac2fd966b2672477ee4066242e2019f8f0f1999c7dbbbb82ac6227a7af3d95d01b5833978f88df9124685998846657d2494d83fd96961cbc72398bbbc1d4a1a2e765f5e98b7e3fd8b50ab604c3db9f6c061508dc78bb0591f99828741f55e5119b6ff92439b97d96c82052d4fa36fd1658fd54c5bbb91598200746c51ccb9713a56cb37b3cd49c289ba29b069b7daabc0c5554c29d127bc7751a3d026f67b87e771f895b91cc92445521e76e866f87d9f7660e33765a83de67d2ecc64587ec72403e9c16b703151ffd30d15ed647cdf4b967ae4e5d8e3a46d586c9cbdae1b762d32f0ada10e630376a7dfd6a1a72c0227a0575e83c9b0864bf230fb50dedfd4a6ccad286601dafba2f467dd443c92fe1ae564e24e19589a5ed1342af4c738df6f491872ff99c9014f07b8ca48ffa61f8b8634c6d6b3b848167fde082f341a9d3344329bafe68e86eec4f92f1419995e441b61f42c6bc92d591b9e81b7027ecf8f2fe2ca0961c599cbc6183e05fac142b272a64f18e22c8942b3e47f49374fbc287b1c3cd53a5d8e8461eedfacea28c7fe0c6ec7534aa3b0a379d7b57a63c9878adb4667d604e6accd1834ec0cbe934437661d4f75a8f12568cbd8ee4a313360253785809cfb4905c355898bc30aa55d6ca831a3e9d58672df4edaadfb70e12fab52b29f3cd509fa249b250a61d4617a7d42347fe4c1055b0eb2d0a9769b9ba93f4e4ec2d3c4086b3079cb4f1041ef6f3c882bb63f2e1ed6686d07d3272d36f4cb4f05743fdc6d8086054b9e1b319bd305ccb812b9b2ab3875a575ee903f33488ecd710f68317692eafc2bc5ee246943a055ee21d6f536cabeeeb06fa3678704a7c6e5b9387b18cc8bab529eacf5a4ebb44220db18e7602908e6e351246e294d3a817087acfeb951bcd4e504bd9a3e14f0dd2e441c0355ba27552ee2df8f0c0697514ad0d4d3868a92cae4abfabe30c64ccb0b010ad276b0f1e6b1ca539dec9faf9f37f4410f25dcf183d27aa10d91408c0356d7b37ab482100e43f7f8bac30f52cd4e1085b1f018f24c1c43fe82774057f64cc93e2d57fef7c7b74f6a7d99837345f4b39e3b95019e78b50257a52c04f0be63278b7b9f233c3022b0754bbb02847f714030dda575f3eafa310d6b5ac42d9e318e6341f5d6817e4aed1bbb43e41bdbfbe84d8d952b3344c18c57c88123cc1e6276842072155b6f80a0a87da2070b26210a84ac353193b20b23918bd15af612b9cd1d8ceb93d4fa8286c879bf35c7bfd7f3bf2a0fe9e5ab30e68e177a7ee17f2bef58da2c308cae33ff4de63f5823acfba2e9a158214595d12e6e3ba60d6b4e2a0356247bc1801f5aac21755bcc12dd21e34ac34b0fad5e888790e89e65cb1ea71825c602806385c8bb936722f336c1949787c02ea2bd2f8c98a124a51d4171badda23b24c8671f33abb0bf47b386457581da94da244ea7ce8cfbdc658295f1cf2b144aeefc369fe25f2ec92dbf5f37c46027ca580bded31b6eef7445e0ccf6fdcb5d78fc96b0d9eb8e7b327a428f8ed58e0c21eff6f42ae5f54b32bee538f9a4c67f26f32f06023714906b5046a66b7375d2af9200366242e2f062cfbd201e02adef45093270319e748a7664de16eb960d92f7ea39f53dcb1971a1c2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
