<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a555c4074d042237633c6665b57ac5d62c6b59b603a27e50e3d109f25d2590cdbe3355a69441d61e629d467aeb05fcb52f0408d2331c50e0452ba76741e2cfd59d5e3f1d59918477dcbf994a63754221a73ae1bc67c4984026a202339421364779f0eb4bbb6abe05271304e48e006004f4c080c09e469f6f1d3211aafb65d166a96b9a3dbc688f618293b39b671024654260bd2850fee50efd4a3795480dc652d3df4ab99c9147102fcfc03527ef063ad88a40595900b832265b6baf1f26198a6d85598e5f71b91ff3dc13ab16fa8f54e07be6f41914df2ca4664ee86975ab6f072268db370d5a3e351985b2d9d5e3a63aa1dbcaa5d59be2ef18200c36de29d22ff71f8289a754e700e7e6127e15fe9d3ae2eae1681ff292cf58039c7ac4303ec939b3a862c30ce87958a6f7c5349d17f406b5c06accba227678a77add344a9b805f774882b51456e38ed4b984b14edc2f6a2cfae7f233914a628c94a95e5e3b526185e59a59dca9066f4131e073d4875ab7d8cf7e783ae846d7f6f919d75f5b994a97d942b8a6f467361846e37b8b22e03e321e73f3299da7e51c02d637a8f5665530df6b2ccf198e37f240bae74a6dc6c12798f413894cbd2214532d5c6f8b89032f7a82171b9bf8bc6ca50a3b02536f96c9e3d2179edcab3e8e163df46ea69afe6e3cea61d94bb3df299ba24cc7ce3a695f66455df984959a8b891e3626ad37846c005efffc363e0c975d2d1ac3e2813463509ed5dd8a371bf4628bd3c5affe4f0fbb77939f3e2eccff6416435b86557e4fb462176d9b66a2f4ad6e8a08ab88b6262499bbe3de0ddd4bcc5dba6a7f128a2a04b5ece186152b0372deeeddc47637e5ee76efe7a892593ac00b0baa17330023ac0a035a87fd4d583733bd4832c320064ee6b7f201b0f5c413169bc8f8b79113b9904b946538079f1346ad2e883b0733f8ae9b42851136d7f9df7fc28c482105974ac7b6dafcb4e86b37debfe269eac6054ebe5ee85df0e61b0345483356f86b82bf82f1dc08300e19778205b34774b01a4487cd5001e1531d5fc35e38825722ffeab489f79e1c65d16b8d2ccf6a1e30e432b386828c9a6a09fc94529ff3985b0bee67597c86686e844f24b3559daccef006584b3aa16e654c478d8ce248fbaaf69a4b1da87338776edd2d819a1780e719432244f3cacf05b65fb0fe80650bc4c148a1fe953a26c99d956bd53209d91e3b4bf9915c4c66bd5b821e2aad88e92bb4d9486f010bfd7f74e736c937545cafc48fdd94405cf2add4b076b8a17717bb88457b928a30bb99530c92fc762a48dc22cec1e77152790729474bf14e87f3319c21595c02e17a2407e511ceef11935ce99d6bd04dc0a9cb2369717642f8b27105b919500360e2c6b1e3e5a6d8979048e4df2ac2cbe7e67711030bbc293de822888cdc261b544d1af829f55ebcc54b7532b14a060edc415ad0dd735e6edcfd88cf488bf33a2fd4a5029c6ffdbad6108d6840190f60de929c4c425c6256e28c2cfe0ee33afa206f6a3e8c7ebfa85eddab016a3ba2d590f67f24d5a2a2bf9e1a0a91bfe5159d8978097137dd1fc5873c20adc8fe0064dffefc56c7627e3bd167464564537a254d774953bcde953e850bc9b4def3002ecd90236edb1f3b417ec87044985ded34089ed0650ddd6b0675a2f93c0b594fa184a952c1662e592b1bfc8a59b73c19a144282303b6749ddfe0ce0f7178c992b086ec581b1e3e4106447f3c6365ed5a1de8edde1e8ea1b84b8cc6b39860410f0ae2d3990c7178beafe38772557b352325b057ba74744dd24c466a414c6e0204acf1d32dddaf899d517ac77d800cdd2d169060d8e6090de9dfe1fd516de32be15eddb2143a913f12372b2190ddd084404a9dad10105c0d00fcd97f39d0ab1ef1ccd7bab9867fc91e893798e721f7edc26e11efc94dd2068bc44ca84c990756f95a6905587b51dd7460c228566a4cba7c5983ae1a5185fe2c7870c65a17da2de0952648e2507039f3151c8f307577560f0a6a89309832010bad9b4d1e52428c1c95ebb817fbe9ce7be20ac86530e95db7b5ebabf81f7d4bb68104ca2f9c0a7ebb38f9b51fee91685fc6473506ccdb38457d2cfc9ed8db9906168db176c647f58db49b91c6f400a6116abf4afca40a142e343275c88ea919ca4918e6696b089b5e93221d553cc9e060025570a8353f6c2643e96cc6a824bf5257d3d942304fd0695b3f27be9952c04ae7d77fcca7521b297529bfe43ba98c18259cb30a322cc627cf20515c8fe586eea8eca05bc6bdca2df6ec795eefe24c76091ee78bc932220d3e97c85a72b725bb73a0459bef05ff7068de233232e2acd5e128600330f03302512a1e0ca6ce2d32ce0eb3b3b04ece4bc4fbe58d7519f38e145f69ae85cb17799beca5c3d43a80b3a6120660cbfdd17f5bdf2a26c27249a6226531f1089ddd72fbe0b4be39231dea3fdecbf431e9ea8b0e3d31278705a9b0b4bb6cfe149a2946540aaea2dc91be7f105aad6d010ed5c0183cb9cb051a11b5ef5ec49d00851108b5ff81fe822bbc4d404e7efd34f8d770e91ae4cb8672fa6f95125c8f48358b7342403ed54b7f6a1212dcd635e376387eb16e2971448235fb5cbeb2790030d680df9961c4d416dee9d7a679ac403c622134ff8f1f958edb1d4e8a7eb5e5110c734d565f4f05bfa176d2ab70eed8dc55ace2f1c0ebed2ee9e2c6f42d274d2c074212ea5c96ac0359311d89847886609a4e875edd63cfacada5d801d52c4da72edf94141e909d442249048e94e490268e7c200c73156b6737a950d63335c4d8d6b66d49a63db2e528cd236ffd75b98d1001879473150c55fda99f1140a00642da70383a076731a346c58e475137fb4520aeb2e103f2dade368ee8c0c1cb7f0ff4119c5800e4a910491f1a85bfdec3642d9ec91e60e6422a4e78552ed3266ec626af8e303f68f9a64e843f1b125c9ff4517128781bf191ca3223305683aa9725d711a557922fe3d1332bc979f3a503c6c597c30e49be0109966015596521df8b283b32f222022e579207a89a2fd47d481926af7b89515bc8971913c47bd5abe330c685582278b3002e5c9b61c197a158328b2f2e6d0cd16801b3de5313601afcf7767ca89214f830df9d48e6d42036daec941ab1c770b6c2fc10c1c936526563a49771b910d07261eb24b02608705e43b4d671c6211a12cf6aeddcd81dd897fdf43a75fd15b798b31b04dc06621b554a0e49409ada63b7bff0e9e0b507b8c1b27c5383c87e01e5645e0e6b0c5a7780963db90f67ae0b8a7c53fc7a91e78a7a44084529395813bd05cd119dc3ec3494bcf31b69d1d1e945ecf167e2e149a5771d047df042ce99c79eb4de4c1f54c8773aa8f2f051a07d7a33744a4ce7a87ffb6da6694df7a68e2b097473f35a0e4e9773da85ad3b87619a7aba10d2eb1c0894bc01e1f59af82b68a5cb0b985b8eb05b652c792d22d6f385fdfbe5a3139515dfcea02e31d7b86fa1e85914e740d06b05b368abcfa70bbe8929febac7d7c2579ee389c47d32c7d9dfdabb9a56e3403671b9c9611d11f2210fed91016a6645bfd065d7ce49769e3b8b9fbb945e786abfd5d2a94b5bf20c3effe6f587af1d89edd3fb6be6ae08881e3e4b322d368cc35a22cdd6e014aefdc76695dce6302e1c58ff9c76f2c01c671f34f25acb313d8a91863369da98663f73c11e1508b187dc16417b13f01f503f22361cb5c372407a556468e8c8154cf813cc6ff3494cefd845237ee17bae9d9f569480567b443de062364d996b3b55c83e0890e1fa904bc7f208bd71530f40dca9045563f1710c32690782c8ea022c7075149173cc55bbd080e3419d15e4425b3e9c9e9b1fd5d7e673393fe124365b9067470186d7134c50f7ce8eaf21394fb5713900d1b0d4cc62fe2e50f0bbc9c726da3cb7b36c93bd69a56cc621d674b053cffb4f02ce3f68ff0cbbfd574b5f0f3349941f7704ffa1220c88ed3dc6c3977cd3832ecb97bab15875b6c3703d39abc9c18d1a31374d65431d303a6db3e6d315e067458b0614dd1c903176e4588fa5ea6157d00da008def7cf95cd833ce499f58981d4e98d3ae0ad2777c23215507d72adae32225dde072b7916430e8735aa77aaefbb8e0cd1dfc56f38c89437c66142f24e02404ca7371821c3b80c8b4082ce7d2d00a6fb334e82a420652a523996ddf6f5e29801aff25631ece49c3e851d09ae83f0be0ab716c7605c068d53b9cee9de6efb96f77cdd552c5a373019d57a2202da2eb1b9c7edc81d69b35013e54e83eada0ffd052034ad7f4ee88753b3ccce62d6e1c0faaaa6bfaf1dc4cc30a80278e40dc34428402987d77da322906202ebdf4f50a1b9c00d8e381a74af80df7c86137037da0f8f2f0cc0161107dbd4f444a61dbde4b7785a86994d76cbb3687300b173039dde0f9ac316597633ff5ee368e34be1e38b9f9f9e87afadb2bd35774c4f59dfc84595afd2cbe08ea984f993cbb8940e87e04d1dc7bd02f55bb3d3e408d5df1908ae25cd78a8292e39e51ec754400a47132dc9e45b45d7c825a4b8ed9ebc21463339a8be3c73e6e5273995a4319d6c56c958b94aa741600fd68152a0d140935a9331e367d042b30fab40003ca650131dfcdac3f13bb67e57f1d7a6d5150a9a9de90adf1ea47e0319837903cb8fde86f683991fac914398774c5fa89f2d30dc87e881ef69a1a52f2c4d8916bee11604415f15c85a1df5bf9bbc5c76c37011263b9b503f0d48c8e905922c63efefc719836cc9561b3fb88d024da715fd500683eeafdf9900e193019299b0ee4478b4c292a4d7a9fe20df760b0c6f30cd067c5c1a97d3ad9341681dace9e18be9fba5b5acb0f28b250811b5ba41dea53641e3f9db9154ae908bd0e673c421b027825b302496f0c80b93e1f8eb88751848b4246628c758869459d6e82d55a363869a66e7802f7f25f06662fd3b79143f0cafcbc3e0a9b2c93adfd8d47114664f173b75174aea3ac4dcfc4f0a20142a28853356fcd57da87d8b7a02451f1470567faa4226b0bfeb0579add99bb002db79759f6bcebf8e953ed6247fefb20939c69fc29f617da2b00b9b65d59ab554d09bf3c85f38fa992abb802f6a8c2d3079cd21ce75ad40f051f50f79404cb008c3dab1e3b9bbe92e2c3c7f7115c2794ae93405f4b07d8d9abf1a748afb0ac73b24f17fada1dbb46a1c1b5f2364365f015268f389693cc98da2ffe17ebde7e1a608300fd3d850c461bf2a45009a82df3712825331ea9fe5c2b7643d02129372561a194f83a89333e8ec85197f749b2c6caa3501657f3a75c4f255c09ea906eed66d5386987194b80bcb787a173ea3dff6c8b1816453523be57f5c085aae7e05655d8a70b085cab2cb66b60ab25bbfb54998c18753486b0c5961abef36b304e02650e4a33ed26437aa4e3496d8a026083920db91b99bb401e19f01a951beeb5104c6b796b85dfbe70e9fc9a20457da6ce76f42bef32fe72a50175fb949ef8d74525bebc4ee157d339a9b8b6da23d29eda426b4a484fb783042acc4abec4e37b64530bc6e58fdcdfc31f910971ac504f1e1ef1b693fbde59d3d86c332883f10aa77a6676bd10585d2accead4d373e4580413ace86608b92cb9ca3b542c35806dd9b0e324397a378c45893304e420bf1f8df880b27feb48afa87cfa6c16798902bbcbbd7b72ec2569e56b24e9857c8e6406766281f7dbbc1fe9eb6e4f0bb46cba7ad829cc1d57533e9b321f84ce509b5c8eba0724e7cdd2b6e56488e0a5d9e11e2e3f819787de296162059e438211c84df7235cae5a99f0a08cbb25708223127aacfa6e513d4174a17587582a6114a3941cce78c637753c5c09ec40e2b2392c27b09daae436fbfc9d0a2ac9dfa0c28abacd862e09cf44fd14424f7d9669082607fc95e303050ec41550ac60df289a769379121121f5967d2dc4e70e0051b0ec7b8fa7e93965c8189096a449cdb645d4a58e9e4b41c54a42e9f5c796fdb4050ee82a0608248df60b9da0afa578b8fd549252d03051889add6e5a3486c81cf9bc71aa1e2381046e00103ed1d6b27e960c5e811e0d9fafaad161ee5ed955187250a0bfb51744d114ee2d3b6842943a4fca63c5b66eee002144fe43ecc85e25d439b765c05cd90c3a5498160abedaf5e2133352695904b39dd163a5a094cc082e6c9624a0a1c6e3a292a417d1b323dff133264dadf62ea5daf1eb1258808a98ce3d971dd2eca91f7a24bace0e81ace016d1be4863ea7bceae5c43146993a8f5d8f3f3be45d8edf57c9581c63f8d1e8032834236acdb31bf958d6de934a6fdb686d8fabf67d1046bd5b441f330b8abedc7072d0aefb792bacfcc70dbe431d71ad2ac23b70ef63208448950b1b8339ae8b31212628e0c41a88ffd94db9d395bb73203b3b960bcb2922389a1455e33b8916d32cee26025430f359a3dda5861e297d86901b2e94cf297d187da58d6ad3d30f7916b2a101ac0971b2ca5f0949e3666ef55689eebc023f7c188e432c79c0097be2de16470f883b55f50947177e9b778fb68c384536dc2f14c87567de70ed1a498e3cf69158d9bbac052c2907b2ec60e6bd72e7924676555bed87cd83a2adaea3d4ab83ac6f345835f507b96cf244461f4558e65d15893ab90f1ee602c6a9e03b1247634fc6caf714fcc63fae607fe50d905085db1946ac8518d0b82843412784cf0fda5581de37c4ff676fc7f51bfb7684865e54b2a0f5edf0f59d137cc68891ea6faae8948a584870d75eb9ccc0940264c5a49eda519b3802392dfd6dbfa53b1892f0ef3d0bd42afc0d95f7dc198b2827054b8ca4c72dfc7ebf5e98a691b9464da345cf78426fbcb592cc19bcb50f22a7239509abb2f537d71d76fc557702a10a52a1c26c19acf82d86e9e5e4bc2e73a4b37e2ac7cc5dce4c937442303f3cbb293870c30cfa91462226f434addaa47e1e47371805e9812d2fce2393409382487640f8b236d44430cafd7a956e62eb3237ac2e03492432006415bde8bc6cac4a961ec7604353cc6e0fb631e9b54fde92e0bb3028d9d38f7d99f58f24a045a128e4afc96e5b4c4d3f2b5519089b20c655d4f51dd1dcacb4e1613ed673e5dffdff2298d2f32179e41b3460aadc56a0b83718fc19230e6495ff885fe0494e956bed4eaf170ffca43fc41cccf1e49d82cc24c336ef148867690e02f43513d7faae63dc126e1d9ea80e8984b33a627675eedb7299e3e77210d2475f1d0f17b539dce5b80077e6fd966c22e5bef61e236fa17bc5bf925f026ca286b06cb53325ec42c5cd9e5e6eec612d105e563677b07a1b31da42b04131a902f48319831654d3f33d3dcab15cfa349d3de5f8ebf7d499d62692754b0f9415b89c1b652089d309985c4cf8ef38f82933a0d298ce9c877a29088f818564a692b589c8bc37d7c0dd3846b3dc2e486f6abc3ac6202240991eca164a75adb6d867a50e4551b35cad758ea7180e203f3a2f85cf1872d90d6340132a48ab892521f13442e91eb24347bc506af3b3212f0f715b273bb0e73c42a6c16a1306eb2ed8cb7dc9b0c3a39df9cac10b8d0b9a2c0b326f39e8e29692e44b668bfa3466658a560e67d01573749c059998c837350de857450bbaa168c70c784f1d28a33a7d01a0a96e8f1afa625a4507934bd4102efc006da32c3613f00053790eea9922092c3557956ae0fb4764344cde08a9a5ed4a14baa74c330df24e173fb42d82fbe9c6901aa86fdf6ae0acfeed782cc2386a67c635d96cbb184af1c744fa07018ca0ebae6c653dac9ffca316bc764ecbae245ae707f5269eeb4cd9df849a903800dc41a6ea1993993952abc06985683d3e6a26a9a738496c56c04613e616b211d0114b83a315c5083f1ea2f1276e731444b2374b97f340ca15a0ff3ae4418dc0a9b97a60917d6a3c8539e8c524962c0a42491c7f826929278f408e9fa55927551f20a3d0193e7e56b3a499c847f1e7b8e5ed5f2b9df38b8f9a00996d4fe70a12617a645aa00081974cf53e6774bcf70873ec3fb1ef017bfac46b37b3d68326b6a32a06379655ed5027907b80371491fd9dc629608b4fc2c017325085a9bf0fd5da9afcf984280d66876aa1b15b01acbd57d32db69c3d35881dc9b16e00902f5fa9e27f11adfcdeb68f5dab18002791fe010aa4f030469929c5aa6b5c2023ff5013702ec188c1c3b4dae1a633909588ef16c4e5f8dd9694c9a0bb1f0500bdae380d08617015ab7adb7b659049b3d665077157f9a6cf23407775b01b74d0a1f3f7697c3fb586dce87397bec6bce38a03c76a1fac7aa7cd029710904dcb49c60708e589baef45d44fb673dd46fdcfb080e0b9c327e479a22cef472a2304a79a4049d27c85fd093e4d9ff34e56cc8e6ac47d4a89dc8b3df7547c40cc545c85c2f13e1b760a5f64fedb4eb0c4581f70061008c83865400c2b7a7da6aa01c0c69205f7ca562345a25fcdc165d67f9f1d9cf8078c35fe65cf12c880fdab4912a316fc3a3d2c2e38cc4dbd694ba29399b1f6b82d92bd8fe26448fd3c481eb35d9fdeac0ec9bcead985794eccdd0a3b41710a76784d010937fda92924e5d18ec2a19b8dacb09632c2bbe295389f6f53585de873465aace8cdf08e446f2b38f3a5af55b0517aae89df40beb1da6773438c07931f79f0cf491ef1e1fe8a79c715f4f618ba4b57dc179b9bf1f800636ddab4b1e21106d70042a63b7c2fa030d339e41e2d02d504510639a483b0cc2d07f6a2ab2564fcd2b1c2e89b0c26b2e4940f8c547a5af962524c45004c105c7d869fc8774d0bf4d5827702305054c9374186b77d876b63c175387929e98882180b0db637bf8a51921b3a4743ca3a93bd4e763b0400a74a1e38dc05cafef00ac881d44044a6f50f2ed72827e69f42cd2c3693b99501ab0bd5bc9bacc343b7a0f093400f58c7d4953b021cf90376fc175758436b6ef0c18d1cb1072d2e196122570767e48fc1514a2b9799a1b9becd2a3a9bc2083adc0056f1668a0394744b6ec0e0bf21839b03339a0d68ce0352ec25ede06d885f78bc846cf5504f78508d73a00862b4035690e6301ab6db019cd19719b6b9fa2928afd382587a86bbf293fb5fd140c7c3be9140829afe9e837218f0c6b366df1efe5efb0068c43fd9bc4b52ee8c95eccf48a67c6ff0ba073f26955ba7ac556785dd08ec15956a6cf7896f92dffa8929bd1466085b8e236d27b56d71ff85b1845cb871f730fe5807b2e221b7e37ff41182a070bd01d6ef8f997a93244ef9c8dff928c7bc9988a2790dd4b658d54bcbaf68417f580dba52e50af69e36a0ae1f27ef26a6eee0edd5555595884a1b9ffd6466863872bd4e4ea727082987eb827e54c5063d88adb28b74469df67afe0e52f1ab66c43a1704a17883c8ca6479c888a386dbbecdd197ad6c621114453d71a2594f1b564b852a7708cecec35977d17ae43998fd12d390be1c448bec291fe471d303f44f2fa324945704a3fa10d764b50e8359ab71e5b754102780c6719033c329b6f98ebe8513a6b9b1f106edddbc9704b7a3fb1aafed5735ec34a23722c064b2fd1f0e6fdf3107af3b21e3780e2c0cfe306238f85e07d89159400fabe64480ccc1532347572a26a6fc7da1374668ea20a0594f85602dd3cb1f0268e6ef8049d38d29c89a11a6c29ab2ae465e263dc518dbf8d37b7536dd4978669e8a595087da787a79b29380433abfbe8b78b4d1ee671a20ecd622366d5500954cc7ee4451a455bc93175f39be4210007be33d04135717d2342d15dab321da0e802108731ecf9f29efb86f971415b3404f714df47e1aa4c36e76bf2801ea544951767974b30dd1ef1a6b12e2ef04d26030ce9228cb3922bd43ce66bd9ea1389bddfbdf0957abc9e325e786057e3e404a441f84c7208840b8a7ef93542b14fbc08f1faa718f67583960cfda2b122a72e230b4dc3e6660e7b513cb0e243c94df3a824c628df14534e8a60d5b99b23d005c8b93ed25f865ec931c706219272313d67769139fc268064f0a408208c503fdd8886a3d08427a429051394e0ee1a64675b7ddc678a4ebaad6450c1dafc824e2b86405dd0a9e93e80e63a44f0b2c7dcf08b00919f500c6fa2d1a5710b3a03700464ba5b92fb1c4d7d9621d938bf8f1673f5a217b5f4fe3a5b29b35d8c088f7273a1a1c713374b8b10ac03de84fbc512c2719932510d9f75e10aafaf365401a2e76b59c974c1a8e47550662a62186bf94ee43662d78949fd370a59be63fb1bea71913a0fc234b72e9e96cb3f3e9c4c6cf1ecce236fcfbe542fa22307a01346d5e7a5a8cf85ace36fc6afba3065611f9de52af335d9c68d00ce3c003f06ca6c345b6cd96faf51b745ca9471bab4c97220cadb5e8fb22f65845aeec53daf9585af39ead803aaf3eda411edcc29c00f58324e50c607435ec8ec45a4ab0f193c69b984da3260078c4b9ff1b2a0f6ad797dbb16b9a5b60e578320f7ef8408129dacf6077d8c0ae37ca7062bb1366a7213b41279e2849c2c7abc29a678eb8e3e759dbd5280dc419d549a9a611b7d908eec98f932953fb4b4524f930feb67f83bb753d2afa58c9fb8103f3905326a5e176916aef9ab8b7c236022ad27ea495d218982bc5fc27bd4e05eb604bc4898f575324f85ab512edcfe7ef4fefe8897666c1c654d49f340bdb418555dc6d4454ae89566c63998ecc1dda6461fc23be3ffc9a7082fcb74a9843b1923aeeb97a6ebc4d788f81fffca8a4a986fa221fd8ad4f7548b502c64baa4de56f2f7fc075261b2d49966a7140c06cb2978df24ad3a73ba3eb035d22a39dd83860c4ec84c4bdd2210299be32a9471d601e9afb016145eceeaac013c23232db9a2b80ded76cc74b1b14744e744430faacfcf867813971e91583ecceac5ff10a1ce19e728c0c9f5856e2531332c9bbed7749f44a94212545f9cd93c0ee6c48d06d188eeed67dee4d4a0bb635f2e5251037b00f049931af605619f611b0a36df6882dc87c9c00f7894771c8c92ee90537cba20ab64b38bd4ed4cf9b440bff65571588fa114f7aba35b32b20c24e77a4659e3228b546365ebf6b017f0e1e95a6748be927917022f4e1a63eb719a78323176dab0cdc585b614c67d9350cc955784410f509678b36bf726d01cb25fc7fc707f091ab45ef7feb5615035a5e509bbdc138e4b162e270be22745132fc98f7d3a8be2edca0937e99f3c8bdf1e77d4450bd610c53f68621542b25da89d73aed4ddecb77752d94b81acd4f3edb54cdba6c0e25d85b8b01a0ed37b95233c5b958e367ecef8294480ccd13b22c8f0ca8c313876f25fd39b3cbae5e3e5bf484161d6e104ada8399e64105cde4cb4e1f3ca925e2ac42e72d68fb85bb87d2296afd11cd5cf04b595cbff9390f2f91e293838df777139a94a36eca73282ee6e2639518d99428970a8d8e7403e88b6112ff5226cf203adf14e7512db32b8ad81c400f3892f825b3626f25925830a9df34ccfb26ef4fe481d52bbc3cf8a07d1c91642f47f43e98844ea01974e6490c8c283e293cf4d00ab44ac39e6b320dbdd3dc10779db16ec9aaabd366852cf1927bc9487d56961f8e7550de4b74a0f0fc24143104a4cb6c83a8132d2012324a4d3ffaba4d683bd7fa2a83da7b16dcddafa3bd6de3046b24da771e52c37951bd24d3c60333e07e42b0bcf01ad6afae1d63917d31c91738832f8edd5bafef1dfce032e97f13d737d37923ee45347b293bdcc544d109f1b7b824ee05fe5a19c5de29cf34617c365d0f8439fcf18c85c28379632e8806b80990f911be508442f912bccfb9d42b972f7198e4f82b0d74578b3cebf67fb4cca3b455daa2c4ec38f9646595fd1c24730f14b041400558362fda45db8f7cd2cdfe82369f05409799f9afa8d390c647ca2f8bf05ec65995d498b0e586cd8fd323cc4d17a4d0d5dd70dd4a29b6f23f9aa982f9443c03ad9ea6c2fe8070df0eccbbadc9156e82135a04954f669af9ffe9972d515c4101424f14efdecd7409306e6eaf8bc88037f147f3bdfc1a53a54771281f0b24e1c725364069a15def9e0b67ed86318898d6de91a221518b3e724b2f78eb0c5949e4d543ef28cf3201a38db252721e63a0e876ecbd22c3c2603f65f6b53541f37ca2008b1aaf4189159720a7d8bb93665440961701b919c664f6834d9fee4325df7e79dade1f2f6d8b5caddb793107601860edc33b0e19db0be328e40cf535d05510fa1d970c361e88d6fe6b596ce043ca0fd418480f1065ebf627b9268ec2ab5d499b2b2aee27bba2018a9c6a4b3fd147a5956d872bb1fa377483164173f026598303e1ba564482f6685ff6918235b1036d95459ff205203ce1801e968f5fbf335d8528aac3fa69af38fd36c03cd77fdd5194198b5ef93313382de75bb6f78a7c0c73540c656016c83b0ff00abaec754ef38dc959e834f70f07d1610219b1eef9f153946f3740e99d58c13a1606a20943b4e75a784bb1ab0fbcc71ee11904ea10b0860e284b54b996a15f1d8a56dc51fc232b198d4a3e38d1d41ca1d704cac45db2c4171dd46dd44d2c94391a3ccc661a66b756a5d69300ed73534e20ad1d72a231d84f7433eb9507bc4c2086bf2060dcf6abc5542d9e92c19c4dd6fe5714bf30ef711492a2308f0d751c22b7969cfee06d9814f12aab9a0ff7779857df5fc214caa6e200ea6fdfcb222c0f23c1c450a58f452a46b56a9d6b28f6b854ca617b668e5be81325e046cd5da52561f1db21cca5b10f43769bccd22a51e15990a5411ce3798357b5055c6d4c580525ed617dcb2d17787bda1045d95cbd7e488782f4c7ce3d7d6dbac1c792cb1395460933a4f02ce0283411cdeb484fc804cdd512b09c8278e5f55c76c1de2778dccf6e7104da9ecf957fc783de38c2c361cbe0a2bf6e53556d07bac91a15c5c3bb812479a41a10e4cb7dc63f2409c439796c038cf855bc5ad8eb8d2a869d363c7932038711d787a6eebc05640277b85051b035808fb201c456f4ae181f285fa1bae8115b4cc6c6da74e9463fe1563d376b2ad7d7ee719d8f119bf453599be6f2f289aae5d56a3073a897a935a2acc94309daccfacc2e24fde694ac92a19d0f9f0d78308197fd5b8d3cd43f229b7bff88d398265218ec3cf8e52e60d94e698db94f763bfb8f58e56f31ee686dc7265e3d9675eaea37f780d59cb64c261501ffbf20b62add7c9e0c29a29940af14a76802baaa0e6455036bb0c3587dc7472fb782157ec71192bfe8ec988bfe44ba9569816c528e127678be1321ed2edfe7f94d0fbedcbc96c0422fe7baf36426763cdf83d3194dcd7e863fbb998e36489a57761e5baaf9f4ae5f3f9e066f9248cd5cbd9903c80ddee792661ac6444c3142ff674f95fde56a4446e8198e0b4cb12547980396538a96b68981206f69fd0f1d24f2cf0777a925263312d4a4c69e63b30bd8ae222ff4931dde9983d237f56420d7b59caf86f262ed73fa31e3c4ea057bf64d528da3e36fabf632826b411e9cb7fdd623bc7f2beaf1cfef47401da7660243dbf8e842fbcdd60e4b9cddbb13b8c94b4693424ef3db3bb9ef3c52e371b9edf2a06c5ab8a0199f742bf0c0bf7ae8b46b5ef3bd3ec8fbfb12ffcefee5c92b91ec2f5a4a3824df3f25133de910079018746d2498c84ff8c7f1d95849f4264be6759884a4e998ca5d53034b14eb64b177767c2131f92fc6cd7b016ca974f7ef0031b876abdba56ddf512ecf67b8e64b332f65eecae77abfe62001d5ecdb94f2ec3fdbe909428e6375a8b0258bee56e2e7fbaf88a218b6a2d5940f066fde23cebb435d737f20ab49d4020431ec374088d0c69a53f32f66a5fe48710548833e31449474b3be25dcfac6d2c1179c61792565a61073747af58defa28f08d453944364782ff222db1b652345565d84950c60a286a3aaa15d6d9e0b2e771d9364d286c4dc2a2483d07f3b2be9170ea417863b5abab27cb2f78f245e7c60efff82bcee69c5a8fbba26211e8dc3cf49179464b0652adb1c4df7fa295539fabb5915d89d171eca131d3186bba76694b0fb0d23b3eeb777c930cbd60b350fee4765b7ee4d5d3304495f7a3cdcc5e2e381013c9a8b6f5d3ca40431d7265ba09128fbd8c91444b08c3b483726d7502fea0a04805cc9fc9f9781a75cf198b142c64729d5312dfa51d6028dbd1c36c06b2c369b3344df41c2866d0eac62089e76e1d24bf5bebfa695a262d6b524f6d574865dccac07ff65b17eb5ddee988bd0fe36821bd3bfcb876da9a238a2278190fceb19896ef6dc94345b74d5efff2228b68793cb947c9f9713490289deafb28945ba0394b5d3a160acdad6e3418bc674b7b0c4165ff03d80d512e10b2615371782414e5c5182921936bf0492a18e9012e05c9fb846c5721686ac97171e0ebff9769e2670a7d5209c85342669f482b00f3ba6aeac6ec141f536babd7dc9c319e9ec545ea5519aefa2e4b6a2def7cb969e64c88b1d0992b09169e596f71e49f2fc4bb53bf5e457aff497e5a06f592f65d14d72df951172c3bd865c80adec36ee22f596fcd9628f24b7eb0636c6f023169b7922bd7548d98a8af5b3259cd4a0f6cdb53def96849f133e04c48e7afca77c4b775a5910cf851ffce1dca315ec8845fe90ef54838e19ac45feb96f85ec8974dd9c33ec21d8fb9364323d521888c050923af388ce4a093238be32876f11094cd8b880689d687cd14cdf881ba26a949c288545d70cfa2d787aa5bb7ec97c25692e62accb388ddd3af8d494b52f1144ac05cb46cd32dbd87cf6a1d370b3d1a9109a3492d55db1ea99337f68b53884a078adf31dab5d4365e505b7308a88ca74ec1e7e36b978083de5be2d2cfffc2e683f4719ce60a2048e75168daaa74976a8aa370ad3cd826cbff347a5bee192ef1281de5e8f919f1ea091914a46e57a09982e90d3ccb8b27ff6e8b2f93784ae012ac5a04300aff7b143d3adde36f8739d792e35e080a7a18984344a83cb932e326dc839fbd277a9c960d75826968b4a911bc06bc4dd564c2b2c41f167283d151c44d4c74f2106044b3d253fc7e7c9985c48b8bd1b87c9282625bf7a9705e592fadcae0b71a4a9c5729eca6704e5aea875bb944c4d7befb440780cb3140786ba861b5e99de0e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
