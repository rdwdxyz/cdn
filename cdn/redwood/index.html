<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ba9c5cebb20f7e7094a880cec279e306fba0e4d5c57d4ff5e5dbe68e400cb2959291a17185afa31dcdc59099eb875cfa01d33db3f2c31779b1c9c28f4c7c953701f4e9ad58be2fba501c9b5a19232de003e2d3d5a659d478acae3caec63f30dde41abe51c41310c05c1c4468c46f71967329dbe9e4f7ff736105b139253af6e03bbdcb3c896d5bd2d745758e6a12d26eade210c75177a0ffca76814fe3210be691e34107343aa9566853f3c4b9c192f7e8918cb98ff93b3b6f7f6e9b5e91cebc9d3005e5699e1b64286de62f0268a8025a1ce3deaeab7363f00553a068c73c04fe83aa47e7cd985c67542f6689f671802067d560ec3e25cabe41e217b256cd26eb0843be42071cd1b7a0c1de35229d4b3922057624d8622b8c2cbb8a46d647408ef3a9cc37d6cd5f66f2cd90fef2011258258ebbeeb17e91211af606bc55c2eed4a77be35cf06abff3ebd71e08e21f08011a0c9a0464e8449d590bfbada325cf73c3b42fe37fad5fd6a44910229be6a76f28a52c03d050c0e9055b99d0cc71016b80bcdd9d9a2b61db92228b51a58d301efa79be25e3fe04466ce8339c0856e9b131598957580aed10c8c5a4fb212afa390d353d5a5e4c84d36adfedb766ca2ba1b3bc8e2c34a78b244f77202dd56a080e25d6e301ba42f461a244f577c9aa93a5c4ba2c2c74eb303a11a9d8e1341ef75e2745e31f58030b2056a4b02c4e404d06c6ded82f30ad3c28255ea78cc4ab57cab166ee06cbb36317c3dc49af18181285ac0e107de4c3fa0ada7b9ead1a8369033adcfe3a57279a89efe97ce1899bef40b62ccc17e5e5cd76e3eac672de17e1e41e58ac561ce447a0b876dc0ccf21bbbb47f53c867bf145d18069eb1b4f303a131330605fedab65d2425cf1b549b50989d4832ee6959ce9a00ee9f59861227fbcc196f7b97c60ab2577e57b85fe897f48e688dbaa00f1bd618326d35248f6571a6716c67fa0a568a8a2d31a9bf36ff39aae4df6e16067f4167a59cad9709194f90fb324a9a83d6b394297ede582e3710cbc32305f23c3c41ab435faf50427896e0433a728e2f68a0bdcdc65f2083d6eb3ee7c03a61528b4ff593e66787314b84bc5ab99efb34122f4c564677336c62a71c69dd4cfd5b02289b43a7830baa8be6b5e88526cafd9955fc4b9f996ee1524dca1a900cabee317d3fefc18c372a635e5833d6e4480528769b195538af3a801eac7f7cf774981a163e645b9b9126e262a619691c57abd737757a3e78c32f4e980316eb7a4601e84d31348687c1886c90f4f9741f6dfb67e91758d293cedfad958450613d9f92cd63993d900474f36e8347552d258366b9dcf2a76dd87d09008a040a105bda7802c439b11d8e2d3b642b8ab032ee8f679722136efacd16e35a08e720deb52794cd26c87a2880f24dbd315d8e1eade0e6f8fbd4e6844d75ab6f53056c401ae9ea4773024309af8094add599afc7051561bd7b3764db82496d3eb40edc0b8dab1a9e54353aa1dfaed6d73ffd095fa78820d87c22eb571b72da672fb476eb863ad762efb2d9b524ab757f08933093a0f7620ff656467a3fe904ed7d9aee88186510e937e59c19c2e8910f0030241f21e5f506228649c731fbd7dec67b31ae42ea3e77da77bf4ab3108414874e91bde74d6e639223727be5a31cc71d718a2b5c72a4a894b3867a29a9adcfc0206284f791b7ba6c424d042a43671bea547730380e2a03bcfc3ce099545ad9f71d6ed310344977607a44b5e2fdd5550ab288abb61eeedebb219fa1f0fecdd1c70a56ea917e333869c86e04157616a68adc3572e1fcbdb870cae2bcb923c4a8cd2de3a099d3c3a783f2220e69dcfa0a7731996cd1d0a1aa6bd1a682f8d6cefc925ef0b15906c792e6fc4619f93ccae402a8666991a266c2f8cb9186d55ca5311334593bcb74b2a1a0a889c823879827746093fcedbbba9b9b1587e90fdfa38db60f51b3c206272519d7e68bcf7d9ad7f56424e7c3b0a096caae5476ee4fc0c9f27964b0b301bdf65555456b977cc0c05af7732324ee4e6e5fecde6011d63079112d3a4bab2fdd16bc64fe9f6fdf566d62dd6060da6bdaa63391a6b868b218a4aa2df19cba65efa56576319f2d1b2d60aed23bba6440b2216b306db86ad4d44786806f6bb572728c2ac6e91845d1fac5cefe907e8733f029278ff22ba62d242928f8305e480ac14be1e826f366c166d6a1a266c65821c0aa4fa9b5214a5c86d3de5cba09d2ecde5eacb07fd775dcf9a74d99d5d6255c11de13255ae3c70b998badc7e664094a4b17ebea91e820d616e3706526c338e8e9ae7f1711a47f44fe0743867c244cecedddb7452eb4e3e7e4498013f1b352f98514b781d573413424c7b17675a70419febc280b8ed2f9e2e7415e9685e5a2516d9f21684eba2cc424f9dc4804f5e02374d67976168f75c15adf66d5ee46a18e4b452e3f5dc6fe73628b402cf9d0417d4faa2ff986d75ef85842c21aeed4acf92d0bda1fa290fdc4360fc1e72bdc336a5bf157ada48efa37720d7ef390d91c3eb4892d0ed8a5387158ec35d40fbcd993d48b8450a9a30e1dd427d7963333f2c2e87d6ae204085ee302f8e94c826daf68ad2dd91837987262001a771043bc95a5009f3dbd0551cc07d9cef1810828b5f3368ea70e4af8ae03a18b195c6d97a9abc0a10f809b3480aa7cfd3f99b9a70909454b57686b642b0f94b35985345101b6568cca76414cb882e65914a28be2de66c9cc8678e6b337209df380a275f5e31b11fc0f7129bdf578a79be5204d825cf2cba96aaf91e8aef9f5440188a79f8e320c1fe86a6f13ce896e24714ffac8e884e1185b0cbf0108a33d688708fd67f4d64b668373ce19077e95aba81a771acc26258d8fcc4e2dc4050544f91f9487d10c2789196736def96345b5e9137a3741150f45294624b76111ad109bc80f69f63fbe9ff1ccaa48729c7c7f782cf874e5f5cd8a9dc85b077f137a5e7f22f6523965c5bdd80e68982c3b8a483f022be658261e5a0e90e73f081fd2db9ffd5bb2fc1902afc1d9b928f0dc52a9825cbc721c415a662e373e0ad5b019ff3c637c8877f5cf94628ce1348fd88d966029f1486d8ea06dc196cfe6c36985e0e47a7a56baa9052493af983b958c96b979ef2a104b46b9ab2df2229d07872ae5c13bf9b4e0b92761a7d0999299c3de391e3ce579ee5cde5658e5d5f78ee237a3d6175093468632f6551c668b7373dce3f84a63a87bc36a4fb859a42f8f0dba40b7041128bf4005cad2ac3d45054db2c1263d420d3e004b4f69e0687eeb55dcde0d831efd6a8734a737ba499f1e60c789162cd0693dbfb2aec461ec77a53e79f642abfa6a97d24a15f5e819ca940d6c6205a4065dcaaa3b46416cdf575e7e96119b1c1a53f6161d817d26d7b6a07c7ce1e99911f29691bc9b62245fb7fd027705d0c7b3930ec4cdb9ab81898a91bc243ff8798806bf844aff7abe3342f50e1dd58b10cf70cefd233cf3b13570a1bc497168f966c6b6d56b4753a981460d8ea3fdf6e1b12eec39f61437160619c8c3812b85791e6de8ed76888ddb5f55f0cd6785951784e04b345293bcbc5dc43f4fe90ff67d2a2b47152e516789a6dc5dc3c31421b88ed8b0bf414f3729cd6c26c8b37bc1afb504f9812e7c50e8738ac3bc428d0759c11d91e7426f2cbfffa7bec4062baa5e9119b406bb996e0080362cfb044964adf373165f3cde2476ba98b570cd4261a938274abb3deaeba6ac81c76c21003284e8b4e032ab49778cdaa4748559cd8b55631471cdb2c6574594470b59bdba0bc1117ea519c002f13a63a6c264d6d97008c1d98c136b98f1bce82224a58f7e809f6e5963a351bb65e083b4c4ee1b5a8ef9e2577a6309f72f05cdc6343918a66e6036a2c98cb7b6ab45a745b1549a279e1695e97e733ed945c2c8bfb07f115063307ba3d68dd2f2c2b4c557228b21767fe9cd120cc249d0c82d5560464e6ca9c1fff13739772baccb2f14ed7a1884004cdd69f2d41f84537099dc672aabc6567b9af007b34ae36fce3bb64f98ea9caed48301ac08e26c2d37c0a29a5873b0d669c5460b210183ea5dd8ff58aa033802830acaf6a4733be5abb2ae73a6f41278226e4b7fc98812f639b6fdbabee097c01afc72e75406a7a194a4fed426df2555f966cc777fab29d5fb9cf52587e268af14a0569d146a733c657e468c63d9ba5e38c4e7bd7deba44cb6a85c5f04cd1827f150de3aece35df501c350ad6f64c4b284255a1d6e5ff0a432608c604a2dcf8f9206544e9df6f03ef27bb0cd756897f5f264ffec7becefb2b6cc7e6b95203a13747a2d94efdbfd5a5e0b56a2f9c0f0701596aedb2855ac7d05ec470da9fff4b80c45a4f7657b83200852f15fad56b80cc32065b77651af8393b23af12860a8f3f4832851b339b6ea1709762b10fa4d0aee6cc0aa45ef610b34e5a444335f8097108940bb73a6ba18e963c174a05f13cc96c57addb61adcdba81bc1560aa471d0d570d5f082d2f798e7116676246f92e6a0440f877b5df2507e539049f70a758dbac82d230ac6db85b7e5a496c4f4eede8bf11beffe64d0504d2bc674c5b8cd5ad694236f4802175b1d075fb439771b268acfa650dd1438d9857983f62fc7b0c0d3ed08a58eeb45a9fbaf75bb2577c0c1e69080257127c96035f758f5a3ffae324639f6930192410bf21a18971306ccb725c7e522044f558fe51365e3b5769c10a13ff6c08ef80db7dd37b0cccbf6d8e770dd7cbc00b9eb597bd7e019506f38769426171074d09d50477f6517aa0ab70f6a75abdbcef72f5e0dce58e2ea86186f9c57fa2fc1cb5c2505c4d2a5be1aed541800934f4a2078c2dcac2871e9da5229527cb2105147d77cb1f30d24c4bb8ffd436e2cd4cf483f84eb376f7699cf2ffe5d2e89029af666e576cf73666400c3191a3b05f80509681a6936a7965a176b04dd33f5e8b3de5bec2c9058a26a8e3c1084c5082f891aff0eba82bcfa916b88026e88b353fd204eba8cc15c87363f10cdfd80b9705bf7375e4050014c4a35fa9c791248a92886ad99952a40dc876b998034bf25fa72cebb7717268c057ddd3650efa91115fe91a25315ed8b0e5f8365e870a1a4dbe5f09dd25e6e1463b7a74a24bd8d9a841c749da6dae3d70a27b106a8400628621013d2a46af55edca9f66badc230df66e8652996dd4c224c73dcff28055b9fe6386e4fd3fa28788f099cb4cffa276df763b7ce58120cdc4d5d5d195df0aabea9958744dede564203c0e2be58fc3fe47c7ff7a9215185ca46c6214b65b93d2d55d91b1fbe4d6a8c7128da2608c86f574db63109bb11ccb06385be8b4c826f2b0f556abded2468e1d728a0319563853869b58acf128043aa94412cd88af44c81c62a95dbbc0334a7bc86254ce35afb51aaeec06dc5d69cd0e113a75998564c3f717a4f6d96dc128ca829f9517fafaf170bcd429be910643ce9eaeefac42b0fd251035e5788b754142650c5750cacc499b92b062a32e6bc87f4a2d7ad24dbb880556fcef6e04745c64b7e68651df349f358645dc805f4b99bcad0d9619e7f4b5ea29eccd2bbdf9dbbe691747da59118b540feb2226c100a5b92a53fa3648fa13a01ad9709595f20a591e020e79420498ea12a302981a0b022fe9fc5d15f4f6839c713683fd12162dbdfbb5379056fcf6f8af27735ba43d56a6200bfe7c50c54175fea999cf18ccb1a54962ebd51dc1715c0f53e70ea7ea667078e5d5f934e0eca48a5219f011b7bd8e46c6cb6cdfe78118cd80347cdcdc642982ac103d283958b5cbb2aab30ee109c0f2f826f9203591f48ff956e319e58803408af6f4cb64761fecaba4a36ed163e61373e6aebb54a75ea41e2b7cf501b89b6fa3b17dd8f20046d09989910ff389e66ca2beada4ee94475d7f2b477a2217efce29d2a43943174e6f687e7309071d5ee4bdef68414972627e39de0d47e8b757816322643373db57bd8fa34bc22e8497d9661defa99e2ea950860761b5e6ef82f0e97c5d31abe44717a53f19ea2e882205b922ec036d1b32af19305538f18834e580e83abe3881992537fdcc0fe79740e52328314a874766af41b013299bb78b101825bbe224123baba4d6103809c742468988ff9ba4f0df882c603c58ed41fd8572c86d4f895dba5a5f7b935bcf585081adbaa88af6d87b8fef7089f771091de59e4185d91983449d3d9927cbf6cad26f006463b86bc5484e9d8a19031f90047a8e6ac130e0e75abf07515d7754b7ed3ed9d735438237e82637a9c0421402647a446a66f826b684affbafb82d312dbac42f20fde1a46648b3fd0e62bc3475ca3b814f283fce206a0cc7dfd086831cc4ac67c6068c919c01c5689cfbcce88543c9b880052bd96fa86214b0219c16003e984c356c18c4a1657aa93fd2d9ca224a744f5a7899107c69b895f3f862e806c3873e1d742ad09725c882c2889fe6cd609a9642ed499a3a1a72ba7f6a89e431a13951e8b9c4cd210bbcdf038da023a5629e1f55038a62dab23c9d9a652ab167fb53196205af015e5b22a33e0df9697d9be0ef8a5bd0ea104352b20b47ee74f69b646a6b6aef1feb00980b9ff96728fed1946c7b50682938787262fa9c85d8f06a086f7c88a7f3c418ddc6a084c3ee70551e19eff93b69ebde1ce339cd5d837f554c1bc58ed87793d2b3c22118c4e1ddc553ae8a20b1622ac8894168de6744694b001d4bd4dae9ffdd62a718574b4f19a43057d4e86fe50180d3fe25a564c13b994b59d8264d052eb53b94a88df984cb3d859d93df3b4b10d6426cc08378fa5d0346546abddbd1e0220ceffe14ccbd6d5f13db1c8997439159defa6ff96c488e93e71f84ec959e5cc487aab303f73b18516147fd96fa3b144f3bf84ab0a5d5be5a9e39729e2e3747f3eed9c6b59ea6dfe9f6d07b06dbdc1bdc8e4683e15b916225b9c41381c8423a45fb3a1bfa1c2064e5abf7919a8d0c0b3d940594b08046301218fd93d231550fe34ec9baa685aba8c8e3df233438cecdc99e8a92ae6911db58dac5d7faba3f0b1b828511167cb0635b253aee1b2413145989c84e555aeecbc4194fe2295547c5c8111d06a4e3f3f16a67082c7f08fba3fdc16591d1916effafc88d13615f7d4f99a10abf1c006bd7b6075e0817b23e775f512a3bd7342e1349bf42543f9a07c8e390b449bd497c399cc301ed50c72c8562b0347ec0e8117e5a83f23938b71aab58f5aedc5299655c3e028eb6efc3ea6686470a144a86a45ec44a2661fd1451d1188632c431c8f96529d276f9aea2d57bf9b39985bb3bc0b5c9fc0fb557fb79274c36ce71b29eb25153ccd405a59d1657f5a1224002646f15095290636dc3f80d856e9b1f9aab4aafdbcb45d59f3abfebaa15e7eef8da04da5cbfa8940fc6d356f127abefefea0ffc3762edb4c37b966a3401fc1dcd223d7027b5084d6db19337bddbfe103680b72d561c3c61e63ab06beea02d6e7c659bfbde0fa958a51435c806df5587366faeefb70af4f3caa539f5a7294f617cec22e4d7d1a91db26b0a9ff1a272c301183c0b55e79d17db74c354602b7ca853f2a79892e757ba7646a8ae5b9b23ac06e4305c61ced7aa1257daa3199899d97ba22f6a57f2d394c6463422b3f6a9e60cd1e35a5eb54c03cab6a2ccd0aeac975b50b23566ea21ea94150bc56462e299c048f5176d310642c15612374e621691a650339b4a1801d88d567aea7ccca77a08779ef4a5e683bcc2b21cfc8f654bb0850dec42978812fa487fedb7df826543d7d02d6cbf97c03bcae5e6e9d27473f6ed01ac836be31bb5393e1de8168036a27450fbb5f3097dedb26ec5a56e3e4a16f72823b1406b8a8eefdec30dd58d60a9a9fbaa1b8527cf144c38357fb716ef09fba2f88f322dfac795738361ac6979cb867b5c5cc07618c7443753d18fc6040a349f7ddbbb84bab9687c7d9380048889ecaf46c598fd06fb0f698a74b23d36c5e61e93e79c868a8d46d4b7a6d34771605115c48d749b62ef1d8f5414683dbac1dcc1e832b794a9c82e4bbff99f5f6ebcffd0fa556a40ae4f54b19c5e3648c8970b8044a66e01b4284b1e1dbfef29dffe90db9dd6beff7cae7ec8e59255e4dc1d626d045f80a656e877cc00b98b5a57e77e63f6abb1f3665adb0455c3792f491b920c0ddba9261514dd400c10346b4001e5152f67d06714243865ba101fe3bbd88b8ee8ff416069e280b010588a9e8c9bfde9c9d87213c9360814ed02dbad21d7ccb60e5a4ea48d19493e10d02731b6ca93011b33cc405c7ce3448d555b6fa1b3fc3f8adfc962653873d32c6e160222cb3a73a9008b84ac78aaa6ff19179241b5db30dee9b8ebcba0aa45030bb16acb2656d78e89986d63739b75d103c0328934fc16afec563f229e5aab035346878ad8a4e1a245dbda29e7cf9ef60348b572a371526b871487cccb40aed646b78107888ffdaef2eed93db5f1b38ab96f61c4aa13da9053fb352a7c95bcb02d3cb0fe9a80cab718d842bad16026e871e5a5a9632f580f1d464ab4285925ec0af1ba0cb91093acb63c8a6e7c21ea8941460cdca541d1df60111893354f6fb7978ce03c487a3d621585674b8365c0f6beebb3b5860bf8162fbf3b84d7c3af488084431412c44965a2d7778ec3431d94bd720178ee4578922e1ac87fa778c1085040b208452fce90732e34a9f905b6e49bcbe461718f234fa32ee85e40ed450c81eb76571f01c167efec5e8aafc19a411669bdd6c8965c86404c1e89bcc5dc4af20370233787e9cc28aebe3f9d11d0ad45f7cf71b342014f0fc668271bbfb6d5f93545cc75ea9a0a8799939b7f19b58728293c52763acd8a5aa5b27adbeddbc9a7b586bd6b46fa810cacd7f267381286efcf91c9fb818ecbcdf0c59641061981594f88b3d8cefc35ec0c398737058ab86f8149c2a8a9295ffcd828c2386ddb0057d6055447101fae2621a284c4a143cc6516d9bb29a78ca125c91f6d998dac1a419f1a546a0cf058d9a711c4760ce3ca92298980949d5e2cbf1a10ff00423196fe2b7c59b258d9aa652e8586df2672f5eff733ad37a9c39a679e29752cde5cd8e0c30ead3cb8d37872b841d4e5b064096fccbeb5d8a345d86c3c995d2a48cd0c7f41d7b58b4ba77b4e15cba335b7c6640277e9646df45cc4c01e5f3c7d577d0070bc050d68f73fdf0e30a597f7bca56879bf31c29854d18e28a7538c38b711b0bd8a3da9478b8e2a784bb78372f5f316a2fd3fe83c7053b75563a8d428e0531a7c06f0d61bff2fc1cff13056f402749a23ddaba002c62ad68e6b823d320d2c38245dee83b6421fd455212aa8061ab22b49a2da69111f7930426e8119b74ac4a2b89a05c93c3f3110fc5968ea51a4fe50583b2892ee574a6ebe0c22bea2bbc20b6d39f210b581e73b5514dc36f81f0340d3d021a18778c78cd478d45f592c91cfac138332fb09756f18b7f2c5f64d0204d27008bd97abed0a2bffab0c1e34262d89cbebf0c795045adc480d58f7ef391003817c1bd069aa367402d825ea47d39341cd96c6c9dfa0c07c0124f76cabdd705cf0c382273d4e243f31ade13eb31fee2e4059543e228732bc4ab6ad53482ba08967247dcdda1a070d8436b4f05c3db1d2d3f9a44f3ed2576d91a1356baf4e86a3b38ec5d300cc48fa304c3fd2ad3cfbb4abf398e9322da39b28dedac374f223b7e94406276837726bd0748a6d546057a6dac90b8482b91566cfb5e8eced19b7b4ce7a2cfd53e6ecada75e477bf2f9b59f215c177f28e2eeae687ea949b6216c679dc11ede116b4ce698496afd44dfcce979523a5f7832ba3a1328be58ab25d31cf144799e66d350c64ae06c462043f247969470344cc6ea59deaf33c8de8a4d3d00ddd01443559ff6bc4cb140d2342508e516639a748b9c6ede408a4ec38b8229498fe661fa3e30b9ddcc48f898b33432a167c92e6eb132966b160c21d0e788ddfc6f6fd3bd66d94440cbc1e690ffd8b787ce6c69a1d2d52dedb5265a9cd4a8f9d22a8069fd308be512d3647b3f3bc1c49e05737021487b003e62c8ce6cb5b94a30905446a7112e8097dc7572991fb7d5bcbf1c4f3fb3857229ba4bb52d3febbe311e1ca58fd785119948a317652d291ac46ece45df4d39e364531c57c49b4b865ac396d0ba8283d8c53b3137527efa0edc08ba86b799c6fdf564506b5149b971aca17c78f39bc8900690ebc5274acf5483e49c3b47117691ceafa8730a1bb5aa6cb87f5ba02a2acf908691a9236fd277cce10920c74ab5e99742c4fa41ca077235aa7cecd08e3d7c505d08afa1ce44a4e31aebd95cb6180e03d4fa5c327cd2363497b28292fb003d1187dc159bf94f70c9b83c20a4b614d0e8f3bd57b7b40d52a7720ef4022ad03bb2b7be1c62651fd4ca7c05bc4f9b12ce742e0372bab1def8f1c3071ac497254f6d4e3e0b769a494254bf0ca30e589e33ae10ab581f2a0c52d076cdc1ab889875577892ea83c78ba813a0df704140f6deb147787cebc3b49e11d52d16052bcbabb6b447faaa206e30f1933dc396b9103f9a4085b6a1c65f96e5b22b293cef8fba832ccaf1f2fadd485e686a8a54c7829d95a929ec4f30b30a113706aac19032edb9ff26e296f4a787810bec128b74d3b4f3a653e183a38aa5eaae0bfdd9da62aaaadc7c147ec26e9ab0e9f80c22051605ba64e2ea55e0d2f665378e95307a324085cf605f036a423b8c54567a026de2e2173887ed555c5c764736e2203b5e0db9753b70755d32544aacef36be8f7794ecfcb2fa8a8d4f407de12fcc79d54ba1a7776e1e51fdb6166f19821cca45eae1047a4d9c97b23063a95d31b9a2d36fdfb3c5c0ee3a5c1bf3c1e8f8c5b80f0b31cdd3d970bae6739eea7f7b70ddc9f0bc4b4b910e12234aaaacc9a49e88d175860d110cd4bcfb7a2bd90da5363024a923410b7b574b252acb0eb97d5d3cc0ca05d40ae461923f389d89f9e17fa8fa390f56ceadeadffcc4060c698b04a0f3ca89cfafbeb8d4474a044820c852576f42c7a3dbe9bddb551d5399c1d02f1dd3a131236a0b7fc7789f4e694fc2436a088666de2f06f688f2cccc0802701ca0e25f1f0d9474f8add1dbd63c8fe0a46931690a92202dceb068f74f3f7f35ac825465098cbf64a759522560d97d081244683c6098e41c74fdc9d79be3c2338c4c73d0825e359c434d0a78d60aced84277035a96be68a579524bca85d80e023a64eca01cff726f8218c97f09eade881a9d6488761eb6dd4b0301f982860fa4d43bd8e1ba71cbf54efced9c34c1baf4240318a86f3d3f729c71ce191e2c2a5b111b64700635eb3b9d6c27d038946535584239e8e37bc326f785dabe6975a5d228dfe5557994b6df5b4141be24de73aca947afc3fb440de9ff52414e0c1a5b379d336938de1731b4dca66db0276f7c4f153a5339c58c4c9ba03ccffc9e5afdaccc38e69281e2bc27d6a368608d75f2e8985fa81bab30d2ff6122586098f0f89ae8b09679ee48947dcbc5a633d5e76c669872f3cbdf6edc46dcbe0acccb8d978311f0a1afec4805837b1fecea7d900ee7bf4ccd37bf0257aaa739b9bf431409f588d0c44d3b00eb5e2021b014aa270927e6a2ed944166d844bd8135f4a7a5b1841c98b74e7940d5a559ee0450de99ff346d3c3d0ff9301dd87d42764eb302625d55bb4d03bcb63877a6b2d7bd65df4f31e49215c3fb28ab1e0de7a01d2487a514c14098b56de2690226c8da2279a2ae0eaba77a7394f54804756e3c4c42f22ed4c2a0d7746f1b7ef389f11ba1ea411902248c05f6e3b5aba84c94ec7d1ac5a66ca66d2847090a7a5ce54e81dda1ba936b389eb0cbe6987156167a9701415af31a051bb2432575e6458513eab987a898dbb60c0545258775b6da84a58025eb8db934dd07ae62c036696756253d3b78af2670c0cb187bb5dc46864207855e3b6fc3d93fe425dbc69590246307e51e860dea574c849eb7f7856dfc8ba2ca5ac4823e31e8d63ba873d650293105824db7e177c264aee8106165ab2cd18406d43f22bd53da05a03264db9d71c3b0af8cfb226cf894e31e57b94c38bcf6483398df9a43d06db47d9c271c2b0682990bd406dc67a8388252d16e5ee726f5fe51ca68eb262eeb7428926bdb7e3ac16e7d1b2260209954912043946f00f3d064a6e4337490103a4125916786145c6555461273e5fcae8d37a88170f40ae51bcceab34fdf152c0eadc2c37ac87955aa07ef3c7f996fdb4ae6b646d7ba69c5c2a1728ab84ee4433afd7c662bb533333a3ca814131be4a49ce7a14ea8bce94b8a76928d3c48e97eb7dadcfc8ce0b165d4aa68149f00c88a9411ee9b679bc2ae1e42e7b0047527d5e5833b6ab6e4b2ce0e48df63347cbcfb35418bea0bbc0d47badf417b3d57cb2c779fef65bbfbae43206fc55a4987ce2bae38c4ba4d711d15a8fc2cc8b1ca341e341c7adc8c57e05ee1f0b4c08c16127254f688218667e73f76923a634f364825c3cd66f5594b6f873b9f6410ab63c2ee0e89ef79af94786612c44e6e2b5f40f4a9dfc236360146d97e40dcaa022234306f3dff013244b897e50332ad95545f83d1f1eb2cc12fa7c71c14166671388274648e7abab27196929be1ac7998ff82f4395837353189e0cb7cd038d1b82811228ed9890c948b5c280c3d88c63297eb357ee29fae7f6481662d002731d3bdc052b3b707aaa859c5843256fa4aef4cebbc33ca1f5805180c889e0c4943da9c756309fff65ebc05232f8aab4a913ec7b3e45a24e82f4198bed505ec7313d8b7a16d0fdad25ef8591ee4fd5e8844628486cfb9060fbe8ff4aad13c41db78b90d2aff24a75ba51a3c0b7292fde3bd0f17ca1c9f4b7374da40a506e846462eb2c312a0d0f1e78e98829f4649d3989f564e53e87523e004a9dedb32175c2f347dda8b1112132541d6ddaf62df896e22f2373ddf53ee183a270e93fad8bdf082ea07967ebddc888ff68bb83499f5add428bb7be722da75d27ec36f8658660476f3b94aa13b6493f9309ec894f56e2e0a0333194f8718cf80d310ffd3a3e850f3a994d854ee39951cd58dba52ff479a483fe7e0ec54289e2ce558834ff641f45a1caaf4091a1af31f95a12bc0e64328cbdd9222bd331bd33f78d351c844970b031c97c418da773dc90c7b57fe471abad1b29bbabb9c41da62fb92eb1d3e2a8d92ac5c7ddf4a92bf8da5286411193d9298709155c19cb8b14f181f63f29120f1e77c0d1f36e8e02a36091d309ff1a40b8e410816c0ea91b42500fd30531ccd04ac2049b6b41259fc22133df77f23424b69435b4d329f46fbdfe0a6e5c75c005b384d1bb0a420a09391806fa9f83e0a72529e8efd6121100eeddcbd2c9eb50cdaa2fcaab0eaceb2e7aff3110051d979ba06a93af54f129dbdb12bcc1a2988aef36ee97b64f954e366b16319a55d63c9330b10be71f7f264583550261a40fbc501bc9146b77b4d489c0625e17a545a5373032b15970086760e5ca142f9fe088188ad45c6a8c1680b4b20e9d3c78ebe8331a7cb3248a09b2278e1ae5171928e27fe7cfb7cfe6e7783a83283e2ffc5879c1d626b30eb7651d1fb49ad07f466175b63d465c9c4ad42d0dbd7c019829cb4225b8e8f78d9f87c6688f9edc9a888eac6d339693e5768838abacb6579f02d4ab1f9a7ad677726140ef60e9ecb54b03041c193aeac72aadc689b61c8c791c380141363ae0552d594ab2fb66fbadf22759df237b05fb654c20ff4051092048005bfeada7b31f7c571fd57f2224f39da8ad9d2b21e2180c932e77385c0834504b30e8e42e9d445374ee217c029c19c687bfa3cd75f85a84133dbacb509efbd0369deeb24ef1b1bec4ddd6900b1a7e7ce8ee96df3e1f6a2b785dfa302ac6b2d5ae644f4c42e270c5e4e889deedc5d072f82b7a86612ab18e7638290c4bd29b3509206531f75dc1fd27ed43cdef9e07800171a63151f6ae482d5f6664f973f0dbea78abee547ae20a443c269155855dea6de9721f21ee502063e482041203dfda606c878119ea26db9dff3c9eabf204314eff688312f32607724201b8e9b6fcd34c730a77ba26c6d3c363413c48463e5ca805fe02c4dc8de5384cb5c6573325b1e90b1c8f2f723f2d4b5a09d9298745fef1152373c0f9484b0ce562badbbd2f626eb643f40f57d4cc7951ac06428c033c390c1fc6625843da2a86d89c8875ae66e1ecdd870086acdc5af2207e093e9941569f84175b39c078ddcbf5740927be990e52336b018dc7df44bc4da8d9a7d5da191bff46909377dddfff41ca36e04f274436ef597750a8e5b77d4c758e82e29c47ee0125322020ca8be40ac7d43412e1f7be57dc862de3483d9cf8d6c2b2c8e94f57b976117e760711c7ecb3bca8b6d4189b0ce6e0411a3b079839d5927a9825cb17ae921f44aeaeaefe619299866ed8e55aa2a72d3f86a5e1bb56bb2698237d84cdee69e9f703f9714fe8608fb1018604c1c7e0eb35adad80db0a4f71f6520d6cc7da97af04dbb9b58b3fa5c0556d2e0524306991c842082912b40af44a3c3a38ba73bdbe093a1de6755b827a72f478dab3ae1218a8793d760930dbb01803fd83a7d00cec6d0c11ebe75d80c72e60a792228a6794554a46cb9787e83efddc86f457fa10cad45f64f405054fde347da13d2b0b8d98f55d8af04a7a67910a51dd5c68c8c25b3c59bf0d78df3b0b29c81ef405df654d7a1d60d8a3b162670896cc8faf5414cb9a2125fe7cf4bf84b04bf7487e8329465ce5b407abc4e76879cf8ba9c99c140ccfb9d9c23ceddbdacd9cb20093dc9a06a251f03dc2f5b2af755408e9b172c6ab71a5cd61f47df36fc516d5651b08a369e46c1070ba4a2edb2b25f213340f6607668d8bce6578f8ffe5e2e8c3bdce8e96d56b9bc7ceded4b337ef747d30bcb9218dd7cc68e3ee81fa4104d650e1b52ea1628222aa304db50832bd28af72104c7a069e6048c1f5ed085bf9070d0490a84606721de51e1429992e912558a36a42fcc7f3a43c326cb75e594fbb09358ab7ac2523f4b576dd246722be0ff43265df8fa635da5ca2d52d322166a12587c78938edc06e72a79ee31ade9b8d32f1c15f2698251c3d805a0d24b6b9832fc93b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
