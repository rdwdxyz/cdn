<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"39149299f7187973941bdb7de6e81a34ac47f27aa598da2c43e82009b07de68a143a489e6e48ac38785caca6b136a035b2cf2ed4eecd80adee50be69e62f3c822975a659ede1da2cb1594ae8bba8a1988ebfe10a198c44a1820c3a9fc2e23961bd7d44f29664295fe7e32c4a7cf662330cd4fea2181003373c029e7629ed000ec1d640d47872b404faf3d4edebdc31950c52985011fa140e69332fcfc95fdc37a406d6c949cd02c2fc6e27ff5596f6603cfffedad013721f7703b6881e3d69c9f640665bf0cf1f62b8cc4e99af2d6503cadb655ca6b3ee3a57d27e48eeb9f3c7067765e797aa56f93c00c94b9e23d9a943344559f983d127d847e6fc260e39bb075dab6841dcd2b95f3378b7b92b7a1fb4f078436677c684fcf6bbeacf6018fa30a42cb8f009b55644855171b7e353d1d0da1288ed0e57b5ff0fa324ba589e5e74cad05748a07ecf650f7a98170f5b00c296ec30d9ab6e2e5da883877c01b53f0e0be2746948ee6a272975ecc9cbfd173f6bc84606b38d234b54f15621c45d50e0aadc713d4bd11a81794390b0930e45867fde6e623a0b288f1545841e11123594e20d3cff630f6835216e8c1693d26ef83c0139097f59269a70a868f1cddfaeb2f83f02c3ea0ce54f82dd64cbb8141c1a1072e1a5d33b82d27c1a430534f68fc7966b7c515338d5f618c2dd5ff270b9ab68a37de9a32d62bf3657e21141b3309fa8dd810cbe486135e3f5913855fda059550fb9f75d76a4544ca4fc89cb124c460a8a429a8aafa2d00ab3670573ccb1ab7b464ccb37b6a6f823a53458a294e92fe718062d9579f6b039d927378272978b98a7acce241a29fd139c53b1cb8df714b27a705984f00eaf9c655cd36a0d2cb5881fbd2a18edccc589e31acf804500cd514afae0e5636ed028d37fcefca21126dc70d891cf629011ad3b840ff092452734c93903bfcbea3c4586ae906a19ff4a15695b657dfaff2a8c7cd62e9e48667323d58518632befde3179c0ab09c93ff48c04ba87106a0b4647eb9e72b241df431bac49948639b507b99eddd9e50de9e9411a18ca9b54daf4f14acfcf868c6a6b02a5c83c52b75257b429243d9afe4655d4a69f97fb545b3b74ed654642ed95d40412ed5c3d6be2d9e0ed0ee3aeae8df01c0b7e9e1694178381a2f6aef2f35b898f3fab2e206e2bebb703524cea202f58b1ec213bf752af9c4c720700dd9edc6557fc928fb2e7818480ddafce7f354be98c43917650890595943aa565965a4f4859d01ca7176041f156f1ec46f92198a5997883dfcdec80698ff08fdf3499b1b47d2a61364782e582b66f1b78f83819cc8db2c8ae9ba9d1897bb3c8c1f9e3bd25929eae567ff1000a42f31ceed27dea3a707255d3571e152a6afc7be2ad2bfc79a7679feb626ee59873a6872289d41b6b8b5f400bac738995d33ceb64abaa777d0c7edff7f99155d2533dd78674adddb6683dbdf8c1c05ce1130f1c8bcf7d3e3837ce88a35271a83a5350114e591118f712079ee52e4c2a28a088dd43f557f79173762a541dc1d72d591e51c6433f1bb431c3d8848f732d292ff9390b9512d03e668313d1f6c74ce9f225c96a3638d269af140db57fcf906a55784ba6afed4a44e7461d34240eba5e32c1c0d185ff1147c667ded6124c5da98aa22cb2e77beb110bed931aafabf734dc72e5044ffd6572bb37b19305838ae25c5b587ddadacd409c5ff2af22df00ac5b894a68d0d5aa8fc1aefc5a29e14e2277b5439b6db745d91fa5b9ac31ec70aa680095d71d73a4589a9033fa9553d24281bfd5c3ed2ff56fb0ec017c640a47efdb2e733465f3331189f29bddc201f9137e596caa0fe66e3509e6c19a6fedb7c3e6382ec880ec3207119f4e134c51b7fc875518b74cf67aa0adfa90928c536a4464942fb3a80e6e13462f3866e41d2dbb11e4ce5d022628d91d01a8a0a387028401e5dfb354e8a682153be4084d00040e3bf789976ff87f4d668648c75c4cb5f40d2f55015aa192969d3d416bf45fe4585953ce40a3b87f3d1f7f4a3452fde00c3c4df43ef0d43c60df789fce0d0d6aff99581abadf2d1625c916c54ee7c071578b710abc219a956345ef511cff9b833fe01a9cca40457cbd50c56051cf1b87cffda783be1d0a2a7d47b2136049bbc294467c328311467495ec1812d2ed2e31c333d94f2276fcbcb2514ce74031299876eb3cf696b0e6e1fae696817293939b66b6911efd659673b99fe12c22bee610e61e5d1fb7bbb17cacf091e08819c954159a66c50c4672966b94d88ca92bb9d5a0f44981c85af4ca4b891763846bd507a1c95be0ecc919fa3b856b419f4172732d3bdfa614fef7d5620b6b3791af93c3792240ffdbc15480aa6ef7ecc40daf7756cf0ab4d4153b15c42ef09101dfbe5ba00939c18b3bad73c415e3035b3c89de9ee80e571c2d90ce992c9c3ec46765dfd8101df0e3aa408ff4d365cdbb62090afb97096243537e410b5263494279a035fda316b6a8394e518e0bd782ec56096e18ee76f256c604cb28b965eedb7be7781796a1411708b15864c7d1dfe700407f535007a8dd1030d251547d2c381e3dd42345cc81668b5807b67975386f88fe1ea529a95e520c023e282ee55c2fc9f038b10f416dff59fde73a2a2b73fa5a164085c1cd84fff8980f61b4c6efbd4cd6716d21c2e7f65f541b5b5209fe5ed3d282e5d824ad534d46e8dfb05832deedbebca416b23975e6ae94516b99fd16a3e17527db2a482fe2591279bcfd3a4eb8bfd63bc65c72ae58d41bd3d31b366fa7b932047ebde6530682edc8ae5e04d718ce64c7a2ee2a6dcf9db6bc9cc5e38975289ac577ac2e1cc62a08b2664d78338811fbf75bf358d5c80689eb29bf8011d0a054fb382b0841ee07e7f58abd56601aed640b7f76a946639e8ea1721c8206b1bc54c31bd39a6926f8c9a0ca72a5a02ca8db885dd4a83e4b5af4d1c7189cc7af0af12e1f6961f36503bece35d6e9b28dd2315f4d8939bd8eaf68943644e645eb83c72a82c430bf19d81f223815712c3fb83a6bcc10a9c9f71892a64ec94a90ecd9b5e4fda62dccad9e10507cb1aa5dc5fc2a622da96d8b862e633d85d6db7db39fa3314cf4c20c012db1cda8b94f4f745f2a44fe33edd8d99afa4d764075a682e21d965c9bf085169459ebba0fb34817b21c4097c4b10a15fddc818dcb998762a227eae5fe41242f4084b512ffadd4066230c675fe778979d421355a1868a22839c7b1e30283ca0bc1f4f43785d65e7e8f1a3e4f20de1260607834986c712c319a1dace61464f339d2e9199ab29cc845013f2f4fc73562bfc3c9e9b138fd71f688e2b4df3dae280697d770d60cb47150924bb20e5a95fe11eaf471411a26e186437ccd89e03a1966927951ed1b0e051c178ac44eeee89287d26424fc8e83bcafb974087195a32af56637c5ed7e3c03c77858b1620894e0c9a0c5d1b1e85162b480aa231fe1936ae6b1a8286257963f9bd635bc55d874231ee4a8f6e69410a2cbcaeea351dda0c044c96014dba53fa670ec8c03ad906b50374c7e8082f6015be52e74a46127210bf227e7ff66045bd0ece0fa357089216517fd02620c3b8bc0c7c08b2fe20b5737e84f7bb595009d09d9202630c1ad05f62f1c22fe1a913b49153930953147328568a2ea0aae63a5112d93b8a71731339c6439a518f8b8e4c328d30fe752b9dd393a0dbfa8c9631d4c11c61958488ecc6fdb59aba941a7d1922cdd7082abb5b613eb139b8c6b5896a855e8495458bc7c022f3804384d89e72e6b94b1dbf2575ec253e81d4d6c7fc999256bc67df6633decfd6b94c050a47d959b43221ac61749574f6da24813e498bad4679e105c8d7949ed1c73e7d3e2fb6ad966ba350a84749a726e5bb6f5cb09454ac855a9b54221fb4d2e84dfec8dfda798b554f32687195ced1b3c2f3dac41b27762c09944bdd36b696fc1ee1bddc2621f04f1736fa09dbdd292100d83a2081b383e5869a8dcb77a61f47fb3bc13f9c5888136512c88adb6bac708596c5c238851e24a927d584f8abac47b4a8653ec9d868bc51ab532036a502725e02be4290d833f4500e8665e0e9a9946518ec2019cad4ba162c8b1b4513fe73ac0f357a20bf26f707b2390876c1dfb914e4fcdd17bb06e2f1f860c29c569eb86dd52e7a4872e3cccfe9f959fe701eb23b0afe48e581f3d77dac1b64e7fe757427a644c40d14e4080d1c96d7733169228928bc1d19787c1ba39086f307e8528e7a2948d3f474615eaa6226de58ded627831d1dd36efb8ea7cfb0b0907bb72866f678a6984b707d8f98e2b207dc5650311c72608992182038282aeb521a3f0c58255053a0119ed6221bc919f701fa4abe116aaa152dbda080c1fe41162a9dab05577a7bc0e88293b5f55edb1551b00df6b673b55f287b89a2691277c280c3a8fa7f7298275b9d27caa330712f77ed865d71abc26c1664c170b9dbb468b90adc8608050e8e20413c368245422694e92e75ed284c220da1e90c2470d93dda2d68fe2b1f06effaddb8a05ca56e546184ab30c05d6fbd12fe02b1c277005a65ec9b4b4a0ae33c3df325358975968b737f703d39219147b013b07b19429cae96710c1de7d6cec708d23f6a6337a1d8bff31e969a60c928a30e1daf97942e2d3d8cbe236c7da517f99a96f7ea8646f19874e84f193a47058bcc46a5353ae1ed77d090c5361f128f3c849a01e22f61fc7123101664c63bec339d004ab295c9920984258ef6cfccd888ccf0c9f46ce78804bcc2924388446ba9d083aca64513c7273cc3e67be7015ff8d363c0666d46384d1bbd3cda6f9982bcb92f1eb921069f06b1ae2906ac49d3a772a90dc6cff67f175b1f4b2af082891b77b43b36e26a3d8dd1b1a5b2d573c69d28a75a50fb054051c476975cabf3f95bda823fa94b707302bcfa60c9e0471d56b4d3a5ef500a375895157bf3999703ff87c49dde701822b3f65bcf67c6ec2e228ef732414c022f034ac04d94ac14a2dad0aa2a537201f27c8c7083e54fdde1d3bb681fa0b2237dcdc44e7511f5c48656096f400a229328b279ae69816f9775532afa56554bd325ade14060cf7a6a639b72efd246f0cc000d526c80f5839d0c39da48bf00eda3441ba6a09f9bb6184863dcd586fc61273fb42215e52c292a193dd401167ced687a49ef8e579e8a3417426e5630d3d766e500700e71ebfe23df80d95e7f23fe6c9533ef2c5ac87b5db42aa849a30a51d4dab96c826280acd88f9bd759850bf943b79a098b47cdef55d8f06639856ba653e0b029b749fe15488c7cf1e8d0713fa6a41e8e8af809419a419c046a959652b5171088df2c760f2bdf34b480c0428d8fd5303f02d6eb32d8db88fdddd165e7dffff31ec0a92ed4e03f604d68524a5296d2640aac81b7bd680546a0e86591b9bec3f3c5728c4b4f3c98164649cce07730ea3f22dde95d5dd4d311c2eb7f3e18c69f679ad67e870a8833010a4a571a830476c18588cbe23c6688e5d71be7f5a521fc9fbc4298e55bf41a38b0581f17d590a16237adb961f219ce6dd05304f41c2a6a1a45bb12215c0b3eb0933caf2b47a87621bdf0016848561ffd8215014466f9f5e15772b0f99e2793867c0ec2f6d432f00688dd2f1358529692a161b73121ae967c7df9aa7f507eabfe9eb7935e43e13423acf3c22423ca1f09ca5156ab1ab832dcaf8f95b2650222a77f73e9c9d3fb739a9c0d642d2d99fe58edcaa5dffe695abde849ff0b44ed5074e407bfa09c0e0f8d4ec65f8256f2aa8174326a753fd281be42ec8ee97a307a63a2a19b3ec5d20470290a1b4e452dd44c2a06a0cee0b07debfa350a134407a8d59bff0650e2d83988317d4f70f14ab09e48b21983288e6a3bad3c57437f7dc362eb79916c050803e544f5678bc6c70e4623a1ee88ae29ea26726392f99d54d8cecfff55141e46433693684ff937c0f671daee598bce7f0ca81a1aa8b14a4e70fabf65614d6714db01794a67b804566526f14c729ef1e95250f113dcfa75ddea2ed1473c8a2a04b7136c73bbb5d172b53e629b93bedb121e404f14f8afeab327349efe24fe60ff47d543ed35292b8ceb3e34c34ee8fe4d4972bb8df1a42914806d419a7943ce8fbe778a9ce86b426cadbd5934bd977cb5478077c387345938409de8726825dee615bab809e974ad0d652ccfea0e41099785b9ae23fe07a8b29e3b50bbc6db74d10dc2d8ab3628a07b21b338ecdc00586d8afffdb0f48d3b3ac27fbb6689acb992815847f972b21d58d60ec2274e2cec8a160216495acdd01d4bff5647322341d7d192bd563a0af34b0367d4e6bdb3b682951113c17fa8fe955853b894f073cb7b671a989ad248bb9303effa63e766321a50f862987a3aa88bfe79e1338c80b7216c004f123dd8904c955f98b85b0be8a73ad707ddcaaaf8b3a028b73699947052c7f37f23f09ecda51982d6877c60798ed5f57b3d118d6ac5b4f525a164c99fb85161865a5048101a8bac903bee922537f8891ee64f4388fa72cbd4dfd50980c224a6d5588ef290c3a5566f714a636298501ca34bb1e0c9850d2e8bd4ed2b305b67a3ed935f3a28ebb69dff9b2743066d08b124b0ba15ff3fe36ec081f51d29bc2f5838a3073023f0ea7cd131baf8e6e551b6d4e4abd33354538596f5f312801525a847b0aa0b95dc41f0b9a7166de637cb1c4a5b3628769d5ecb6dada423bb048848dc804a49cba648d0e8af6b6dfe58b99eaeb081c825b6b61a34c6f4f28a6f6360565607cbf1e2e9d2f6e4f79abad8045bc5a5ff1efbc6064b28dea424e794dedf7a7188634060468200d00ae7e9bcb5e28d35e211f6a11ea501bdc944ded8b0f9fde44966f2e705a838afd3ea1ed8a70659fd2d95175eb6b1cfb6e1375673b53e4ae6ed4d06c39439b516567d532358748566195d5bb6af657d6d02d402f12597a43eb1247b1cd290ab966ccb6909a2b8cfb337fa0e87de6749be0c515a88ee17ee2ea511474639f94a17963aebb94b94a868abce8fdfa6e79dd9697ceadc5964efb764f74eca55a48097e7fe0296dae333874d5721a9c7fb171bd8e42cdc85a2da61bd2f4ed7cee77e0ddec93c77a6ce3ce8238c0301118fcb7d8b205eb43a81314b9c921d440002a5d21e80748d27966fea4d2ded91f1de17075bdd1659561394a2270b6f03e1c2e11e4ceb94b5a49c247ad56471a61e56c626c7516dfcd7e766e659d3c8662c72878f88d9d7ac1b9fb11ff53da6aa61984f22cf27b8a82a5187f643491051f7744b0f97888e78902acdd7b6f8eef5ae80bc7952ca5ed0b4d2cb3212c85386fdcb2212c87edde405a76fdf50fb1c4d5950adaca35e09f96b159e4bb362cff37411bd5154a42a530840e8ea8db4295f8ecd987b854e236c1f975d0e3bf7c2f050dc5f554460152cd0c60fa42d6ba144309cce38cc5a538718f6359af175364bcd777b43159fc23dbfbcb7bb43ef38c711aebe47b8ef5a3f038d7a94f941e619b0c71a9fe063d35c3e9158e77b90ea067369f116a91f637d1483285ca44906ac0bea4e4d58382f79761e7d1e01d9ec75384e4d7099c822853cfabce5ee91457551735f9e981224aa44d3408747df0de98a678709e0bc972067a578815858bcea79b481f286a591b16c129aa8fa4e0672ec9b01b10c3e17e2b0216ee224f89f67915dfdb90959a2c29cb31df23d8ec3404e0d743f0a1fcc5da370187bd7ba914335c59d169b1c61221d481ceb43ad76d387e8c3ef8807ec94c0cca43d8a91ed423a388bf73e185db135106186fe39df4c7f9329286857ca2b2520a2006f379e526fae74c5dcb6fd162fbfd42a6925a5b3294c78d664426087a65d2a4fa22f5f66dedb9ab1b4d5b04d6af791c3c82200ad348c83a13512c9d7505e0c52d997155b18bcabf9d9f7410ec276a5f0c4db2affff445fddea616fbcf565258059becceb6b3824b70898bcb15da860d12e57a4132f515d352d6b689e638bb11e51165f857cd4819729c6ec547e33ccaf8321b58c968757fa4147bc14141ea06c04a680f43158b05e176ab763609d9026ef6b47e439a23df1afdc7d8337ada3560a0ac3849aff4f3ab74bf18cab54aff11d9ca4b4717311c8f10d7f0c0dab1e25263ca96b40f5478ca020decf14fe6b8ad00991fb4ba786463aa744f3f39a4e2bbe2ceedad5e10e21e206c8fae364135264f867df6b8477c223921267b9261759c2cac45a3714a1381b72abded89127b787232528fb2e46f2a8bad0d1fe038e1e39405cff83469c9c373753b3545fa3c452c511c36cbf8cb6d53ac19004f3346db5d59e1060ab6f006532bfd4d763b8e98a08d473b70527f6719859251b7a28148e21f9357c7f50216ddcbf7df7f4b8b91159883a231095bac38154ba739d1f2fb57fdd59e195df092e43e3412a470080539c48505cf2fc4121883f16efdd0cb9029fbf3083c6d787aa47e607838af448d54c1a6d0d987cfd040f9497b1724b450150cc8edaa80a746db82f80ec9d0fef634de491a28957dc74646e20048929043121e014359b86fc95dc284976790459aee856cf24bf4f9a901fc339ce1e966c5368435c3d4d64cdfb7f492ca2e5df44b522f8c509ab002b9a8ddbad29e061b12408b8521d706af017c638b593aaccc855aa56ca51081e7cdfe41b7746acc9a5feeba8c56934c0b68e47a8b7d8625ab4798d2b8390864dc978adff56377e9e6d027b4ab41a9ed7d841df3ecce61a4f2f8a7a2811e42d46307ecb79aa66f4d53c0552b43b2371e80c346819e2d15bca90da074f5f8f054dfad5a81896756191431464c6de4b916f976db1efdcf28e1ff5241cd8a7d6cce25df6052a673fa3dc7475b8e9ff80cca7c50031d0ccc51235bd9106084ed99b632764a63bd9c50f842db2041c2354fa69a9f368e693731bd714fa2d7b4dd050d9b3c362df7c724a1e86cdcc9b4d9b640c304ff99db3dc67b52a0427fd273b6eae7b35b737caf040c3e6578a7b74261bceb5f758e8a3b37ff1874fa1b65dcb8ea1f1b5ab17f966735d9bc50fc57332bcd8cdd5cfc9e688763ac8c5a30c76972bc7d03d113d2219a523697852f059f3a3258862a4315867babefdaa1925f29fb268ae9cd360eb4c1beed467c54239c7c5e7450a5368b1a04048da43432b76a660b8713a8b9146ce3a708e49a941e169665f2f32f6b3a5210bf88106ddba9a9977ee962f2f4230979d18cf85f47d446ff802b32aff8f0a664a5e90fcc2b4d149489532a7533c34d5e6ba8d7b2f8dd2f6081ceeda538d6dc119fad2311270f4e10d68338e6a73a8ea6096813b6a29a34122274f63bc4a0e3626af2aa0dddc4d1984bf7f1d1f85e702f008cbd7f86bea82746082811376eeddc2eefc0cdaa8f19a97f0995edf83b67831cb448728051d318e7bfa2e1185fb9ed2ac75168aedfcc8fb68e29ffde2a4ec59eb719eedd6eee9767ac260772ea68e3ae2a627d28c4c997bd3b7433c38588f24fac810827f62109ea48b372a19d68c99dd730212e1b555b125a4b25227304d6178498ab708dbf3a45735cc8200f33f236d9d97d9c1725a9c1b7d555ee38857469d8de9f1234f26c2b5b899abc23e9b5a47189a202909cf2c6d687aac0a5a10e23aed3c43669915bf3dd925bf6e44efa5f050ca1d24089d049e4da199de0f4ad7cdbfb344cf9b856ab5136b359e3aa17f504a7de08ae582996f09e89795e08a5ecfbfbe5dc6a86105baecc9310a30b216ebcc62c18ba486ff59470dadfc049f1cc982101c07f036374e8c436317a40c047d6088b7afbaaea331a3c153cc225abae062c76fbf95a58485231a2b8ef4b1b8dc98c9994ada6c70c1ce1f27887d677d6abe2ba7bcc5f5b64a4de1d5a8a0cc2a2960c87ae997026230195a206fd1f8c8e251248339abbc5b512e204002ca572b4dc8b319f44aaefdc3505898c95e61a452d3869909470dca2fcdfc8b21e9c1c2f9c9d18592fc8082fc5c88f339b6e2d9b6514eafb4dd3402c02aba0d1d7854271be649522b0002dcff9b7d1e10b4ae808ce32ff88c2948fbf2a64fcff724807956351ede89e6dd0023189f0fdbce68ab330d1eadc1404d1815e2b15d4e86ed6f60d2d3676b505b2c306ecf815a598729a4fac8cba93426dc0ab363aeaa7edb4d70b28766ea4f28fb5823a9736ab68c8bfe2dc4518ef0751ba5c63f6072a8f4101f544c7ec120f4742d12ab607bff5453383c3a1db7386b31f26fc6d1a0a0c9a3c4eb01b25e1efb553421c7b2f4f7a0aa4a18aea25c8632e86503feb98d90a54e46281d5f90a51be88f3e3ead9897be99fd57760727dcd2edd6e52ec3765052e5f1a73e3f9ae449c42df2a1a0e429e73c3a0a915d2aa902773134ecf23713276de6737f4b73e9a4e2c7119d1bf0bd1ba34269abe5e9cc11bbb3111f1a60c673fb3f25adeb3a17aa7e18eac29d24ff33bddc3f42227661fdeca7d097236bc53adfa60a94416f46ebb3fbbf6d744c7869e90bf18112ffe6d4f4f483949d730f5710f57f4aa628abb28fa9d313484c6fa9cc50587cd1b406815440b98e4707d63fe19215a1a71b586fb0a45fcf3f5f6eeca57bd00466be5157694cd48e75003d836d27d5faf41c094a6789593d8160787db0c03581176313cf075b18716c86471b3dc6527fcd19506d6b94ff0d11a5c7d0b4b26168e82924bf310adf676c060022ffcdf72593b0a4b590869c22f33ece9258c0a79fb13d1ced3858c9aca559754c1a7d801495ef0d5d01fe271fcf0f7295d08d223d6683291d637696f58f4d29be4c7b43a313ee40c572846ed8bf66c9c457bde73f6785bfbd4e56da509efd93dbabf2e2031c471bf28135aad495136b6112b41b0ce47a553639cd1919107cffee1266acef2e0f318a5d9e95336c6ec5b9fa5e96342af1d1783a24143b04648dc61f4643e6c654a2ee4d4eac52aef19106dae389ca5dce185b5ed479ac99cef0a9b95c089527a3b5cc6a8198eca21328b02d7b95ff6b6cb42dda5b9d18ae473c84c5b82b3c6a31b28e5e235b1b17e888e77874b99edb2239cd9f4d48ecda2b8de9be545635f901f70b2c0c00bee60b9c8cb4903196f12510b2da16ec53c1fe08ca5489cdedb0835dbab013de451c1e08122b9f60058e84be57a3efb91cdcc2453e1163310bbc726dbf063ca68e3f6cf23e29667f4fb893601b81731b1b34638b4b02f8e1f21eddc045368afa9e91633a05da8e0df6be9f69a22b045e96eaa7a30b95d3f3c713d32bf86b09d3f1e3208ba2e49ef20c66f3fb87a95cff9d8961c243ab6fc5c84942b39e12c6204430be59b2b3519dc7f1bc5a011f3da298411c168f07a79940c1a1100392def608d6f8152be9cb57d395e151fd84497d683e2bf777b852ea2aed869265d247545a2b0a75ec84823fc4ca5dcb57c79a1ce8aefe1ec3fbaa399751e5cabd82fb7dfe884a5839fafba22fba2259577f058da58708124a7ab3b2105c1ad02d4c4b0d1469587ab378d11a3c6237be7a267eb8aef7d44a34530cd10ffe872880b7135d92d5362e9abc0ee4a04b10a4c0fa2bd0b5143419780b562ef15e8ecb8dfc8ffe7d5e331aaa992901672fe243757ec1092395e9431906868e0d6baf8863033854eb24f0b6f60429f36878e4d39cc535757e8f380078c057c4e2387c080d1ba71abe254218ea076a09e4e3953e87e026ca818c75edf88c81ccf412a4a37e999a080ba2621a382301bf3ed15eada58e6173b3debbb5538453b644aa89454fbc33c53b225fcc2deb21fa4b942d281f1395ecae721197c5fc6e087be3236911eb8818bd90497dc5bb9885229e206ceaf4e5f87318d02584689faa1844fc0797bf1fe78c560219dc9a378ab17195de4caf6244d4959c728da9397fe492ebb1587cff36ecba0c0f06e9c18bc9745344d4dc8bf26fb08c9ef6f7747e9bd1ccfd17ff2e6cb0b7efe7b7a30301f8dafb19dbbfc7d2d9f3f8c2fde5f0d412970d38b4ffbd5434a58b72bc867649f39dc1f3fa6c5ba810e7623c5e423be40d313ebe2d5211e35085eb8cb82878994102ea26f8fa425b8b9adfbf95b167f857365db492a88f4b919fca7dac3a42f32628749f9a588ea90e330d4ca182eaed556d9525664d76d36536a34cf1f09a4af7170290894f4890768e73368ecc9d7c876fb1b5d1dae76d337ed50d6f92f99e22cd2b0f01de8237e33326a139ced6a3e3d1974b161e7ed9b3b893c540acf916e220f21d84c650cbda6e8944f275f73a074c8e621a27db261a43bdb42f6b7fee007397ae6cd52b3ff2bd173b7ad2e0750e46fbf254a5268d44125b98dbe7cf87fc760a397c33734f90bf4ee0dc522654476cfee27f1316e4894a42f069534012e38953a76aa153cc1a9ec04eee06a92c6c46f621947b383e021c842a8fae0cde736756df53d6fdcc03916060de8ebde054618c49c544177befadfd9f84b07a4f6072dc5d578157fa4c82d847cc4131905361e872e4fd4d31f65eca39c04aec31903cc84693a9882b125810810598adcd82cbb4c3f4eb9e03169d0fb4227697a476ccb609f84413cbee27ad96787132276662fdd5564a64f552bda9234b77d2e2c98e25ef9c270c074bdf867e14ed3e905d4ef26b3b077156e715be147156ee695e0f3d10d0bc9109d8900e8568d89fe0224e095ce85e2ffedc39629f47ede492b2267eb2691a3a18c4e995f3707608eda625acbb41f3776747524472f7fec43ae5c26341acda36a6ac7ecb8ad4a9c26b7d0db2b9b1ead33409ca508372d8b4e8d8b8818d2e95057ade297106b183f7e4e559f94d20aaaaa2f9e6051f71fb7a8c06409e51d7d89cdede398d305596ba726375120e20346f33e4228f3a2fbcd3fad20abde2dac9de02cf2b11b800b9d913c20c84aef129ea8e432c80f5c8ea86f62520aee908208902abcae808c444a515f03621468154ab88b035293e9103bffd4f8d9f3aa05541d648c682a6148ac009af75db7ebbe0838d207481469f659e864bf480ec613a1ea5778ad54636d502bdba48410c0d67e04f6a0e34777bc0cfa2d5427c31df9982e186d712f0ee1a9beba6641f23bb0e4c2da769ed954b867d29b57f60cec57115295838784ba34a560543fea7faf0df0890b5f9611f1617ffa2dee936bd16e708a64f67459a99fe3e3fdcc652bad67c1d143bdce4b5836f62cace58968e34d8f2f6505ef3e0e3142382c3aba0be3244ac3d331bd3ccfa6586305c9e7d2c8ea9b7ffa159b99fcc07116392e56c717784e7a7467f7e3bebee1f7b6bc35e7c89fd7c7d3954a52676a62527af3912f4b81f304b088664d527a87d25523771ea79bbaf1ca4c221dcb92eeb8e8e6d844c6b54abbec7642cd10c3880b66772134da214b7e5742a7f067065917d19763e04fb5db790099f6a544e04255376bd22fac89c0513d0dca97a8822ed461ab5e9a11db38e911b138dadbb0e845aea910a9cdc1bf2af496feec3433720200d8028be970589afbed3abb019c3faaede826ef1ee165af5a741424b4baf558c8b0b9fdd421723d396676d41846321439d92e8ade76bf29e79d062093d7c2bfa2160fca50a6fb3db5e5221b848475843e3dd94b640010fb2b705948f2b5ac1b619e99444da84753d4e7613bb5f0f54ea153cd1a64d475e8585eea0c8047e911836f0960d0c6cdbc05c8bdbc695d3417f30d01e6520edd2c08890640ac24b32dd99672993e9d89c8f79c0282f5c5dc427244ee5e043a7a510c83fc67ee8d9030ac56e33ab4ded55b006b3530c1b187a6afeda9346075ea0e8ec3e95fceb95b8816b4918e1d2259f3aef53f787ae93a5a863fdf6c696fd0b693e12a94f7f922154fae46accc359af8fc529a1a855d37a98463924f4c34a68b71905f77c75605476f682165c367f0f09c54d26de83b594b1e2b3fa64123d899008220acf08fc4845d055954b9d51310b42a7495b32a468e573844cdfd130ae02ab4d3044b32b3beb965a9c3f3334d9e1beadbde5dec3c3a6941d9e439b5e0448048c724968c96ae5466d7989ddb4d443d6757f29fe0629634ff18eeb03d803134caf90c207251869dd9b6b00f8f4250042dfea9b7be55df569f3986055a4bf5f30901b9fee4e39d84a6d1145466a6d82e586bfcb05e514000531574945cfbab492b042f92389f994e718a23e6c9d8749c66585844c75a594e77870162af37df3f2ff1e997cf58b6333acce36ce4080f6ca56bb06878b2f33604549b8e2d1a4ffff560170a9767ab7da4397c5700ffdb4d292e3a20cdc94e0f836c15fc70581e0b2c197cc6de3c7fa4dbee045665d106c44bf54c62cbf841f5c68b44ae4bd4ff8c337d73dfc01c53a246d1694040b9445e4243237e9b1c1e231e874a5ea08c059c5e5593926ccda2728a7eef89d0b73a01fb7b4aadce51602b45191bbb45b6e956e1fb4d51f8bcffafab3afebf213e082a075fbbe8d7d62d15fbcefd1cf03cbc3d354f9c5a934bb51520e83c8f62a75a1662d27c862aa6354bb8e6c1fe39556acdea11eb00e3749d57e774bf6b6b3c00129d22fb1689610ed1afcef76768da27b6ade61cd0d3ef369f10341cdb9bd89bf3e64b6005aa04c99d12f4c382e90cce8374fbe10140df8a04d29a43678859bb57c5eda49b55ca1a37c3bbd7e36aac9629df3f5e1ea8a9a255d582d990a7d29a05f161dec425eed2f1aa0bfb2b6f5ad554ba886f4dde4686ce4afb88e51882d0b3e1a01d7b5916e1b5b4d43fc339ef54d6962631f9408a105c91fa0e9f9c2efa562ae364eafb99f52a852f5d52849981677af3fb1ce4496fa6e514e78313a690a64c1da80c5e625d4da734f7853ecb956628af34bab0b684e0c46016c22df22bf91a8fe00e475b7bd670043306e77389b367b70e6076bf0d84eec215d460017c35c4dd09917447f658b0d6b6fdd63813a233d1829332ac038b4ed318afe91aa91a02490718edd657c56874e23ba9c3cb59bba982a81f3692dfad9bf76ddc6b79453c2037f687d7fdbbe9c08f533534360ab76eaa585c82be2b80d54a31ebe31ee214372736bfa82cb5a6f19785dbf60d184ba62f6384bd3b59dace21fa371beca41210d1d91657e05693ba72d1dcfbbbb4790898f8b72495044456bc4f028fb0133cb4f9cc4e17abefd9e50461bae46f16f00ec2fdffbe66053fe5642f0c8e546790a2396d86992edcfd5211b8c581b72c63722cef93786d31d2ab0eb80407acf6ea3ac2f3dd1eed135cb8eed501776cebff813e308580a9568695223d15e6ceb64d12689b32bde586b6e5c1c6274a59ee2fae061afa94ffed2a0b80f0eb4d6719487ef6c299d2f8cadf1484a311145bc07b6347386a8b63160ef580dca6e6481b623ae494f48165636a52660bdbbf697acff8926fe04dbcb02677558848d50c1f5b1e4d5118ccb8683377a7499b18bb025055d9947599b207a7f769a94591a98e41ee0d2a25862c5ee9363d44f5860cbf1df7d1399cb3aebf6d00d6498740b6d6e1f9e1306df0512b6307c82c3f72f979eb3289eb0f1df84cb6c7f25ed96cbb878a991db0757fac40b3dc18088c5a5d0173cd1b2718fde880b63be4d9489dac3337d676301b94209eccdbe68080ed78b97c99f4c39213cdca52e32cde71a2828cd4fb999e514f388be201b6e73dfa1c383d20a17c34efbc2a11d2587d081aed9c43a4da6b450755ee931667a7ce867caeba91bfdae87d137f86cad06b0cc16dbd4bfeb194563ca6adb0d3f77eab2e00de895e17cc12b858344d048cfd4b4bad036c540c94d41e2ab409c6a04d922c14355ae6b2f1e0b526d390e04049e648d8d34d21e8dc9881493d3cce1e0e0641eed4f380898f7ba0e0958111edeb40a9a5bffe3aaa2494532b3de45488279ff98730a6a3a3ec1ba7088c979c687f59ca19c1d3cfc4c8de4a6e633db536efde7efe5b604ccbc644b0aa65f23e8ccfd114b71ac936da1e067fce864be8bda1f2f5173b1852a7dec7e638e1c1d1f0a38981a3c4a13a1d0e8666e8d94747655055974ed7507885afac60835e05750eb7767030c7b021bbfd541137746ee58442bbcc6300663384ee8adec513b2fc87a7f2da317e93d227e3b249e191d8060cbb9bf1103cfdbabe35e80ee763167fc5e2d13e95d9054a0716d6f0aa77a99931ccc42c0ac5ae4eebd2422f0aa4cd9bc3556ce7005f08464e6de6a6f5b6308a1e7da0e7fc051b1c0d97094448fef348a15bdb4491cd76242c6cb9e3d2cb106ff8c1113a2ee073eb6f8fee1c7020f1d5241449e7aaa59b4c0b0c91fabf55b00f6576034f360949ed6776fb89e1948d9fc7ff89faa05d232ad83c1371ef388b0879c0d5369a5ebfe8763932c57f224b75263fd151b861bc87e2c58bc163abfd923c273eeef50cf55fcea0dee72cc97be9611e739250b3a2e0cb08572ab5738b97b6b615e5307780034af455b40e4e35a1f942343bd52e1758ca8c9791d6a60274dff6d53e01580c50171af50f5e1e92a5d9495d50eb9a11244acfcf2b0f128b70bb1b08878f780fcb85fe5fdf307e73ee852b08db160f454063c31867de75cb39881c10af92a3e293e402e31e6e3fb4a726df4bbc82cb6abe1df731cdffa231bbdfb72eaa0d86b5172885b416ec1c932e6d3f030a14578681b65893f9328280cdba7a859752903f1f0148b60c90f71f6bb6a9f86212cbff0196917f280654b66e38f2835c90e7418165a99a838d49e5f3854f37d81588db5b8041c33dca3f0791b8b175dc1a4e2167550f962fbe2f8e7815554664a063548881b11a16993e8f3e25bd4e477109b76bb0de07317fd3eb025003beb8f6dc7ff0e29aedcb21e4108ec1cf0834ed9c6705e18ff37721a613f3fc73984880a3333ea0cb0e5cbaab2c632f642206027e50cfddec14054d56f61abe5a415dff527f5e6c993893546119006745f05a592ff7d2b4e0df9f18288b3d4860350fcc365e552b2e92517d868ac19a3cb8c766bbb14686dc81b6523190da2a1678c1d393bba5ebcaa0fbf6fccb3e3178793ef5e984e11b6b1b2cdc035f4cb341fe38fc0142949f656f18183d7d503819dff55a5d67b22cca2ef98ac2eaf0fef620793604d9f714dd5e64cff22e8db316b52647746faffa91a248f2c1c5449940fb726231c4b3d30eb6a7cf1981e10346d058dc3bf44caffcf3b9cbb1f586cba14f831e73c5a668ab48b30fcadf52d9b8976ab03bc312c4e366c433b2ec15ce86ca5b2b652913ff37ccaac000ac38b94936da498497d7b96df1de66119f98a475740d3bae4ed3c2be234b04379ff6c650e3930f6ffd7caa6b16e591f11cca06f3c56d454f371652ecdb96218abc500e685ba6745cf25cca14ae3e6d03a47947ec4366ec5c36876d8b7c00447cc7b184b85ae11a0f206b5bcf14e80f9ad39fc42a1ba7d2a126c74b53d0612e8fc0697bbee585c5f3b0f0b88f1a46f2efd308e7be035cebc6478aadf116f12bb1f3d450b09cfb688c292334f25b012a33d616645ee1932a4940c92b76fbcfcdbc052bcf884c8dc3767a56a610162aa8883f2ad9c1907e69bb3aa39d85d6ac5e9f86dd969d3fcd5775abd1f1748a31de75fccd635abf4b9a013231d1d37a06d748c5284d9afaaa51170cf7f58cd36b1e705752df963b81f9946c76ae1e26190df60dc6613bce1ad8e557aea4db31a13b0498076c1d7e6d3c3241f8a3daf794470036c34a7c3016a7e06f6aa032471ab5709378a3bc39ec0a3f5ae293ca75f1b9ad06ebca9b167d384be68da5002f94f07227da35604e617ec5a35889c4b95fe486ff012c1367ca9a30034785f8d5a601597d6f0ad459f9c25b427f30ff32f66d2d27efd0f27d5137d2c1e1b31404bd33b08e7251b362b66f37a79552134605ac7ef740ede575342fc83eda8d0ffeb457fe4b76fb5fc2d123b8170a66f03cc0a5745a2af45972b11c7ea2dfddbfd2d6910f41f3972764b51b388ab3cfe171e51681572609204806ecb2bb0088a06f1a9cc22315d0644ddeb5c75993ad3b3b4dfb366c2373b17ca9cb366e680b97c706c935b9d8a7c7fdc99282089de8b796e04ccb9f90fbec34624589c38df19b4abee78789","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
