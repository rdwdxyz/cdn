<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b3abdb69208f764eed0528da3ebe5e19f4e0c40b55476d95378ff881cfaa3be71086fa4903aa2c06e50f89737c42e7ce7bdb605cc916fa93528cf929ae1262b4ca30cc57e928e8c7f3c93a80e2ae596dc1beb1b1dbcdae7ef89387d2a958e7b5eede8bef27b0bbf40e3a5e4d5ab880e78ad585ca470cb0181e52201067d725240ef1fb5c7646bd0a79035e1df2aca581042b2dc6be751024e79f515eb08ade294b367ec3129946beef4e04180f2a1341d5e865431bf5bc42fa09280c293e6fd54ae36bbd2b13bfe58274ecc70b3481449f4fafd89619cd84a33958d099a70397e2a8dc09fa0609270e8e7646e4459206639cba5d0778ec6da4d36e16cf677864827449576059124bd5adb955d96f336159f09517b3a9d25af86addd29485b190360876a3010f0e1e95553d189c5cc013efc09a25e1b021dc917b3891b09ac6f7f68594df694ddeb8ac7f9b21ad00c772a3cd1f5cbf27e6c1aaf438f69c84daff77d6755da391514dd3305db7a3636aa9b54d9a34e422c38a667d5b55d0a20f588a2f87547459cbf2653d3a64f9aa0c532d88a627db1a42a0d59414c6347629e2c1c427aa8a9202a80c6b300e85308fc8f4a89f86af340cb6994e6737eef5ebca496c38971527632e50fc6ae76ea8a7f00bed291d14782bd2a0dc2f48882bb493d414a4519ff01739846a7859aa2bb722486c406edf9c74a4f50d047b166faa1d23d09944cf05424f32fa0e79ab9f0d05a2d6ca3a0ebaa9a458479394986fba19553d44ada3628a455f1b07da793444faed0d94d74f22569ae3ebefdc30063edcdaa60c0b2665ceba1067673296982f7fb67abe2194fd6a7680da7d1652e62139e62deef20a9a256bc270625e2adfde19fa2af855e933da9b8b80633210d01d89ecf2a21fdbcc24d3360320701ffb40518f2928a0e3540b264f2521f0f49ab87cc58c742f92c286108926baca14bbfd4ab156d03d089c5df18016cd9811db237ce002f4d039e8ecf371a1af5e83fd79492d1d7a449e146dbd2fd9fd8827c47f038534df2b204e42c2cbb1bcd3315bc12b433dfcd85c54b467116ac6fc3106c804838ebe79c1394a20603bff0a20399f212df3ae1455d8119bd39228c81129641df98ff0095373f87a92191f58d1b8769c7d69b81e3e0d21ee707380497633f1382eed403310ea9326f64c5e9dfe72f21866de304046c56a18424b407f326f8fa209e056f89673874788013f8a30305e05e5cbc083186ba73f448eb50f41f87f4812bf57b9bb0860d70a017626177aecd6eb04cda2c7b217fb86849a8f795836abe77e3ecd5d9703014121b8b171d97a22266165b69b7c3d90299599c994a39c495733146ff6acf942a43d75750a156f8e2f6567f873648a7a41a6d1bd1a70b431de6041674425891df11a43bcb1866d4061341f624e5a9b54a10f505216657807c2e8ea0cae1e991f5d4de4a121974293e60f1b374ea26325e1d8feff13fb9cc614bf78daf54ce78c09a10f5b6efc7ad14b1e6ccdc4bb1b3b97bf17fdb6599b9b43b51020a758ec83780a39723ee377ce9112d7d14488e69dfdf7d0663b00a5613c4873741db3dc4e4e1f4f24dd01af73a810202f522d8dc6fb863bc2c58cb2f2d2edd7dfce1401ef39febf0c521a7dc40802d052ad0e3e3453230b2b31eee87fa698235012bbf70bf515f7a1410f1c20feffb356451d4e9bed46dee1e1992e84e5d6a4bad3e8105038f98e06a995f87f17a3b45a1feb89570ab9720bcea359f97ed1494eab1f1b3754b186eb0834e31c1bb70c88cd7098d7b61fb338b908dc9f3ad1c721e48ced3debaf5acf417c19a15e5cc958fddfc341149b02a32e4cdf322bfef1a59c780d766f9dbe0da76c91bf6b907f0b0f5a8081a7f53b5e4e8fb4ea4043012323a57f0bfd56603080fb2b8e08ae310716bc4c8101bf41e070a63366520ac7a1da4044fa424f2bd09438f9a6434968bbbac7da3efc8a4347905233ee90a901edad50789322177faafd173d26c34de5ebb9fe2e5a8fe85b7742b84f0acd149fc83f6005e1b78ed15904135a71339573d61ccce37f3bae5bab429bf99f069314f02e82a9fc38497c8c264fe29d871dae84ceeec62313ca87f7c54f0d8963a9c5de5c0a9eca66edcd43c1fbe7182886f8c764d6cd52be6ebf533d1033bd974b5c9c540072ae6b17e811173fe0cb3f03e4b369b87d1ba7216e5757aca11251df8878708ae01e1c5c0a2812ed71f27e0ed2a14181f05e0221929237c38ae627e360774d7af93176b1364b9cabed6ff85360f9706561dfea9823c0e46af0f1ca54e2d9f8bf7a09f2f6266a6cdcd47d424153c35bc39b901384596f3bac7278d9261789ec1849d97f9dc98f1f86ca12f1dd0d0fc3932af8637a887e43a91d0a48867b1728553c160797aa43e3c0d65dafa45e3241b3049f7344054f4188506e0fcabd4ca3e2a124c7f7a25ef685638d1248b5d1822dfedb131c1b1ee501a0af61d044cc9cf976d1832022b85c6ea9bafd811f877cfee6c6328601dbc624f18b1e6cbf75a7f23a16c87890d31dad54cdb77c27c7eab2ea18aa3b08bfada9871dab35c1c509f3fdbc985a6ef3fd5d3e75344197a3999f54ed07c6c959c718673ffc60e671166337777ce99ffb533afbfa5b4a9c80ca03de731dd718f871d0a3e2c3fb56ad985d4a2fc9b5345f2700be8ef4dbd9b94e56bb7e4f463894a4208ec331134823487736ccb7a3a560ffc7ca8186d6befd6c738f0cfb3caec9f2daab43fc7336921184138c519699a82925a7f102cfd8f806dc9821173eb7cc898872ec654e4cd5232e2cc8ec06980e4350404437bfa24e41636d0db71b28551f27b4e01bfc4636118d489e2bfa1b65422dc89117b9303a240cc683ab1c8503cfa167f39416ccc125e43acabc66f598c9201f5e518461cd9478c4707eb9eb099866da48c27e2c13c046572315a68e7c04b8fec2b6f215b48daaf76534f313fce297b8c69481a685beefcacf19f73aab2e09777192a2db6c8347cf3258e097ed52825250c92ba293d876592da82223abd09a778234c09bebf8591015786a4b6c3d982687a0432a3f8aae46dafdd731ebdf72bf65a1ddd9923716b0b7b5879a31397c8d98ef1b8224140a28baccc11419c6b94497d587f5d31401de5c1e8da47128d1646aa2ad211ce412284210f927d2a4ca70032851e82d53048df1be69a530c42928f15d2acd712194fa257737cd2b2b82c292cadba53048bebebe52c9bddd9a06234243c12e954a7bf5ee53b7142bb84b0f57897401fc899fa18226605184f15a917ef89a1559757db6aa6652970409bfe54a35f916ad44b420db076ff54f0fa31fc6f8da5d0623fd151682347840340c6c5445f126dbdbf89550bb39f817777d491679930858c2b8d4a6eb01672d717c004ed6fe5a18d807ebba6cd44460a5bb1aeb0c0d0891a31918bf8823dcbebf394b4d995ae4c6a8cd79b23e913a050b5c8fd802f1d728802de14536a1bc28f0e1df309283a9b2b5ce0d2215bf2e88105e6a0c6d1984df451a08efad2a136b2825e80841ca993fe8bc7783c7f405b8fa09a5d23cc78c05150d8eda73f7c89700c5f755c446dda8163a0ee6115f1a6e2e8944ab92c510535cb80416e6921ebbc3f77763a4585cd9805f7930affc1a625c6ca43e9a7ad85b524ee41e1bc527e45460a386c0127c35dc8f425fa7c650c7a2e6ffd6b16b321e5f6f36e9e290ee74af10784d2a89ebaf86829f4e11a7ece2d2ed2d9238cb9fed820e44157e3b42c8f4ef2d5225a08344abdeaed9c8f2a41a06047b6cee5192b5c4145e705f56358d167418fe675a5d35c2e90ddea3df091328ef7526a87ffe640483c664b21d44f42167a3750bd6ca9b0db119c3cdeb490fc32e2bb53b4be7d233311f4ea7ed32551ba18c3f1ed062b96597b97e8e83550e6260419cad216b6bfafa3016f2c26cc2eda006c109a39e9db990d68b7e488dfd0089c5e2299d990771499b32248af025412a8f849f9cc07525bfe8eaebcb823a8746a2882ed602f9dc4905322f1d21ba987e08e12ddbb79981eeaa9a83fd001ca984d7723f632024aada94bac1eaf6342147b65519770dd9e99e868a0ea7da940148c26aa00134d39408900ba4f98b875ecd60fd1b74347a23fed16931adbfda3623cb4aa99deb20323e2d490e2512a71d517dab2464d4009987f985ab2247b82d63655d6c333a184b7fd6a1b45e72d8a1634c2b63d41a4c3b1226536f6be8d514a2f92b2bce0bbc0675e8c2a4fdd611028e5e19bc800abd9717905e66f402fc41214b4f46fd90362bc886c422311fc5a94215c14deae68f989bd9121d0ee592c79c6c9dc4101f132b4f4a610c1691fd2d63ba0e3a16c45d335e9d9bdc15435342f503e024c3694847cd5e9d8b20955f020428eab9cf5b1453eb58276d222710f291edb8f16f64f545759b2d40275a8f894f2441720341b8b07b4542eb1e1dbdba661972fbeeeb2fa90c5f1bd9d181546d50d670b8dd88cbf9cac638637defc9d1d6b28aa2ab422d3a7b2cfa5dfc3f259fee86005d81b7a34e46650482711755eee976279dc6ce5a0fd5ec3bfbd93a232d7260e35ac95c2f3160cade8d315cd625f4a8e029a328e76c06778359aa657b3942698223037a8e8ce7b0ad5934ae0052c9b4adc9c03b66e33e8b38521fd11e6a6a8d205f71d0de0783d2b504a1aa33549eac1ce39e697c8b04ace1b4d574f85f250307c8fa8b3051d71694670809d04aa928d8424dfa20749af1d2aa7ce5847c4b57df9a06ef55cc97fc46b121628772c0196083c08d444620d66c8d3e65910bfb53ada3530da201588f93cf790eeeff1ce33b25a02d7a6337ae291cf451432058a00e492949abc76e858c081c2ab9272856ba460d93cc37eb23d2cd76eb216201cd4b8aa5e1d4c5339294b3eeffb49151c18893f5c274b6340e3004791efe66ca4f5a975a50be791af713561df99ceb1a08b2ca946d7fed19ddaff5670bd97c64b79a7fd911de1c5618d8651dab8f63e0df97d962dcc9fd2ff4b833ab15fab10992db96c16c52344db288a987a2c9eeb425626e0a96c6143a580dfe30fc6309ce2d8242b7c92bcef456e6d6bc1500b37c42cac04acce11b6a471208afcbbd152aa67c072339ffa344127526371fe2c346e82f2373a38e53227683eab58c628e493ee974b9364be531295e1c8a2631cd19a5637e16f6d917471772c150dcedc7cd62c54368f987ca5dfb69dab2dd01a7548ecc0c5962961b838f1d1c7f9d659b005b2d3c8662fce9de57a12d3848e23ef80d50536b077653db71a9aa8dc3befc1804fa5ed350d39db3d04e580e02cced7106fbcff34c1d37a9865602daf3202ee1f312d2cc0dfa62b35b7ce09028118ece179a2b3b35f2fdd2c84fc304dce56a8a36b5304b4fca860379cfe6baff5265b9c93a50c4d9778d439a297f43f54e49e5d082e6d674361ae6de5473d50493f916a6a9914e918f67be9d9f27e0b6ea9299609f204a021890cf727ccc10268748aa4d863121b2c360539593db3894345b03670f8a56d1880fdd28bf18c03fe0bdf68015298c5a2e5e77d20e8337335d4d76db650c3c3603552b02b7874fb19b0d8a1f4a9dc242606404f760e43ec91f56042ab400daa1cbd237850691303d8b41e6451c2eb9427f77244dab6ccdd89b18377587dd6c45b290240a00b85507402de75f4befcf4259f1f8e569eb29a29307dea66bff5ea83dfa1ccf422e1aad3d3997766684b2dd80eb38b63f993128056d36d44923cce483bc801d011e93ecbc897ca66c7ae6ec56477b30097db70acc3c0ea70b9a63fd29f267f8909083c051505f110e8d51a182dd1a303b9745b937e5acf7c59da663d9aebba13321cd72f62e7563a27a54a6b7171f18ea323f664487d562f1cc6bf9909711c1dc2d37aa7d907f00303504290619770ea193bb742cbb7d2da4ec351a8cf2b5c0e5ecf235927fee2f9196f42f47ed1bf03d79815884717788455110187b4e8f1b5e3040b5f20f7b1d6ccee3ba70f19900c6fa1fa3ceb22acf19820f86acf1a0528e75c7b5774aaf46adedd0d36223f41f30713daf818df131f0d761e4937a03feb40adc1679b635c41b955b1e85992f00a3ebaee1dd91052946f06c15e60dd11ca40544ebd1c2662b7a4bd009f70f73669264953c4d013c2401a376c0ccbacf72eb0c13d477c121053c7c35338c258226fd978670ce12d42682b78ee918962a92dcdf9c72ad24beffabcf4232f01d279dff6a8a904349231a68fb16076eddb9b6c93a2309613b7b1fde7b537f09d8ea88d8d06c13cbc59bff3d8280f062da3c2950df22ad6886d920ddc954dc64b9fe87640708b6bcfc30b4a5b6452f02e569d1748acdbc46c8a3242ba74fe7c46286f06acfea9319203cd2f6834c74c84154dfd65f7b1a8571e1c28614477621257680d4ac561b141ec5254c659c1beafa6182834da97c16ba4bad52effd7739587ec9c31cfa8a6220581cefed299d4e266602b96cbcd6cd2c8f0fde1e48273cd27e6b16daa869cc8b29cdbc3710ea090cd89a30f8c8b7acb0328e664b865e8553a97a6860d59f5649a31dbba281d338f575326fb66671dbb254244f2ec264c22e199a3cf928d4abda00f9cd8f3f727d44ea24fbc5a2b21304b62a88aab19ffa0599d2a76f269cda8c98c7230b4b37e91759a598f6ea8b0fd9b5ea42ee8e33bb1788a8cd428701327a26ca1e574d9bffd9b729d123fb807b11fe9469f731d34eb00b42180dee82ae798a153a4e372ff2599bbff71b070d0827c3d1fa001aa1983f009819e99d27988b4f1ce9c15599f2c192c41099e9966ce17f9b2e6251b8f701e6aad930c022f8ea4c0cc2982d2c5e7310d9ffa5aa32f1d8c65f568a12e9ef2da19416a3bc5db0615a3c54c0bd5c733e8056c6cc10e195643dd245eea3e89ac7e5fd673b4ae5f50e3b4ee5c703c3b3c97c909a82795527e127ae1cfe6998ac9909da19e7f3f02871d6a3957f27812be3f2f9b2d24a99fdc9f4c0bdc09b2d3d6faccdaa963af6aa5b07ec628e7a81d37c3739b1a707d7f1fcbda0600897ad07dfbc9c729586f8896f8155cb1b0544c729a6be9cbd4dc0376ffdb4977b9f4e29e9036bd5a57f2cab027fe9ec2f09c2ba3bfe5aedd63614e3993747a7c25296da798f5dbfa84c71a6252a9da9c14a9c2e0bfff4dbb5ea8fd1b87bd700dd3558eec6d2fa5cf51e4b177bbc2052cd2811715abb026b2b87fc9f51bd61591db47734d294d0019b6e7b7011409438e512585ff1c9bdc35c4a7406ed4df843a830a4c51b3ad057899547fb76c290cd3ab9969d5ffa4cdac3e85815d7ee8f9eb0f4d60ffbaa2f4ef8241e634da5a0754b5cd0751c6fdb5b9969c4085696c5bd1a9ba0b742107691756196040375ba47f40b45c369fea4375baab539b985583ad7dc33b0054e888a569d6f5053ce8429fa76cb1b739c37b44f48441b77e70f9cbd7ad16fd85eb78b027163d8962986b3fae6c477c06e4f331d35f42bd167d8662c0ae45b82eb6db0f3a8bbeb7921dad80a94d899ca6e2c7019d742d4acd45251d7886eb187e8fc0709a3d0a6126df7b36d8d615b7a8174572376740dcdd429898c5eecf5f9218334c39cda494cfa08bed67a846080c1d398195b7427ff68a87c7d8dac2e7c29a68037625c3df123cf4206ffb92398b95e34670bc9424dfe980c5347b804619d1b56b67ae99ab85bbf6966166e6293d1dfcace2346b17b5e561c86d1b14c9f16f4649330d5a56c1f5e0135035cf3c52fa49ae43822b31c47adaa2a9a751af2dab6162e0f3a4f6a737ae6707f0fda1028f7d161054c6d79107717d766955330fb0aab1fe07b8478dec72c6906c9efd141d6f7c4e4843c5d859565b45d9fc5148408334cfa0d46b30d02ab5b5b3e3a4cfcc7529660be500873e2fba1578605beb6abb09b8187ba157da7779b1fa9c6c111242952f7f80d2fb345045e53001712f96c0a1b042e9bbaf0ed55b8673536dd88db9ed48b5cdc268812116543960218a337e7e9e1bfccd8fa7dd3a8df0ec06b916c31e58146a13b85604f05138b5e761524d6f475919b4978650ef8c86b995a3797ef673e45a14509e760f5dd3b2f2b82c45afa6ae4ba213f4da1d2ec6705f182c36fb60cdbc5db258442fde196fa9bea76599d2c3d905028afea3ee16efcd162651b17c6a630e7b74e92c6138bfef0468b4a610c79b8b5e2ad94e7c9e74272cbddfdc224e9bf58ee584bc91b086f686d9cbb800f37bde61d3ae372958f356f73544032a3e7e58e1755a309da06d3a50a79181cf18e65c5c7682f88a0f429788f5c695eda267d4a4c96fd19f28b16a2fe0d1385eb908a9678acecf5ae9774b1041437af71bbe245b9f0150a5a7210ce0966828d839ddc0e79ed33263f03cfdc736a311415f5e70d5c9a7ca338f537cab80d318e8af7c4b0a8110ea40c23d788212c4ebf9fddfdb35e0e62320af5f4aa6095db44b128293e2e4860b83684f21cc52c6826dcc641831c54d8bafd70d364e4e8338dc901f315fc49a584bdfeb7b2313926056f4395cf13a5ba84715286925bacebb717a7ac379511f6c71daaa58f9c3faa6ccf044c7d92768916af72d11250ca0d9fbbcbb37be39f57b194ca25b76dbcbe78aa8c7e76f429f59ca63094318b9e3b10689723fa8939ae02fe8f46432420f0382bed1c765d8c81cbccdc7f3f424e867e76a656fdf9da0cccc8cffdc3a16c5049457a445bf953fc5a4a1a775b10642722d08e49ddbbabba3a9f31c84e79901455997f65c43ca9df93c70a0f7756196cfe93536339030cf76af2ece9c814c5b7ee9e11bf65e79904000577e2fcde88e73f021514d2a222c9ddec700d671e0c2ebdc5100b2204429331d53287f2df2588fb10a663af3fc3d461fac32eb04e9f468cfee680a431e4cbb12a7446f1f61ef7a398b86ff95bebc224cc9260fad98a1819025e93bb63596c5d2c3bc9e8bd018d866fc8a9391f063fd4ffd6a5059a8915233cbe7e92f09585500fb2be949e9def2d47417f3e73eb800544953039ced954af7c74e0c4879b2a56ac781edd7100549c03687db397f64865fe5800640bb35634259bdc6abf0fe2d7c681b42bd6b4af1f0a4e3e7250bed1e78ba0f9d11391b433a48a0091a69644377f6c1059c3deaac58bda25640e62cd2ba3e1dc0b2e2e512f58cc3858566275e26be00b069347b32b1dd98533fd6edbb370e2f45f99d7431d6903b65ce44a81d2c879c1b20def9dd9be5bc18eb3663e7971eeecc16706f6471cce7a0b5f2abf29d5143091daf460a311b606c8a4ea7cb0556a560bc14647622bcd0616ddbca5cf7cb532e267d247654613b658b3d61da5486a1c0cfdc34fc023a01e668641679329ff45a9459595c288c4744ba6e2a586f9cba5fc190931272d7314d2bc916f142b0932c727ee61e426e7e5c88263c687e65f9576726c83aec52e920f41ad36282a0083d13c193ecb5cbb087949da782b310dd71a7a550b311692af903f8e972395bdd096bb8af17eb045de6dd6369d5d79663bd51b10796a51ec2dda92db449f2c39f30d950329e5a1ecf4ed21c8d9e1562d88068e6f2d51f93699d6271c8350a2f84ec35f3b0fafb6069e9363928ad4573338ed757164b3d2016908c11d32d92db7a2dee64598943e17a7d144d7b7a228c68b99534adfea0c41b93aca129f7c008f1ee9e610731fedd536c69587ba4edf0e86ae7255bba33c5493a6149abcdaceb3ca9aca5eeb158dfcfe623c9b20280e533c3b609a2ea4cf7814bc29f6961233df989907a43d246fb282b1dfd59655a07c8b9cefa015fb93abef9ce64f23c5f5bc9964cf2a676953a7b75a3b40620b525b4b2ac349b1573dc2a3e1574d98b840b906a098af8c9482b9008d9130dcdc7fd4be68ba6ff2470a00712c6253fa0f5311478dcab7ad7b229cf8506e48ed1ebfe5b0d8d877ebb2bbef576334b5e4ddd4e7a64b0b7c49908d6d9a083e20921b5ff9bfedf2bc0d8c2621c0597130e60cfe1b899f49ec289d89ca3d9ae341a8a0fd2f4af5fdae7ad3d0158dd926d5d53a69804bb4210f464a1fa639f3bdaee8efaa84023674baf3cd84c382ce192234f5fd9d44d24bff3c6bb30ef3c948373f7ce72e2a88e966000d85e327fb8467a4be7449ef3fe7378a06422b4de6e62809ff3b5860dfe86defc5092232238cb8462c76561166337cba1723aec96e99fae24203aea5da527fde1fd3f2af29eed969806b28b18af120c11e68dc1d4bd523ea75ff4be7e2c0b723af83d4a13439c2a016b73a46b48183bd9105e8642bd997370115b08b4740436e9248f4ec0741c0e7425e6d76bb95fbfe4028ca306d50b1fa3f6e1e304bc85447825d040ef026f830018183df04374a60d379dd7d2b9d9fe7601a48d19176277c1bce9dba4ef70cf8f4057ccc741d2df09827ed0fe8a699b43c59e9d0dd39769cbe09abe758fbf36eec45ff9590d66e6bee293f95bb896117d2a7827f4d4b9ba6b327cab40276794d47d9f39f2167381ee11392a08b8c1611ee55f0941d889650f99b629c9437166e9fd1eda71efbc81df9076685c64c704193ed61e265d75b6e340a57fa67d3bc83996f68b964e92d662215c1a4288f73ad564977dcdc343546044afb21954b2b95e10337b502556f42bf42b86daa1377975cdebdbea6b33bbec2d1d8442d0faf64ebf53d71b6aa0cec6bd54ba77b502a107a608b329b7d33327676f7fe5f7329e4c4b7a8461e31da3d1f6cbfd43ce14eb73f1c8038b0ea4c4b3f27d8e7e98cd0d02792834bd9f61dbc7bd58cbed6c9589f7280a816f990a765d6dda7e980d918ceaf7ec06e9b953fd8483c41c3ca9b3d67fd41e5830092373a70876602c6f753e698c865902a4e978a9cbf1392b080d0abd6deaf8292c52f3078947f7d814177cc7173784da3ac7d8b8e596141fc88511deb993bc94931367cbdb7e1bbbd13c772410e70e67023ec06afb2f1219ccf226e816b4b4846dcc8258ec421e11501d672afb7b8bfd10beb77990d9c243864709185431cae9e4cf5134510763c840a34c15bfd7be3abc3db88fd3d6a8800700074b65422b4980ae1c7128da6b8d4a58992057713d25867e425a2de3fd1725686b0b50dffa4368576a2c5bb6b2a36bca7d08488c281c92f0905562cad56dc4e1d9af2071191bdbfef026fcfe2e4027bccd0decf5c6ba5f3b30e13ca62a108f8fae08a4772a5dc4ac442d38aa23a33ae48cd05ccb0081b117965e3025b39662a46ec73dec21b424215fec8cbae8314356118e9fb66f8450d1894594e5aed22fd9668adea654431c3caccfb8ce6afee8902761c20c0cb9f96d32914b4399b0ea68af3e41a667ce764f47ae016182dc68282a07d346c1a7e7327cae1036b182ab6fe493c8ecbf856ff2dd7d60f02e0cb54535d2b9de223c54c3ddd7726bcdec694d9a81b5209d3fcd3c9b93a7cfe214a33bc6eae93d1439f7fc9c82bdbc268040474b9569b64d0dfba63bff7dab673ee178c3a32fe713a7cf783954a72c4c0ca211f1c192105745d05302b53e0d4ca461e4d9ec286039a0540b89f6f38586f92fcbdbe02fcac4d4f8fcc934df1567527778f36ca51177c69d7861152f1a4f96ef0898b0654f2e6b2eff478525e9cc2bc497907424a006cacb4c3fb972049aa4d94666944efe32c923fa736922931a64690870c42b555274ac23785ffb9c34042e26443a9a44eff573105e79012bcdfcddf46aad985be615fa76aa2d3a909ef24a4bfaae4cad9134c0371b51041dcc1e380d6ff6ec2f9922fcf28283aae8d1fcc97b9b5eec7adb40ed4b0f9ee32b89f96dc4c5a74cacf3c05219f1b6944e0dfe7503172fcd9093760ad487d5327ea3f433987b78ade0e3c14eb0557ef279799269e0631b2ec277975046b40b2927f64907ff84832d3c2cd6bb5f8bb4ecc31002fc907a72d2e3ea2a01b8f434cbf6b9b5cc89006f3360716047b5a293933d463265ce52db1edda486d85738e47e932e20ca2835262778289975d9d8d4a0e009950b5690516eb733f2d37bcef25000b033accd0d630f11a623be068cc9288229114746a135a67e7130202d24dcc4e4607d3c0f0ce4415a7a21badc7df6086d4653f62801e81f3e1cf605304d002d5571ecb8434bea402f490a65bc6526da8cd2c618e1e99449ff3045d4708c8931e2c615399aeb1c2ddf17d67f74698761972ae4d0412df959d6e53c5d821ecba04de8e9c50d10e08c21285ab54b0491da1d99932bd1b97c2f3c8ac4685cbe959c7cc6aa41d63d051a0709b0c42e3a954352c9db5dfdf8743eb9dcdb44b072c689433ce7b7e54143262c20c89acd31110e1ef26fbda4437f31c2bc3cd68cfd2eb9de14fdced75ebb59a7425ccae20f1e8a4bef2c748e86d721516f19e8c9812e6eb58a0dd4356bd585231f466aadfec16080eb07e8c89616b1414db715a8b0625d5666084691f47b9f347fcee8afeb911d3251ea6634e34fdfe733d740c09cb8af1021e4bb3b78ef181c570f11b8c02ad68f6c327083f54f966516bcc9b2aadfa6cc363f50ce0720e5316e8ef9249c797348bc87f2f909619840deae0fbd4f51522ad841ffde7feb7d465e2c3108d620398df3fce08791ffcc66430730c3a9e170ff00c86a85ab368606b7d087603475990d5999db2e4d76eed3cac2af9ae48a17efec0eedd6baf7456f04ea9d0a398a826416fb1c1d062a0c406b85da976a0193a87b44d3ad24a57556e1413cc5f15323d5308765073ec7ec0dfdfa372c4d6dee638ec58a112baa89d5bf6a7f036b2c02f8cc5c9a4ba7dcdda48776b99ce1053e3cbf75eccc52ebc4246e8223bbdd9b6fde7abb8f48f0a879cd6629fa7ee8bb650e1018b7d7a87aa02d7edc5a6561951cede8abbb0c5d4c0c78cf5e624b5031f32b076d6fa3efb8ae03e1808da011db4459ec75a963c30a9559a5e9d0c42e1801b4e7765e80e688c3cff15b3cfb08f8f25f975d580fe46d92b20be79735c3d631dbe45ad5f5e05271b862691f943dd5cacae220318d8810e84cbf1167991b5a958e8799288a82b32dcbf12ce8dece84575b25ab5e021199da0f966c2ebae6d1e31e36706935ec38d3824d836f91e03cecabfc8dc28878d973f27186a502c2495aee9d5fe999e009bb2d1d6a0f753d28b18a8f921dc76b53ea3dc3f54b49c79ba8cd8c421580b1e3ff0d2aa6dabc72f7f512b6331b73cab70a7535560df5509a1732c05cd6ed1a298ae5afa71eddcf3a702fb06fdc1acdd909aab8b196287f6f4de3ee8bf0ed58beff71567a25f40b3aede8028fb65aa9aca3b584dda33e7595ebd7af5db55f50a3ff2e47de735b4947fa30fd274c6acb4ae07d6f86d06ff92eee3b1c574dd0147433d3ffdd732a8e986779323639ade7d035a68e8a81e23ce66e68c1925208a7680977c3e218c9f6b445f581cd9443e9a7e6bf275a912567b647f0cee3966928ba0f88bd12363cf44717a851a67abccfd93cc1b11423b8a350153353a3c760592fa9c8de732ccb0f7ad6a93f85fbb327791b0d50737f1fac9a8004a949b8560cbf47e14b189e34b39f583a7644e72ce11c0f7c9a845fe2c0dd88b4417f02ad4c9b05e913fe92d01f66d4245c7aa5958a5a3fb81e9692930c5a0653cca6b84178fc3dbb9420f76d25a8a30607d05870ab48516ca2618bab65f8d0532961d7423545442669e9868caef5650a82ec52fe8a034086afb265c6211a27a1724405f110a279ff1d6a4571bb5b170a00ad75212dc2107181f93ab75a6840ad3432a5fa683fb1af81c22ea8cc08721acaffa94ae3c15726e4fc9c72bd6d62227e0ad40bfb3ea196276002d2a23509b86b5b4a0b24e0782dce43cb4c6b580b42b04067ba1f69173db39b4ad73c7c49b8e404809410a7d39004afc167f95e0a8fb60419a6f4dcec9e770ea742fa8963c8916d8be91b96b801b4bf3cd1db3276b27da1240c8d26b769b5090a1c1e9db07443e108865dbc4c9b7dd3c91d709989fd1c39be87370094667c8d73ba117bcbfd7a35622ad51e6399393fc877c802cb0f42e70cb461176c95b268bb7e6bc23bb27df30471e0303385a690f6d90e6438d122759238512e8d3674ef999b9a35a16c8b2ed774451f40e14e92aa9026202ed04e74d9d111632b2051518337828a3fecf828fc60b21b9a2f8d6730b33b2398be457de3097d225796f32d7fff02a17b502b0e240d905bf8b6845f8cbeab825fee898262770024d7f5b6a5b99457666dc08eb16bfd2b86dac589feceeedbc4b570b37dca630a3bad96f40d8c30795f5652e38f96825e83e3630877056e8151ea2a80c62aa6fd39fa42263b478f7ffd98225c19003651fbaf0341f6f5caa79e3875ccefc197c03dcbefa1638f347f95defda44b3f91c265fb302735d30676d236f50ab6eac4917fba36d6373f4a870e510e45717ab0aeb8c4bbd7f712f840751a82766dce28b229871c6919ed7d49f13ff62fecf66534f03baf86b29416575be5a749968c7f4760a8c350f3bf02235f8cf2bf4fb55fde33ccd925bea9806e3eb4058a048b4c2b20daa182c3718e644fc556271a52937b02b217cab9f64f36bfa0a521365716570487056db8cbc95fed92ffa760531a8a92942634c41c1c07b8821d35c6ead9dc6d2509d05ef82060176f902543925aabdaf44f030ab2a4eda960d3a747ecda603888f0bcfaf522b59efb970c4a4f5c62b2a83bb8dfef23e5a5886ed41deb64c8d755866a72006544a8c83e10a941d36b64bd8acab0bf131d6613de738604ed88b8e34c67483709ddee8eca4541272ce8eb4b75175cae337a0ff1899819995a3efb8a837b9520262fa43c9631e62fa0fa19bdbf11d3ffae9c774def10a6ee212a8aa576dc67768048e172f8cad7acf54d4088e4924540fec19ac2d2c3de47469ac23349a5e66f1f65a76b14bb12d6be145f12ced1c63626b3f3e14bce9f6234a33a2f9122bb22003488792fbace24d249a0394785e1501e419ad525ceb4d25055dcb445c8c465d9fbdb58d81ca4ed821fdc5c3fa2a7267b3ae7bc68858f7b37ba1e3e2188b786de238dcc2805ebf549a98b912667d0bcf20726b401aaca24faddff711601c95c1bcdeee15cb6005f8e442d8295dcd938c2fd27ad3aee51d1aabf482d0ceede3ce46e4d0d6f0e89a5675a3ef0cac04e17f4f429395dbf9f536e67f93691643cfcbcbdc03540ae545c221fb36fc8cf840e8e5927cab632ac4cbe60d59332ebb045f2b46b1ce0c2b4758c43de6ffbc3d6ec8c426b1b0e50adf713e772129142d6fe36f2f2976104e74ca62c5e721271e47dd9adf678da597bed4c930819f0c71226036ed9c1b72b62235f6912d9617002ca42ecc34d378c4572dbc7648c1857d66f08f7147da3d38224407c4679a90cb0695ac23d5a4ffc7f0867c7f8e1bc57aef457007762a9b3afccc7abb2833c34628e764f9b083b6727d100590b6b3586729d86215647ee20e3b8195a6f2b8b261eddd907b98693edd6795c10b147b666bad55e786ec80cc82dfd2312515a4cb36a4def49208d51247e8d3e5cd4466713c7396726289acb7aa58048b377eb472a9ecc5d30df316d28a58f2faa3368c39f9efe5d30d4701f2a75427c66f3f55aa49c4fc6750e6faea0479127c63c4f27ec135caa4c80ce80298d600d68166015eaa2381b37fb1790751896ac53a899aa1703f0b8fd877b5a8e76bd1293576917a144b6797867813acf5f3e2aeb34305bf6e900683b7cdc9fd867e5b71a4421cd7438752d153d6cebbf1ce00ae3f3a1fba92c802e6bbfa02fdec57984048ea0d9789271a77b3c59b0e63052c8069cb8e9d8ee95ca9209d2800d45850bf0cff361a3fe67ae0709916117d328ab1096f24ad62f0829e5166c1de828a933406326ec48354e7f117dee0c74b02492a7fd997dc5dbc556be644f260aa10b7d0214b777792353516204b1e2c6eaa0d8c32e451bbce24b4642eb7cb2722aea213e09e29cdb65b2fa7bcf473e7b6b4cc2320c1f3b9f5c435896bbeac34be1bc505e36e0307db9080fa4961c194cc958d8881da4ff64095ba8ee65959f890a50190b04fc2527d43692856cc0d1c1229a3c8938531e1ab81efd3f0b6c60b2e38aaecd0149153634e65412d1ca1b829a07bf393b488dd17ba37de7300f0d5cf689c991c1f92266a244d3c4b5617f010c2b8226c16a9ac20239066285907ae7e74fb7ce0f0c5dc325d321ab6c743a9924d5255ff9a6f91634d7041169977c9aca61f87d6cc3254f022862983fc22d00abfe495780b4e84cddd24110a3ce6f9dd7a5a3175ce217cdb1bd34e60422f8707f4b07d139c2026e17abd32be45b3a315e85be37468da245be22f119dc6b7d0777941cc3ac1d00db1e599add9a9e9e42554e08fafa0f14fb07b27814e0646f3dae8b0d6556e986fa17040d532f753636b195ed04978f28f4d21f1a7ab5c70b53b193f77424ba4a090cccddb36e8e7ac5e2039b6cddf727f3602d20f368b8e72b2b1ac2d5fc305a78155e62eefbaf36f9992cf95beab545f61b9c36fe7d615c2979072c2d6dfd2bc83bb68af0fc57b20426f44ad970b3850d3ce5f441117048ae767c351c6154c896ff24a797799bda1f7eead266a69df60511f3f211a34f2706234b279cf4cf76005a351bb110733286dbdf145a6aeb766c36b11689dbb03fa2ab1fd9de7fe8af6acaa09fa4144a192cfa1a82a679622493432c7129c2d25b897d4a54cfab96b702bb7ae83e4aeb28ce63d32388aacef3a1941b31346782f20394d12b78ed7caebe7ce88a1ef551baa5b8d64f068a236d8eed05a3124537c80a9e672e3761ada0cf1657a3d00b544d84d20b7861851a3d04b0a6549af39a9d7cc05ff6b1d8b0ba6d88b82c395784fd4e8e92c067aac1bbd30829f4db0846a01883ad89a3348411d6ea20b6be5f57c8c86bf61a67c83df5ee5c13914e3e42a9de252ab35f91800443143dc80109235f903a9d666f08b4898a3ceaff878b81eb744025d679b6bf1877064222df5c52b74de90e27a67f7363217046bbd61f40820cd492070bc3fe212bb34994406a1bcf8f729d9e8f6a868627e1d7abacce7fc754a2a15c192d7932548767be315e6247522a04495df421cf119a10802468df840176c0e5797a84b4a0f2db4be40f0478057cab0608c9090203adcbf87e4a25542d2f659925e6786c80025dcde4c4bac00f5daad6fbfac92d5217ac95961d6928f5b0b75b259db9ecd72ae2b45560dd1db1e813e451cf84a77e1d828336267001e65cecedcb67d63851662ecfa1ded271475c830f5eb302527dc2274d2f2e48b7476227d9dd5671f1665282a81b13cb69e0276beb75a4721c698c7e83a5d77eab1042f0f0f13b4b6ed892d900fb21a75883c5cedbebe39ed7e63ebf71eebf269ea73e86cdb7841b08045a920119f162ab188cd7ee97ebcff21929df797869ed816ba334c1ff606643d3307d34a6c9cd3c22321632a22b8e5b654f0525efdacc299df87be157cb051a0f12dc17323e770b9bb8f722ae5c20cc697ade59f41ddb0e8e53b08fca07e389f3a5106b42945720ca8847f20a82bbb98d17bfea2faced360455185fadc840c7b860fa9acf7a84c306c36200a47cbce5e5796f9bc06c50ed1d13f81d603a6d10d1cbd6ad335da2a9583f6f2b168d58a7595c2a87f636a2126534aff1ec56a872b1f43dc50673c2f4a660a1cbb5a92fa5088e5dd348ef7fd0c8aa6c8161e4b56b6a4a3d7c693ad445dc65fd560e698f5e8f0602b81814db088ba4899534c545cf724200cb09cd0c3fcd949aa041c0f15dc3c2a76795e93f20e9b743d6635b555547589dac78ad1351a870939f3079ef8363569bb3ca7b53799b79603e9d50d366e39e27b6f28c01414a36b17ae908594d0fc53253f1b3c955e7e00660b973ae01088068b8a435b290e9c8855c85a768bcd7e276303998fec556ca50658f90f5fcc8c8503369d184eff70fa8660f7087aa1d9b1904d92fc427f6d4be1fb6de8c1c13cb17cd252f4972925da81127c812633598095e1afe7f9397ee1cf97fb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
