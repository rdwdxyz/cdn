<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"576447779b455d87aec532b9bd521c1add4ea8578d77dbe74ad19dba27d68e5ad30d03dc938756b2918564f48090847679284a8610ad275cba0b5674e02ab1b08f7e9f53a5985fbd0ce02b5d3cc103076b84617c44c98fc56a49db890961b939e402bff0af7e71e56ed6c7fed3b01f6b676afe8d96de571d212573ce50676d31ce59ac1320c6e0d9d5ade5e1555fdee1dc26127a7205452f28033a7faf932b5bdf30a8e832824a68375186ff8745a352057aee450c06e643e6c660819ec4e46574d960b9a620afa028e0d682e9b0cf2f97164ca137775d673696d197a1b57e5f592ca89f3e8911b9a4d21a4b1263ebc7ed79b97afbc1de461816e0a01442f8f0fbdaa977dac6027ccb0a1c4b8698f03d158083410786de7a8e5a89bfadfd309c69a383ed4f86afa3a078801771d6b9270fe05bb4d4e77cc48a23c23cfb86ab7d8160a82707fec79184d438fa4cd58c4c01218d512f60ac2cb7d7ebf7b2c9c3edec60d202f95cf831deabd0ecb1a87fa871c7326bf0db84891a6579128a998591331f110fe8bebeb7c68839f0cd75f29c926ea9e9f8789d3dca800cd9c4047a940a8613acf6f3d40f270a1f02afae80d9f38df0e7a9311f8bc35507b49b1d441f38c0ef5e5dd4d1672432e04591f5b3813fea95144ee56b32be2496558e90278099f6508cac9e3c90261cecc7ca2941bcef6ff0943efc5ada0535429ef0f52cd9272fcbe361451862dc0cf104f77231db19676dce2da71b76aabbd8b5362adc4aab3cb51121eac9019753ffe943154413cf67588d87e31553f0d16297489d04ce3ba091b1273077c1bad20f5c8156c714b005f4edc70de43352110272b2481e92703c633809c2bc0dada7c27d10a8f30be06778c7bf1df4c543bc4ea08a0822bde073f7948893ca788531ccb0413a8ff959ec3817646d1aa5e6ca8aeda20d0f63dfc7f97173dc013be6dcde186931ae021e80c2f6046c3555f0e56ebfe1cfa56ccfb6f58e94286e5163bbb275a878cdf03509060346566b542401555086c7fad85ff8bcb75614880801d7f0be4b78705eae3fd6f891b22dd489e1a7c7caa02c9bcee9f49aa61db7468dbe506300ddd7c38112d01015be5f075aadc95e054cc061ad8f0a149ac9dffd5ad81d9129899b0baecf7a58d665e42fc59cdfae7d98341a6c58df8cc0d3eafa1b74ed8789365880339f92edd53ee52e91c2857a777f9a4f8ee9336906cf12d5608e00843f744d1517e750fa7e6ad4f970104976b8c460a5a150db6f1d6bea56222606a30b71e7c3e9fce0a276f9a87e2f0dcaf1828a78a42a6352fdd61fbda9e34a22849846610bc1275f3c3edb153fdd733dfd89d2df32920a7706bc968422d389a8896fcfd86f882896efa2fa0ea7a0e3938cf23ef2470589d31ccd746cb91e24a9a3ff3f12cdd7944424513a247a28f7f98600806761d9bff92e8cb45c8550e121d8624124de2d8aefef2ce1288dab684f2658e981a872d1fdf024abdb2e6835181e3bf2043655693e6866f6ab7d60bc54598751c193394e24ae2012d2bc792cd424a95125c15ae41a7d9defbbd8a99554d3c34f848da1c4f2a592a50389a60cbbd137c0282b57a96ca3f19f9a034a9750dd3ee4d20b52ca4d554dcbb4e4215aafb4d5efff02106cf0986259c27b8527bd3edd640a4ed6c1060f992409751d1fd8c9c550b5f5b9887baea06afed9e87b0fee48f05675be1d4d67db8483341d2235c7bd662f26bbe171d7d7d1f95dba876626873e16703e5c13e92e214b0425dba92bd291d7de96f830e763d48ffa08642d9058a5364e1f0aa1880d55a153c630a96d327b6753141222b9e30074a2be31b75d8953e5f13b7dfe496e11c4b0ad5262791607c5b8ba6324a58d7dfb6b19539b15d53fe8b722267846541356f5b08546a0659b980b46c2d7250458420247381d1d4702470008e1b5379104e64b3c624f424572ecc5056fd4db90d3618d3cbb14f0cee34fdd67a80747878b22dc93df469d1ca306504e11bed77f99d72fa6dc870b5411bd9ddc5986162837b60001dcb7df58e4c37559575e48517b221299d1a12a73d0d79d037562da0d1add3380df13ab7537304cde677fbac29e894680574e9e9b26d3fe4df7596dec210945780a75bca76174555428def240f8a527253a74b679f8d99b517d1742c2b9d7926b26832ce01fb07719481b49df648e47c086c3d73c9e5dbbb02382beb5052487d387bead84ba6da1cc2d396210d4c45d0c03b4800026e4a10cc86eba66b08f5f2bfb5547286bf58f720f1c429b470fbdacaa63d5b336eb947d1be75cb452406b441d0e4e81e4859e238943a834fa1a8f0398474533bffb48b5af8d7e33c234281e9719f80f7d4211f56cbeca3f5dfb8edc1e79135d928f2eca9015b872338482997f39489bd5aac1f2bd2df31bcd7911b005df98286a9a66478c3e44a77e073a181acf5a1a8504925747271c69ff2cb58a9b56df3f8283dafa7b0938daae8ab38c6f0fb7ce33cf2d0fa9cb3c6b3e6a2c9fbfd15c3e3a2b222bbdf472caae05110cf36622b000fb7ba1d62bc41e5998312d5604efdc0e92426657212d9b00064a29e541ad5d5d3b2f1254f64a10895ed8bff223ce1aea7c012ee9c31696da34f21ea37ab39345c1fe66c3152b0e7d9df58760c1d6c5180ce46662e5cad1bf6ca50cab097529eb97c33ef42bfc766aedda883f511a6384bc2c92727326584c722698fcbd23ae1c8554ea4a5c92b042ce54260a79077dfa359b155522441d1d407e037e21096271d0864cf7c770644dc7818d5a41328512c51e64b035fad67f8bbcfa0f7b2a1d93d7bf64d4c9431164437ccdbc296375f97dc1bfd3a62dc27cf00e3dbac689c4bdd5486717741ec48ad8885ea4be596251bed8eab33ce7b9b97e3e7a71e6984b76972db722bac5121bd6e5ab6ef27cf576680acdc44e3dd78b17145f531d1985d622efa6c02451dc1241c0d9fec7879b03d03dd7822af29346edb314161a2dfce0956201d47a150790d5f3931950a341158e572ea2212407d6bd2aa0e67663fbdfe0f26300f5a82b109db1388868cfcc3a94d658a5b4e67a4ab91e96d6b7bf1f94cb92e2d041a988a5edcba9b7a50f6c268db9da9d21a98a646c7eb0e4ce0c040c0ed58747e1a35ea765851fb73d04ff3b00191eb7a2183d4b9ae29fbc29aca397717f1bb8a32217fe800ba3c19008ede50695ff98a37d4fd6fbc77865741d7744e027c2a174ad9b6c7cba0df48703a11a872b7332d4e11974528b8e718ed5e4459c8f91c47cbe85c63ca1d95542efe895139a781f368891f6f5bc74e64644231f34a5b38f0f1385c1895e565b2952798d734296bba7f7eb2b1fd65288c4910dcc7d05ea4048b10d2073708408f0e95c0d80ca6bf93d24cd49980ed722f8122494b20b13c70e4d69ddc726cb3dfd556d39052316beb954be280ea3b806c14ae9fbbb9d3d89e91231740f82014b1e006d8ef63d3ac1f901a1a3f687b811d9d8442adb63c1762d9f51da4ccc39d94469bf52ca52a638241cc1c5db49287e0172b3942a471d9a60169db67644b7e4291be95fbd88f7a461517f0d886263c24773d03e5d7a2488a3f180ca525c04cd2f3ed2096a7ba88397809b734574d339fc0a62fa90192ae07722b2ba5bdd23f618fda801c479568a6a8964c336ab665e47c9f4cabeaa8cf5557025df6f29be7807dc9b70f29b2a7bae74e603e8d635bcfa15223f8afac3e5e3d562ec21540e21d0278e2905f4fb96e4dc4a9fc8d3711403feda494bbdf2c55bbbf332ccec5287effe4906cf5df490b49981fe19afe3e4a66870f5ac36e18e61044bbfdf4393ae184032e951e28d7c066f892b86f1d38e9b5f8885553e5c0c717219005e43bf5553ca9c8f6e656a5c7c5e3e981511a29e57e9f2b3b4702d331399b0236c04732f622d226d41358e3538a87b245e9b7330ae7d816b47019749e6152f2669d9ab9533ae3b8e23449cd4281e1c5d026a256e726e3ceb86356e1a1cb6fa8a2ca9292653bac82a3602443833397ec1b9228b80ede578fa3155734674e2a444db60130debd31091402f003c4ab0ca2886576407928010e7ec032247a5c857af450c856a06ab16a79b622004722682c8948abf0215bec8ed73b86b5009bef5d2ec8f28aab04ef6fef476ac1aa65363bc4cf72746c1a114bcb1d6c489166052b3f6e0a33dd03a61485fe4ef2fa185dc51c646aa05721902a4856ae08c332b70a93210702fd19e85c4fd1bb6b69ed99271c93467177cccc1ba7c721994bc6331a0ca6b081d23090d57effd8123c495217a8386f352285642ed9c25c39de3f20eba6e8f56350b811d0c22646f9ee7863c9c4f1f43497212712cf46057360cf5e3bc40deffcd047084cc6a0c59868e957d5b628e8fc49849edff3d479b9d70c30a5dbb7962e6d5e7cc789d1ca8457f2a8f35bf62a4fe0549b03ad342da0150343741c777eb1dad86f6eda6ea1b34de6e46429458b519d06fdc56c4400902fbc16aa55a5c2ead9acd2830560a868e055c1ff93b16a35dadd5d773464d1c637eb307502ccc9cdf801bf07558082b2acf3fc4ac74fe2aa0fcbef98f4b490814ce7489bd375a481a2826332d0847688578932c992cf7be4bf1ec864473674dd6550336811a3a2ed043397438555d0f1bce8d99a6a3dccd6b1e903176205f6e7944bed88e272b4d13e4c1170c3a76e2c2e214326d3a5a65c80b835f676b5d22da6c84256607d2035dc88685b67182fbdb478863dfdcc63f418250039f5597bc7db3951ccb9bfade1d2406ce989ddc165d9684fee23d6ef78b50788232d38c61b7a00c655e60ac331c26b2a5f62b245844844754bd78434f574ff65f3281ae09fb65c77c74a547758d91ad0fda1e7eb681ce16d471c683d5d27d08c0dd7ec2a8e7b95b6c8d3a470511fbf0fc2f1791b3d1755e42f760c00b471b4816ab342dbc9575ce1d5c1ba862f0fc5812ef3e4a09d7184ebfe5386220353bcf3e2b3954c9d55cd9ce1898d9e8cf372b0b2892da06763d2e913654c80f12319990a993e0b1f2399e97e6acfd2e84870cb90f06b3312e0199f79a0dc7c5a586c8c03c2db8da0d52df0fc191858a7296d7fc6c40b876cc0fe014305d7c16b5fb455d86612f9a4d70adb1b4dd14c4a8e28e661238daa079b38c0193ae5dc0b23f11c832ce288a0f7f25cfc9a11e033a73c44d9d3bad2eb307ddcb784e8377bd25ad73bef18c77a3bbf02bf62c5c54e18e3cc92efe3451a3f4694542a433a591012fa7cbba9cccd232af760a7ea3b11f7017fae4b01395e79047135f4e34052cdf2739001097ec4cc3ae8a6fae33fb04e1376423b4c4596358a3cacfa89a5ee95b3b6e80254d7c10994fb6663857ff88c6e648a103efbb961f0beea55eabd5c8db96537f6927c10c968fb3d6bb098affd2cef7220934f5042a9e789439ffddf3a19ef4ee9454c2e54b04cf27401cac9dcd1b82a5892c2595b82d654444b3bf4b592a0f88626d6dc822823c61e33ff150cc6137089af23c3db8e953646553f6f27323633363e5356ad1b6f2399accbcc50163d4eec9a17b9c14c506631410a0120e3c6dbc3c21a5031e7017210c90f223102d39b77a66c7a401262b0e9baea4be4b115d7fb11b204de238e8647026233a9b51106d7556469840d38ac3d43aec896183e937fc1b6dde56b45ee5005bf5bca432e6dd44cb0de602de922d7e44f86df6072bee970e47d7a524f4005163bf73cc3a76756cdd5fceb848fb59a7cd1fd0dd2c94142cf40ff01051bb9f2ff0c0bde998e8244b8c2e0d8fb972cf46c7d89beb1363723a20876073740504a73411b6c68f65b0eca55d8645e0c0b9a9a83a5bf3cd5d92be37eb345eaac8695b708bf2e1e597d67117a31b7ea3cd0bf6f0b0d6ed1b6739b2256723487c89103558361cd512f902caecba2a984917b2c891198f99242298cfc5e48948ae04de85e33804e0b363232069fc019fc246428026df2b02312189737f8a71e23ca96ad7dfecc1ad556016946ff59d6bcc892e2152a72e5f10ae286447a6130d3b919b1c4eeac155442a746527a05884d4013443b7ef78362452c302ceb6921d60a25570eb7bcb7a745154740446d23d27a1b5b55eeda974d55e579a0e0bda862f80eef826a28608e10c9e34090897479fef0630c5b30b59b756ae0bd1bb64cd0e00029092edf495c2572b4a8675544a893bc73d7302b20b3b1f830b6351d34d6a63953910b33bcfa325f8781a6179ea3d64f29de5c8932d1c3b21dfece7495f974b0c59eeb6fcc48664256d6ce0c206e4b8816e0040e476008d9dc174224bb9dbe8267a33663b2bd76f943118e75acd728ebb53663a4085335f997d52ec160b385fa4c7c7957a8faa5d190078a8ead1c6bad9343eecdf2ee831aaa757c814d524cc4cda040158bfd4585abddf03c1716b9409a5326d37cd7388830295fe34e50783f7a6bc6d7991182e204f021459dc34e3e32a8027c0ddf39b18fdaa80a9c4e92cd8aa91fd2bf3139adc4d3379dadc5e62a02e81a9e11706d3586f755ecdde257fbfa25de61cf26b84854bf01adc933099614f60ca92f6d259be3d6f8cdff8cea2ff750f65fcac04fd2d4b2bd7b454df3821cd073e1b87eddcaaa8003d73cf506d8e4aa748cf56b98611b4ac0f5a704deb334960819da64d66df526abd22a82a422f67aa993fb4c8d92401fb97cf81b74c983f4b363590db7a9b920712349f22c17dabdf7844f45cd61ea920b0bb4c02646a941de7debcf63e0c68b6dccf044ffbfe5bcc56a41e7ad68bfbd895b66ddd6ebf35dc8afc0f94f8ef37d44d7a225e5e9cbffab87dcaba2fce39f8b8bd3c0e5f5ae3eca290af85f42fcfd6645d4d29b450453d9bf8fea42bf2d6e92fb4403562667ec4c7581a073e18de1eb77b9bc16b580f22f30c5973e118afc4dc7750050bd00b96bb73c0cc0fc4b2434043cb12053e67441aec2c0086c2354d71739efd3a8ee1ab45c8609f541493a6ba8e99e30d7eb80c8acfdfa2c705bf8a9256825a2d421951353ef56d27645ce4dcf6b19249e60ecbf43ae04839f59471f7ca07c433af8df15c7a63abb49c9b0a3be97ab6981d9f20cecd8f1a7f6a970adc139c07d30c68308c0ca19d62ebfe3ca083b8d910c1ff6a529eb94bfe8b174da046c4da5ddabab0a434d2f8615b508cf7040dd7cb6c79dc3cba34a23cb5203d41b608507e4df1da9c5ba92a8cae2723ae3ef24361ee6077edf1aa0640345d581ebd73172cfb54fa0034a9f131076ea2873caa35509d8618793641a592565a884d3ac8b89f516f403671b24d939bc8210deca1bcbfcdbfa5b326065a76d6b3795e52724dcb776d8fc119e2599696f6f1262d714568df15f60dd4fc0f00d8ff1946998d03ed62f0b197b4de699396fc801cc446d6c94ea71891c506edfb796223554e5e0fdfb55617a05b563eb16b5c582de5b0bf96da3b9f9dd8f7c901b328e6dd9be9658e07057f8f308c046a48823563eeb585dea62a487d38164fe42ac965d989680896ffe86f81a103300a2f75ee4b6a4302f37391ec3dff2b2cd66117648b47aa7dd8bd6fa90f38bc8def52aefbcc995b4dc37d0bd3f9802f68f1ba3f3b1c3663b4614283d805d5be57f70e9c310d016834d0df09981724db1cbc62052040ee2a67c48ecc28b71b9e0e09d41cffa5782aa567f826296c3349f0cf40d78ce0e7f5a81fabc1d8a7150642711106f79633def8219ee4ebc6aa434a9c39aeb8d64248ebeee39fc947058e1e4323061724915b8b907d9f7316a3b80f29cb45d27e701c8b7f5ae500af6c03eb47386d73bcf582d2cf5aa14917bfbbb5843c037073a149d622a92832abf30553d3e1d6fd06983cd4b2f6f0ae22191b27df4680ba25b88b7155ca09540db1d60e63871d1dbba257e37bb6364d1769220f1d6ef4b1c61dcdb44f517bbb01c1ec75e423515fce3bbf4ba9aeb1aa100e0327960593f547be2c0f5f8179b58555787c34e4b5814ff6d7455a7a20c98f86e0e1682a490305c03931d6e9395fffb4a54d3e4c1854aff8b196bf9556c7d025cfce899d110c2970e5d1f0e128804354ef76508f8ef254cb4abbfba5bd04e9e897d1c516861a99683a59693b70be4f2642b5c62ab459c503664afef0df0a8cc1ea8fd8fc05d9a684f32b37c8c8d473cf25f51dcc798aaae936d8361edba965ff436b94ecce3be7e3a5e5a6f4984270c87664a8919b7d792f3d9766588bae0eda5eac3995891d8520f988a1c592d26b3c459c7194efd8ddf7773988f89a9afb284128f61a42d5f0e6a707d5c692edde0989fbdcc1c0aa8113f1e8f44b90492cb6ecbfad91550593adb85fbfca5fdfef3a413a886e3f08299aac185852ffeb251dbb639fefe4425cca989234fb384c0ff98f7c37198a6ebaab4e8d5ba0aca594867ae616852bb5eebf1e5a6aef92c71c0dd81186704918fb72040f48ecd002c3b5e1b184163e306afb5c8607be84a991a257b88ea0ab303fd411af6bbfaf011cfda695790a1f2555ee247e510f2dfe36d273ce95508a8f7542a09f67de8d9d2de2a5394a89155a94af4bece2d7e30c542c9cffbf190871411f26f7a44081975aecf0d195704e544e6aca21a6b20574a5f938092b8bda449a5e6cd8f861d11c076f8a0f5fb8c19ce3c6ca2247b60f18a9ab1061e054e986ba16e48143b37e461e3f4a64ec7f37a7d3f9e96587022fb196779d2d0472813e36ef137f4adedca12190a22774e4619238a46934009a5c8b3eb05d1d56c13eab1793396edf31765b241e89f54a59486e227364223cfb152b6301dec19d768d95df8a1322fdfda6fbbce2ce70c67c672e1b44235a2565b8111be18b4c8c5bbf956181cbf3ac5b6f14540b397ee5f5dda485d43ed1b2ddebf132bb9aeead51ed161b5e07238356cba8756183bd054d5ceb04a32cc638a99db705bd87e09520b891a988ee54b72aa108cc132a4ea2a19672566bfa09e7b6ded17d3304564a756a0e54683544219374246aa7f3cedb90dd2da266b680170dbb9870e08f207d5c9fa3a68f0099c2d6f2490b2994e93eebe3b252603df084c23d49412c2e6e100d5b3c294ee03add121b909be888a020eff93721938899b0a7a960e0434c312e36b759928a25b0f393414ad0cda7c2529e257727fd0217a5dd8472f31c4677f05cb90b0a93f020a5ddf4b011af1e09a6d8c3362b11b09f5a4e4e2f0d10298467f394901df219947e819db257424175fa1ea4be6ac49511329befd1c0ea2bd3d20899da9558a7532a60ceac7d407acf88b7e81efe15d9b60c8bdadfd867eafdc21f9f2fe8bb5ed138095e79dd82921d11e7c38e0bd85b34b1350cad950d3679731cb7eb28b08ad458aa4452becb7d47ec4b7bac1cec247fd0f7bdb8c58514c6f8dd2770e423cd42085790b657d4cb9f4abbfb5cecf325657da94d9f43d63e8d8b0122192c21675277b1cb951878ed667299443b4e363109ec97a209aad4aa797ba26a584636ca5883a265fd129f810cb8b043cf97299095c7eeefb6e1049eda3eaa2b20385a05d03631c5273466373728487e758df3c4adad1fa31688b50400c8aa60f3ec270d67acba13b03348837fd02fd41f36411e6bb7ceb1a0c4b2e8279965dc9756941a0c879fe346fcc2f2e0f4dc1804e21d26137f18f64479c72778b6e7f073004f11e8190137e3dd64f8011a63b7593a0f0a6c151a19ee47465acec21297b7e9373fc5c1f8d90dc56a0f10dc836d4b1cd1fa2d30580b392af0afeb242d85f5aa03d45a5102441e5e297aaac15b4c6958602664bb2bd52c8ed43f1ea18721b0b8f9d77e32279e828e6f034754bf4d762689bb54f88c2c61f3077fd7a3b0e3b1eb78a3a4136263b59fa228534153d03b866ccb104ebb38a1edd709bef1d61a645f1d5c04e0389c76b8bb5c46e7d37a019279d5dc19daf6a3ac13324748caec2d1d5299d85a0ca0f02ba557aed8e8678eb981cebe73536f8c4107d99f44d4937401d7d99f861de0b3bf8632abbb5e58d9da72cd4a2eb9148f19f9998f078b2de04a24936b4b7d2f968491c7677f0c3decfa21c3ff9ab8d0663c30be47fd185f3d472553351b51e3e5543b4f4b5d2f906b7ef7e8a6bd2c9ed1557079958ed4247b1851a259cd74ba370873446e8e93c635e70ee759f2048c435fd785b9be54ffbe2d8e8880c39236601e51b9800a204cf40f5026d89437edbdf54ae467a340519a978c4abc8b66d35334df51b3aac50cdbc00a9248f5b8fd5eaec47a59986e2e9c1d5d883becc5d46bbb0a674df8da2cc108eafd3a996a9b0e50e66d54ba0b194e03f77088bfae10b7ab18a01a3ab40b32b66aff7c6c8592c5ae5fed04c55e689f1565e2b14940a25c82fbf36a660b002a55077e6a582bef0a93de4cb6b36482a0fa45c25b6a1c483b5d49b55f15ae1f29146c1aab9a7af5aa1bc806dc93f743313c3238892024b0ae944366942a54e5e7805b98b8ae598ee6bf1f65da804c32acd737cd7471f792e71bc8b25cd4d6843070f52a99e8a25203269b16ec3bd88c098ac2a76ac6aada82ffd12c9470b7f386508948d87fc753398f6a3968e34c6055036322f4562b539721b60dd2ee1a7fe62f8beee00352e88ddfa6a9688410a1165d1d8df5ec5e9fb84ad8d2316122d467e416f93284829245fa610b85c97dffb80114a362e93eb436c6f02153e1e932a6b23fc19bcf9c7b47c1bf972278d75f799903a3a9abe4c870d81fb9ceddb62930e1a5b6b0e5357162de9e80de32dfb442c155038840398f3fb1ceed3fe0279e7d429d3296018580fea470072613b11c73223fc42a8ae7e446c580aba7800df0fbeb82506d5cbd6ae5e1d58137c22dcb697d9836f72d33440d0947f453316b949ad68b4298b3cf8bf9bfe856f58545897417aff4f1609e6471955b0bdab0fbfb2993bab57932d8f59ca529c042aadcb8352f91a1a681995de41e437687cd2cc5160c55798da820ec5ebaa6f9cb1a6ff27e7db069230d0ed78b43cc12875230880cf071ed1359debe01249077de7af85ba3119a985278630fbe9e263c136614f7de087924099bd5f820f4a25c550242707d9afaf05636c7b469b087c805ff2d5afcad7127c9969c774d831c5b6a5b9ef80c68e7a689ef2042e94b8c0be5e09f17dec1fe3881df7a882d3c6eab3c5695d47d9e95fc2c2e5fb8de42f8d976df48b329d0720eb76cd88b361b67dca4602e8325681ec19a38b8c67452825553edef76c7ff13304aaff444a4cabee7c3bbcfa6801afbe02fb1aff24564676f768bacce3c4cd87c62081d689f1c8490e18d863710ca684b0dbd4a522698bbdd5f11568178cf3a5f8e7004cd694ecef932820b0510a90fde963f783f4e25363770c2661270ab278bd03f7e2dd6dd3a6fbd63b74a8120cd35acca34e8b92b9b870df18b82ac437a57e4d58745002331562fe224d9a9a4aef6f0b02626b1b487e182734a34a742b646b3dad0e8fc03ff525dfb941856228faa1cba9c616ab1689cc57957c6975c2f098e5e7d419f1aa0e4d23f16a3e92a78468c9e94a817dc9e7ed4422c11dabc00f6e11ce383ff8ae385211214af55025fd1aa54a2d4c206df9baaf21338122eb9efd2ec67253bcd626e14a720740dcc9b16e2d68b65932275f5a284e36864bc234bb92c3570a161c4a475712d4401329755585f75a4ab823a48501285168d87b554e8cae31fede22a6a34196262c925be1d454b990d5cbf1c213202b220adf583e70e7f6672fe296d2e5d52ae7f8f1f41cb052eb763b247bd36027c7ca9424e8757da3a22c39cc31e334b99ea3a56b9cdecd689719ed5ad9a722cadfe48de45a2a0142dcc040b062443f40f7e7b27f0ab10334f5d96bbf53f31b5e6249b2f8ef3c81c90fddf764517941591d6730a3c90611bc8d48f405cd2f381c3c4560210543e43da08c3a4da92adea0aba0fd8b2491753f571c6c9efa60a71943b4300a616e451b1136e8cec686d47dc4e90202b0341d08cc3ab74413c6eb9184315f466c090e1cb102434c63a4f7c2ba90bb5dd5b5340cfbef5727e5ea65399573a3de0276648f2ea27a4d9f599bdd32a98f659d0bf377c22b1a07b2416506c0ce0c55e26ae7edd9e771125b36232010253ee9b686e6d2637f294df792eec55157bc03fe0b5103c335bf94a8d95c36addbd2ec42bfd2efea6192e4ba64633038e8a6a37a9117e8643d9b70ce34ab44915872c5c90647673eecb50e20e287461efe5ac3ec7f911459a5679bbf466b1cba47852c7abeca001f38929633d69b0b2bd59dadf9ec2129c62ed1696a0ab4777ea72269942d82838a25f3377c9007c653a12f8d1828abd6468a670c6c16abbdc4ab21924f805d8ee536f478bd9e31aab1185495ca775f9b67773300777f4ae04cb3f39a55c5f394a20a852f4dbe6d2077a4b9d9ef678acf8f58f3727438df6f208b1e7054bdfb69a9a07bfaeeb3ec9855f046511eccc06e5ff083775716173253b4809e8238b6791816ca0d2f988aa9845d4ab9267abd8cb43c0a5c7c876c4d0e5c46191a6269d0e9c264a4e582f75d6dd598cfd12cee1855b4c2e38ca6bc43e1264794d7fecb0602b0d2303d4210972d7675b1c141257daccd50b7264f8cd0f1666abb83a865fad03c5c8217051a0c3eb202991565e1f37cdb02dc0ffd2206f590e02f8e9d778406612c55b5d64524d34b5cb8c2eeb77ca30704ac14d16fcfbacd3e45e45d01d19842fb59e8f75c3c8da1703a70deffb31cdcd7f81a6a98d35004404e24de4648456031631abbee2e9d3618bc488ef37aeaf8ef708c0f7d7c3b7ec679c3a2037238a175ccc8b27847d78900294cfc2fc430070b32b0945ea38f921411694a3f818fba8e607b37b9aac3793fe3c74f29d9500465ec3f79e62d37f317d6d7f84fcadde784f886e07d5acb18ac137488bb0756ee59bbbbe8bdb743f000218a0c2ce77146301384126bd5fec0d08b70b0017ad5b239b5df081a2a2e7fcb2d96e0baf3df78b42b88b3640b4ba1252d12a9e00da49ba28a0b80daa9e641f917c2934ad36fc47d85b638bcf82b3a31353e34d9c7e2213799c1cb7dbe61ce0979333f4729c50d585ff8a121a227b1394f30dbd64b9e7873aa0c66293b5dc6f42d19cc04d9fac63af97d391df0ce30cb5748f8f7dce567943bd0b920528ecbe49e5f1799d7cb3b745795f3f13a9ab8b7935514c36ef1d2d551d70b008915d80ae78b268b29b99ebad67b1083e4380d77a66d7251c1caef94d3c3e74ac500b46008a019d2371978f6ee6d44a5ab196a656fdd472e01fcc6d4344ca4b54a37690a7b615db6489a155242447fbc9a8f9059d6e147eb24d571ef361bb7855e7f2c6bfee1400ac819ff1462db29dbdcf0a0bc2b7accf801b7e69960f6691014747985edfb5737a9fe02ec83c74ccb8497ab55c725d7deb1620fc66cafb00559f6d4c003f3d2a371e058ce81708aa2a602aa731b417d259a48399d4e7901f153dc72a1ab9e052a072612eef38e0a27849b4bdf6aaedea1266c80390e5c68652f545521bdcd6d377ca040711e0f3303fb72527ef2c31c203a70cc6da7dbb4ef41dc8d654dc73a4593aef16bdeef8034890c1c7c9e569ff8b43ed60024c29b8dbbb6cfdcbc062f7f6bddbf161b4e2f85e21026b1fdefeebba07893df1378371d782b7968cc702afe39248d34e257dfca34764a873ebfeb00111b7b9bbcddd378a47550a630946bbc2a7ed0b98df648a78d8efc4d4f31e65dcdbabfaa0b88f0f671f279881ec55ad6166e7d1500b2788870b937d9c5e08fa8470cfa9f8832ea45898701facdfb4071056ea827c78d816a6129fdef2a7490d5e6b29d2e13f47b7dfc35602871fa898c7df49ced33b1bbd1a1562b3fe22bcbd982a780f63c5032bb29c936107e588841d78ec0dd7ffd3fea36d5b8d2fa65a196728898c3a30d705d67182c03f9d448c0cbbca74269e72fbc1e399fbf32977656d89ec4e3ea45deb6e1d60a4c07112c928dca7704a6384e2a5cb8ad7b383a61cdf4b59a27584694b5215c603dd2e992a29c14e2f4448185573917c362c282b27f9684d442f179c264c5f2bd27c2fd0cbfa8facc1f55744e172711216ec2b56710acb359d09dcf3607e8e3d2cdd81aa59776f443c7567cc2925a2d92dfc34d919819835e9745477b416b55deff97bbf4a05a0cc9bbe2bfed48da95a936c85bbeb6607f5768168100f6252a3b08109e1b1bfd147a3de13e70c01cd17c163aefd5e36d69d3fdab2de69d9f2ca1be4d4fda9ac159c24e8481913918ecae7a2e94994c64032d488c9a4bf21ce0aea77a15b9a0b9778bc8b896b43693bcd9a53b656b648186b40af263fda7913d173721dfb5e930de121758e3485f2e7d12344807260d2e242b63b78766b8f18281ed33eddf5b1c3fce8c9133ae68291c67654f2f0871025b2211a9166f021c47a1fb41eb597b168b74fd6f3f9daf4cf6a4cadd861ef0a1b9121d5f1ce05add6a202dab2510d4de62cba75921517b59bd06baa8eb8c4bc28eb324b26b2da332c1405dfbd14162d96ff75659bcde2de070d53c164fee7e310a9df0ab9535cd1d7660a982ad5f4faa049ca0f8b67b546018cba00434979356e893d421d2de0671864e3aa343257a47f568c0f52b19c86497aed31b98744cc7827f5db933869f2342f2556ecd18a47171b5099ea0f103c18b2d435ec146ba94fb14f49e2026d03ebc75347a350b49aa79fdce876ca0c4080ca0bfe3d19b1706f9f057bd39d1671030d5e5dbd117a793032762df1937cebbec034fedf9dce0560f1a50783bb77992ea7796eab8b803f1ad70a114ddf72f4ef468a34aa04260419ab3a644d75fbaeffb33570713975f3d792c1e0a4c2f3b6c13c060449e5f21d78ee54061f2e7344c0e554f1d6db3fea445e25e97731eba0c991d1620acaac66ca85bd198dbee76f88220ef51a1725683ed61c8aadbbad47a1ad73bed71e1893432c8c98527a9e84f4d8769e086e78167c807730133ebe2866c7f59a2f889937b3f60a3867ee26da6f5c60a89d0273cc1b80a45457bdc55383e5060328e27c73401f8106d8c46d1eeb07f1224892447f374718b08e9dabe17cda9a0b80e7b1cefb569779f2315525959fd82cb4259b46f3615c99942683db3d09bade6b2f4b5edb5474db9120351055f1912ef935f40def7054be801eefe8471bedb8b3a4e3673f9188d01a242fed7fd45235a425765399cd282ed763801843fefd1969aee1d3c90f7f5a7c13264e9dcea810eedeed3e63663ce6db49059a673067c0d8c1a2ddcc5f10a5f825c5b53d95f8f8bf7765c1dd63af08c13f102d2268f3af17c857b34dbbf05dc17c377b1be4b512ccd9e25c5aab4bac4e8dfc228f180e10195ac363646088928486fdd0152ca863c1b507691654aa76fa2d33c2044b15f914de74bc2be18f5de254b7e5d156037359a8cb7bb4fe27f0587f7da0df45183ebc4d74c74acc779e80798fc123092c8cb9fb40bd310596cb05374be7320bdd7443f024f03c16612b0564f04866c9f616eea4a021c9793ec6a2d964430a25c671ba3db40a75796aa4b14b219c41eb6d0b62eb9989580c782fb58d034818748198140bbcafb242b355196fff6fb05aa799304dfbf20a047a022feb605089aa9086e1bd4b82a7809c5e9a18de27c1bcde7f7e99fbe8cc13493a995e4e1928eb329e22db7f361aca0f91fb2e733d68bd942cad2a44d2675e7b30d07fb34cbf47cb9abfd50961d30d51e9afc3ad35ed6c4a9ea48e731d38cb5d1c2692e97b8320b0e157132f34d9fe8ff93b2184117e105fcf8a313d19b2ffce829f48bdbc1039a0bd9035067161cb4b55468651582d1f53f4835c05c889619d0c99eaa6a13e889d3da9bac9b21f9df5b6c3481b983e9a2be1adb57939f94890bc1c2059af88e72af8b19a38d5db36c3ccae544b8ae90cdc2e70a4f31eabf6adbf869643686bcfc531e06aa128d73a3a2d73c6b4bf87d728c97eaf523625fd4d8d0d088ef5e241dc93b3c6f7097c184e3756f884cfae3ecf6edd0a249b7786748d72754906e8ad91b67f4c56cb1fd855dc0d18dad9334ea5b77311b28954b15cb719b0b4c7bb8ede07cd238cf2d6bc0b93cb22c04d84959c14010cdad33ee377030fb8d57f8ae62f7fbb8b81707bef36fe2658d00c20d0b67e8d4b13d581260871cd58504addf8bc53d5aa007298aaa2b2555f6ed525257fa7cc994cfe8f382e048169252e5ae1a831c160125c9c7dfa7d32a5e1f75435a8e717baeec158d7dd4dc37527e7e0900030428275f42456aa7fffcee6363bdca52b0b85838c6532542a8c70a971fe0d89828ef84f867dee3f9f8e52643de6cd02388775898612be5d0fed5ae8d9ccfeaf9b6185d1b543cc3ca8c55808f59206d9a6cfed087626b2fdbcb78202fbcb995cff91888e04d8796aafe07e8839d15082ef56c61fd9b01d48b825bd35f259b384979f409e2e43917b4008e6efd3f5f401335db4d3635317a40d17ffd9b911d92696edef8079f80bd5d85ea100dc1acd3cda69546472e54cd023a3fb1f635442e2051e80286870c5b5b23f8b373cc3d59fdffee62dcdb8b8afc68b21de70d6f01d63ecc53a7b808f9c1707ce8a22ced51e105c1097d5f70c442eeb938742838ccc480ddaa1c18db1f4b43c4594b51c0d276fed428d87b5bf353b4033c35bd870f99ba915c0c6a28a44dd5910b3849dfff769ee91a9e9e77549c02a7d34fdca7a980be918593c061dfa243265b7e31bedd9833d8b03369cc72c2577a456e73c13364abf162a5499e20a3565a1e9470ce39c64470c6eabe573a8b754cc8770f8027120ce8070deac18d1c884e54b70d58e0ee0dcf08f9f0acbdd06129d10e54c47d6b2cd55cc6637c327a861951c01a978f8fdd988710d1318f431bc87256d0c79ed804b15bdfacaf0ee11a6ba2545e388f55875ea0801017a6377157b00fa368ff5c13eb0d2d9dd292b193612c31a51240c4b2512da946a6449af8d7369fdb4665b364b883b02cc33cc30a69e6bf0498ddc22907c5ae5f5662d2626e6f0bb1c3000b3da7d5737c35031ebb781f62d135fb20c562f4be9ab8fd904e0850dc3eadf87beb479b7983cd1932a38146b178e307913f5c095fe17353f42e1f3a521b1093003d8ab3c6b631fb37197e05802c35662d0d202165f6c5dad2e748bcc03477ec3e0a3eaa39749246a564ad2c7e0d7e43013c1788fade3efdf3ffce60fb9b87e4ffcba44f5a2d617cc048e8aaa08e23fc8c66942961a0b25a8a8677931d1ae39bee66a94cc58a5bcef48512fdb910913d221b70c99c90918324a7b8a55a034fb4f32649852f800ad0df35a28ce3f93e3734c0743a85978c56b039990691d9cdc15e84b1ff309602bcc6d1ebd772dafed5bf2d2e8492c5dead680af8176c791c8f07086315fe3fb091697cde2a2dd033397b78949ad252e8e1f421ef8fe067060f784fb85b0f6d594b2d87463d79bc4cc8fed16a3762b3f13592f265a964b8b28d72156bc149e00330368df5536a738c0606ef216488a9f9a58d259222671aa5fec662aa62c8f6a42638c02f8a3a3cdb8d6d5a40d46ff2da1113d2d35a5369381e6d49f0bfc3ca529b46456d78be6b141e6fa922f71f2fa6f6ac1caca3bc653b515a1dfa51d56a1758dad3ddcdedceead370528f3b2ffa34935ec87f732e9cbcde487ef7b5c97dcd7fbccdfc3041efc1fdb0e4b9cfc88762a861b9e44309cd48751fc915c2de1d9e6262dcec89fc1b77ab65993cd790b8c36a4404a4bf00ed9d806a405aa80b94c46ee2d6f155868a2c4274eefad58a6a886e59179eefd7af06f20e9265af385b4324ff3716f4dbfeaf21b5aff3b31fdf1c3b73f897c4fdf8e5a4807e55e955be19b55319d1df3d0f269007dbac4b0e6ed89a9a740de8d646c58b85424dd139efe7b366fe8f6954476ee5a7d54211f9e4e8d0dd27a7c637e23cb1349598d122c8ac0830e35ec0f43799ccf1447a7bc72c2186273068a2e1e73886848bdc3b0e7bcccebcb4baa0ab877bfa00abd9ec0deb3cb6cccf9438d5193bfa8f1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
