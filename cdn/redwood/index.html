<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"20f00d9106be805dcc442773abdf8050d65aa00f1da1870225a7abf73a37200359b05c188756a602e11cf70ae86cd79a90861d2724fc3d075a36f8c3294ffcfe4d01d8ff55848f6e2bc44f95798a4d39cc6cb582a26c03f0cafb761435ae56711f839cc8d2a7ad7e992316972cea1fc6519fdecddbcb8be729f6e49f29349df30bbbe6decd98cfa9d39e83652f85408386d9ee77cee81351e6cd8858e90a43e6f44758f742f8314885ca2e74332c466d3590bf9f0e503611f43c7296cf765ba13b0fb8a56af327155b88fecc64e8295e0605ef2dd5ca06d1b7a200fb1268826dfbe0ff35dde9ee0cc654ddd050c4bf00c3ced0279c13796931695a1692c3184533eeb952340ccfcffb2a40fe322e78da60e2eff359816a9444f8bcbdeb2ba6538d20293855bd907ed76869ca872107bab98f1817751546bfa710b141c44cea89728ea54d873c5961770a9ded3da15db2b00abcb718b4229888143bf437a49fcd3e94e46f452bc123ff833fc1fd435eee4c622db679af0809214106fb112d69fab52d445300226d061e162da0027c34c3882a8ea0da72a31f21a70c026f6628181b5f878d24cd24616be5c0072839b76103f065f7c9b91150324f194cb9d065b8fd58ad40295c74adb01c05f75a023fcecbdd4afa655bcb86c9cd93b69eeb239801d3c160cea779ef771f7de77f2d6f6b40e8638503510cdcae92d48906f217cdbab07b56194c2d83df1aaebf2b4145f9a42cfe10336e5ed3f7225f8a126281eb9ea015a3368fb5c6a4817a6e483522b26fb7ec9e4f5c9890a431caf89b8c8e10b3b0d8b81b3f15503436076fd2df80344825cbd80121dda4a23ba52acaa52eaccec652f120a6bcace2c9917f7aa893196fbd2c9d67fc8183796ffbb5c874ed89c7a6344b438f064eda554a8a0ec7b174695331ecd02e4adce17b5eec8f2bf4a54d4a17af885bd40b270ddf5f087b53a3ae776d5ac4dcdfb998e93ae7fd71078f5883972e87d88ac5774e0cb967037555af42c040860a7b5edb57cee82b71e83bd5e34f185e2ee9db66b0b07316f61742cc872800071488cd6d08022b909d1394c570d42ab28d159cca9db2d0bdaf5421d3d847f39f04276bcbb96a94a37e0b0e73556ee0c15fe2aab6d6c1bbea0bbb4e45674b1b9a9325e6c8c4daebfbcfa5a2a03a83f6ccced5528d572224f4bf899d4f07971e4851f25c9febd0939f4addf51e6eed912f08aaab0c8f1d7530123985e9b8a78095b796b56b5d028e5eccce24a5d0b952319953b9fca9d888be12b9b2389046eb585528dc3c3f39793c7bf0254b9ed6a9078330e1513ab4cfefe43a0649945125ccf61c8bef98fe9c75568e2d8b9adab3fa6d5a290b4971fb100c0cdfa62d66567a42a011f478523b3c4b8e6dda3e304b167464455a4a0a4079873c2e64c22aad1a0bf4ecdad7f566ec89dcac4161a23800639cd8c71b652b1fbf81d22caedf488ff7a7eb8a03479eca2d9fef8ed06e7c9e6b8541a0fa310c80fdcfcd65fae6cd1835401e24240ffb9bf392c994dec0881e31012ab98b511a25a22ec3f9ee6bcd0870bc28acf29f0dbccbe2d4c3f13864e8c3b64b04e6a91531839f92effef8890886ac26a614574d318bed694926beb758d984c95e609e909fd8808f824f4a74b0d7bddc6916262bcd4f8d454db807e0b5f9320829a448859f44f2d800dcc11a8f6895c877d4d4d235380465b15abc897a67fede0323f13786b4d1ae5a26f2e196436aa21fb049eeae532a09ab88c68ebb7c93b5e1bfb6e2ef0564a0f56cae04eab1647cae51712c4b794be8b7b2558bfab3802cba4d530f3c04f34acf75e5b5fe5fa2b26475110e2ea8a272821fb0a4370cad2dc594ab01c31a3955cdc5012f85e15da1808e6a4a7c149b46f722a7841f7deb6d47d97ebb80eba885213fe9ac4a0d5188b7564e87b47fcc7a3c77580dce142e4f7c06e407be1c40df8da742dc96b2b5c36627cc343b20d24e2080c7c63506b291d67be31ca19ae0112da0ead270bb762f33ee5530463b745f3cf98ba78753ca7e55cb816005c947b6bc37c8283cf488873fd11c6644b36ef95d454c34b1aaac871f34301a947aa12f0cf9dfb18beed09641ae760c69ffb982384550df5e7b1c0b7ba62406e8806f2ae9766f78ef5fa1e44bbf36fb1688b12a5a6745e9a4a213129802756e852f76af3bb4d8109d119fbf1650ed4b2c30b98af7fff3af25bf89e801b40846108cf595d50eaf1bcff1a3087fce8a008c90be4903c97c40ffa2f6cd370193fbb628c2cd9599927fe9421e2dca7c621f8d36f7ceebbc911d2f9bbdce693a1513ef11179de43dd1f3e9505d259a2b4b2d7dace12a4537132903e0c3c7da9a5e612ccf3baed9eb3623d536630c94a11726c77f77d5205afe900f9e901583c48a4da039948233e95ddb2f7515616de7eb41e222a147ad27bec637832ba0c3e17c70af82aa32b6e6b76a3b0578dafe38b261bbafe1f8bb12131dd13a92b7b44f0435f1c40293c76dcb3f4e3718d238568691969c546f9491956ea1a82ec69e36eeb12d42271d2035ed5b09b6fc8b94ce8c40fbc961de835d1e9f4f73fe0b455345fe601907068959441f4204223d51a51e00593fc1852778ca7a0e201088903f6170d6d0bfdbd1d5172987008ceb3ceb3f58dc034dc66cfc771dabacac70b956a83391dc42a60115bfb2108b7fec3a43b5885fa7c3792b706a6cdb6e17d2f8e078ec2d8f8fd1740fde0b77a9d97f04da04e872b3f0921bcc033ff95333295121f53ab752f74082ca862df34cbb6a203b8dbe494c8935c7df5f42b3a2f0d2453b03423f8cdec99a26a5b6b00d2a57164a97309b8f62292e2fa0095f8736962676c07eef91665037f4a7ee908f0de49f4869f3a8a5b222269a5ae62febb1b64e72746b028f5316d1fe9ed777b7dff06909728d2258675be6ae4aff321306cd0039d1360d26e52e4d3581a79eb4e98c137bc323ab1ac6b3e4e247622bc457ae39c7424c220e9cabefa90d37f69e96226da2e1929115b07c794e706e94082b83169e5ed4ec6a1946301539b6db38dfcf5512677be4504d27f414e029d58b754a057407392c6fc4affab9b64b62e0c95d0f1352e71e15b06a865728aa760bf0746a034cfae66c933a623bcca5c40d08c8d310e37eca11cc05da24b2c321bec746f1987d96f4ed80b2b113e0b34d0d3efb061d27f0bf0b0ec7a425cfc4498e33c796ea6367d6c905511e0ce9b0df949be45ba4a44d6d3bce2e38ac2c66872aa56d7766202794ed647cd64ec8ef02bea1fea4fc9e1014bc4be94bbae80b3cbdf721365fcba09c1839ca5597b85998799bdbd675da40da0e3277cdac3104641331d3142335f68cea316ac28814835f5430de00fd9c36f776613c21323466a6d4cb1dfce39dd526fc4ff6f1ea165ef0ec0c42deee2b119844fba1a6d69e715a58a626131871eb00ee882003497b5b31a5c963db472c47c2b6865fce044a2cfcb97136bbe066c8bfb6f7cb58085078ad4cb68cf9e2a243382936022371611d0f1cce65a0b9c2cb10d8eae0c8e070f7a5c16927c8c814e267890a5507b0105d275de6af507e9a19d087f957ddb8a29d92de2182f88668d18793c9d3a9489297fee8da0186d34511aeaa6f9819aadcb4b7fcafe8ca196e25cc6f452281517854dd4a2a5045eb0a555cdbdc6420c27ad1a9ffca64a15b32694dbac84e78e7317972ab9ab0fe6b350c4a3ab626206ea92a1370b1329c5aa1e369d10e4cb69bda33c1039733c45c44efcda9017a414e2eb011cce3ee628fce9a49af6379b336f2a7b2dab5927fb54b6fbfbb9c0966511d88ebfb581a5db52afc782684986a44b1dd0681acc933ff6391fec8f6a3761cba3c413bf4664caccf4f6ba0e01b04f1881e541df435e1b42402afec00a73b674276bf38e0b74958a8b95f6be9ad94e30d3520bdbd8549ed95ac24b9bf0bbb3236ecb5561b0322fa91299f659ce3756cc3e286b9a4c15d3b40d6c3b3edfe9ecca87472d1dac26dfbf303e8b275e8c1dfbebec718e467d8f42814392d504ac2902ca0e709df0ef6b3b586083d883621a135c41f0b21373015a4e6858d4912064c4241d71edeb60a38150e50a3c8bb7af6214c8e3986b71a362753cbbde4616636e2314459e386925480b5cd804c386b7a615e07c14e0565d107518357fdb4615907d2c3868cfdef223f7109814edb09a049821fccd5cb5a10be40eccbbcc76adc734d713b7727c7691c57a9b42b7fa220ff0eb5bba403c040bead1d6245990a3a8a62532b136a97a46c37aa9d6247b9053fb9fb2df7911d0f1f2ebd5a32f3ce2d9b2513326105752660b9cbcbf08bb9906b385d9f2dc02493c71b29c09a40a4093a9d7c7982597d244cb4e301999be0d1de040c9d8011ca01e6c72c8c97ba044370494f73e41988a5ffbbf7ff477688438106f895a3dcd27359c04f6c3b8586986b7ee6e2b7d4e745f4fe25ea37dbf5148b8778b0c45f37eef1d18249897688457493a53daee7eb614d929f833a5ec9a6f5904a590f582245b808d899e65ee9da7937c32a290d6826a6d80ee947029a888b3fcb9245b9625ab66e5b6ad2f8dec53da110e473cafb09d4db7d9a68d6f4f8cc83df0adaf52491f724248f3ad09eac043d052ecdf72d71bb0e85cf3c722c835e8214c60c6a92b0d416ad6f2316c426ad5a8d5a81d7cfb47b1ba4f76a59d18eef11ef36d288a488dff9534fafe2bc1eedbf25434fdb2877036ad19f63306d3c849cebfc4e0029ab275438acd1d3e5ec113dd89d3b52767b024a7a5f89c891efe782dde28d595ad52209a17da8a1c69f3c74013ec71f1f85f45c7839b56154996adbdb85fd08b64c8f276fb938fed78e0ee7973b80f767b32917716852141e31f48c9aff8ce2e71122d51ec18ef2693662f5affc732990178713c6b2b0155ee1f8bfbfc3aa0071c8f895fd5330d7a9617fafb079569955c4748edb309ea14f241d4fe9a638d564762d5a2233d27e74e71e247f1a3a4b57dc05d8f9978733b97228ec82ed5e10a00f169b2d2a8fa39944f6f760af3de0a09c02edfee5901ee8e64059f63a9ac442d7623d88662d3a38d32af274b4e9332ce311f82686a0ef51f731a2a3eab02a33b97e012222da09297da14c600a91776240767e9cc391db4ef4f975fccab48d67b24ca015b1a33584da4895a69f026c47d84aca7c87ade686742d47f8b9feed6a8d829e5e32627a25219c5ed9aca01b4ff227d2f25e7931ff35c96f5e406c6156791f3601dd8536d9ef0ea64ae3baf77dd98d9981f75e376fdf15d3c6a265d28aa9003b935fcacb3f7aef78814fbd6d4e39e5cf45221f4d8b974bf6172bd589f068a42249a65af3f6be623a3c5047f8cee7c242aa26d8d853d1229b559242cc8e6674b8d0ea74aadfa41ca68913944c8c8a6f644eb91517441d6011f4b988bba797566abf36514781ee7fc633e46ce9e7aaee7b4def30a33aff2970948c5d05c85455ab66384eff7d80b2414698fc006c1805436c56d55fc0104987088fe132817884b0bd1faae0063cdc0aef1f19a3275b46c529d1a9f399c670135a42364af593720b6ddc40a659da2bb7c29601b79ef799b2d20ab8968eb07791f40a88c1d05998f466ee75891df1482350e6fd9b983824c1ea5cc81971dec85372d5f3acc170af86c542d264f7bd13c36dafa5cc519eb49c455673b845bda9415a925517b4f933a4909d4fd340a6c67bc2f8100dad5a332413cc2282be4d74afc7bf9ebe16ef0ca4f0f871d88f3564297ef5649133b6744aaae04977dd81133778eb51f6aee6b13384022d440c9ca660a6a03e961698c5826ee464056bf73a9e2075398163044b2c67b9e92e556ae35003d4d58b54906c8b40dc16d97337eac70c97fd5f505025d1cc203607bd864e2af76ab89d202a478d1517256d9d8a1d864e747b3755131f6e5d8eca3a078b7a3de7e16f5f95d0ce59319948267622daf97bd5999b9e5d796ba92d1c401b2e6362a7cd25faef51fb370ee2205bb39dadd4657926de156030e3f6f6de20ce3c590411f9aa9b50af7ac2c33d7bf5de545c6c775978fa38870a0fb3de85035d899e7d5c2b9fddec9b6c1fb78d1aed328c79f7dafab24b271d053e5a306653563dff47ba76d12ad4d92dd287b1c8e18395ce74ebd55830c2d6bcda2b5aae856919ae620babbbc7a57c78614f2213cf907bdf2809eec84f3747c934655fa167b9c70df54eb0b183628e90bca11ec33f76eec2348608ef57881fb29937531b4e6f4537a271f08541c7cf56734d20504d928652269428b19479dc20ac807b3844a8b23972f4388e5c87b5a8946e12a45797f99d3a95e42535e95c3f8c00f0625822f3ec3a0156f02d1ceb5e7362d3e3c4ee9c11a649394556d39cce58a975d203a8260653ab41279e72f6e8551207e82837e13210e2ea88bddc797cc87e25fa1a72d56043dfcea60037e1de1f0b44fe029fccbbe0b64fdc86febaaf840935d3fc3c3a7d9b0edbe0ee0e7aeaae3bb52300b6ecf38aa09c995314a6c87a8d695b61bd0219ab7706c581f1ea49fa410cc89a437a9c95e4abb0c0e48677b2962251bfe34753bb24722d198ea42553906e5b17d86d44d790e6dbe9f078070c54ad74e1f19f65f07079c7075862d729dcf141801a7d74a222d006baf96e9a0c5a9d254247e2112a9282e4e5aecfd0f46447c102f4f390daf96ce3ac99ac4a653f1f1508c7a4949acfc3329153910be886abc1ce63c03bf01fea0b8902b6300f5de7fc995130f561bc8c510f2bd982e1bce131b50385c50c5d22b893681fd0a1dc916aa9f4dc3922715c379e943fb7a42c09e8ddf313560db085640bb44c4f958afa708d115a21fe717fc5232d27da5588a7887ba163a01959e3e08e726faef3490194d22c1c54db404ca60dfee0d08f5dbe31abe7a1fa9ec1a93cdcdeaca190e7a801bebd241a095c3581ef6f694b1a6c98177cdb9f64d7639e5c0c1e940f7c4fae82317fbfa16a9068598a83219d68e32b0acb7b7c37162c133f0a1999ae9fc6d2a414d9f245bb3c9fd873f8a05f872acf564fa51ac37fd0ec0c9d4252d1ef1d431255761531c4df2d14bb0490d199f0e0ef05353f907e1bef5063ae510c81ee65a1b4488c3ba8170953b7326968ec9d2220fc21748d83f21231107142810bc7706a187d9a8ab9747c7703347a8821b8d106e100781288edf582587b7763086b9dd29b201295885905c731d1a9f0c175f3e6c0219c0b20e1fab81e189238916f443c0e8a60ab95ad7e65fc787ac3ba75341bab67f49ead08ef33240836379c84f1960864c2601ebe74a252782836140a6545b851c6a049916392460dc92283e7a26c9719f43c4a81f0ce45a8061c00923534015e094b7f9b81916d2f8282ffa36090f336c9b48e17d4a3e98eb49aa78d80e4b400ee4f95feb29f5c24bba8bae878ebf6c29edcbf6ceb732c8316a79da0fc6ba8dd0bec038c533c71eb589cfe87d81587302928674d2f348d6ab2d8e00bf375b2e03c972c252954ac856cedc3ebcb81404c340ec66f4df450b7e8ef677402463800130130c6f18e3b8dae81f28f9eda3b9818275f3f3f4e209e9040b1cb9bb98b3dcb5cb1fc8ccd00e39566656c38e19c8156aa40d162fc7814c50962c063f687575569641872da8c5d6797c38c0ad34bceda01c87877bed4c7c1cd87dffc1d6098fbc44e7b0254a5c213649062cbb4f009a3a9f8ad01c975f9dda5a2665669c4c09023d85dbaac9c0e8e8d5b602dd9c65ba756bfb085283c6f38c39126c3c89b1da0d00f3b5d4cdd128a6776520366db18d5bba80c2b3e871dd854a544de13be1d366b91d746c468e27aef5497ef56e70e74223be0f0747df7b4af32ed28d1475e5bbe1ec3275f2757946d9c42ec8a54ffb7a4c1453ccae11ebbbe570c0b73680e078846dc3d5ebb5dfce769acebff4e54b20ed61edee3ae425b577d7f8ad0cc11969c7ae23ced237da1fb35918ffb8d5f808433303883c050ba44ce97e25401bbf1619d1197b2154f74fa6f91553ff5bd8bb5870aab0f234b57619731da30c05093d86bc54e78a545623f7776eb7afadc2bab16603ee807aeb33e7ccbf1240f548bdab41215fbcbdfb3fd9fbca7de6ef31e9935b47c62aaebdae24d42b8c6786ef4cc3d53e80f135c27d836e2a75f5c5bfec4a1e0c94aa5a807ab7d160d535cc1174a7a9e6004b6ae63b881aeff6b17723ddc5a9446a3cae891ecb0a4c41768826e7c5925f3f941721c446e9b4801023ddfcafdb6ce8cd3622600f13cbe75c6db318305cc64ce1e7e9c4456350547439051700e94096f26fb73b7eab8ef17c0b4011a7a075bc06ad5eb7a979e51c66657c3c6db932e44d4eab4d1667bc24696a860d9106d1e7b3affaf49333535634f06336b00831a4f006452ed01d5cc45142af6674d43c5ef3b2d07c9694e12124be91312dfec8ac65259b7b3a7ab6df504619e2b53cff45e4a44306ea7337c838408f4cfef745ea34c780f25b0f517433e1bba3c5ec54226817745191add04e8f3022fba1b5bffe4f13289fc02078555c9b92c9e32d0766d92d4eb1bf66990bf7d3f4bb3b7fbccf0c3d5972b8dcebcd3dca579d192bd14125e77ee165d9841c554f28f3cfa4671496ec8fd354d31e60a90cdbece39bc19576edf6099985582002d16dd5a3ce3d2dcdaa7f2ce5c9fc29993becdb38357fff79dd603322a3a25d4a012804fd4ee27efd6d7f7d3136091f3954ea5355ebdcfed8148af12f2c2eb6c7b7476bd8a07f394619f937270a5ce51cb928c2373e1a81b900e8602501cbab7c2d744840caed1c7e25a8fe0b248abc00389c390c694e323be7ffb053e1a33ffe2046d4fc6b1a856628358622d0363df8727966f211b0abbfe07c2092a58b402cb0dfd23994d41eb00a65c65584b3dd7da9cfedfb354220c110aa5f3e34a9afd68248027f2e2b03b87a4c639daf8addb32d9ca8d3679efece661377e8e2fb50916e0c88b79b38232a5a1c74456ae1c45e2f3edeb795cc06c1b42653cff844d9a339c9cf1cd6197cbb80082f9aa9d512bf69435a3a3369cc253c5ed2532fbc1ad7430f802416f66c4cd85a75632eece76513654033b1e12d29d00148365114cbbde1ff08e829c7d329ec3005f12086ed2fc42f8d2c2039b24cbfcfe55f62e63a1b719968952f088e20c2cab7725566ca6d855372f9e12479d87451e7082dabe9002139db5a04c0c7942fcfb5d23b8c75037d718837113e41faa3f2e8ec0986bc6202e4a9ab8ca8bc89463ef155a2ab56ef1390349aa939cee24077e584e250fce25411069df1e50d8337d23321667c8d3db12fed17d5d901c26c91480f10a6b55e18c7b8cc1a3eef477ab0ff5d19367b9edd66b5d102e83a9695cfdb085efd8832b04c890e11b004204514484eae7c11f37d8bca38065d1ca9be8319766108a10a71f68a59939609479c9b24b4e5cca0e52f5cc80a7cb171c38014aafad72b5e0cf5979ab2deed9ac0cacdb5dd1a563229ce3b4992521c8c2e4bed74fba808b46f2ccbe0a78f332b28d13577967514244c1bd3970751ed9441e3272d4f40854165b1274f3f34abbb63908f8e2ad0a35176c368aae22cf9cf4fcef1ce14836360e99bc859366b06492e412858c3fc620a3beffb7c360cae832ff673ad2d38676d28aa6525913f8a3267e1d72b3e301d16c533c13807e4544a47f5cb6e180c606ca6e205065008a0a000aca6e4470c20a42b174be85e90783c5055520c71478d17701f379c14afe727d48c92dee91c9be28e024cd8bc2d39892053d43f30f394cf1c1953b961d0209aef2c9942e30e6748d23edd8cb268510965670567aebe24f06c6ed05143105969cd2eca35e7614ca25a92c8cff84b8672f417a09ffb90377c810d3a793185e4bc1012d7a37e54cc5dbf3adacf7441e98d2c94f53cefa1d2646ca4a666c71bd6ea0ff561c94f9a4b7253054d567f71d0e71f775a4401c5f3491af3b36876bdbbdc32ea973ac1cc3fbee1a972ea77e396f04c2b16c8c32cd5784079ffa1325f8cdd80b629feebcb0cc858e17bb9c158f26e787361e9e7216352cee61b1f781b1d1fdf6f8b729f33b42610c4e7c56687dae292e9b0232a4703bc9392c94b25ddcdf56aeeb061099a4473ceaca788c22fb47511ff3f3bd7f63d2d10e8134cc8474c6fa79b0c190c3819a36052f2dbb315d7f9f09cb03504372953aad96e2bb0557a7a35ab8a073884e6d908765993d9eeac59b2165544d5c761bde09ab3b35bff9b51a370362e898bea3e87b9746c75e7959ab76b0cbeb645801405dfa8782ec59472b60d87e35f757443727d91ebac6641b6f0328f5a855fadfc9415383cfb33e35e0507237c15311cef07db73b77d229a697f6fdaad2013ea5251914222aec941fab54a002c35e582973c08c56cb0d4117f961ed75f7b99187321d5093fd4bd6d21ce6e77996e6ea62f2247dd9db78226a7eee34865f49c88c5617421acc9e4eb81e700fda9d1b375667033e0e45f9ecb11dda79a3e599c4717e7559e039cc8189a0f2c0a87fe5ac97dcbd42b7ce48631dbe638e6565473694ebe2868009a7b4b1fcd526de3fcc28dc9cd67c39bc7cd57f437437e47e26bc47a7a5d6146c89b15cfb5ab5b92aa41e3a0f86003ef7b6697e41d8d61a8291e25129641343414218a9977a918546bd565dd0908e989846adeeb14fd8de788add0f0b909945c311d6b1b3365b778d5fe3e7a6f964bae16bd2a6817068f7250dada8551da33ba31dd87d0e7568828db95ba08e07aaa4a1e3df79c9015d20f9fc9c723f49378f5851596ff8dfa7bd047d36b53a6ef501598dd965564f17d39bd8e4955e2d97e06d76838bf95a902fbf5db1f835a175c3f0adb0f8ff06f6deeefe9e5054a7c0fafbea8141fe05ea9c1e8d0f717fba0c4a779e31e2417cadd6ed16f1bf75342cd7d5cb942b8114f86ac3535ea2d706a99e00e14da3d178982597395bd10b531c2001fb2d718bd4e7f6c0e36e405adb7b08494d002ffbb8e3e73ecbaaa2b5ea1ae2bd4be4ac0b506c8294169307fc7fca1ac9e8a5913675667075ab1ed9d00a79b16113c789cf06ce63bc15762e715a0ec55e418cbb418822f24e6cb30e9c0be7669348ba9160a38d75379bd0f584b59b8b76caf72d1ae879d262da408cd7ccf64ca31db2c5c8f8e418653a6894d5fafcfdaaace8ba56e5c2c38c0dbd4681f71f6cd35d3b6cacdf5c18bc6a9f6d4ec2a1355e8ed89fea0a308486002191334d31b4cd354c52816df6a75033287d72a2d781bd515ca0cc7a5ab55f009afd18214025ebe918be0a1eee4334b2b32030405385ff2378a878042897e197ed3bf7520a8689fb29f0b01810c7d710a3ce2afae96247720a3afb449abacab4082af79325ff9e212dfb5b9b8a467d928f724e0855f8ee1ef81c811414191e0f1c920c3030ff28a4191839d596971df5f513c7a4da8e3e7b349019b04c92465ebe479d337ee2f151a4ed6cbc811517887addcdd28f92ab1f55ad996f93895842560ec89205077cb8ca27a80f6366a3eef18076e0881a6d0f3c50dd0eebf9fc29b7477f94cc7b9bc70dfa96cc4669f7ed49b3ecfe0de7d7cc6c3568be9000929bc057fc29af24a30aa2dbf4b22f306b7a576059abed3508de980cdb0af4367961be5a8117e60eb764afeaf62b561f93edb6c1781bcaba1823d382d296f3bedd552d6923fc176f73ab4853f807afaccb2e66b76082965b15ab33713e8757d1a679a3e2b7721099ec3cfe030a4f1bc1e1ad259a906434a91c9b4947301d2b0b4d0b9718588d802a1783db036c9952a8e460bac25d22c8f3a287fca557c381d2368b97c58b5c0ab4354b6cdda4baaa5d5375c4c293b22b40c8f4f968af76065fe70dc03411c381a96e5783257898fc784b55fee5365d4df000ff4e900a36fe96328c6f5dbeccb6fbbdd672bcb4d89cac50903baf8f04788a821d3066ea34bbeefb3fc5d633058c5e760eeaeb3b67bb5629c21a9a62e2fe827f9312bb91aa6d1223d9bb63c202dcead126446e33cdbd9f11ee9dae88ae4e1ac569738794cf0168d8bb06bd25009241427ceb80c9c0aa0b0b87621fdeb07845d5832f077192803c0b339b942874b231e45b9468479e44709ae1541b7a8df2192f63231553a4c4fbb78c4efed07f109ac56c7ba5769a0d501c95cb30d20297aa7ca349653c68a26877b912ac5db02cf63b0b03e641134417659e434ad5481564d00b94fdccb856c8c90ade63396f52bfd8a24f14ead5bc18f4dbd8064e6374b9c32b906039fdc44b6e8901fc92ef58ad75e6d8675c6710594c2d7dcc0e3040fd63383f2a6dfa4ae7064e9908b0483c0a9f3a3258084dd318b05e870da9849f6e681692fd0742adeca8ed46120d16159359813c3156a176a5fc392cb793d7d20eb743a95573db5737fc87f5eb82234b7b05f3e620cc6974b358e50e0ea1453443401680a9bcf7d4af88ff23629afafe2053544e26c4cf12c61a7f52c5abf2fc46da39737e573a3a5baa9547129c93ea7ff5a05fb0833f6ef3b18a82a631307166db1d590914d74e0b467288761fa33fbeb89d61d2ba23052e5ebb4d219baf9ef0fd1767302fd3eb414a905fd9e0f0f2cf209ba663c8ce694667180260119f478a654fc3c3442c2c62fc511152d90417cd81fd400a0289edb1a7746a5c9564eb385b7e798d5356ae23aeb7e314fc9b28e9b8c4c8a95285d7cfcf1a228873b5f87537a56a7a6429be5b3174ff4672605092fac962068079e0afc2f48d2b94a380ac9c0a4e1d418687b6711a816244ec8c869b9b57794c8335df3c3093d6a73daa0e63265c9ccbe02f4defc90ed6cdbe5c3ef58e2f104821cf14210c8a5dee0639228ee7251af7080a10b09c9fd4fbc4a9f8e6c628bbb584cdfdaad1a1c1ddc33e9f407d9a14ea0f93b6b08cd3d83fe886c101644d8c611d3d76b8ca8c37e04027a2a083ed539d549eeaebd91b652d44b31529f75dfec29abcd1956bb780e24cb478cff06f15367e8f0b3710a713fc37d5f6d710700bc9eb198748e47765f203bc88da2c1fff65ab47a8d243952bce64dd06581ff32a214cf552c0d156e1242785b96b1dde9e4ff2013728c2403b0c2eb940e07532f25eb4f32a92ed58e54e7c3850e0bc4d2c8d478099f6dd10d4f2661b24faadd9de492d66ca12728cc3a129689e5222014e50a74b5f9e8e5ed728b7130053ed39525053a24f279c686b078de67b6eef507796ce801c5b27b543b0302f5458981fee971d9e8bf28fb550bad318ecd30a42f3e630d28eb9d74355b3bc61d4cdd4edb3f63467b0181d90b0f3631f8df78bee07da3cf6673ddcc8e1eb995ba13f40fa65d0898eb87bf27741f327e62429f5c417b60e56829f820165e6495633c523eb9f779e2896143c8d3a5c8e4580392370036ffb3f9cc6ffd9eb0dd4f9730a069392822a2bfb3aa5a0af5aa58ea5217f1965a9f5b1f6829901d5459c8b4d8e25fc56d4a7130ff084062e86e65d31fff6b4b1662526089db6dc595d97c10d57329ce0901af7907baafe56ab4d5500970a4967abbe70222ada9deb086a88ca761aa314516fda1cfd5b0bf05bcd4a9fa846505af13bb6ae02ec675cead1b53ae8904b636295d1afd052d6e00f9e531be0f6254abcd133723f2661abb3b170df08fd6c77bc8cfc8c72cffd4919607cae6f89b88fe70da2282a0dcad2a37396df1436263cb3af9dd44debfc73308e625a847d9b9bde1631b193c37c37497a67402ab9d173e874c1d99e937f4e6ff90f43d03a98ccf7aee816221693495bf60130392cf3006315e8fadf15954e91f79c7fad7602d0e055d50735beb9c9e3d682b5914f7a487e5e4a6ce34a5dc838f35d6afee25b01604bf33da2e9c2c1ad89cde385e60e7713847b28ab45180383f135ddcc499238160aeffd29d8d34480755e95c65e0fcf99a890a57b56605c9ca96dc52f7490e7449ce2cb6d68aeddeca6adbd44eb48094f4778c67c47236da038ef82e54811ef623618a906fc8ec8f993f98444523948638db0a35bbaf72ccc59ac6e10688964298a566612497d9bb583491d500641f46857895a401aa81ac082db505923658f8bef4c7645c63a49333ae68ef14c48d76cfabecf74c77320a54ecfda90a300925d554cf421b6f12a1957df0e22518310873fcbf0ee2cb362481cb7a715cc3053fe0a6c95149a32488c8c12b7e3ffdd1778288912c903120887299507f143b8ca342996a20565a2420147b15b7058774cb09df64731af8cfb81191e3cd87f8fcbfe1a7567bafa786b260c648064b0cccb6b0d1400cc12686e880d626d2c158d3d0f231ed4176ec39a3ca329439f00423b1d0639fd30bdd15ca13c2551dbdaab626b5d6c5ef75f45fd23333f26ffafadac4e5ceb226c73e9bc2035c687b5aa99aaca3e5f187130420408fbbf8f5482dc6e79adb5b118b7f21c15a6e39d6ab9ad28b5e2531d8457278b915416e691fc82da46f67ad4f5aeb54f0d7b0cf7afc3c5f4a4928236aa5e5527020090cfe2dd50096d828ce399b429bef22b548f907e7cf151e3c5628b156d30d70100a587f150159906adb050c1ac8825245df0c53a0f225b45616a6e6bf1b3f8de4480158c1b7bf703b8ae52ab49b0cf4b2293d5488aa239687b3edca7bb88fe7b4694727b9c4a3e2a99089ba753340a40013566b29377f2c999637857ef87921b26e8c6befe1a9ffe146c1f3c06fc8556641070ba01415de68a5630a18602b97c94e464595897e4ce625a030fb86ca67201bb81c5e69054726e6a5475f057c2e0f335433be526596396196ffd65d088527c1958ddc99c89797c9ba9b8a6b7df60e904935f75416fe4df70b0be09be762babbaa9ff231a108395717ce027be3a7ced76d1353e1d6b1a186d823394be3382fed7bfe3f35484836c2927f98edd056c308f4e59abc57bc3b15f87fc6002e1fa6c795a545899e80547cb1193929849dc27fd83de6c191013f3582d569acc8271fa965ff062ee7afdf6f3fa03f20ec774d967a832e09c5a8dd59df40d4441342ba5026049b8bde0fc2b31760ca028e9d390eec366be24666f3c3f5d139d95abf6c3b7227e1ab7f4c131dd9cfef7a6bb458abdbbd29187789454779d57c2a12956f55da6a1a2e0f17dfc225edd4ffbd06a57c5b1b01a8a9a164a00e06bf861feab5aadf31ca7e42e8e72d318e98bec8eb101aac8dd8a1ab7aa1fe5b39c0525ac732115d51e621d2ad3cfa67349a0aa4f5d4ab28a9c3420a43ff205d8178a035a401a25f75425e37fbae056a90ed3a25cedc58ac5a3aeaf162b7521eba9401d22eb157f4fd3aeb7ec9ca0b39c0c238950e074af4e46c6f0710236164c8379440b4c3bee81b083bc7e203b314abd53ed7b35df8bcb8e09e6b2e9712a4acd062201a95262f44886ed2bcd02c0adf07f8e5c6988867e9d8f9c88d1bdf6d3b447221ae47de464d424a15c2a41448e5b4596c541f677c6d7b06a56fdb48aa3ebd5bf8a47f3ba74f313e6415c29c3cfde2d704a5acd3fa79aeb88fe8a368efbd3369ceb767aae5929cefce7a2a020a78de7c40aba01b2353934f81f3348cd22953e6b1491f3c83ed0208988e8cbfb2ddde97edaa4c7d998c29cb3a2628cb9a0509d43201b2608483a831120f3bf9b0e024ee57548b3b1b259f3abfb123c1f8ff7e80345eadc3175eb38b044d7399189ecf378efcab6d02719cd75680b5e2b9349a48cb2c417300c4f716378487b3be3caa5e663a7e24a0899980e324faa6adfedf49f4c69673ac4bfab6d8fe77300e05d30b3338fc1d3c8ba323240e495460ffee220aea648b9bc83e29d64225c17d1d2ec825f5d2c0fb3db42fad6851a0e594e99460770d6bd3e7711cd97bc565379809e28aa0964493b69dba9ab701af6f0ccd1a2994ba5d12e34562e9639401c85b6263ffccaff349636fd0534d6199d65a45f37270b4ee50c1e935e203f6bfcc2b03e386b36c8107c6a4c61e5d32eb5a50f69e1accfc17d4068d8324343eabbc64c35a1323709e5f40f5855d6ec050c5cad6a90ef86ef85e0f5d16c6ba112cba6679604ef0b2cfbee7a62852f3d0f9ecb36a280e5fb0fbabee823b025771608441b185bab1aadc051f37d2836f523b34ff0deb6567eea6cc8586b2e6e0289ce7a3624a7151f7fb1c687c28091fa5943eda27b2af5d68a251aa799e21b158fdb65a24ff6bae47e7e982350ff9fa5654a14e7ce5b56783e154aec0fa6e3eea5c435bea5fd78f85c3356cc4d3481009c1bdb578a4152afcbb5fec4c8232afaa4c44371dab7a53366eda1fb93a7cb41fff908441319bd699caa72b84bc743d07a6a830eb68242ccd724da8381a1326d56835a188bd08b75acdebeebf83fe4b826d2a73b95cfa819039772113bb308b732d7e8f17e528dad604085585066c321132e4c17c7e03f705c6dc7882f24c57fd870542f433d34676e15474fb7155b6d61e5d6ff75b315dd93a6f4122073b03cc9dc0c8b26498b0f3ed7b95093cbce0e737a064528aefc710d327c04192b017965b513aa5c224084ba127cc017e16fd32983069fb19e9e9bee1b278c8edf38810c5e4f7e454696b160aeb2e4ea7bcff6b7db49aa9812d1a401b2b8d86899a441a496d9892bf1133636c47230b011ccdbd9d4109843b51a4a42e102b5180c151ddf36b8314d60c4498d9d4213c5962cacb0f077fa0d18a10ab4e0c63e5e086b489668bb88fb0b9d62614b0e23d0fb5f78823371487ac5b216889cb7b08714244c2df91c8d0ed07d3bbb94a1cb0dd2698e84c0ec89a8d3ade0e8c8ef6d7b9e42e8ae6cbc9b80d181e41f2ca98cca197e2ce79cef5221d810aff8b50a909a607c128b26a30f0ff85c4ea46bf52875b063c7d8d2ddf760124f822db44e7144e0f153a7f0fd08add41a4a27fb1edbf878748012baccd0bbbbb3c4099b221ac5b74bb0a933d3344044fbb75a0ad51df489caf0ffbb2bda3a3b47c8f11c46d5be3e24805dc2b173fccc99e4553f3463b78398a94019b85c4cced97c4b1b20c1be49b741fba7d3c0f4b28ed0799ddf4beb276b31e782e95c26dbc5d4118e1b43204a5c7c463fd05ac7f9ab785444442ab5b0c46414673c3d540581f7fc61b4796a77aa8fe8778e88d839012a93595900d0b8df132515f07ab3764fad444a59c23a12557869fb6d37a7a15f3ac08243c199626cea9c50e2803c8091381a624bee8ed34bd93a37ed4630ec26138fe18e8505842e637a731be7e0f396bab30ca1ff4b009723949fe3495e15a5820d07fe550e44d568831f88ffa2e7c530cca94d40dc61f7dc5df7f6cd8ad7ed520188848ff64152bff434a5fe7a01670e4ac3d6c46393c934a4864eddf19c2be2a62df2210a7f13b53339a01ae6d60099e4cf3aa347083866ac889b1ed7136ac4a836a46c2902c3eb2aa2c75d3226d8da6916c164ef907a6cccc57863fc70e69839dc0755b649f1d070b1087a35c109bcbbecfa45666977c842662635ca62d1cd99b3b5c1c25550fc3bc45a0fae78d5e09f38ff60fbd49dec3f5883de5be9fca482661e54f081642de550b58b04e8cebdf99f72861f51a8e22088fc7254e555143e7a09f0e1b93228759f7a053cf75e17c11d1b7e445ca27289b5f2b03a25b1a0ce508756cbdb447193abb5bd382456774a5f3ece22a99186c5003d59f7ebbd01bde094b39b33461c793bda39b40a8b0b1c54f558012b3c18b204348d9d7777468845ec6242c5dcd12009dcaff00344526f358ba35214ec68d1129bcfe11eb0af391cc3bb43c3862a44def504c4a9b9d9810eeb07554b5028a427c16cb5a824296c520ca913efbe9a3938fa7a5f6a4d10eee9cb06fcf70f675d8598e9982cd54d1df0cfef7b533258415b5986479f7bf2ad86dc4c1dfbd24992b9a0f1f17072eabafe1093185dcb947658bb15b72a1513df153db2da6d252642774e5cad09642c2e9509e91c75fa6260821f2346aa7d92a27c32cd8ea149fb559f0d257bc5d08980a69585d79c562d7224715f5950ba0be1aad15ed560a94215936fc96eea7b39","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
