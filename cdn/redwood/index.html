<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8af3921d5a001fa144e6854dac213fa7dd46c6604c14bea3c28457b00fa6dfe298254d533000098d5ce9f8fe51081eb0eeb34463e7b2be0ef5068a925b235b8fbedc18fa408dc72c07a220286df3bac949f917bf070b9970d669f45bd082c77e3f342b238c3546b03fa0b30e4329376347c062f476b853e9f8ace2f752b8ebb06ff211c85ae39eee133091a784ba0736eb0cef7bba214085d891ebfa2a7414b36ef6204cbd64644e5f9c747fe55c4fa50560cf1e78b1f3d09bcb025acc72ccd1223578394da17885a71b1cce59362a54d1240cceeae28a44e607cd9aadcf50356bd54e425f2b962dd0b9921a104b652622bf200ccf712301b217fd127766210bb1f0c0165dc238f89242686980fa5c0906bba6868e57b1144799ae2a0b92885cf398e7faaef05160dc1f5813cfe9c79ba26cd0bcdeaf54304b7a531d0e208f2781fae602b373395e7db41dfaa322fc272e243d7139c1d67ee9ef9ee15636763a51292a7ef051edadac15333d0bc50806a52573c5d065dbf2f277cecbd8e3deeb1a322021d37b4f287296307d79a106ee7bf329b78a51d59d09735b8823565126158287d707fc90c65a4d601566c2f4dbbb8fe30390f45f87fe032b0ea63d978ad12a350c592a78929d2823cec837fe32c528863478ee964225db240b86e5874f54989653f2ebe7a7e4a6d8c7908497daeab0adfdfd41e6d1f20bcf16c5bfc30dc6231bd32a4b14aa15ad9f52e726c6cc2ebecf002898f729e882eb0157b1ffd3fab8b9425ae54e692d40d841ff49f9fdfa724389c3598b9c8a1fdd1ea80eaae9053499664a607fef95b1f252324e6e547cacf13263efc3c8bdf00ed0ee8febbe0d24e8ee36d4215f560788281457b6a44acbf9f2d360cca6f08a3b0b7916a2dbc8c269796c30049465bbfcb460a15cea121f92475957929f046fa6cb4348e08f3f300fdf41ee0c87d38799448ee9c97f736d07a2c3df1823871e37e09c0b0ca45728ffd4825b73c6e2bc71a0e24360897d724f437547f921816ba574aa295473fe33dbc9fb0e0f0e79bdd71ef952f1604efd3c171ad14f370594bbd90e86d3a9844342ec6913af1678307f6c2713019e939f3f447d8571c21024dd14ca65fff250ef274972b4472e0bdf36b72110e2b8a40b6ba10466f166443956c16aba5e773e7dd9ed5f0a413d7e146221c5d1104fe7d5c59cbf1080c38318a9dd2f082383452728e9b17f24831b00bda2272ad7a0c1c5a4deb792984a619ec377991c2e81c4e45e33addc04cbc24f9009abef4901903b92664202509092e999d9045a7def7b07f2cb6746d7e94ee28ff894c57d5028d6b4bf6b9889264e729ef9d95e509b2927c2fa7299b9b9313d074afe1bacc4c271bb6805ecc97a85b8f333efc8c299c6696baf16022c01d99eac8ca164813d00d295dbbcb0406054f9f0a05edb69981c7bd3e91310929de4a446a38b6335c59ba323309e70ef98569dcce5ee6e0da62b435439a7d733b0f279e6bcdc76e4d3a57391f1bc7de2205b9ee8b3109e3b1239be9f8529dffcedf0ff97ca9584c6e2cff9ea1e0888b7ffdc6f5f237005a40b43cfc50ac75d8de2addcd100260c12a596c0fdc8a4ebe88e380db20877cf9520d36e4f9b72ef746cd9c5b25b16d1e0187b711a24a740b9773d05609a4a84b144b5f651029fd13779690ba0b9b06a3daf2d7a79dd72762f4c64b9900415a2a4fb261906b1d86b90e571436d02462e83d60cfc29d540f3a324a2778ab4bfbfd8356eacae328b744c76fad49b79938d738cd4118fe25a5934cb34f8580536f38a39b6efe490d3c25d94b304aabcf5e9cfb377af48d150fed86984a06afbf148266f94378db06bf5678ab66884915f3fbdbc9cb74611e8f3c1ff1766d321c1405446e6a319c591231c6eab5c07988cd5320e2b6428f70fc94fe37b978ba5518fe3fbd681cef1eac1b3d4e4d359634bbb3ff992af02bff35fb8e1c838660e85057c871db4eaaccf0eb19c2d25365b7218061b1bc6da9eb9a73f5e37d1848d0cf909069b6f32f27ddb2b1b3ea976c386102593cd57c9a7befc5c023991e20a4a9ffd5170c753c9aa125f6ab7c4f384853f602dc05597c72c21c1efdf1cfa4fd598afb4ca0945c66169b063f0619de3ce3fd070cbca2686401e835c19ce73817390f70905d9617fb2e7815d6da9b0430dab96ee9835f312f70cee7e56db663520db8fd5a1c5a97e027c1ddf56108a0d2fb04cbcbb32df1ed2a0a702d67e5012ad81b64ea8904f14f8c23bedcc247378e023b586f03090de5403fa27be5b639c9df55bcf0e9cb28bc33b0a0a8552f8b6dd4d8b055ef5d01980524cd8dd1f352923200bacd519a53523b3d393d689b0fad18ea8ed6c840d77a067e2ad2f6064345b6df481777d314b43c6496611c52fe79dbba563dedab711a243fce827a3c980885555b1bd4398c6064031ae220767ab8b73fe27692428d4a7bb96a552a5b80723e5eb16954267de55b286784a6255753f64ce73739f6ce582122294308fe19ecbfa3bae36f8db61ecfcbdd1b841bad4ca17f4c8515400dcc98d7e57d1f315b088a16110e31cd8f992be5927648ca7ea044163a29c68054360aa2623f61b83e10cb4d3b2a4dd14612364dc86fadc33b7174f109b5cde82b856b969fc051283888f625c1d42bbdab95fc413c51fd32bf85a4631147e606e7129d2ddb773f0d891d49caf3c5b451a1f410cee1077cbb5072c484726b6709053695fe38563fe9069e70368762ed07d4f1b5c42c2df1612b9a5f8893f2d3b2da8ba1f3c51d92ae2939c48e0279168d167eb324c48b2c9dfa8a970dd5ecf02610c2fa36ddc1119cda1d256b2da0e08ae8bf5033646300b4eaa69223b618f880039e8499f57bc565982fe6deb74d731ef0c2a6d2c277ce28964e9a2c2c05080906cb9b71adcd8668151d49747c985b992d98aac866ae2732fc296edd5477b75352bc093ce652194c99ae081e040e95e4d9f1574c49f26a3a0967d7f3015995e0ebcc229c27e547a4082b049a2d4aada5abfdad405ed70d7369fbbac88eaf6e421084e859ec7a5f3adab6c3495790d03a290e24ff096e0af8b16c04ba40d7998583ea66fb5b44709842f6cdaf51218a237cd1e9b39e7bfdafcae329f0747f8fcc2f80695f57ee89da50ad546ebc5ee0e1e803c02910a4223eab07a430e949d854f000fa48f7659ec616e1a2f11f6cbce5567b191a956f2ac6c35b55b44a67106c6109d46b10072979b49a18bea6337dc4a451a1405552c5e4a9b9c8af43c15fd409336cee6c1636edd81b4b3f451e67faa5718e5055bb38aadc3dbf32cad2390cd91ba52baca6b3ff1366b47df73d0e11aa929016251e183acbea4a78c9231592861e608a7914d44c3332fe20ed419bd7d41e0d88fb14f562748e650b07e5ba9219b5158f627b4b158943253ef1e37e2da1605d6d10c3fdf07efd7d41fe202507eeabb2772f17677119b2493b6caa4977aae49ab59893247d86d3ab9b784033ae214dbae566cc3914942b0fb5f54a79635228058c147465960ebb4980f5f8c64ede0082e929a3c3febfb0c4f73e37f1a622f4e99a4f4acbe30ac6e0e11ca6e78d0b468257d015b160cee3fec2b5e487201b464765ae39fb2475ced6d7bebaca786eda9f5819cba1c18817ab5d454e5ee4c4adff5a2b05e2a7f4864d908e16148daf823add0cbd8ec945e4e1a7eb6b80ec60e183d200495dc8b309afbbbb9f68bc9b34bc5d77d146e063877c5d7d859489d3ec0ccf8cfedef627af88a3f10b8f8ae31d80fc5fde12aefdef1d494711ba909d5f3b56849b141af2ab95b0e8c9bd5ea015b78795fd18391627f3816e944b67402cda37716b728ae9098d80d8f9f8ee927fb1eeb745b2e140c83930d5ba989881b846c3dbcef044a38ea4e0eb4a401223b5154293a1cb93ca7f7ade6f5ebcc0339458762830012b7d725b687eafa2a4fa8088d1ce9d27a2d561ffbaafa3a54afb8b97063f3cfb33981bf7ae90d6079b72519fabd3e95eb53aa6da84cf60ffeb296e5acbdaa7601a3fd37ad5cfa53d12160d5e4e9dcc16303e85b71aa73dc93b9eed23819d74c182635a3c63dce7d2215d29111c2dd16928a8ad2d18b69d0eb8ca58ed58d41b343ecaabe8b094b15a9f5c862dd0a168a49249583c832cab77e4496afe8273bb90c2d1bfe5699f8fa6c4f0ab67887a3262b2ef10ef2d132d6618279324d76579997b92fd42d536acd0f315de98fbd87ef24543e6cf029a16544b2b3794d0f85e85a21c7b23ecd85f9b7cdfbe91f00105a24e3567847e3d6ab6eb5089da2cc91be68771c5ee8d72dfdfc09f6061e176ebfc38685e3d9c0bd2fe3d39355b454fba755618da6f007212f47635f9b2d299a5ffff84649abb5c36e045ee5179b7183b73d995eb14bc7aeffc046468b7e82af2fabcde660c7ae1a14c30856c3079c36f859bbbfa7a88ea80f33d20617964a5c6abc6728423012fe673ac35495afa2211963614e1db952cb1398c2260bf1ef5ffa90e0cd23fc2016f1acffa7b8492da98a779bacf9afdf06918353a8377ad2ac3c35015c5bc23651898acc30d7e47095ca621af67417ec72c85b1b4169bbab46168adf4026a16ae7771631fbd960d93fc0911dcbfc7181f670f64a4aa14e57a48ec6e2cedd04fdc3e6bc91e00c70c09626129c398866bcdbdff4c260e38226a7258c6c1320acc2ed56a5354a37d901feb0f0e715a489b31e5789168d10989b5e079df737c13e396c718481fb4a8b8018a7663bf309d0a0446db7e9fde24d9392beb32a41c15af73397b9ffaffe1deeacb3d1fe5d8a1c71f93edbf78baad86527d5e1a62e5606b8443ee20837fe142eccfa8a4930807cb3b7c9f7b0aa0af011a2a01312b0efa353111cc27ca07c1650f90b046af374100cc21af2190eb8a9ce38e5a8c252d22d443f5bd6cb7b067391fe02147fa447ec17a7f675cfd0686712cdf489b5ec118274679e4a554252a11a059b7ff43ff64bcf5d85d077016af23a740f7dec9bebe37101189a8a36e1a20ad038620743bd7f04683e32b1617b6129f800fb41611c1e4a8714ea18b2dcea345186c4affbfb5b0cd75583b53e0911427aba69a9d44f4afd65c67e679633ceb08134902c598afef738c84dc6e847cdf978af144b26d9616538aa79ff1dce4b4a467be9f4da9f8a2bb34e264729019ca0fa93d2e92842e5d0f02c84088f2278334c3c6e533d3a29f6b041a47a162e80a41fcce1c3543a65ce6c897966ce063300560538e1c8298333b113f103c8e6355408200c70aff333baab833c7917799c6992131131c0095c5198cce504215733629c8c8d62c34486745f16c84f8dde0de478d29added361b409abe51f3566d27116e78c8633de1633499a9d6fed234f511002c61ba19bf7c5c8a25e48fcbfa2817c0273ed429a14ff08a2706292289c723826a3e9e4929a6208b8534c47811a9152db676f47c7e949b1bb5c732c321c2388ca25776b42d38e6ab36ec1792d1c4790c41a32445ef970bf88192e4ff224631fbf39116f1669fc2f0bb90594077ae1cc1417e6b7c1ee7ce65329c477017b1b084491c3ac35fc18b09efcd1370c749e983fb7a996440329a09efa3bee007e480aa51e6ac19c4bcd52fa76898762fdee11371552a2465e7eb791e183eee9ff687ac86c4bfb1e1a959bd1f4fdcccd83c3e4bffef8c5151bd5766c9c7e4c9ed7708810823f2bef8ce6a0720c322866fe851e0446a4cf7b86aa846662381855aa14b95211911b00c61c296da96a0b14025c3cbf2676d50987de97365248b02126a5fcf50bd29d531f5317054fbaa7cbbe3423b8f6a7f5d330429dc3eefbfcf856969f894d7b56176509b3a99863845d6d73da04f6ac98838738a460435339a36c049b72152bbe99882e43737779a3caf1ec85c2e1f11e40af46ec85f9120d246573472b20381fe02c65f95082064df4832d69f5afa67f79d8add070c4cde8eee45374862bb7081e3a61e8974f7d1f41615de12c0195731c4edb1efeb648e6f49b2b200d97031d4a37dece261e0e64db7449d42f8459ac8984a073ee9462d127c8f0fbbb9720221908a2720dfdfc07a602580721506dcd3ff19583c8376ae77871ed5d216c002fdda0414baf1259abc4f450ddc5ca2c31c70add6fbacd26ce4081fcc136d534541681efd03795585b1d7564b58e5539e2334b275e24faabfcb47b93c0ac1b5338fd40d9ba490404439b94de5500291c8f47e982b809ebfeaf3ca535133a2b75a935d4a844dcf406009152c385164f4c8ff67944f05ee0dc9a86277cdced9eed0f81d48df4e1b55349284599d447a1b74b39dbd9d55fb3aee20f76ff5057a20f1eac8f29204afd0ed041e0e17bf9811f140f7995a66dffad1ee2c03228d1c791e2d8330bee27b056d1547874cd2703a3c0ed6dfe8fa5cfcba36a1b4d65c0acb81490b7821f08d7d7b21af500658e4e3cc4a66c141ce1a713e72a60bcb686adebc651c9bab299dafc0753e151d6e766ccf9307abf4a76f6945597f00811721188e81c4826d1d3a9f994a3c1ba96d8460541463901e231870a9dcc377a025e0086c2eededf16bf72d60ef4c4465b8c281b1fef633ab6adf45b77688d988ec2647a7ee521dd7a85fa1c21165c057ebe6167b0af0ecd11a99370dc1a6e09ef4a69e65efc4aa35444538f6c87b91eb8be862bff3866d3ff9e2ec84adb800d709910400012cc9f96a37d968b1375dd82909ac9224f5fdf6f3c3fb3d336aa0c81babe5fba645f5ec1826ba6f285a864776a5465696c5e8006c0085f1cf52b2e0a8d60771ad3883feec706e5cf85ceb5120be10dd9233d9af8e9a085f555cc0d32c0c1c817f88712234256f8f458d1953c959d939e76764b5dc151fc552148a4e246ab5db033472a9d812744bf25edee86731d2c166f51ba1d172517ba186ada0cd41822cd26b178ad50f110934e091a4b3055e8e685b41a723bcccb1e02e923d3d7052ea50a8b7595dd466dba409ce9e5f92285c5e7c459cdd7d0540697a2986f964671e1e75465fadb1fe5245c2a5c7fbf806a2df6241a3f04e812d0b6ab815e1acd1b57a1aa80c33f2bda9ed929e67ca694384b9ecaa1704d0457f05c05014b8c6f93f7e2dbab04e06c5d7005b5ae58b0e1a987b7f8526dd21ca4358d2df3344cb8a5860de34238b7180c92947e4ee778b0ee8f0e4d1f54b3e4004a68ec939034ce8f721aca89f8cf392b89a7518748280faa5715935c13e7ea99a232f11e7425c7be1518d998ed89bc63be2fd45737863fdcdf5f02790731f16a691ee5d3810f04dd26e27646a0f1a6cc063f3dead1640309665d8c0ef65298e34e1a8963a12884540259c2a65a4bb9565021bcc6ab21f7b8e6517ee7fa9cbc267865c79a16589c15cf3e06beec83ecfab64684c145425a6e5477640472e94df4a79d768ba1ea797f70abb537002ab0ee99a784592b956924a46620dac07a2b681d6151ca97d5041de5212e37dd1eff1c33cd3b15e394ce570262b69ccc47ebe0c99dce5b1820405547f7093ca20a1e118a825b18118a471c01b50887206454880e68e78a7b28af491c6d550ae7ac6df6b73373645b50e905e9a728f20413721b2e136125164ce62658ee4d3b1ed7302f9658cb0971b3cfa2bba6751c47991f973e1fb3a367a6470bf19160f33079760d4dbdae33bb9491fb19496c597492c28127be18aa126a8b04f4350d85df978abcc58e0e2e453e35b38906f57da3749a04322a99065c5d6f298b579617e4e2e50431499856a061a08ba3dba6b491e7f848284ceba154bb3c02b1cf4e104f3678bbe33bb8e84fe69babfa9a4f1450182f2d4f6cedf89f81e2270f8fe4b83f8f69ba43cf2baa527a56310b4ae9669cd4244d8b66c393ff02ffa2b1ed3d09e8d25d73da230943898571ad323819615a45408bafab389d76b5eb9324874c7b262120c4f03318ceba1a09ff24dae18e28639eb7fa4c7b6a5e8084d9a7d3eb722fdaca31b5fefea6adc14b67e3702026d393d42c05a013fb1d0087e9c47c2e2b866ae94ebd194f066883a803cda4bace02a842797e2de4d925c13c2cf14083b2d1329073b6d69edbcdca2c81bcb3837566b153de5e5b13cd4812f592864d5a4ad0dfb5c676a941c96fa2991a696e8af1b2241343a1dd2763cfbf7d53c90f1f3b808729f7f3c0bb1b7f7021da63f14e453ff96374c9ce2aa5f612ab55d08cdb87b04ec18a3e165dc54d323f7c343ce079bd9508a44f9ebdc00361fa7074ed3317bcfa49bd7e89e9ae4ce0e2cd4d510f8521a6508611c7e9e24bde603b82250b46ee3ce1422e0fbaaa595726a96802c380fe312a1e3da549e6cc3f56855afd6ad1ecaf588c3274e36810739926685e40bd6f4a06da775e85427a440b442d7d835c3d95d2095e79a6e7b5e925bdd7380fb6b0777b19df1a69900382b6be806d3ba99c67234d796293dc2548d76ec7a48fc676ba5c43ab06f5c61b3688fe34cd7944437633f85b41a11de405c6c47caf49358d01cb2ecf703da00ca8f8ade9d0755b794467b30329863d947a8a512003bb4d311ef6a24886653a3eb3e4fc5f006eeb0ecfdf13dd2c2e8249c8084930ac4329a7d01ed16d2692c8c6317030c951fd7025dae1b1d0c3caf291f45d6bfaa8eecc51561f691c422c4b06c03a1dff70dcb65a06eff61343f89bbb820051a4344aa95d10532462c2a3af5304be1c236a3dd5e031e4250617c39e3f083c1e050e485e9c3aec84021cc8ac8106efeb0d711fdab79213ca10c5b8ea2620d75ad29e3ba8ddd80ae51680aaed5d46d3fafea1489b9fd3c8f2eb5807cf332806662933d03cd51d326a9aa7d9ef2d2ae8eafd27fa393dd54f44552b3067d04b37c9b195fa34d998580c81869d685411e1ded8cb128e22df6863787630d935843c84776fb5d390a20c98a8c036caf154201d8d5e9c48ad1e5f18b31768c977addccd3d6bbdecf2ab48001cdf4d59c6c1c76c7017de1e955660770e95589f37c30f4957dc49644fad5ca23b06af35514a0bfef0875cf446e3a4e444c40c3d1f32a42b3a1f9418effcb8cfcbeb3b36b0fbddac2c85f4d9e63c211b7295dc40bdf1852a6e162ceafbe177b13b07d6d4f08e224658925d4d7cd5884596fc8ecfcc5f94a56230bf8244a4853127e3284bb5bd1b4e0dbc178cb817dd41c1bb39352813aacf5e5506d6f6097d22e6f181471461c5272cf0338134c833bfd74097eb2db6dbcd6424e95133fa1efd9aae28a54199f7121b7a8a7964c3b34a0ee22e5f2d6f02796ab55f2dfaa2708c6fe5676cead898e58d888b65f0863bc0b1fdefad032e84835b4560953024392128e637df62a827d42686afa489c32b855685bac7dce35a1e13266440c510b0da2acbcb99a884372ebd5881145acf9ab177ea7664fa5cfe166c84f4ca1dbe865ee5f030ec86f30ff16e957926820c8d7e5a02dc7f3e99000145b03f08c48e3cb18cec80f17f85cf7e83f9fbd4d9b622bf48baeed8506366ace0f4209e21797edf17e25cd19a921ddca297c3b59abe1496c37aee7bd2653c3cc8b35673a785e1dc712380d33337e21dd0134aa02551bf856c6c4f549bb15188c42c4c4d0b53c7d82405fd1b8937246adf84cd1d5dca5b37093a295c6d2e4511e23f1e8a8a531ea79318911fa23e25e97a96f63d0d625360037f41af2e4902bba928f5500252cd2ee5c0d66bc2862ad40a66f7ae2c788c09f2ee71216b47ff8c7a46e38408b04d30bdb1d80a564e9ac458657d27b122d42c72e9ecf928e0066a06bd9bd710e6d645a94e983e0fb6e1740536887059f61893669279cba2040bbd2e49d61c5650c5bfdda1a2120333da7dded53a7ef327d0ec4c26aad19de93305988f169a051adef452ec264508f473fb2e59ebdc169905eef3096062dec63656756d7bccd263bede00f744775d6e14d8aec1450ec123962ed2313ce0fccc5369dc3ffaea04b7fe41930622d2629cc59919c7e9e483df58a7e68120c2af1de6cd011a4b5e461a9a0696ca8bf1daaa1fe8e22de4e6369283dd9bc4c1cf28b6a1a3a4595a299da47f393a2f9b4dfd9922a56ee982a4020c4e19f6b7edbf932c87ddbce35e04c160a1183595549f7469738aa95aa591b6f0f4126673839770fa1f4c6c5b4abce62013dbd21a15eeae258dc5c46783bbe8262f4a8675455ede77f5c486e1fd3663005bb644f0e0b347e2befba3473a0be3ea9a23ccf3b8e15c9cec7f5f3970836b325f577d1d574a51b00e28b7e6435cd1cc4c755ce1c12b917621bcbe43e18e10133da9d46f01b517911330f125c5e47b0c55ae262aa4602ef28082c67f88dcb9cb7a09b831f0a873af2defa7ee4b43b6d4892ed3cc84d56549573fcfb53a21d4ba5c3831ce59accef1db6314d99adda663c2709487ec9f980edb3be0972617483f4def8a188ab27fd9de24d49a77920c0b359736f6e02e62e4448c20b30fb2116fedd3e3c885fdb5363253169ee2fa0c72370a9b47c01853756e88ca5dd0af828a79001394ad74619f797149eab51aa6d429d324097b0ff686ba27c6a5d9c524cf36fc3f2000cc53219a3db81732f6efd0478ea508188bf888709a3b22a52690ae25a4373c7f3d97097b7302c22d8670ff1ab2d38cf3d37476be957896f3301d5ec686de96840926aff4ef44f794cc06601f20762523fe2faf09e4e35e9f124d10e9b4cd9009a9853a1e9b7f8d98594131580d3cafebe355d4da5d426e47f9e65ffa9afcb522b6e2c3add3652925eecf49e11ff46694be487e6410b887c863a7fa20641397aaac148abb58acfd4e3b431370b6b580879006c9931115ea6c4f1e4e06bddbaa05b79a4a03ccd7ff36a77def91ec9e28a14b6e76da4ccd726ca59fa1e2a5c3df7614460d5cb19406925a5f4b626fdb6ede722030b2e56ba6c690210bdac16204ae167d2b260b2c19052be474222292a077008fcbe948649e9173cb33fb94f7e27ccdff880c15fce758d9c8b7a5c5a5e5facabad0b63a56d8842c78a0955726f45b6c0149f2b992faacffef9c981657cf6398552ecce9963c7d5748a21cdcb0c3d132201746d4261ad2829cc2af0e312d2fb03607b443e99b66b9ed5ac2bc327969e8ac6d03e7be0d0ccca17e5ceaa0044d88e637ad75f808adea2d37a789935d7c108d31805809ea1b7885e873970b289a87d0e3fe794ed61a9e7f8e2cd89a0aa0d71ef86da7fe3f9315e1e3837555dc2c61b32534ea6ed396adde53495b30f52583a22f72b5ec99288690c8780c619642b732f41e0a372ef0c7a1081b3303e236a228568daa4f20149757d2f6d6c76a47345dc08783d29974242fba2073d842378d2adf74f61978b46827df509687ebb5e5b479b1b86dc928a5ddd1c125d88d376dfd8d15745840cfa17b640eb83b92d4630dd5181b63ed198da0995a87b7226049c4fb6aa567b0c3531b32758fc5600bc0e3db4fad17444f9acb88f1c170405ed77ae777fc8d36911874ceee55164bd409c5e97fd22551c85852588567445879595d72b6b7cb55cfd8041f72d97e3cd609f29f9240e18d47c6a3fc97f5fb1e1f273d820324da466c7895807ce147e3dc98d1000ca9fdfb5f1ee420f3b88c3bdb5d71b13824175ba94ce7accc410df7ce0c0efb44d0817b2635e43518007825bd80025d5304cadbc8d279310538122430483ad410decae7e90b311dfadba3e86495c449ba8cbaf0cd7c7d93be585091c7527f4ac26149f6745e99cb36c220212bbb5ea8e1709cd20e2dfc4b2b522abff40c574beda6319dc365fa1003e6f42caf0b3a4e8646f0d724003ba0bbeb6352c9ea63ae9ddb5f1a448b27c6fdb83dc9f99a012fc5e2f3ef8c57b46a557b57970c4b83f9fb1764abeed82fd390ab0ca376e0653905129f10d44b4e9741c09190921a12d73221a2abdf6b7aeb6f941a8c5d45b073720ed56479a2592b0c91bd0841f952de627d44f8ba7067a73b51d8def6c4915d4efe201c5ffd69ceaf812d32802379abbfa8a4ccc3c3f50c0049eb50b8e78a3b992c71661f394f03d8fc93a7a0c1d36d0097548d48c8047552935ec5e89eb3cb58f7c5f3c71c094be66af8480ddf6f3c4b092ab3dda2a051000807bcad2fa15987f34592197a4d69aa425cbf561501c74ad1e5804e085df990746ea33f46bda4c112988e48aedc35b2f67f62162288b38b62e98e16964734f09e1f85591d8e57bf7b9d39547ce85269c982782bdc83d194dd410fd78a64f3a2a29c3c2351d66f6d31ef7e04ae3c6379d2ca1e15309823dad5db3f1ab52f15dafbba7d364c6eec6055c719b8d146ad9999d02f7681dfc260a119b77d6928bd76d0b34e09a29c0b6f156ad184345b8c5ea0928dbeab5d8a1097f32c82424cd88b767c5f809a149144b5c691f3542beef53302515ae61dc1c78ea8ff4ce502504e96dfa7f949b637efb71307cfe517c45f5eda2119ba6f8563a2bb5718a8ae403cdc66da43acf138e208412403cf81ad2c1d1cd19bf9d215d5dac1070e5a326a447f6fde485713429baf434c8d77c462b8e683173ce96bb6e73fb9a06d511c4185bb20f84a61a647e1ac770a05309b3f5829ab39c47e0c5385dfe4b1d0eb39e683ef3b6701d96fa59cef92d50e068528246654137826385de1b1630bce536c3dfc3a604e32a5210f152f6081f017cae67f7d087a99f46ff6ef08be73d98bb2f985870564fdeb077551d9ebfbca06ec835738b4f559ac38b061667a768565537673811401fd2ff6329c16aa8b27d2c09e2e55f2a4a36e48b4da6d48e26b36f19435bdcce94ea6c13df00cd01161fd5da25f48d94439635ac62f0b9f66ed64f9b8d604a4b194625259544c41e62d8033088d0a4bd03d140aff44aac94f11f051e7d052640fac7443f71fa50a6a0ef81b14d4a2f499a41e5de4ae983059a3714920b1086563278e6e9e046b47450731100043b0855e2ecdf965ce6991a829b5b1d418caf4589e6694d3b58d0fdb6236e5998352a58521b1768105dcc0baf9a4d7b25fd1c8c7e0ff8daa786edc4948c9b0037d59f3db1176e4add9ad92de8fed0e2b5105694298b7fa45fd48322e54995db0ec8dc242b98f739d35bb0fb816dc899e5cec0541b158b06864bbc5343226c1908d8c3b20fc55986670999fb85c8df8a1f7b6f52c4e50574489a3cb782555362edbea2ec68db97a59fb3af2bc825d8ef8d32ebe2765592bb583afa5bb10d5e25b002e01cf2bba3351dd3908d8fa6c6732dda652ac283f205c03e51b8129e08a217411f6454b88eb06590709d6a19a428340309aa059fa44738b2754cf35764d5e176443d0fc208202e45e50bda3e57a5128cb977d65803326cff5ec152243667239f3de9165af37a8073cc45096a5e62ad33cdf6cded8e992bc0796c0444031039735d9ce42a2bd4b4ab6da567e4af08db08f961755b8594f0e7839b56f33456408f796737bf10acd7ef491073e4570705eef12ba47bfcd3717397a9f12fef6589897f033567b496f1a8a20492e5255b09e21598656f3f34eb833172badeb052bb5dec90bc3034243214b65918788925290407516795793b5a3ff8764d4888e4b59254e028e123ec68e68a68b9fd23c315bb609ab0aae9ea6c4a053d1a4e497658860cd6773eeefef30c2b4d13640fd4723536ce2eed0b8c0a98682d75d58f7d3dbc03261408e22a5fe081b43e8db554d2663284e9ad413c93faac4e7489da2ced9b1fd06dac05be13344580fda7d072326cf5c83904db01dc5037718805b1d1d45dbb76b8a8fb90ae6794c831f15c7e243593fa13b158588eda65111080e80c4882efd9a4b58da166fd9078b3f75ad508c9e8e11b4a7a19857f09a4878d4960248c0b829f1b9eee7e1c82d8f75183a62b00df539710c56a1ecea5d140542f633741c8d24821962ce71dfc290067e71ccd29538b1d0ec48625f5a3c26f99d1c509c2356fdb32df36690b2be83de812c27e811daa25f3a6fe066ee4a99ec6ee34b51a4dc5097839b4bfc1ce5aa6e89b9a9ca7472b61048e6c6e052096f82128669d0da9e18737ecd1384b05dcd30c982c63bc1d426eb8f74126827167bca6f786457593e848fed4879dc1b8149735a56af19edd057d4c5a053d41813ab91447f890f0dcb5c182fc4dbbb47820b00a44fef44dc5e720f4e0a3ba165a8fee62fc662951b66dc993adecee8d2b9696367f61151e13a02c4c973d34b22f0adbb236922b518775195baeb2c670ff93e3aef4c727aa1fb84e38dc592f455539f693fca67fcb18e0c85a9f8bae1893d5c7b341c497fe1161a43974b2964cfdc28a7c91fc3cf530004e915d4f73addc50b4ceb8cfef52122dfdef9dea91038dbdacb4d2d59973458dd1841b9e218a36ab059de5665d92346ed89d8b734c91b3a515326cba1dace16105e3130724c3db8472b6e3d2fbd3ace2202deda85c242c832ff9e2793aacb0d69f7f5c397c99df496b4517b898b081431184a1de788ddabbb14156b73cfe342b8b92935ec82937d4f86092247e3a0c530784aa33a55773bf73ff874408a582eb06f0f157d3762b840f67b78aac22aa4e3ab7245c268a9dc84710cc166d9cb1363450c79415aa56277122904eeea75f3dc81d535b68ed2dd0cfe2ac81f79656e8299b862d1de82c21789c83c57451591a427c8c285612a228bf6050f82450d91574b3f7580425ac3710c07109da40d5a202e7993ca2116736b2a4baece7ac6c5654562d71a5ef56c8f9b7a235d99f4413265a04f7ca57e6925a6195fc81d553d435e414ca1962a8e3545770e14a1c6bbd7f66d04e40f9c183bcf42097e4c99c3688f19291fd268a104a0ded2d68854b54c0cec9d99a0a06c555fa3de60cbf45d7bda74b0fed9ce8c4716544f9608d62121a1cda6434b97619043e7018b01fe47000d774c330d8e061fa0e4da5a2a9cd63f6d1d7746d7adfc4b2f8eafe2dbad25f6fe100a02d0d0074a1fa0cbb2909318c7dbe612d9373f51cc72c5bb7d0cbfe658b1d10847228604ae8e6071cd6c263038b3fa9257a6508ec29b82f4dad1c41364a4819b0f5eea83b73cbeada795ba96f86829e0c78c34ab6fa67763b5db702a8bb64e624c659b70e3459e53f6d2908925ad672db14ea78c79033c1efa07449171c5d303c4abb35b0dfa1ede7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
