<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bf102227be8a8e22ae6af12880722f1e5a77de0f5d597242f9c16a3da9396527b7ae2533356f76251150869f0b4e98dcb309ded8c7a35989a84fad1b6ad440126432dd341dc564c00a7b2be694f38abb6d6c4fe00703960a1f54dab8f8dcde47c65350edebffaf56c2e40c8ea823c3b1c32f416bb375b124eaa5f8a92df3eb20821e8ff23d3bf0e772387f3f101c9ea482db5d19705d9f57626d7df99fc1a3aa6b8c7cb85a37a6f249905cfc60cbe533dddb1dda4c6450b66085431395f81ca9b6b357e98e58b42a898fb498d1236a41a7cf52a59e9caffc5a12d8a5f5f03fcd5ea2b968993c900c3ab66236cf22daa4b35c99888195864b822c004a5229b5d367a930767b907349448b053b465a133dd5b55f792c3003b25687e1ff382b474ee7d16bd11c568743eb6afcadbbdf158d1506fed4bc9491da501786fb45ac6126252150789ea0991989ffbe718b27e571b9cb284b04bc00ee5cef0ea7c6c71edec0f5240913a2b853562c12c9dfa841b535eee447537114ffa65612946fb7675b0a94e22f234bcd97a735e5f456a2eb75a217841a388fd248b8615b4b5f2d9097fbc6e24d8ee729768cf6f90c26be325172cc9f07165f5fed4aaaccb009078b1b0f0b1c463bcf5b720e6e495a4dcc3426f266af2de112c98224df3d9051e34a8355a840235300bebfe367ec4ebb4d4ec61213dadfd8564c971d390ebeb5bdba03e8a48ab4a05a6eae437b7abd322dfa4eda9ce49dcfc512af7e79cc4572acedaf3cddc35e6ca9dfb3c28cd7e38c24ea5366d6afc67f0c3a61934e6de71b91e54e1d8a8dfebaf5b265dd67d4a6c52cc1b48bd3a7f83516d74bf0eab5275b90e2361ae86ef4c72325189ee057bf5cb43492d728fc39ff300b9e345d7bebcdfd2475f5c53e74aaae143a350a4964677217f1864e55a0b33b3b030cc177a19048a36e5455c260f040e93b7aae62f79de2a45e93feaee0e4340b3aa3cb71aea990d54842607f19291882c23a5e443a9252d90cc4c71394e2c41e5e8dbcc131c23a1b9c0e18a4565f6293ed93d22c4d6285c23bacbb71d54b7a393683d9ed644f9cafaa2f82d7e4ededb4b57d1429e1447def6b9ca8bcc8f48f1d2f85cd80553a21c8dc3f1b451ce4b5c5e071ed7232f2b68f23325c41d916bbd781087a402faa7226df77e6d5ead091ecbc413df04775ea75525f534e9a0137b7e34fd6ec33ffa167c8c8534659674a04aa3d134b3b302e965b67d5f7cee1849405c7dc560c913613172593180329a699ed2e4b94e96c7dec6a46687d3d5cf7b4cff2e6ae7f52cf75653c624fce46ab4575bde794a2f7ab75311499260f1aec6bfa4b7ef41d770e242312d8e98020a4b9c4ab048bd4d8ea14d1d988fb385ce3b7580c53302ce435fdf10ea015ce0563c6eec15d57644c1860f59df8776c0b1a00923f5fd4f43d5b5688eacb4ed95f920c5b83bc04db50deb3d2348da533ecb9ef2428b4d15e5401df5087ffb54107e28c30390db6e8baa5c5089a10df915dcc9731e85be89102a9b3c432c0edca066177a356cc2c67a914e52472c6827c8d58f430ae7141fcb4e955c076fdd8efe11125a2b00f575ca157a4f12614d85a3bec6cbc219bc2e16fbd0951336a89a96a92bcd7ce4d404b16bdf5bdc07ad3af4f72009fbe698b92e5a1837c2b5a3c6b66379729359da8a582701cb4ba7166a1d10e7d9a21d7dec7ca7a886c879d3a2b77a04bca79cba575bb7b75a204306d9babb4ff7bd7d7ddbf01dfab0630cf7b25d8db56bb4518c861f58a77393e3a8c9f3e0b825a25c3ec831802ac0ce27405e48f7227618e66a2a009c2b7683661e55860e50d2c762ec3ade763a5efa1ec1c0c2bd14061961a59f9cd3194e5fa5db2bb1481db2b33fd8ae487d2519e483a80ecba171a45138c012e8b1c2862709345918fd89c1cf81008e836f1bf736fe9a9f2a8e97f195ee1b753280bb97e42cf8172ffd11844bbb2b665c07717751493a43462410bfbcfae34c8d5ad354ee78ccd7a3f2e803b87646dd17971c986d2947682503db3e73d36d2db7535cc6a651013d8e0a319b1277851e6f3c02d735787da5dc7fe39bbb950ba2bab26e37d02d8cdcc623b925f05c965d12b5a3eb2f6cfb118a4a48ca4a5bd3f6e15711687463fff59436b8081465b00d4d15cdb53199e470b015f12fa1d5d1ba7ec9a11465fe7567e4eb6172bf41d4d82a65f3f6eb5fb6bdfd5977f878b0166ea2555ec005dc4cc7fef9df4342da6e2aa91e703157308b951d2a15cd3b8d4aa40e176a7fc8cf25b1c0890bc957c938dbb9a8125eb52bb67d2004fbd7bc883e2316f022f0bde645462df4053eab2f2dc766cf7ac26a8e7a33427495576124f36ef75a4afa1c2a9485fe2cd5ce7067d76933a826f39b396d4a177742c0c16738069ad623814e6336800e2c4372e8b427e691daad81da87427a57b7db03c65ef7b5e74354c45170c9549078e90b7a508c6078481f541e2a46fddef7d61348dcbf2e361bc51a4967fca2a445e9c786917c7248e84e15e1d285dd543e2979169c9c1f2e381f8fe7b2f7c1c06e2218504c4da630ffc867299b5a19ca25f4d76a696b5b92ad5da874cc8972fbfecd5cb72512d92f6fcabd9f742cc4079d7c2aaf17b4ed7778c85258ab78c47bf04637c4ece9bcbbabbaf1a0518e53df31444cc7ee9cbd891b7f43b79aa0a4f0b8d6503453e19409516bfb52376e1aaabb99c0b83d402d310a782bf320f67c0bfc42ffddf7a0b32a059a2b430cae9b4739f30163da61d3715e69f0eadc5809d3ec31bf387ef5b5620e2bfb5c3985f0216f4ba83e9292163d3251b9759299c7bdbcc9487122ec5713c1566ec811905028b8f3bdd16167f6d26abb66771946bd30a49e1c08576793ab7730c4016cbfd416f21dd1ac7492fd3e3c92d5d91981341108a39b78ecd4205e74b38ae7976400e830b4e728611698af09fef2c806779e160ae7704493d73d794317d52ef5b119e7d4d6748e9e9153bf30a7921942d8f950e82a1d93bd78d3b10b2c9b77346145533f3bba5fb8e93318bc0f1b9f1960dea85ab97a3960f1d4628d8e6e1eeb397292c6c94c454c933869ff666d51a6a43e551b20fbd574a1fcf908a1931b916c4cc13255df4c65ffc7ee3d0380aeccabb36456a0f6f0b062eaaa102d412ccfc1151ec722d90d8513be109677cd36ab9a674227ccb63e6c6077fd6566a5907fac35149b5b0bbc23798b28f4fcb13428c537472104bc84211bc4c3bf5c14979f961c55c19009bf818f873b1d4159cbec6d23eb8ab179b1c1cdeabae2e9aa0396d6b0c9e292e4364fac492fb82b576476110c3c47a682ac502c838cb47e016b66793c68e1ee27cef75a1632d31163ac74777f246f8066f667b0e1825d0b844a6549e26a4ebbd8bbf19617d9c06ee68e8639b4238e5f0addda1768dfaa630dd98a983105de7dc4d39ccd185594ff5f1ee74e898bbdfa2d1f480e7dc599233a4562a9fae376b16a3a59dde28f5772d246a641caeede7900a38eaeb34620fbc2688750faa92dd35387889297e2f0812ac27668fed9912e0a3f8c1aa43dff7be5783ffe5cc64ae9bb53e1c36d79c194068784d03df0ffe36edf5c38f6d046ac5738e6a7a3e4c2f481ae8fc2d9e3666af06bb6b5003013a705a1bfb51973b82c31f8d773b6cb1c3ff5a6529489d022d8fb51437427574fbb31c051cc31b88a2bacee7b909a56c502ef11ca7a07931340f79f59734f3741c2488423a58f2a8c433664530b95513250b005513226506ee01aa17cb8749efde4d2683951994a98e4578b5a0a05075872007c4c792e86b99f0e36658fd7ede78d6129bf299b2afff2cf2320a180253094f96a664908fa471b9bd20f1b0d62ed98ba6fcf70692b03796037eaf9d2014c181b406dcb8f3da0ff52850e2a1f17318bee1704238bf7c44c8a6047ac5f1c548e140cbc68a262be650eb3478c3e36e4386e40cbbfe95a16e13b973c779a8caae83d54172a95b29ce4a37d2926a3c1b8fcc03e16b708d2ddbe38ec332ef43245f5672d2845b663a7ede9051f73b81b5adbde98ece43a378cb260f8a497914c9a084d3c2d522a70b0526446358241a3014cb54045332e361a90d14ac5fe3385c4db52895029d7b42a8ac6ef9b62219ca62635c893b5230b7058081f624f3ffe947ba7859a4acee89da06b71e7b80a279af64bdd579ee315d180cc996b8d27558fb65d0afc1d7aa1e3d185933e0514420a769b64e26f32ca049932f9f391b8501bc2fc66b9c1c0aed9dd67e1f95a145b667d2a9bda804a8eeafa528d70c503d6c23d0b73072b5d980c68d3b34ceb28a1beee72771b3be3c6a5cca9b129617ce4be14b6d942d25bbd8863da48a369b355c561f374e632c7cfad4fb3f4c80789bef17f846a5c7bd86e856e716fe31078ed84c25c9de7228c59d1b7d03889306d3865f6ad8a7ac58cf59c1548dd27013e2f66ed92ebbbf11565bf0f9d5199c9918e554fc167ee9439c662fe0fd2b24dba01975326b526946d8f2726a2f6423bc279147de2a84dfdab04b4746ebf458bb16b99f35409655edd9a2896a4e7762d34986641451d5a7bca1b2a5109a1f0961056b0fc0a2293cc0bd1844e1401ea032843c4e9520c408fab5f0e00c4710ad6c1b88ac058cad6c34a3844aa0254e54794c1832fc94fd5aff37c2f93d4eb713db27b5242b305b7c3186efa5cdc15ca5238ec65a6dbfb254766d9eca7166069a522f6be05a50a5656f2cf1051fac4d0befb8dcc7ef63780e989823dc127512b4b8befd22faa061d59fe28110d81052970f85b4710f5ad1d306b02c440841437366c97da176e0f0b25f7cf765cf4f55a31c2c0334de6cb9ad4e021462fb648abaaa903350a850f59a896b7b6560db9ce0f4f5f8bee37d68e9a1c5b8c152e772aeaaab6f6ae6091d228e9d739eca91511b9b00a12455d16809b754759e4e03ef60615001657b344f64be05844afb83df510fd4a495d61a4713a71f1ddfa150c7838827a472b486c64489fb0daef10f8951376300c401f2a16fcb0add411a9ca72354a02ecc07a53b51cdb7836472051f2cebb877f7e3be922727b92c1055d04c0d4e18f670bbaf622a02857efde702cfd5c0a4c59160eb6290b15625c06fb3677c91b18035f3320574accff031813d157e78ba75d5f54b4fb98754e6284c47d00cc742d07f57822c2a086fa8e39208a7884323821a1ff0e727e3755403104c199c337d7052610ce2e145a074bf2e319403d28f7d2b625231f2af8744b09bf1674f334f477a5eda2c02d2d7c382d02caa7ce81b66e83796624d94d8ee01dcce48ec927eb34fe4aae1c72e9ffcdcf2bf95149604618d8be49e5ef5234392c28694e798dd3e6a90e5765b9a41943f012c41e0449b0ea83a94e5e43b2f32aaaa31142ae8fd2e3024f2359b298361b10e2a15dac4239b5d4fd573461741f69ba67d713a1d52ddc04ee9674ace474cbea49e9b9af5a805554c903d2e8a7c52e36ab4e07e79158f35276b2c328ff9a3f88129521fe9bafe6a6210df8cecbb33fcaff59dde8a357832f9f40d01f3d029025247b64b6eb290dcef7b90dfa4faaabfdb6c38f0214bcbee4c2504ec725d4bbcd561770b2138ff0db886a69916c73ea99a9207ae550de573e1a8e8bffe0c77bd499bc966cdf57ceb04ed61b7c56385ed65a288c014c6d906f19f79bd4b739dabc405144d67d7d14f9dffb06768211b8564667009c63c390a8dc6aa3743a5daec264c3018ac56e7c8c531c921cfc4e5f6b134f41b636da2ed2f1fd59d34897e51238188d76f28eb0404f98adf7300a9b4727a5a11b6e1fdba78ca04174349e95809d940ed679cc16a68061f8cb60a23a778aecb2f2a98d2ba5ed7348f6fa725758361f45e7bfa6045d066bf1847fe68faa2143ad49cc81c004f7f90fd1c49a7ac301484f754990b12a4ec72a1add79b0dc75802a494c0a7a7f6062ce4095e16663a763a4c84bf5357dd60038f897dfb429e67824701af2df35dd110b5bba1b1e3e2dc48d86794ccea7fc6f74ef9fa19a16c4680b2208a923495c40144bebed6137e38207a01e98a32ac42de74d179b96ccac0acebdf89970c83b9251d01cee747696d8dc8516eaddfd24b8d3cbf39cec4daf59a5bba0fe43bb1cda5447cdfa58929e26fae0045a887e13fe793f48c32d75d8fc4fcb3745be47316ad762e3a9586d01a6a8147690e4243ca3a00769d62881613818b236b4ef8762623ae2fd540ac625eb8a2b8c005259916ec956d4774e68e4b893e7f4ab036566c094af1197c690983a821cc3478421cb22ac0d318097c465d41e7c458586f9baa1803a8bb407613d4d1b699e122ed2f886bfe8fbfe7a043dde97084d8134cda1fbe699834e07724f9a61743247aef0d5ee2963658d57a3e06a3e45fb837a12d81f4ad4e7aa6714c1b38d60c59f1e1fa44babb52b9eede98d687fa61b57e4ff0cadf929222fe5838610267c59eb01062351ddfdb93ad8b68b2ec54a4c04942bf586fd8e739b73c406db1879173ed7d332be526438851b3eaee21a071afd754509f5a904ba4d7bb0bef826d6def0f469604a498463ae35e1f36975075461a108af6f74397007e6830bec6075cacee241792208b339a0683940d4581ad2a6b0daf428fbb9ec6e72898aae1cc0a5b53440ecc0de4acf67c539f7be449aeb45fcd4a279b6de4a9cab9e1f49ed70adee0729804c1db482ede503438856f0bc6b4deca0a1717094781cd613edc2b88deefacef69eafbc3026b9562f9d6b193f803159e127bdbbfb0e019b06ef7f30429d9321fdf4ef1c15fefc7ba0f2cef56959418f0fa9f2ac3b299691c4e97fd2f10aade66c8aa6ba4828e084f5e5bfafdd18cb8e7d4a8d98ac36a87cdde0b507ec492dd6e9d4dc89696e87c25c826082ee319df9e166b2a38205d151f4e364a8db3900bffd4eaded9c60e0955d0324de120ea02af3b0525a2a09acaa89c9727579e9917006726efc8601eebcd241bb483c01529e69a856821545411f6043835ba8fc8f001f961b366b946d975e44b4a8843fe5a71cc69effe0e6dfe97cdda8748eaf0afe57afb9a3a572c08c299bf1feaaa092666e31dab50d356ba126fb9fd4f2eb7bd02405276f8d02238cb304585934403b1c3cf876d6b9e535a74dab42e8937c9793e068ed092d8c4ef89d1e0f4e8af232d9b98afae29d5c362407edd7bec6e2053dc0e23911624331c1e951978f714b90058fa6de0738249314e732e9f819fae24cd0e536aa14e396b6e6bc476e128e29dd8d25fce6c5766570e6c5a9ab8970f5d71c52a943b237d43cf1c2149ddb022bb998a5b69195f49835b056d84b857bf1bc939c9dcc52e5a96e35de857657c6318b9cb8fb2dadcc73f71e5ca7ba6589473575a4c5ffbc9e8a5517785e24b55848e01515101d6932202bfd23f71e02ec2154631dc1e64b06ea125de5eceaddfea21770efb37760f8306139b024494939accca3af0d02b5744edf1810f17e4570fcbd1ce810fd0e6186cef01d1f5f91fccae4b4c6e101ae78e78692bbb6614a8f8afe6101e20693a71d91e74eed2574d8a82e81001b2dc0fe907f27bdadd9bb4f503d12d11aec7d4cd382515c1edc09db4327da7df90d0ca26969aabcdb6c50983a3be6e028bef33aedb871493801be3b0315f29327ef913d43b140a9c815da76eccbf4ea911b83d965e00b53b1d8f8615dbfa8d48f14bdd94172c7f2a039bcb406c309a91f3768418b1a12b0e24ad05b2d090cc236ef9bd2bd29b7fce416db5d2d9d381164ba72f47255883179f109aa699aa3c24ff1932633399cf9fec6262b9d252c6296d6783825a407be6c84491bd2baa71e2b675cc086fb2106f088ecf7605e1a73d1d1903ba91b1282d13a20689b0f64e69f04da949a594a5932472c4658c60fdc84695c1bcff1993af6a5b95684b846356f8c44509235b12894b3e5e5def73de61e77a9b93657e5fbbadaf2a02b236227a88f96634b50fb5d29d9cc53c546a188118dbfb1a75945a765851c723f9666a39777e2f7e1ba965cb47e8d500cdced8b58216cabb9cd1d9ce8c6fc4b59eebffd2dbfbbbcacf58210dcc79f8aaf5a08a32200aa779ec6cd897d742905d6269026d2bc0c17d16c6836431fdc3155e9f79e5492c0264f6270470e0fda334369e48055a9c0aeab406846d6bdb7a1abb9e58f078f8e47ab9b89295769e11a614c17868720ac970d24b3e2de02daef3af5948f43c30e765674593ee6810e3600aea13eef6afeb299b080306fbd65ecc6e9a286fb0e608d60ef07c13968e7274d318e0adfccf376cb9ef444d36095033989cb726e3a2d57d70cfd782ef07daa1e1dbe02e1bc54f51ae62acb43199ac68f15134b2ef3ac1ed2a6c867e9272090ae5c013a174cacde5a26696ce601cb3c72860655d61935e2a8ee766615f70a3e7aa7d3801e8e549cfc1b40509d578e1ff9efc04c9c32918c231e55cd08b9b424df9e0b30304eaf707d64f32153420982446eeab7c3d670b39b337e29e0ac5fc6dcdd1583376a025c83be03e8b1b38f51d584cb1d098f609121343c9f175e36881f3827086093107d04595b374eeb819af9703011aa5e24ad5cc1b5e88229076f180780dae20fa6cb64dee34b7b4d086acb3538cad4944b726a770d4cefb8b6c9f70639371e131c43c2e4520a9af02b0b2f0f34ede47eae2190ace5507dd2abc58bdb81098eecac6f9a31511131be638c2fd6d17ffe3ac82da011e1d95140f46dda813a6263eaa4435e7ad2055a58f60af6eac2b44def5289bd5e2dd70e7955e1cd0fe767a9202726004bab30e42e654e7c1b90d8e0bb18752baee4f8e93c5fb780287554c31f760182d3d267b48af3c8d4cb9351476ba74b4eef692c847e4dc01fe1c68663d0651be612277a5a67947bef906e452868053f88bf09f7711cdd504e0d4bff4fef456968bbd4682c5dd4cefb01817c6b5e1b757079c0dc493e8ca854c93d9bf1ea4141a7d56c35c6b6ffa893df90728528f8eaf5104abecd6a1cc5601ce31219a16359de764486355d92a5a2f9d620183535fa13d95b2b59892bd23a803e8001b319ecf9250defcb65e21e0b6c0e6d05ba7f4daff01ac9bb193f3df4c22644d84f153d639973a58aa992848bc7cc4f99a60498649d9a8c1a4c845de4c815f5451f933a3571daa845430a3734fbb20de0a2b083cb68c1c19b6d3d0ece167443fa110665c808398fd97ce4798fd869f7e2ff456b58461229e8d7ae701fc5b79e29b476935975b04739c23aa01b3dd4c31b22261a1d3e3161d880b558684918539c5eb770d091d48555a3c28aa450d44d7e25bc1049db860b11f063ae3df32f1784bbabef8ba625103d3e9c9f08455b9672910e77e8d4fb78c4ea16540884c68a12841426aee2842cea6e5df9e179f609a255fde279c66112f9d0752ec61de78456ac5153d06c86434072246678d9813961d599f2dd6e9d7365d091df38a52fbf862b223024c389f9f8170ae0b6616f9503ac12525f9cd40ced54f9f2b8dcda0098d7256edb33d3e0aab5349270106a941b1875473c065de9cef8deefff190ec8af5a401f179d75db611efbb79848ede5a2bb7f3d6e0add4c084e1912e02370e8a207c6114d482399659d8376c0cd193b658e71b949fdd4eaf18339281210d6f5cf18bf4ad8261f3ff84ab3f2c831231bc140365ec19c49a79de2852bcd91f4bde572b1344e5d221a52afc9c674670b2f5ef0ec6551e23e6bbd7995331eabfc7482b6badc5eff1e3410e68809288343e503274f5d7ff893be3adbff72bf6dc8fd155d719edb911d2c0e821a8f79e37453b8295c9fa44fe98f8413224388c065c60fa526a959bc0343ccfbb71deaac979296b98d7dc72e6db0bacff8de19316acf7dd81f6a8dd01e050e5bbf88337d501b68d4018374686aad645255c81cd7c30aede42bfb74f5d5ed1ccb7d0aa2b17e2dce5dca79629729cc24d063567ee655175f37f24bedd632bb91c90cac312ab30fb4f9b060528886cc231134fdd2667eb8e1e2afa471ceca30435f7ab085b0d680439f0218a9c2048006db167263e1fec850c809b8b7285f6ad5375d97b1974619ab1aeaf89a15d65baacbedb4c5fb73dce8c4719ca5836a2231ff00b44e66fe3a5b042a0d0b280e170b3c4dbfa92f47aef9c227a7ff3b45df78488d413004115829836e11395336069b2b11ead71a92b5b6e7e544a1aad26fc070fe89ee3459eae00f8987174100b51f2eefb685919058b9f0097aea39d51d4518c5ff88df3a0614c03d28cec2b749f52a6866d8c897662aaef93765875c5670c0bf45e1cae25ad7959d249be3b2dda805b85cb8bc6c841acc0fa146877f28db0c5af751de5e617452f1babe3ed9dbd5c81a14e33261214ed28efcba5ae8f36d31eaa96b1cd680312857bc479e3601ad18da7c55085b645dfb4e65e81496d966fd0bec59ba20f43df783117bc69e80fb8a859e8042daf352bf00c7d93460f68db451d4ea84c216f04fd64885b5f723023d3d45bbf8b1fa96df150c8b874263288d7f65b19677a9eaaedac1f5fb4249171cbd667971f2e0d9fd191c61930fcc30a854e19524678e10474d808a6c89e9a5fd178b234372ee440b2893e5068d7bd2f224cdf6c8b8581e411ff551c54ee5e0371cafabab461def259fccd74b21ed90ff503a48838c4782248979c20fc411623bddb0c39a58635822fcbe8ce2a41044cd7efa8a7e5ac9eb244e1aa004366ed6b093b6cddfe155ddd768b4644cd265a9114d4bf5eb8c30e382a1db05dba84fa9a5255e9f2321a527f9042eea22d16f0303a3737e435055fa6fea05b87a93e2b66a1368941fdb0e1e75f8766cd2fbacfb4cd1b28003b57b1deb7f490edc2b7d081db36e9cc401942f7c4f4b1ed1d984e0dcf3d0cdc6fc1c2018cec4964886ccdefbfff98f9ac86915e5c874258f1c3c83d31aa77543319083757c2af9ca35c50e438e8fb3e0124d613075a6a6ec57d6912dcf4276446a90cd05076f8b8470dbf6ffc68f0487f23d400fb7082ea21fcb133b1f3e3e2d68766dd9cccb25a99821bf7e914de6299a2ad0eed9a72322a0161c3ef0128f7064adecef174ca365d52e78c89174d5e8535c1abc33ace1f35c7257a2a9c900843af5cf9818feb68dff1fc2ca9e14c61c2d60c298799f67be642866fe5024f281f5bc26e3103f0c6792e62feb0b05730492110da8b15df5525bd736d244481f13c125e73fbe5a025773d7259ab35d77e0940d5dfab8096bfe7e00e9163e7aa30f19b24fcdea67c11a866dda7b30190845fda6716732faffec93e0ea77152099ff59c3d0d0eb7c1b2d61a36c0b54ebf6dd4828e915ea319853585ee3af27dbdc41c6ddf57c1b7e836bdb693e0afa83c51842a241ee0ba1e79e6ffbdd4487a2a4b02648433256dfa24a7e8b3d7b7f01c9e6367aff7900384c557e839177323e4c55678411e60c29ff4b47cbd638847efd5086f3709ed336249e3fdb0c0ff5f400b7db60fa164dc584f442c08718f903ad49e41dca4abec73ea408dc47d796a84360eb63c6b5e9336747eda0d501d1a8dfa0f164f255ca3f55934f22985d2e45afd0fe48b3514918da5cf40c0bff1aee74ca59d283e0c66d0b6085425511459d049abf04953e71a2315dbc1235b3c9c4857c5926c3d5c06ba6eef3ad87f427309ced9db406a939f03adf03d0c2e1b4c17adbbc2bdaef7afc808088af952f93ce7171dd1f73aa16c5454c52a194e6c0fcb74445256ce1ade2aac96f5b77b039101af054121c3a2be25b2e79c49d5469c202ad85c89c02b9a193bd054f336a044eafa91087685212bec1f3397f925febeed7cd3b6885fb95d84f55979076b0c804c493bd7dbc84b8c7401789c8d07e1537f3eb49326c785dc47cc56cffb83c75ded75e5cc35644d4d3312be719b59cdf6597dfec9003d040faf16977b3817165623f138c84558974b95c79c5b40d9d0cf9adb6f9cbbedec122c3728e5ec952b5170aee91f5fd431678743eba4b7d7d6874526c1a72f176a682051a601708a00cf967eb63582d709bdb547e67f294cbaa6266c12cb117ce5a2c16d8208def2a6d1a57af568fdeb1f20873b8065f14f4c30bb3d7d573683b0b7868f22e5408c75756dda43565e1d6b445ab3a4053d8a1af8716b891b8ce0a3bbf06a5e615b875d637b96ca56d56be858dc0785c7d025cb8ff261eec5bdfe11fcd6a871f8639f7f1e52cee9fad57c6ebab0a39cdfda8df0492e042f4e67e4bf5a9064574cfad1220bd33d8879da032810bf13c10ac80e6b4f3ff745374dac284d708586de98ba81f62b58dba8ffc4b6b762366e0a9b40ba79ce12550a61e1e986a5f1710fda2dadeef765ad479030abe5dce37ae2a9de19044ddf46171519cf0091e064c37fc7d766ee6d613ef473542aff10636bf6af1a072128658551640badd8dce547ccb5a80cdcf2376ccc30292327687d45706da0ea577f050c4d013abb2460355ef1ba049afb4a766601ff5b1c8c84a79faee000f5243793596f5e1f68f0232baef21bb3de6a08d3477e52726cf3eb461a74ac380e8b533a5ef605a9e2baff97e9e72f695b42f16b76e741539f94b556ead18676d54a0c9301726753045e1ac1bfe690a6250ff0b916fc7c5cd4e9a3124599d669501c4d2a194da98f44e95a88d48d7fe22135bc277096af03c1b91a208ca4a1e731273f51b2544f51e94174db1ea2e934da4c2defe8da06a0c109d040dc2ea56c1364fc4af579a6364eda7ee06abeb780b89f3d947e5dfd320a1e09f2eb6ab2dc715cf761687a6e238f1e4a9f9fa1a0c6dc7c9f629114a45fb9a00f103c85f62487e0e62a121e58c9ff5d3a58698419587e2bcc87d74ed31232e3df2c7dedaf39f24e9ad4721883dcc15e2dbf674fdf56503385001c1d947d13dbf4b02dbdef5aee286c440db1f445f7fe204d2b137280d82c5097e5cd02a6a2171c19cc0b41b77409023b3cedd288f002d7e14a0a4b6fef4cec21efb44c2e07179e7e189e80ee8dac24451ec061671144cf59bfb47517c3482a903c3bb23387b0a371829e85536f642427440034e49e93151e55ed45b9e200face561913b543803cac1f370bd2805c44e51422e962063ec248fbb1c26ccd8bab95f4de77d26c9ffec7e95320cc1679487e70a5c4943d0516b7846b7b5cf8bd376e4953dcd3b5d3d00b43047eb585dfd0a9b3cbd375da31ae1af17a4425a422a0fa5007f1afd7006db1f8f6a9ffc0d8f72731ec95f495e40f08fbf37fa853c7b11531006dfee8f7272ebe1a2ba40473e5f48a742f0099bb6bcc273e0761a5909fe9bf30e9d3197e2964e3d9f762118b2f40d50f608f6fa818229b414786803fed9e9a94f79e07c1495738300a3c5f0d9a9cbe799fc687e91640cddf6c41f73ca200a5a6312ff2eb249b51ce46a27f83b357c244bad2e5b649445c7eee4cc649e90e04aecdc751f8ad40c611e4ed56f94d9fc997b7366562de9cfeef8738c0273ae71ea941bbf204362e868483f647a9fee67b718c8634e06e0111ff320a502d82423224c7f2c30ba81c8378101721eb881fd996de802b76308f59d969fad84fa9e66d6fa4f2e019b8fb4f9b413de6fdbfd282db87dc8642563cf48d4444be99bd1d323b99627b708d1ca7b2d013c84ea42ce7c0262437c79d7975f6ee037773e076e541c63effa64c78cf08dc0b0bbcaf2298e1395a6c15e9ea3418e95974fabe44850aea88ed0cd6c2885ed56a5887058e1672cc88fe7d4a47f55319624e41a38c19dc2963711240b9fc89a9230e2e2d92cbe57fc48c9345732886519bd751251ae0ccabb148d9caa8c0e8c799b313aca1e6b673f01bc7d8ce37ee26082b47e55b7fc31ae393860bff68c79fdacb2e188b010f40587287ef2abe251cd81c5de89e5ce00ec356d219218d60debdd102eee2e2fae3ac3dbbde190e79c8b49908b08b953af0298eec2af4e4b5a04dae75c346c6c7789144edcdbbb47c08430fb2c706b4478d55eb4d98294c7bdfc404f1bcc0bc6d10a6eb51472b5a35328fab89816be3a26ad44a1b9113d8a0147aac19a9ccdf6201695b99ee70993a731d15da1c66454292948c5a0815737bf4aa79bff472a107db9262633ea80d359510141245d3f06a5bac1eca8d34c9552ec3b43cf437678f2b731fb8f1e3a393261af669f63fc05607eaee36ba816d5ab1843ca9739cc02de23712c350c1659313ba94fb45d63627d53bf2d6dd4a51d467939740b59e27414fac486e4ba8462113f34a2f2637bf7db356566fd87cea378b403f47a8f4dc99006587400693bfadb2df0cb1bce32ddf3b5361325aebd869a324cc918509b7e36fd8048fdce0e71daa4050819ba3873a6caef1c2f9d84625b4b67fc18b30339e521618a0c507c4f5d0b14f43f6d338db4d90277102b900981df26a7666ae2b45071bc710206b365dc2814bfb38e57e53ceaba0704ea99d85a3a0f1a0d661e96da577b2470c3d148c206e94751e861c20c0854634b5dd0d05903b5a6bcd687c93f6aef0b5dbeb57ab6bd5b95792a2bb39505c6c697109ea061c8e81788e2d233a5b7acaa1cffd9a670057c28114e88baaf7f62d52d9982d35da06eddbe9ab2f5a8c37bd2df44e90ba15495f1cd810ddf54df0cd7f7cebf6814b9b50ecee167e79e264608e8e776fcfaae5b2b1cd309df945db905e40ac9f9ce860ecc0c25a33d1f8cd62a0ec83b79fc77f3a4242c95483c03eecf65edcc4e4b049a12a1455755b9e7dcdbff197e80ce743e1d70ba0cafffeda65a1e4a7f460efd9fd50e1bd50b0e8cb5ef8d1088ab4e1595db204e40ac271f761e9a5ca4d1cce974d4da401d9f6373c22a3ca8902c01caa453dba01d60aba5dc3271ff39e1ca6767f9394327759554c43325a689343646fd4b0dab517267f29a8833d060dec7bb3b913f21883ec579eeb32a05772ba18c38f43628ecb01820f37a5944eeb70734c02caad2ad8cb53883578aef7e49a3731e91fc90902699eee1a70311105592aa7f430a38bb08f5c2bb00cb610ee046fdb6a78be13a89c4285fad6e26c3dbbe2b7bb6f3ca8fe07cb22df82864817943de434411a71ebcfaaf0f683a665175d435293171ba935b6db0497ceba839332f255dc61c98e6d786f22f5642df2379905bef72525b7f83882179df3240651e4f4e73964edffbd7684b5d469b3dd41aaf55fbaf4bdedb947c63744e1e1e5364150bdc642b9756894cf0a49e24f7b87f88f0090e8a817c52e0e28ccdfb7fe50da7ae877bf4214f5cd1be691be5225173c8d9fa66305cf30a91b50ddb597a786c9bd38231378a48f42d00cfa132829bf5d91a051983d4b7fbf3efbbf63f784a377c7af450305b2b705e5e40e74fdf5f54be1f6a9a1e3bf19c695d06a0ecaaf37552128b7902908f0e23f98a27f9731b196a3f16140dee293b0d781fbd0400d76abbfb46aab1351e9acb08e38b2bf7e4c03150494472df46d3b4d009239ec00f9b3eeff05c1828e576ba9872f54d22d25b1407a286e2c8f970df91b26aa8234f76fa02998207be124e5c491377cc53dd8afdb48d7e1026c5661783016f79424ae32e03d00d73bade47be7fa6213f96f1f2832d4dfcb58d7bccbe2c8364817d5fe966fb8326119ca3fbc42c0a7d2f5b56c12f122fbedba89665eec2c6fd5f2dd5a8457992b4872985938a4e40cf3e7369f46b4a4f70c563d9f0e265df66ff4d10d75decb39aa132c49fd5e30b5c147e3a7a46a032b11381a364a23b8e040acaadac6747ab1f460da332ac18dc0830358e7f3345a7a1d55e63691757b89b492abeac957f039a76c4407292c1e8f43f0f514bfa2bf6d39c0dad0efb09a070d39ec1eb4d14d21eba6acd19526d5abe4dbda25ebd4789ff44d26edb52db438c450d8046521e95f429fdd8da7388a8190ecc2b1684ab5a7860785874a1f19017ee9476d3ba06771031c71b4f3f8dd99ba5fa9617930d2ad2f7bfd6aa079e96dcd8f027557b2699971e3fa06438654b2ef9e8de82814be221712aa6490d33654bbfa2b54d89cea5b9feac0d7e1d15dd7bc5b09947b848803b019ec40379936df1d9a5cf8caa2fa6fc22f29178ba807344a7f0d47a564b2623c4c24fb2cf996e4c1041b5982ac75b6b5a1712fcf3d6d8a9fc17f10000b07565b78c9e6eba1d5404911f8fd9379ff3c55c9bf7e7f34b7e6613ae4cf1cd79f178e8553d64c7f03a07354437e8b2cfe7dffd6db57de3ab1993644051e22a93bbf8790a0966148f9c43cfde3edc3066c67b616a9d66396468df7bff9a86c907129030eecb318305b296a4b37fb0cdd3600954e0ba83a051f4e489ed48ae000b36ad942e120b266ecfa34f5cfae196bf25ce29fc1e74865a2fd008ccaf1b6f43f80f38699372d848cb3a40094c05762e04f732cd6419b3f3cda50dec6f21178feaa8871eef2c6dd11d91b3dbafdedca47a1ae9960608c09b383fa4078904a286f28f2b6af0876b83f4f90ca0854a73965ec275d817aa63a23d620d8cfb702b549ac9b2a5348e628d39cf1fbe2b111e723b539d177c6bd24d639ec4c1aa76549df6cc57fa33c93d5945dd6f4b314fe78649d0b88950138fd83458d16d29f6f1f0cacf6e2e2c429cf262f170ad916787209eb28dff1b4356b65d44e3a7f4475957aaa734e5e069640116d7abc1bfe5b307f201ad0ba59bc06b190e0240e9bfee2458697e5f691a06b91321f9aa5b0b38050a7bdfb2220c205df96d7cc2156a743c842444b772a7d4b888010fac10d0609ca12444d554ba46d18ddff24395c77c8e032d1351d3367944131ff1219841a106dcf3fdbe498a53f0aea382561af64d6f43f1fa069e57c1ecf46101a7b4206705e8238a449dcfea4b3d244bf59c1a8ee587f94ce9c3e6715ec3950a369fa2e17a26d48217b527b5babc359369965620b25f9464eda11a5614f063ec40ba32a4c10ecc37c06eac59fa4b83dd4c76f87cb6e401df9d6c33f56e0ac3d3fb1cffa416be2f45914e6545d48a5832abc202b74f5a490ce3d9a678fa8d3576cee61109b4d22cb3b963e4ffbf464d05ad2541ffa2a731f24cd37e174daaaed7f8106e30e20a41dd00fc8e5d928f2604177ced00b4f610e56e1a271668fcf0f1f87aa4a1ff10d29b3adfbfae48b595fd9625f677962f1cb047f8dd68489fb7961358ec7c02e2063bbdc92e68eda7eaa696cb87952300e4122dc8bc32bca41836356f4e2b833ddc67d9be5715cc1b9e3f33828fdd5a20d4d168860533be16164db2bb7d865c423a9192f60afa52b631e4d89a14b6c816d327375f619e31db6111019c550b6c704be64a951f0b4de115ba1a2b35d475dcbd0cc61a66ad6b412c05bfa11b44af020a3b9d3e1e284ea450b9cea39345a1e2f66fdad4fa180b370652047b1bd9ba975d34ec1a0ff024da4194537b4f69c3c40ffed607b02e62432e4120eece5f7e3595ebb8ed74c89e20c1853d325c9f6329c10adb58a258e187ccdf91fbae3b3cfba694dfe28673fb8cb37130847d291fe65391ed9845ea2878bf2a5e273f745b20b048c4a9de3cdb50ef0feb052e17d88f92fd3267c2285adc540294e1f2b680890b8b67df7e6d46534951a94deff8a468326344d2f3b656f6178da1cabb4014a2b56ac5b72c066f44cc70bb51fef61c58ddeae2929cdd56c1cf69dbb0c215a76e07127bc6eddb8de4583d853e9d50a92c5926677ca51d5eaa000927b837f7e8327008d8b61fe98c261356398ab629ad8d5b273c4a3461054c502eab228eb4a4003fbdb55ae59eceb8a3e3cbb730616c897f13375c7e70137074658943b2cd4d40ad76975814c5bd7f2cf6035e0f25f6b559959c825a221e516ed7e36bcca3354c3afd89773cfba28f8778080d05c64dc59a3aa430dd7119f3c39c5b0690dd9bff33a2cde7b14c7bacf7122d1cd0a24b8210650d208a77b2a541ec9dd32f3d522fc7b255af7f847a150d7488701fb0e065ffc7529f64e8fee04302ec753471d8f764f0673497dd6cb08ece853da010be523b5f1e789aa0cd4048e23a33dc48fef24e21afe4a2bda48e1d543fa6f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
