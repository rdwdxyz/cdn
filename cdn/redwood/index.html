<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"75d55dce733c13bb2b04ae0e479cdf8dbf7ae218e9062a5b51c5e3dbb8f229e724758ce44dc6d626dd76c9a5d1d90c6895406d4b66e2f17177e9c7f93931238f5249fa7cd2f3883132a10c5cedb7340ba3321063b3ca799f774195a8f26940a3d38f99fc30cbee94a2af846045a12fc273caf4980c4395bc363218cb4bd28fd3dfacf9532beda368eee2e5cae6d65b586ba9c0296e70b087638d30e9b7f7410727083b4d1fe07efcb73897d46cb2a29793e22fd2d638fe36ca66e6cb995fc414ab0539fcedc281b86d2d1a29bf777b3c649893d8fe115767f02a53d21227e8afa3dbd2fbc18637e654c7c7095f157f1a61e8664b28a38b7e98fbd4e6dc072fd695ec7be0fb67f3d083db69b1a77be11760224be005466ae367c4f0cc1a279421de8326ea27222afc81dd26ffd9d2ac40618b5dab11cdfe6fb3b50846b657de6f5c31ca9d48bf861f40d25c99790dee7f4db8ce7db3eca370cadbce8ae2f16ec101b6d854eb67e49bc722c486e50ed665944dd9697638bfdcaec810c8e022b5131367bdc079352ebac2feaebdd01a5058646551bbea7f0c8c3fd7074a69999da575e63c3e56230292e404f72e4acbc01b5f90efec2e1d78560bec3c335f58cba535d15a27b5f953049ca261e7d6d0179c7497253f494bc20f6eb85ce40503b1f6dc0f4158f67124f83eeeb55590c38aaf61d77a67393c0c5ba7f622f6403fc8a42c0c63a645dda85f65ae0a2720a1dd859cb206863d4749a194beb98e46e45205b092071ff8e32352042bcf103d8701fd54162f51c988383fe7ca9b53ae0bb3f05c3b4217ec43fa57e2a29068ea64e01baba1fab844e0de151a499e3f781bda90db38a46ea4e6b2b9a030431b7cd5483e268416130ac75786142c8ea306ae5c3b8080944f3f6dd3ffca1cc10da700853b96274494bb8ab97cbb474f1a2b0e735144bff9d5e4014f702a01703d960b37bcc0136d458be4e856a3d5518ff84c07e68adf20bda55bb32057737b64a37a892d56afb44a7e78c3b1cb98311939fa7feddc0dfaa7e795d829edc24ba607e1faffe0790a946ae7ecf5ff1ab1804317a8eb07bf5e4baa2b23ff5202f2c44877dbf6bdf604754b96f3b57e5d7a103b8f425922cf65ca8c7909f4fdd54bf507e4f94453f6e508a3b74503dcae69932fb153d475c2f1ea24d96804abefc34f37cc7f9541592952dcaa3ca0a82ed02a9621668a16e5d964d71d8ba1c17b74a76dc7139da2d4cb1bcd5324bdde8b7193003cc158c257ef33d88a6dee84883a3e8eb0aef620dba14214e109a1d3bbb30fbdb40246186baf2426352f4e98329c474ddbcfdc6081e78bf30113d5234d5f574b53defb68daace211923cb1cb3049926c4751cedcd1d88022a0b5fe8d16db25a363b5f8993c64af77d4d99f375cb6453080c00fb12ed23de10b35e5758dc24c71daa61fcf5a2bbfc025e296b76ac9b1fd863267e7f323359182607a5c1251e733ed37585d396fb5f17f183b94a3f59c0c4eaa09ec63844f9dcf753f3ce13cd5640009adb6994504781169b3444f9a38d33609ba1ac158de84f5c56505b31cb5e5d8186a71edc3391f67390df8652211a9c5fb0f8776bf0413faaed426f13386852241e5e092fc1bc911a08d2cb14da083e9d3db8e81e8d617f0b307f5d62c3936c5720cbf742a916e0ac54102bf253915ef6f48e5112b5bd11ae866e9e5ad1c5be974b891749013e42131bee5b3901c43fee90f01a5346a918dc8e43960fdffb1d50bd687018affccc8d9264d666dcf8f70a4afe9b88ca0f0ea2c90e30c40a2fd1e350e21dc84e1c517a35350214ca09ff991e03699efdb771ade7c15ca85a43921725ad3932d5711e42726e3a7c70cccd2d08b80488408cd105b501d310cceeab735364837cc5486d00a897525108ae1ea9ebdedb1d31ab66e64b26e28e8f93b386898e523540b47b8d4ca5871ed29f0ab25412f0ba9b28b3b561329a47b4433f79930d9ab80cc1ff4e754433e7ed34727a2a1373564f0e8f9bd59152566ca0a5b9b333f31598bf5b2722003704820ef0d23e6608fa2b5bc4c2355f048f7440f0050622c9ae1dbcd58635fc9b5451cc4d21748cf2d383a11cca47a9f739fec6f747c0d6b8c527c3c27c66f974d75261ed2e79bd43c72bca919611035097558faf0bf8357e189e8df3df77fc1d1fa4c57cce0324e4764f202dcc87e8a3ebf8cdca545e883b6a9c824455381dfbbc34e4f62d47bc8695a1e27fc07e3535960a1ec71c643f4140f039c2905dfaac38bf3d4fdf3b996a66dc57824e1efbc6845c34788b1c3928b733963a1343d461bc57fc1a27a666fc8f1b75fff2ec16cc126036c758df27f9a898e98eeff2cf67933fddead71578c8b42075491070b0d9d5259ab40b8a38af209b18e76fa07e25bea193567c611ff4e234c56ed32ff2b536c55f0b3b9e032da4fdec7c0cb25a264c7cbe11e9665b4bc1d39ebcfe7ee9c0e1388e24ea77c512ca387c306a855b0d2bc5047c14def938c4a31b497db9cd7bb8c0527565c8b2b5511d7964dc462c93fd61cac4b4c8a4e80b54d75b9795d3a5a8701fb830dfccddaa422ad207336bfb635cc3b9223ccc814d93d8db5a9b78a0601dbea216a41269bc8e11bf32a99e62f7a64f8bb0ecd08707c68749838478c9b8f9cda3bc1c832c61b7ea5d47c3adba377063a3ab5e9e4298191d64addac16f2203069f5253eafa98f93c055c121c835e2efe86bc9a707d5b40364eef8970388af51527c10d0a826628adcfbca653e2b11d97fae8155daf144660728125893284ce094e8e7e69daa45aed59a778b2e92532f12c437fba0d1459cc781803462561297890c6814c6e769ed69889f694b5c72738aa1485dada53cd904f83b264ac9d069b0b2812161f1cbd5aa28490e94b05b6c53a8ff925097b5695cd2cf3245a872a96003e72dbaba261c825ccf5977c4e631f1941cf8c579e79ec51d9d2c4afe512e5458412940b842f20f62a9e4489296a3b31a1622e9f03c5267ee142e774e5be786c564a61c8479612779cd32e7aaf9e2341d6d394bf98283c0c1c0282036c1cc52b0e6c8bb465a8a3c590426d321ffffd3ab967c6e4c322743bc12458667576c6b93a8bdf9a76a43300d5810630ea65a1518e8389cb66a2051728292a011efd3beb869c257e81fc92d8f012fe6d25fe14992ae6b853e1db1795388b2394dacf1deec1a67b0e8eb84e706e8e51f4e21a946c188c2462ceb61462995ac1c90b2f4d0d183c2e4c4464369af6d94bbcaef524a62b04e80fe892fec7669a5cecf4a1f5a1d0875d93168ec7a22db7f9a5fcf35ac2c369b45a12e74fc77d41cf26f670bfd466ce8c11bc2c3cfe11d068586efcf11a6d552fb47834cde21173caabf2feba265811912da63133d4b130290ce87ea05a1fbc2a7728f9c504e697b2f449a1b53c428033d5b7f58a4160999ce93704f2015d5f133f692e417bbd3aee88877f73ac31836e734da22c776f35577b75b03d6f6e0a3ce2e47a688eddd8c3f1f61a2d7a3b350846a9586cc92cb63545e880449ef6c5b7ec1a613f91fe2ce640f754c0b804a9fee0030438bcba6024d3cc748beece6726008ae7870cb0742f126a91e92599be400e73323644b733f9e9d5953efd676e16d035c8435200cad507a67d950d4bf5f96b2b04d1460198fdc4114e83669fc7445acc88d4c0d87f3a05f9186170778b2faf47fa2f064248fe85d83ddf48930470c5bcaabf1e45661580fb713d4f8ab21d163c7ad9c6094dc6b71584d16107536bf8081c20f13d7243cc6ec74079db8f38d5b1d51789ed9886551a551355eb0b0e366ac55666e5230a23ca8237ed4466304abe7def9c880619c71c43fde0ec64973124fc1118816634e1630111c93bf22ea68e1f715420c8943dcb7b0eedf43426b66d9a3502531a659f2db4cea44a160c55a19d3b19e752a9117f52ebfb278b8b4cb6c0f692e04eed8f8e5f87426883a3accf9875dda16220dbfdf3a0bfc9b72b2c189fc478e5f3275887bc8de5980de0ae1452e4f2248929c675f96d9dec236de0a479b06eeb0be96d61aaaccb64a306fbb9650b53a1e2b4322cd26cb272e22c995d3fc6e7c9809d8bffd29581c61d9516c3c6010e87608a18a7a04aa984dd39683d7c62ba8dfc5f5914b3fb8d32f37340d4f1cb10417d975fb3f3870e5f1f606aa2a9ee00c5bc40b41fef459a4ffd32312268a22e1a93096db0b0f3b600427d8a79fed9ab353503eaeb4ed2a6bfb134aa1a99472de82aed0fc2b10d268e02f58216a545c9630e6603114e7b9c7afddaefa73773de0f46fe3ca4ab731b6c0e80c0c80706ed752707fad71adcc9c063de775f40da2cbd9e465e89541b2150d74d6a7b98d42ec420045dd65efc528cf2e497d018968ce54efcbe16512f797b994d058a58330bb022ade3d38b253ac354cbd8e187f5c7dc07906f45a7847bdeed5dca76edb249d5ca27df1b8effcef2e67d95e5acd9401803c5aa414be80675a3ea2f2079396cd9647850263ff7abc0b6d0baf7744b8ff7545dbf724fc6ee0c1b629bcbd6a2282022bf16c4c60017c3479802520bef9c2e5c3c74434f74df50c891e1f215e3034594893587358c26cd8a063b9119a24d211eb5ec949b2a37430bfd885d695e0a6fbbed4b260611c877cfc8da7b87299189812ef9e6c9e4fef7601d01307f7d2ac3d6357d7621c6297e3af5af5b77f42204bb4ae63efec72af58969f7531bf81ad109dc074bdfcc0911ed1a355e32e98a1698e34ab8f1142f4f1ac8b00c539bda7d24e85d35755f2ef02662c167f8f86df0667cc8afb4aee80c889e0c91dbf2543f69fe754c91345d0426100c56bc11c6d8d48b367048790ff11563c1ed5a9c3ef4f761f35278c6b0e6adc762f45f1a2c840655374d313a7a95383011fa7704470115300bf4c1fde611248f589727d84507d35dbca9b9c6ab9e23a8435194a63d4222ae0ed529746288bb3463212919cccca6f77534fa2d2bc9ec99138117723f43c8665ee11d9dac03b31a32a34cd15cd5f93d87ee4f0e0401bffb6dcf32f8b3b2eab0e789e01ad9da5226e03afc9911538caa8378786254a53eedfcd1aa56bb846406f09e33cd94a23f473cb35f7f639bb5653df4ff363b6eef487ed477fc4e3dfe4fc090386462c40469668553a2eadf7b4fceacf790dc21d957efa23b4df4996fdba560496d475688ed56397e03fb9cec4bec9d3545326b7c576c0a161876a2540a32c2674cbbf28ad4ea2e0286777c2eaf7641124f06556f74cff256510190b151462108ce2dc2ed8381509c6173799abea37bd1265bb345d2c884673052efe38e6b8cb1c541e0ae3c5703d168e26bb843256c2d72caa0a7ea8d0e60e0b695e70437ee17d6f8768866c7cdd9756f480e08ae350390e6c5de463372ee30a42b23728d48098a19d760bcb0bf4db15c2683c24ef3a9b15fdf35a1337cff544863335ed05c7353c55f96fe633af834be2687fe06212b1c7422e14404837ea53cd52f039387971bd0036a9e5135ebc704e8ee2a7a3e82131f3447e2edb4c8628bcebf47d35105a469f0199cbaeadcc60ef231978e870071558595e5d2d8c0604fb5bf3261ccf8d4bbd215af91730b1e605df28ee98ea3fabb5fc7d8b4e51ed23cc770187793f92179c765d575d0b551b549aa1195d0ff36c8e2affcc1ef91c2bbe78aa1de2ced4779c12aa7f6c93d470e74aa734d34b89c7fb739ca3f5ae073438830623112ede42dafde4fc47f56a6b764bc0170ac97c16cc75302dc529d2f59268f955a694179f924870443de3012ea88fe5f51c9f37b4dce53d66e06e213422a0710495fb663cd18c60a82f6d190619fead7ca0efcdf0b3d834037cb7aa8f5bfd134672539fbc6090ed48d5002fe8d109584e31d0079ccac49cfaa059774150765fc657ac2f8a0a5c95874594edf23470a4c5cc851f39a84a9e11e3e574f256c354986954250f269429b83297ff164d9186904a8bb325535afc87f209eb56f28458a46cad7d95d6fe9dcf674d04bb7642111e63735b323a05c1480e65f6f884448f5f3927c8a57bce16bfe17bd1d58269b1ca59bacadef35fad14807679b1a52cd63002b742cfc3525ac16b89253b72edb1c1e7ccee9a2f9365457edb13ac7d8a1133d44c79330acc99c8369121d22fcdfea1d4c475398bcec39b6e9263ca797762f52d3634ab601904eed807e9bafee6d1ebd61a606e587407acc51c4c7ef173aacc810e4482a75fb0fa20cdcce80732b374eab8f4efe2b96146f80789ff71ae0713d3f113cfffbc60c95c08fb0064f04b9bf29fd1e5f42efc9a624f95538320ae60b4a08c63fcee2708d2b673e9d534bcc3f9270f3f71e2f1a75f9e1047fe54df44a3031e06303fdbd5cbe194272ad36824aa5b39815acae36ae82a1d32ddaf8e9600f078ee9296d0da16b3deb29ccb52a47cd6b0f6dbca1baa396e136a16d4323373e410b939f170ad4f83611233a558a50501c1111a2f9579e87170182aff47cb226f2e77057d5931ae2dad96dc8974faca21781a8ef8b047f59efe6e377e39436a2143ef0c0399d56bae37f209328a472ed00ea71a863695c7e3f1ab8e261442043a7cdc3821f94cc12d7df89223f930dfba8ab35da758466adf17c90ed48f2f00195103a85d5fa7bf6a44e2c527b77e2f840de88ac45d49f5e950b8cb943bbbe58418df05283ab3b5722781f6750b1e871439574bbf2d1a23aba0ca9391022ab3aa0b6c2865746bb8638061889e22b8741481f41e8697ed56639a5aefefb689d004ddd0666c6cde684689a98aab727cf0e5307d2d0be31df4192e5981da5732fa8a23f631bf7ba6f50f7fb5d43960e79049867a3dd6cbad14ef6bb279b9818179e510a6a4dc07be018fc8d5df9f02e56345d6a185eda555da089701f7506f101b622d33089df30c55ff259ecc75e0cab62bfa366ca21a130807f5991958d76240bc204fa88985f20a2d9c97288cad151d1bcdb337f3916aef5ed6e3e0e643036a0c999a858fb5a64d96aa1d65e80376ac2cf19f723b6a1cde5a461bdb7f6742a4b18b153896162913378c9a1c118edecd376b99c5f1d72d544cf1bdbcd0864039952674f103b660938a5cd94262daf09f45502da367f10344d9272f2713c28057211f13e41201b382fab90a8a8bb7f2cba2e39cac8e93b060c5e40eca4791f8772b435aa3b48888a044831607f8d02cb86b6eba6650678ef1acbebb383addd37efe11fe8eb74a8f835eecb92c5c26c4aac8c4272c03697b18dc4871cbba021b20069988baed3fd1eb58d8309b75eba9d7b6339ac80a9ef7a5bbb3f58ee23c91601330e22d0cf518aba59e51eb9b4a297c3dce3888056aad6c75a16276891adf24e0267eadff5dad33ac8fe698138651481277dc06724ba1a02cec73b11376df92022e796fdbdbda386b050803fc462dd070812eafc1528046890dd56c7295b98a05a371df7ffbe6ddb11e3c76b8a93b9702dc32ad227191c402acab8b3d463e335ebf012a1145fb76377dc7217104e2bb2694e28afee9e5de998162488f2dd1e9f4563398afbd2a260d9aba84194313f66357709c11ec81e9c872676eab4e144b211423c7cd04c031123aa6f0f82b97761f183bfe56abe8dfe656cef853ec5c0b992a90b176e31a60544fbcae78187799912f4f82f41afa53aae54f9a04b1fcafa3f007c20817b2bead6bd4954f8b2b81f11067dbabc7385eeb14b7b865be3739b4e73b1f6a7b1adbb5bfbf1b1daa22e1335f7445147047a48a6c1429992a46dc7d26a7f315c8e7c97f27004c6b55f560f6ddfb168ccbd178c60dee1daf5d55913b4ce22a909837e2e94b1bcca756b54ec84bb8a046b60e21886f56000fd8d497c7900198ba7eda43a2e7a845fc7bc6c61091814a987c1f3f03c17ec5d7eeb9256551acc3589d81d11c211e43d79a7896a762c3c5c3ed384198b9afca2ba1cc46e8c3d7375743369fbca793644af8a39f19e0ef60cc239d854d46b6a3d808495f8c8a92164f501df5165d6f0cbf4b0f0751f3495c3e79296d64a9951a64d13b4595d745e35f52e9d8ea0a83f9c63ebfea82644879775af72e569adc7dee661cbb7ab234d2e6845bbe06e0c846720595d125ba1a4b1158face9cf651e1ea04e2f0a2e6fe006a57c4c0bd044fba7f1cfb8411c43c40db5a4f5ab780521c5a8519a5a41d797b86605c6a0a5298edaa424b5427022e7eced76314711c9c7be3165103164a862fff4a662796fea830eb79c94792c6e93c24c719ee8661c56928141c2f7a81c698d67fd23a009787ba80447725be150ea5637ce66f966b71d28761f0b986b3f739dc5f0631e8229ddd23c4b0df6c5ffd853ffd50533e09fea7f0a625fc91386e859d65102b487308b6b6170823674a4038b3c8180051d47b6fee2963ff57990c022f185a2bfa165020843882b79f03faea6ce56a8eacec44d3ff6076ae9fd743b2032e1f9bb287f1b31a97f9e6403c667318646ad68ad4527d491b178d6bab87b227d8c0462fdcd6e87d469dd56810cbb7aa422895199f33e46c1eecadbfeccdc066cd3f31535df21eee863e50a7b9f0d7e4d871c97a9de648b21589b58510e9d8b6a1e1a4146e0896a4eb674a49729178008529526f77b6b2658f8b4dcaa7fb6e04e610cbb942f1301f60cda1e5c3e19fb2aa70f7d6d2e1a12a4623a25b065655f5efd40a524d782cd643dc0a6addbb97eb705ba775ef848df3f02d930fe6c41755c0578437b86ef3ade4848c4fff5c9c824634ac28319370da6726d482340aee4883b8461a20b5a63e56d0b81feced752887078f1a5657ad7d55d55a38a134d649b153b41e524d009177ce03a366a5f61c8418357ca7503c19fba1596ba0c5e916531a8d64b254439370c90e110dc5c4da85bfed4114b6859ceb73042ba33586fc9081b84339979024d64b953a85e8a9327f9ffcaef744ec54f35ed180fb4df7b1d22878235c013f1de1d1a5afe16935cb7a035f631fe85ff704781f04dd77826b613fe7754333c3694ef8db2a7c1bc969f20a2450685f9eaa650ba5c3efb1a85932341b5eb7e8cd1206575809a39d831fbc1ad19e61f78849349c5678be0cbf495586125089b1764ae91155545932c5c99cff9d6013de0d745a73d37974d7f6e129720160df4ee8804e18ad1025e21a9167c776cfea38662f038710cb387c180997088485d125e1db0eb29dbc69f1b5fefc5c80c1e5396d3dc02918e33c7a084426262b0bdd97fb1c99ca6d6431ccccfed0cdeb772978729e9772ac31c0e88defc8c10dd8c18c802fcf925fb2aab8180b16853596de7d36e420e5b2cf03dd929bec1e9ccfda22ddd561784ff4bd6683767bf3a00fed6d738104491a4261f8e46cfdfa27092fa2bc5e7a81ffea499f1dc318ba6e303a279816628d7eddc5e97a904db8276800da98741a5747d4dae673d64afa8cf1d50556bd173006a991601b457e8b261bbdc54706ea2c5895cd27b59cadfce31e1af1dfff54233b7adbf3924589e4196ea3aba1d1e3056ab431d0495c192e8ebd921ed0016f1b23456e2e501348e39be773d96d978bfe96ecc1ae3787a0a2335e14a2a2c1b50b9b5d5857f34a1213e2d475ea0cc8ccd2d2360e6cfe7f186da31e7b793f7cc0461f25cd8faf98ebf28064326696607c7716e2445b6b36bba31f466bcc9954a741c4b45aaf4e405d6560e59ca8d31b1d645c5e7f24163c53353d6f4614090d8bdd7d9997f9f347c0310bd39b684e00d3b7e26fc4727b31263ffb70db52407f32dcaa2642703ab6fb070f9a2ec5db84f72e6bb073c0b8e266c66772da01f7e1c7b14e51e96151da7ff327007def185f94383aa8f7093d5e03c41dae1a361a1547d181204a9d6df7d893d251541537017af01016de8960d44796a70060ac1f39d05f4faff292de73d4d0a61ef53d1efde91415efb99f33238f6362ebe49b7c4edb7bfa4c7d338637733f4ba2a5fbb1cadce065b3eb5d84022e23b8f72d6e31de9fbbc018e378e000bb7f6efe111bddc0684b948f06513c6d42f3cc38ab58df369888071744cd0c35dcfde6a3a24a36ab7bbbdf08635277eaaf0557c087faa9e802b97b311bc00fb7089e17d912122aa6708e88b2bee53d8203cf92316ef6a2d13d6d324fc8e3b5159f96cb295de86571b59614286ec7fe25ade3c037c3f7cd803f73b9e206826e28db031ff3e01a37c5ba630fd76d4223f94b8c9fdb4e2bba2b4eced9fb2188abc44f9066788bb1ae96d40cb899ae1bbf525050fb490d7f17758ce9830af095c0b236fbca8d0982a6fa3f9ba3b19870ff1653480551a13b37122a6c3a3e8b575644b778eddead7cb6dca6835a78ba569a10458cb4886733297d3a660857903142c4c4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
