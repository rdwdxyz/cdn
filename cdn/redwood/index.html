<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6fa9573e0daf7afa6aee0946337b5188491925d9a2512b78372cb82d4107e947e9c3e2dcc471b21ffb5223581d73d569ff354881e63f02bdd47dac529a48bdfc7681301f79362a3190dd85660d46c287658856a070c5cd62d0691f89cf84d49521409924362c42edd38472918c7b6cb6e2b6e3ab2f64d55638cc56326d5b652d36507963fa25eade1b4aa58164b7b339605ba3724d2891ed95dfe92be977d438e35d65baa2d65db94522d65e523cff2c8950fc8378c7d6cc3dbb2c6ae6a788cf0580aeb3adb3706d5ae992f6d21ccd0ae8406f3126d191a5d957bd53ad51c04584ece2d0b4ff352fdd4f223d3f2d71948b378985d53b849c41c963d215bca6c7f7646d51f7215937dd0fb3bce3ee7572daf0b8398da8183ed84779e436f8aaa226f41ff1295904d10b92eda852ff1a762d0d4b5ce8fbd057fcd409416d12f9ebdbf1fa0a7054fa9d2e41b04b913fa49305977c3998609e77b7bf76fd591ae32da82859c10329056bc4e36effab63339d1bbdf0a17670fdb00a2687d97cfda279166da6f58b9c146286b5ae9af03ba93c6dc89022cebfcb91c9f87461995a40d97ca9f24302c21f36f2b3dd7c9ba2544c9c7325a2ce76b9643e54cf0e11a78e2a23466b1baed8a6ece070f9d1712c5a28e642a83ae6990bd4bd4032ca6d4822d206d0fd98fa8b1f7a7772ae4e33d2138700765a6e1fef5eeb3d40b16477d56b86f48f663ba681c09149ac62d9b80e011af582fccdabcb4681f2c654228a619fe38990ffca8624629dfa143cb346dc7478680dbadbf0ba4129175c34f24996829b333912a5f3ccf19a34036479d9c41e480ba242da49a8a381e1b477ac07304be841d14e9a64ae9fac81e0344d1c13e893383d8605a062e364036f49e608db1f8c53ec34df2613cd2aaef7d09dae6b34f861f0925bcb1f003d214d39263845b8eb24197b968c99562fc409dbd5879e55142cd533fd3980558af143619fe32446919ab00e46d209b5e46f72b3c2c7dbb0c731669a1d35dfc2cc77b33e22cc4e0b1dd4e905e68378acd82ba0bef850f2edb54a177f7d67b0d54cc95562db4b17779ec011a260abf2b1fa661854ab259c0f8077af9cce923cc39140785efb7e0e06be328f52a70509d47e50e7cb1cb286e9a8b92a4de21d14734b8569668134007790592e0c56cec3d65ef583a2b8089e086a540aba16cba14dc86f5034f3ddae1535f11220e58f7909f31a122799222c2077a6ec8f1cb070ee7d3e82a8a65ee9e6579b5eaa0e659e0f20386a8dbee5216c1e417bab01f897ac26b9f9ed63e2f22a85a48d77c73b01df5dd1ce12ede7c4e948ade8951ac7fea2c24b56bfcea1a66aadd5ad34fed8439b531991e66b974aa5d34289d32b1145f1c37acd449ebb0e2e49869a6b02ec98ea0ffe31c704d25ad2fcac045fd3e9331702c670f1bdccab8cedfefc2261ba61e97b025df858b309a85bf8d4a047a2dfc8d6a8873cd110d3ddd6053dfb3b8cc0216e36af517dae5065dfa8b6980eba049983791796580d40e4a1bdbba71b4c4200e4a352540866169cd4d821807750eef5d4c03fc005ca090e9e388c41fbff1e24ebb096fc7ce179ec5b4b1141fe369ddd8c9bb8a99a06106caeec042f01be7b9ea62498fbd2bbb70cd0753d955cf2fada23b64ad47217d0e06b1c29c4e10f2324441869fe89375ba44593834ff167a17f3bef80287c3bbae28c20c0934ae650767c90aa79e417502f04e1c51f2e0bcf97197b34df27a2e5c1e221b8925498f2d94496c1c7afb32b2e7e82da332c165544906a73f40272d3c1da489a9b7f3ab858432ed1fe69a01950e9cbc3140c32872301998baaeb6ceaee438342cf60bd80af4e2fa997040f4137ec5386d93060e2a2b9bd65aa0c551e9ef3358f8d20a37a391da19db5b7873e511de019d2cfc3c864ba3b6ed831c57431133e4ac7fe04c032c05e083ba5704472ccf14767a36b1c78bf236df1648fb07b718583234f33f538770f703528be0d7f75f11c8558630bb0ffc1b73cff4e6c54a1da4d1a946e7a599579c9f184c391ca0569cdc87a0af4a7a8c8db1da74b979b065d0f749219a55fcae28088793d453e8360585876a873649cb85d9c02c788cd600be4d6f1fa9c53bb0f11504e4c328f2591b971cd7a208a065527fb9168fb2fd27ed79812f754e168e86a5b1afb27ab0759a8187c41e4fd389bb0f297f0da4c4dd308268e56017d0365d6617b2822357f2b1093e20404cdf31d75f198608441a7cccfbe5f51e2baf1d3df424de47221f13a7950a78cd7270f621344415474eb89ab749065043e7d2f8c046cc490338e32dbf4872401d35bbccb2cc0a82afcb70a986be2d8b520298fdbcb4afaaea6ad163b2aa110c308c9cc5eeccc12cd3199bb9e434053067da59cf29791fce9be78a6f07fcc3f3ab1bed12d6bcbaec32c9691011eb8cc06d4a4a1cda8f7a1a779ccac974f7c9c05f9fc358bc31bfff8c920c21280ff65ae05666467c48595f01e8e5670db3f71e911885d5384be801973757dbbc3030e274157c16f944d5cfc918f903a049889bcd68a43e03409d08966ef947327df46d2e957044a809837fdbcd64d9bc19859cb699b45f352954d9deb50a2e39fec83556efa303f1c30819b275e773a734c477aea122b7f9d28844c83d9a59c68de570422d87805329599a10bb0b7b5a9ea3870e63a2ad1257292383138b0f3a8c01d101fea022d3dd08013a78dc384621745cff535513c768afd8502dddfdebdc68015d9e5c493423c15f19cb691602c6d6764971e8d9e34d1b02fc1b6c37f4d28f0cec429c6d87df28f427713fa4f6627bd5ba6dba2cce67839a64034773ab08412cb8a6ec6ac8d0c0140c3ddc3aba10d1f7aa1776f052ba9087592bd9c93b7e7d94313b1236a2568511e49568265d163d065b8edca727829360a8c76af8b6be795e08f26739681ead9843e97b72d2407d3de1b3364b72452a314142970f948b881c265f640eaff017fd9150404545c9bda61276d82980070fb87109fa82af2da9d5dacee61c37904d52c3c25800a3c54eb67c23765b1bb7bd348d2b90326f2deac6a0ea2813035587e6d69b50ad16ace210d8c7502fc88c20e10f780943be1f742a52ea73f98f3bf488776047385cf26f214a0f058a99af340d2a5dab901442e8771f1a4ef8440969b9e348018e59ab2c75b826315fc1859006ecde542a5e95d1eae4f7878407d2a55a1871839e22360799b07c222115ee7bde282a39b4b30b2c8169a966f7e7e3101b6da49e51586f9cc2b9d1073eeee0dd8d9ebeb52fc46eff27aa8a1f751280931e7d58418c5ac913bcdae47f06577ed4c8d8baeea3fec1c126ab85306fe54da77563e4ade3bb716fc9e63779bec1e96d2f124ca816cff3d7268963fed0ca4258527ced918c6fea681961166e02ee85821c78d5c97f40bad11189e94561aaaee46911e597d56e0da79b29f978e5bc1995a48291af04f5b71efeba960c2051d34986183903ca5234b81e4ca7a8e462ff19ae3c7fcf5a124cb01167f8dd4aa3a3defbed72dc9231f1003d4b51e13294176685c9f532ee635bf9e1f70cc212efdf69d3820956ab3667708d53cc64dd489f5f6584c9358bdf681c3506d622b34c916dc2e57b6aaf37c67df23a5a15704484bb5da6a476685cc5194bc81a689984212eaa55a8ed1d94607e7ed8be15e679e5d4ca4e0ef9d6958765d8e6b447b9e6632b11e85dd6d63f6c249a0c2d971c4ec50d0eb250979a0cd043ad23b8406de60c504ecd6a7dc099710588da5295735aa8010b777b527505683fbe81e7d04af9c260ba25d90586c01fbbbb309cf10fc91dada6276de45d5bec8b92610c2a19a6d56a46d25079778450bbedb056f4fd620d9e6be1853eb376bdd009dd4199f1f950f2773b0ca39cfe615141d3f8d5459b7e61d1b3b77d7c1922aabfcda9dc0137e8fb5d863c1baa4dc7c270c5bc1dffa306dc0946c7a8cdaa462ffec178593fb00337ab0c72d90384bfbb6dcf0b684374fb65dc045f0df1bae61eff3b906f63bbef37c95ca38913a123740d157b1b518877340119e3f98ce9382fde7cea8a9839c5e5a8a8ac2f4ae52ac3d47228d1d38206f71e9a9023a35e328510571f0765f98b1fbf775b67d9638bc0eca2ea4cac61dcb0376f47dd1ca015639a5f07eb8b7280244afcec0afb44c8093f59c5066d507cd1edef904e89f6b380794d56df2dad04ac77d96aeaa45c8424d64777200d0e894b0d99713f47bcd30148581801ca9b39468902270e4d1f0813aabdb9332cfa11f48941f766d4a8c5f70b9f4b9c5d4ef5d381e7658eec2f170e1f151ee5eb72b98bfacd3e83ede499c6959b373f7c659665372ad1b4d0671ebbb98edbf0d5640ca7d718f88fe521dbefc00b68382fa0899dd87f51bbe4bba976729c32a05c9c7bbca3b7c25f30322e76d8b2a76a9ea6cd8ca821765db83087aa5341a0ffa8e917ae959e04160c911a60065ba6b2bfe096f951bfcc9477d42c85324540f3943d32bfdfa5f67cf960829ffcabb6f80aa82c47b37efea18418af3aff7825d918c31dfffc594c62df10ac343b2a7fed88e7cc81c1e3240919d003cd78e87a970ba80c52de94009017fd9ec711800178891ba158477c9561cac39dafaed6a7e6eca003f4e94cb791fb35fe74197ed69ae2f20eb8d8c708ed27d86a1d6f3d7e0c7af34187cdc39cded377be55658bc8d2bbc8ba480ddf861cef91943c5deb5e3420a01cf4119efc7c71ce6c87db815d076a586a3bbeab0734f5139523664c643bce05ecb802fd49472337a10d9a824d509a51d0176873c66b2e895ad7db21c3df679220f1c9af8682ff1747be0b20db84d4d47746038410a9dbb4bdc988a480fd0bb5d48213f75edbe8ad279aeca5d7e9d1943f91f2ba2f9c17e4cd4321d531f0a540047360b689b79a5438d19c324ac9e9e93123c04b62e50814ff48d9bb76f6ac0d124fdfbb7ab4a2d38d763308f84f596b323753ccde4fd16f1350d17a5d12687c102e70da603f5b81290610e9c92d5c56f546b0bd60e56747afad77c284fe24ed3e86845694f345ec34d9322491b9173acb4c01f1fff835f005db9be6a662c4896c20366413364ea80879fde87e39bded90d4cd477e7cf365c076de7c6365afd220d01bb9806ba7c74c04f0be5b0a2185e04fc8cbd8ef185fac74cba8bd293fdf85223c2da8041a58822d749554efa3c04d56cb0f254b1b42119dc08fb5b43bf5c9aaa45b2917882752ff4efffc39015484634ef8d257dfcb2f4bceb5f3840f09fef581eba9595b1e35cea20c64c0dd3fb8f3ec52ee75c37c965df287a2fe6e08f78ad5150da8b79979e045baf09a5c1e992119fbc5a0d3213ccb9551a5eeea3287b058d59da01b6f6ff67ad0c5404ed6302a2e5e8367bc86543e1f2e16e36942fc966497e403589fe9c22cd1b1d919cf9e653441c2d3386b3dc9a0cc0d038d5cead15d3ec7097cb296dbd27e854c76e7067c300bfc032c93368b70852254eb9c0f55d63f416ac3af2f75eb130450ae52a09ae85286388b16ff240b5062c82ea3b86021e8d6cecbfb5e823d31c78383d3fe175d2cdb5b2932059e89c2c6e5156d4c759ae351fc5e2c6fe5577ad6410fb32debb8050ebd8e816b142bf1e6840e2eff03df87dd1085de296942b7b446adf36547ae04ad0585b5c9518453abcb3e294fe7c706ff32e3be5dfd9a0461ac2d9c5ed9178428446c1f85ac29181aeffe62f30ade459389d9512c4aa73e8cf160fb3aaf5e48cd072c1c06d476aa121243198b6f6b5065ea2f2feb0d038f9467689509c24e071607c62d5a3662b4dafe0c6d943c6a8a55a7fe25dcc8f019a2e34e5cf812aba91964050a01a17b03a25acacd943922f02ecfddacd160e7571ce7cf0d2a2a65618c5cd51122b11a7e73a032b35dbf4cba6fe075b52816ce649998ce41290d730ba79aaf296c0a58ffbd209426b3271bca2c0d95f7e6aa22178c6b1c6688ef616a2a739c9eca6cd6b4afedb8576306daf1e6d09f28f816fbbb9a2b31aed1b5a5f3f4310560abe7fb6eaf278e35487882f5590961e325c5e9b05798b6b3d18acf94b72d45aad2fb132ccdefcb976fe4c2ecabae14a0c8ce569f7f22698fe20d2115b9fb7ea9174d00da87cfab7654baf451830710a1eb75474aec9172de2e8bea21ece6fb32a536fca62a7d2743a02cfbc2058877f4a8ac0aa8ce6356435b754b5877d8906c3068467226e1cf31f416108bbecc7d88270e4930eb0ed4470dab9c4eab3792f71f6c4e9185ce7af11339353a4a1927fc670ac72972784b8ad779c40751689b1b643b81c6c5a932a6ccb709b1c0d6f4c5d10ed93bfebb880bb3547315c90646746e39bc38671a6cbffd00ad56ca1e53691dd171bb5be140cbf2b4351ce8e598cd4100c1b4e45521bdbfb73cba21dac88223a560fdea29f34a17f8b233ad237aeecc1bcbf5ba659d8b324f14b4498e7d6a4fb226a048e88d0609bc79e5fe5615d004988b9385c19e301fa2b4055c21936b36c45a6931d71c43e9e4c83ee13ad6e28091494ac854eb6060d60690ab7895dcfc9736fd7f95ee29fc7e02674f267333919e92fb1d5066772bf9afd7dd8c107357f97ee7ecda3fd37d03565fadf786fda216e99c07619b2c6bddf2ac25c7500f87b11ef1a39726b43c1b70fcb10084b345f468eb0ccacb6febe48fb85f7b20580bbf12f6347edffc1349a5ea4807173c6bf5a4a9c8abd01d69b690812363ef553f19a72b26e3cde068024e6523f1f000750e9c3c7697677ce42b588cecebe622e348143cb0b8471566240bb5bd3e596bf37820caed2d55f423c3d04f70f66909092307ab98ce282ac9db21ac25d01fc5e91b46f6c536f6a7f4fe2d7735e94ba7b0d8eff72eb127ed4d731a5e81a3d18e08bb689138fa3c1127b951e10611a578587c701b45a1a0018b77bb8a4b94b40d8629297b2d73c4aab92b3624ca579a395d80c1c0b8a7851e67130b3ae7eb7252f67bae90aa25d8c733507dbef1a46a83a95e14f5267ff01513ab15cbd6e82efd6a76098446a63039e0d3bcca18904652fe64884b2f8e9b30f5f4821de897e0d59c03e34edc74875de0c446be43767d3cba6b51fef3dc4a00cece7527b201b312c7cd1e2a90967b25ab0c69eb57b1aac46187a4e1e01f9026cae23b96d39ec4069adf66b08b3d34c1eaeab8820554f2d29b3e0f0a17288479cf8fcffc11d19050c2a5679c78a3337ee56cb136db9f47ab69375b59469264b0aa74f60715ac352417fe2a59b52748b0d98b6273c60b8b1321a3ae3879dc00f6f17474df4d68e0aad0850e5069fa271490c13ba966d7e36e93b893305c310a60a9f7f3012bf618ae5382cb17202ef18f8ed470bbc4744f0817311c06509a7fcd9ec3f2bc872440679e99252ada6baca570a8c6e8c5a1ac52adc44b4b6b6695aae70dc97344cdcaa4f8719cab0e645a7542d8be3dab7602c267f81d24d375741a031b8a423f9f44a6aeeeb5acc155c09cd512fc95d37d49a4df0c967ad2396c6e3c12fb6743be4fd540d33594a94538b55ce5ca90a0ea521641984572bdf0eef9383d0cb69a649484b39be770f9ba2558b87774b835f91ad700233d57c5079fbcae72c594dd7737f8f4323f7cab015a0b95ae7e6b67c8b6f6c76e245732f522dc7f6d483d4b9db1e35d38476f34268cd5013c71a48b051de5c957e4c4622c41b1ee93f7a629d888234935eaebff031293af628278f473a0a3d80f2d43aa697288c4f6646c45b652dac5f0173232e676bc85abc4b4f6050afd1023763ebec71732817e7dabe173aec2d3fc5d3715f1b734ca8a8ad01bb9e33e0abb426fb23a217e738bc78e9b73e5b2fd166b9c4e6a605384b3215f6abc91a41f52fc16759b00edca64e4af340b8e659c5be9d1e81ae865cc1baa64330132ed5d3030ff5eeb3e00a47deef16e572e7f5b13b5ef77472be532ee48de662e90bf7d771f3a85eb876a1f00cbfcbaac5707ae93f11f25a99a7d3e3788a3003e08dd270812fab31edf0ac61c472c8ed1605f8a6d62e61b0e69698df6ee4ff462208f806514184973540dfdfc9e89b72ca9691be991396e61e447844f03e95b428db3cdb0f8cb7ca2b1bee7dd963bb62d8a8db4a7082a27be4708352921f8aa8df6d912aa8525e4bb1a920d8b95023b66e7780218fd61753565da590c5255449d510331d9ef1ddccbb86b105852a0d970d0b46989349c477adfbefeb5b71c5a3cb0292bb5304fbac826d700b80a98f4b349fe36f284d9d4f8004e42c519cac96c0c5272ba7a413842de9b521aa36e02a7afea5ee0ded3062a955d962417a95068aa5854efaf93730b6e5cd46b8b79a5ebc4a1a490c78488d1b3c6863d5b48e1bd1640d0a8e269130e1b202bdfbec97b6f6876d2c076031cb6e26cd1c7ff5c63a652d8385f58f50e6380232a6bc896d1c8fac40f6db6e21d9e566612386ba10e840a0421217e0ef9c58c8cc52c4de6719acd2fa283d36664f5922b9c7639d886416a3d572404e8f727fd7ba681a62c34bd007b6c119babaf97c9cb81c147aa692d5a1d41f5aa43d13ab150b4d7821002febe3b8fd68eaa9e7db5a03570f4b84131982fd007d2dc65ed301ffcac8483d1bca6aa91e002ed83a82840a0550d90ccd38ea071421d04546399845fc6c742311b2fdade8d739c7c7642b855ceca4443672deab7407413bfdf83e23ab053dc1e75b6b873ba09d522f0c8910abcc51d7ead9663465a5fa381d20b490a73ac699e36943fcacca568cf758a9071cd26506bbdc914d7bb606f89a19bbf43d8277b82ab16beb9f958486f7c547bd13a23cbe03056ff8ae9e0293e00bce90659b72d75569a77f620270223bba4b18e738c85a87cc3c44937a541516fd90e16a34b2dd0fee8e9d8b5e5620b749bddb49c86b1a6a086252588c1d1cd53d2d3323115181b79c9eca644ff8163a3348658e8c62a8a90ae33fc4ace5b091407d7f007bc8a17ad74c66c43387084939f5ff104e36c71f8d65f5b11e9f376853b1cc38532cb7be4f4056538e482cc990472eed9713d1eb3449117e4c724983a93495a39cbaf9e9f205b1a03c42136689de168b3c947e672353e62c3a1a78aac6352e108e195792c110da1d67898e115844e048fb4bbd82a05e65ff2e6163e4cf29e4f9f21e098c67d5d7d78a136afe0eaadc32863c7f76bd5d0bff2297e6d912a5296e814d5e0ccf6ff92d5be4f1d8e41289933e09b09a7499cd9af0624db24e75571763b9ab8a18d72c7b4159119b6b44da89c2f2514e02a09a65000196f12ddc1a7e9c4582a9f1c3f9a45a2a16c6a50df42f0e809f1be100808318ee6c5c1d19123b3a225ef8a345e9f139e03e7f91385bb6e339422cf83dcd769a83b14e583469f05d1c7f2d6fc924bb2d6507c74afa86cfdad24b97e0111a6b4d738d4918bf2c15c5f8502f1903c826f021854af7f219cbf1b6184126abd14609ce5ac1643535b3ae39f31db74172cdd9bbe7b7148b076cb670b8375c98642bee8128a0bf9ba8bf4035251bfa5d7ccac1df69e37e71ed59e1b24ce09b464ec3b71b1d5d19012339130b1d2655fe5bb97d171f6e9d046022a7442bb3062417bf897c51a42f7cc359716c66a7f9a197e7b8d5ce9f0d6daba5666f949453a8071d5418023e9db7dda7006bd861fbdba40032c8fe18ef6b477c899099f403403f0750dac3c0cb33eb04cb5b64bd4a564f44e56e90584bc4a8cb89e77b75225a61fa5199ae7403093c96dc8d43580570904d2a828a91daef6e41e61d564f8dde06b4ac8b06914dd8592199f11817c63ca05db6f51823d9b79a7b906315a9c99738ec6d7175cd5f5c6f67c717c8896ac277b2f121159ccc9e220a6b97fe0356bcf1fdce96bd9557b6594616a770a4307eb9266cc0a9b3992d6e32ba43ff0811033fb9097314cd3315aec8345ad38cccdf594a13c88eb3430fd967d2db206f24babf8b131cad58ed84b228d7c020a683e8f17a08097953bd281cf72a9e1f7b693f63877c3972b4d39aa2f04ac51cb7ae07991840e7b8603abfc19e587dbf6451f82fc1c58667fe8c503087c5acef2a5bbb2305b1ba0e5c50da22800ac15179bcf8939bfd146ef3ebb049483d4efe47040bbe7437f233a1dceb307654f7e282244548ee127576b1a129c86c2ea950d498fdbea12857e6c11b2ed494ce6a35486963afbbc03d88bbec94461d49e14b00bcff0d9db7e83fb0b0d1b075a7983686a2e33fb30671905c3a18186c59beb1264e35670866bd1f526349c5a510867465be67cef2676268b66d4441468d1f87bad183eb2413841e1d3ba5ca0272c00b2abb660e9d6e14a24155d2257f75346e3a3f4b795dec5c51431d23e2368151f3599f1ba2a39f9ff18d22655650fa051b775178cf773a0aaaa97ad609aed7d5f72a40cfc7657ea9860a05cbc2bc8af2498c37f73fd40f592513c56321288e83bc1c8f0a7bd50996d3b7bcf6ece11193da3d488d82d92e88a7d0736b1b838f48d2b4b74e9a87d66cfb1e90d9f639c3c4c792be04cf2e6350e7a193d51e3a3aeb6bae04f9c1b80a95073769810df485b53cecca8d9f2d801fd5b1a87090637931b8a43615b6b7bf7c2ec9e07e7ebe1bb3ef3581bc1224007344958318b0f9ce917e1801a572bb155bc96ef50e0e04b584ba28f3ef6160635188c4815ed12af02a818d8f8a1421a5cb5f8dbb99e09cf4600ad368c5c2e9de03cfb39c810e36f7fb56f62c730fda87aa44b4bd430eb9a77931136533ffcdd8d2c76099ec9f1180316474a0919c126e958953bb863ab1ba37a250c83e5c7f36dec234b3edf4c96cb0b5bcebcd27ebf421b2cd40270a8ae501d55b5c46e0a5c99ec6b0c8763884495f559480341211a43235dc18bcc28ab4daf3beaac67e7cb5566e3ba5c70057ecae3b395f89b08255cdd419d338507526504741b94be02a5bd396468562bf14786ed1d6670f4b02dfb00d291ae7561f9f7d81ab72fe2b19c10dc3a5614e7e97aed9ae16c3a1f4271fbd0b960f3f161804dbc707457ed0341632ffbfdb1e5f05f175c560b5d80d25e4d050dd51d8c3ba8ad9ae58ae5c574aa6a380cc057b2535d6150f780b17436b13b0e51f39bb7ed8ff96651e8754845d7ef9ff0fd9e707d127c3ac5fb9e9fbac9b67e075f6bd56df2774201d8c71b0d4f07ad73e3ee4cb498fa601c5986c455d9e30e9c4dd56854630748b718e235a94b246b73d479895bd93de0153be0dde5b1fb96a18dde2b24cf1774eab813e17294164edbb25beefe388be844f818d8369fabffb4c0db9282c6897f22209b7a9d330d7cbf81803f9166d4d3d08768a7f00b379683ff084ec9104e8f05e3188d75c68b31af56d061474f1dd81cffd146e2c40a1fe1ca36247e6e605698385e9897466f4f5e5a83e97c17cff1b63e7ab2f204eee782761905a8a98765f75fa74099d284d36e71232ad22440fedeef49e8b244a9dc1dfc04f8aa244995065efb84dfea59c577aa3254236d1f742669b23efa78541a24a56156dba499acf211cd32e035c2d628a3096be6e946661bbccd73b8b7c558bfca57e99346c1e965038c4cfce248e511db898f7fb55ecb5fc73fc1b4b8947625df980181840bd47d16a61f2970ec563a570727965c28f6c7d726d9fb5825b9d1bcb12ac77b890f8f68b87515c285b8e5cc02441d0e76131a472a1c861c1c1c004758e735756955ad8fd69a3cf032bd67d7817bb0ec83f9dc5158b6bf01e5a9dadd611222fb67fe00c94b754ab5f3216aa0d608fd46d8fced0bf02fcd4c7a2a8f80d6b53bd41ed4f2d442afbd70a1edf9e3df65a0dd9c843b137ff9ce18f3c8be79a23d6148300e4fc331407dc7ae864b3c32cd04bc28e020e3a1d3e37a9d8457a91d2c7bb0052784f313752dfec28f941636dde21183418a2588b4d93dde69240f040494bb32f6ef6a83bd386b6e9e04bf645c9a856d2e588c8862ff571455b618bbb9d1354bd3a8a05807dde7b020efe6942361911533c65380a7986c716893531d113a91db92f6c6901734577b5c7f917611e95bf5f30445213e5ad4dd4c400a9d56bb37c486f47b17e24b84b05105c9224d2629d1854fd75d98ff1a2294e6deee424457388d8cebba4495b3b16dafeb388214d55a646d1973165f4f318e73cb2306d0177fdd6bc401c87caf890f948ee8e0fa6e0ffaf2eebcc9d4153cf1f42b0c767ad9ed76627e6f247a588cf8a765a4f4ea72965596d74846f411874af7c5885ee6d8567d1fc83e79b0848b1c8717292ac63783faf09e4bc763271e155639fa941b72ae0622cdd323db1bba7f4fb2dc637da70e84cf11834f2a67ea432c782e323de90e10f83333dee1bf2819c7992bce324482d7f88282708c0bb9771cc8468ec55420672f5433ebad76258f9dd49a08aa0606ad5a8dd861fe7a6903351e024825d89a151679e08f7b9f6dd14a1e9b03788ced4173aba7ea971f616589bd77286e174f77ab09893228c5813f201d786e338bd8ee02dacca05692c9b032d03603ce1cc9f32ff4ea9d6e3b7ed014c7a6ba013d31247bdeb25b3ef07fcf3032200830b06d37abacadc714dd9d0c39e00b06ea9fc71247cf6b75645d19cb75d7d1ca492f8ea8964130d0c6d92d1e1e7cde71ca8f6f2a5e3cbe6ffed33a93ab3e3640603e28e9402ee8402acabb868403cf4f4beaffdcf460dbee3f0749af30a74e8e95182f2561ffbc575937e08cd680b6d1aa545653a7bd98ea4f33758e4f280e0ef2c1e3a963ecfe28f39a7452395d487d6e2c0efe8ccbf546b4abe98b9b87aba0c2bf521d23f4419edc16c2b909e67bd0f04b0ffb8d6e3db2cc99f1cd682d5c40bff1758e9c052f9ae0d0a6fc35c716d0911acf5a2fbc65751b34f353f2afde292659830fe027efbc1c5978ad43beb1a44da1b32ff9e7e126d0ac371b3e71555321d84875497eba8bfdd6f0fc1d9a15b17b6528b8e842c32222c29b1bad95694def63fe5bae40949ef9fa1538262ec2efe2e446a2d071b4e9a274664c52e269a15c8d8f793257227efd952048a0867f8a9022035569cff778fd9e1e095be4fb9030726127a595bdb28bb63f8d09f2d72901507cec1d5cacf957f7ec91f2c8280c3f88358c665a30082ce4da36e5c391b1fdc8794c95b3ac484f09f13fdff4e69b5093f92dfb6679889e5501f090cdddddb229d821af76b174ac80a0415efcb0d781c525239dd2bd4142898ba5b19f1330529e021a9af571f6c3d404343c5ffce6edc596644d79057475e1132a4413017f8e95cd17ceea8bd58cea36fbf0ec6303a1204cdcde383b234ea4c6db2b706ab5af7ea85cdd8b6999b810ffeda52fddc83ea8595f9952b3bcb79095869cdf6a067fac28af11da792655bb765c61679cc847b85709015f0f59c05cbb107e11d0d42e925f1fb51a3e0ae0cd5a9901a53dc27cde525f47e612580d03a362fa5c73686f822738a53ffe44d6ff0eedb5a7bbbda5cd0b1a0305ffd5138e7c1902334cb1b9b20de5bbac8987804caffbdb1369baec48c0ef22c0b7b50a51fd69ce1f5e1039b72929699f54b8a39ec24baa4470bcd67ed4c3c8d92aae7831b4b536e58c8b422c51fd6df6a456fb978ead7cb0e96ae97faf08c180894ae5f8af23bf85b28439303463626cb5373eff148eb6265606bd2d1ebadea9df7afbf68c23e135da174e558aac346067b7fa6656841537bb33180afa61c7819df09482a297d84dca800520f0b023d66b9119fabadf7fe33e36381e95b4f2993a657d6c9d5fcd7a332cc3b33d235a54e51c5b7ae26e1ed69d4c59e4f0c63a041e53a46094e9ee9c10c25cdc417c1006ba48210d1b6583ce5eeb07e4b7f4529ed7f5bacf0864397b9478be309643220bb9880f08cc8e0139d19b9587600b2f7cd574f2489e3fd8427dcf48950fb19ba4cc38fbbcb24f75e54e3f793155ead05d6b19178a349755aab1d6f0e113b3315f9896a21ebe68fa2144c579e6a8835b3f6bca7d7296888b532ccddd7398ba77ab0eb84339a63523e798efbec7bc24451ff48f2e571365bfb3d5630a88c1f91261443ac7fc95a8eda293cdc5890c868e0cdedf682d98145f647c34f19acbcca9293ac3c0d8aef82dcd207f2b77ad2d9c036ca64ffea48dffc5332ed2e2fcd627d79bf23831876427dc6e3384fee0f7f1bc4545dad533e4199cd18e5ed83546d8b2ed4fb54b860d829e5fb88f14a0c43fc16c9b7320754941d44621d6b3b3668ad5a26c3ee37e0b69868f5065b1eef2fcbed33acdf99de59251120203d81a42fe7d93ed0adce6f6fb65b7a36072551e0d3d5ca74de954ff139deef6814afd0fb7ae8314580b7cff89a8baa314d091dd8f409d565ba350fc9db58d1e208192a931f526bb0cdce7935762725c0ae74772f27a8b9f1dd30d6ebbbcf44a6dc2dbfbf4031afa0dda7c6d045e0389a474af94ae60141970944daa26f13ee27c42f4fb9ba3a7a2cbc13ae374ae17de7dc24c5b22f31c7af5121cf1045d62330d636f7e1ffcbcf53a87372e051654c948b11be2ea559574307e71fb2c362251195254a3fc56858c5cda04d0a4ce953db787c0e2d15979e8660cf7b13ba98a72c52d745f584051467e1c27112114e7f7fc81a0f4292710ed1ab11d8b25f76890e4e8f9b5a8e77b8bdd75c5d19d0595e1b84054ef126cc0dd5595f8b92834e8e8d4507945e68031e221f640bb5c1165fcdd41d1567c02c8ae41c8892b545c3d788d01bf4070e174e0e318a7bd7213edfa9b822fcf57aafd5a9840fc332115a04ab1d7b6a141ec990a34edd670d36f985f3ff5fbb52494d4291f801e33dae468095cba62a5a31ddc249a9d6a0e585e423c2b80744d73efad6779f0909336856b854ae1ef25ac32db8afe890cd66635e1ec21c5e0727f1d38dfdcb7825ffc18af560e3ce659bba45595056df66afc3dcc0152715d936c1729bffc7a05878afc268dee7f325b2ffe2678b10ef9b9f3ec639519d05d00c3200b44315e650f7d29bb7870f158fdc81d40d99c364d4233f1266371cf5a763be883d992bba6cfff6abf026b11b3ca0c4755a4950d019e42b07be7b41f6abddf8fd2e5fd512c9b9d5db0c3d143bd6d9f6c6b1c7daf6e6d905560935919c3d84d5c7fc036278b60194aea9d87852c46e7906","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
