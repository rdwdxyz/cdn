<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"94d690d5094069d0616ec109a2a9b8ef97903cda3db4dc3424131e18057df2704ec13056f66e9cbbcae1c3377a6bae62b53a7554632729390631e4cb9af40e03113569a3636d341a1a980f416968fdd5e4a4f8ea04c3e40d81a9694a340d0c2fa67c3e22a7c56d6b050af05becf933d670197ebeb2b3b20d559bd5890130f2d6608f367df33e1505d0e0019cc4eb115a9d326cc0f9760bc85908e39c5c835dff89c7769f234d9d514d31aa8cc30861604115bc00ad771a08706d5a5dfeaaacec2b84cf4ce1b7041f17bb70966ea85062d44b0048f563d3e35033172e3d3cc68c028348336d42cbd5b90d895742feabc5cf1806d07842830650dec413265a30202a74015294b631a98fc70cae94fe687419e21335b4d1efaaa7a21fa12319a835641978996a5ca0b68f0509fe0d9a06ac9aa15cfad4f865681d28d4b4d5a0ccfe80ba937c10afb93f9cebe5deb9b8507bea8314ec3d2682a9a2fd4c85b75a71d393f93bd074fc7230c503586a6b3b40a7f1157aaf40fb7f247bc29f66e91a680cc59996b9ac77d486ed124a0a60199b8feb78982bd082a6838e7c943164a78bbb77b0b69abe2d7fd7f169e311ad3469b2d1390efa47fd07b83eecaa3e2827eae3917ed5576a449a8d0ad5fb1f3fe404965bc4c25e52cb9425f0388b7661f88475ce4ebdb0d7d9a056b4c4dcbf61b83a60336a4ef5afbaf1b8a661310c3f19073bda0f7831659e6d49ccc84ee944e7c992674424ccb2ea62dcb6abb17698a0502917b85f2c79a8daac219b75c41375a49c017d454ae2dc0758587f300e747e1f3c044f650889a3c3c9a49df62b7b577db09e95ae53c9633ab66b091854ff7db24628117552724758fcaa8db7375f209cd4ae624b0a8f7f6eb952e197b275402ddebbd109a626d823e48a8a2bebff93ba9d53ead8687c03874c779281956467a1019ea1c8009b64d56a0005abed116ea5e4e2687f71970ab2403f13a6172da0df7cfd546b8f63e8fb410f2913c7f7e5f6b1710b403cbc0c7b7bad3b88f8fca4544b529c9981f512363c6ffd2ac9517a48e4a996e1730be87129de5901ea529b101db7a91df734aaaa9b881909b1195dde0bda2a30bb005d50be309fd98020abec7655002cefbfffbfaf103ad1905abfbb1890bd22778e01bcc2c771a375c7ee4b9bbbf86857d2eea08320e8754635f523f9c22c51c8dfc33f0f92aaed2b1f6e0c69bd49b47ace571011aa5beb881242710c506ca232b8a82af2a0bda2237fc702ee48e494cc8b0743e47444c9b7fe7bb29ea21371fde5a06055acd000f25ea80d5bb124187fdc40fcdd4905ef206a01822d2c06149e5d262a403cf00bc4e1ef525150309e5677773d400ce63c26215256fcafc900844185d5c04622c2a7bafd7c68f7dd294df03846a41a2b9a6bbbed84296b608de78fe43c2167c3b0da5aad5e7842d162090d228824c2a610407c0a172f1edb7fcfafc05a9336dd3cd1d4d18bc00ca2f9acf2491a90e4ca20780e707fd6388256923a3f4575e2a2063060628c626f718f207ff0353b37ad21e7afc0d85b469e69fb725c1a52eb97aa3404df121c773b9d61bf15c31878a3037fd093b527dd874356703a11c5db56bc54efb6328a05d5c7f7746f028f00316d07b3b685f5450f7c919893c2c8a3a7e9a4ca0833687c923faa070c565bd8702981e1fef6ad2b504c9a8eeaa8337af89b0d635bb7d0030ea19d517ee4e4436791723a6fb2cf388b514bd641ed57056fa7e1f422cfa3973683e981f7157fcc3daf538d3912b4ef0a1ba2d182e4060591f3848ecc19a9fb83f78fa72b25ea9f14a9a56086259dd133399e77b720e5cbba819d4b2ea420c5fd619f7fbf2b0ead65b9966e25710e738ff81fc0378cdb60624e56f6166395236dcc28d1694bc8deb947494a7f4abd50838ec7337d44bc592ae69a931e597e39f24c73435c0e26e9cc83ee0724a36a8796c30a89387567fc56069b5d45df0b323cbbe195d34d976264441be4f3a3e5da2173f427b4b1dc803397987773ef21f7af15911589c0a5d012cbb6e95bfc2d0dd1e953e106eabf8a800c1bc766501c16c0bdca3dcede4218aacbc55ec43a71cdb1052ddc21047be1fb094013df6ce321ff8943b34d49fc20c8283e3415289654d71ffeedab1bce9e8a32e286264c8e712fe4c34cf782d3de576edf3256e5b1d39e2e539581d3fa40da174e903f24dc9aca56de45c532a9dc07e9dec433df3a54283c9f07dd742760fe082041bda64f0692c0bd880056a1a315fabcdae3da2273560cabc6db7cef70402ec5680df2c1bf710fab4f184bd8df98e2e49302e017f5c633876538012799fc512e52b88d1dd10040450878471b555bef14e745523c82dc8a3192956ff03d225364e20543d35877c408baee27b1ae39aaf7782bcbaf2b425c3fbbb076002be3c98a729eebd2f7d87717b53396ecce49f781f178107b19a2ffb00af745754422c519fc0c45524617645572b2c245c903c0d4ef370fef221a2b8ef62b367980f33ddf526117ff351397e6162cb0b5c4ca519ba6876a799a3f56d8e3a449a2217ac16e57a7da509780eefac71f931cb73ac2f2ff7fedd324952ae5fd09bf1b01e65124f6d3e33588683bd0e9d0bd2798b740a5a41fe8c855591b7e7330aca88640cf4ebfb9204c31d587fb3ef8d1d87f7963972884c5c31222bcdbb99fb053965e639a3a28e05095c04249cc8b9dccbdc7f3b67cd95dff200573590e567ad8cb6d9ef97180a97d0997092417b356d4ea27accb11fde8626b588eca0b6856e882a04f4cf0b4dfa8166560327e58d79406898e6373f142f68b73ff875258269c14d6bc26c41cedf410697acbbaf6956d592f88df11ece269c9e45945aeda817d044fb23dd128deed286850fb5ca07c667768737c37270ce3f58944b7881deac7d0f27afdeb3bc33064a1ea2bb4b0735b7028a152e37031ee56b05dacd02ee6afdfc6f8dc21b203873104cfadb345d5b18e6d5e65398417262cb032608619eb07aa766fd0f2e86ec703709fae1b8e741e50e3f961ccb0ee857beef85b4af283ad734ca5b63e31412a7ae3865eb1c39af35c2b646e2a0275f23eef4f44d79a0724f78dc9c74c57fb87b6d83fe53df0d09ee5fd9c77cda825e1e23e8a983d6a8489bc9443c907df125ec7877880cfb73d8389a728a0d409563dc5cb96b81c2ffbaeaea0a89202c68eaab9699df5343a7d5f4835b3d6c201bdbfd7db96ae88acab53e70503a8292afb11bb30a4c3bf7418503fdc9a7243e714323aa29a8146f7be7c14d003a45e1ac0d445ff0609e432fab708d26409af769ebb4dd8415e3f798973f772f53590edcd20edbe26a269d5b1421e60f2453f137f4d62d2545c95541330f166a2507426c223e5be87cd1f58d577f48a548bfb4e480cf3f9c4f50e41de94798f0aa4cf6df39527a4f10a87d35d2ae575763fc165cfca0cd50e7570e7af2ca7a180660ff8d2b2595bdde49be9f25823f47f152adb850c3b3803558a34dde306753340327c54e52d91e4f880b47b3497931debef2290597ecb3d163cfe101304719d715596031904687b105bea21d5b8a8cdfbb81382b98e342bc0e7f6d51cc3ac6356be307732ca6b67731e52c63310b047744470da03a6688571f1c0ecc256f9270d96cefd607569fe6ea33bbb4e222761b36a2c914bf25b688e88fa08b1ad89b4ebe4725894a75b58e0119752332390a3eb3987ac79c810cbe07d27c695e72700ed128bacf14ffb56ee45b317102b403cdad590c6be491f3a8578a13b0098a79071bfb806db4c198ecedb82e579577d0c972a175b35f5aac1f9351e7e37aad462ef7fbb5433be53c4d8a096fccf02314431e80506070a3894ab473d74aaaf8d2937d5a1765a577f078ca07faa3bd96bb4269ee8f043068577a18333829331c9941989ff55f2726da9f98b6897b3e8de3140d32c4f2f57780000eddac90d7a1e5c40e2b362d70f9f3137b2c9ca654766d3fd28e8f4753f37123a922ffbb93c8baa8ca248aa83706119974758f16ab6e41b17d80c8045549b1d77d1d221cb10ac6b1adcf25105200d2d2d5c4d7cc26fc74d8b0cfd090ac33b2bd891e714e4dd0bd229eb31f22672e5fd34cb933ba8594c80a201dd4cee5f3f073d56c46cfdad2509d3974e6be5dcb7f10aa50f0e64e805cb059ddf08a88af87d3de29cbc4b25e100d3398d7d0cdc8e3be457745a22a61242d540376dac894810da2f474ba78887e237e4ebbacce16e0a365ab7aff2ebf32a92a55364697120854dba30cefa430a83e7035d868d5f2191d44288c38415574a337c495be7f130df48e182240a040eb1b4780065989589f07b6f5d674e9bc0fd8e3b068c279bbc796803baf7996b7c08ab991d4676366932bcb71d772222c13aebd9893e2508c8bfa4d4766cd23db1dbd029579d3eedffcedb0e6b7c1fd2214e065f9c8482b39c99ab7cf1bcfb9f27041e300280f46f14523c27d51bd44c7c6381e18f1d0dd15a173cd24b0a71f93b1315a15310c9097f3e196489810bc19793fa0a5994a908bc4db14a9b5c29c30b43c2b7112482f80f23203e8fac4d9a73a64c8494a5c9914ceaa64e3d418ea9be9dedb893689e938d1189e6d6069f108bcb57454ff4c61d5dd3faffb9a56f6d68a446a60485b8e4ba5d33a18415c4bb6bd9d42ca65918791fad4ded68463f78af7524071a991087115699c04e49236ce327b28ec6f4c66761ff4b2d602f128bdee775f764d86ac9c38c6c0f6bfed890f0d3542ceb92760b4e65cc668a56049a7331adf9292d2b909c5502da70034e1390617eac1a0fdf56f1e1bac48c62f3e8f80b6de9cae8ce61095a92a8419a73698a91f06ed6a48ba79ea65b429c56e7afbab42fb43dc65fae352a0b8f836736a02f1dcaba15bfb6a9aa98276693722b5e60b84bd8171970e9ce7c3012b052657ade19d290feb28437ce2a6c0ff18c2c64adcbe33ec7d117a117e42455c3b694a0f9c54bf006e48e23f3711692b138b82027b2c7d424beae8d9985c0c1b90c14465b814f03690cabeb508968440c574fc5b015d52106d32932a59207fbe44766bb1e1a969b6c5cf4ec53dab39a970792af96dbf43b0b3f8530a18736f72165339e445183c0358092a13f299fd86505ed8bd2a90f7485dd0db7242e40051cce5c3ab1fe717a9fa1b8af84a19c6c25ad8ffeb44e664117d4230007d5025d52841a85db6b05ca4dc60bbb2bf1247e4eb343cf82c037906e37c23c7c3e0f7d44f89634f0a8f7c1a0be46d8d998c800b8d125170f7e3f6c0737a4a0ab9045ce98ebda3f95ab48190aa03518a0f9be8ec60873ed7f7e450773cc1f57d4d1208514901c706e418d9fef9965bbf13acd07eec36733fc15cf5962fa5739a0ed6ca9615b9ab1aa9508684bc1351f51265e755896c93e4be62e3b7c1bc65b04e6a074153a11b2c3ab9463af04f3114561996f950e5bdd672d97cf34cb711932cc8cff65c0282f10be64ad22be83c28e30d24174346803d27406bfc1869c7a0428ee1aca44e461303852e994bfa84f7dc86b840d0b3a1c32aea8a6d6c22ee3578d95a84ab4b650e13ea8cacd6179f753f2b2a57741cdb83e6ae704bedb9d73995f037e7cc8e5c0b370ee43c437b5ef650c121adfeb05517440e605d96bc8015167e23fbeb3053d4781ba64669a4ee45566164f833d331cb2438208397926da8da31ccc3f690ffcc397f9e41b0e50ce4d9040f962fcb0bed1eaa72500b4b37e158c73d9153b677593009470bc3df8a5406335513e566f6e5612647a1685ef5f00218ee2738d3a40daaa5224cf58f9287ec6476971bb2f8cf4635bb6cdda70f5d3e33175418fa298dc4198fc54148ff5240dbc01724feaed31b25d7fc197f44e0d769f4752c1176cbdbeb73bb181f5fa23eea6855cd7f3b4794b002d0535b27d47b7e05a7ffd2a829c453373aa329d2b564b4fcc53b3a4bb8879f9a05d86ec1c8de875a7426cb4d2d190fc7f17836f9aec5b51139c6bba1fb54799e48d8924d94802b334f6078dc9e767dae54ab8749912ef4b75ab64a7aeb5e8a6416ebb94eadccc6d965a09eb3144007ea36f5733544e943d6307c531b3065bbd885dbcf2a4c29f6bd4e7cc1c344dbe6d22fd511d152dce93f352d8d59d3dd76d8e2a0a32705d100890f4c89fb9b2a74bf227acd27279a091e9c5d71bb51a8179a9a0b4fe4143401febb440031d6f44c6b60351f89ec9ddd47061725c8c2d54051cf905e02e0ff6ed096c2c2f8a9bf99f664c60bb533969a0d91b5a7451fb9623e67aa9fe9107259488e485dd4ea0671df299c396b61e3be8607c51e846d62f13ff1fb0e1fbdf1b3471b7ac4a0e8fe64095f1efb2b1509679fcfb1761f635e0abbc6565c78438fd4cf217c11b4bbb02e0e214cebc3d0ac24e02abaade0bc10d76630dddc30631bb5adf253808c1ec40bb73d24d12498727466b3b8f8a2e90a3635b48e60d50af4ca93a2e792f4f8b0c01a14ab3d8438d69ae05fa6f0486f9d0b4524ebd3e4fbf52a0c65b9f99fb6d5c9bf0e3a7cbcaaa5a377af8b7ade1aac4f1fc659efa4a2d5e532a75bff5157ffff84c213b829f4099ef12b6bebdfe678379a55bcba00b4174248dc8d65a9d5b1ca0864a0087daf318699f0cdfcd8fbf1ef0a92333b96271af7152b19228f5e7a05e25af7e9abfe0b76bfdc1eb167ea2468bf88ef044bf329588b7bfcf81117a01dc9f9f2cfd160e19f3cf9bd4b33c3fbf3e17c8961c39cc3b7b2b0eff4a558b444d99f3e3ec3d354eda97c19e0171ab1d3e6dcde5fdc188ca85f4f85a21c471936318a47965aa1063141c8184fd316b14890e54b5c1a72480ead04d1db94aebfddaefa60fc3f0e62f012ead238f5fca9a718437bed289c791db24a647faced9ec94896b600d76b2894fbf67d2548e7b8a1766f1d6aabfd7ec66168e7ea5000054d1e535035055052e31eb6309db13957b9cdbf968f2ac75b51e26abe6e856f5567c4c12dbd4d10ce4fce37a038b15eeefac57e82e3a95f5f62602e6764d987bd1795f597301b116e76a9240aae7572caff49f65b65362838e8ac44bd7007a06e5560145dfd1c7d5f3ad9db283b8195144a1333c82f2daac69af2df257e0d012ed74af9b0f6aaada49fa09ff25ed5799e984dec6e9ef4dbf6be1530da0302d872c2a724dd83a614dca3159398089018bc67db028efe68c67116c542d9549d63651e313a9a9140bc05ad8b931e818a0d356d1d86199a7f88c74a183ec3360892991c322e10d989aa7b0a6bc76b7dc01a48a80bedb317c3fb79fb33768a7f9978a2b245200a9a464704371ad9f1a8af658f5def9860d2e9f3248331ac67b17565c9753273cc189eb989253f9876aa6f843de2136433ecc0a5f0df9973512c81ec272c1cc416c2b2c8858382eb877a855635ca95702f478bf0e7d4d49df290c2cdc3ac34cf5a6782f776d15ac40904685b409a39af6cb1557514c382f41cbfcd8603a14e8a68d71ef8b9dda52810e4acde172577a81346acffdb9c7e4a7a8f74a6c28f6d072c59af77dbca73f695f39f2022d49be7f1630de347aa98dcf5398caa567427dcd83e7891df27a314d55f16e975fd603c54bd035d94685c0a6fa97bfc01352e2ebc96e8ddb68cacae7ac1689c3cf9cbbe1017c02fc7ae23bad670a9b8c8098584e14c09df3bb9de5a7a4b7bb1baf9cce1f8032228e7b3eca41ec2777c8a5be308e9131f2b8243b1fe1ef6b1d4899bfadedd14e8c0992e5b1b0c7e44ac18b0c311104523a495f92c1bd996342a78858ea12488c929b99e328e4b6c269d0253368eddf2dea70d55210ee8f236e8138d3172db584b8f03d05e486855564ea9590ee70f35419d6840724774f6896541b328b1de5158f29fcd3bb82892f9708969d767e3a65be60e443788ebe8a0519707732db49ba3003895ee0646656bf9ab13ef040a487782f93803db14c3530010db4020e8f999683035054de7b798c9a4f0e20cd30c174e58ca77ea8f8f7932e706ca064d98d0e0360445ab23f1fcd0e750a4881d0a987700d3eec1d4d3970d33906acdcf70b6f646987ea07b0bf9e6e0d6538829ccbe9445080670525aba496bc620226e6c5885433c9072fde96f07a13165b0ed6e6c02e1fa1022e12418cba69b21bf5f3f1d85e2facccc57dc19aa6345202d862af04272f54f9f4c875dc6f834e0f51b7649bf88dc7fea54d80e1c1b1bdc934c5b415ca72b7f7588545451b6672f5ce997b65ddad5ed93d967f1a495ed14e0e3ddff860863fff0bef78a8eabe64d79d4d388b3b272a78021b220d5e0059a5a125f79d402f16b5989d385bbea74f5e7e1ecd7626132e25c0fffe627fee90a96b788ad3cc80b5156c735f3f156ffae64f428b0c3aa6cfcb825a79b6c4c1db90b53455f12a68822a92c62b48ceb845f1fe0cad37a88dd7ea309008cf9d2658278b3af7c50174434ea9f5dffc9cb8010ab2108e1d1f91258825415731c19be1cdf1244c86d701bb54e433d347e0bd6e10a0fa2b452ea98b926d37c70b8242110c384fb3ccd8a381cf1a9f81fffb0a032f0ab3fefe91db53b5f7a9fa707a5c3ef8eb8957214df89574c4b66473a9331591cde7a82cb3c0eb4aa8016b60dace9af3c383f6bffa49a41aef3a09400168406e3f56744b8160ef7e8e4438945b4b869445f38302b749dda94ba06a673cbf4e03a9832d8711590dac14bd0c2bcd6f437c702190d97fbb30444b4ee8a419cf123a4059a6e68f4e70f1d8497a67818623c1fe2d6410f4ae089a08fa716ce495ce48f2cba32ea44dfc96ee7ff274bfa022b370e6d42ca574b9c277dcc2f68fa44dc87aea42be04e1c42893592a1515ec2c9b1519fe1ccc9ff1f568eabcffe01d94e3eee748e75f5fa1699260d1577635e72ce8c30126e9eb783a23cf5b054d74060b391a64beb36d226cf8609da7e4e3c084a6165b97f3fbcd029358e8082f6b311a96778097c25ae6b28026273d39b9ffb816daa769127cb13f3f2ef06748421d516aa261f53631432d133cfe0b372c97f37b7c0362cb38433300524e4e7e3f92874432ec65de408df0f2c10158cb40b24acca6bee394bc15ca3494728e7d9ad8227aef7336ae33419baab2935f3464afe05958d388dc405597ee4b7a90837c441400dc20789f3688fa2ec848e397c5e17f24fe104eee49f12890b2cfe152b4e31550e4393c40b5302780e9e16e4319f3cd3e6b1e6323a58120ea70165027d5d049223b5e0d098736457fbad83ebdb2fceda8db3bad17f73247a784ce19f7f966c8a35735382b31a6453628ded1e0c65f269c34f761102fb7d4cd9d8b23dfad605d6bf1884b242b227fce4bd2f228b45b7ed1c82c70ffd57ddbadb3d8e3f90cec7c7a73971dac26e8cd1e2d3abbbd2fae310998ea928a04551b6731a4439ba9fa7c8c8826a28f493a9d0420e670378c5c4c453461430272b1991561054c5fd7888d8e9ec127d9eb9f0950dd2fb34e82579b109f0ff39c7480e4593a451cb5b0d17bb1dd7cb0bb8e708f24957a302b0b9e4693b9b0832dc0d3a4199710e17724f494ae9040c429feed4655824f0c56272ec65ab75de5c6b88b7f2a679bc9062457155e66299e4783fd2ef88a530eb28eae14cc3b6708b29764963f760fde11b6451f8736155ccbec597cd424ba11285e72f2d5a700e067a14e4074c0a8a124d0b866c69d8dd50f35a9635e56c7e6b8bfd6d7807592d845a432971117cffd981ded4d7896ffbe02a88bd0112b68136381321b4ed0233f164ffdaac3c51ea887ebbdf3615c657f46a22af677a45ed14a04def94c4b3771eb6d852ac89f73dfd71234ae5950cd53a7ffa9784c53eb2add39a2b3d683388d822995e5ca7319a691dc4e1b75355cf93c1a2fc9adc141c95e8d9e3ee0aae9254f6a6b1da231c829b4f6d1dd7dff7bbeaf75055b080a6638c446b8ddadc47f22f693eea620021e95bced158da0de8f18734bc8f8b1cd701faeed26f7ce6b0b977de2eb515fa243361733dcd56ee76edf65a505b007787d3b8491fcdf54c1e49923360fc7196b4fc37f11417947bd4b618980b533afba7cf3bbb1c3b264bf5f19c8114ed46833fc906eaf3c15e2a1dba5788f45755d4b590d543e130cc6f177acfe93d27d19e75335f66f690a294c74b98180bc70c337ea822d2e8f7a3f62001305f82ef00b3485c801e62f3a579ae0b98266c2be0550120a3cd959c36a6ec4a6d1b35831e8cc7f16a14f12d15c724161661ccfe3e5897ca11d6c3398275045c14cd51fa24e0c949d8c4cff4fcc6eaf8f64bb2bfd86acf1208aacd73a3a11fc0837c692820b79b5247f43802e037b980eb806cbf6f323b9da83526f63cfe41a0049d981882c84f542d794774f673809f8f756a23278011d7a88d08c89fbaf721fc61fac718bd0b17bebdbb65cfa285ff54078128d7e7ca8d8caa2b0dfb3cfc3ac6830382e2a67dfda92c33f14f1df6cd4354184e249b5297eb818a63ea48f477f5100bc359b5e780056853ed37a008d9e19dba3422b8101e7d4dfc92ab1de6f1b9aa3d12cdf98ad073fb0dc2acf3712e651e67cde6ca41d52b80f7ec44b9c5a2466b6b142e18aa86b2e85caeeb673e6974ca33ca4881417c2ee7c68b343c488dc7ddf8f6cdc855bac5298d8e39f963e30e5a8ed38ae7d455c1470b2a3046acdd2d74cc54b3679965cbfa1989b0a9949018f4430f151d8525554d50dfde4506cd2a4014eb088f2beb33239d0296ce015693a5d46ba10b6a78eb19c79c7d51416a687ee1444fef931369e08fe1e9e7ece8ced6ae7d7be3d275f97fb1cb082a2a7be9cfe44e40e9a1ec2352c9e4390c73f3193b1dd73c44d90f6a96fbd71eca87d124519393bab31480b8f0424ab332ebdf13bb6971de56ba05944760ec9558a248d401b257ee1d05b75b54e4053dd6959fa9e58a5c2a5837ede36db43ea8d7418b2e28a32ed746dd2f12cdc2e6ebf7178b54cbcac664e918aeebee97390017e3e60407f7ad7259bc09efa323b700d3cfa210044a9c202ba7608517fa1e06ca162fdcb72b264d2738282d26a4022ebb94f5533d7249d8e378ceb97845e87026cb53098c013bcff963f05edf238397714830f4fc9356e5f9011c3d10fbc4164adcd46913243447ce3e63830dffd36b9aa6b403e221795852566df694140afb449b96185007840426f23980b556763a7aa5e9c1e6434a3f48b917bcaa2ae8a328e1514facc4a6931179007c877ca30364cbed13932da1bd79fe2ea6259e5f2a6f2f5a2085bc8d7b2d7a58a897da5c70022fe694dca1f0493055f10653baf4f0736674ebf00c9877cdc980f8aa9f1c96abd3365876ffd32ce9845794b515383d9085af53d9b5e26fec93643bb2a3bbcdfa1f2e56ee692dab1e6c73b961db857ae2ed216b1aba14101808769ecff50067196f7adf91f6d3306b7590abc9e8ae614d5a1809169e69cf1288b709b539fd8e6ef77dba3779402deda8e800f1bbfc243b2936c96ebfd14175e667aa01c022ffe84db81cad067a903b2dd4fa5bac4545890342a13c3369c6f5130c7df83a404f2d454350befe9a9eb07a381798c53a0d58c624ee3f703761e4583f6b0bf0bd2831153edd533713ec0f7f9fc8e1c239bd19915b80c332088d020515c50afbd02f5316cd499c17b23eb0bce83a501965793057028677c625e6b8224fa78d386280f0276eb01449094d4d8d05fbca8aa9f6e0dea6b65c8ab30688cea919b1f2dc59ad840e064d3af97a9b1d2615ccb7cdc16daeea39a7067534884a03e16207ec22b4a311f239b42f4cc4f2cbe05f7ca2c5a86520ab3ffabe5b18a50282ecf4aa6f5a0ac62eb7564eadde78d95a0c3cbf4d43a967d27cd21a775c162101608d8059d0383b05971a6ea7927f1ead751e68f448233ab61a88bd09d6417abc5ab3e4475021dc7a160dbf7580b798e56218a5adb86f59cd50eabae6ccd2995fdd9b93c3fda5193296013d71b083e7eb3f5d6b9a79efe563d83a7343a0a54e0d3ee4b94a0ff62c5f13a086487df5a6ccb9ecaa6b2c29240aec1fe3f77fa1e8c8d00651ff01f32b560f64cc51bd0e8287ff34f7bfa44882b2430385673a8bb21f00cfaf5a6a35d84dff454855fbffbb85258b91e5216d25b8d07aac2f67047de640f6a1e3051b36cc47b45c86f2010fd0a3f7e90c8322b1a2c4d6c890f537bc5858ab0806c64df7aeb3992c9690993a6c5470de1548055848d118b82ad741ccc4c72de064589f1a69a0bb546e5dca55bb3acba1b75ae61a3a42e33383e62e383c672aae4189a854919210c02ab2a9c0075901f076da99f83d4a64d42c26400eb30aefc3fbc1e94f39704165bf7574ebd149ec11b4c2bb5f269f1c2e68f0840277be004cfa41e493a4d29b6c2808cd78a2481ebda1475a715f78a1186dbdca10150b9362cf80ac83c687963149018f050329e0bff86a69d745198fe2444c969df10d0f28927eb9367e9bba35a5a04a5437d827d719df4242f98809a4cf3af4720d809a66398865392c9afc0d8375f22295a0a264184857d0f4823fb7aea6a5eda5ba7fd3d9f957060ac10b9a5f726857586321f313f4feefdb59654211fedb84ed0ad45ef491c5ddd357a5199a4f667915e1921b6b0b83acfb394b05825dafba3aaa8b2ae388b39927dbf4ddcd51b5b7fab1fbf8c1973ffc112ee7a7a203d41b2149733d974cd2a97300671c46448df07d594c349590ebc615a63fd28959703b8c68f2a246abc6efd5f570175b8b619901d27731fd30bea046ae2ee1a91ed3d270fc12e6135504467b11eee04cd080a49bc5e403bbc9062d6c7b9ede1a9e098b900d31af874143b8babdff7b47ae38039541fb05f2461c28f20014ec83daac876e07a72dd300dbd05b9ae2e57c4c90b9472dbce891703bc7b59ad171b5fcf6de3e2bc3d591b64a9f8b82a314fe26fd9fe6b65e89d79579ffc11af8d72641fc4bfbf866ce8af0474ce338cd006540947f27f00814ffb8d3e2be2e6964d61c2fd77f851a9a03b8c1db789f6b144282ae98578d978b524fb0df7cd5f0e42a6ed5b74def916ef20846ae0877bf6544ef2d817e4f5c4ddd235541bad69b34442d858b41db29a2310076614875f7bc02f9eda9af757e407badb389e48297a40b6664ee216ff424877aae44facd09466c9217b31c133b2559c7737a3bb7befc76f2e85f129341663008e09132c0d4abc3e5cbf0621b8ac6705c6cd2afdaf239e0cfec580bbf227144aa23e568e65488f4510db48a1dba9a20b1476ee1bb16f7e692e8e8c8f9700648c082c5bbc25a806a616cb74ad5c5b36447cce0afb0a39c067a1b2417f3a33aa5fb69f3bb86da57acde67754b3bda375547fe9ebd5891d92f4b846ff46b6bf8fd6a64441d508c469913f90e470fd253fd4d63dabb5ec3e51b541b9502b16c125cdc6a91ff43960775bbc7dec56e33b2ece56d0fc16530ff4836928c125ea44a2a5c6f9d3d4de6c79e112fc4d30a9395e7c418cd93658be0f3a5c238d0f7c3f068232cb94200c82ffd71c881b18ef8cd089299b69c1cf13d3d66c50829d234fc8962db0fa1245d98c4b50af0c4bc9eeacac15141abd68b9ef2fa1692fba5756e52d580604208eddc1d1234dc6fbc8711d114eb9d0a163ffb6a7a401a36477f9a3e4ee5878247db50e5a0b985b0ce66f4e45dfd58a5be9a1131cce6b8cb0e153ff1c58cf451bf74194c2253bf06f7739b36d380cb57f5f70ebceb94f721b970f480ccb9eb8f24ccb12dcd6adb413dbdf3b2c0f01ef704040b827b76d40525e3f8ff56ece4180b44fa305b8e3e1831838bbbb431c29296497a823c2ef021866fb0a66b9c19ec616e4776778f2b61ef6794bd4345148f84abf5a92163df02bc10f94af08fd70e7c9dc23229b650e8c2e73e3d102fc6de184066c6885e2d0e6597e8e0a1105df36edbc519610f164a6b01cc9f1a68b5bb69f619ba13741e7f780b356ff9a2a5cbe3ad31b29497a913430818bdfb57ed5bfecf0d66c5c3e4b597fbfd3ac99289e589b4f7be74d04315b1ee3b8ec2d252009514b086ea1bdb8bcd99d06718317a41ce99e277a41c72dca88cc339d306047cdf99f05126fa01a75b5e222ed96e37016567fb9cebb9905650de281c4359fd0abc0e8d7f360acc4f68cb655ee5c7a8ec23be8903fe2f98614d41abb554fde003662d4b9053fd82c47a8372a98cb14a1e10310dcfe187d4a97896036db6540519348caaf53f602949579f6e8de2cbf7d48b6055b2638bfb043aa8971d77c00b9ce4cc512659d98f874708770502dcc54eef2864b3fd434fcd7f962adabd664e3c247d09258bdc682576156160c6ccf3e00b9a62586feb57c253b323145ba6393a8dbce3b820d84f5a4becbb14e610cc63e6c5fafa8a5be76178ebb3ad40004da55f8a73c179ad0d5aa08e790f17820818d57aaa41ef9975ed144546bb284bd3ff2e92ab5a76ecae1e39c8b49abcf5eb6d984c8f25424de14b999d4c89acfceed32a66e345f338c5e25fb35cf24ae15295717254bcc81d799d4518154c60e20657269855e7a8e4dfc23abf77b550b7b359a4d465dcecd68debd69aaab22d68aab66bb026af4ae2980e64c365fcd4fe83bfb4056c5a4fc3b904cdab70504535e3eb1fef8ac661f310e9598e637e6bf3e71b95a4fdb57903a6ab6bdcb192a87aa902b8252758c44d8536062307cf25250320216927d38fc4ced310aa418e9f3ca4d0fbc180e01cc9243d3dbfde6caa91d9b6b5c8d6c13288ebcc77347c26740ef1e84ecc685012d786584e62f89d32cfe4734bc526cdf1e3732ce55e53ada778c4b79ae28c971c0e3333e10761e082804f3cb230edc6d19b7c0378d52dcd87c796c72041ec992de745e1a8c9ac14efa37f4e928789613d1996adfb1b3c27eb35aa1a174896498a79e1fa5d3972a9ef07a88a1c6e3b84a285400825f1747d1f09cd066b41cedc59cb0d8a50971b0ab642cb9a7aaa97f82566a0117e11b8937b3cdcfc61a844e9f7a891d63a4f535e16678ffd47be8ec59cc635190513b71cc06901d6a22a774241662ee22e7a9fb27606f467e6bce99aeca0c81de0ca2065a539c62e35662c3b0870cc418f91dc3a492b9be01e309fee159fedbb622b0e51cebcb1bdcfbd776a3bc4ccb2c5ddbe83cc4c6a305fa423ae6dd0b244f8c16e0894ed80dc911490314643538ac127e6152743a7518c4e6f4334a40d3beb377997396be9e3b96c0c140db003108494676433618e81ec9c883149c0b362d18a56996a1addf54cd8312c97fb4134a97514a6d7a42fbf1084986bea0834ee469ff87dce159d7995c2fd25f1d42b0ef278e6d9248c26f8eb32bbead6a26b8ce58cf5cd908706ffd3c1aad52be617368b353a7acb8c9b67d97fc3ad6c30f798fadf8d6f7ebd738b4202158c57c1a480ae313773682f084a41cccd2d0ee01f77618041929311207b39444d521801f7faa22712af7ddd6285383c3d6c80a4196c4e71bd19f48a95cdd52c53be0414975819f40a099173f498f57c32d40057587ab2527c095672dc95d32b89e9b5e5baaed002156aef76cd3b7cedc7010c1ac18c27deb2a2c596d6b36698ba2666b979e01d46cc3a3d1acb4ac7b348228229cd7abd8ccb2d547c31d7083319d9449fd239c4135637b7430f3d18b98db762f95ea101fb8870032b41cd280be645ac026847947ccd2fb44724e381d0c37c1ac8d5ebf98e495af2f57ab8161f759fd1a45ecd13f454cac5a5512577aa3b04db2cfb5874825272b6f0c3ef8e81c8881756b37def6075b40c62765bd0292dcf7eaa00030a627c2f7d79c72e147896fbdf30f9ae504fbb1cd63c4f8c151156634caeb558b10095c31475fe6f2005bc28684288d275c8a1057507fa63df0c18a02429701b8b4236a5b4546010927b3861934e58356e6d20a3699a952fc36bd83794f401752fc3e12cf7f652e8de1bbf0470f2675aa2d2a5cb37949e3456830337fc8bc160af78e2153d81cb97cf62b0d52df10821782b318cb741ad054fb4f591b7466203abc871d47386ac2dc9cb8f3e829faedf7397240cd7c55c56ae6bdf8f996a5416d09cbff660d7a609379a23217e740bb633c63135560c7f29495a6a5a8565f7330fb7443f2b9f8a0dbbca8880ccc6e837842147fab57f71d332c5ad10a036a63d76820ad987a645a33ea27445a871901ae191105cfd215ab052f16a892a86156b4c046f89802024614c3f3a93814afc97ff0ce1777d773d28eca5e6587579a9f29f0fbc4701630012da5e774d98cde0a8546aac98a831b92ceb704a4c054b9576f47dfbb71f7ef439612b02b0a2fb9542bc2c46f664f7ae9e6cc523a51d3981d02c8ad9a056b7b167cc93a9aff04a9066166547f0717bec9b4e53ed052f4e1b5a4ed87cf178a93334e1d05a84ca4bb60a4c85a777053c2e5762b9ad76bcfb95d695c85b84a6350d2ec9fbbf7f0c70334e8ccd3898dd13c19656d834d9da304be69eb7ff5b3ac9c0b8f7dcf9f60c7a3e2de2264081034d6cf1da523a6e52cfde3dca5d0585011a2370b5275b384c66486791aea96f9a480ec04c50d805b898b19bcc4d95fc6f0c1db3132abf069767efca8a23188f8b337484ac6f69cb668df9032ce96b13ce562e5ff509829528b4578eb1a282ba7ac644246d25f46ea387225ff929766ef5486cbb70b61a643c6344f33ef49899b5bb6495e8370b49c0ff0b642cb8a6b68d7a8ad900fb8af8b31f1e488201a0695ac9e2ebc9756460e48ff8c5f9f5d11990ed17642348ac0e2ecfc6bacbd3a0c99dd7a194d9e2814042317182666e9b42aba19c602656d049346a599c6f61a4b18eace5044630121657a588567f4970308389caf30d8f35c903cfbf60664a275136fabc11c1914a08822870c7f0e075ae4a2e6d4b753bdf55a2bb560b4345cc07a983d1351fbcd71121da66f11e6b72facd510b433c063d875c74d51709463d910352326bf2b190e7d2856ddd55e7450a268f92d0bbfd90ad9001d4f5240987da90523907fbb0f71d8141ed1c3a8014122b938f644be3b12a57d29f0665391c6202d8abdef85332b6a4c950ad63e8f5e66782fd69d81250ff7afc81dbd1282ed8df6c1242d0169085815588f4eee3bea6ebd7ef30be35f26b59adb01735c4f717a6f8a9e33a91002f5a5d8843376463dc97a0d34e359bcb6eb72ce4f9f4da8b90d0add51248e60cadf594fb452535fde2a502505cc5006e777396b04d062d545fe6f43e99467eba14a2c1dee0ed59e24127bb62dcbdb331169f0a3e7b1073d895689843665edffa15b4ab0540704b8756e075bd657fc556629ce63189390d72fc612ce8da48c2ed1c68190cd158d3e5bb144eda1ae5f32955fba5c135286449851c0c41f66acd50ab76e1a8ffa77ad0b09c0be4742585a57fa10cf3a451e89d192bc3d34f6f1eefb698c760eee1df12d82e74473bf727ec328ef09e40f6f0fe3aedb083ba3fc8bc6475423762fe7196e9656b36dcb92a4c72f8ae660decb1a2d789b015551b30996369633e4274f8b4a2722531f9a5356438a1ef6a64145c2454c4f4191815dbe377f2bb86debc8ba0a0b45bbf46338a621973a4eebfd7b649ace71cc207c1c70d923113b6e888305dc3e5387ab2eff2a60a9d7feb471a42eb83143f821358a070280e1db6b9f9b1cfcabebf5c990cd5fb31b3ce459d5bf49ce6d17efd10d5b872bfb8fadf62b14b7a421e2a16eceb1fc6d8314c6e19e635678eb2e796188113e3464b463f67394c4ab03f96f65823d49e3cd3ed68ad5f056c17491c7c978b4ba94ae85e9dd7fe855854fe47d27cd2e96698623aeb518b953037f967e566821dacbc927c910a822b7253376e59e256de4b4b319b63f3c9fa3552e55dbaf57749e95e7604f65f4bbeb4ca4b4120ed04b453af397828958420d231efdebea7946ee83836359842bd1a7268c5859bccc2772a7e9d9ddad6e458c20148e426c2b49918058ea77f309f10376534776ee0aa83304437024512b8ffbaf188b1ec80e2f0ed35203da00a0e45483f3f3c788e258e9cf320f9eef379a80cf41f44b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
