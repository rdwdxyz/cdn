<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"da64f5c66a89782a4692905576859c3fe55ef021b6eb2f77b298b504a0a665843b6a60576ea788a661e35f23624db886be0992c69f4bdf9cadbf7889d714baf28411d4659d00201dd52b0163ac298cf426b6bfac6d1220f59959a3e5f0c1ef4e1eb91b4c0d8ceb560110fff8f4d2f10cc24d2cf08abacb59740c3827418c846d0d5555c0ec4c968f94116883657052c3c4a24b728207d65c2361b2ed38ca08698de5aebb24a751643d1e70571f9e94c2b749ac66845d7176481885b8196bbdd75367b6623638b786ca40a7499ee7b716cf59a1ea44ca42fbee8c0ecf291e180136a1dfe6360f77c581786a10009d9d8e7b7547dbfbb0340b88b52694548a935653b91403fc7148eeeebb6f9ec62cb68fef242f801eefcd967e4a68b8ba1a5e28d79fccb082d75e10308b8212ba674f1240d772a694826acf2c5e5a2012a1fb14dff497aa550b21c89220003b880fce522758d14e1a1c4bcc5f2f41825c1128e8ed66d849cc3c7d51a57f8b0eeb82ad6fda7062176a142f7a03f37961a432200ff4131d3554f406c7a51438731179c1dbf87d71631e4f5a7dc2c4d383178737a5a526c7a9d8b7129745ac3713d579796df312d9ace042dfae174fc26fca8e597f1398072270c2eb8e8965659e573bc57010bb1bbb69aa60d4a437dab1cb8fea6ee45e63f15388d2db31702bbba844b72196e0001451558ad02b2e9f73b321bff460df421d35b16296f28f834f556be65ca9d9ac39ad655bc0c3fb26e047578bf6984a0adea64d1fdadfeca0eb62f5cadca9ed56f45434b8a9dd90011059d713de3c080bad387e54d6ee858ebf61e497ac95078ad95747d7d3b9285da5ac6c38bb586f393765b396cb4a0474a981fdb5bb94b6899f6eaafca19a0e8c10c77b5b8263b1cc617bb187205f5b2074ce4044bfb3a4a9531cb39e24b2d44db26c2fd629dce237400a95dcb50909e77a08a3596b1cc508a78ba91c5c32fb6e5bd0df9dd05cff6a1ce14e309e52cdbdadc9eaf3572abf0f95d2c506426f1daaf0850af445339527e37ea5fd5635857ea6385c35474595a14ed4e0b53fb43b9260064286f962ca54ead420992fa8a26dd7bc2f4884f4aa9be6fe7b3d9fec92f66da9410ae15967109df4215efe56c24d1e2260f86a323377332d01c2539456c1eeb1ea6218ad27ad7a407d7b3b78dae11a58d12f0823be4d13040f9a3ea047a592c01656342352a1b2d1d56493130620011e85132b361e1a2aa521a091357110a30ebcf211f5f2e402d3bb8374a8c39339bb0663004492f721a5d526e68ff637fc1de7c0713ce256f68ddeecf8a7214796b06902fb512f488052b9b5935ce7982756e35a00e7939309d7181f6b8aaef5a242f5b4975e0adb701cfefd6291a48bb9173efd9a4b94c341ce520eae101ffcaf8e02e7360ebfb8f8107b02a37a299dd42b2f2c1f1e9dd004093b41a1bccc71b9150daf8c9ebd4b4cc176e46dedc8ac445875a2869380fcaabfced77aee45e90cc39f80cb42b585dcb2d264862bda01b22afdc34fd881056645d7f79ad2f65f8e33c5e06af89f4dd001f91780bdfea838424178a2f13ec14bacb43f2757cab17c5b64965156def1578f06d512eb6eca5d840741c5237e6e0f4e13fe840ebbe2a64e54decd0ece3c72b55e792cc377a3082668c8f61347eaa157206ce0f09e6c45b53322cb1ec3af89d7514c4c675abe926885883a410f985b5e0465e248e83ef01a8f6e66e9351ad18e28ddf08a3cff41bfc99926ce7e3897401164a2afb957aa3750b2697ad2487e3660c7982275b63a4535a4810f14d8f7b398d933def9b3f6f8557417c558e9b39801164764d1471fc249617a6058f6654713c5a761697c5528a5c63955eddb377f60f83db31273868e65c9a0f447ec9c78328cc1bd3c2ffe03652cb02ecbfad3e95aac6dda914ec25011189624419c02444996dce15425547beed81ac61977efe53eabfc0691be365abc9c7f82d048a6439cda8fe94f07de157af3922481e685323b895af29e7e2f00e47978c1dd500039af489d16da248d31fb3f07652d2448655a7de3c530bf07c1dcef1647777526ac0027e2438675e1564f531acddae54ed933fc3e7bb5139c9fcb33abf3a2af22d38cdc01b1a419933a46d50b7afe7ddc83dad5bd53fe20a060848b6b8aa4b5cd0aa15808e360a3d8e9b8f4fa6c67d9e25ed1f7a0c9746ffd54ff22dbdfcc776d4231661fead04630d851245394839d2f65294718aa366b3bf958ff568aad108bb56f534416b73eb6b8245130ca03c1f363ed86b8cbf7282217cd5abfd5b5198eb7698ad20e77cf6e22a2bb5f98268548ea6eb3d77feac4c4d05ac63fe0a5bb3debccff909e1c32215ef4c2febf48cee1eb3e569683ae12d2bb1d688688a3b91e40f915d002651e1a64e3a9b2dcc211d5ba8d7a705d699c8ea6592353f1a89ed56ea086853b817ef2a631888f578f5e159b366e8805c0d9794747fcb72237715dab23a8dd670023b2166cfe23d66b32ecee3b05574b5f940769d71db8f7a7f7272eac88112d3587037ce5fdd0ab53d2d7c55e649f888c09b4374db103867424b9c8ca4c02e25c1d37f914cb7bdcdaae660ad79249a6dcb21e5edaa5a7e2782b336159b7866d526d1dad47a41aa82d88d5eb67845323d0174a5ed5110134ed9180796e65276c79267cbe57b03dc7c67f82a830ea9bae96d8f42998dbc11f61bd6284c5ac9b8852d71155f199ac549c8693fdfe0449f62a0d9c9f727545d2accf9e1ceb4a208593a45c3925620551b72d676a659a78d3b6ccc6587aebc8c87b370a4ffafe6feb32f82b2cec4ffc9574a211f4546f72394a0ff7d256c9d940ae00b145d410939d105ff5af970309d0210db5f25fbfd8429204b7860ae6dc3a3db16797f47c035f607fb160bcb60f73265c5c051058b7a2a668ffe810fa37d4f76d4452b4aeabf76375aa7b68e11b4025333aced8f57f34d2bc11d930576e7d15e9d7e8993e5394e122b6a9f541e629010e22f5a28696c98689cec46c4ee5a5497171eaa2e4f722f9a063b3aa4f082a6a7169b9d674d1adb2e30874d78b4f04e65842c3896c1d6b1f350cd56914e15102b32387ede81779e620881e31f1f530bd39d5bb8277caed329cf26f3a59222b013932764b8ff646cd0f0f9bdaf1e3b38ecfd60bbb31a6899804cb9d5feafb23824ee8ab5a93ee3c9e83bc0e3e291d015fa204e307742f983f5b9db886e8d4fe1ae0aa44968d6d007dd15f40691c63ff0cb9440106f11cb828bbde6e9916406f79721c92d8fa653c5e9c0a9107678e6ea225d5473cbaebecccf734b350f1bd2911b9eeed3681176cb65103172e1ed6fa408fcaac1fa02940fbec6a111525fadd345df1cb1bba1228c6c4d0d5b7fe5ba6e7e96739e0b8db5e97a5a1153ff75fa6d6e88abdd63c68d6b14a27372eba8b3cb754810a1bfb807023b7b0ecba66e5c10ced2b44c54b54431e8a4e0f3da4cbd8f9176775d4d5a1cca24c97bcafbe681f58f313dd0a094c9112a72ab4236d83bbe60e0ccf4b9f17f41411f068dac7fa0f9f4d8174a34bdc1962433fb666cc6aacc310e7bca358041e3477f53a45315b2ac7e230b9bb36f11ea35e6a40b2d5412b1d36e5d6887a0a09ed45e4cb286630705c37eeca45452a8ddfc7aa7595b02382f147a0eb5b0b414eb20fa0b83d7aba279552c0d8b8852a6e10ac346851f8446bcb5346d15fc698f60a449774133151d8ab45a1981694a20ff2df4d67507a2bc1ce74a439bc77032323a86e14765d404144c8b90ad646d02ab48ed58edc49af7d2722502e427acb302be16de1e1271cef7d5d578e724d68385c8d96999f411576f5b2c51a93156b710324e19a7e9c99ca8de19258f033ff0ec22a80875513b39841d0016a204b7dc7577c819dcf46d0611efc78810b05795089eeea80cf7ebd773844f03c7deb5eb6431fd3fc27b0dec0e55eb9cb154f7fc1dcb4c9e68d8b7d7a63cc187df2781893de8545acb1963a1fe8598c14c522305fa64635003e70cf7e7ef3ba03804c5b6881e447e577506691b4d39fd27e02d3e990e358ea63ea229acb0ae62018bace2cbac3b28ba5576d74d77367e65567a88089011bd3511218e38fc96270b9fcaabcbe00ca64e9c7c707a933c04e0811f359b112ff7ae3579ec86b6d9e88c1d4195d242bc28999bc8c4f53e67123ed1a92e5ac505a389ed48d615af9b3d69ab281c7c9dcdfd319c3c4ee4e48f1ed0f17e1afd56090f117f1b0bdb985572fdf46a26f7b56800d4274ec4e22b42b21aed16efd4607a487221d7a377fb7f4cf586119702110d11aad9005ca6f507cb063595d16ab793d7dd9f111bcddd36cb94196fb1094c491d5d377e818d1589bd00849efc0d88a94038c8ea300073fa4ecab89bb3025d4b3dbf1ebc5f33f93e818d7df321e89f878232dee6088432d04b030afbda7d7a750b3d648fb94fe87689dab4e32f2652f0ad0965984a20cfee8a68cb8b25084eb93a9aff24a3c6cbf8202b2107926b2cca6ec809fcd495979a6e236b448f1d519077bfeee3e2e241dea43ece2fc4e5f8c77618abe06ea57cde28068197197700334ea4b307265e25a9d72c5e31536ac2104dd93296283cd5e8b6fdd37dade0d06b9b14188071ba99e9c3b0a271224965f812d9fe02a30ad7fa7098fd38028c3c282607ba8417a6b129aa2860fecbb86b0094c94ee6410dafeeed0116503c60982ff3957ce7548be370bd5b12dfc0737f91dbf148408ac7d4726a598a046a87ed08c19a65ca579a5c4fb215b37a82fa983e7c229e4ada842484f5aab29b13ef552b413fa72e61359087ef7937779aca8e887003aaabffb9f7184fcb466a91fb6a07c009658c9762cd93909f1d98b1a999bee450025f2e86988ff6327c561ebb5b831110cc4fc97b4d64ac5fff5aa44f30dc7ffced4a771195d2e84015a03e8ee2ae6b080900da8f07ac8970edd06dda8bfa094b521447cad24c14bec5692f917ebbe0e0029ff394bda3296e2d251341e72860c6fc8dc745f71693dddffd5236d72eca62909ebef1e81bfbd5e6fdffcf48512d525b4840981cc0fd89ee592dd19dc7c634571477b247f8bb052a788726d873b7f23c462aea85561b35c92459bfb1b5cd940bb16da8c82f55a6452042b7e44f105467ea7937c6286140149e6e326709049e08cf4acd97c74f2d6d2334f515f1663f1e4f04f294194f72c9857d77559b71b2171259d01b5eb3b1cb00ca9a27d0899a4e1311e56bb3a9c284f2929bd2a9a94ff822c443abcf206f42f76e7c2c5b22d3ef62114513a9996c1032b6b3579128396618685ff4903da4c43d0f155107c5190313a00a3f6449d81358cd123ddb71d963d3cd0ef8d7ee0d8e0b28c95ee87cbbc7e5f47838c8aadc831a98085286bded0a2d54cb948beb2112441a37aad6fe50368daad46b781eada0fd68a67ac58d5655610906dc7a1a5bb49cace9ae78b2431e7da6dc4a61b778fd5a4013fc4f763d45e848cc94b0ffc25af759529099b5a12e070b67f9a87c9c16047a846db5c67c208928b72df91eaa19961281a9df1f24bdf84df1f8c1b00ca8682743eccd860dc0a8a39119423d26a7af0451f1601405efc0087e2b7deb65e60ad86a269daaba9052be60e7ab3d8fcc37dd72930c1c89420ca9c7bfee8c37b9e104ca1e8ae60893bfb0e971d54c173d2005d7db5245bfe28055b9ff8cb738034182e34d47fc97af52e169a7b0ba5dd4c06ec7b836e171d64d965b9cd26eb28c4e486124b051348ab5eb47a4bb59860e423a2a95bedbfc618b229056c918bb00ded14c9545605be00a55f1c87d8b8ad26faedfbbd93724de8710073c8c5ed3a506652b4c01e424402fbc148fc8eda66297f8fb234c0504b37ea5da3ea08272c60807d51c7a538e24485f00b84bbd587c171dcebe87d7ca964e495a9d0dedaf07428686c89eba585c4f4548ff0265ab094eb695d76692313e8f413f30906f9ae37b5f1f47e646cd49706d6011d34d44d844069f3b18d4dc00abf0c79c4dfb4bb2c4317eb0a29219399273f55fce873c547abae098641c3930d0ff7c70b50a96ad889375c17de0be93a2f17032c2d05a66bf42d3bae3adde1573ed3967357d6b20f68c27e4a60e145a3883869f8fd1166b9554ccab301be225ab81bbd9ba636aaa6135f10dbf54a46f2110e0dcaeefbfb215bbfa0e5b831e913e1f937dbdcf3a7bd096eae69db53fd45d26c7c030d7512d17b5b221e32bd93fc1f7abc54f52de9d1fe10715a091651a67222f9ecf58cd67ee996aad1f85190277f8bb7194addce123e30b0a574a3925d01d635a8d91860db947347d3ed4dff8702c0c0443f8887e3f07494e6e28b584033e703bf318240d975c19e31d696ef18c08fe2bae77800a18a082ba95afa11248bae1377e2064682d5e4d1c37ad1dc6bf59fb413670d2d387489804ecc3e73132192357b7a995cfe0b26abcc13c632f73e45b61ac1846290610c6653d28d1c122418f6ef525b7aa1170f249205b3ffc5641158e13661b8d6d87df2c7aa250d03eab8159748ecedf8d149194e893441d89b56ce9b1ba99391f75b71f44d231a86cbddee4a59b84d093ac2ca43b2aac321175dd63ce6a1a16e54068b929b94d8c34969e238baea79664b4edd22c72a768e817d933b1f54bcbc009804263b9a1d8d079eeb9782658a4cd248f31fd4f64b60476fd14331e2286241e6aea5ae67cb07de24542d5f4886b1a1cfe207ad1fcab190c99a2950bdb7b7fcc36bd8e522f0458c4506218660bcc850a624dd9652c102b115cfe82c5e6ee551ce21bd039667cb4239ad76cef53e4ea48d7ca961e65d28475acb0813c508fc25b7357cdf7a0e682316689de09b7e69e45fcd5ed0d84e0f2a03e4abd7b167402efb542ee6717d231eeeb02f03c5fb18e0e4e95b22acf400b64d0cc55a65228639ec14604a2180f04aa6faac9220f0daa2ee5e0a6bb1d5ed9f620880e08021b6d35df7d9d2d349b6546a0229f000d974b5c4f909c7a652d7ad733be0f836da305c85de54b7fc4595b0a8d2c493220314b325c30e7c0edfdd3f7f0b48ce4124e4e1489742ec7b79750996ebd80756ebc8bf73e1ada921581030fa922551f615a2319bd81d223a8a253a844c2b4ce7da37fbf42132cd34ce659cd4a1b2125be2eeb1a527a5c178774553d2bb972699d2d672a0bf0bfd3be34d1d5f417e99b4edcc787beb84fb7f5228c32d3f571519d88e9c208d5e92630800372fcca437cb2867f8926a5c872d5945beb72bf66ab5115695e103ba5ff673eda68a3fbf04fd84b6ef2206146cde4c64054ca3d99d802d298e879ebac2df8e511298b10cd9217ebbce070c359a25cd01befa7cec42bb6cece0f3fff5549398341809d6eeb08ce3db19c9860a0408e0a218f7e9fbc28ed3253b8e9b0f90434e93a4dee0d09d4b13535f01095342bfb70b6ab7f3c3998d27dcd1f66c9bfd80fed41dd8bbc18d6a9a41418d9026addc91ddac034197799a626c23ceeac67cc324c44f547fee5b495134de18522388cde14aee32ad90fbf0afbd07d568af6fb52fa0009fe8438042ca3c9a9c36acfd8473b00b69bac2c55b63e56cd0a4fb2be2348374f2d63dfd6f49f4f47f06d61c94f31df9854cce5c129b535feb903709bd877da454013a84958792507e5133aeaf1e6204258af437e63e4cbff02db3413d3f09bc032082bca17a1c1e493abcbe32c6af54e0215c834069a932dfc0e4bd3d21c5342387901a50b20e8bcbae013d986f8b8b99603939ff66ba5d550b1a64d9f0f782713992370d2e7a194f223de89f387ff24b042b925984cbcbb1ffaf2ba164e5b215a34f83255714db839cf8365bd6d91978fbd8243a945b8ea6acf8e4196846641970bcbac4ee2a277a4e2e7a215d683e800ccb33ac284fcdcb2172f27633ceff5b307d027a16a42e05ebb9772e84bc0fd0f699c4cf756eefd6c2788bf95f9b51cf37a65c575e9c80cd526be930be7c94c7596344cfa8ee4db4d44bc11a48fcb2de877d153a5e6a792931171fda41492a454de2b570c0b782fb3e6275c75745b41acd2dd0f1b381891ca8d3a16d3b7bdc88109f3959a3aed245e01fdcbf9c9f612f0a7a10c20fa8468234ebc97b9aeb3c02c897cb73c7322356dfaebd540d9b4bc98d9702c739f6de3e0f9035f8f0b48ab590baaefb093b21022efbc6a9809faba16ca72aa467910bd4108bc012384e61a1407489c1cf209f7a0fdd3c4e76e7b7ca7aca2dddda247e272a0fc0da777e422b4e444bd9244082b8a68c80df74e27b508230256b6ab4824c70ec0a465f93f01738cbcc9d6d6524f77594c941f09e33da718cad34a862719ed60019c4f91427932ef2be568a4d23e5396ed542195550b27ec1fdefaa0421e16b7484a24cda6381ade13b0ae290e6330f8a3bf1f5a4fa958f06bcac37767e040c519244a0a2a2de672fe90cabe42ea3e79e111912abe085a2ba1865413315a110b03a6c06658b9ef6448200edc1d0355f158757fc67dcb8e3b160b9978c6b432b156a053981c894f99916ad521e443177b81390f2c79d8ed8f29915aeed0de1454bf79449255503dd92353539fc6f40967cdfa01a1c974b426d9dc5192e0ee4e6237bd9274f3900a7e5bd0c84cdbdb09ddfe5834a389db20a17244307fb3b3af2328c4310c6369d525d0be393e57cab2e52c03191fb0f1853ad2a0975504e3942f7e16e26ec1930edce2e83795638f03dd1f4279af36737245cd0210258f202c4c90608942b619c8606c74c422a29165915e193918c79e60f0d828e1070ebe332bb167ca93c3ca11f8a7621c964eff5a24a390156edfd3ad711f3e67fbcc9640a4aea2feb8e9d0d8f796c2500f683efe628e7f18cbc1f2fb2e8deecadf98ab7bd5b44b8612b7d2d4907b6331b880e4a83640704835fc7df3541fe755c578f56ef02b79a59b05c14b4e9dc1782233dc6c61b9749d59daf05025ce66d7ed0909ce3b5e280650500e863f76a03c68909500551d760765f71667159815a19eb4a82fb81456453301c790bcccc90f26a99f2858e5080d3db7963a743526762b5d000726e966f61b48ac09fc225a7463efbd8157d57231120eb4a961c54e0ff26ddf8893f121a804de336da3cdf350c89f3961ac4340b71d3cacc4041fd06a88f0817490e6965b80ece057e4c4cf5b41f8d7971ac8e3a3c3425a10ffe1269528cb0b78da5cc91a631aeae3366388e7427eda689a4786431b140b2355b654dec77c725202d31c4b8eae5032298993ff3bfb6bd85e67599e602d4b2ab29ea8c842cc9396f641a87655d05c35918b8ead6292bc1292eb5566b644636a14276446c73236c5e6177a60fc7be629a2fedf3045d50df78891f60ab26443e4fb13657a04d3d23aa3eed169bed10598108ba55c4cbfbd1d11db7105a094132fe2726e0ec9cf454c04151fa4490e973dd2aff8765ef24abb6933312e2ff8f80f7baa7d9e36abc57f30fa4e7e39376725afb38598d73a2b63d48683a7f6a051501aff12592d359c4626396b810d83297dc5312103b114b5a8afa552e7b1883307678a6e4374a14fd6f9f68fa3a7ddc8c80de7e1f98174dca839a88a949acf27f75748b037399f744e3468c0a48bc9e1fecde394712701554304479cfc3533f4b5038251109feae7314fba313ea4707dce4af4a836d75122948c8ea08931a2d033b9e1ea44a12b06b336c6192ad857c1ea7d0522a0c7974f58ee0b04159238a4595768af207d93a19115ba6d36083add2e804f6844633b02fda8e2e047ab61e6ef5ca5a79b5a09344f6b86b7e9dc4f966c61b1ca3282728c71508cef258da6bab29ce4929920f566f01d6c67be122f4225689c0b5b9737310ccfdccb90fc25175dd5345bd11623f0670ce368c4fc203ee63d06e869b43437df4833defa5aefa3ec12ab2364b53c56eb5e48bec0e4eae2ed7e23a9f18d11e10273cf497981137b1df279c85e7d369bc49eda2e833200008eb88ee17cfdbda5b94267e6b92c2ab1c3b9173e3a964253c53152297d833ccef04cb9634d94d678f9787eff2adff631559f553d91adbf368998e484c977d781222a596521ff5eb5ef68c0f2f4888ae50f7c5db49dcb55eb295dbaeebf567662594d67276c067c2b9f69dffe2c8873bd83a8afcb0daae6c67600bb18eadf5b676c301758dfe06a12d58c2f6715ee67fa5b2c71ef9a4124ec9af57d25e91b57a9b577926e4d36877b6698ed34268ed29c794a06fd1cd2be2c5caecb7d9025548f247f3c212a56388817d8950a2c55ba523475d6783f8d096486b84f56216677df3ef86a7c5bc187907c542a49f2b2c9077fda34b0517bb83e547b6ce5ca29d81fb2a3f7ac93a8e716ad297ce49f1ab7c77c8994d668f269095a7bf6c2d3d977ce9c8b702f717d81ed006edefa69c9aec6100f5c224890b3e1b5644d2334ecce5d972e1e11ebfc43c964ee7fe68ae36dc46bee33cb7fca372c5be64670bef90abdae28670f9b3139527b47b7d4291486c4b8dacff6dd5cce3b948add93a47df00365416a6fd7c153d91c6156582a4f9cc340e3369c434da8a5c3c020b7fddf2e725a511b5020e1d56ae80c7bf28c612ea77f23608323988d613e310f9803b66c77187076f6a44030857f8e1e1f59fecbe9b0df2e83c239f4896bd8c58377f14776e88ae2c24f07bce07dbc699966215253d88eb47557d969372a17976b4ccc94df88d8195a4012efc150e7483fae53c7000a655389aeac7d458b0fd6d09c40e5dce00fdd615b98404fb7095027d43645b03f4c77210db09472715c6c5283ed173dd5a4cb3490463a457f6f67ef1c3500b6e160eea2dd8374e6db3ded55552a6dcc29057040bfb8ff2c02a3330c7219da3ada33e60c77e86b82c44a74048badd9137ef2877c9fe95d5be7dbb7337bf4142bf2de1e1e841816b41259ded12942b6b2b6f9b6d684630a7d07597b9202b26b125637f0eae16aec28d5c0ae7d72bf8b9a6436a2ebac892cc482d47288ffa1ced162b886e94bb7f4223d4322a5f4ebb831fa5538a03b2e6956ac46067abdf76d7b09d41c107b63f76febd0884ddc5aa2d2c0b26a003afb4db3bfd4c90eb2f1303c5c9c49b2f519b2288b75bf5f7bc946150c7e79a7aa5655267ce92de77c0c51bfa53d4b92fe9c40a610e0566ab09e2049ce55fde44e5b88f81f9f7ef4727de3d18b856082f5bc601b1d9b95122eb3aa8a188fdad728683a0d75154b20b84774f5e6306830b6397ea3d909ea7b3ca15e09901cfa8c1d1ffd48277fb8afd2a8e432ed4d1a0bc16a382cf358b1252404eaf23718840fbec3db3bdd36fd46b6684aafcaf81515afd9f685de54d5fd67ffa282dea74284642eac77818d9803c3e406bc1637e46b99f6cd9a7cc101390a13b2d383c1d7b0a17ed047ef64231fee9203480e77354a1407540ab88b432a1a59ab7763fe6d7d2ba8129c2338b038d2f1022d1fd2d9df8c447dd4cb2f8db263e84c29d6bc9a4cb38e0f85c6a0075f9b4d13d27ffdabbea868c963e9b208f48938910df51f12707b6a164e9ee54284aeb7e6203095fa3626d175d6e97749d10886a9d6e95fd0dfc632077f72bc53c4474661fc7d30d7a26fbbedc3bb2e03cb6801ddd5cd746f29d494167e217289141c9084e0db837ff8983b58e8b9418959b4756b96d6a4eea8de3a605e4661043c95bbd7b6110d6a52127348734370675de952646a77bf77bf9074886f40cecaebf27cd6d780ee4eadb1a54dc7730175e90eee806c4a385d290e4a656370058862ccaeb2e25c4d456c65de44ced88489273f4471e9f6ce6c88447200851450783871ecc222873c7323aaf895c777be7939b7afe96f0f70d2662d5e85d69b72cf77d82e49dc030475f48725388afbcd95dda59a588e39320fc59b6d063dc1dea31f0a99498b0e498f624cafc65e3b066766adde977d1a102221f4dc91ade5f9f8d1712cf1b7f2d4647b51d33157cfa6c5d595faa0c919c64f2340dc64ebf748ecb66085c262992670e9c2a52101e4435131c94b1b4d8569cee4a2cc3031f282d26a1eeedebe34372e2af6297af3a4abde6c79a015dbffec2ad267e73aff1f0edd3cf71b9bf1dee2d1b6415700aeb3f9ae84977a4b2b56bc1bd5b009ae2cc9ba13e74fa251e94bd17d9752b4f38af106667590f7dedbc9d4cea31df6ba8ea9eb4a7733db50cafd6b79cb8a9c0b5a63eb93d6142d4050c34e580c18a7d997c0dc679076e1b6788699ffdc677418ee5470ca7dd4075c994b7584c8733284fd374576f8bd53be7a4c80ec4cb4b2ddd71d2cf9cdf02852ba6035704db2ab52aed00916f6d8cacffb91f7d0db184baa7dc08ac6b9d7348b9447f2f33c8c04df0d5e07e60650f02e5a9e1c8acdfffa62bab73c3134c0674d00dfab6d26d46d8120b805968c2f731ccf08c8e7d78415e02c77f015dea63871beedbd2c97a0ed2d8b7ec3b463db95cb33d04b08d461028c123df6e8194b2b5e3504b5a9f81e1b27b217fb239faaea2c47ab494eec9432aa5e9ec12786fb3a61124c3f27e095de922a96bace81c8d368003fb97cb8821feaceac1b521826d3b9de76f079ae453ed645d6c4f3a00009cbd4a9b0672c6ae5586cc2fba482f96901923bc1dcbe4e846c9f6e5b0ef71d012aae8a54e978f9d8e1db5e24d72e19657ad10dfe3cde91f776d5f23f499119d0bdaf63581a01627468ada16dab7ba76a88cd30f42e7e0ec25d74189c3612eaad30ca574a88fdc5bb608913d18f1fe1d4c416cdc734462d847cda3446cebf646288dff05cebce16edb981bb50f228924478bbb3e9337a75be68041803643cacf2b72327d9d190622de142c88488d0ac6179eca84d743dfa68f9b3dec4661b01b44bd14f0a57e371f543e9605ac5b6d9574859abb5f8b6d4f8afa3e46d6a5ad784b08d4674635d4b925f0d5fd3c17a9c2ba174b514d6cacccf9bbb43a601cceed2d980b96c7c4fc023c05dceea91d8395a14383319978c31c1173ceeeaa1c6609f1a2b9a00c7bab1b8eaf703214bcc1e83b7ccfaf46560b30254b04c142b302eeaaeb2a32cbd654021c1582a7b085d204d391364ab751e846b66b1815a3d2caad3ee225281e85904ac3b5c80e390db1b56990e6c757384bf945c9ae78988a7d56a90a3ba0e6363e12ddeee3cff05e1951cedf14ead2857631c1ee378c8ab591f75ab077ce27590278d1dcb354970ea58c6363dff5be615541e45fbb16027b9cbc93dc5aca4b10eee4e6a87a8f9eb68708e339b35ac7f8152100d283a12a400335c275bc14355e0f4351a8b2cabdcdaab68a3f85f38157774e1e0a65eba9ee286692517c83de132e0b14e06a79a65aa72d2c0d48b87f6312543c2fb1aa73d306f3b6c1c86e1c5a957312b0c6dec5f3694270cba7aa4290a1ee1c179d9c3e1bb17d2b3e9acd9507244e52572013cef947d275195590a2040396b6e8a26b5db9acfd2bc316e90d3cd9c66dcd726bf4897f5c3560df8ccb75123db6b1df09f508d387e9c86912ee6784c42ca95a76b770b95b014698df1c8aa348a0d3ccc9f7e015bd8a6fd76ad91a7d1880e015cc7ad8662ad46d38150fbd4246d4a268cde3001aa3b70077f488ae3ee3d80c1652fe63111c5410c953e6d50c30b313a8160345f75acdb59ed3612d64350e50ac6094b367912dccc94b4856ff2ae279c1e33ae55749b924299c6816ce21555df5f47280a7b997fe7cfbd8b0f3e9cf4a5f033c67e6661f69985a494a86a54f3ca9385f11e81eb27022fd32dbb527521d1551353dc623642d7598920b5999c62edd2b274b099415af2d7adb0997a7d7c51f32944e24eb68f1c0c49b06a6b0f4c2b6d763dc4d64a4f43dfb39a4ed5511155b1f99fb6a6f95cbca5293e76079bb51c10cd91e784dd565ed0b7d69bb7a0294b3f65aaf8eac1cdabd447ae01d52439c799b934a06365913e7ef2ff301c3763928fba43ef7534b10c4ca0965f728327a68cbbe78b694039b814eb44cce7d4e64c7c1f737e983de8210be279e822a310a9ba324fb329023ad8c4087e6036e9ff3090be557c6c8d2a72ad1c7675417da7d175aa6a1abf544bc0ce4522da664e4b72a8ce235d7ecb8524abe810c5b259b21e364ce8f201fa42ba9d487932ac379bd9818665f9221b16e30cdc49a04602a7120f80ac0eb36210f056e980196fd552690d40b8e6ce85e70ed666ee7f1d619496ff22b842cf3ac71df31d61b052179f5784b9000d6403e343337de22434b72e2589c73d0c95ca1317a91c1967e837cb20e1f8efc43efbe13ad2692f68dba9c4a78131d770c78294f6902834cb4575cf9f9295be29b8a0451d32ba1ab691c61664f98840c0f8295dd7e297844deb811171e74dc43658438b0354aaeeb7a7557f289c2b8e321d094b169c2144e28f3eee92e441160a0ba7c4c29e27ec71a072b14677f2642385dce156f14199f7ae98a2dc935811c8fdbfd8049c064d994c29797bb25975cdbb67ef9c2d06fb330d1cbd433f3083cefe872eadb81a6dd8b30f7c383db1d6ede4002295641df710dafc973ff02ffeb1e8a406b9956ac34f1465ff24d3ab392700ac38382579e2ffb286c175cafe8b60b2de2f4bd8d9a5472aebdbd703728b19cf77eba1c2048d03d9666366abf67bc273e84d697c8e3e4bb710aebf828aaad195eda7d479c4aaacf15d74de6ff6192bd27628c9799d65adb72d1ccfe9b745c843569f643ad207cc4cfa814fd1bc41d8101553877301a3cd5d676db5b04442d55c78bbee1548a3726ea8211711a8bbaa77e76453eaba20ac76f6eb5624fcc891b1a21c9be13bbe0156e96e16287651732f7bad295e0c80a16cbe66c1dcfb1389e9beac9d6276031db47d085bdc3f0a0e40fcb2420304bff4866188a882a657ce27b1df1ef40423039619c93dfe80b39b94b6f630cd0008fd937def808547c2c204677b10a3dbc9f872fb0647d3152b4e7460d91be7570be76b78a9f6541fb400faa4587fc3b0c968a43b8b09f072a9d3c28f7496b65b4b10d5805700e26569ab068bf3964e7ce146e388e218ee7b015c768a4d62e0b6e63d34e33490c979732e825c7acf3d79ba53021660eab23262bf2610abaca282618fe3d3ede9e24c6534e9097bf13ed2efd2ecb477eb4116a838cca5d770d366bc89075ced07373bf3111f3840c17e5c946eb282d90852f22d794aea12ea1e8bf0bb0ee73bd82794f8dc8ad7fa3d7ccad4a31b42e2b66d0a625c90b2ab6005706243d9f1169babe504f65a2cf57fb4a2ce2dafbcfaa0e061f6949b7d8abd080bc1f478a3bef9c9e3c28c4014d414821e74e9850db04dca24e56f2b9efcceaf03bfa0f4ff3894a1ee0dd9c3fb9e5a687263d81e754b1b39b1670500bca05afa4ff916b1a13bf1e943a9c269ccaa4b4066dab994887af4bbf5d4597da09d72a96986859ff6f799d222eb5fc583dbeebbd32ac072400660a04aacd3bb3a9e4a5868dbe6d858ae27dc43959d5447795529ab3f85ab3d9379c92bb05cded9540a700385c29caae03fa12238c782387d21f7df07f8cf5f3d1c94e9b73aa3329dc06c8b9e9106e9cad7c0908ed4857a4a6daaebdb202182fb3fdac5c47a450ab51d45e7884bc1b3054024cd207b6740df3c30fc6840b3dd032ac622166bae83c71738e3170c4e79eec88e9f5732404b909f953bc47402ef44aed61ed71cefe4d0502aa56db09c09811041709eea9e8c140729a1057cd6ab57c90e9f1d5436760930ad9a867c5ee4ff045cb6e8b6dfd428c0739f3b825dfd37ae687db16b1a41c17b7c57f8bd2c34e522d2e54c6c913f9851d0e84c25a9ca9caa2ac58b295b2ae18427d46bd96aaff507e4f243ad4e91218039d08ba3d6bfcd974947441976a844225c3a3fb019508ddf6147504a2f01521c10be8c05978c8bdf25d6aa227fe69eac46bf7b2940783f507b7127d79b9aa90efde1daf6d7e86621a76dfa992bdbec4d61223764ce375e7aac17a8f467260b7fd74d6cc47b1811c4a365e8e3f6f6d0a2f9a68b59be2ebd9fc3cbcb773fd87b8526a7b5b19888789217aa1f6d7edfe983e214188b670f9b4c568fafd5338e45f01615cccbc8330ae531fa8b6a2435a018a28ed65937b6ff1e593ae7d85dc31eaeddde5f16ed759717bb676b9fb30843ac28d751726e06ad0108a5bdd89a5cf9df6dc3b8f012d73f023ceab27d9eb9688a2189d74737f992bef1527e6f92a8c12b6663a7a57553c9a8af3ba94668fc0c4d6292c5065b39e04d23e88f9dcd9081591a37a2fbd6059c550c875404f9d0ab0b45ec48ef51e575d6e0805cfde7134c3dae76fcd894e8c7124cab9f8ff5fe78772c004c9ef25eeb6f81d58d3a641a246a846d431c2904cffff45bab4661f7fe250ada0214d3bb38b5415298d716ca18a75348545ac570a8de125767e28d49f4afdc20f0bfd55966afdd57d8b1454ce2f429de5e25fdb1f194cb5d6ac9b639aa96d614dec5e0889d9176c022c10636da687f47fee90bf4bbdcf03f3417328eb0fdebc0b7c6d75ac4486eb75cfeb90696ddc948997a50a98fb83164aa0d947ad22142c3b30a0bf117d99f56a2917e992db61b2473c2a944f46b95dbb55a65619226e71e7b3285b2c59cc7a16867c3562f960cde9aa55d582580c7bb7fdd8aab3ceb583c9aecc4bcd442b7559f87750e5c4a3248d2edbae15032a70182bb544a090ffd4f7386cb12ca9a19d2f4d90761551144b0c117793535038def0ce992580c451b6d33f22b67962a156e87be5ea5f71c726c45d28533fbdfdb2a2d3c8e9e43f8cd4426a233dd7452f0883b0050185ead951f6d22bf3b493733007a379975fa620ebee785e574c887b3e32b1217e63f3f62d94501ddbf00cd63764873b3fbcbbe4156002e1e84b777c18514543abb0f904fc77455c85dc0f6d1060bcc6460aa80b34a22722cb09f0876b6d60e6734708c9340e82ecfaa89b95b632a6f6a364675b321ded9c441fdff560c2623c6047e531a3aadde6088fffa02113039331154d9337e0bce40f726d17e38773b09b1bf0b4152e4f305d458589a3dddd6a4dceae28df0275fa3634413fb099d0fcef281c6ba5e95b9220a06abb4e86e46aefc267b0e37262f212ae371f7fb6a7bd3bb699b32f7cc9b02aaaf2a1dd59f03cdb692202251ba59be410de8a1ce47670186940ce6c1926ecb61aee4a6c11095494d05b059c8f3c61d020e6b8b09b79bca6cb36ae67517f3e9b302c5e5284876fbab65dad1a65a8cf3a20f6ffa5afba9eb0efcc7db223075d4a48907f0bd1deb8fa6bcaa18bfb0d6b298fb64d0482979d03d7bf6d7fa5fcc6ee97b4446dce04cd33b43a709fa1c833e929d13f6c0765b67ec38aa42960d7e91dd5590258844ea7c1b7b7947293f1b5be15ef0526409b9496216645d63b09c91db1b6fbeff3777277b3ff1341134b6ed7076c6dd8e579ba22a9a0a270860cb40db7aeb7c781e95d2701e6b75f7a14e52cb107e7cc59350118f26cc5fa5a4859229cdee18b5e744d3fc586926fe1ee38ee0417af6484eb13df6a3d80c15ed67e9bf4592a508e3592148aa5230b4dc6f9276711d4a6a7b805cdf52f0c96189fd3b8c5d1e039797f7418a38983b732e36e1f3c090fa7d117e2e403a8b559860ad215a9737f025b1d948246ed0ce67f0344343d77886a4dffa29a59d427df78b1a1541ae05a7d9ff2be1ebd1a5d1221550fd3365f495eedff4622527ee932856750a719312a41928541c7704140b64e55d7f78ae958df76eb87cfcbc92a3a0b287c180260d140f51a541162ecf2d51b65ad2d3cd449c6bd0e4657204436dd44d8fdd9fefa76cddfd029f22789cfb3271e2b870794b5cf8f64990dd2a1b24c8a9b2ebc58240f140b386af85bc20d3f7e7a6c2e06f81d4ed4bc46b4cefdb2db406a7f06533e639b98eae3ed14193090a2714504c9dc7cc7ab1234b9bc4e27c0efc284997d5b00259a45586ccf19f7a49c7b1b8d5dc22702c462c78b299004e3a9ced3296d92f594574f659b2bd568f3e1dd8eb42c15ffb049f79a078fe5060883bd80df778036374f1a3dbb8a8c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
