<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ba8c2b098bdc9d0594c8ea99ec87c7878b13ab7cb0d7dcb216a76a032a76f849b070e89bdd9f5a8a18f8e1b2aeea701bc1955c2d8608be11b0d1c1ca3f999db8933128017646f16a02339c5d8e8c64052c5033c6b3e5b4c419e482d7f2bc7bd452ab044fa4de99589dbacaba21018c985353cbbced8c863605568f0b75ec598e6872c58bc55ced0fa02672dc7e9a6415dc8c623d04adbcff521943205262984bf16a56c3638abf7402ce8493ed38a9274c6638c412600d6e547cf7bbff1d56f71f663966279499e87bd605d71af1c1dfb6e209459f1d3b9ffe058d8a6e3da9094a1d329ebbe0950992dbae00c9ffb2395669db8faad82bb21f491e3a3f8a882edb45130602a16e99fd7da85fa0984bbf0120b7ea5dbbd053035d9d7bdac47a35821b1457183a7b3be529c907dd05eb972ecea3c9dfe1ef9845fbf156987c62b0563ebacdd4e2746b155eca0de1c7a8a550b04f68aa62be36558c030ec18219a0b11f04580e8b6ef50898a1912df24edc0a3358203454f5b9c7117269441b9647cef7cc201d8373d88bbd1038e69f3c55ef81f66fc09dda41417a52065074c18f38ef2e7f3fa012ffbd2d432c38413ab38e9df19ba29f852a59045b4255ced1b7c7168807429b906db1533ebeaf29945e125b6191ffa21bc8f9aca0476fe832f49f7eb178499ba8011c3b111c655781c97a5007c98b6bea0a48910693f04dfd11f3bf2edaa79dbc830b9977204ca939f45f70234382dfc3f2a68710f9963211853d31c6d79be3e06c304b496fe47f3a9b638a4b501e0d255192c9729e6dda87b130b59ffca6d992afcca4d05d3612d2441940890a173d45ed3cf9e2bf25f146af69186e2f14a39ae7fd7daf61f8080fefd368635649c79eaf4846d22ffd9c33fcaab6849edf410ab00766bb6a623bdfdb50581b74bf05f850ce666dd34a0c48f0057f66c11a96f61008282a2298ae63b1aeb9e84fe06413ccc85bfecf220f4fecb6fc7c14e865f179da50ab70ebb6eef8a854052c764e27c4db691882f06fda6823eb62843b8e872f1e87dea51c8d001471779ba99e63782377331073717e85b2a11201e784cdc83392656b7df8ada794fed18de5ba029cea91756cbc6a3ce1ac61357b21bb53488aa5291ffeae876c122a2aaef52c54ea48340b86424ec2cec99d9b90e40de3f62757745fb1400951adddcbe6794d4dfe98c7e9917b46b43b7b89d27c9e2a9868fda5ec76443ecf277379135b119265a542ebe30a15587c22f55f60cc1fdbfb19444c7f14ae5e215e56ce14b6b4e91f3b2deee292cff26f5975ff28fde3711fc3877432f178e1220a5cf1fb950e5ef6d606834e25835d8a05611722d0553a35d9c3ee5e5bf236eefaad4d188ead1cd8310a6a1bc693da313b44ce4d02be6517c5298e248ca7aa9a8ad999e9691169e82c246311c54e91c3147b65f87dfa50216f65cc11c57751711b4c163ee73e28b1e3bd85d19449fa3ca0b3f9c0ff76e2e75c03fe008c4219a0ceb2d6927fd73beef025576a934932d299399e0225d29d617db1007f41dd8fd61d32eddd25b039510ccbc84c8ba0abb922d2a3cf68b2de5829ee4a008692bcc47fb81722df573d9de76ad252e7d8587627ad484c2cb614538a1c37dd067b0b337b5338a8bd2cc8fdce3736be42c9f7e51216d476d4690b8b6c2a9a69f1c47723f0102b5771cf424b3db972e64e8715df2657495f81ab74fc5cc6b0caa13d690b17aa95dfa055968dc0e57f06c76e94bdd8de9c14ae468ffc7de6b8588c7bde884d477245f055fc724e4707dcf5c2eabf09779ff1a047b184baecd34d79808b2ac98b83ee060a22b356425c8371b5b3d105e57d15ec2bf90c71a73f12eb66dd31a06aeb65a344a54ca853b4b23a8c0dee86bd9ed010484566ffdc2ea6b602105ad3d726126e14648d3e98a5c08e2ca44e39efcc9b562b16d225eab7e46423df3dd781c797b263547ec19644c9d9ae509164fc34ddef6c6656eab138156e17e8cd45d699afbe19be09a5a7a61ff399317f9a36e07353447119bc89c45731bba16561a56803763bf43ae435ed98b0a40d1fbf86c8dc24df2f061d0d1995235a3767f6459628d2279c1ca2cfd49984c0814a5f81aefacde84c1707dc791842324543c43809cbd958ba7fba6e8ad3973ac4de00f977a1183ddf884f037781b9e377b7422a483de5c7f67eabbbb068bcf5328e69751ae1fd605599098600598d8511042142d1d18faee7e6132cadbaeb6c45484bd2414b50166c05c947b7353987fd063c26965e3bedc89f8c59eead445d234fdc0099f90229e08c305562c74dc21ae885e49436590287630f7938e1684abda4e3f274561c72bd6d2f5d27d433844c52d4d517756390346ae147efe2e2b1c603b60673b07ac6e7b4a1aa4cee8a268a30f2a36bbd5cc59d0b6ddaa133ddb7692e7fe9924a33eece47e6fd9935aa63f5573500335474e2379751bb86bc2c3278727035f51dcc2e1ab81e1309edc5a236227ef12466a9d5a1e6616aa623bb16febc04b5aa8822f9a1aa23c13559ee0bba24ce7dcb720175787c3ced05bfa168ab010560a2c471f11002d36b55cc272f8be8c99fb73263cc3ddf0940dc09cac3ff50fa91dca829aa3aa8592e0e6838856089c5354e0c9a60d5bbdac1e2812458e50b574538d20d190ffaffac3986422e5f9698e01b137ec6410923b4f0fcee55d70d72b354e65783a69a4b93d6f0b9f1a9ddd6757e204db5b1541d7bf2155223511dd3bcb2a24945c1707f6e4784e32f8f9a22267e2db6a256f288409052277672be4c7997d50272143c4a60390de9f96ae95c5c8c7352ce78accec1f1d1f66e6da0c647310cab273a5b7ddb996d9d60d4f6e5c68e5f9ce93aeeff8080ee6def3d5d1800a31aad2f9f44c44d9559ceb6d24a0547711124c7b71098b7ac8144af88bf6c80c0f95f621d4644b5f35da7e5e67a6af01d5f06888b90a5974d10efc7ed7d71ca92d390b0d07ef1518ca3049c52756b8628c4fc3876dd2e24e2de4586589a7baff15b149a3981da66005ad5a5c81a725c65880f71974d9d051a839c1c4973aa6b8827eadcb39a052e32e1a0e5a5f37ee1e1f27ce7366ccf21c1d92dfb5f5378a1f51da2a85d1ba69e1235893547e1193dfa2fa628aca49261bfd50afd414ea2b3b4c0470cf66b580ae73c0979aab848b64f4532780d45ad1409aa18b0ccf7a6b97fa2c6be78a6c6bd45104b681a19224cbf69d3877b7d583aa53cb6010cc95c1bedd93d3bd75f40968f0df2b53ebcdaab0c253c2acc66303a54e367e03464f3f6758c0dc20351f774fd2dfffc8f44752611417f46e807bc0e7978e83e6b852c8fb55c277d4d134a2c3c3d85020818dd5cee71b3ad8951e6cabe8825d38cc184c26b4ea689f44d557c44fd6434c0040dd6c4006322a231324ba32e11df9c3f8751e5ba58f21dc715615c4c5a87e442310d96f6245616c441170a064a6679cf888bd0b87eb595d07ba8aec5c819dac24e10ef6888d1ce27b8156b7a9d721ed40c101f33423419ccda1de84b7d1d11e1067cafffb7f42fb2695135d00840ef9ebd1b8677d135bfda5f9a8239cb436f9fe24a006c621243c5ecd543608cf8e191464ecfe67380c3550dcd094153ea034ffe3ec8d1db2e6e8d9bc71df94e79350db100968bc6a907abdfa01123ab3d04ed93cf106fb2c1671ba582638b951a7849d46c0077eb8daeb628cdf53dd91d629621ae41702860e72a1e2822f693ba279089fbbbfb5b3ac3c1b1c17305975b0028bc8f7d09f401fdcdb6e02e2ab00b729ea65b3d9bafa74d13a11803b9d14d52007d6f2ab7084e087a7c82fb4c60c917194554e2746d67d99c544cbb91c29d78ac18d42f5848bfd5e75e1d2a4a7bf097c3794bc74ef05ae1c81b0e53e5506086a3d8fcfb41babe03b39221e457870b037ebdef1e6a49a3089431f02f539d85a06dc1569566c570fcc0d78cf0108225cf6207e8675a32ab0cf05c87a73a77b9a0266a96f4c363462815845a73d7e31cc7ca802b35066360e95b72adb11927869dd15da1bb9c7dbc91b14fbfe6a9d149b64a6063d96fe81c3acd7fa3d6f39593a518fd37cbe70518907a79b0168a25d13129da5bc2fb197480897f3a85f3d0168ae62125384076062bc9316783157b08f1292833d9e0ad06edb9a36fa166acbf241374de5e9e71333824a05bacc8d08773cd87eae473222e1856c36aec595f8a1fdcab79bda6873da946f0907bcded54800037db32ebd064194b1ab18fac21f517c9c33017f33db5d220e390b9d2da111bb7c2dd9414324464f511c6e21878bdc34f6730f5b99bc3618a5c40202c20ddbf875fb9627867cdab126a5e72433d1b06c988e44c59bcbd341cf4c404be62e38f19887157805d86a54451ecc0ca9ab53375dc166036fb6a0f2487a27213d52463dbbbddfe2c4dfe43a4f7cda592371eaafc4b2290ad003ee0bcb2a19036754b3d0326d610c98963780a02460cf2f4f7b324bb2f56eedc77439a3fec54708c41ba85c93b75b9d8018765d097f47bb26204fc20bb054c17c8c754c6964b366664432a1866b3967415dd888aa49e45103d889db92baf5f197ab73edacbacf1abf016fede3c67ec3a575a03c3c62f1a2291613ac85946e5758a164039bf08fa2957637989b6b85c76c786cb9d920d1f6eadf62395f07eab950d7ba505d735e67363268b263b5ccaa07a9b0c1d5b2d6431ed51eee8eccb42043932431a67853d55889edc2112f883544ab24ceb734ce042023e99901e5e546cc6cabdf8e806449052403bac16a7acff84707b0cb8ffe93dd6012ac63162dad671837de42a22f0a665328c9e0a6185c4d28972768b342160a3680b6126a90c3c7a0a98021279eefef266e7b6c9d9eb46be352d767f3ee31e05e6f3498f089e93be27df20d5b9bdbce4effdafb0fa484b71340c6bbbd34674aa7521f51b53e004085b633a026b11a93806ec64271e78f67e03ed59793c3df3ddb1e28abdd4424f7cc14db74a318a611669ab813053673be71a0933b98f1e52d163897598c1b18238b07d3f82aaa659669c2339f654ee8f69b83f1401e203f3e6ac260571e8a0933a4a3f5f002c3758f610c355b56abda822b9890c872f0549f1154bb1f2b404f947c5f6ec53349028c47c1fa5eb435916c4a448d3dec55260bf94c14ef79f8cadc207a5b13befca907b6f84182b417a614feb686eea2afe4fe8932f6b538103bc863e3a866c3715634fe46b43b1ed5942be24b57dffa7e50819801f80a8a526fc6eb66b50acbbd64eaf022375e95e015d1bd300a6b89925263b18806fb6dbbc5893f755ddb3e330c7132a97ab4a49aad1bb7c93e37ad0eec73c02c0267885d6bbe2c022efdfff111446fff5748704a66a5097fec6402796a892c345222a98a1eb8256bd36df6b7e675c0d26d1f747024bf0115dc8486ebd4299ba7294df0e49e9cd4e918520de00af3520dc95734eb7c780b1b0a2c48ebf3a7a6a9dca8ab1ae77384a341c8edec35c3b0f21d09cb2f3415bdac4d1cf7eb6ee6beabca078553d17db77aaff0d4d54d10edbb49b100577ba059fe74a51d8a90cbbba88a15c7008638a3648ce52457c63910b24f988a142aed1ba52d09702a74bd0aa1175181cd66f00f5f1d545aeb2aad13099fd945ee6d2b722322572118984b2ea3e106572a35dc4f2d8caac0ee548a130db9b1657933c8f5b73c7b149b5b879c0d8667f9f2517b8de9e9550eacfb446326d369f10d582752379ce1987937530187580eb8a58278d756618c20d1b485f5f2dce0cf756a6850e7c7b5f6e8a1b9539ec4b2f74a495a6ef2b552cf26c74891067189bf2fcc15dbfbad83c37282dd8cc374f1a1818ec8b34c587ed79242b44881748a0d958088c9e050582db0313c554b57779696085826b7d03d9bc6fda334b136179d45c7cc3554b0a6e9b736cece39a1a5bd39ff84bdd63858593a683172d19f5f2a18cf456b1c36052f0a7e0497509fc41d2ae49c5f579d5479372fc5f1073b20166b03897eee136132eedfc1c2c44a774da470188a0c485df753f10f012f65d5637851df0d71f3b1dbac5425bb1882afc8d7bcb60af47cebfbf37cf0d9d70ddb9aee62a310590139103c2510700ba3faab537d7afefb069558898736347b937c1d960de425b3c9ac88cab0c37b91a8f4dd4668f5714f8f5adf0bc743b97f5b7ee2952cd17e38d983fad5e0d031f8c435e048d5b540016ce16d6e2efa1737871b37510dab650b85f851157bb029c8c7c7c4b6df68ee5bedb0b206fce2c5f50efe89149fa5d38dd16cd9a6a9a7f75daf9fdb8ef5712a424eb4401ae3119379b16fe4eef608191ac0ee0115890d54907248ee552597895ea0662044473832e8f71651323b3364efd7901a8ebf3a1076141889093b2721376326ba6f719d8f7cfc2802ffa3eb24d916c66832f6838b46bd963122ab7e2d034708f2d7fd5324df30563ca01ed1747f7f3710f783e469705a8b7105aa876a659d369b7ca48ddee8622300b7bb50b22b18340ce344de54461234bfef548fb92ba2134a2478fda2d2ee0a7eb9eea2d51573ff0944366bcdedb273fbf9ff52d7b21d1c06cbf7a0c039987fae58ce07515b5acdb545ce1ee1d867c6c49156d85544963ea409bd4ff3b5c44492f5ccfe40bea80deb46db9c1444fb7050bf799730968e4b70b05e50df2b0ec0ea6cdb90109283682d1f072d0c35d4f0be4c6979ee2d3ef01aa03745cdb433ffda1d7f7b13b8c33e21e3e2df832fdf0f32ba5e35183761c7e61e533fe5c610fbce579578b6130b868ab152c3c8d85d20de50de5d18c613d67ca8eb1a8a64c9352f08602d0bc7536bbab7a341dff809a262bfd6d750b6c2645199df80c36050b39a2f2544778a8aa6dbeb3980bd99a5fc5b1227c69538137812a382a80bcb01ba5e468ff1612b7cbe32c03ecdbff4ba0f23b2725cb69bdb1686f854c82c6f4497b62d158daabf4091f8e0bb154f4a70a6fd2b135edeef6799b0f24fcba79438d9815f33c0efdd64349aaa32185f2ba450c39d1f801d900cafdc75e0a74f8296a4772e1ed9d169d44737d1fc8abf945e81c29dfafa3cb46430e92e50731bfc4cfea94a7fa005fade24eb0db3e4ddfb6acba7db491d831bcafe1167a1ee39ffc82f65a6c5bd3a3787a934a5d25ec221671f35c8f544a68ad62340b248076f7464e4fd309b7a46c1cb8854409334e68ce5fd9796ea325a663ec15d894d6e4855d67a9a4daceeb310084b83efe02d14760e6ccca42cc7a3843a1f380da2952694f617e5b270413bbb280664a3e8d53c3a1ed702da9234af32719c70958c8201c5648d442cf027be7a75287bc4a3f0339b1c29bb63125cf1b9c29bf0945cd59b2dfba57f6fd0efdf19f16a71895d4aa17c4a9432ffcbb40b31ac2059b504ec81764e952978519a0e3064a8b63c3019c63e6d94401a5a108b6e417329bba032499386cae0e569ce957433dab5d8e8a409738be6bce7522ca19a0473fb01e64642bce36185f626c1c8ba364105ddf306bbc8df4d81eb7d2d240d2a65458c1c25ec77a16b4f624ba3b475cf3b620f38bdad713f3350031db309ad8a0055fe4b57a0f6d6b7d22d3a2b1f0fb1feaa5797fca0e6e29451e8d5f5cc7d0f031525a7e6bf2dbefd63bb160ba29e01ebc267cde8add5c3aea6ad711089df0919c4bef8f4cb8a2a9239de6038f4a9341d539414386e30772e5fabeb14790b0ffe989768951edfca36eb2f1f23b6445b6256f80d26f9d137557423fb4690dfbaaaf876d4041e5d9baf9dbf386e563e3b53199a7596a5e6bb4455138f8d30b09c3f3f97161a7b597252f4d63f66dc8cc08ec1ccd24502d47bc577a91ddfac584c26d73442077a620d52465b1325391fea2909cfba375e264fddf67d94c7bcc1610b154dd61f84e7720899eeb6e4cfcf176def529ab7dcdbc5075c24c2066cfb1e19664589ff672f7fa2e5d7be7439cc4e79b7770ab2492e6119d42f9f8bb41bd617cac53a01362a90ad322fa3136787296a9d7c80f165da783fea12f953fe6bfbe28eaa3589f36897ef42fc69465fd2b450f62c90386a5691379b3ce52c56dec52192846e05c05331b77fc328e5e203054d823c45a30137fca1706bd0109e461f0513478c58aba186e5511a59a66bb1c125f029c3f7f2b986d61df8f8cd2b7bcda1b9c85a55eb03ce4ff085065316fbd7f47eec2c8abda0964048d484bc277c55fc7030b0bf30deeb722750e4d2f1c11c65a887e102e194f9a3243b647f68f86431b72a4d0d06e287ebbd03b415ae7bebdc7e63b0e393c1626e44cc1154c5eb0810a0958eac8088e8faaf9ff72e1da99829956cebc6f1ab8c15d47e7982f0c32cd21146be8a7b742c20adfa86778a37f9bc8e2d699fe8fc986e4737d900e482ad8b9b4b028fa70873a29d171fe3b4ffe45eaf2a459146e8ef0ff03daac1bef05bb98ac0ab3a82208c3979ae621c4c683ca51f72ce337152ac5caa04788631d9e9d8d3be09d70ff4f155993ca550458fb3dc207fff6ab76069be6aa83c30944c1e4df4fb59fff745702c536caff2694c73b276195558fe69c21fed3efb150e15d9fd48888cc0efba021500298e95863cce6908d115248638f3d80d4a1d515d5fa7ef82d16781687fc9ffdfe8c928039ca3d531d87bb79fe299eba3ceeac05c75e35bd46f9d1467b6fbe38aaa28be760ab9825a91dc22a2ea8504b7eb4de8250a7faf24c4d10972eb28b8fbd6edc02273f371baaf54780f07d8d0ee2c83d7d275acbbe31ba5cfe841cc9228922d73e4dee4d436826f38015b6ce497ec2fd56da00cc80a321b688230c435ea1fa9088d28243fafbe588bf55c495d658bb9fcce04ead6754fb57bb72961967ac86ec80052c402c7defc4db5c0fc95009390089ade751d38d6ce271511f78600e14da8dae109969d6fe00f835fc83862bc8be64e1473b40c7b0ec0fd2f169fa6da2796d2ddd62977a3b6436be992813b9ff71fdccc590ac5a1b857c31f2a3ac9ff428e6035e05fda2e471f1474ce877749a28ff714902d2d6db06db40cdcfe989e11be9c2ceb27c9258578b4e55af951279f604fa67294b63b66dde7867742db5e7548aaec14420355dc1b401a576cef67c7fb0ef23f08f17eba786f137ba13081cb0e6055a1d1e9c638de5fd9181aba944be3076f0bf2c49898831def47898a6bc496f15ee36ca5a2a1ebd79a70df6c720627d7b30064d143ed929994a6aa41410f16731c3d0f8b57a17c8d749c7ddcdaeb6d1f0da1d7be5ecac2e1b8e42443654e3999cd55cb3f801f16c19a0d206a53a0c030665a5f93f111f44c5cfe6a279f2506cab0ac6c4d7a5ea1cc08eb17e4cc207c4d303d8290b07f3cf9ff760fe70e6aa04c6b2b68d779a2aac91e9766dd1f736c02cf4cc2ab606b7cfb21254d95cd0d9f67786e9f2eceaaf36af47f20076c6dd18864ea7a87e80f98d88385ee4637480ee750c55b0ddfda13a967c3e9bf9e55846da7e0682d6cd95df32f7b4f1b08fec39d64d67bdd4b8beee6d67b36c1d2eefb884b0246ff431d5a7c1b95f8ee6b1f1f9f81b7f46b7753692ae13a14504b589e28297cb93b5d42edb7f6fc96aa6938a4401fdffe4aef7e91516154d8fd5f3e92021c064c5e39ba672486cb09338301c1b3aea90c5e4d44b83f7d44e496d8236138cddd2d93b124bf3ad118f7f0b8174b5173f5221673b205c2273d3de4272f3bed4c3dffdc8015df82e1195200e9f1efc010b522cc120a16baed22ee841970269d5159a43e19fec963447edd6c62c38ef9f72426158aab27a1aedf8737bb09356d9437f4894ee23877bca8a81df1be86ada3828ee967c4334e38fa45defe3aab5939ed86c755c07fab2b63513cb3b367d36d07344589137a6ca8f36a45e5ade602dd49451b2e6ac9743c958ee04cb4aebd4fc0d2966144db4a360f67ea2cd103ca5d55eba2bbf7f7265afacfc02aeaae443dc01e1695a96e835698c5a208e931e67474c3343035a689a05cb61fa764e18dbbac9f2daa08a968253ed83db263b9eea89e44fbc96f93ab4dd5e265dbbd6dc1b294fcfebbc830c9ff551327152866d6be231a4791c9c1eda16e180e7ab9466c7d764289d1f01a2f7adbc721a642ebd2e72604eb65bf76c218647f90d0854e25de4a0448f9946fe17a0ec54b36c0f59fd6b514fede3653da2476210406f076b199764430c5037a47c880119aed0784e82c3e506bb2f840add31cff8b4ec23735dd93e811ab188815305ca914a7f83c7ef5f553b3455e991975d8dab2403ee7b196623f5908f8bc79b2151318a9b96e92e34f4c3f87aeeb261f157bc3d39783ae9283fc3bc84abcba1fffe5b510582b9a3547d51f5903f56b2111104af8ddb653476780d02d408757ca3566e494279f0054277f00a1e54ff5b85213c4a6b7741c619431357c146ae3a62b0275802122720e4866135105e19affdc5e0e02580610ff01dc9d44b6d85fee07148187fcd43d0d5c1595fb774d6adccd4371ab8e93533bde48c21cfbedf450be4d7f2cf9157c7f1135212346ae2dcfc7c11d32a57d7709d338585db39fab5542e875571bf4578f4dff9811379e95cebf6ef0298e2476340a38e2fc523c0665c22ab1059bb97f16a996a0de28dea4bb345623ddfe4bc844dcf3f001736b57cad8cc33fe278f7393994caabc64ed2c24a8e182f6ff82a730f798e738609dc595ac7de2d58a629bda9ef23b7b9652feb2fbe098d56fd6fd4b859e29a56693dedf452bf9ec3f49c716bb1ba6e39742f4855afdc0e937029acc7659f35be077b3127be9d53f5d8f44c1786f5067fa7e0c398430f7c60121725ba66592e173e39ceff85a429f98526434f22a8d760ca8d870cb8d9d5ea0876e2bc60bbd6e1fdf25ae3c9623a80626bf8d8d6e37d3b7f428a3fedbe0adae0f1221285311d63ebb2849f554d521e7f04ff490d7aead1a77054ee071dd92eb850d7a06351a854808c5a54493a31570ce34dd27396559069a896a5bd6f62da2e4ef03e48990ac6c2cfa0dfcf931bf18ad7b3fc4a37601104f9bc2f866f6ad1b55172148997e4f11eb06076642a170f4791e9657f4f6ba872a7e04cf91f9ea93337f836e98f3b3a3fbffeef0db5bb5e1a019e5f50836187829003c7362fe190c11e092cc0edb4a478e897f0f8ed54eb75fd4ed2193e52e25047111cd3622ee7e1afe6572886bbdc3524c1c9e4a8787256559a27487d81ca95808a145fcc265fec03ebbcd1eaf48c9cd912996fa08f890dd338f6dbcdf654fcf4f2deb7313a9b51e59a3b79fe510577a7331b013a984992fe30c3cd0a0dec950d5a439cff51b76ae4d16d2d87cb6dbc43630e78323ee8311d561f69b2ba1fbbfd173832375538de7a3dd5a087c438375392e1ff2d9d566eb41c7a0d348af86a37cef7a159da323a0292a261137a4121594112682af140cc5fc395ac8368c582dac4b2fd4a51a0248d58a192ebddb34d1a2642c924aabc215ec0f5b7cc87af5449355b3ec1868f06858299c28fab2a3d497eb1d5cf94d6b1b79f8a897a94283d6420bc62de098d90e9ffa2aed2b7e7523a35d5b71b2e6f54c155500eeac79f0dd1772a5444119838bf74eae44a4f77e50afc93d724738393b81ba2b9ebb146d9323115606d6189e70fe681cf947587e5c215835c769fcfaf1a2d69ea2c5a29054496aca88ab49c9180bc1fd4e21e738bf0339ec4be6026dda22c826a1774d702d197f9f961cb257a9a9bc0c2096b8df103685b7a758dd8465222567c2dfa7833ce28cb7370c19545474502037dc0be78e9c1d9f6196aec71ebaba35dc3829cd763dd8592128b10f3b38c3100806f44359b0cb57bda62b0703a9675b45681919638af69ad880558a0cdfd36b48452eedf89e122ba22d8b250ebb8a273d488d3132b7e3016ebf9f27e4564f3ba4c28b037f1d733b3dbf575a8d7200aa6aff6effd83636169fcbc6a9b1bf14ad81ddeabbe3ed00f1ac9e5a28e02fa4301980a8f0043662bb4e9404636e306e6cde52f47ed69a51767ac34c2077ac2ffcd82dc876592bf1440c4ffdc25958bb45dbe19b9b5d8b50b76f3b2c0bb17d2a738da07125b49ee0b255eaabb9e284a8dde453eb13751d79a33f2c9fc3cabce465e62801f924ef2e6795a88f8959f2dd08bcc3dedfc8113a9456bde6c574968fcb13e3799f414797e754384c1cfd9de49d10e96b7c22122d51480d1e6db3b3b37bc290190d6980dbbddc96aa71f7023b429c1bd1c4ca4695cb9f7b15818ec7d781b7f3a64b3bfdf3a1d45e317c66bebe6aa1277478dc35024665dd460fddbac35e235ee1cc4c27a380f979b01520825f870759cdec259fd87fab90d9e635514be578e930332a934d972582a60b75e7622ccb5da19259300946918aa3bf09b55a77a63f4f3d7c5660a4a9c3c758be7317053b63226724997cda8056ceb0bed056c4b81ef9140013b90774ae6c85e9244897ef723666aa3bd1cc0a5805faa8d0170350a9b4aeccf2e9fa19b259f0ecaf7570e234b253aa54631fbc8b7c84ba3e1bebd3ec3bae3615f568cac5342d1a3744e0c56a0d969fb9b650aadddbcf964f233fc52a5144945ca7aae62d7afa64b3ebc3140b6621830556896410fd2d3410768cbd819ac2edd9ef9b532855fdf1e4a9256e3af2fbf8689b43a15f410b2abe29854bf570e7c4e826957bd01abea12a68840299c7628ff8bc9792be239613e7d50a2ec7d0f88f49d72c567d51e023105c3af4bc86f6359ce8e4d68ed7a12ddbb7209dc98709fc92202fb2c312dad88db247a5c34f10f7bf3a6baba435559db9aebcc1f49e7ef3e533f45016771d5d290d6aaee546a3ae71aa77e693c6622700d9c3c890d5231e3c0d4554b1892ac46db15dcd83d8bdaedfedbef4bc5919c0348877ec7b38b9a8e7840da265d778e06ab40679195d4a5b81131d41464b6df37bee0f0106f6f5f2e8f870ceca6b0914cd44d481c38cfff7d9640d3fecd8ddab88ba7d1e5553369b84cb7a39460277ceeefd9cd473dda8b973865683ade5a64244be24b8b134cbb96c1300744361efb43b4a8dda013c7cbe2b9860ae876e26187860ae7236ac0a5b8a545723c0cdbfdd3d6f63fe8fa0c0f08042911b936f10d4dfc047e41abed3ec5c4a85cbc893584f34f479a878a0168c5dc54ad2977dd1a976db9121da4769120b74a56fc7fdf685b9cadc289880ebffae77935b39908231d1cee9fdf296b7343763b611104f21f499de824578b6aeb9b8b27c969aa0f539a9c607b1a12fbc409a85f3c27f2e099ebc0b6b116ebfea0a1670befea780279986ba6652db0ce6100d93a1550b59bf6280faba75592ed61ace16d42d7fee8cc3426a9584530845442338d8d3a7ed21e6cb113531c4a3f95e1df6d53b6ef93875fa125f91da83f3da53af9c7cb5427f8d63ff32bbb101271e85002e5d590017ca5d13d6ec1bdc2edc447b8b66da1c8eceb1ed94f215a5604904fa431661bfa5b8d66718023e7f54d42c7d2df4d2bc049d2797892a0dae48176cff808e2c2ce50029a6c538c3c1f1130c962a9c8f5b82c023f891ad771580ba638526c1c02c9e95edf2e3420ed14e1d8ae665120e8e4169606a7f1dbf6ca9ddfe6f4b83519a6437e031531d426ba2039dc93de93f9ae7b71eae37502a711bf35b732963b0bd2476fbcae508aeb5f64f5540251a4bd46b5bee5a335c284271f479792a18c8644c4cdc6e6bb3d7ab2780b5f6684b411a23372946d1775ecb3a79e11f715774245c58b77356a1d455099ead54389f06593125d988eaf6709bcc45cf0798af17dce398b1491ccf399a3c72c476f73459f916c871eff87cb534f73ca5f588bb9066a3d6e0d188cea97edcea1142d443387dbc2aabe87ece22d0e53647116a04a958e798a3756b8f45e164525a816da4a1dbbca7a26c4be1b80b84d34c5361f789a7ef491c9ea6bda43c1d1e3c7b76ee6b555826a54f0e8ea4b34813c94f758e7f19d95c89adad7c4fafc480064f4e8e3a960a3b663c594e993b44e1f5287d2c50e76fb6bd785266f69a2afc4dab4d546269a85bb31b474734ada932f09efc7d98077aa665cb86852f41d80894a9ee3e2c1720d25f2cdfef8dd18e64186c7da2706317d75ebc3e779f9dcbc7965fc4bbf6a8f23510b6ad597b7da2ec618041195a321b27e394d9ca92c5202aa0c603f15ee27ef72bce81cabf40a41928180d4df85a8b8181402680ad4a730ee8058c6601b26b796eb877973dbb1e53f0bcc5c58e64e91dfe32d81e680573350117b6b7af68fe6cf5242981fc784820f5ebd722c7b89dd2d406f216ccd8ccf47ad02a8f9dc4fcff5b8b2028fc0edf78cd2c02a192e2f5de8cde2801a7925e0d68a43c29b2bc2cd1aa6fabb598ab74250720202e5b4dfd765fa8d9c6d873494ef11f53d852526dde31fe5ca40b15b1c1522ffa2af0ee4c4410e7f26b80c00f3470f613e7e16613a265103f7cd9bb7b91dab74655de87871168637b1bb76f2f6baff1f77d52da82b457ac6a54a6f013f43a21167f9a33943f5f3883ca3a189dfc551eb2b0817860717c6d0883be9ee917b929f5a1605b37ab3788c4a4e7f33852bd15ce2c897dbbe3e428c50efb074a44bbdcefcaf32e841a466d1131657ec76889c84914fc923550ff6368bec0e91cd8ee410142b9596b131f637d594864fcd3e7b378e7c6361846c6ce0040531a4eee4da4ee65f44c21bc071de559e53d3ca955b3e8a22be6abae8e79e269839b0a9197c2f6b522a112de69c78b2726d80516ff52938661e6149209a15aa02628495fc89d87e6731c11d22084cccf43bb6263c4ad76780c7dab60edd49031e79e3dac1ad9f7f6dfd42163d2678d63cc4238df0dc89a4478a664974ee4e5a644856d5e5df0fad49d245aa93bf29ca41b10f8c4861179f1a598e12c49f674578d6dde74936df25b33b6c5fd413478c46339962e8575165fc483d328a8f174f3a15d5d89db6c0a3a85bd6ea4676195071613df0ee96a2ee8e976a83a0bc69248d2885afbd28c4ee40d4246390d4256eb64ce7dd5fb8a9c918945073bc22263db78d349c3dd3794f49c4deb4fd092fd491685a30fa26830c1865a8612b4c8e6d433d2370989dcbdba9d47ea88885ad127f0714dde1e9b6fce030cc6a4e4e56fec05d1bbd042c040c4c52714aaac8569c8a2dbb8a95b7d0838006b82fbdb7d5e1729e706ade844dfb58f37e859a8f768cea86303eca2f7b1475971b54290b032e5abefe37ffad8ebf20453ed3bf2d4d01e79ffbf638d4414b0dd499bfc0c171c4327bcb381f735caab0be8fb12005acee8868bd2a3f157ac0efbbf41e4523e4a9d2cbf9d5fe7cc1b6611424831d3d5db6350c13dfd6b6ce59ca9cd42060e4a9d27d49051c644dd4c2c3e074c1d5abc998ddaf3631fd4eefc1e871e336bd755f3849b50d07e2d508006e170ed51c5eb1dceb86396bcfe285e8aa69fab5f9959c942789b5951d7afb93cda81a4ea39c4da79f5f025fc3400c8317f815524a2919d0235810772de15fc689d85a68940a18e2169f1d90c0f331b31e205aac5edfabf0ef1fed20d7679542c9970ad70226d238f5e88d5470ebf235f466d8d3f3fe40717de6e5a1d96f8ad7eae1c20f8e9dba851ca3e54af87be057e948a7dc1c70417aafbcfccc67c96baf11786f66c5beb7bed20b665523592efb2c24c4103f6d2c6f5706945ca4f39292aa6fd8826950e0be8df18747de895ec9126f93306daf094cc0962a1e571223427c3f71fea37a7fc129d4ba4b9d13350e64c41e488ba322f3330c4e0fa5a61005535c50a71cf6fdf4fe55bd1f0548bf9244c2fad714107a27b2955eb71e9aa0f8dcc696aabe24aea67e465d5c94568aba6b692d188920fb3f4b652a191fab45347b732b40ac9725e068bf3368e047bf084af1e774ca4af908ab54cb095a74cb0fa7bab305439a3ad85d8972539a822212583de4d7fefe53593a368b802eb3e85f7a4eff7cac7a328a63eac4e6864a88a113636a66843140a862db86d5e7a813f6040bc49704bf6ce300b26a908ba7172e9191b113b576db48b8a552182d9bf3dab67ab5f96e56906038f2d7d8ea605541e000e289d4d50f75f252e5a742ebafbc07051478793190dd834f957d24e98578ebac2e3a826ec78f3419961c9d36732b7c12435e856c87f8857c4360a3c701f832dd3bae08bf3f68b8e854642c75712df3d1e8612394145c459b32fed695c8a601fbb06f426c4528f238c855a54c671c3ebfbf8aedbb09a765ec7c1405abf46c24bbabd59fcf6505527819741048abf06b24865fa76cbd52fd2ecd1ff5e09c4d314f2642f5709da684e78553c4225d29701ee6da7d4fe4b4039589f69b8c15b1cbef09fd155a1ce46d0237356e4cd0f82ab7bf1e704ac99d3c58d73d5ac062284d7a8e019f1df7307ee7f1a956d5ef9853d4684ce993513177fc792ecb3d241edb87fdb05e7f2e95601340ef93681d56b7dddd3ceae57e02001aa35afe49bb614bd76b60cb0d678312bbded855cf6d45febd5999f3ea947b050525ab8d76437d0ea978a323d3a2f02388616963370f5ea617402a151e094a0d8d1ee5484ea68546ee18f87484db913cac6ca153c6fbf51917fc351fb8f78f15f47b678a22099d29dc331a3fa740d857a84783bf64c59db25fde3204c7fbb901620d4b2af1d94f2f6f7655592667460deffd617a72c2f9020af085c5695aa2b4ae964f4ea1e38aaa3643eeb407c145dfd2edf2b24ffbede2f51865d610cacaca3b97efce4908693729327fb6807ffa1f40676cc020a2ef71d48999f58138e0f28462df319f1cfc8492c7ae670fb96c8022459371a45bc0ced3bec9fec62a518d57ea7cdc77325dbd383a5df3fafb44b43b311a209413061419a36dae45c9bbe33c68c93625df5feab520f19d30808314fc1504822147f741323e0233ebe75b7347e1da12169e698f2153518861f753e43c82d7f874a861a932b59bd300efe5b71d627e66e7ffff958a43472f2626efee1a227d8c184202b50a3ed98b381a43939f831a4273c2b5d072357ce9488528356ba528ea3bcfed23ab97e6e258f5cfc0bfff31e4b38304ae31055339f8ae557c2d03c4f3291d7210eb0ea0e7ecb62d0feba25d42c4e7eeea372d03d3069858b580e6c1e4a865afa25c7b690090e1a0c7e3eb341031ab0547c731ae4eae36ef5b0c2a7d3abd03ebb61e13e2e153b3bbdc95edc9b078c66cbbdde3588b36e656a5992462f5f5829bac897d96ebee58348425fb026a62836f2e7ec1b1ed055f246a66646164303361026dda0d3fa5a2f38aca69c5dab6dd9666dc62c0b30ef85379d7c730f670c328599a193279442a71c18ec659d8695ba3b7fdfb3cbddd0359853c250b46bf6b7597d043e87bcbb36ed2288ace2cd0ac5752e38d4c2ababe0cfee2019d16b844883692794d093264c23713829ca8c84df66b2ac165c43878e9925eb669954007cf09bd0981eec19d5a4f195ff88aa53c1cd3083af699228d38402ee3bd94862742aeec9309e089cc4672281e3654619e8d62cd5f46326788b05c80584514676e8be036117affbb6a52e799bf39ec13dc468cd7c10d1d9267a5d1f01c07b3e4256cc7c691bda9bbe9a5b8da12ebe2666e0c8cc02e679d16ba8bcc4a13a61ad1dab50dd574f23f69349d01de8b9e53521bb1eb87ea7d8ffb1f9f95f6e1c8a4bb7fd216a20f08b38eb7625e796494d7dda48169fbc6a9c1896f01d572ea29452ede1fe7439060ee554a97d5e799fe311e7ec792270c4962e9a9a8c982361efa4a5e5e1a5bdfe2c92c377862b616ca0b54c8b7dd1c72aea95bb7eaa4f25d7d93787160ee105564345aa479de7ed5ca19f100d66912615dd141abba914dd138dfb50ddcd93a94a81aceafcc76e3a712a10d0583b4c175558a17d77c5cb15590af12a0d138d94e36bec345eff920fc030b70e18267a5edaf0c97202612fd66e5e7244df5ec79d3c11de2e951aa0c27ce850b427ac269c4e059760e6fd5d3a7e795d59d7738ab97b91d5e9077e00550fece438906e6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
