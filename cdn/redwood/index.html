<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"51f8d8046ee85f05eb48941e621038ac7c639ca5fdfa70805440aa620ce0727489ac6ce9700c8b5c5f5d2ecd0753526c19792d23b15dced6c83e9320c6b253bf6426050bd3fd429b11ba95ecf72444a2bf42d6107c349d2769c553c85cb3b37e2f0a78878ef7fb87f58c848e2e244e62e3c08527b7c43fa44e20c2d86d0762250f1f1e8fdadfebfb354ac989df9493d035f3c25b24eb06a3af42d25887d83db04e00c696c0264c8709c9a1f1d4739682bd6768b344b25c3671e360fab4269da61aa3113fd35c0df22094a381798344cd45e7889ae94044111b9c05d6bb4bddafad203c2436b817340e3041b2136b720dc5ea20d02c72ad6cbe344a9f79940bb29eda5204ce61de9c0b617b68d98e5a2c7ce19ed46b83ccd686142c687320b0403d1dca2427fe3320b2384a1c598309aebae44fc24bbace8e8eea96766ad4a554ae8b3b0dba70adb068b10d80ad81ba0d5cf4da3051442b580585a5f8b7599c823d2fa5392345afeb118734ddf43038225219c1d35d74fb97647eeb33865b4d4b824a4641fb886ce7149d560ea6862918908bdccf78991e47460e44224a6df37232fc1a88957accae2ad77a56329e7fac57ddb4b5d114acf44407b7e8e6d1c34a726c5cd9313b53c5bcda7436696a6eb0e182cbf69bd2061eaa9464dddc6bc9d01f2067ebd98f2fcc6854a0baa0d029fc975016b19f54bb1bdf4c905f6571d139348b6fdde99d72f0a93b4c93b593f2ac86ee1fc1fad70670805237e295c719685702fef434de0ee82cd7801901fceb40d435153a3742fcf45de2bfcfdccb986e102af5746d6977a58b95822cc6dd288885d41d46885090736b5af632de164f80b7785d465d2b84838bb1d25202a58cebbfd1001dbf1cbc3d93194ab4f26270c82fe51db7fa74cc367ce1247f7c743f5f28311a39202073a1684bfd6e95026e4045ceaa0d386338020d20e82c030daaf35f1a004a80e6b2f3c3cdc8f6ef4235bc0b927c437273efe9399b4f5a43aca7925c71928f32ba997d5b0a73e4f73fc7f30bbc5054940eb425cf12a20f08c3ccfa1ae25e8012e98f670c8b7bcd59de7146a87ed53d717e5e4ea1e922285575d3ab9f6612bee13acf8cbaaa4f452636768c8de30a681f033074509f7bb611be93e49814b698fa33072f9cefbb92bf52a79b04a8fa117be1c733f3c56df2fb332459bd40a227e8e215fd0ab2b83deed446848e35344ac650e5f100af3b1a508e5b935fb865f186a880e49b82c37cff5af792385643a715fddc1bb5d46a8ac94a3c780921a4e9ad00e8a7c2237ea4d3c720f2585ea6082b91e6c172b8f28522d293404c67ba713bd2a711c7095251ef8842a04b02dc0321e354e3677310439d2b83b8a775fbd5801a4f94af3819e70ea8f4c9a12711c161d648feafe10bf1106cd5cd9dd9c68b7165099075955bf57b6160267c8e0150858ea93cf2de42d997656a932ba44ab3b4d8681d71a04fcf4a7092e79a52f8842292bdd28a3652414e66fea42a2592cd92d8303160a464674591f5d8607a156351fe38a28cae6521fa05da9854cb7c5b30f9d5474e3dea6dbcb3602e013c3ee744348222cba9484f4d9878142316abf6348c3fad8055f5ec149aea68cbe809446a3de038b846ecb17f40aa11d4d1660ac789bf1b05df8aab95058f3001fc06daa8961a7f1306d8370d41933eeb8b387449fb2d0d8672318e42961d35099f328ece6ed7d17e7e37731d7422879e9a724e07d70e833defdcba783c8c5de76967f496eab8b4ff8505030401dc534377d9b30250538aafff3d236bcb6dc4cd7fe45cd753c86581a68af1eb88a4e15dc30dd5a106dca583cb1003692ed28bd62c1231668e6f37124b04ff351b1413820e99273020572af14be2c9f50bc5ec2c674e2eeddad9c2b9eb629683259afafbcda42c8f1aa1b8f25f92595aa4ca864679f62512276831aed554a18d53273265a4b6af98922ccc44938a672e34df24ffb4e65bccb05c1ca294e8337dd25815b0d2a80597b966d4ff0ed5c404599562ecb57ac4ef4fb5dd2c5ff61093eb2293c529f7d0beed12c18c0ca7ec1d6f27329fc379d4a45a44bb577456300920b8cd36a493b45de1a1b79982747237e257d3b5cd54ae15e91fa805d9b21231510143719675e96a05c2a361f5652777c21ef5cc744546c12d078e5991ba4c6b8ecf776d53f480ba3e3b48a6b3aa86c2d7317646dae567f416afb49d8277cedd6d9d7608266a0e20492d2eb143afaad27888ef01676caf045b87c8e9d2a174267560ddf696a10dd497a7bab73df86f99ef14bcaa834b11eaa54f2f965bfa90c6f9a0446d40302cfe12bfe869771fc0177159983e7eb2b4042a410c9b379ec9f8bb37d2c95b17f8c68c22e3e2bb9010569232f036fdcdfffe2e99b1d6743eaaa16563293557b1de1bc12fd8f440f65785e6d0b03ddc64287cbec226b5db51f06bc5df29e9430663152444934bf8c45df9dc7f893e0212deb00f1eba3a8c7b5afb06af3226b2f5a1fa41680bbc79d2368ca6898b12e5afa8c621d85b814616a034e2f10803c64f1386a4ca88730dad65a431067731b96a7fdc279ed11109488c5cfcc4efb720bd51db108eeec03c8429b87be34aa5ecdb71101cb22dc1a06e9b766e9fd336140d44741d2b55c563a97f0a2d7c659bdc70efb12d3842dbc37e48fd6f03f6c402311b09560e37b64810024640ec2ac771d9540d33e9cb3f65eff1121fe9d302666937129884661b77bd7234e2e3951c1509ba55e7305e27cd37ae50b69c857fe9ce41685f616bcb13f973e5cb58921fcf3484c38cfdc4ded221058000b9bc671f4288e5b3d59e1c1b22769cecca7b86f7688c2c2c88e057c36ac549070dcf6eefe9806f57c484b107a478855584061a605298e86d1d35e2e38c3e13f5fc19994bc6d682e90101fc74bf0ffffc664e9a095b74179b5324a099c744eb1e8807d824644521cda624c93925a6ef81e28c93296a7bc177699a000bbf49d28a7511536fddeb763d819df73751c306adcf5c7890146f038a117f2a0596c692e27858717d594f9924cf345de9eae57379709f99b83c1686252a696b51a6bd89bb9e8ff3e562e113622c7a301b12bcdf36d8c9c1c345df71396b7c2522f6198208058dc21849e60523e6039c8169ee50d1d28e4e57a9c8228940553511acea1c7757b0c7b597ef5b86e3fc76a2dd011c3406dc1dc522e62aaccd5eebb6aadb73e094164974c629f132b92fd2dc76cd31193a1d1f1c04fe487e72dcbbeb95a6ee4dcc49facd17d5f44306a24269d0f4e1d04b08eb14fa3a831fbf1e08460508cb2fd90c50d9caf29ae701bdd7c3096c8b1044c3402a5154c2fa0156d2417659d5dac97ea948b215afc992d2302a8796f6e942d359bf8bb12e4c83e5fcb6c83fe2467695ebf111842cd61ddc9ca0266417b22f5b8de4966c0d48ea5c7f398ba2471947300f4f0f07ab12724552f92caad6dde7cb412599d078a8c59280e8ac10ee546af1dadb7feb5c4e0f134b5d6c5cfe1ffee9a688511dd9aeed9099e351ff217d6583230187dfde955bc87700ae9dfb9d1002d2b639a21b1218949812dfe8ce8a36b09598c6b463c361e1bf7b5143b12365cd941e13d4c31f61e5b92683e8d8e1eafdeedcad84102628634b3d72e653ac8000e9d13a6d86ee47437106dc2219ee138051ec0cf185dd2405ef48092ce4b0030dc89ebf3e1cf0780eae9c4d4f035d8aa83ed57a65eadc67f03c677329b95052dc42f799a56c2d92fdf55fa36df17e817c702939268ed34031548d827132bc91d0c7bc66bb2a3d30d1b7b775130dd707b5ccb962891d4360d286ac9a782c41bb534babd6f38dc95a0e9011523f2e3b66a78c38e02044ee90a4985e76e641758fdfe97e0fdd6435c8d3813d5215f59865bb00aeffbd73fdcbb8c985118c46bb894804b05fe9fda200a13723541113e1fb14c4f7b014b204d8e03ffdc98ee9f2db9d6a40346469a4ddc9b9f25fb654e1a98150aea0fcf2870d84dab526116ef6d21914efe8455293eda342ee9d83dd7eab5ae7d61f8c3aebc84a39eb24dc1cdfb1fbdb53317c47855693763cc7e652c8fee6d038a8321780cb2ec8d66feda982ca1ce19413de8555ab2f160f4c1dd3eb230bd5f2beda2d16c8c6231a822502f766b75fac39d07a16ce12204a5babe4a716a552ec180b42d7e78ac93f6c4b144b63c01b6a2e20ea4ffdbae2c71d72b4750a5b12dbbf08bffe5c1b6f02795a843675ab9856b5464651de0b9e2001b6df71c68d88e71d60364db7314cf9235c1a3f0457052a59199accb99a48de28768da214f2729097c2a6a37c2db0f2300fca36868c66f7ab919e62fac6a1979da0b1a48a88e03e008470cea244efd6a2dfc9eb37b62eba6a5cf15372aa151636a217ec7cf88e1454341deb8f6c1f357aafccbd24b26f5a6ec4dd6f972ced43253a32ea54b10bda34383b13c494fc076f50603f27ba9b433ac2fac5eb481253a4ef0fa1339f453d4c6ed5483d34a797527b339ffaa623ab52501a2d7b01ee90dd459f36599066740b11938bd48c5b595351499265f372b4051dc0eab0bb16bd526a4db395a8621cce97c30b2db7da81dcf61fcb3cd9d08dbae632c78d9bdb374fc8ebb5ae3f360d087935e2edda27099f489912607c64a609b327ea7fffe84908c281db5e05a02361195bb536f77538551459585f99bd7910a187c46affeaef9781b9f258271458410359912f8ed613a4bf8e1eaf19938b72936c5d461ed026e5ead2024d37cbc1df8a7528adbbf660ffd9548d5423d0f8ddc1171899e33a424c9b2415e7823c876d4bccd17e158b939310b9667dee8c21c2dd825f0c61b3631e10fed99f2fbc09b49b9aa66c59e5ba992efdb2b162385aaaeee6b6bf3b7e45789aab35b1b092a3c5d90cb4e5be02a61d5f0d1f81fdf2cd5db8d435244acac45dcd338a0e916100a17fd4b19d24b08953ad6cc208e63cf31f95651a4ada6f8f91bcc4ced633903460babd10fa83d14f819045081534eb2ff1a26406cb17095bc77f94ee569fbc18d5439e2875d64b2e3fe19414c1fe9d8184078403f20092c3378f0610b71c623c950144a2d8f2e66b05829d7324144d11b2ae01451b15c2b12429e857f324fd002906ce5bf802c87caa53407050d262280712a14d30d05591ccc7ea64eb2a6b92ad38814d16b61eee3e7fd16f743e4480633fcc812dfea3ad6b460ef17495ff674eb5fe13da4520f039a50c9aa36e3c475a126404a1108f6490d343b9f315e69ba6abefd1a45f351f225de4e2f038e1e3a30d327474f3d274f87af927d6c1353a4892e0f9fc9afbe0ff84b7ffcf36b1d6de46d94ed2539e52182d8d44518a3d5d2bc5f4e35910391f5a312e82fb04e039112bede69651af8d26c45b4cb0a01a3515e9eb4f84d02b96465b1c5063bbe363cd2ede36679b4d907f5a10f790f8da6f006f459bf0bea32562b2564961017c6bba0fbcabb92af286e8434e6991c62cdf6bdd0201ef8b78ff88825d01595b45f8e9856d60b9698a22cab48098aae1de0b3044ef7545489dfa1efe4db7588dc2e58c23c23ee7ab6cc3f04c368e185501980674b847a5c7750ed2b01dfdd2c57d9d626d46a00deaec4a6513545fef471cb3d4189a7041b12a3bacab981ef227f906d4dd46c5f04c8a67ab16a0f2e658e9831cb3bffa232b16b860c25230ffefadb056e0b90e4ade99e6ac02b72615b0602f978f79d8dcebb5c0f98e5b15ec1072daf89839c7188cd5bc2c429ae86877c1288062894fa5bf1bbedf811272d8f3ac234b0b6ac8978a29877487fec017ea96e374fd1904b76533b7877cd7d91201423939502e0d0d0d80da30acd1fcdfb78553c03ffcd240907f602c81982c8f5c11bb27d7030fec561fd7db10427ee0ee6fc10c41f1a93fcdf879edac4043440602a688801d0fd53e02937d0c6a37fd0782e3d44139c5404291eb49eb5b6b12ad0c217cc96637804c150a3c58189fe1958ed6ef70a78b515e851cc23ba3ec40a7646a9395cdc2f0ab07b49f6c6f77427b9da3be1a5b0a3224fde107056166b0b6311034648affa3c2c7a2284207792f2facb640ac002724f03e425b13aab36f30af743b75fc55aa9e9d56f484ea3ae44bf8c3292285dbd89262b6c24bb8b1f88c653c18c581e1ce0485a512d116791c05abf684b082b797990e088822ae3254b892e85a40659adfa84d1cb994db638cbb0facd1d9a4f21979c794ae975618c5cf86d2a584ceabf089d37566a44fdeb1501e22fc0c521de1fafbcd6df5f54871a519fd768cc92b1bafdda92fa5ecfbbe94da193e24831c88b612e4b60342957e2cac2dc2632ef480701048fdaa2859bec6fe61a5651fff1916064acb25e9609ef3fd0588c97b02d5222bed60080d1dee922cfb9804fbb91abceb699a59069ab283d5f9fa9fb07506fb1423687bde2f4b1b741bbedc33a434afaabd8c715b05ae4d0c3d8fbb24094237faa29bc8d56b86d00cfadb1da5578af5ea6fe489b0bfb282088045d0fd7266ed788c82e4b6d11764ce362115a1ffe81ccb9685dd506a0cc6ba2c48bbf35a63b7ce2240223ec28c0288d579c7674e2daf6a033519512dfd3162e5846b5ea1da0b0143aa3c7d3f4155bf96be10bd0dd3e7680f7096534b30e6630f96dfefc41dc602abf5f6583895b0f4388c25aaa2aaa6502adf34203b7b896ae69fdcd06c6b7585b37d8885f485933f3617a0189c2d7d6c737c866ca32e09b103953d8ee3f7cdb0a626ff75921252388b6b94d4e20c2a9320be89b2cbbcbc532c5eb050c7ef56ceb26c6c518f80ad410fdb2cf1b57805ae9488b03023786486e6552ae25f31abecd1414f621ed61be4d180cf7a4972daa21882647d8bef735c57a292dc54f1384af84b17de02a4f18c94e72ee1edbc6fe08a9b70cc088bd0bbb72b23e3b875ca318030b818a82188267ac52a0717ee06d48258f98bbb138d24081aff0842749661feea1f1fbdab754c842309c704df2838e0a272d524b6268e5b9a5bf5c0dfec5c116a576050efdc2cfce58274f6c987453c07ecc7438be15fe60256501687d7c3e8adf346823e5f601dcba61cb705d0e263d97d8b1107d4ea6999ccf7d955969a8a14a6cfe5798ad2c917077ec58a49cc5dd43116ac0661d3e4eb88d5f474777a12aa57eb346b451183714142d6ceb37db3eb245bc22c1195f3a6af7c7e38d3cbb6146b8806594c7dac6a029bcff4d1031edc299891fa81e5eed658a7e85de1a14d43e2cdef587fc47b595546b777cb0f5fb4338362e01ca4b2bc1176e13ed5112244ac10fb54012d0bac2e91631bb59efcf95502faeeb1870d185ab0e2815ed266b2c2e855d3d5d513432655758b5cc85ab3c874218382e9a27eb674fa675bd809eebee1632f989dcbf86a799037f524e901ae3ba1ba6d3b03c12f05d8070d1fed48166820102ddfdc4923647710190a2ab8eefe922388e0c8c21509018b99397283f958b3e7ddee533975896c2d578cc5f1ece94ade9bdbd807e7f2584689b14c87a85b063b6f5a477236122ae7792cad1585cedb587a575a2502842ee539546b1d1e8a685e9721087b5f4b86b24f864e1f6bff2e1007941cdecbbe3669782c3ba006800dc6eb49afe9bc4e36eb997d218737303eb4c23d9861c07729fe7f1faf533fe7f42bd119a4aede183767e9715b6ff9ef0ae1895866b6f7dab72289181799b347a8c9a01becc8bd1de76ffac7e66e29959a92fbe012efb1f27490467f3a4c9dacfe590b7d1d0359abbe059405880677f5a6be88073a4295b9a5cb9d99da2f3aaaddf932c037bc1b5f210a9647ffda5bb1a8357994d6302d08d2a54cc7746e0b2361270e1cbf91ee514aa0d914aaf9e3cca0bbce6bc2646eb6de4fbb266b3168c6f47da4fb3d1fa9ae302d2fb0ff68bd562088584be5f2a06049501ef8442fa06df10d41df74f2f009772b7501c6e215520136d9c8de80b8b46d535c494327f73e920ec35d8bd6482e2f213e4c84759f91d7f49a0ea32b316f3e3e6ecc54f6011f7ef07f991d37dd3e601e765706169afa1e6dcef528f9b05adbd342210556cfc9e14afc6a7ff6e11e7cb97c7cb64349975587cee7c211ce1363b4269835468acec3223e27c12895dff65b2e4178659736a4bc45e18486b7348e81f136276a5c0d57f25dea498bafd5a23607fbe8169d4ffba5d16c998151cd8147ef8c31516ad071391aad0c0223454a94eb6035e0ccd66e0fc6cf747a025f4c6d4dcbce11fff14ffc45ac1a8d4c27cb01ca94b9487a6de6ad030d9539847072c5b49725c996b3908e3ec18fde889b8f3428004b8abb71934b17fb0774915a66abf9e6cef411a70a3a47d10852bf442a3df6e1ad8dc8e00956cd523b42f0a039ae17ec1aded45950ce385c495fc8c964fe63df69273bb3cbcde9372e3346fda39fe2380ca0f1778aebc958167db2d7920eea9fb9b8ac618e196fe4235018bac033be80851bdbe01497378e5627927820f04a9045e7664f4052bb57a49e24540a28e5a4e350a8150a8ef1c0db1216ebcc985df1abc96001b6408de7aef4b7bc73aea249666ced7b2488a7cecb9c1996f9fdd1ef3d6d19d09241278883799fd6910240649565d0e85e244b860ed54c2cb5912d562023369aabc7d0bab19b2ad92dd61d0eb926c8133a5df8dd98e8f8af7cd77116038225c23b0d3f1aa8d7c8b94e850c9c2509cfad5f9e414cc60c4ab937243951e9f34769e54c1461b6ada8ab10846cb4bbac6574b98b4badd84376900742ec88925dcff4011cb0116a58b0570dc378863fd62f8f35a74de962132139338a628c6591e636a84d54cb13ff6229c09a239cc5f05ad430849c4ffbb3d24c69fb0989184e53378630009ff2aae92ed0a1667437765a279e909daaac3d71cfe82f11aa5246c90c7397a61b6f0fdb11cec0f5bbdfd4b9fefc35791047b5aa2e216d41eeb7b1ddf36197db567d5a0ae11ea2e112533e0151f408ecc670a46deba21ad6ce94c62b478d12d2b27e313ba0beae507fdade1591eb987346defd580d88c649a89725a4ca6a6835a0c834ecb13c1243333a8ba4fad12d628ca8ffb211a1f5a965f3d5f49f664ebaf88e8aa1685994619927f95dddc37b1128ee689a5e7a31e3db85aead563d7bf2c20746f766dfc59873b3af4aafcc32468622e811202e65962ad74bee1b08c006c76140988675250799ed92a89ad8946dff784ba4bf081fc229d78039334fa1b064137e6c683271fbde46ba26d6998c595f5988dea53fe7f9fc0d1ed7f3995bd9b1bf05cc520ce1dc317a0f086f42cbb90d0fd301b3f936e9eb9cbbc88ab3899782c4848c6a42c9560dbed86abb7185fbe4a1151275b680bd490b53cee8e7b908f818a89337ef4450c3bd5172fe1c5fa3d80aa9b31c18e8ac16f13f858d494954500ca6e019d3f3e1de2dca1e4723db79ce7c3bef99c90d78d08c7a46f7904e75eede136d6bb8cfc9053625e7c7d8cb06d7f685264b7ea53b958626dc06124cfd8420a6f1c3a685f2bc7127dddb7b287e9febf45ef2b6c461557f38094a81351de8003acf513660c8d9ed555d38c099e8adc5ec569b9b413f2f29f7c0555a1149fd6745a15180f1f706da52cba96a5afbe30883cf20ac448b36480d7ce7d01176bda876ed1c57a20daeff7a0402baa5c4a0030b9d7fc13ff2cd5d30b03252dbd3e51975473f66d2b1fddfec6cc556f73fc9545038e8965328e7900aa97e495c7836eb2896b5f537b8d35a94767ea4b7a6a4661ec09031afbfc1183de36fda91551834447bcc80f45f5fd73f0b45be2f5b249608cb312ff96e9d1cbcf501d76d2e9079e0c026802fba4fa736c46a6efd3cfceb5e7243478e4da8b693542cf9d3949bcf44ff2ce148a6da8826ba411b4079e8a057a2592d0e52cb1776fab423c5c4000956f7136f7ca750c1c13fbf7c9adced2b6461516f41659d98c8814a0711720e4a72e3c07d71ece529367fc5431a5af348d0d6f82e7932e3c87beb853e944ff568ba8fa4afd1a29cf80c3d1a7c5719c84a5ea70d4c92e62043089398222504eb62da06da3441641b9f3be5388e7b1b1d4e5dd85cdcb8adeb041f23b9bec2f4ab326d2dccff3db6ed3af1db05f58d569a75b70d874f6dda620e1ff13e3f6714cd8a69884f31bc593aa1401fd228cb99d84eb1977c67275fb3e180c16401fb086400739490aead2012215cdfa151fb458c76f09d5581eefbcb91a052769caf3f4d84a62b83eeb9a947dec2571725401395e1d4d8f9ac8a7ac6745c9dbe9cad8689a33d5e4c8915423a4c0f28b1828147873b8986d2ca42b2a22e5d644fee98dfecbd354f49f948da5ea72997fe633707d44dcc76150929be34c6bdacb406c88800ea219d021c2e9e7f05d8e4594972f50ee87274d9d9345e1a004692a32af44e95091937f101937d440bb9340d5facbf8a726892c683987fafa7b9fc8c55585efbf9a60008e8e6bf495375d3fa317147ec1133a5ea3c96c3273f84eb4430f0dc4fd8da2d36107ef5189a88f7a75428890fa60324e0a6c7a7b57cbb809595f6009b98ab2ac122d285b7fd802a8ce413f58c8dcbb1ae895dce4b8b59a0f10256dca94e66f8b4d15206f93088fd6e2b5e0cacfad3f08de095ca952f334ef899e952b869d625b4c2314dd1089474ec7ccff5a0cfa7acaf7af48370fb2c4308916ead1f23728467443a1f6084bfdcd2db3af8cfb5f858b07b8785eef0ecf48a0f181029b1eabe38a671bc8d817c4bf8456452898d1a7a5a5e2c1bc25f40841f2022856065a85742973c8e9fb86863524d185c490d8c4a52571b9bb410f30a3e472b57bf6e2b3ac7ac69e3eb266c3f89060764dd5276b87d181282ffc9ea90c3a2bc3eb6c8809728408971471eb353c7e18e63837798ae0d2d58491dc0b36ce62acaca3aa4ec57659038eec7b3ad7158813ec9d1f7e34226e487f91a319df2128267c7ef6788b42155a138569b1307e8c39a6ececf0f4f64a36e359dc4fa123da684302aa560b57ce834ab58286e5ff9959670b0a22c82a2fa0b80985095f6a0621e3112b24e1bb1264893fb76480e3d3662a130de719385121c14fecbcc6d1f156846caee2dd28f3de87a652af286381c9c10737a42fdc82e338ed4dc2b4df97a1246eac25b214d4f1e1aaec66824e54259332b10ec19f442b43190b73897d15ae3ee16d91ae8968c5ff26e347f90b011db72687660e13f438806f53b57acd3d2a34d25396bf3a3ec7028372617593e540657b131db831c7adbc589efe174931497061221811775b6a587217a29ffce878af7903dc5f40b933d39eda098876c5d0698e019cf41488d105f3aaab4dbacf750be6d670d1b3d84d2ad6b3d8bc6c381481d7ae0c3f59959cb367cd729a5463fed6a63106b0bc73707dc733f881a90bed75dca4f986510ccec1244654e63bfd3820fba6792b82e559e8e18fda1030cd88c83ac779861cf7dcc4c28a49290b4bf3365e09d47040425cd266d688743f34d8954987e4ffb35ce067efc9359748663e0f3a193ff44a8b15c063ee64eae91bf1bfc003d192dd4255b3f0b816f3647938920f6a82c7b49a9ec7749431719cdd5d7d50baf01dcef12de45ead4922a4524e0741ea970c47effd1e68a8c3585b823283de4d177040178f969fde14ad3bd678fb305114aee5ba0b83c9b0532e01f9ae40faa845930c340ae224116ed568a19feff113b7eeffacc5d6d65ff60cf3f80de1e9ee79a33467120043419349b9a7d1f4fa955c3bb4068cebe06f3bf9e3d04232a3d7d1e3caea10a4edd085d30219d1a7e0dcecc89ceb3dc7b0069d5d1181d7b9f7ff209b642e4c5d292d472c284b7c2e9dcd50d31454e274bb88d49fa6bee4d0a601ac81649365d775bf422cb284421cffbb2d1e93ec82a2797fa9ccea25b50a9e85877a57a18fa9fba7436c38e992cc224a5450b39d922f05bf715e0befbece081b2da055dd5be3d16980513ae2eb76cae034ab3ae0a9a6177ddb05a2122a5ff0c945aa3bbb4aa795d7619b10efbc2b4c7338b10377f22c664707b12af2e6b80251007668f3e73a9562688a6c5a54db6096f9e04d143dd05bbbbb8a1276f3f403b79043c0be2359bee51521c01d658280e0e95efad67e48122575ab0fe1d1eb7790c1287282bc44936b6578b1db52d6a61124a359146e6f9b99b78d7d1a31fd2ed8cd0a5464fc33e49737286c63650a3308ed3b8fa266dd46871664b674a053615f0beb2c0f067f95aefbdd70e73cf6bd9fac0c40f9384a3ca9f743bfb96b48d122e50110a611b7cca91c52bbfd4e20763695134d10ff575c2df68a4f70bcb9eb2c33a3b06552f158256ea07bb1cec85297005b3c8af70e9a896ba9c30ca96f83cafc54d8266e9847707f1fe033362089e6d503810c2ab02bc2545abc6d92d35e57445c0aafbea0eeab0240643471fbc5c04f1fee9fa354834530f8110d1fb902a12c276e05e2d8b28cf0e399528275ea80531057fb883885112b8c78995d69b0f80b7aec67d73b2844678326fa80f73092ee05ad0a60ece20ded33c544f49b2238cc53c463d85c1313ce04e5be05269a590461db37d8236597af4dcc34d337e08dd1438db93b29397babd56e67e87a466537e3c4fe00ee3860b9a87b080c168b1d19ecb92c2b4ab460462880b3ee57e3201e7870b2c21c1be3f150754179999a5c8a0147dc2f061180b58f420de05ab3119c9dddad62e8e3940071f14b7a5cdd78785952636d0be77240f8e3cc9f85a871e1fa4fbecfb92eeda7ff62d7a32b50a643ee1e65a42ed09b0eef83d85b6235247407100a1871028715ee2a042ce8d12b60b894328928d4c778ee2b5e737a8c9ce83bf40ed6884ddb4214ce490b2b165c03e6942a7de4d03905f8c3372ad7068cd4990422e5851832dcef52200b41d7afdb5d0119a88bfc3972e27d2295ce7923c94809e9eb15e46325be1a6b3c2a9b1f991a922c06893f6be0768ed4c481e5ecd06f82ff4553e6853b3811866816d70ef4fc7bcf489bf6168d7cc3f8945effec67a3c44e36c39606c65c858deaf22e3136488410cfc374fc94db05841eb68f5ba4fbfea62354519cdac647d74a21140596c258ed8007e9136543a2a6f01bfca7b054e5134bc3462c3454ffad6cdbeb9ceb56573832b4cbbaa351477bc718a8e03b4f933476bb4cd9f85754cd6241eb67960760646983e8d6160426247bc33ea8bfdaf8292dde42852cfe4170b3b03d3be313dc7366a74eaaf28603bbea30cbf6fc1b4af37dc1e8b52cfca94fa2e3f2aaf7e3fc56f667dc78e8c3ebbd27c520d67fc1d31ab7f1cf6b04e7467b9bd17db20d61121714cef11e8e32567eb45c8b06c14c04fc44d11fa24bac8734eb6c1ac3a288c9c1c06b6a42bb9756f22f2c8ced6462c5f9fbbb7562a42f7fbf4f166013aeb3d4169dcaf9da0409cd231a1975d62b90c546755e323c30f7bc375a4dc1eaf43af8e9fe504ff5609915d5f1fcd696435eee6bbca3bc97a39aa78856f327cf200394e9e57575ab4d1cad33d7e76eea474c2780aa90586d6562812d8fee9853f73662ceb10947e69c61cc269c944175b72a7709698ffebb3e40de08f62fde14dc429bbc6a9bfe1cf82b87054aa2debd1d6d266cf560db85765b28ba0a7b91984b7983ac35abfaf25d573894e6860125b0ef3abf8ff102aa764654b3aa37a6cb8300045a49b04778b66ae38f57ce7c54ef41a57d22121d54eb9ca3f174b1b730e5a8733e1d48de0eb66531e8695242f8154508cdcb44d0bc84e7247185aa0b54c93ec99871bca891be0a7fcc6aa11e15ef613fbd7d104c0a13215e661643ae03d6d2fdb995495ce0c1de1522196d24885a06d1a8a835323d0f748135d4a5dd5d8f4ba8c1d6446e6bef82eea5cb3b8ba3bfde90c4e64c87825aea1d074ccce52b2eeb33816a6b34bfb04228eb95eecffd07db89b70d2200302815220f85df164275c1a6afa2aff4fd80acdea4acb360ff561bac155ad03aca5f0375368341af9d5a8466f37cfd0efc2c0a20bcd8df76732f642304ef12982cf627865c9ea8c48d8ee6d93feab39bafa14dd6a7c4135825d4a38c324ccb0649bc4f0b22370e099338f4c679edf83a0fd4d94fb1eb5aa41de963cc11180b653ead6bfd4f34f3e14c4c33141fd22343d725098f1a46310878b03c2e22cab8eb93b9854e2203c149623a7312c76661d9610a078606aadc0e2579c407f0e92a121db0c4dca3391a596f41effdfded254a395f0ad0b434737f941b84580f94e39b40662c0ec61d9c146f963de34e07cec414cf7ced744d4719dd57834e076a6bbf7adcc1905e73889a2368938c75618c8eaa27db5496cff2db19eee6e19c7cefea76ea4bfc4a44e3d5b4023cd688e21923dd77679e32115dad77966b6cd1db776cd5ed18bab6cbebbc3fa8de3eb1ef0ac32cc62f7cfb713a4ff4c2998014f3e2b4bc2dfe525efbf7ad758867c3d9a26bf34bc8d869dd7c0534f5cfb8979aa0bc27ca1dc2c10384099aaef2fd127c1f72d2d4e29b85e6c99b646bfa3b65b46132c83453a579056e59337825fd7be236abbe880457c02967e55bbafae1ae6f779be4e1c73a4e209bbca284641d9e233a98d0cd316f94d6638a9607dac492fb2aff2e809699752e8601f0dbf90e15eac8dbb0091aa8308a240126b9db494c60235ae5c98a2e2da77438893d5ea2d2041e6561efbeb67ad4d04409d5c9824203055331e05fce84f9b64c0e35000ed4e7b25577e6ea1f4ac3ab1020a3a979bebae03e55d6782e5402c28b282bfab7689ea3c622b81af1be0672281e5cebb1e08b3c7ebea6a16b28249bef3006bad7db4dc49a49f584532dcd9a37daf73dffe8056da1d36ceb89b2f5cbc7aa859a02e6de6b9a772cfc9cfc1a0eb7d5b553ead217753f63a1015cd37e3dd0abba09eabdeea0afc5fc168da46b92a84232f2247b3d06e74a604bfce28899422bcfd1a72c2ecfae0225446ee768ef360eb32ff91b59e515898c9809bacf26ea11ed8a7530ef814997a2a1f11c7334a8a366fc53cee88fae9af36fbf2b475b4b3cd745019ace4eef9e1a60b18a369c8a4fa7c1062767120bed3972b6f92d1be2aca496d5095f5736b1e0b75b154cac9ae48ab49e6b5745bf2f005f5e02f55d9025b28df3989d4cbbb5b13bb88721f0d158c9ae638bbbbc7048b6ce84790e1b76f16b9ec406abec840d5e81f133f7bbfb6868373f02d341afb005ffd2de3c758ad6b1574345373c364dd81868318675bfcb1bd9217559ab76df8a01188188bd012bde39f1cb04d9bb7a8e02f30cac4439e32512012f88cde4cd41e6c085a6f5c2ad9c22825d62b475767b598ea78eb6e4bfaff437927652974a56ce5edb7cbdfaa1667c23cdac7318c4cf1ee49a5c15b920094759648f98cb7d12f4edf209fa23861498859916a49fb7806c8af761263f25e82cde71596741332b34d45544466d380bf1dba73b110a6d32593c654d574c8821f5fcbdaf02e7f198e08011ab45ce745672b99f25e4ab7b5bf0c164074c31f14eca122d9990339fb58e09396fb6cc8e4e4159d3a17a68413bb7e68b0b6b6cd35f4011e2d2e651353e7d22e48ce95f60625cdbd8dd954ca0de9451671b1a7015461366c2770d50afe6c9b6e78810c9198a9340f0f38dfeb507462717cbe4d76e2786b73c17bd1582800f0668e1ac060416b45f84187c78c683ce67d3152b78f913a5d5747d7116822ab4181db9fb8f40be78d05d79d4da1c6e982c66bf1834cdead0fd6d900f322ce61d91051e004b79d39718a7c0a91ea94b0392633bffed43072b3a9e1f1fc032f399a8a29fabaa3b0fab1d0fe7aa5228ffd0724e989d0b4f4a90269f244795535f67f7ae7bc8737751f89d88ef21c146f0917763efcc3596c61bf50ca090bff3fccd55741b28308e1956bf3d77f54b4e0ea83876f09ac20861e522dba6672f67f03a0b819df950d6c669110a64cf21c470c07da74b5a44d8d94fa368c8fad2f18d12a9bcbfb1cc78e0eeb1e8e644c3768210e4cb24b0258034791044579ab5d8ff7530f702bdfb5ad2c75928a425595dc7045bfc2271d66fa12f595beefa83fb8ff3e232ab3e66bb491f9e1fafa567d00dee42c585748255441211491d6099dfdbdd52915281b000ed33946b53aab4359ceb97f576182cd4825ce13f4ac4e80c209f9127ab70e8ef16e06ae6232bf39ca80d8c06e5e6ba6597fbdcbcc99b35acc8f9c0f40115612c25596f0f9fd096d543235eef524414e502da49f7fb111d12bb0bf1973e2f425dc492c5770e62dcfb013c9c1c8900ded8d583a6112f6220c52a7f271d95f6c3a449e024a68e5dc3ad2b48eb352d2a4bd3712b8b94e3c15ab279af00aa63b210477e79fde59f4dab5133011504997310e6640816cd7af5bfb6d62365e9ec1db59ad4fd0cbf29e32303675157c8be10b49fea9003d58c667a86577c1b51e6251a6ca36d5824e713f0d2ebf12f3210b94414735c1e84b4b57e6a4c260acee5c6ca30b4cea1b84555fb913a5de08180b4ba9127a1847832cf17654ff1398c40c4961765317fb910bed399f6441c6eb3c32012b1d69c6fd35ce9e6af7302d1709796523b1292cb0fa1060bce2acdce8f1647c41710368d8348d12b5b340421bbe90b42e88b3bf148ba5a7f5134f2181cf7d16d39645cfdcf3e9e02d5ab5fa782f7e4d378d107b296e339ed7d6792d2a58e4bb634bb14a2f9ac6494e292c950681194e9ed080cb32d2c7458ec7a1bb2c5f89a198676e7ef407b6d293b5bec03d2cab0b2d409e6c3110037c3ee88996bff7eca37ba753b5ae6b67dca4f5310309a9f144666c311e6396fc15887cd70d9b0e97c0e560e66c667fd3a3f1867e6a3b876e1837c99cec98b3034e4ec5e5ab6b6735bf2882e79ecd37e8be05c712728fdf54baeaf0151b6c070807f66ec21002e26feafef067db83e5e73e0293742001931f594f1cf3e73c1a1a98f744ec03fc3f6d43eff67006d39a5b7b7ea95a921432a8c3615d8c8211912acd2414529008530f43eca27da00b78ae59cbed9f1e0e7385af9e1f13d4738ea9db6482afbe24faaa2afddd8bbb57e4d81ea89a8766801129e7fb27fd4b9126c2df7bb29514539876dcb9520534ec096f4fb8fcd132994513debe87773994082b99b9f77fe64252815d4a888faf331d14429d29dc3bffdc6c1dac26d8b279fed170d4f8d94c6f538c1cb61aba60a8ffafb140ccd8dae8c2bdb7b3c975e312fa40470e55c28700035f9203a23db2ec473bdbe24ddd8e140f9d980c1f91affe273ee8fb01152ec6228fa6c86e5d9f55bb7f5b2899611ffdd2fc781324b33c3a6c9478e88ced3f47b50171c25077a4f641ad8ae0e3af91aae9defee31b13f74d073ce2ee6997027c31e6c3c7700bf54c3a373b834ef1199d08daf8bd19915dd57541666b9309d5467e1fc001e8613e93701adaa2016f5e12e8ef1c7bd8cb02439f74e3d6f1240d3b7cd6cde38471163afe44fafbb8c224cfa0dac15567d23e9d11e7223a99aa1618701453520386c495d28351c4b89ccd40ee60ebaea24449db1dff7af971e3e1f9b91117abd63bb8bfe4ef183a8c8ab0afe028dfaf8b6d0a6848fe697436b242d6e1d8bfc03a7bb397f73e92e7c061ad558fa5c9c2329f83fe65b2429f87d3e0b25024c87fa47d798ce8ee7e60e74d27550fe49471ff84028c4028bf9b0711c68516a285ca3642940f0276a7a1bb5f5961e29f1a186f5e6cbbd7ee1c3a3286a71a5b63578492daf0b9bc31278899eb3c1730aeff8861018cc6274c831aed5cf6884dc9812eee6f7d231328e5b4fc673a6292ebb0593eb284928595f7de885dc87718b8f9ada378dea4c49fb0c86f517765d4df3a3744c0be0d5bc8426e27da4cf8bac6efaf95bf7fee9940830ba1eb2e5ab30b5e8e1bac02792b4e74b00a0b4686e2404d6b06442436c31c6a508657290ef179d2f44a38e3d04bb8cab93255ce43574afcbdae64252a3557c9cb813ff0c01c0fe29e19ecce2949ef4cdc9dd57d628bf66a5f6d2f1b016722472bd34a60c27ca5e1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
