<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"04f4970c8212f0aab5308818e4bc22353714a75ccd921a24582b643f7b3186bd5b6173302d4cbd535accb680fa1d162fa61277937f3b4d35421254745c78a438331a35c624bef27859e951728c1b50c24661b328597277b72ada3e07ed39a7c51d677ee488bb8d2cc7d14a66537ffb06ef5df8be8c4ba6f168559dc8f29630bcf2de3cc6ebfdeb4567119652a0b39d7b4e63bdfc46e213483057e0427d4e458a83760f81d5e587920adb76cf32be91ef706a6419d76055be651841c178c23064937f5b9aac0e9431e98f399613c8161f90637102351cfe5609d16e4c2bd56f45fa8650dbc49bc6bb029fb011311b092c1ac81967de4c5a949b5f051f5fdf9be6d17897f1058780f01a061f90e0dba9045aa26c3e8676eeacfa6a4839bd8c25c7e0c2022ac076506dc21c503489fd7c116e0142d7e010512c41ec89d03ed002092d86771a4b5620a2361bdfbacecd034cc1c89d0eea2f3a3bfef5ee50a8018365f256c96adbfad60b319274f6cb1b04fe234fea17af253d0f52b176f7f540a4c59b6a9245a877dfa23427a645e32e0aa54c3b1f4cd6a1290389dcb70a0ef888a353ab726524e846e605d349b4d05ad8c385465bb14b5334571fb320aaa1dc197977addbb738787d5dc82a74ce82d9b19d8f3318a57881640591899e4970c470fd9c5bf9ad8cc6043d7a6508b2c52c7497dd387fd2ae691cecbde29d55fef2bd157c612a99779af6e04002e54186c3dcc9e43800a199abd7c346f68b36b11f9e774d85a6d9935aa0d11b3f6d9f89524d8601ec45cca423856e349eb8b7b6d2da3a38ae7681c4f00d8bcee3c7df9476d9e5f72fb9a0b95b2db1555c03a212d6f48f0364f030525feedeaebb90024be7386a799aab5ed2eadd9b17b6bbfb1798fd668916c7f4019c1855c012afe2f54e9e10859ad5b59cee03def65c8d8cd6606b60dbc8ceae8e98658bbc483803e8601a866888b70802ce34af97745258bef553ebe3209d7303b3c3c557d89b8bc27fdb16176d91c27f0b9ac610b817635b9f8c6e305ed827540db13b9f304a049f764523e766059f34c6b1e0dbaaaa26f3afbd895c174dcef4b14fe38fdb2c193bb60c28fdabe7a86c8e37df13a161c9b74fb4cc88249d3aa8c4899d54d6c803abf80f954f9c4cf03de89e3b205c8097ec4686b296e1cb88f9cd01a1cde2af97d0ace291ea45d3f2c4f208cda00ec49ddb3969b1c2001d14d7401d7a3e75ef418c8d6a5ac068c1f689c5936c3f3bc9b8f75bd5717500c06ab95567b4c4e2543da7373741ba534ca7fabc2931c9c2f84674768dded16d84a47fe10a08edae044f1d35ea0cdfe45a11724cf8d326fa5b86baef01ffdc086be020a684b42865dfaff4675754f4a4590a226ad82c57a69436eddd96e2614891b327d9d10b473c8a4cb4ed96938d332e01bd1726900320f23f4ffd6ecddf57da378ebe7c7ecdb02e757c3846a9835402e805819ac30e29669b228fac6b2ad09454ac7e404619bea7c2917082b6576e882c53f295afc154f48fef57eecd09f2fec1be161071431d8ddb05032632fda49dba94043dd6fdb8fae315e78fc36f18187867b8629d0127142979138053f5c739169174a8a2cecbd2ca3df2d848ab1e3fdbf1998b5db21fda867cf842a0210e78cbfc93f801c7530aecf5bad23222bddef54dd07c906be0ad3ddee13da7e78e4f329465b98a2bcb7445a27ae9ff2fbc8e86d9497979916d2d70300a2e76f268ef7740e3ef833084676b38e44827d2852d37567e555bc685a8738be4edf545802e1c76daf24b8b93787b9a74a8e822b426d9667211480f1d70d3476c7bfa87d907e26f701ef97f9f23a9225b062ed5b7cb2c6903200836427f43ac410448b4facfc5c316fffc68ea662100bd76e76812ee467e20a0ea705410f7295990d82ffd80ce507505d989835c225d9d36da0fa0432ab9b400a8d21b3a002fb3f8977b8159e794752af4f061b7a255a10e245072ddbd2aa203c5601898bb966735ef5dc0bc421d0872d4bdc400eea1bcc47100441a14f93d811b772cc92ddfa74693d533483cd13c0b3be3b09c937d141dff6d585e07ffef840a94dbf0b0623dbc22412fa9b8400cd5f7c7aaa32dfc51c8d269896cce89a5a9723fccfcd1bc184e75e5e95b72f7cb44cd84c5a40efeada49c4c20343ed495665b4a6fa687477cb390a6e415e770c65a507ef309e8d6365cb87a1a89a287fbf12954761e7792101ed85060e3215a449645c9b07181d8d641beb5da39d61f1fc1cbbfd8ed10471d85ddd4673c7147933e618310fad9bc616d065aaf9eb2279b4d9d8a2730f54b5a70b3d57b4caaa5fbf70d13793e43315d69d71e8a30f1e1d6ac917f9f4209c0a6fd70abe40d061f947e573c9ae0a235c5b558bb4b896eb30c6392b204f4f6c594d63ec8c5e88714381b35a2fc545de0199bfafc44135449fddeb73aab3452de612726d868a49f0f006126b2d9b9eb0d427ad804f55e9dc99975cb2c548188a4114572a9928c46a479464e2bb0e349a6291c3034655a11bb83c4718d772858528a1959b2bd1eb500560152e130b0d7e175b2879510ff70f5d3145a611f2752705942d59a3dbb13089c17403bd66ee5cee5fc124710a5f08e56aac42de891817d779ae280f369e229aba4d9a20527b1870c096fef616f8e29564fba109ce930cd00ee93da5898515df3be6657c71ed0a8adbb135a5b35fa4d13f30072a2bb7a222707ba66c157fb75a2e87c50a11950a8a17ba827c6468f80a4f098831019c69d93fe7ad7c9cc911a7b360bd56cd6e92054c92d61d9738194886306771bbbecd43f6407ee462d6f040b64e151203a212090358dae32d83a98773daa67c6d5738fdd568ee2cb8e122fe58a50c6b95981861f3f989b5590486b6bf252dd1c87492f114f7931e0668e4fa2f0193d15974e403e2669da49c1f0fb2c6d9e0707c8d6717e0329983c286bd97b1c63ea57bb48e4c60f367e26e5a11f7778551de3c6cab2ae74ba9f30f325a16d35234ce68b7844ac4ed29f1a002ce2897b433bcda33c9547e9d30fa2aa8e84b8489095f8f88aefb3bdc2a29d4acbf9d2eb812d1c9d98ab56f54b50c39076a80c40256648bc04f4ad7677499b501725cab13cb4a6b2e2b32434df597bf70f9ea29fbc11d46af5b5a3526270906ff4ac6eabee156e89c5c69a38e9d958635edf77dc76cc8071949719cca1124913ff3ff29a1399a7213324e0d1805ed8cd2c2566feb00ed14500c7dadbd06261a8b3816e590a21a12db47c274b9c88245f5a004f7428822a79ce2b5791a17e09358634b6ef44796d6807470573f1b106717b4a15118d1815f5036ef3cd14cec46b5dd2c43a69f8f13d8c68d1e8b15020e8aa30604a61782fbc026861cf04ef7b59f8afe7c62a6e31c03b33b87394c80ef86f1dc0f097cd9bdcdd334a8e523152b61bec8781faf65a864d49831f14617cd0b3038e849484289a8c87cc73057321157902b5065ec19db6b0ab11d29c25b4d0c548d1f270104a1ef884f56762c638b6587dea07f7450e88152e4d5de81ae2727baaceaa5dbffd48a99a3faad3b5bdb05c54f7bf981ccb16859b2c7d33b598830a05ea6c6898a329541c7048de5bedb7ec26670c3cb027257b9ec871f07fefb90f2b2c4794941eb5894d4dac0579ba39512afbb4318a50a46fc43809dcf170b029dd33934d68831191fd11c2fae4fa405fff792f55159d69538e0fb66b55864b1d535c30287776959e5f4297d3c342d837887356e8be48b5e8d73bc830a8c193db84ea129c56a5a8c500ec917b5c71869235131ce9fa28d1f8d19f5f57314451d21d0486a70e4bf435eff4a076b51129c9dc037b7207bbfc51c9282307a0da82a4a500f6ff8d22d9ea2279c0b8b54bc0a5866f4d6c91b17c63ab43c940ca81451383887adca43b448250c424e6c9dae49352504b093ece99114d2b80a8afcd2505439af5557c062d3343295a1b8d031f3900928e6b20204658ffad26dc2d0639154aa4c80071cb87623f584bfeb4d7013c8b30114e07fd3569585e3e202b83104b3cee64070bf126f50ac3bc68817f371ea4693c3fd60f052f0dec12f48cf1c36e9d2fdb5758c9d1d1cbd626737d93cb464c617526e1ab241ac7a68dfff6a9d83b3c382f9bcd6c4d42a2ffe75edf465ed97fae8663cf93fa729586420527d48a2436b8da97e485dd6e7f4c31b6203ea0a8c5d98c04cfb5e1e9d7ac33fa346a68c3b0148e34dcf56ab0c59c6b7393e7082061114037004d98b8574b6ef87c8afa3f8258a822586c6ebb3cc149ba15317b198753c0e07fdccf09cb646ea4f1cef7f328315c7f92e734061d6a0e01d4b3a16ac751ed92bbccd6bc1d46f0600dcb6f29db215c72a52aeb48c9a5421e4e6503eb3cdcd6fa74035466970a12179d7247e9f41cf401fd9b055e79c2844cce623c49ff446d2e9d6be7a3176faf909e9ab3ae41757301bbc495bc89f04ee174d12d914cc480b1c90b24c67dd47e2850f32b2334825f6c69bf343fc5dc3ba808b309689c933ea1d9330c9e0d05474c7f891ca1ad760458ab8b75a742c2919228f2d405b7438c7ea07ecfff98dcb5318783ff2fb01dbe1f7268ea9c03c14a35652d635bf37f9bdf6ac6a1bfe1185a7d09e2010d080d4905a40cd05112390ec816318152c0e7dd1c2c9d1640f131ff07668b4aec7b57342185858417d4001198ffb68128fb083473e9478b640551b4206445855c13f91694cc1febc58b4f0582ff8bc243c22cb63396b1838bc77c5de35cfcdc7428b69ec1df02d60700d1b68573de5882598cde2956dd7ce52ecaf9604f51987f6ac73e930ce0dbf0dcd48003184dde9dc2bd23e40ab7e381e0ad3c16ec2972484196744f6fc07c6347cbd07b1ffc6062633685241659be1b3e7d97fd5b43fcc9829eb9cc7c11f11dfd0b97bc887ae5cb1a81009d113a353960999b8b5a2c1cd8e231851dfe1183d01752c841f13a729ed09e18891e9a101134d88b7d0454f2a28ad9234288859f9a82d527527d466bf4431cd0dd98b58b2485e8b6ea498133e3ce3bd5ac3fabd90a64cf74d7bc07c6173239882f6162ae6da3fc3a8bae6e27137a1254cafd5393e36fcbacec84137395bc656138d0dc919d0d0bbd69420fd2804e091b6febf1df510162ba61901c442e2561ed750945c93b1bb4c20923625acb44d4d83fcae36e9299016ea77dc43c9e8642820d3b63f70eba19584326f93bd23056fddf4be4215964158d2eb55cc67ec8dfb54979f064a3058513aad36acf839a6b19bfb28d8f4508fc69584ac87a7fb78299955f850b359f05684c6a627cbc66b53dfc09a366325b94dc037b812fe6b46f73feeba13fdc7635f94bb7747b0aa9112be2ad6bc002801381a025eab578566755dbfc187f6d836a033d0df3e616295fdea716656d56f810e4b8799939dbe0c6ccd5e2ae0c10af601075d17f8fd00d056ada5222d971e01dbcc865d88ee50623113db93e2aaa919f11194e2ab8b1ed8412f42d8a2a0db5d0c1dce0ab8604bc2756ebccbe386a583b694ceead5e0df336093238aed718b386a398456ed90d39644089a376bb5e4fe20d9e8271b0b83b61b5c8cabcc6ac86be1c56d6649b1b2ff68c546e9d7e074894b5b2af5a84ba10843a9b006fbf7a06eb943fc3adb27e50f95d7d1fe9611ff9a736c0f7b65cd6ff2ebba2a327d6805baff496b5817cf26253256f1ff1d8d93f1dbd45d371c9ae7449999a31bc714f39c2671aa82be1b294292bd781d5349ee7b8e0020611cf2e5d68ad297ba453ce1552b484d9bc0aed2245b5a2329e5a96361c6cd8d979eb5d67efca8044f710d443cc34bb702fae1e7ac9723d9cb8c750c8f49fc53fe1c11866842eadee21ff54c509e9927851a0dbc679dc5ca97a5f7d7c7eefacf22619112bac8ec08426a3cdef4f70ee36807ca948dad2cdb0b2716b817be741863a0b9adb4f28cdad765c2ac52af0cc575280322a73145060ff67e0abd18b046b75d2762131529c21056622e5fa9e3ca350ddb51c570bc53c30c36bbf94ce283bc669bb4154c31d8ce1d5608aff12d909e8de4db635e0082c8967bd9c790ff01aacacccd248e8ad1d976816b98c1443085b3e00604de4aa314631b4b10758eccd1e7d0fa3a7d718c169818dddfdbb838d386c28881b5f88304c622acc252b7b60a680395844dc3016958da2ca3d29cb040509c3b38544d0094759dfb4c12d231a2e6632cc389cfb4a8bd2970827cd6f4ac2ac3ea44eedad7b03fc5d2d57119f9e537c0a21b3fa1210c0ad20f31995cd2483b5d630502b89989f1a6648c167c5bcf8567b392a1a260451c1c901008793e70cf9b582ff120595b8189128cbd8604c49f2b4d9130d61c017fa6654a06a42187de221249dfffc6d6b8fef04fc1e917429d68cdaf382b758da09ab7ce328ece6e0d776eee9f6f233d53d2adb56bfa093a48839129fa7ba9d26ca82305b3e2d4e2d7bf8adca43621ce21c9378388e10e8eb3584bbc409a6ac359dafdb21bdbc2a32574ff52f05fd514ac93e7e08901a8c528f21eeabb49b9113a5140ae88000166a8a2f28577bea8f4ebc67047169a0f89aecaa292d3e82ec68747e23fb17adcb23f5fb59b4ebef5001d60a9db5968743f27dde9ec93135bafb5a232a266c0e237987037b9a4c48204f79f7109e64ddd55222b9aadd2e303a3148dade096805141cac5e6feecd0624aeee72f23fb05a5912b14e12c63391a82a31d55764127d8a6134d60f6aedc0deb6684c42c4cc7e37c64b4636ef318d7794cac903e287b7383239d49efa620441d3b388bcda7b84b62b11752cf88ffe01cb6c8fb0fb12aa2477eb942b703e20c789686b049600f84357300113d19142a2cec194976c293a296995180536799e426c0cc83f4d22c922bbdd947c7e233e11315c754adf37cbc0505b1b01b74f5ddb26fcb294a56d8636b62429c5c24b163ed9ce1b8d0948f322cad54fe2bf90acfd7ae759074d20028fd25704b99c56c9d721876423342783eea989879adec1b1270ad8a3fa9b6b67a40263c99973280b7b536728282d554f45ffcd56f97e1a5748c63a1fa6ed8d2684305e6d3a7ceb247771a3d6797bd123914dbfea57e2f25488070e568b745726342dbb9057b459831eef62a82ac91e5c6e4a028ffb261fa952d405552731cc8d87651cdcb1316340fa924f4513be62c79cbf7a683174060a5f069686203d23e7dd38dd6bdbf2c3d65c96f69658b8795e7d1398937759854b703b6d387f436e317df9f8cae536cec709a5afd90a9fcfcafbb85bcba8dc05f3ce928e1e693dcb89020e28a29a07a3481c088637631a23cc7f01290b347a9e1ac7bacbe953aac4791374bb4742b1ff03393933982b501f688b8fdea752264b534a639efd0648260444ab1ada1c870344d20a82002f941e908b24e79ace8d37e7e976ec5529bb6f8b8625812b6d3fa8376d7e316c382c637cae42061160964bb32f86228c09b1473818d65399ccfe4adb1b34ca57bb3f87042ce39d948f2a54ec97fd4fc0a8eca6594c9a31d3288680d87e727792bf2095081ada43e7b654ec4d731051db55ef1d4ff18b27026d61729fe0629af69043b68c8405f5e95d4ef6a0a005c5eddf614b975fcb1ec55316d8702cfa373659e8d45566dc034f949d54a0a6bc6437e241dcfdab956815136795ffb2acdd6453482004c718c642f1bdc180773743109c98bea3cf5fe0a310e30d35399b1844fb866fc1535aa5eacbd2ba02f747093990d1fcf45fd91bdb2b1452e5868904268f52efb4c5ce166bb7ff77ee2ccff6637069507411aff5c3a0f13e7af71c85b88c3c70ee5d954306550577618492ed6b0a088462c0c3475f4c2e0d6b491f87d9ea592a79c09aef42033e40c4854f3421f2a395a5309fc3a348e977a0dbf4372bd0b9c1e615ef330fb655d589ff16ebbd03ba22ac4875a88e38cad60e51224e5d92860257c15e3b1a519038e23f8d12c7c99eb288a5bc2060846971f80f272214fe842e18dfb9c89e3f650de82e0db526d9affbcc4fb971841db4d048158e3ad5f72d106ac6dd4af84249c507dc34f7cd8b9cc5a4b4e4dfa761ae99aa09648915e9a0a1c93778a62b8eff526089821b782ab6e8f5622844453e642bc61979ee1bc0f9567354e7cf230e51f1ad85283dd1ff6ee99b6134d9e67e3b877d0a419cc570af96235f02719cf1a447efe36adcb34948a26c3e631702ad9b061a289b452e16b631be6b8aafa3800ac7ad04e0332939649d8ce6559648f9c1eadf6d874cc2d7f59553bf8d5bc5fc3bdb7acebf84b1e4790116406d7c1fc507c464b977536c33aeadd91e5f147acfe0705abfdf0d4051afab67009338d3f09376932db453dbc284fc968175beeb2848cd5ba48f0117f4316beb5d8bafabefbc72792710a2b8d1738aca5ed44000f350af53c7a802986a305075dbda9c2b0b0f547d1c3341b0771dadc95afd2d2954e2761c145f03fb8f279c7436886228687c668198b4b63089817b8b932c2cbe3d912f75d8182034c1cc381892406c9e8155e678b83ab4613aff1f90eec8df5248bdea3b90365ff46e9ebceb38bba3d3080c819c5d4405721150575c9732e2afc147e55021b774911878dd24e1258831dacf6c6a662b98ad024f038612d9031270ca49b87c730fda7340c9cee46f803686a996cd927ed2acdf37a045699777153907b7482d280a45ab678c7babb715599237ecf1a18d9c015c91e32771dcb159555c15920c0d32f029ca1e657bb4269dc93da4cc49da1fa98dc60bc8ff9b05b0f04a4d4babf0a116b1195d17dcf85667cfc534eca54601f750775c864d1d9772dc19978c75bdca34b78a07c6f13850c2575ef715ddc53bbf8be86cb566da2ba4f90ec95f1ae5b78b8f7b5ea5f33457447aee97124651e559356f9e950bfa89c93dc43c651f0d0ca3a6305d793fe15aa3c56e152e963d61ac83ab01a3872af22634ad3af3acb0067bd3412d87cb01f6a71c96f866f13e9320d5b3e1fb41f230f15596c7b7926d48d839bd4f1a90054b14c3c78570f8d2f78f85d89eaa5b13dcdf2bb5cf6d52e04a3631385b8d1bddf1a49ce86c89d6915354b64d72b8535f622b99dc4317ea1a46aaa2c1a8bb34dd294cf4a09c84781dc1bbbb788602d2cd61b7074a540836935a06b20a62771d0748c63a894590fe8d09628f66e2954323aa076bc8f5d4dfad277a818b86b3fbdd21ae4914c3dcf989fbb0e96da0c874e467c6552bd795eca5f192438f9ca91b4a46414a895f975559b371ac478c31e5e1aed20c63c4a1ddd5af3c80ebcc339e07dc65074c6e071d3076cb3d3d4d348d0051192fc51b786bdfeacb6357521b02749d75d89a2f5ea23561cbd11ccaa45d48fb96b4363bdfac04de8e8e0dc23f8432c104c4231e589c735a8af2cedff89622026e9bc7313f212882771b38bf2cd4f07dcec562d5c2957d76b39ce57acaa3436d2de30697a5e0fd982d074e250031711e5d724822e665061ad692667a7450a6e838adda1827f18a29ec48c71478a2c3f821a6ac06f9c682f3bda569cee33ba66a8e71c11f6ce564c013cb55927e2ded9f218957573168dedb1ceca04a75401ba24b0d7d32155a8d9a8e04fba162a2d64d7fbb9e7c2a15a27332cbe61a5e7ed983ceba3794e7d36c8823805649f13c3afa8a0b2c851a090da7fade2f84ebcbd1921917c6eb756332f78473c8037b8eded226538fd8f6a787c1feeac36dce9367ed4c3e5c786786501c979ec2767a17a3a3e3c3c0812a8931ce7aaefb2d726aa0ff1380dbbfcdd3c20930a5f78034919322561ad93b80413f2bcbe04f794b3eb33c0ac7ea64795a4adb244cf12752fc7e8c7cad352ad930fa79bf7fe82ff5e0ed099dffa41035221b97ad3c610574822312d95be8d107b1fc5a9e3ff9e85ab096727d970cfe10868f3b59b7d9a9b4edc6e06dcc79f1b71fd93dd38faabe0672dfaca5004604c0d7a2b3c3efea92e4bd7cab672938fe788bdf5f75b488bf198e0a71620fc1376b4d231c3c35ccb17fff16cd50c4cd638057b0d4630e5448b5d4d1cf99361681d3283fb8b9696129c15335f3589cfea4579e25ea3cc0b7c9e1ea8cf738b43d0616f86afb3886bc95054ae86dac0cd8a5722d09837077ba5b7c3269d447efc98ec7e475eac7ec660a510d1b3c4ace0ea7b69ad2d9131790778b885f550bd56d3898adc524989042de0f3deb5e71e087f6d148c766865577777347d47c82f7881259f4b6c0940bdf726a4d6bee0d882e0beb4532059a9b111fc90f17a783681df3c1c7f62cccfec3b15ead1274501aaf0e412b9461a9e1fecd3c9f86de693dfdb0a73e7716fed1b8d4c80895589756f4763b0894e87ff817bc92e852b6fc6440c2f72992221a4fced787fa0c063b3b40fc482b9c0a54c98e68ae72c7728492fe0242e65090d2e7e55928aa6bf063f76396ac898d8c5de5bea5555a8ebcabfa5dc0bfe88d6fde232cf489f68491a47299ad5ebbaa23b9effd53bccc9004a61ff17adb20557d88b5d58a83654f5b368255a81e790b52305958aeeea433168f804e28db1215767eaa8655d7a8ec71ed1fe2cf2e9521973600490c97b841448558efcd5d1b4b9676d60f9ba2e5ce363372b63edb64c5b201e90d04941805153c9ccbbbcc2b0f70524d4ed2c91a9cd5a08ad0147f2fc5787a5e76db7d9263d0cbd0d87d9456dbdbcfac7536070ce769cb1b799e99fd5f7e1ef9ba5d72da55db9f34dd6e637f504731129b0f10a2fcb75fea4a47f92de5df2f1b4b1612919c3417eeb586036c5660ed7e2843808fe549e60933393ec0e313c87fb73deb19c01d3bc2d657a09ef166a589a60b7d173d90906615b90ff65abf88dad3a3e27d28c9c4297a638877872ff5ff6f12c643bb269e5373e30d1a88b388fef63cb7ad11c797e16f20ee0c43e49c0ef950c77f5aa77772cd8ee6c1079451640477e969b681cebbc837ce7a07aae5daea1c2499b304e7c0449e787b443c1b5b51b51ad2911a9258b9898550efb094c46007b95094d0b15165b1e760174cdff4b37e6729ae2bdfa47dcfc9fb761e15d27b583a58e2769d4ed73c7c21e40af98e9a06b77b194eac50b507d58ac5bd37501c1e9dbf14d42cc2b24cbd60cddca97d6ab1bd25f344150499e76c63add6bc0a56163454d46cbe5c37853f2a52e1173567ce0c6e4ddfd69debd41939f17146c53a9272b6a2cd1200d1bdf9c8a9d6cedccaef2ed2c74962b9cdd23610b3426cd62c9b11e9ab789cf25e8e027d483b82b93bef7a3ff6b546bd6f6ef98abb0632a9dff152d33bea85875ac4f2220b5175b783a5144dbf189aa80313874f7a7b7ffdd16ff183f2126b5375daf97fc4c766ea62a887677701d6c72191ad4a39d4f1761f2c78163e6b1392d27a048185d56081badb5813538ef3141dd7570076081643230f4f95e0ecefa21c1e5afe3ab8104eae8bbc408fbf90b39b31c2984c2063d1251a85d4db8b53cf87497db841d2bc54ce36f4aff941c792f9349c7311a5a74b2f55c7caac198ff957566ed2c8e195664a4a27db8c5b03ebfe44c7118bec3537626f1b250a2f12c6ab0172320ed54d85e8640b3a5464e0ffaed0e77d57d59153c8551f0e5cd1ba84e85bf1bb6394a45046f442155e7e89540c0521151e3cb6120cf0c462705f057ca099217f7d6547a536565720b0400f58dfc67e2b3190531dffb783802ae2ca6e708a4526850ddb9067ac55c63ccaa36680ce8f4e0f86eeace6431a18ad7f65fb5fb3d6d10545937ea2b724bf831044da3c2f24ab16a09e2871468259b7f17ec022658908a81598beb93bb757f1db7929898efcb991e1c0f874eb42f54a233ae791158e0024f9915177c5b0340fc1688f7f3343640c3cdb5beed48ee759cdcfffe50b8602507d48cee531e1e5e71cdc1e48a3fe975d29705a686fef8bbed2823ec81c7dc35ab87c4728fe62d0b272b298658cf489babdc9e38acbf296322a7d66548e8d0be59020cc58fd7ad96f91710110dfc07f62a7d89897b7b975a891ec4f69b85150cb26226e61325d0c248d38f0e6f310932d46d13933053585a262f4b0f0c48f481e4fcc2cc44a6019fe585f16f0e5a88554c921c997c30e5a1fa7550c467138351b7ce841399950d2dfcdd42593dc8d065df58134c35513f396678edef776d10989f539a00ce949249ccb17cbd0b54b9c56303cd6b712efc3f4ddafe663bc45c90430e235049db9916518f822933909226133a2157979df61f6b36ce2fa99b315384f843f9f9bd9fdc691b43cd40007577ac5e4fc8159acaa12eaf8db6de2e9aa85bc7ed725c53f9cac949cf6233f830980aab8384057543e78f3da2ce10470fd0c54fb6c39f38d3cebaec3fd50353d596ebb14e8df1178d8602117ec2721babeb117a72e5dfd879af6836432519df86f518acc65e98d68fcda456b2c13d7237a81ffd818c4bc34943a5ed20a5d79b9dd5ed5f6e3625fcbd29bc7aec5ee6f1df81584d0db0e9034c1d55cc236e51947c98c539bf19b6422190427e5a786eacc2bd56dd56f6fac0fdf676d7da1eab679ea4f9b639dcd5c147516bc80aa70fdcc32db4a14b61be774b35d68929cf0a432cb42a832d962413a0583fa614fc9fa80c5a651186cd7ce0f2153f4368277b0ae280a120fab01f1bc7fc6971ec1fc12abe81d92240190fcac8306236b26098e39a45f803303759d9fcb749628cabe3a74df10860089a5e358a48de7b46ed12b9d1846b603a6a0aa741bd308b2da37dfe25bab7c2402a13d64ad746f76ca5918c2e5ec6ac9212e7c46c23294bd51e38a03f9b36374426539c71379579988d2ec058b3934015ed6deb11a89759a523ddfbc92ca167dd078ac2d08fca37680865f83dc9600e12c1d8f7e09adae4483c5bc50aa4b0ca8a03db87157c10ab108861c91e57a827e988dc5ba6713e6ff7773d58cc2379984dacee8e69be573a2138dc9b47309e936f8bf2228470aab71cd4bbe6dd64288248d0377388fda54347c54748c0ee227cf59d08521380d1b4d2c94e64a7ec2cfbbee8f27e63d6bc8cb95694e719b7ac1e9129e8c9ef1094a2f11f20f47b6cb5b4a84b93d0663ef3080e7c59518d72cc8f03ba1dfab81bcc9a81d00420be7a1b1052f5a4cb520e81a670d20e3d28148963785e8dbb257ab7422e70d4046f3055b7c73f0133cc53e924cc37091efea886187bb7a1ccc440c6e85be6ceab4746c6ac47ea258b77b5b03c6e0eaa8ea589cf977c05f6986dfb3c44ff2a6028009396faa2105e9a0e0f74ecf40e7a5d389b8decc09c11136f6cd73fb150de206cbfffc09b4a221657a0b7685b6ad18f02329e0ee9123b916e216a6bc0dd9c1f6569e5c49410f85c0400a2bbddcf3ff8975bad506259e40ed287eda06d2c6fb5f5a4f20b3eeb5d2ee2697a0b417be4a6caa86719f613aec927761b4abc15b2913f7467ec46316928822b3e54917f82328e3f14ad23e436e92ab2ceeeadc271e19e899bda531ee9897bc403ab9a212d63ccb7945a3b9663741a2e1abc72d1340ae3f16bb588f3b4b82845ecb451743dc028b48232c289953b05268a06a95c8df3ff44df1147d21c7269fd93ca01c07f08bda7dfbb63898f9618895ab86ec4f88c0a82c9fb517a012f4c5b278e31c3eb35151c19f583db0d50d06c386982084f2929d37c25e7bf7c93c4af0fb9028ed5661d24370739d37abdc4563ef39e8946872bed0bc86d0c598458a2c2c6a0b80353de32a608b4e9500fd4f27342d79fcb5c6347339975df584d8d8f5a6a0b455dfd76f7dbcfa80ee48f6f0d40cf8613770dbb5ed8cf36cfb6db3ced34cc977941f64dc568c143627ce201b0885017806a867fe8c2a98e2fac0e1bd947b7f5b261fff978e1c15fb2ba26b35e4a5e2423edd25375a5e5945d7b88985808e07a8417fc95d1e378fb6329fe446705b04d0acd19270f86dcbada2d5cf4da9ce6a5077f393ebb60870c9679e2313d4b85e6bb30724a9892f7cf6a372789b3d26376bc0dfa5d53eae10abd500f73d78b10ab1d616125374ee9a2e2e8daaafb452c62c9058eee09981115d8fe5c35730bf60981a9ad0eb3fccbb6f2f33e12f02644cbd7e8656acd3c3f5f3e9c749bded971431cf1f2eb7fa3f1b907aa2ccda2b47b351d2d0b566f63dfb64ef86cc868ff0e89925d060ccd66c8e81cf57ffa567fa182f831f226a3df935595d05866c5eb1c2624b494c6d0182b184fd0aab17cded605399f31249890ad9219e7dff852c731c8e34e8056d34733413f711a24fea75609f9c8b39e1dab38bffafa11aae0de46b2d4f1e9ed4feee2da3e451f9360c7afdb9a0108f287e6ddf51a3f7727452cb8ec283edbb46bae0d148a54d0d375fde57ea06e98fd5c38dedd1a21599aac83a05a4cea39a54391c7843db9c98929dd0db0076649645452376fa04bd25ab71748ffa818a2f599c5e2570093561110c377613bfacb7821b7742b82d729d7481c4b09c5bb3a6b9c2a09562626ea86a42c95c3fd32041b142f781dcdf49850963a6c50f9dac33342afbcfaecf3cadcbf9719053a1fed084fbfd9b8f56734c1dce5d8b2902be035b321399c1f80bc6ea58807acb9bd279d29132ac5a714e1c1a73276167769dff03d8a3d561e0cf0130181f6d0840b6f479e16d5b60859287d9256823625d9abb40177ea424f796748ecf4190679316d2ca3c24bbad8574eea904ce7131eb6a8888e2b736ab8fb034abe0fcf9143dd0228caeb62653f48de0c953089969a5351df44db004dfa778d508e369aa2ca78b25b0db397b4ecd92cd0d1ffdb564a64c8e406d929a93b178277aa614d1793334a5d1c288f64d910a707542885e9bc33c4b22eb49fdcb09588eb17b5c8b2c9b5c795417871296ed3d6dbe067651e13865032a235cd357d4295a8b3dd3712bebf681932c104211a4cdf0db90cd56c23e9ef7dc960129616528725ae976bdb873d57e12193126a99dcc0ca1a50692d0d3ec4f60d6242dd4826120458bb1f13ae1483918bf34d3b4c77448633c66791841d939d5a21ea410411d3c2a57a249d0a41f4332537acef857177c268ae32698ae178b8a7c344ab1af76d05a35aa87f581c11b80b5b037a7ee99071a74c4316a25aeeaedfe66e9f5a966ee51c8e7694bef36b377f95d4daca0c38b2f87d5361e7214837d2820fc3e5c32d8f548e3fa8997daf52d1c61e12d394ab58a1b4132e62b181c4b6adaa89021fd1ba5e3e15a180c26c624782285d6293aff9df97cc072b0716b4601202a4e637f037d62ce42ceff5db0fb60348d67a62bcb151c4fa7897249c4e52898ccb829068e13eca388ef9b65ef32049246f4f772cd0849285f7dcf5e584e76f4d057708a57de1dacfa10bac4a7bfed28dd7be1a7e99e370e73d5651be9baf9da7aaa18628a4d93389a4ee652937053db05e6e2e211423f2ab2792b572d335f3294c896c633f6f0c498290cefc59c3f40641360b57d3e60064d6b427185bc3d6b25b739cd8d968647476393540a6d0d0f7051317974a332eac5b58a538170f63982252ebf844b334af2db96a035bce2dbf70dc3a46070c01ed25fc9d6d38b6a93013beaf7d8753527091edbd24a800f830927fd697962fee31834fc42b12134153e375ec899dab0a1056c6c146a88208f13d55f23eecad5cf58b907079e98663d54d031d3ee55655a15b746b9fe3181e6306df0e8403f7e067e3f358546a376d07fdac835234b9779c37439495cb41322d9880c1eeaa7a84002e2987ab0a7806d104c9e64da5d8af8194f958796b99b81ff4e12ef231caff265bb2f3b1fe8996b50fbf52cb25cd41f59ac789ca69c1499b733d5d316338b82062e1187258080025b453d0203ba8e634419573e97f9d2002e6bdeaeeb68957550dd1d00a8b2fe195b487e0dd7590527db695308ccdc13972547f56880c011e5348007381714b335ef323be71eff87b34a6f12d7a0db1aa3ba2920d2047eb0bf8812496aa94ca4d1a6f5a751ad9d942ab1568b0b3d9959455c57c8fa94cef5a85ba152e4822132b419c1e4d84057634d71252b1cb9088ace7127aac50adbebccd5cde2418577453f5153b56ffdace990ce7cf640984dc5cf0055211c35c8faf71662910ff7b2ec2877d4cdf1dadd0c601226a28bef18a9cee3467293549cd16498d5ca0721bc2ddf21d6171b929a1b0b81800717758ed79e5d838af29b4f2dd3c94058b5746f7e75e74260d9b36b4b1a3e0bdc017ea5ab455ab9d2388cfa5e1c6e21b4f51ed3b9127c64f1db63184a3332bf09f3ec984180dfdae0eb392847707abe0915a4f00e44cc54b86c061ca8f92a6a143a2864b95014398d330b6b8259c25a049823692bb3793ed7fddf01547223123dd4936a4dd3d4604ad4a9b0ab03a6fc5b8ae64fddabdad4d35a6fc3092926f1625cccc8437a4580f7274cc3e0d400a0f42c2e18d06f57bd418565c4c7bf8ad2e3cf7b9330cfb6c84e353f3db0fa45601491e7ee8d093a151c78d52256b1fa67adfc1ad8a77c5585c18c9b6ab236bd126c0de521af8bce9091cb7fb68415033b282473d61a7330fe5655cc379a661b596effc97850fe5a4ccfe56c5283aa1ad194ba5d20130b8550a2f9b23b8b5954774c98b016ec2942719530e5470b214b5e34aab92c7c8a24040f8b53454318b88dc52d6efae5aaca90e54119b2da60704156ab925b6630631ff3a02454985f060905b74be497d39d634dd4c80447380f9ca3e2aa08e53082d921fb1edf6201be1b071cec875df6e0819ea236a31b15f3b1339ce75323033a643bdf9be691a6b3ee2717ac0896b3c215a730bc6726d2a2f56efbe245907f613d262d36b2650ba5bd508409ab425f75da94ed477a91f3491339dea3ba6a288f3dc6a6c9dbd154f90ab1657ce718c455921a12386aa6708220c0bdc574eff6aa67868e106bb420f8f9c90838286e35dec3c7ae269b97d9c58bfcf710a1964b2dfd9f00b7beb9f07cfc54121c48829f3a7ba6c04cf79554be25bbbbcc2b356f78247b811f187f0449c4506b350ef4395cb87c6bec6682284a6fd88f4a2ba43aaa6dde7738b4e3641c8f0dc167d86bebc1e309fc3db56234b757f999da914dcd5c702467be0252965ac6f2f4cf1cba04f625fac839573fd5cac3960e417113af0902ab0d2c079cb9f99912f1cb008aa3d6aeca4cf8d215916758fa33197be13f222defad3a0b95a06aa4e5b5d454535e4fd6dbc138f1b7a04b3f8e7781b92e6a6db3f77cad8bb52cb062211e7e3327f0030a5e996a364999b65b878a83bf05ff198adcca860fd2a10e30166473d3dc060ddf42b04fae5ea2a6d52c4a8fb944691c5b88e4a06d4e366f45768b791fc8747df9e98e4c03f6800fa7d61e9f41ea2dd197827c241425057eed2b7ed9455811d73b8fff194a875c954c3fec48f6d742898843de4c5c2773c22b377938dd13e94345a41c5ac63bcc39a8455ccc1240c5a6ef199fa908a0ea2459955a822976a9dbb9740f681829726647d548b87b7d2050797d6ef228ea08561d9b99427f7433ff35ee84ad89a10448279e7c1ce2e3e5116aad47d6c40be6ca9af18ee7606ad6fb2484f3fedf228639e7d124686954690967360c756c14f62d76ac8d0d0f79aaad58603c4a4253e98df96ee6e82bab2d2d9bdb0b5bf3c4ea0f2a330ed4cc1bde2f7bda75efdb88d17a1af1e5cc211d151950f77952c1ac963df4d32b12105174f044f4a459d5d8da9426011a36435f4121bcfb6c6cb43f23f4e1e3ef8f0dee39df1f1ee171faa765da115da9d78f3e4f5b89a88daba5cdbd27fba6bdc5b8b24bb4b4aca4095280330773eabd0c3ac44b2e1bf85b9ba8cd01b6c963138bbb980d2321d6dbc80c76ba1595be30a817f9dd403a5f924124b5457411016771022dea1f85feb40c385a7ad34d3cef0be1879db3db18db44bde7ce74f54719b0e25e418f3e49a044fcd2b908b5afde8c5f89cd39d8784dc9ede974cdd63ca1d05eab6fa419500e2e1e252057ceb63a368db261863723f27a56c18558caadb47566d8a86b2be99363","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
