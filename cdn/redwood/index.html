<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"238c478fb64d876ad524c0696fd280e226154e6513aafc9382558ed5b55d4e59738f58a814b1a630b4d17710fa2932a14019402939d47646b4aaa64dfabeb6492f02c30b99d15bcd6f64b35e2b3a74daf4da9ad814618409c431b9d059a0721794906f36cae33a21ce0da38313eb680670c6e027f8e31f489252482195d327696b9638164513cc618f0725cd38a030b5291c9d5667f6cc7afafea865226d63517bca1218c5386aef216116fdc1662d483e23fa51a38663b44699d06809683f3d6de4785ff1ac744bc07566703c1c042962cfc9cee05f317f0b5ba5a6ea9193db4ccea40a3958061d164f8a87ee71c7587a6c9b54e81d40e44f88af5ddf777a0c5ab3ca3f60161cf38ee1bf76dc5c6e6b8db8bba28e1b02beb9a694e0f74f8d4e247ba3793833e173b622886796e389fd992628da4bc92ee0cfe48e2c8a6df5e6560d43ec762144c262358652ce8c07fca5c38ffa1f18426a94f10ade64bc65b19868d995fa9cb9b07a0b7004af25b7d74feaa42e5dffa2942131a1cb99c6fbbe955ba972ab137c7d66bf2a893b67f5d27271755c096ad1c5207a22acb89274dff8c6c1fe5a79294443db6c957bfa86507c69d86d82b080a15bd4f8340d42ae095148a58122d6251bc88355299dfbe5c2f2c2398bf9f138b9dcbe95cd161cb7f3caa25eb66153a08d11e791853fa584c30833213d9e1016eb8fe3b29a45a5f17ea07187892378462ea604f78e1548dd3ba85fa45f4f412f0032338e1507666338e3077aa4169a294e09c131c31b128cc47843dd61c58e5357ea3279efb0cb212754c9c9028474528b09e906aeca0363950062071a7abbe09bb38f28dde7be6b2744d5c89d4b942007e9d1e3dd44f984d4cc3a6b05c0d74830ce5b5ddf1aa2281d90a2292c506bfd6df99c45cb932286491e0d126b9015151f6d62f140b8806b477f9e13e63a812c36ce4beb235cb60df1fba15e51e9825e8ff2a658a77c7bbf6f9961af8713252a1edca66e890fe02969093b199ca506d6c4c7fff1799bcbad68ce04f743649808c48cfc91dd328a238a5386dc6f14403d5d0fb8b81e4c61cb8b5a4b0dce170458637ed3ac1db06caf6877093fc25c9e85d42c1aad6b429ea15e671c1b0e443912e614916f2c534748e63eb790af5b6c083b47c61239166b772b3f8d0bfc8b539c3ee657c75b549d998ebc1bff254b59194243663063128afae010959d04bc01d91e2652829f30de00ca37cd9740fbc59bec9beb32f6ba4c7b9ccd41bcb5ba1a9e64937e075f7643c957cd2af433bd730c8d2305d7ce2d5a00cbbed23e8497aa1b7fd44b27e1185976ecc1618749b0eb47b29207d02bc60a4115258426484f089eb5fcd2da87a34ff9bb4ff44f7427e8c19742011d7502614badf34e0ec8fa58a61148cc7d23f7a91021f23450209dc51ba131510f213d417deb7d2d32f53f506ecfe022d5883752d3c6570803ad443a35532764821c5afe09d57bf1ce9e31b93865540bc56e1f495d06c865ee8069d0ccaf899eea3d3df4e12558e55c1932d70491ef71043230200346c174f6f6c0d209e5622245174e5189cd97dd32fe6d80e438541696a92f88b8e9f52ea2228c918d252b7ec3cc9092deaecc45eeeabe1255de6b91b6161fa7a533c424b4d7f9e7807bfa62c3b346a2832ac9d8f5f19b9ede11aeb440bbd2e19302bb67977ba89a89db00feea45d339b488cf5e87d311bb16887faff5f00d6ba9b969f5a06d1017049ae0eea4e56d41f80c2501b922e57a2a9c022a1c80682dcbedc1948504484e5b214603fee6f166388791ea3f54785c83e7bc18be0b1613b2aab8e32222e83d90361134bbd7c8b47a0af81773f85b4bf73b6d569bc5213141547df11af3054e9b5dfe4666075fbbbb7a2f62569ae09427c73662d09dc6883610a5b48bd010e92b29346eda5ef70e5d87756018d4eabaa899d86a9e325b721db8a34c4e79ddbf463ec041cf2702ecc1540c922594453b6e52ee66c7ffc8060cbae879357eed402c456c9cf281f04f262f73a68abaa6914c16d5a47b7fa306970ee9c3ed4e7526d46a5a38d75f624e15a63d29f1af08ac124d8c90b56909fb1391dc02968cd1936adb5c03ecf304ae30326d73d2030364c1855dc30dac456b133ad295fc066ce9b5c8225e29600e061fe145af4fb2ab7f65b70d0b1b75f88da932d5c5fa5fa1595d66d985dc6de2f81a20d996839c545508a9adf5b87e9d50568ad3c4ba7f172581b3fc6ee411b73a86c09ddf133f06e9a374bd4962fed42e02b0037c6042bbfe747a36a0954761cfb52dc807a9a8fceb456ed2d3bc9224c150338c97ebfcdc336d28cf8e322cb8913c9e4d2d32b5e63e7141bf72259861508a1b9747a3492442193b476d6bb23713486ad6f386914c29157c75625769764ea534a412c2803e55f95ba55137716ff0a0661fc08353dca836f07fa07a9d636838dc2f83e70ce8534bc559755f1b6550304e59940d0eeed14c1bf132ef88256f1a8522b51318d186807e42707259bcc96f0e20951e81d651f6f5cd5ba6379dd9bee18942cb88dc0d561c3c15e79db9eecf53681df6b05d74efa99a8afd0eeb72a6a71ffad90e8f2ae31e9faa9a486ad3ee2c99953b1c804c4d6368fea1e6d31d26f3276ce777056207d17f0bec03237c5e7504e65377dfd11505999afbaacfb649f9f8c3fbf074bf7bf4016cf0fada017eb0d6905dca1b27d66fcc0fccd12c28ff4633d95f74c345924b1bdd88c6e5b56903f9b15870b0ac5e7818abe20339311138e6c2bf288b897779c66e40c7f7fdd2144232fb72b975183e302187631d517d02c525aee726c5db1cc65dc84ccb2c345d1a28489694464a8d9d8d913bd5b4f8052fddb924556c212f143e793ac19bb6d62b2a7ba99365a87684e597c4e12cb8354d511d14c85e05bebcedc1e16b035ee7982675ec5f9297d03ec8d571421dc4df237c0869814ba18f605e868a1faa6f2083d43e2da4faa2e4a5f8f4484d34e2fd4b3b9017d58343ffe513f4723de8bf2c87afbdb6358b5db841f9434a0afdaf28138070ce69d17ee65d4a1257fa1cfbee8227cf966e32df8226d552c5e1b0e634ea9257e43e582f2a17eb3043e5d3426e97ce29e4b52b772e7baa30d420806ae7132a34993e48de605ada4b3cef71326c2010fbb0d3c8757386c1f05cbe821f456758f3f49eae4b9bbdcd2d1c2ab9a80a77a41b998cb4f559ace128b5491a34e97abef56ed41aed633349fa5f0787163bbd995d00ce4df59222105d3bb9ddd1cb88c17789f7e7bdf073c02d67d0f870d5a12b086d33d8cd5aee438612f404c4a6700e2e69da39ec5b7c6ae89c7f3ad6bfdb29ab8a1db4f93c8f15d332fdbdad420c24c546d555c8a565d46d5a00b84b6819a95d8ee968b37b46e0fc09a555096b68a5bdfa8b64ade36a875ca3d8a7e5095df7ba89f1f4e128b0cba1639d2860ffd11e1d0dbf4d0b6a52ffc47ebeed64199e59b46afaceae2b19fd72087b48874d55baaf1af850aa0405a608bc3383e7ef1a266ab4cba924d7d22904639f05528af62a0233aa3f0f5e9d162833bb2b6e7a6c6cb85673ba649e5fdd98e2b29ab796fdbca5ecdc06ae877ed93510c6f05885267a20f1186fef2aa806d21a51f4bb8024a3afcc7f8ab315cc3df6941c83dc44e4726067ba79b84a458776d1807d7feda507964127c78b6172430622019e408d93df6008f9998263ab07a958260a0e8329e88e0fbdd38f85220afcb2de31e90e4cd9e8e1d439183e76f85f14dc25949b0f0458ffb3f0356cfbde4c277c368744bff93d43516f84382d58afb43d10090310691176d4ecad72dc882060f7f5930cf43b09506baea588ffa2987b524f824b705f65f9258662afa39d66c040e75c47f1c4670fe45a1003866a52b45d4924c4fb6a655b1879382188c5de8ccf909fe16b9c938c0ff2c741d8ef1a5d1dc0da23fd3482141d50f167c8d895614b186f8ea7ea2a315c40af933c28c6013acb131b32eab05089b9bb824bdb27b8e8d06188d2cf9fa264505d53b6341c63a352525b72b0020e169c5b7fa442b1279c8152b9cc70e21cddb362b46b217cfa7cf6ff4e92169ecdf4ad77c29cda1bbb42ae022f6fda0dabf87f9f853087a2c397ce312bf4df9d25f9be8356884ad1da4dcca99e11ace561efe933d4f392b898728b32da2ba51dc636ff8264e8e7b8c98b1bed6ceacc14d4a92b60bbff8aeb0caa608d46a6e2ff914f9554b863e0a761ff0a45762d535ebfcd186556e82b6d6e2e6ce92d94a9597ff3274a15eb5d7c9eca49c1df2bcef6f410cd2f5c11caf2f7569e35eeeef68be77e61b9e4a9b590f482981fdc51ff6c77cd679b7c06f9d765fc7157eaffebaf59a032f9cb848c23168963bc87458b54403b1077464eaebb0d10b5523a7bb8cc4e3f81c9dbfa62b7379d8547d1bf70ab46bfc3ed50c8543cda7ee4dd373f7823b81eda8d6b1f3cf616bc3b65516b2a39a96afe4624c0ca2d800647142697417b4457bd973ae3146a3a2571b82167ce49ae89dd3d440495bf1085134ee43b079be50d06e93822dc51f529bb86604cb84d96213f284302ec90ac29aa8b912c9d128df54bf9d663422e4005b4250367e3b848f86b0518bd241a34f46edc2a467530113981751edbadd87b291be68fbc3b234d1d6d4b4b79dd97cfd73c0e615b0e1d6c015dd7ab79c329d1605bf05aacd451ca8c1bd1f0837215eb234ace99f404ba9c3b58d6866fce735006c5210369e6e5b2a802981de0edaf363742242c3944cf30f65a85ed7e7003e2c63fa74e8c253b8b1b0cdb9fa58370834572e8096041f73ebadd5ab9b3a56147a6e2cf4a047f1de5fd9a66a63abf37058ff6b098283daaff12498d624b409c8b408c9fe14f362e80ba6c5db23d31db874c6f485bd635288e12477b9a831b898a5f146217184182a2531a578a561651e60d13be141eb6c60dff93a1aa4c9ee9f11fc362f46aa0bbe2f0a5834a132a71d12d83f39b00e55eb2a266aa01235e2965b0e464df73f45d0a0c663f1a0f9480e0470f52ed3c856dfae9cf9699d7d352ade696eb3ff246fe6a64d2447895c8d980fb18467812343f095439baf5b35ed82bdea16455d816752fd018cd92a8f38c272184f1ec6525921ff9085cf463317fdc0184d0c991bcccb8910dce1b58a688d77179bd671f2b9825787eb921a3669afad2db84312beb4008cb5e5edf48fa31381c3f3ef770e9b70eb2a0a7251d2d53abaa5ab5864f849330f37b0fbc3aa42fec411a47e5dda5082c6e7cff18c27cb50c9e8f8874537e37bfc7c8d5c59f471b1b8f3582722965ac7ce310deba0ab0e7d012995718c72756ed978dd204786ea68d5b7b3b58551927366bd9fbcba227f00874926c63d68775c75e1938e253c978d24f4b8c1cfba75301c7faf77c07eb829ce2791d70efa441ad76ac14c1b761a1636fc3aba28d4435ae28375192bf12f38437b21b14d3dac4b2cbf548b64ec3a032aeea0d87506b86f3fa6f0c8778da41ee4d50cebe87b02b7ae239858f064ba0dfdaf9d5f1f89f0e4cd830fab87b2fcbc8431e3037c6adfc6f0988e89a0d272df315f50961a04f6751ef07278a8f1781f4040fff0dbc28398103c048ef2fb214a0206e7bbc43edf9336e4ad4eee21bcb59fcbba934d2c25b53e14b1207242df9a403296b073051e641a4692dfd03f776278104f49b7486c4467a7393ad1889c207a36682ea96e968693339e56923ecd846ac6da40c59d53f8f1f7994fb517bd33d0752736cd445d846803a0106ae46e282a603371d601d26fff9e92949d2d49417e9995b16ee6c3cb9646e8273ad91bb869c28e389eb9e7cf3af4db06030accbe41a392be0e56bcc04e2eb8eb6920a101094d8175abd661527141fb21a517abbb4065ab5971dfc6a5a7ff137b87238b450799c14fa5322c922409ef7ca74c2790ba76f85056272f0096cb88340fe51cef66f0b60cdf5176a7b1096e4508b67a5161ee5105260fa1f6c07fb8a3f1e1e710b95c61b7959130e59920037ab1015b846856e3771534eb2fdb95dd5d5eed736723d3784073a8fde77d065e8c81cccf0df68befffd0992f5e4ee7e9275e45ef5b2762342196107d1764d4b6581157fb5dc628a26a980e96ef77b5e152ad92ef2b8a03e2fbbd177e89ca7434cd450d59bc6c7e536099c0bbd5055426237ae4469d133f8f36f3760472c05d71e073d51409c96de6b1e6d32fb9e73eecc8a8ad9a77a0fd176a9d817b0fb2f64bdbfcecf12ec799d9775e82573f29989fcf83513316b214011923e4905e2f348deb98bec2488f304c01eb9dd9a6d382f818720b363fe42192b8c158e61e5c6ae29f278faf5f738016b50f838d91f3b2fff6dd297adfd861146a993ff634467510182f3a6ba52a157395dc5ca13c84f9febe962abe5f4733d8dbce15241b2a7673a4b9e5ea64025624f6c30e3ac0c42468f35103fedc66be3260a68f0314f4368764963cd65f2819a59e244ea1954add6fec7115e89bc41ac4aac809d492e3cded4834cafc170c9a24460f39c703cdd100863d062aa06b0c8792f1f58ce0527b4cd441222506b82515a41bdda1b7fe6d29cb33e75a0d38333316a59c3c597516393013f6fa4d3e834cc837aec295d9c1023a93bd4d3584c80c299fb9a444d63d18b9b9424719fe2f21a871cb294958ec34467fedc7fbbdd4769e61802c4e97e4a237853e7753bdffeced8f740f0424649025766e2b97961d7cea3ebe76106d8d71f627dd79029fb957aa2850c039e467a1448a99eb390f2346036816d5c3ccceab23f1f4f8aad0dff0f448f84dd4b882354d1f60da34a3da7448524e5ba570cd17ef1c1a30c9ab687f10a51d53a072ba592effdc1692ab86d3bea80721c6f820f6ed576754e6fa798f3ed34801be1ba894edef512d62f3b6df05ea1d82125e5757d2e5e97ea8299c32d41d96ae26cee8d230244b8b4791db19bfedd47aaff28364e5c539bc0635a4347273d003e3205d11ed6eecb34a4c821be03ed32df1ff8fbb483e85dfdfeee424459835b8d0ccd08a898b4c31d37081831d746d9ae9636590a7545452e92e62a303d10b13f365d02e79d5d17b6953a58754e67d77ccc551da25c4075291802104ac0b6eae895b1a136fc13ba0d2f1cd24e967293cb79e529b399f4119e85d38462729fedea5cbcabbc7b719ebbba25007ce3ece4ba688c1e9304c3cd60c1b54d5169cd6e396b68799b4bd21368aa681eca5a2797a2885ec0eac51f72b502fb9c4912fa4a3047a854a5e7710b119eb7fbf121363dddf21974c2cb348d124514a1a44fc29cdd15bdec61c3f162de0f473faa1dd02c5ac3e535335f0d0309d5cdf006dd46c9b8951ca1dfbe7d87157badc1d77c368e2194016b54529aeaa866d2dabf575dfd3f0accc48c006b57729fa42a4980add744a8ddc4637a611826f83beef9512fc6a8058854408c3b906c81abe61cc2168e820267ab9ee17d137831257a410943ae2059f138642b921027ebd1cc23efb94f3d38f631c7d7c8931ce20408c4a48cbb8ef4bcb1d9f044c9df47716a5f97f3ca469928eedf3924655f514c521f1ca1861bb6ef1bc7c9ecb628d1fdef570220d50df2a02e225b7637cee6d0cf9a9b42e0014aaec4a409cc3c34a3137d41dc45260aa8aee237051e5ca9d1953c4764e22bf6b25ab253f8a81fe48763b85db70aa2d92f7a75404485df965e1d97b310d2f930692ec68d5b3b9daf551d56d743fcf352afa4fda6b814c119f36ce98c7b20c439e0a1528c6ec3627f5b2b5e1c75b58c9cbfa7f67023c3054272ff76432f18bae699c528ea596874c298c74778f41a7a4324bd0ea0ef5080c96f43015082ac2c82786abe4aa6b1a8626ea80dc051482639a8ba158fccc9ae9ea6306a9b4e1e37f919792734784f61f0e29c391952dbbfd644dc090979d296a6e4ad514af2af47869cb18fc8bd87737603f8a3fa7c0ee7ffe864ce17cdb8cbd3563c6a84983dba4f485f878b9c12b5db40100066ee5b48e782468b8a05a1a69c7305b04f9931acc53ee7dbf05050d068ee19c80c3c275c7a9cf9799ce16a562eb61cee0c792154820e6719acbe09097ed39585e7d2a42df24628c75cf0be44682a845f6c469a37022b5f403b49d54aea58bb58ce660681969a759700b86d1e375448a07d9be4ef97e07062ca8ba5fe6b17379d3d8d3b977faf6e02e9d4dbffc4d8c204ba943fc9a8d5757ab2bd43291049923b191b0293824e6e94f5c973b83ba7a9975ce72f8d99ef4b57f09777b37577a48254f499e2600929ccafa132b72023e73542dd6a4918acff18f93cecd95d88c3e090d2806cca66d8d4b8b7e750855c31f334687a5211f011593881e299f4a4ff9b5e145c61cb1fb8b35c19dfd69b9b6e179add5f6f5397676cba296e5004097c99bbd0e7f7de0914c4bdd1e4e4e995e29b45ee9415c93bd5d4d91683cb06c6ff32ecbcdc6af68fa7429783d2e2437aff1c5e2602ea0f3f92bfe69622517ab3b031c5d7e333619eb55732b5616c5bb4e02b948004299cf0be7f7add3a88f07c104d5ce4ceb33cec676c1ee21b168cec769b22a8013d6479b0ae1e72c0df7673a2239c65879fd5f30627045a110d601248e7988bd4d5ed9d42088f96ee8082524e216661e0b5c66426b913c9fbd6597cdee62fbcaf18f5d4ae45b299e9ec139e6c98d920e9c9d9e8915db520ef932161e2422af0b3870e42525dc874e8b97d314ea0611fe212d0900dff7eee6344d83ab6dea4ab9b1e61cefc69280f2f4e840269ca6c67e544f1f53fbb549416577fefca86f6150a002af73c97ea22328b9061a98bb5fb70ae17d3a01b99e8892a5c7e43ce2815ab1e31cb7b901ca17625e346445c04236907d62f5a36078f0977e94a499cf0e83b65d85cd42791677d7dc988d0e977e36469f0e0bd140d13d056374ee945903c304eacc4036b44bc163dcebecc1bdafbb082afca95d28b9034965fe8b93c72142be1cf9ff273f69f8c0e917391340b267d62c595636a08f36dd8305d1dd77cdd5242683601a12b4ee2e915d913c73443d6aebf02772a5ce6766e79bd9923d6a707dcef3627f8da66ffcd2ca0d73df3722d57afb84d8a71a6f3f82dde5fd20c79be197bdf69f700b212838839b274021f2585839670d0ddae61e0670cfd638ee43f94602a651dd828059afa3bb9e2688b00fe90ecc50869094d1b58175285facf144406d8a1cccf9a0ec77ab9accb444141aa4246b47327eccb976381f7cb66372f466d796f23f6dbe0b941d34035e6baa70b41936dd9e004fa214edf3832236e0f42c8feb9b9a808145e023effbcc0ce601a35d7caa2498847c7d74635f12d4bcb3a4fbe975de84717bf82aa5796faa2e0e56c650d720969921d6af4f2dae2bdb92cb2f709003fa1ad1f343f72c81e3d10161488bab72a904780b3b9b490f15d7c368040212a4769640b3034db051e477ace2a42ccb67279ded3dbe2809d73e8fcff3fdf2cc5bf9cfaa265dad676cdc7aee19a921ac424212c40892b22159589aa3fadccba606b8e0617abd855066080878380c8c32dd85c48b1a6404d76943d9c3acb472fbf0b0d7c673bfb2e4babf8252102d3593e41e08b512c897fd1d47c52751c2f86f1c3f11d44029571c47835a8af238048ca515f9efab9701d67b97568eac1c45342505caccdf7a6cc37415ba26a8b1b22dcd40ab6c4354a998a892fadbad3129b8d500450c858f5b35b4d782c8feb6f0b166df222023c787deb4a2299081a1da6cee1dc5f4942a8cee189f0b0c7250122e21f7b8edb2a79331a6397721c2f42a41081ffa8d77b876dc01251172a9a984385dcc0d296d844b144c58d3b7e3312965c4d9dd56a23cbe96f44b23eb8a1482a9be37864df2b062b6da138c0cdf7112d36327a9da022afd77b01fb3a10b05f7243de76451553d968c3d5b4662eefe8e7ee110568e3920b514406ebe37a9e0ab74a34ef891c8a2af37e15fbf64e4f8ec003dbfefc301b220c9405d52ffc13155e6236ed55b252bcfd00e4d0ce17f65c33c4529b12e0040ee93922fd72d32af14c2285861cf5a183046962b5659296f4f113baec84790a1c61448e84cb335a871b92555418326f5b7849e6edfddc05f57bcfa69b8422c840c88b021c60b450ceec38dccb43ee590ac3e9b93353aaf66718b2ce47136754138d543ad3dec0d2917a68584c3df8b49dfca02e7b2980a5538d3a64e11ab563c4798fffdea9a64ca4a4d91cac1078d2a7f928ae4c097741cd4423ab4feca23f5a2b193043e9ccd0fbd11c14174306bfc0d7cf06f1a817e60f22ad7473480313303da2fffb369f50b2d3d84b195afcc296357cca41ed97209e59bdd02d795d6b99a6ba1eaa26bbe7b0caaf49442710406cbbbf2fcd57b806de5fbe02094bceaf0eae1c1dbe65badb7b426fe67ddc03bf52d8a8274eefebc4d7eeacd2632fabd465ee065ae370132a881c8cf7af4b9e09a0352c11c05267c9ff3d2e76986f19eb3abe1cfd1dfcaad6c98f86566c98a4e8ab4cc8f6f4afe92a027614749f1a13a13e7839b0e8701c857522232ea745070b9632cc6af95d0808498d7e71f07ae72c27639d47fc72abc8e7ae3350641381aa2765c78b25c3f1945027a41cca5d1291a66582b059544df1b495be32a603d1b73d5bb6bcaa3fd3ee7d1d1a9ac7593a9587545c0a30a620a1d20e7c9a42a7263a3b5e5ae7a927f1e6e774b8a9efb3fc4c4a3ec2387e7472ce8006a1b900369609b5590497af247344d6b320effad93b6a015765d1c4c74eb033866109dcf0f8836b1cd8b779de7fa6fecef17cc721a0628231681688dec6c7b4097d5eb0a8ebfe87637c61fa097aac8c8596839cdfc045f2856f73cae32b5d416d67062ad256b78af3de2a3b35919653f72409584095a3d2121e1c88cef714c00457db3607820cee36809a39ff88cb3074737a098706b08cedf5ab8f9d99b82f8d7c3a6ca9072e8e32e9b2ce2b7aeea5dc45d3485ec4e551d7197d9ad5b95be45acc533921f17685b167d8c478fa35e33826de1a31bf2398971901b605ad727a574a7668bd26ab1ec4c3273d19bc1fea9bc62bcf0f7feccec4a1f5a54c5bf64729e9fba80fafdf69a7763ba560e72baa1133ab95e63d13a66d5d49eee61a86b9c297da88f0a6f4d69e7b54f6bd5d0f9e4d875141d4cc836e2dc0ef0b0a6b2158ab0b59fdf90eb06c33eeecfcb160666bb661ae96e3ff2245cd3ae62ea0ea0ff7f1626e8e3721a7b0e87f5ba2d13066dc07f13882aefeafa2f7e53024678e23d707fe3a0b3f596849df8b2eb4a159392d25ad737441baa7f38948efd03e90d879c1548404e17ec7f4f82f2e4abd47ce055f0477a8daa8683794f267e468b0c44e4b2d93bde5521c6e2e2f0d01279e04afe47fe02474b4093dff6e227be629f8f7feea90b60f5710a151b8b3c7af03bd723c0f0d6fb99461b1de8ef83210a5f3ce44351d9c4bbadce005e3ce1c8220d367b73f010ff906cc5daf06d2f6fe696539be70edd1a353679ccc44e3441720ff5e3b09bcca38ff73542b8c30f7b7c283d09d5e199af6f381d23cb470b5d74a5bbbf21bd481603a6df745aeb50a4a368ec168f1f0ed1aaa61a3d4e660218d69c0f29a3cd038b6812d83e364061c83504b2bd6334f481a1ff723065f5c78f04605e18633d188bebf67b91f47a174ac540816a32f2b969d089487c4891de21212574fbdf91b2b5ef72cde0d7a0229ea1135d8142e321ceb848ba5462f68a1895bd9637156a754f24ebb8415d1e6d48cd4640fdb3b4e3e8738120092bb98ae3b858d483c214ecf92a0cfb5ab600c9c7c856f9b67e03a259c10b38a2acc34d34a37e27c593c281f870f3e2b77c5cff29df7f92a5e96ddf5c0801cf821c16d6cefe5ca55f207c0ccb865b9b28501e10459b2bc73e0b06654dc5414ab0a90539c39b752bcc3fda8356f4c991189c7730b1d900c620ed02b8a9dc52c9e9538430aae95d029c2291dc707084d681b4c3600c3590a67e35831a4195278104e36f538174bff7d767b4a5d2391cd8f3814fc1e1f5c9c649965bd16888bafe20ad955b5e5c1677725e54ebbfad040731dbc57fb530e07278ee47850131647e9de359b83acb7b7163d4eb0ccdc62ca2b891d4f8021b696121bdf6cd8ba187db99c495c122c3824e47fbfc932dc93ef40ed9197634d230c68ec1ca68d03259170d4fdc1f1127dfbe95a09051dfcf4d9c00ce46f663ca1ec006b16c752f9af28331b82fbe969e531e8cfc2127b418bed63d19fe92d9f373d388c139ef33b720275e4659094ce0b017b128ed5fb87eb5822fa419a9769a9ed474dae23164608a26a2a6067e48e11e3c1540b5703ded432864f8d71790b894da87d48fa1779a0204dad15d2091e22088d912e8c9938a653752e45dce76736196f7b1fa76b253ca8f8b77fb3b64d9ef42b448b6728f097a37779acfa78dabaf2e81c9298bdd1924861c78426af81e592b054592370b865b99affa091122026d5fa7b64b16dcb48528f7be0730cef58ff9c90c9f94046a6bc0be75485b3cc6ab67eca5424ce2ccff596bfe3772468cf406038fffcb5c330e92cb65b6f1d2d13f4e120a5bc84892ecc23f45f81f17a7ecf77cacedd6d37c3d0ab177db90595317a8d20ff4ebeace1aa2f78d90ca9c11e88b11a0fec54322bfa4c8af01364f67e0e859d4812aacfa240cfe687fa0ffee02bcac94b154d3cd84ee88d617bd3aec882b7b5eb7bcc595dc60406b383bf709880a724796ec315f2ee542e459e74c89f2c86010a3fc11a4ab15fa510fc9470db71aebe6ef9ff9f5ed64666ad0b073a42d1b374bb1ca3c7af64302ecf03e67d356aa746b85c4e633f66a0db6a78670ec9b474978dab149c0d9664d463d078210537503c69201309727bee94656e4c4989d749c8e727b1b7bf1d1b012bdea12f234c7f91651ec8c70ca9713114113cf682444050482f688a90dd5ab1fab3353a26bc2d47cb8df5e474cd0c736c92852e523047323eaeaf4551f5f764ae3258107f92014d2db99f0b407b6eed8b9ca434a250292420d29b0f0b3a85265297367d181a15a28f8790e75d99e9d8f743c0db72eeed00d3f22fe7fee25b021ec957ab6d95ba66c84dd60fc47d1c81a4869d5b7a17d9d8312cac8e015862376d56935ba5b59a05699642bac2a11c28657f64c1102e1f9064ee1f7287f18b571e024ea3a8f0818d18bc2c9dc01ee18117a2ca798fa84ef74cfcddb0228c53f3f07e2b0935b0d2e34d633274084332bce9b18bb75d716d9525cd6dec05e13ae31eb2dc13b8320e1926e426b8fbfa03bac1f1d56c4a200bfab56d640513fc5a010eaac95f612e19c38d7a21ffd889e7265a3c3cb8f97569966b150f39eb1469d0f06241688f137fe67d159aab0a0716bc087aff091503f0c02c079b8a9bbac556bbab0a90ae9479c439e0ee15df2d5ff5e5d75d99db36d581a107aac7494631f5c8a008b0d08fd5bc8051cc601d05b12a288e38d1e752ce729e9cc36e4083cdb3a4484db59fd8ab36acbce5691d61e0d507f8e0ec82261c4a5436554d5c7e53dcb639982d17fe4540eec6065e8e188bbe238d5ff96f2caa007c3c7372e7f808e2634e5281c20c3690b966d6a333e2bd8836e11b4a180f3e9b24246bccdab5611f97da6c4ed01fc0ebaeaff8328af808182c5ae0b0021e87c16327b52bea8d5606dc9c7afb193d3d1de316cfd646315481fe3d380edca705002fedb0c226e15ffcc4d74f6de1141a187cd59d52b2c1fbe194408aa87c04fac725d9aed689c0b052a8eefcfebf350f2fee4c853cd2a1342d9ea59f2c2d78a49aa4e00022ac0dc7f078c9e3cc394fd083bba660553911ebda2a2b224f5c913ef72268fc471a6983b3e5375e7df7ee2db478040a6f8289f5f218c85639a69f26ba68de40e0941849072aba0411a62c1c0a37348d8518b336981482d44fa614b1fd9642a3341bcc03dc308f0000d0c9b5e40b05d84b04eea512dea5b8339b3e254e6437cda6a0ea0da47ce2ddd093d39f6204ee53a46089a46aad676be8c6e6586b279f45f5c3284c5df9f0b9f85c6f40068df7b72882c8db74bffa41fdb3b964a49bdb6ea7a523a852f194eea0d3373c538b2420b116d0836a7b29a8472080f01249bb7d807b3b6724228b961e513f309a7de848b13fffab35d76ff5220c11b066c778bef4694bdd470aa543385d0d8fed7682c6770a3e9c62f117c996220e565103d7e947e1640b29beb768871ae2d6f08fdde58eaad5c382120fbd27dfbbae5256c6d6f4f4ee29e8bf47b92fdf3284938d931a3612b983da0dd8f36ae9ed775b8f35997c2c82d45e92bf4f66a16694ba4e1ca928d1c190eee5b2cff1c9d9434d68cf846095a507f614861067a7b8c362ed3608b0ffcc59812fee62a774a74ddee5a0e81b594b8c8c21c55b18674f771c0ef9465460d81058f8b8959d5a5b6658807d7221a38ace836e751309a5576e75fab64f4341786c3d000b5bc107e08f514cbf9815ffe1381de2e5d7060d412306f0f9e85494bcc5c02e6e6aa6a1d1ba6fed197a7e2d88714099d0897a8598eb1a1bbc03cdfe757dde3c8dec5625658a35fb3e33d91b525f9d076940602fdddae8325a70e2dc1f1c2d4dedd82355e09a545328581684349136ab7a8dca93f6940d7963e5d902f4e62089fa34b2b9dceccbf2a0b3eb68775d267e11da52568346a6bbef99f752ceda8ff934a64e7aa31ed8780aee1b633d1b995636d9851b9e0c2db154f3719e538d1284a69351b0b2f6c61aefbe10e1324fa509f0793c48264f57c7508323e0a997c825381e753eaabfcdca1d9ef85e55667433cda715dd597369f4284e41d978a2600abb1ebc37662f53964fecc3c7ffad962e3f2b6742520208be28e935438f67816ce1ef2c318330b1e42b766202d7377900f6607830ade163cc8960d4d3198e84695bc1b69ede2c64db7cdee9590977f6ec64c4da695494183057116480a5cfaaa68a0c95b534bfe6f1a83d399e8d4a7d2ce2042beb4efd42b2364cfdc9be8ccf0940905ce48ce638a6eb6873bde6a799fd6b84a3a9cce573ce3265ffffd4fc376e57e762fd71dde9c168af51c7e798465bfe0b242ba8eda4409c88e3032db1a97345fa0e30625c5463746278b793bfb324a60d69bf628044a7134b7a7008422eff1355cc7f3f92a10b73db0762f64013b2e65083478d959336a56c2846d61069223dd10894b7af9f1602d14491edf8ecfadfbed0e468ff93fea84a96a14ff5be31f7d81285a840af3f622a9a2d4d6311eb6b28dfdd7fac9af47640d07eb9acc389938941098e833c4ad7cc8f3dbe88d7a3f489983d51229e614f5804ba74660e466cf93216890b87d56bd5d0670e27c2ab7b7ae92ff8fee1cd77613e7ae60114adf3707efda9b4e6ec6d21b321d008f7963f27b59549c417eb2c8b2e92366d55a187757b4af31137a779e3566877af1130420189dddee780af1c518e0b872268241ed2647a563453169e7f198a0d6337b326629f987c794ea7b5374c8eae63ba4d957a896baf247a6761191d98a2227fca22dbb23526020819947c29f5ce5ad0b164194f485ac8afe105bf31db9eb1ac382ea194ecb49f951b952b98fbb02ebc1b41051df3c595d9b222d23eccde03843a0a870e001d95128f0818f78af12069ad5b83aa23ebdeb88167032ccf12ed7579a9edfd9c1d19c9b33107b3a1482bc4425a40d06f3bfc9db111d849b6ea0a64168db10db85aaf797a1fad5acbbcff20336675541487a050a1c1cfde1af9f789457def28b0f8901e79945dbaa6913f1d60b9c23ae3a36946b660cb878b9510b5deba325f1b535613582e3d0bec1f7a4275142ea3202ccd923b4926a091ba5e0655aa5462f314636740cc3c4d7dd81a016f5757102011615a6a2e1a4f107adee00887ca01d7571fd59406f85a884318671510d0f60db86116ff72459b57d6fed9b48d6b22e155571cd7ab4e6810cb6761b8205a598a4a2d16ff3b01f65ad161618b60b628616c78057b39fc188e4629f5cd6c3c23e462bd0407e237383d7492c6910d58ead5eb0b10de5b3be8a581be8af51c75ed1aa2bbb21eb753817413dd28bef414b979a512711c31ceac53bc532bd4262cc52296b226dfb86efa873acb93038f308e728f85a3ddd43810c9e8188b4ba92e4b3ad54bb953db93f275c4f913e4560634ea35c16285a789b7db908943cb9b0668db7a7f112d930aa937b27e9a54a392078689b8762640cd42732dfc14f1f0b14ef11357c969a5197f39a97ae4a6e30714f175a28dc9060b3210df551807a01043ec8a38d5ff08d7a9c0220ee58f6763135d27edac1139f63119f99b2ea72866698c582ecc02c20307cd5549608b2471319282b7bf30eaafb9cee035326e62717e3944aa8f0d584d4e3610f23cc7b31da9794398de05dc738f09d8b371771a3e1388c3bfa076301b2e3501c7a0b7dd68838f3789c7e387de64f8c14d172ca7eefa92299109de9cbaca166179ff2b3489dcafcdfc31669f441cbf2165f4f52dbfef7b9501984b22d1281f53c3f53a0a7abf9ccc6fec02e1e0e3685184f6759b6a3d28380173cf9b36f3c16926d74c7d19c63b010bad3fea0f670b8e96908e07f9dc1e37d7b9ca434776d0e90b64de46d8ed93869f6114c4e20c2099c474c5f68ee1dc265b44cb1f75399b90fdd1180b118d1f7f4f4d74b2b9ba9efd9a44646f5e634659aed111751b59d2b9aa1ce01adab35af5ff25801b8102e9a48a3df6509553f0d7a615a298d9aae3d4bdf7c85060d3e7cd9e332eaba5c3ac93ac2770296234d5c8bf2edc69c1aee2985e77825ab98e2ede52a554d7dc900124005e41415066b95cd01def39810377364b7557599d4e8318fc5209094e716b0a01e077ebe47bea1c021e15f2261eb07bb4c46cd4753b57b4292c67d897398d942cb137505974cbfa95e2efede1da8158b98af85703c5dd181a0512458584d30e6a69f36bd7de9208706334d1c7bc0d29ee3e7052116145922597f30637b5ac6d52871d70e7db0c9ab309498f1b225bae41208d5eb8d6c4d43b80f54bfd00729fa1ce7ac7d88a0b8aaa743f76a09142085eedc71d77b66d42c8c334d4a789c3c7061d224c9a93b7ab0d6d6b0bb7458837e797c9bc805a81518c7c1eb1864d977c0b2c9e9a87c8ec271dd8eda5e825c4f30f04c22d6823faca9ee4853989318fb40e157001a2f8b76a59b26167c593f32198e2baae5dd753c67a171eeb86f4f1144061f06d48c3fbbee3753535c2a8050ff824f57c8bebd3a60a13d6444fb2b1f3543b4ab1ec2e0ca31940bf14e02107ad89ba5ca3f6b1b4f9974495b739e2dbdbd836729192d79bdcb62063756ed62481f690d9804e956fdf6e7173a13ee48f6295134b890b4f971c0fdcc72b135703b35228611c1392e7c058ffdd38131df56058f7c7218aa673f0d433816e889f3c9d44a1f5936541c85c1f9848c2f722850752c159ae35361a1a1912820a2c9eceaf310c733699457189de8d5a49889769808ddee75ff77fd505f532619fd83754db136c4439e59b30271d9914e17736ff4635fe844080b4cfd0605fc63d8ed7e011efa1cfac306f24c9e84f0fc1682b81002cda3f60b8d9f8b8a9a9e65570021ffb52aead00362ff5871f767de5d88b2339c8f13f03b89907ad889f9ad70969bb97faf866ff252fe6351b870079ad626c95eb032da14e61cb1f2760e63d5082507e3b939ddde12b12ad32354e48a5d0dfe68209f77bf02ad360f04b20c2eee2315965ad8b4a7c98656f76a46767825dba09febbb61ed7ad4341dbec158818b198d2d7bfaac3f9f6bc7829189dc547b25239fe94343d48d3b1ff0a2f6bf889b0820a52eeaa64aa0999bfe9d8587b962af79235a50e90d8742e6c97e323e73d81378f8ed26b04310dd67d6d95cb08e3190a6deff4c3afa87af694dde88059d2a58f5a014d6de3a80c43dd5585e06408a522b0fd293f6cd4d0f3ede68bfb6b78eb1a0297585353da317226ba72eec120269d03fb3c68dd23","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
