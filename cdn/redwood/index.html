<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"00058e0082aecf5c0cc5143257954057264dad958d3970cafd5561e75d98e73e4f71b52097fa766ad444334c24055170e4bcf48ccde83949375a98414cff9a43d65105f0eb0aefc57698bfadfe7d6f2da7f12f307a6f4f2e2fe9bcb42b5513eda66927ddd5f1ace1fb8bc69cf1db5830b75d1fa76b7e60ba61f6ef0f0e3c9cf435b1de15af692791d766eafe23c2869ae495c9f3433fab17aad27a6caec150ecb714de6eb5260dd9630c480ad5babf630ffbbc029f24efe3206250713b2a2e41d36a5375e6daf9559db55b4bf8ef2c061dfb7d5f57f8788e6f2138fc2be27dbd07a25540b65e2756a71c94281c833cf33a65817ce10aba9a90d3e742c8f8f73f66fc8f778f4d52df14893877d15772f772ca470001a20713f23e8125a5d4a733904ec502a89b1519682623af37472ed17dcee05f8a4a27a83d683395acfc182f017b900f39b4933133191c3b4e9e8ebb431ab59a7e6fe433a7134849a2efe84dea9ee5a0fc0b1d026bf822ee3c115f351b033bc9d85a55ddbc47693109991d086cf9538be183180eeddce87a471828c4eac88e764be7cdf0e57c06f0197487425578a74f5cb9ade77ef36738b5d9912d9cfa0eab7b8ce645b2aff60d4ac4fccd93f5a038f7eca2c9f6be5b7902f74f534fca4c3e6b0e9d4cef285562c2b2ebcacd142d52f9bd86383e9ee53942ac930ccb88dd422a12e078f619ba45f9d60a0f5ff9c41d1c0ca036d89a0ae729aa201977ff5b732cb2d7ceb52d6b8233e289c308ec8b821b0239924739b2ec03d2bab7f93bc0c67dd9eb42d9c7ae54e8418c82028c50989bd62a81c4ed8cfd4fc4ce0574c24340949c4529d6bf8eeba365023b77235bc033faeb9286ead0c573b6ff9b0b238b9d94a3eb4290573bb9b519cbcaec1ac49bf1f988122f9105685485aae2650c5ed583d46d26d0ea15fd01f9838548942c3976065a6077e41dceb7ad746107185c5d24db3c57c82f24089bf55dd3b6398828a92961dd811c175c215dd387c76ffadcd9fa20a1f057a1371d3d701bdd69d642d9316de8efbf7f948426c566f5d8de134ec28c73a3fd9f63f166a12996884b460e2340a74775b0ab50031a69120faa5d67d83c050d69d9ccfbb65d9ebbc4b235335d85d7d54fb83a111fbf8d7a8a9b00179bdeac330a3b500fd433abf8c031ce798e509e8cd28017c3b587a87a78b87b3ea5d811f1e6d7be4bca6f79c0bd8a921c28d6ca4ca8e9301280fdc0e4d33a47c7e5f40cb6fd76e4a77ea9c2c63e660ae3aa7202143b7ee5d7350cd019cdacd3c7238fa5c3440b24ae2ce4f2f8eb8c05c8656ffd437c76830b7df2e53bbe8b32d529c1beb7a37374a6228ffa9b911ee5dd671826cff3b994c37942f2aad67c2927f511140f4197791364f8ed698ae0193f2b537fb93f158aa0c83892880ac9a182a40d323662f00299b08971ae12e6e2070da4a820d151fd1a25b844d0380ec0ce0292c9f011761921b1c33ad79671b3bc79477c6a2435a08858609fa490bf1f4e2c91badd0c826cf18ea62012c91b56d5d1f2beb532b2d50bb2f4f36a93a02230d078d485fd110d4efb3e1640d48085acd5e0f7860e19c7341e4386c7a436076534a07e4176d59503d639b7e15e415a0c856a8c225959689eeafeb68697d30133e753c7439166bd0228a55bf9ff966a6c35786c2dc5a5b10a6ebda23cb8435ed43ab939ae2f0946dea93efc76ad192406ca05584a76201a3f12d0c262731a5638d5f97bc751e94a24e73fcfc2077a02d014c00669db956ec7e0f0c72bc31e9cc9f5b9ee8e0dc9d8e6c055af533dc3f63a7ec74e5066a3bc9cb5fde94c74da4e2241fe76a532ff901994f3a40658919f6e5c7ea736ec472f61dd7c45cc1727f91026fe78916dac1f9c2d0eed972823d8b4eab893477955011b9355e649585f1d98ed97030d45aa10e7b275b54b295f7f250fd66feb0bdfe5d59a4f037588639826a533e3302caef765b3e255665ac4333de23b0e55cac8e33c5d3e3d4e6b2534a8a396b1c78d4e846fe87ca713e26b5beaa3296fce334cd929483da49e1ddb9290a8b19e0ddf4c01ace43188512c836ce58e00229d42132efc90d94e00a7a34ecb7ce73e7d7f1ca4edb7df567bf97cccc97fcc05b16b6139c58a0f82dff56f704591ed2abddc88650de50062982c8ff9f6fd89f2c79b90aa6193defbb4255d34ddf88c92c314224c8a325711a9e0cf77b8ddd9f953a04480eb448a191d72ddeec5eccc17646f0b94df5e1168a97af0e53090d04d7a7262d27c17479bc715b0e407deda6a58e12f91de6cd02b758ac5d23cd0ab3b2b5fdf2b5cbb193624336d7139c9bfda51d0f36ee9c8c04686f60780ef5af80db91ce54612816239f1ea682c7e217eaeb24732ff2a777426e30c457f12661a22558d312a0c5b4a9088a2ab44ac8d2a10ad3847e3819da2c25aaa389de7cb782f739d10f0ca2555fb0c64f648a1bba3941121ba6092014b6e30e4b1cdc19f96c33c642e17a7ce59cbbfe98c28d7a06e763d79281f3185304729922344e5e3c60e32f524502b172407159cf78a4103a8b50a76b1185ecd15b7384cd359d076e465aefe43ed201b79a2b5a08ad408858a8c8993a3b7e87c1357cd4e0018d3685c3ef1c5609c7da7564a0761dff0f5eb7cbab4f01e7948d2a836421a6d051ab54955f1a18b8ef996671c64cffc781d883b9d9ae2db0a61326b105ae682ad9afd08bfc3ab41351e63fd5d1e86f548411b786498ba97c0bd137fcc5eecdfc3c830802a5682afef53d38d9498f2d95ddc108ea55a69e907d919c62a6d9b77296949462a0a5008d0892c00387a2a3109fc41f28051022573c7949d59585ce4abe920fb2a0f09ae193766e7903bcf4223a010ace68318046f94cf3e261a1a160f238efd7c1cb645015cd731c0cbbf8ab90ebaf7e00f2e26559be3225be8fa98c0c1c162a26841be40fb4fd40f67f72cca1d2a0fcd47d27121a8008a68e18765c6943996c887b48be4db70aafa27ad36a6467713f4f8f244eeb719cd469b829bc43ba5f631098bf5c34b91c4bc3f55e22734d3fcf5787e18ac49df2b41356eedb1ed6a1116c6c767a0c13458a3eafb93b0daea1cf22903662d192f934bcf6f71a18667ebb642815af891b63b65569d893421d20d00c99d35c92b669235819341e071e8b3aa04201657edfbbd43a5decc0754a5a8f3f78696c9c7d9a70aebac51d24ba39fd395d371d7aba8f137951ed3815a44d96f3520c0846489f10fda9a3af81bb2cbc7c1ec0a0aa8c3c0b87de8359754e1fcff45b742130ffd45ebc2d535f1834eb6df5bae1ee6caebee82839384fd8293b766d21720c04b1640692a9cb469987cd0b0b2b99eee8b8b2ae4ec0f4cf983c6d0f2c22fd0b85e2e00abac81e605e2ffd497bfa074c8cb987ff2e57abd8c43ed674fef22ac3799e8bfe965c0f3b2e94dd547e21f664a23fd57aaa7595f13053c8b14b9d2dce4a24bdcb20761d1cd41f17f31570653e7fdc9066813e949bf7a1f6b7a246053dc140b47e2d3d763c2cb519dbce0adbf20bcad70a17556deda3c76a9bb4b6c9a6bd44f735fc961a95faa04fd4ca6ca71e7e62464dde29b74f85c132642d4e6aab92a1f6bc8131e5337e415e5cd5697ffbf69fca62d5ca1be5a63f68ea06909ac72ffca5e6d3f71aca2b57508433079bef6f6de60ccc0fe686e0def1389c51fa9b7d4a33c16337bbb2c3d18f510872909e8685252fec9c0be379d8ab34e20901e03dfea39c18406fd7ef5c3ea234a766a9a83d99d963db37e5d0c717398286c466da360a98f5595455c7296c0528be77a94496e0759a210afc4414992d35d2e6caa951fdf03d170469f0c8d9cbca68029e56776c4b9173285b68f3d5f6af04572fe6b9089234aba64357534520f77990bebbe8f13967819fc4b7acc26d11d8b4124fabedbe4db30e94f1b874e9cc4be49cad29e6700ef228011d4e728a1db4e14eae760e8831dee6187506972735d1af31dfa02d8fbbd83d3a704aadf3765b6d5d62bcbf5fef3c280522b2ab6f39f898d7af130f6d4c41070ed4d3474925f24727dbfdf52529c2b03abd4b6f2de44acd1e3296988a252f8c0f5c69913d5e46710a23ba342a331b197d11573857acb8cd948ac14e95600dcca6e1376f633381f18604fff61d2e31f5b0ea4907499b74da669e84109d63ec25830f6d47b2176c8d5b3871781431b5e3de75a45adff97abe3a7091e34b8215e5a8f5830604c80dfc8f892b8bb0942f0c0c42247c21f0275c096d39e88854205729a453b0f3d1a53bbe3b5318b0bd9a18dc1dad24ce9879b76f0f3f9bf287bd987061d934b8ed11fa35a9497dc6ed78b6e29fb3e9cdce849401f0e94204b463e0dd97c5a37552e7d3340099a33cb7e672f64ccc6253310c83889e56e2b0b756918e5d5b17bf408fcbd2ab25dc3be74d4a291ab0fb3deeeb0f3c0d0d900593491c94be962aa5509c4204c3774ec2695c52f5b2816c533f2cc5df7a02b3e41dd58fd847c9d8feb7d3a2e6ef6d8b33241af1ab9badd9d2d4975dda7938ada8ad13dc84f275391a0e7a91056e30abb018da0b96f68078996b37602e9981bb9054d8f2454983e450ab7ea43f0299a4ba588da86059f959629e8b1468125fd3598d5da6d02da62d4e8aa6987fbc2de514e52ca031b6f33683045dfe3ce6b5589deb580f27bfbaeaba85dfdc247fdbe05ff692358d54cdddc0a1da5001e2046af72ea4047ce497f1c353a258cb7f3c5dea6251d6485bd56f4d4b299c7d4a8f875dcc6bd6ad8d54221e429bc6601deeb4291f0a30822a6e8a5c10d9a03c0fed208911702949d180c10c46aaadee6364f1768de2127f6c73ae78776e4e992b4e1b95449dcf7d63899ba613f65e825045fe7c68b0f5739009efb42ba6d86d1dc94da4bd81f575f17becd183233a1c2483f0ba06ec1223922c6a44822d524a19878b24732f3126c929846c065fa0a2fe23ef4854d6a7423b94ec020d0c73e78ad2a814bc31972f8021b0b4a40f38abd4e8c6cacd5b83403d4cedd52082cd22e696681634c5506b8aae0628455cfb55ed65f373e0a52aa8b5679c5c4f3d62e468a4a15110eec633b67b7b7a7e9db564c9b7ac62da36a9d9f047644e09bf5b12f6ca4c4df8e69b4bb65ce4ac0634bc894df02f4daa1baf207b4a111a392a55c4755a90978b738f9ba0a75773373dc53f8ca3cbfcfd4d25770c0bdcbba428d6e5dc1497ff8ed8cc5fa2c434f51e62a57a61af219b871b119d375f7c72e090f322f71f087ba5860509d7fa5bc25f74fde4977906d5f15d4ca43bcdf928929560b895f43547dc298094a068b040c765aa13a7a032b32ed49002101539b53047f7af733b9969c2fe044c67f5b1c40d35e8ee3c718b4f3ee99e03334b4896f1c723519a40d8245a0ea3fdbe385f9f8ba0128c9ed91bc19937040a0576129f91dd520102ee4d0303bde9e849faf29a64075e0eb5a2cd7e8ab2bb58d267836bc547b324b1d962c78c7a32fd13b02e65d386391ced0e1c8628a82d4cea72ce3e3a87c5b373777f617d2e461fe08a28fe790f9e9685ec3f087ab7aa612666bed4bec6ccf8f5fd73e1a1bf061daec3639e5a742d1d5ee1d3026ab30054fc4c54d4cd815ebcfc6f9328dcdaf985a649b315b544f59277217b36cea2c8bafe45f197ff7c8507b1d4d2860334e3c704f1086ba63e84d9768aa4303fc203167a3828e591c17a07e04701950b100c5ae10cb28f6ec9ea095bdae298deed6717731b3cc8b29352848e3e4499e7e0fea29b7c9434787c0a43cf4dd2b33384cb9a41134ecb84ebf46d59270682c90438da1b432505c1ea744122d0f5835f5359905d4b3992c54c2760c740b9c22bfb57f9b4455bf9e7198e88255f2ea772624c59bc15a45373f1da78ce7f3b356f9f82ddc9eb851fcc8fdfbe81ae14745f45fd0c1c1ec320a968466b5bde42c9de0e0c75f8d2b2e9326fe47830a8ef74fd33b04f92222400678ffb5f05f04f3b8e70033ecd23458bded23a5ff96483ba6757e13e35d1a2150474d95342853b7f82a7a0bfef5a38fc60c8ea71043f08193b59900eb25d1e186f93f84cdfea7c638b65fdeaef9c7464a8721d05a54c08905a3cec71a6c4c1e18d3b3fcc4d4c67fead068bd79bfc600885b65c387829a070654773afcb44e44a30c95166e44961c2dd1540bb50c0c73fea64f5ecf12ed019237c8aafe9168dbb2f512e825392039f3db263531936f296b4dfe9458e11a3818d7088188cfa6c56c34d28fa51398dac4c3a73fb7dca1130c8f68385bdc6c820b0c807a749a707dba3a545c85324ce57b3853acd72ce2276bd94c347ce0cccb3d4e825567d2db76bba0c3ade5b587364d293d450afc0b4691ea08cb6d4caf9bc5e22c33c272d504e73907b5198c4f7074cdb7f2e4a73f7b9367b69e62fef47e68ff3f96f4bd02528061914ceb55ec7aec48b8b3ed9bab77977ac7ca1349a699a9d8a98325d0cd77b1d5f6a60c04d8d4c24256cec6f3f22fb08e364a3d533114d153920456448e5ee3508f61f9dc558167986229cd796b134a8aa3e914d94077eb605d3bbb351f3da4c8438d5aaa673603a435279e23671645f88256740d1db2a46cc28e33d977a6846a48a355aedc9b6913ddf03dfc859fe4209711b80c5c3e6255c376c36032049331d2a1150d1a79405e40b3e4d27964a31bc92e23f3bcf9a6f8461689c6be5db9173da075bf2c50283298489a7ccc719cda9635ddb4ae6d98bd27b50c2a7bb365ea7bb3a68654d961464aa53a21e3d6310165c2670c81de7106729cc3f1dcd54270c243ebc308617c7bdb19d705b90f22b88dcee01884562adfdf3a806650200eaf3feb973aa9591f56d33c8e85fd04b607b67b538a6cafed39aaf58c30c95e3d3728da06f8decf7baf505ddf49e492bca60d7ec61519455338707cfa50a60d58c4b2f704d17cb48a9b411fafb15f778f25bbfadb0c394759af2762c0b3088fa47ac59721cc5c2818517ca2ff4e30a950c27b823d04b25178a506dfcc6a212670d3ddac3f0b0701f8ff002b65a593237f4139fe2409f3621eb8f8f13fd6a19067c77b8817f7cfd1358bf6d25497fe2fb778b5765b5ce4360fcfdf8da17cf7ee861feabcfb52463d372f08ab65956f515dd478928f8ca834de18e18f2415feccb02e078a681e4bdb064ffdad65647c0c39884943f9b6a5c0668037a876681c80c4d3f094c6d2e2fd3385803a3897850328d7d3b795a26ef7ac440253c908ffce5de0c088866a510ddf193433fd0a166a4fecdfd25d48ab3aff8880b7cf4429b1e00f34c7c2b73b81aae53c843e4ccf3d65e6e1adfeba6dbf0a5a187f48b8ca9712522b52386793a97cb79bb371f9417d7e4ef6ec83abfee7b0610f7202e9abb5c8af8b42fb92814727591cf7fb2e76bc64565ca74bd8eafd1a5922e5dacfa4bdabd96d0655352661b133d9890ec3dd2620fd454aa5e8b1f9c1f0d33dff145ed2a938f6389c6db3e0cb3c1620be1d6e7c5a767f7bcc960375cf9b56743ad4ad2e17c664c36f1f4b42d8bd42551aad007057cf7ae36c07580e90caf4f9074a123fdc42ef710b67427b23c3946e982dc5b268614d29d6ccd6432fec41efa99e0dfc505caf729c6432b87faab473e73f8b13363c22bd21b66fc1d7908c4f92bb36a334cce59b16fb7a0ff31d1dc31a1dc0375d1d20ee5106612d308bd745580e2c26544301df41c53cbc2bcfc6d9eab30d5ae25ed839f23e2278c5e1f8c0defb58dbf88798176364aa89c7423901e2849c251126e92a3efb4466aa9ef2868772f376e4236352f9c91244e5745ac5ed2462b5f479bf15821caf9263629fb69b983dae5ea2c7534e4e5954082f38272dc8de65e6b93815c6b27f4c705acaf342403d1c721692b633b3977eacb04e348d28c8ffb8fb30c4a2d910d73dc4a983aa9e864de6e73c6d63ee85e061d9f18a705ca25f86c97eaf94896283d404e1897539e2da5c3a54e20d0b4a7adb812b228545b9abda0e3ccbbfdf3030b3c359d9dfea1a38be03000d39e12b7264b687f38370f755ddd6605adc34b623469f1f368ec03c8a8faabd6591035d0547dd479e264f2cd4231f7f434c2fc69282820be9244e152197bcc67803fe291698c4dfafe3bb6f278fe27daa1feff16f0eb28191d31b4d21ff722d28dbc0028aa71c07bbf3ac193db21585166fb0e232171d7f54f64fba02b3e8144213d759fa87cd609915afadeb50f5c8765ce2da1df00c9da8f7e942cd8e622696740bba7cd6accd6f3f49dc5aa49c53ffff39e02e8de9eaddcda59b205897dbdbda685eeddd7908b0a5443044376293b5cff6dd215cc9ae533d73415d431b5abd3fbd680dc0de6c5b36d0bd882bdc7c6869a731dea53a67a3ec1f8de0f2faea28481103dc57ac03d1000795b6629d22eb476975f135d97da0acf32fb05820947d4905fd77dc9305e983504c3afbe7c66bdf72a6e6c3aa8c52560103ea1526560cef225e1964d3854f6c34a00e16aacfb6ae92a1dac622770c31b69b8fba153b0400e1456ea27b32d8b6428fb76e521b0e2a627737db169a1276e9a63d881f8ce22d3855869cd36c323f6d7fa7a8efd40f93ae27169c847ca745eb822911a114f6c0b8943f46e619a8ebfd5fccd2f843994f145e0f034135b1fb6333ab492d58c715216eb7406fd016ab2f952db120b5800bd50f0570f356effe2160e2caa85de37afdba519b634670362dc3c6cd50e3b57c9f20f8b1551345edab410c253011761b1150077e65f1f4751af62b37668dc0d0a888dac43522e5c6eb4060662a4fcd19c2f60fbf26c4861ae36c038ef4509ce7d1b94237ccde7545ed9cfc383138773d26ebe270e202fcbe0797b003235713e4c99db1422c1552b89db43a9f73ca357174b378f3af11e2b35c270c8c09ced98d39ec88d075c44a6d1c5fd7d6869d8f7811a184fd69228df96d58085dae1d2499ffaaec9f2d68a849c0b09c3570e84ca8a3634f21fa0f6a8b977ea8cfa23c462235ed542800bcaf6eed7443f5e61b7a056003723fc41bb59e385b4e23094c4209e48bab6c80449334014ea9d81f79b11c283004a779651fa5337171e8db3d87907a7e857b762317289dfaf688fda9a6da97c816d2590a1ee4598f18291e1fc3a2e7c5db0f3e9b1799d62bfbd1b1eaf6e01c0f9cb5fc31b79e74aad1955b5e7ca680e08ae98e381774e1d9a0cf8375d6cef149183605c064af20115c98f2bfda3e6123bf2d6837fb8a0ae0c80bff9bec855e8261a450fbe1a9058b5201edeeb2aa87c321590c6ef9e444691f1e0ca1c94877db79982dc0143c7c78ec4b9b86a8c866a29531b5ac87b5ebf818b4eddca5e4e3f3ed3a208d228c8c5eb636ba8ff0644ce95ab7c2fc8dbc0731b034fd547615896959488a9f4a3be425a307931158d70e737477eb0a135c005a37dfee6412f1b80898e533fea48a9d2750693bfcd3f330f5d5d1bc4ece71140954ffcef6a175dba5f0083a25ce1a3b2af4a47818eaa9536a9fe8ba495d081e7568afb89f16509083c2e5869b2d705c2e02a56d66300a54608468cf292809cdbde8d6205a0c068466d100853710749f70978a4130bc98d469ff6a36c4777d14309a771c50ed3ed84b24c43240eca94b69390b69f0d6cccb1340a757fe1983950626f8a53de5a93689453ffbf58eb06358781820996ecea1cf32afd95f4188befc05dcaee8e9a5c372b551cf659bff87899fb9bea3cf67c09d4b250e605152009a751689c387d23b52b32250a6ccda9644fb0961ea50ef479e3f8fa4639e3d379561a4a36d7d5f30aaf4092e9dcb1adc55c097f147b70349dc8ae907ea2365f852427522b0113923afaa117968cc69325b30a171c2b84fbbaa55ad818f20a05319b92044cd734de067a125c3a9000c950aea8af06c71802926a0b5fe75cd7e8ac7222740bf3716bcfcb3b24c0cd2fea989928bb6d9998daf806ba000cdd58e18d0facc98fd8afb5a04fad24a25df5283e7445805e7091070c1e59279d91ce7262bdb842fa9ea5a2821b3223fc8ea2cbfc1e3c22bbd4dd27392861611a0bea0f816d1c75e77a5c88521a7efe1a05001e87f09c2fcaf50bcbc3e36a93caf76606052a323d137f4e7aecdae2bd66bcc0ae32bfdbd3bae87f9d7c96cc5d14e6dc8b4c0ba7fc1580da8bdbe63b3cf8e5bdc022a1c0e9a4c27c710ab0e56260f0db4594aa8f2d956f950918a2bb34e1cf941fb946f154356251298a3b1871856b6aea8dbea3b862d1a91d6e77d45eb92886670da5a71809ac6333e650fdd3ff37c3e5e6e21b641f05e0ace699c2affaf7269fd2f78b4b73df6242f18f503e0dccd3f2869eac63d5fb7f001d465d8b29c99e83d329036ddf4f4ecd8a270858bdd3f86642d89f616f57e2deb03cb5d3f8f3d335db878c48db3c283b0b2af8c03e83884a3a67534f14fd0757dfc17fb9743bb5672d03820787d150f050c35f13b492ba35183938920b795aa83d396f1b48920d22875653ee4ae5c16479389b5176653c84beb672f0964c9929bde89b0235bb2a852c444a0930eb85b5259d127f6fca8b81f1552c781832339afbd2806c4648989b2f0e1ad71e6b558729582e719d1e2dafb8094b213d208bc94c24a3e8e66730795813831f23df3a5fa697251eac9bd473334829c4c98a5b8324d58e7d68c34d7b90423266a56f66ac06cafcb1309126b7b1e200f17503840d75f13e1098e05790525e49edaa3a2ad533144e3d71afcc889be852dce2b8374d36e010cf7fe64079f43cf9d5718c0cd1b8a11ba23bc94c81fbbece79b37c33f41b8ea22a9ad669677bd7b65058ae11c888ad1a3df45dda3c1058aed79a7f63383b2f1c13fdb889ffa703eea346c3848f6dd48485fae6bd00b626378f2a491cff0a1fa69f3c7e663a86c60017a1826ecb41a127c738b52df17ea6e0b0d3fd3920c10bee7347654fd5a78f9db67776178775a61caabd86502f2118e5f7358d70ae4b0237d243f708a2545da1c11dadd3ee57f835b669e13e08f91e4ec17c3c693377e1c863c277d90ae910a362463546af76b6dc857ac51da3d9c5bf251578ae3781d055983e90ced1eac38b1ce8c32718ea7fde31e04eb7c95f4d9703376f2c40b2e21c480ce54711670e1595ffb822b1c0732e06ca8b30b43c5612328d31c8af182785907ae3552a597fb243baba931735b9d56dad3a351dbb42937f421f164a6dbe1bd7d72aaa037f0e0f56fd7ef8fdf747a83760b9e04ed1516601300e4c2c16f21dcbc29fbe57bb32c359078dc2774dbbc21cc66203bd0bcc7d7a2de831566cdad3854cea084dedade74e3ce76584c7e3f83472570ed2ad8dd4c4006df9b41f95f7803fa86a4b6f788f034c96daaa752f25a8df261cb278f63483465ce432bf150fcb54857698b61af65f4ecd769ea0dde7fffaa874af2e18463b30b45110f35fa3256210a8dfb09a2253b23a289334bf0988a99624de19a4a1b6074e4ef47dd919972d2e0e756c9f7acb760242e2cc69a7551ef2cbfccaa8ad6795fd54b7351f51899e7416d73fa6eb5f539de3fb07fef685eba5eaa3701b55571034df8af6098390c1d83bf903b9037cee323c2e0411548ac136ad1057a9311ade6c96794d02cf3c12ad65b2d7a62193dbf96009a38bd58887a9b31716f05dae04e289bbec1cc3e59caed7b80f6483859cb6c6126a39d3f6de05cf35329aaf33a6680324221aac14bfbe257193b3ccf19478d8d629cb09020bbde2fa9d89e7351adfd82dbbecc986dbbe219bdacf4d81c6bffc83aaa70bc3504614b245b57b2ebabe8501e9019de1298dbd9f8fe140e81624c2febc41c3d1b20fd1c4d6a1ccc6ef1189409f8c53e9191e7a602a1891914b492155005f2575a1b6a75f32559839d129cc9e917a67ae7688ee5e570fdb9af86e0fe492246edc15c8f185568505bb021ea339f57007bf1fbb6278b297ee4be73a86a34d4e7034ccd3f9a4eb5fc8226f9abd1f6cc9f8f78ee1670fffa1d11285b31a9a5a30c134e954fb7e907f012766a3a3078556488b26ef7a86961f0e5fea3aefd91f4944b23e17206b5b9fac1cff855ba5b7dae54464f2d95ebe251120eef5c274cd35b2a9fedb031d5e7b5c8b82e9ffedf9a82cd226e682f6c22e366f44bfa05eee5b52a399d2eed2fd43e053e3647ec6d22bc60991076de756de759ebced473fb4ed970f691c777967f9dbda34487a7c284b56d837b6db07674ac86a55bd212c850fe2969e2a9150b4f611f5f430fb7b83a4f7dc45e9b1bf8177824a2411d762dbd7da55f46454c1d4716b9f2b54d1b82e5af37d004b8080ebd46c14ce68ac43c38d2a52b097a6b224e4c24cfa4171adaa54cca5837b20da877ad70806af118474c793bcfada9610fb2fbc09253f687c0590e3c57f5104f5a13171f093b920d5265b34e298ce2cf7596b5c0ea485add22887aa4757bb9006a049dae349d480875a4fc407272db1cf49b65b05ff5a714a8952a8020ec2b2e04d00ed36ea4e0f0045a9c6c05ddbaa61c8268033086673771d7c8cc98e511135fadca2130422ae6aa245dc9940451b5896fbe3b27d8be6fab9af9628f2a4355232d3e4a01e46b8ffca9f00de868933f1ce04af6affa8b4a7e6f5a7a262b8c6c2c548d29585cab0768305a6bc93a7c23cdad6492332b03f3a850f87885fbee4c8c7a6aaaa04f3ece6389adaa5b54359ffa2b5e494eb82987d8f06f5188c350355d5a3723c1dddeab5ea3b011a68b32deac13150b0710af56a9f7e9d3a963dcac12d182d53d43a9db14cf43ecfef7fa32a8916984df374f464018c072b1c98d722b11fc469a2116be582f8f8c5b69fea0f3fdf2353dd548a6a7ce064549aa86a5442acaeadcb5da2d94696679ac98ceeff184c84c754bafb65881695be53b6d282b325c1c699baaac97ae516e9d005feeee1074c12af4906bf9b9b4733d3526c943db13696465944b06c4b59845d6234f652342c9f45cb7178d398d32ecf33821081d582897abcdbb9247126b99c368b8d2516051499e6085fdabd28254af7ea4437e9f5fab830efdaae10c61560f1b6f6e283e6be69a97bf4c3a154fa9a91ae056df2fcc78547f12e7dcaf259ce31c2781627c411d6c9392e4904a364f678351da0aa9598ec8b1e31a30d21f4c84b489be4e71594f6f88664932366fc86083c499e7acabfebedbe1fe169e45f9c785f11546b6ad3ce937d8bb9cfbe44f4af73e01f383b7d29ab78514858f77414dbf984d9db44e2f16c679486ffe294746f6053ab3adc759fa11e59c54ea19673d720769045925b6ee4bc2c44aac7445e027e64ea4c2ca709a98a56d1eaa8e25009d4aa1bfcb3a87edde4f133597c8d69ce58543385f2ce52529882536dd2bc2e43fbdb2e880d8012791b6aff2b8043feb506be6df802b0638de27531f760fe0fcb64dc41511bd30f46b4407f81afea035d11c3f420e7a5162e8e8585a8e6c26c3e07106ac8906b18f91aba4d6d74eef20f6edbd2c522763ea93cceae0f4a28e05e7f6c941487b1ca90dfe7a5a2b391eba8304a3baef09f7effb6a12dc74377530774e252740e3c6f166a60dde8aa2d742bc2cf7f11a38b98632b7f28dd0e26e18c48cb81239bd57196324e6a38c7a107385ef5b721563e6207faa43ab8b2343acc7ba520da2e6d9b71db72d8e1126162cb19df50a0abab29a4f230fa682df06916fcbebd238d9cf2c7fed827480087378375d5a5c68d7d29ac4fbc7fa9f450e503cf498748e04d1fc03bf84eb113565b6102aac57aaeaa1ef2af04a882659d10dc5475892a080c81c09f5c2b5e144355a7d6fd133a4fcc2c7cffc42cb80d72672d37b6876cf06e524dd07ee9deaf77a2fd563744305e1b92ac5daa4a04353866e6f3906eec7572b5908bc6712b41c350c6d64a2eb0a81043110d5566667517f5ca4ecdce2716ef30f95a8b7347daa37bdc2d15ac54792020151068eec95287b4958e01404d462868d1fe8562e76cc3435e64e23559b3c905a561429342d120f88be1b4a4ecd0811c1a31791b7fb6c2d23293d3015ab88e125d1e7fc2b1e7404b91a188b731c359f86f6d269c8ba532b0e4cb52ad09581bae8b35b21413de1772cc633113402a218b7dab51f7078e38b0c526e2f35883c16e0fc211d2c5bbed11cc433af2781e3ccd88820413993e81ea42eba92ed1638006b1d61eaecd9e2efaa4baf800148a3dc492d84360ee478ee7095bf479eb176313553e724ce305e388ca6386ca153d0df806e7684940e3bd8c5948102784552f68beaaf470c8dda6c38056efcb21f60beb398ed4b67ca30d18cc0e03cf2e7d12a929967585820a4f825ceab822867540f65d5ea6399822a8125c9c8dbb85d95882fc7ec667dacf4f6ad270c9a36797809a43e0bdaab7337d7a715d964db924852bb4209a2f6edc56712399864c59732361c4f1c771fa3901e490231e9912c690f7bf3ea3f74da8028c172a6c62bc763a0efa3e3e9ab94c6eb7cdcc6a7dd6fae929deb2b63f64b786c60fc57cce4e9a971507ff6ff01a16c0c1b57d862e315f26f44a504b114236524c1f9d43daa87da93b0eeaf918f8127ad8841932fad51453071317fa61b3f4f70ace3a04d6278768681462a58e9fce30a093b6733ae47fb53e8df23c3a153bab2bf36c6302f9b1da93b697f598e7326cb873a7fb930ea678badecfdf2bdb09dfc29e0aa79c023814346ccfd4fbdca6e565bbf8484d68fbee3e02723811051a24976b5dcf631db2c1e1cf1b38a1e3fb0ea7c1457150855b9413de37deed6fe988522ce5801ee111a57cf3fa495d5186354225f4d7a1ef05d86c355399aa59b6589501d7a7b53abbd1a34d37d92f8a8e23adffce9d02d486c0b26145fec21d9d0f7ce00c3bbbd00bac1f0dfead3d437ce8d55061c4d43412c77164326228b75e12ab67778ea76d26184aa79098c35b4a7759cf0357799fb216813e7c26682a42358278b0abf2777166670e218fdf430e5a9e004ffb68d9d4c0a2810000b79376aab703207c04d355f029ad132e0ac10bd95a7e93fa5ef216dc51a7db5eccdc9b82ab2abe9cf3cfc4afe9063d2b2244e1fe094828fed511964c497e8b46e57e68e413e6dca5b7fcb274a2fa4c14bc55ff31d51d75a6bf75e6b2713d4120109351f2e3a8d28aeaa4ec97cad1fd152e603f7101f0f33fe2c453d2e9e73c7235449039ac2f5b97b64f06b8c456a4fd82668f6ea39dc1c71682dae4b4b1038295046b4e73c2426f097ceded906c02ca0405c895c6a0593870a5a5b2cdb63ac350225886ca2ea0de13731a2fd2231f1dd8d0c638c41d01775638c3ba06c717e3bd2694ca132e2672633f9409ce1f48807daab6999253bfed0b1378e2e774bc5f4b3ce18bfa27cb8febc511703cdd4ba28f2f5a5394ddd37f5114237124355d7ebb29658408ea32b42254112badd5bdbf964c9d337c76ca7b79212d8fdf9f7a15765de22e5226d9fcdcd50460da707f03860e6e88ab906dcc2d7e07048db264beb3ab57e1a829d95ab64aec2eddf4afe13a430eb6d53b5e5c5d0118408429308104c2e3b3cbf63a8f83b4a182c9642a5f6607bf720abf8a21460c25bf76223051953e09d9ce1d319ed5d3d270833a8ef9573b5245bfa344db3f365f52b96578df58713fbc86dacdb7e5b7a53761fcaaf0acc8438f0f69296672503513fe63aeae164468f16bc6265ec1edca66a36d2f0b56368cea1e68e2f41ba0fb269d7d9434b01cc17fee3104184ca5c8ceffc75183e63a687e5423acd3d5571fb121e64aca15a60805b420d1624e7988c0a563c09911da8b69df6262f4d01ca88d43fb8e43fcf7fda941793619dd82d94626d09d2e40aaf170b0b9707861c7cf1ebd87a14b3fb19ad4395312488bd4addd0bcfcef94ab66cf0f072aa8a58d17b4159548ba1f007e854286aeb9962ad3ba6a880fb9413490d9ec2d1f108101048e0701b7b07ff56717e7acc0744100ab565d93df433ef54f2574856eea0a6dccae5862f42de22ec8d1a540f9617ad1dfae665c3fc03eee876ce0b504b08505953308ad7920ef228984253daa068d7923f944ce48bae610ebbe115f816e21c6f0a257259e92b96ddee771175c00103a68845c1987a3564f7c4f9e7467235b0dce53cb882b990f03f4221bb297ef178fff85317e18f37429c3c6065bc621fed1cea31dc1197af71d9cea783c4e0d6f23480cf59190596b7592359af539c8fb2d0670a8d55daafb2c7813f0244ea40f74c80c7b8c3977fbea1e4ca9053a41530db663ce913051b96721cfa75f374077ada4792a272261839523fb19f8a1d8f04c15d6d2b1d86fdf45f7033e0aab6089262626003c9445b005cd93ec9346c27f377762a3643945ddf566372abdf5d7afae391db50d8448ca91f15a66bb43029ebd196443225c02c339b8e84ac0fffffb8834944f1b24e11e247b7e6460abd60a0fea5cfb254f9f50a7b50d39f82e75f5672c374ef02d79b8c6f435140fcf60862c414c4ce3903c1d20e60520fb161476f4f6f2d72d9391dd8e5a15518d530e16f23f2488f4fe4ccd2b9f0dc2e9992abace6b9f398b319a0e3b7b1bba29599b202822c03c5418ec4986f2bc54f6f08a2017eafe4f79be04beb5c14d4b16bb8d58a3fe20fddd22959681511271f7596342c6ae4e6588b133d68c619cae9a05e2b22bbd0a3392e87243a35c6d9157ee2d9b6c33285f36434cc796f9b298be89820ad10f4ea5567bf30ec938da85cffb548ed5a2799232cc9ddb57b1bdb84dba3fc0d379095361d65c0e88110e24104fcf1acdc4b341e33bb90b6b2c9e3e6dcfc56b2968ed7da5990a3a5b77fca9694a36728fcc0547916939d1fe4ffcaf0526bd7d94d65a5dede8e97b054458517761822dcd1a42b36d31d7e36ebfc38e76f4a1104156403c3a1256e8f9ee313e267e2719f7a96dba2711e6d4b90e940f892fccb102f493b1288609e9f7a2939937dc834ddff0f778e82ef7f06787a69f56e50d48a8aaad80a0a8ceea6674760c690161c716c88517cb23a46bf9476e3ffd85df466d5ddc110025bfea9cb1c3cfbac172058d6e98fdb736b6cb64cf16d8c7509ceac19e0f66243b6e54e675a863304de637b62ab58eb9747693f7fd079defea20c16f9ef0a012ef52f56f9b7b532b6c0618e4249e98c49596dd0250ea4a76a127b27b0fa6f936c8311e042e0e068bd195c47b9b7c08c1c4c77a0d32db24fa3efeff2fa03e1ec5e6a5f8ab30a42c84528de464f080be5bafd9678732c6db79903f4f08d1d9e9da1a4cd56d7eec18a891048c6ea9102c523bd6ef7e34c6726c3d0d21c184d115d1af8d16994ec9d0dc6a6d1ce78ed653c646d039cf9e76721832788d43324bbececdd9daa500af978987bc5be3ea130a89923f51714731083f75403acc2760f27e139016e9cdd27bfe662cea9f1cb099f44d2f3487acdcdda496ea61f4725fc6a63742ff4c96bb7d3b8e6e79f9633c81c5380db3e105068a34f75f6fc8bea58059970496a3b64684bbe734aa0fa24b34014f47bd8b24b5244e11f79050dfb77574d50ee34e574a8b6d31420f93e2ecfcef51f753b62e638c7292c6b686e4d081a407b11ca7c3178554fd7922d25ad0b20ff3cdbc5e11ab6370faa17db2662d41af36eb197fcf0bdd4b9b91c878d48e6e672799eda4ad31acf6320a7ec269e692aafd26b83fe6b68cc6e602c385687864a4485f87d7742ac4a489066ff8a41bc8db3a5785fd46c6cb001caaf56e459fccae00b49604a1aaaa83ffc8f2109b1d6ccb32aaf89fd62a78687dae385d62a430c2d8f6f2328733e2c9628971390eb3e116c0af4b6368e6b526e24cc92e4e2d061fa69301d10e61837c27f5f46093d1ae55021715fb9154500f3d010e1cb15b2a5f9e3ed2427010a837f3efe30513c59d0c8f74f390aff8379eee1aa0f427c31408b4aa2ca4a97c91309de2188f9164797aeb795c5cebb6c4455d48a4e21d435f52e664e08a9a42094c7ef1f7ddcfe0b0a089f10698968a37d155c3c9b7c1dcc9a65cd8319dc089c3d6a5edc54a310eb0e97808fc48f592","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
