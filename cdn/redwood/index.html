<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4285935a5ba4313ae050e659da79576c04e5c672f7b1516508ed541f74bc68228533e274cf6ab7a034d6325ae3a35b9f546865eb28b26e4f5c89f93a6c2986570fc96aaf4eae5f090a5bf57dc9446cfcf08951babb630073c2f53ccb835fda636ec2e52445b133a81c8d22051872246fff13c940e25c129f601bf4018e5f5a7c6a5270687f26fa3b1d15bcae6d587435a4a0a98b1b82b64906e1dfd3b4c835e1b9d8692d7a7679b3324fe4c91f7cc66cf78b5b3b7c14f3d2e39cb82f71565ec5ddc198231f2bd2629aa72ac018e67661e77ca490258b406725de98cfef2873563c13fed80805165d0f5e3643cc64c3d164fe5d537f4beeba19a2f6b36f38a35a01ef42155ca81472fb6d656ff19c992a6acf8b48d1f79479ae469ed714a48c55ea366fcb339f3352639b7f6491d3683e515ea50ceab6612dce4b6a6bba4d2805f7ba43ad7699b7546ffe31cd3d3be646b718d6d4aaecdb233e45b2c90c0434a2243c004b72cc3465b84c3ae5dcc2cc82e064044b9cd7396feb5c3f0bdbad98595d19ff15f95bd80907f8bc84557373e0d8fdc655a1d462f9505463fcbda5500bdda1403b9c6abee8c93d24f53a1eb0413e0b749456a5990ca5d650e004316fc6f25cd34955cd58395cf509ffaf1929fa8ca4bff1e5a8796f71b72f93d8f477b3eba45b6c933758120ec6b0453eeb88ff2a8db5c852edf7751ccec7cd532986ea514bbc185a889451695b9386c07e69add4d3b99c0b540a3a093c545fbce7d9389a1eb8a03783801049240244d077b885c7f7003687c2987fd802083d620c43a1516ad9b91f6736554e6ddb02a3630981b1b297fa8213ab3d4f73bc5c841fb609dd2697fce323b9e5e8539a11c40b6877c650edcb09cd459bacb3626702b3e7a3c1b854e8f102d7f35318bfe3687342b60c8851d1bbd1631b7a442e0672dff3565be45e1b637c195d592edb9bb53b5294ba9bb9808487beef552b2c7a0d0ce5256df1e1b010e34c1666ad56a89ab7aee5cca48ca5d3065ab6212eb0ae0d9ca4e957bd016fcaaf318bbd2bc735e0305eb9852d119cf9168d606d30afed98fd505fc769110bdbf0b7502ef8363db1339832c827c7c903ff17603b73603172148debdfac07f871c6651a3046de74bab9d2270556c997ceab971130736823e251ee6f5a131589be86b478794491e3fc35f2ef2be8ecf325aa5da7e519e55afd30711f343b4dfe520c069ed0eacb136d400f956d78e8d270384a0b94a571d150d8d2dcb3bf9bf8aabc3064403bec3bc676e48e8dbd5584afe1120fc75f8ea905f1a30c82983cb9c6d9820944c21543d2109eef4e22f43126b19191f3f97ec631b42392a79c013704e1960074a4faa9688517b25c4aa6b2b418c33e350b22fd798b30a61e953e52e17e981ff3efda82e73774d2ab05c29a49ed7c6564cd3d2542a65ebd7fefcde6700a5f2c7816435935c5deb0fe1d95a67919bdd11f3573c7148dc3798c63f916b109377826b90f9539208b9fd90ba39911d256674f785edc4934c990e9aadadd0dc4a8c780a7da450bb269393e2d0e6b75b4adceb218b81be5b863af35e2d36849decbce97f7205e82e758dbd7d3797fd1b871a388a14c8f28559da9d313f3e8f47f9a6928a21a94d2dbdd48d4b32f131a5129e9b6a9b64482a3c610080b5dee7067354ec1d062391f8148c0306aa28516072a6232c3ae7d1460f6871dee0009b35cbcf0ac962a1c1f145a1900851de7886d20b919883f61515a598bc344365d0c3e32bf87779df82b400dd843c1abc2be48d819722b056b736f8acf001eb99ab2f2d9dc879a17e45186e78f39bef755d786cb2c8dc5a5a8547ee71d41bd70b8e76560251717a510a29c710e94becf1d0f320107e3b59224cda223161ee51086b00f31af491b668ef64fae016eb1fdb61532ed8e30f0b1a5b57b174450c4352b286b2d69924f9e4d839ade6df00d3cd22574a51a2b98ecd69cf0ffecb65a9ae49789253bc71e23c50e8d2f7fab5489e2354282d0072564715ed841715080ff4c67cdb54a5c2aaff44ef08eead212aa78c21d7dac01185b1edd5ca1f364f378d0b80ce08a75d1a961b2ea6206bbd1bddc407d5f66bcb75d3652998970030439f3765c1bc9f20c9d2274b835b9d01675e217ddc89fc3ad10511c69d95a9970a2a51f9acf183b235ec18db32767d2eb85394b015a05deaa05616b86861adfe3819d5691f7cbee6e630081d1a0f94304772d476e5c4bd722f8f463bcae73c30191ade0411d0eea7dafd03f15931c49555871d72735fdadbb9521ebac69305ac8fc03860cb0834fb8d98739f63240c1313cb67fb8c4f065cfcf0c9ac3d7c1859a594e73f323221b5c4d1849f877d08f4d2ac5eb4a1b87cbf020af0303fe6b21f6411709b628cbc8714168c55ef71c6ea3c64d14da78a81822c169fc014d84cf6c7e7c50af3c99690cd2f0eb5e09485175c361e66caf7eade503c8d8a8846335030fa8d593ea01896fc638558e6a40287174e094e120379290f78f976d91cfa7d70e10e6464975fc43b09b4f9e634976324e60ba98201dcc3102162f5e923ff71c265ee4e37b05b316956ab2b57875e047b25b795d199985150bd669b91c7b35a2e8cd82f1f2ee5b58e6d756ff4344b298815cd3e1e7937138d51c7b82e7bfb7c1387afefdebfeddc55e94162933e91da8b4e3a6f7a4483b67958bbf725dd369ca23718823a84ab2dcbdfb1e8ce339714f9b3d490c2d24fc116944a02e7645f5ccc1eb7acb07c69b772303918764b42d0635609f22e05a372cb004f2d5186754b15229efb3d1f4aff22efbc942b3df51c5b921530ae3a3da18ecd440c2f25b8d18d0f35231d456c13155d9aeb81eda53a2d4b219e426aafc1bbed8ea72f9dc12cfe22b2f716e073ab659c7a3a3dee29617a6da078a64974f9854627a66dd7abff24ee9e6364a440df8e38b397e7fc7457cc24d667663ca4d7956b57754042959f0c46f184d30e9d353d6ff789c3d9cd86db93f3539f91a3d6ff458f8e8a2783577400ea79096db1537d1faf483f160a9efec1ace29a1ad1d893503ccd3619fd0f7f205c4144f5b4731e86194f29042c169bad65b38fd2ce1aa18898114f487c44911cb92f9a217d3af925dd25810f4369b55fa9a7be31017b2ea81255d06d2e34467727192d4b0a831305f35b7cab1df8c643486170883be72b409e1aa0802cb7d2e3b4734bd2a32a0d7e7c16bf65a800f75cc3dfd9bfd5631d65f88f8ced44f6fe2aa3e6b5db6bb0510636cce18ed07d4c2e9ce666460208346982eced5278ba9b44c84b54f7c34d0effcf3329fc1cb502993c22d6bcd91f1302c36b0a1e0dcd78cc324d42be2af58e4645ca685941a3f01efab811d1ad96aec095b0761260681c2044ac562b3abe285ceda429532b6d16f985518bdc208e7b50152b0b98701bbe6fc3a0e4296d593fd53e076079402b6e549554c9dfb175a4292665b11706680d97daeea479d9123f5e88fbf1ec409de8769fe9727bc4c22f13e80dda28ff7004d0aefc14a24e05fab5d0d5c5d74b35ae0c9b290c89d60b6c1b9066806e451749f52cee1d6c84a7836dd0c7ccea992af113eda1f038b899751b28210e5249bd7f61acd96a9d785bbed1143b46a4a493c1467a0b2af40bd95529ec261941758cb291f4f6bfc9b4ad0def91771dc28baefb38d14b3bdce5fdb48ff7cb5812585c79e47932bfbc520fd04f4289f48984386f7bbe305b7a96c12c38d665f4b5ed7ebd518b3c18a5b036b456c01e2a573872557d41a7e5e736bd79a0bc1cb4e2baf225fe4941ad9594513acc8f0fdc95f169dd3e10e0d5c103b81d5054977e17368211dcbb70c23afa30e66681a718a3c20b4e1d2fa5c5dc084e2589724cbb16bb8b943710c22399b154894af1f894311e7e7278c53c130b41c6bfa7b6860571e6901c47a84ce140aa62e847cd531e48d6032f07ad0245cc3887051e87e670b3a98ba59102b7ca04034db1f085b577d1e94a58b97de7393450501ce26111116227b55f6d8b716f6a1fc0aa7845113a6a7d35ce5ac979236291b65c5cef5300001b57e8e6210b3a12e7d56d245dbea3c11ff2ad57ea39916459362e37f2ab42b5aaa866e2a58e7421f9cfe3c92d569232cdf3f01ca6f604a527872b7faf7385207cc2e202e29d565e6a3039a175097959e4ce1e6796f245aa23e7e80301bec2adac06a7839298f7a9460f97845ed8d2f6967afa0f1a10ac18e15491fb216b656e3344ade4cbd13f0090a0effb71c0d71d97c4015813f886f3693cb1519d954bfedbc4d57d8bc59d1777242ae0eac802d6ecb278026f0683ac8314cd1dee881ea8a997f705116c03af101dac48199d71bf56bb2a54dbd94e8faa26e5c1aa5d408336a39b8a89a42ddabd0fad7034ddb17e06ed1f42038ddddd8c031fdfaed7c0bb9e49af8535e1d8937d8b5983cdf97edd69b445be42bea9f5493cfe74c0350328f18111e6b8e29a21fe0039d47c369e33b7d9fa63083452320ad300debd407c603428b6c688959770a66e66f1ff967ccc28232c26f2db28a1008ac470d801be716cf9ae430dadc63ea9fb9194dc4b9a01c84f907072d513f9ac12a96e8ecf89b7da409d1d6bb2443af99623d9f025ed46ea4c6c812c895237ab5107b1d197a5be809997c236222ce8dcd8d80886af7534adb957cdc53aee8d714df09f8d1990fbb4bc8dec5279ce0cf74df2a97ed8fa3becfed9413d1eb7934bc242bcba8d4b413a1995eee4ab60fd8641f9a2ee5cc2185dc6a3f99769fcd964ab22694db92143cef3a09ab4de5d058900a43189543d541a64b6dab30f2f55cd05f5208019c827ece8e38700369ae44a3b9623601fd6297a99ce73994a9749cee74324b8155d8c9e2654a182beed99bd782caaaf5396ce23d8f5b620e253e06e469a069c070eebc2eb8bfd78d8f0d7fa520406632f14433b81d5c4e7ea52ac0116d6c6389386b226915e875569593b5fbd781548798c9533aae2b5bc298c03b368d0f577fd6adb3b1a7efc618434f5251a1cad16ded21fffde2c1c22518c018c6b0e9b1e53f6a48dabf98c344fd6af3329f119617f4300308f5a5074c8ce0b6febef088d6566b00342367b1820d6ee14eb0bcc77ead0c49c088835d315d4a24ba24a44bd8d6ad29c64df16376ea3fe574ae0a1207577fe54f8487d14457d8faf20b5f06ab7e8a552151611070f656c9bb26c5d52d62e1efb3d8a6db77bd49cbc0a2ee385cd9c7198778b5806271ed83b1c64de402986434eb0287b5c46302bc5cc1d39df15fc740362050bce6e5e4156b46b4fe1afd7323c28580ba28cd9a081d3068a8afc4903ab4c0fddc6542cd72f52dd6dba900de66dd69f180c454f8c9664964769daac42ae710a2b5967bbfd0123ca1dc1cd23ba8d0b684402f436a5188ae6d096e664eec30b9c71b646ae4fa4ad016393d4de3d7b509e9b93f49adc23a1b4a13c50ee937e112e8ad367a1d5a9e1b95774e677e64f3f5889951d3dca0b9fa21de863d32a593ddbe65d298f809601121b7be6ff3551edf08466df8b3f61f0e6d9c1cfb9a1b241b78e9aa870b4be32e0b694b271cb7e6a5214488b9aa0696ac9542a385e6989b20ef3dfbd91da32ead3c125049091888b33edddaa989ff05ec4b7600fc0930d088e0652743f2259bb39c412f7142ac5c7f47bf116fa3ba878f65b708580d4edacae4ec7600ab89c1ecbdbc792a73fe08f4d131afd4afe2836bfb91427bc4bdf5426e2a30ab36a855659bbb54076f5f2184e882d37b94da1c0323d2b99730334fd22c9c358b691eba1c498010080a56bc7cb40d8d55aa0d2ae501c9677ec0f7c5544e5c286380569f7fa133df6b5a91eb604d6cb883abab0e3e10b21c676993d81f5e45255ab8acc853cfe7c96f10b372ce9bc8476bb267a787a60a7616e315d02bb7bd8a2a74358f7c04d1b632922033f700b4448855d89d6c7e23b358a1d5eb0cbd353c39045e02c6cc50db5ff0732fa219c0ac1ff498bd196022526838341ea790cabd31086d2946d39ade8b26b1c57b0a7cb340ca1ebdd156c3afb469351045140ea55a534bec43f8b9b0de6ba49c36b91adc988e462ce473af7df1fb8e470e4fc6df694d961ff08642e7b44e2b93a6dc961776409f8187a75bb02fd1cba5ebf2337bc00f3ebfcbe70389b4d6e50d40546907bbda513ac4b9d451b8fd8e67b633fbe21b2fabb8f76ea23ee82ce388402067277bc1b845cc356f5fa5eb1dd4cddff01fe8943a54a343bb636af1023c8930c01ce859fffa9a803d0a95954b9c200ededfe7f44e5111c800336f7698d8320bc9de59d5170ee7f4b79aa05950c8027bc5315c7f7307291ddcef666d70bdc27b9637cd87bf86e6582fc8853b7ed4914275e71e0385365c9ed7f456a92c8e2eaf00040e76fb0304bacca70182e3e42a2a1ac96648cf8698cbcc4b8dc8ca4aac2164ed89df41e071440bb60717be6c6e766ca5f8de6fc557fb183035fbd0b93fd3d19d6265fd8a81398dcae4592f7823714edb54f09355e7d998facb00a091b015cf0dfb65d9df7401c70867897f26b4591152525218728c1cf615a80c0b5f8cc78400abfb65f7a7d1cba3715e68e48806176fbdceba6cef9673be119ae14dcf9675f33c344594e24fbb4a28e7d644f79e74a2aa29cbda3dc806e932c27696168b00790d2f735b9a3c36e762b94396c0f910df9defcc57aa5dce1c7e7a376f7d3ba7ccdbfe4dacc270c65234087ffa0f1ad97d0094effd62928e1ea1d374a8951fa659e28fc63f0591dacbd6c0932e790de53900e63b1e9174647bbf0cee957dfae0cd89d68e92b2367f0dc18caa4c34100794b12ab3aee699e1458616ddb8935e65f7a09d83a09743fb1932a089ab910aa802641f2a50df8fcfe3551fd4db16a9aadcdf8b56fd3b1642cbf1826af6c1992b5a2c5878a1a0c59279eb291cbc062c4c3e8b86a55b5f13386314497c27fe7ddce65f688c70aafca6f8d20e71d5e9844c92cc6eddf99d89d3ba78d7e86319c0f718105cc39ba94d6321febdcc343c50bfb2a9fc7a3d269102fc9ff315163d40037e34661f0b6885c963ffb1616a0dcb2d01eff1f4cfce62fd09bec2531a84c45e05ce8c6c956a3ec8b67e505d038be205d7831f030b10204fbc781b5df02e8d6bb94fe507f7283ef7ae4ead1737ff262a5eca71f59d51bbe9762d11d477d2fa744447c6d94837da46b0f8d7b47ef9a7debb652a3bb978530067f755ffb1ed9746ebf49915a789640de2190c5b0d8b7eff44175b2cfaa04559ea217b64c50082045b50c61f1af0dddd61da5898dbb859408e1a6eed3c73f0eb692e7f8cc3df7bc0c628d56a37b00e031646d6521156fbe8bd7f8bd94c97109dd3da23cbf8761ee6dd43dcd765df91d1c906895727ce4f3b38b45632293105e01aad34ad23cac8ff788f8f8c59d45d81048a5f46454b975a7231a7416e66ec1f7689ce359ef486f5b6c1888bfe8465acace4a1e596502736c176d4c5d5480554ef527745a928ace7d75bae7bf54a60ff9a026ff66644434f2d6d532b3c8c95722486d571a09b41c0e032532fba2820352b393d77b42bc19d96d10ef3b680fb3fb32e2d73ca30582073ed4c92fe7878e2e3828a542fee7dfe80c8e4f1013bb2e94f2234194bcf085ec8d2f79621d79ab435c4d0bab30ebbfa837015fe28870d8b24345d041b6e3cb341895cce50d42ef435b00f9d5f54189e4439372d9bcfb004cce07b1f0001d834cbda07855ce345a6c1f2c866a4f1a2a622155b68d4f46f4f3e3dbcba94c55594d8c5699643819cb6d0261fa4207fc72b7cfce9f94db5732157fa2a7cb986af9b454cc748bce02e9fa03e03e023ac65656c518cebcf5e8a62f05d783622c7144f2e3e361410fe7b50b382a753d5114e7e44950282bb29e2fb783004bf756f9c40525c8a23ddb93fb918e6931d476a881e8fee170eab38378a4a5e42b8334159e04fec00c5a4a2a1cd952e50cf26e2ef9755599d6a9f890b17b353d703e91e4c4ef30c9cbeb94450a3ffe3cc6e0f4d18833671a6256a45f3765cdf56787557c4e973431dbf978fb46726903abbfe86d1b8d69e4a1a9cd42f450844ece4d1ec4769e7526381eaead340b451ecd33ed860bae2434ef1d96313c6fe5452d47ee5f3efcb2e0c2abbc4b155a2508362f5bd5336cde41bb1148398f4ef47922656a82fd31bd43932936d7dedf257b318a802683b596aa9665681c059af5bf7783f3717215ffa7675148f0938203798e1e31d7240005f59fd54ad42182a492acc23d9d9d0ccf4156f9b791fe27fd1ac9563eee0c2398d9d2ff28cca01d52d63a957cad5b51ce592e2f47b0ad0670ab6ec9cf42d448f4ed64fc5f864b353ae9b3193bcf0e355d3654b08949cfec8252d636afa088e7cc2a2ac379f1eff86fd6f8cb0d3acea0b35b0cf0116b682df0cdb6c3ce36555df7e9be73af98bf1056c78428aeb24cb9aeea14fdd14e44a908d983cb4469251e4bf4e23fbd790f9d7450fe6350554f35b5ead36c54de569d5de2e2d8bc3564beac3878b35b410611c37aee2e240df7627c06ecc5ad1820548f0e8e1e5eda63a412da81d0e5ed916c3f6013145e4f320d58bd660b96e30fdc80f13c7a9bab81bd5d14a24589a3e142d2df1e022194a28a53b976186a286ccd3f870380935f37a4758642d89d05011591f922b34c6fefaa744e35d5112bbea360dce2a27f74930d858afcbbe9183411ce6db3eb86e4482bf0bb3f25439fdee7f94584edd95794eec967154f12bb23a31ecbb25234f7320ec60757d4b3a95d429e8b937f266b752ab2fc7a32d4becb0c59ae149199831159c8b12b8ee32c2ba4a50f8584379c3f3774d6bf495000e0332d8f4d39d0ca720010e1e3918c4fd49633454fc188b9905a526b8bc533bd41a8d81ae21ef6e555901dd43c40e27960a820e7d705c96425ed34338d7ebc5526d989acbab742c838315b16fd78fb655342344165454801b8e23e22c39a2f61b96a772bbf1472322d3b223b953594d646d3ad533a117a222d2ee51ed8cd625f1017c3815449dc667b35edf50e539f07eacb6ac195ee6b5dffcd3645c07fbd9015b569779f709254c7b34a7d589ae7658b75daea032e05d52336701455754f95a5da804fe2972c00ea6dbe0bfbc50e06ba6796269f7206b996781cf5d0aeb393c1a9657fe5d17303c71ab05c5230308092ef693be917cb087cad4d9df9a04ccf9ba6b03269f6725a9d697c1938e30dbad5519120d25b0726c63992ee801e3b1cf8e4f3a07133950ecb530b7b444782a31acb7711916f56a8a8fc85cc9fd073ce13c0d9b78b1401211ba4e0d4d6f2b6f127fa3964fbc09b72218d3a00e99f1d4b78c3a9b1e499dbbdffa02f97c644ac421ddaef84a8a07161fbb190ac6d2b45439504b238b373af4e77e94f6f63af2c2dd2bf292d5c4128270b1499f025107364c71d6fe6686a7c52d46d1d7faa00746e138de41d905672d642fa56fb65c5285f389e6ef1a26521ce9e9ddfa3ed804d3a227cb965abd074e5a03e731f26cb73051a391185502985daca68f09693e2518d73b0237583791825e984f91c69e68ea7592ee72e8989964e7718e76d78971700235b4a0f3535b29c01f76ab6aba859318793482c179a01cd936d7b0135f52916c782f8d1e83127ad8f8301f4cdf674518fdf9928fa5a4885bb5e71a6f3d4c07d613b7a525b7f3343fd65b840a1fce306308c87ce503325fd4869788aa041ba13c643df7095a531141d505be83c705b28c62fd117a0ba618d915287e5c25eb7de4c1614cca6ca0e8a058e5b584fce961a7db00e69162f2b61bf3d76bd00e34693ffd58be21bf24d07aed88b1323dbdfa2b079f274854e87e989b4f43c820c209b63ece1b50badd4cd88578a97c2e9cd6e07700bfcf6f3455f5ad0ffd690641255bb4d72db6c65ae4d573aab8b4bdb3efca4c6f9920de9393524a3250bf1daddf47022ebb1fb49793a9949af301d917d705fdc18d69837e0c3970689d5688fa11e069f6f923cc15736943c78a86b9801307e849cad6e45746536085da8e3b6507dc4755755a7a333fd3c1ee749cc51375f15aebc0576c61130ab94048239519bb0851e3c46e355ae0e8dc756c0cf20bbce7620233bab91917cb3c8fd1ea608ce30406d8cdaf130e4fcfc009be1ba945303a865b6cc8ce61939ec3436875086e615b1abd673fa5c1ad29caeb0b0c922f52c5b00610058fde1d93983aca93f698a666572c5fc09c70548ab741d9e044691dd83dfb6c01e018cb1102ee72570bdf1b0c544c8c0861eea86efb7ffc4a68d0e3bad02c938619f10427c545f65886637e745d007e650d88b7cdf01d39f868132b7356fe2c22a34155c024a52d87d95761056c1e4b3eb8783ca7c3a86193f174325078baa8ab726408be68978f8dc99dc33bdffbff6f9a62df46f3ce442184c131caf981092076feccf08f94735e357a12af93f8fdac64559b23cc7fd0191fa63518517f92294f45b3245754042d5e82a98fdbced63b9af297206467073d8ac805c20d9b04b94f9e74c94f1d61c034d6cbcd4f6cc4ca6f840717456f4c0aba7cc639449a6456275543ad39a695aede7b22f8e8227934b6cde672d988d07d35008fe5d58059251eb0f0c0491a8a1c24c4b415f8783a04b9d97a8e2777a931b1af55918470a659b4f05afcaaf917dc87e083762f893be8f00aaa7930e0d7d23f52656e156e9352b6172ba98ed5293322fdd84daf4259253a1ac1cde755f5d1340e5553596b33a1bc503f0f718553d656964f1ceaed6bbc97b4a9652e723e905fdea638cb4295d8e7e3428101f59433b756b92d1f02b169d7c53587a219410df21d286a82239faedae910b62df17f77af595fe6909bf0469c16a86f66aa8b8ae4b58a571b0973f4accfe3e55a7d0c617dd2fe86f0fc9f8fcbc246907d5a3dd2a2d25ed8650935dd5a6d847211f13b693cf358a3d000f04758e117215eff03bddd4a209ae827db5f3be3ffd8af59c68984ad4664e68eaa24f40b5a9a048cf3729697534a06191d1ddb4a1984e8b874491050cb593a7a70c61582dc2767a1fe61b287a6fd77c5ca5769af3e1ef2b1c6b8c1da9d9ab0c74f235789cbfd7ca988313e839cb4296620634bfae778970a801402c93ee49de9311ff38d0f57d6240b3bdd561bba9c219a2f59b3156ba57785f40f1a09dd201f817717f8cf18427f1edbf1b298d1d8c3ca67fa203b604e4afba77a8d6c5ca43dd11958697c9f71b92fa2a90d9a2b3a6caf8ff4e39a9d918387a0a40086b898d2119b0826ab94adfb446505d938720ddf382b3772eb33e27eb5947c8da87e8de8b1a0ccb00d60550b3bcee117fbe5eeb8bc6edd8b717e3c92c743a59a97b52f4fe338961c921a63d65c5bae1ef401178754a38f2b68be6892e92971b082bcaaa149b5c26769bac2acc6328f7fd4c52eacfe8536b2bc86741353b700ba5d150325fdd00d5d65b0ae5f50aedddcd639ea0d220a8da544be80d1b99d8c524df1544265d1517b50d480e21453931ab1668a040d9d5e1be22c8dfd11fb3ee375a90aa752a6ca217fba285b04b44a354abc1b2ac47cd081c2ab2f8d061123263676866f8e2db0c4ddde52aa4583dccc6d44b66423256734d33832520ca4818717733478884745e4b1bca743cf927a259a35e9aced933b1a9b96c0db6c44bc616084f9bc4ac4bd7847eaaffc7e7e3f432574797b18208f0c660dcc9e475a0ce72f1230780bfdd14909afe2345665dacec8759dd303640cff8d11ab21cd759b22551dd4af9a2f66fe45cd6247e1fe97419b413201123086a91b2a38bd07d5f67a87b2ebe28c679ea4666567236e562a37efa13e5812742195961c7caa948bac7a36e40277d5f62c8492c5c33386636d9bce7e8f6bb7c5fa21c65beee7453938c75f8d25d89cd045a33cf59653441a64223af1756ee668ab49aaecb3d2049d4d3b49102834b7eaf6a64c31c2a99c48e6a3747577b3a13578770dae4c36ca91c6bd6ecedc81d59cd34531eea6254d3404eabd9dbdaa446dab59994b995d4e30ea9ad0d8028ab11c6e1cfb6a29d3e637cbf89f11f23f1c5db36400116be71e0767bec7a11ad4aa2ecad9cb06e7cc5d133d780da7fec2bd709e0701aba9c55a1cdb268c967cda245c80ee3dc1171701dde0063563c869fafac6e0d26a4cdb0f7e76d3710fd054f3b66a867ef1882673ce985fd0a7cbc3c33515ca5e26553a80f60dc124e024f1a0e45cf134611ae617c710ae3d1112ac8a7d93c89005cf76d171affa81d2e94e1dd761ea062780e3b46900dc485dbc1eac74be688555e4f52bccd087e0df591366aed5d0e99b190aa0fbd5204d791f275dd3032029215cb5b04d6bfd7cf43c6530c854fbc3652dc4e83ae93a02336478c6ad461ede9f5d5486018a86501a35b0750da8881f116ec1ec56b382f14407e12d6f22b44641839b32ca242013b7a1cf3b88636956ef4f4bab5e04d9f443a0dced54d45bb582843d30db81f2b75a291e316b3af5f24f1e0a5654d4b3a3d7e7463d0c07524647ecfd505e87f19aa91b0707cbbbebabf7c1d98b4b0300de5c2b9dcd295518e7712ba421d1c02a0fe70b1700d933d23c6d6c2baff0e2e71292770c32be05c879edb6fe74032bc03d2b40c7435d5b51e8502ced36ba97682fcfc09bff62fa3a2d7a07159f709b4d385d57882b1afbcf1649de739a22c88db27e3ff33e9be8e813d50575657eb0eaf92edfb4a46afb3d4873d0904157bc1bcaa22b5ad47c328bc389c558c85fdcc552fc6d854cbeee3f52a58a07ee04c34bda76a2f08e7078041b1ee5d2285146501100f77d94f7c91554dc20e5dee1def34b81fb943f6a6c83f4dafdd966218c2b21b82f5cd827f789d9356ba7d2223b75ce61cc387b4ee3b753f84badc0b5afcea6a5c9a65306ef1252cdced620abc3555be6c4c064cb9201b10adaff86eac4799a00a02f202f4f076d0b9d35c2aeda315be94c2265e96594d1d3a871aac58306609c6ed4adc0745ccfd0f8a930b84244d7c9200e56e354992951999d2000f6e55895831df9943431d7a4e0fc17b947a2c338c680526a81975fa932c853504168c3af804ac000eb1bc91afa3a9b48e810d6977c002a7cfe728062daf63964e851166e5a9fec204bb9404b26980bf1ec9b081c3448b705987c5d482928710d61becb1cd801fe093272d453f84ab184730b4519c96ebbf738e8e32279286c623a400c05c113ceefafbb75b6b4345eb5e6a61a7ce4110f4d67aa265b1423e27ecd1b06f3b33d53d91f1d0a59fc75146181ba80574dc67a758dd5e84bbf659d2761fb68eb09529d300e66b81c5516502c38349a90a466dd73bfe9b2048405191d9f8d58d66377e7be708fb656fefb6d756fd49bdeba62d5d76cfce61af7742821e915bdcdd259f7282228cb46f79ea2dd8342d8e0f7f851a1cc8583c37641632a0ad278c746b43e873c385fe9940317b0e895132179dfa3d0c32291c98d1db31def125df35f417beec88c3bbe535d5962ef18d7b83010368ded5b11e47a964a785a506c7c5a1584cb81a91bf3f1694e1d5312ec549c5238c7a6fe84a2de16f869473e1d5ffd33d00b36501140a786f43e3a596a873e50cef2aa2ce4a8032006611c2376cb8faec598e17e5c9428d374b002f61caf49813e0d287384bfe66b37cd25a9672052916777f14c4ae636c109fb1f936f4f0fefe962c25fe60b48341048a9961707fa70ef47b2ae0ead3c4fec16cea2843974a8dc362843b9eb5cd137e186220d536f4ae409566eba7cb7f8bc9f33c15cde54c39a9aaee79c79786fb7d47e3da11a11024261ea74c5cf7e24ce763a19557a8a264314e910493e4870e28717a9c1e0005370f3ccd6792603b4e0595529fb11c72ef34dfa843152c69927ca2575af1c07a65475abba30f0869eb625342ecafea0f3ef912fb4a445994a9dc2f9813eeda188226d77e94ad84d9ddcf05eb9d747ff69cf69235d8badba16597d33b481aa3d3830c1e262d49e2d7f29329e1f14cf6079b36de929ebdef21e4bffbdf1ae0269a2ef114d3d514fb3d8ebf9a90fba2752eb3dcdff5dde648d1a8b52743a2ed668991cd0444eb1da6dab169b49098840d7c082d562c6345e0df820aae3e1bc661c2a9a890dee9cdf61ab5fb39312f9807d8980028120647d1a6af50314ffb0696ced05a0bd279299fa1eacec680941b5b028e5a7ab8a6cf63962bd950c4e2607f166595bfb6e2f4456bb6e07eb6d10eb4236ee9e52d49f67f494b1b59cc4b97bcd0ed7b9c94e89fcc3834ca833f21def5131a185a02707b0190394e046b31a80edfdcffd5dd61eebc2586c940a4945fb75bbb384b7ee85b514157606a2192364a11c7ef3216198fffea342b92fa68574ccbb72d68c74e59c4640593a39b433994d41a87ca1bd055ea3d6187d6d5b4eed8524a378170972b0c43998661608e2004f0e95381bfaa623d96f0d9d4a7de8fb7eeaf7ecf7c746ad747154df96a6dcb8002cdb279f6c8bf44a46c3d96fbebb7e2fd5f1a04c657d55790291ae701310ed9a54a1a4c9f645a6dfa4937ce4415aea1f607ef3cc7f752724345dd03fde30d2e596a8c8ea6df371775bedbbc2e0c12ce36b8b3d1f8563bbd8f114042e4d8d37994455eaf455cdf2ebc010040616e9223cff40f2ca076fba67b5193ec012ac671ea0c35680828cf281984f154b7510854ddf0cba6782dddcb500dfa5ed005fdef5799ef141b870e6d0723384d4b4c5260050adeebd848e164f400d3746f2be068275cd1404b46d7d6c35b5d8e20d611ac44debf6da4de3af8384fb2644db18e232f54095bd64145a0a26b95e36f3c7dfd26a06e88fc835dbb8bf9a72da88be350dd3f01ca4628be0335593be5e6fec9f9b99aa7cd609b372dd9ce39b1f5c861bd5b3379cd319f2f4a5eb709ccd766626108a757e195e625919c8b9f6baa3e6268a3a75814753f288e25456e82b2c8d8960b1252eebb5b6bca4c08baee491a0ded56163ce478e2cb3ae8cd9f4cd666a149ed48fa9a85c53183539b112eeb7b1deeb9ba1919c0a8f923f89c5c7e21db3fb50f325852d3351443ee2bc17eff4d540405c052cf893d9e499a7334d3f2b6004953bf22167","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
