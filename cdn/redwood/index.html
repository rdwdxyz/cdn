<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fbee992b11e26c260f1f5521a4659cb620ac784dc0189550d8c58cbb5e786d9bbca50d84a9f9d6f20a4e03a68a41ffc181a3ad7f4a24f75e9d1e6afd864182dad31738a4b2bd429526a4de42039a05e9e8da7d7d6e5befdf2c499d3702cec00dafe0f86f47f08d8391760d236d042d46b56e7ceb8a59424535db825a618f60c9e2e04f3ac92a5844648428b4547cee96e690cebe3d7e08ac638e8f5fa0f0865daba1ecd2804ec4ff55446586ac6447d6e4e9f77bd70aeb95c054cb9eeedeed9d9d42b1967714e6ccc24415a911eac091fb78e36366e1f8dd36688f76c981c5073b576e5849625ebd41dff69c071514fa49c4d236f4ec096b0c2b24ab2ae26d2f19332cc99bc1a00428f873a67972a192298bfdd5c8a85e5df8a72f403d57da974fb49fb2257d09aad9a6aa6c6fa06a4a6f8d990deb7c26eed8708430974749e6f9c34b0cdd581e366d29f2ee51160c611d4bb1e4b67f8df023f02f8ec72b27ed0f09768b31723bc5e53e384047ec52eb370a8b2a51c7ac441e491a2ac25a16caa384a2a555cff9bc756d063294708a5b15de39e1da689d3d9f59c16c81f9cf47ffa760c8b1b6ee55a6adee7442821919bfd96b7a088d08fcc780edd132f0d801650aa3b7e0482c71da89732a171589d39d0867074a6bb31f7c60566ec405b1113a37aa66d0c92152245a5792c20c9f7ed1ba4919e36f746612ca4fbb7d2664caba13636b256dfcd452351022971b38bc40fbed7bbf3acc1902424ea696378784452f054f2df9b5b46594bf760ce913c40e6af1412122f3fd5d10f3befd18cf7e7381ab4e70d4ce1d2fe92c544c73f46dc7d378adb99bf1d364fe5efa790ae258416eedc5b01256aeb8dbca79a4d09626884bd430ff7cfcdd529ff720f8fcb5dfb03024910f16328736f7a8ecbdb90ea7b8621cfe3a3157e6b91773673a574087d0b508f82995894e8b8e96b1d1c7081d2dce7f6f87b6a24458c6d031214a8d95bbaff54971b532ae8bce6543390f74d7220a17ddfcb64c16949a6322917622d11e9e2b4a3014cc4069370f74b2875daf1f8aeedfca2cdf212ada45469a7080de445f2b442165d6c9deec067e5046cba95dbffd6d5ac03720957ac514b819ce2a65f5eaeeced1f33ea8019a2402ebadca5005cb398138bd978189f0458d7bd1c932c56fd0d65a1e18e5cced7fc2fb9d71eaae20949f2bd1b333ec650bc8e16bfa55b42f96c1c9ca7787107c9014cd203426031cafeb090cfcf538119636560cf5fe6bae0729262408c7c0f9d0c75c7e1cce70899b53970234c45f4462fbcaef1432ef2afbc105f24a27749d048ac632ede05f0fccbdee6aac0cc599f8bdc41596baccb141b3ede88a8c85d958c2e6a28a3e3e1139ea2274034a6d97b905a214c87d7e0f7d3740a8e5e1439aadf1b2b6c1d2220a33c552282adf25b1db52acf6e5574a1d1521a9fd0170156366b130a545c92bfda1771b2f3e821b048db7083d9fee1b3b0cf608c3ec78ee3a0e319aab74d5e142fd0f1dc41a23a7d62339941e710326ece9702fef9336b9da9ebd05ed2dc357f3c9129cee27ee824e2242577615a66c1d11ddcfeaaa2c57952ecfda85fa94e57cb3637646493fcac0fe66f24d16f2ffde4b79e20935451ab4b0c55e6e86325424f71530902b0815f83cffc65226a11ecd9f219a9aa274974f0b106413a862cd2b7bc607948c9f8e633aa4267431c38c0fa111eb7f1aba3c983f16e5cf78b9d4a393c2ee9ef61caf73129a0b671da8809cbfa61684fe7134c2ee3058ac55b4501d649e7a14e84a8c8f209bc7d1dc88f909096427946ffa73e71424f2d6fc33943c6bf61c96ac5fd67e23c22defb6091373cd65913bac7c57e17239e8263d53c397863e84aca3aa00677d8bccb0bcde2233dd8df41a357cd1ae4efddaa4673f53a878122dc2b4b6ec3ff5253ad0e60890cfaa82f0fc27d3656d654973cda2e8ef7b178345aea0e53e001ef67c44fe07126d54e73bb2d2e4b4991a857e1729d595b5cc3a01a4045ef5e9d2451ce11dcc7184578f1e504f87af97ad22abc0dc5d466fa15b0577956f082a6b037b6fe0d05408cfc008a33c3a4402a7a3531baa1413811b7bcaae868a1b00c305e6b544268aee6b3d861c45a50ffe0ef7deadda6f8a4d4ca4e1d7ded8c8b01156d27967fabb417803beca39453c7a00985f7499b5dab3e668af3851db3dae070ad9a9c2753e324a55d06d18a95def3661dc9f9dfe2e18482b4849da84ac5e8a5779a6b1a5107517e6e1db9505e8403be24e146f798ec0acb3b1c75c965eea1ace7be19bd5b84d5227029584acc9c8d005776ad90c688262fa3c83a1224fd5b99149dd8f32b7c27c35f1e46cd5743b7067348f2ea913b71efa107d7b2581ea510b8c8cff49cc794b8b06fa8081104218af3a2bbfec9cbde23f07896b0b3ffb5e8e516729aa93a976c3cc6daed41876aae52426470f9d55be9d277dc9438c6908dff14d9271aa2619f5f743276a8f8cc3e4065e1370142a806859d94a8703b7f54857ecc9d24944b98ad53cb77cb34c1cad2659599f1648b016f46b787f513be36cbcda810e35d3a20f9a2b4fcd5e860f9a2f62ea4cbfb470f6dabbf7ca2fafc8e694b91fc852b5c03ab8252f0205c95acb5d22f63b153cf7b468fe63a9bbda7c8d60604833d044b7f883f453f7c7956a5c93aee3e51d7c30425640deb5e41e19095cbd0949560f4ef8bf64da17a0c8d946a8b62ae7cd8087f6456e4b6492d7ed672386d39b855bdbf6298b47ab4b890af0a6147a410d312e6d4faa4cc3660ea8ebdc932d3f8a27f77930cc3244f4cec3a0ef7b22792d1b0bd602dd386704105172426f2cd39bf7e40f4aabdbd02a99c357f55a91eae2ec3c6b2e592339babb26351c00ba8837272deabcee1533ce42c29ec2843197cc0f0fa2a82464030c98b3ca491268285d0fc2c74b421df4e434975396c42a37591972efced610ab4a056783ae96914f830d7f96226453ef3f73de5c599d72174992e225ae2abb4b19a719f886cd940b1177179f2142dce0eb294b2685af20e9771d1ccda65be19dd8c68493e9a2c56c3ed577641543eaf8d1ee048bb10044cc80f722aeab07d6581eb426aadff090d2bda87f4f9af9077c187b3ce9c741cb2ef7a6d285c6ddae165133a796ddb4f05f0ea38984cc3581beb74ba310cc920280b71d9ba4c324b2e61c5dd0eeaacfaa60db17d69a75cbf43bb02aa237868a0a2529fd8522b0fccd89b9ecdd9f9324a432b6f3b7c92760004fd2cb31231ed8ebbdf3f3ed09e79df33a1f3b9525e09ef5b22a2dbfb3c0ea2953e0c27faa5bc2f88806cbcd5a54bccfb57a1689b74050d4c8eecf37f536c4db28239658144a79a70a299cb9360416b6cdc7baddbd454b6422144d92fd34fd2148245d929d43d86ab3eaeb7eb2c353b5014d68f3d819b689cd8315d445952f01777633cd0b2f34c8fa65597ec31ed093c1a3902deaf53c1e26aefaada196d7c0547ff8a7b4028323f45f7497fc7f13e48fe27aa0e92704674545e0081873d1c4b31a2f06511a06178bcda62c7fc021a3f50f689cf9e46d7984952313137681f1d8c95c8dffd2e51df70b57bdaef07ce2da41458f0b77807940153c2ec28699d36eb8b4f97639ba6c2c83a917e85837153d0949efbb4c7385d0b1dab3eb55038f7c58333afa3c60ecbc13e51ff2e3de8542af0c730db3b6c35866e0a56515a439aa8f1a6f9a03f23b47bcc36bf7b3a1df9775cfa51449dc9907913889993ea9edaee89d5d6b88ef0139c22b4e9a46f1d64a3c425241a6cf9e79469f7666eda5cb2007a03438dfec2831df9e463935141e701becc6963a305005e1a03409ab4bc0f5b1849cbcab2c65651d9bf730f7c29b241be332328fd2ac160c2c61b9f22814493836b64c8e38884552f339c63054ad97efb6319b3de8a033a4cf57d5a59c0a6866eecf6ccfcb068f01483e2d3453945f48df73b5b95c1ed371bb0d3aadea6f08e9f21105cf870e73bbf4f1adf18b74ca5b50242eb8c761c581826a3d3b8875eafa77e65c0ae90ad7108ace1c1087d072cb5235ac9402a2ebd4e225ead0469c20d7adf45a9897f1813fa0500a7fcfc55bda89a864b03253c50683a0eaedfbfcf1a4722869c603cc05af71b23ec88d4871d553c76dc00ac4f5923003d70d978f9e3e5cdd79363b6821f845e0656dc7721733b77561a919e5ba173dde5f72c9403cfb04429e40892a1338f389f781072994aa4e3f7c32322e0547aadb33e9baba563f4498ac545474a1ea33d41c917d2da82cac28f09dcfd7f3c5fd1e6e62b660f81a8352b7ae9824457ab4de1246c63d100f8f22ef150960a941f00019e1cd5d9024a2d636abb1dfc3ab539cf3fb070da3cbc27352155b242d884d68cca01156a2361e9a3097418338049481605aa505b7130348948116037c63d7c679e31e7de05e045aed1541c55b2681c06cb76ae1dfa15fbc6961bc1f2358ceb77c46a4e26a69671c5185ab28286d66c17707aa5cd49c46995032c616c81e602684e14e9b075d746ce54655feb6ebae9d29efda26e2dd1e1de256c0dda2ea8e8a65dc1a6f57e371c5f58f3c97f9041cc8bb2cd13f5b9da8531ae02e12822f508a3418d501665ab6535357994c9d04df22c28ede24a5ee77cf5f3dc5941e974e4dd6bf9861e3547092838d71ec481af493bce417ee65bb175995f4a0c165a8da3e7d6c84326abb7478cd528c5fe02c21dee5a63874c51a849b9f3dcb292e8f2d6111d31e37e172be9019b00de7ee111494d0f7598f8d993155ad29e9bbf81e4f06cfeb972377af2305b213f5f0f9e09dd3e2a7cc1af229058e98b9f253dac23a187593fddd46893c17b22cb8f6f6634fd8dfd29a2292566baba66f24d0a2442d906eb8c10c0cbbdcd828c98355c3e6dcffc8bc619a4b7da7e62afb5d50cfcd7b796269b6b168f02f0ed37d77e6da0ecaea483a0361183198733f04f308187cd9f1401e7060d5f6a18e37701d35604179b1b331f115d90f6977e56f9b554126da7b98b87b131882b8663cda717b6a8a7e460141e15a862baad864b1ab829ecfab49499c5c99deb19bd708435957de789949364f20f97ae5c5c23790d988dfeb77b42066bf1b2f00d8c02200cc6753a62a9c74449220484361b0c10a5a5b9c6ef4be249bcd75c8897c72682cb7d29020775f9d66608aa04e32356f1193c879c259855bf9a0b2cbed1167c3da79036a21871b060938c4fbec61f13807b396957488f52e0b8ab5a47f22f083454b33db01d8df189138b90dd8837323181bed1189c47f19208bbbf16309eb34ce52ad5063afc1a58b17784a2d3b4495815e4ae241cebe1661b34346e7e59010039df019afff0947e9a091de13a0f5f8f25b9c46f38533a57033a20748839095e3c600ccad8af0210207caea54855aedbacbdb36e89e7f933a227716c84b7428dddea6b9dddeb423d3295b39ebc2bc892fad6a638a40a01a67834ba88b7a07e1aae3450d397132d2ef7f2b566e91c4fe32ebf877d82ade9c6f89c791d2ca85a7436c0b62ab6a5bd0a42294145cdf480517f73f86c3ed80b3ae580c86ec754e7185ae08dbdb71ec2ada95e2a164acc00fda6562c5b83eeda0ae37303978786f97cc678842a1457c7097707935e6bf25e0691016286dba2ef547ce44011847d1fb67943a6745f4427c4a95f595c4d9f438faa2ecaf51bc412847845f7741f647198e4a5bf5d67992eac9d536c489f43a4db4357f76acf1a65345772d37830f443892dec58114320439d2d6eb82c153561c969198a3bcc1ed19276010c48d916de761362d92fd304a6229e47925c56a0d82b6b0aaf2d21a3dae056d0b78bd6e43c5db6407ce9bc56b3f512410fa81ba6592201998c5922a8edeae2492c5074b58f60c3a1cb8aa2921a0428d39966ae7b970fad2e80e6d44d70eddba12a1e6512506248c6da391e39fb1c6f97762af3a4d30c7b48ead0c6a3e00445dcb54ab1e42e796e8814adad6173c2a4939cfc2b6dbb9e54185de51802a3df71a47ad0548cb2c8edac58f04c380e502033880061ff48bafb350d8a7c51643aa8ef47e58ca90a461d9251599e38d398bb4bf21207d2199bf9106be1405795cb466b8e9bdc3628b5331b154831dcbbd98a3da78e338cd3270aa24cbce2a85125bac3b76b56048aa400c2d7a347d51e2d0fe38cbf4a42bc0134cd616601e6627bfc15a7789faebded37fa5b2fab284a34e6982016606a72b566446b0f878c5077a152b3188b7e9b0d2a310eb50c1ce2ea5bba8657ac3a7b1fbd95f4c44b3ddcce96d7ec3a34285b85958210d4c376602292b8b52ef4f28e59b5c9866fff47eb6155958904892cb3ae713bd0bcb8794c785595a0f665b183723ca6bea85e51413cedd7ffcab96942e95f29a5522e0d43673be5a96993ea9770f52b080c0b3a03bbfacd4ffcf9e031640ff60f60942fb9f1db7ea2ff54a179bf840c0fc9f54991f8c8f390f2c1bf2734bbfc29563bb88f4d1c5ee7dbd47707e7e74460418b5cde262f644369fc22de085892a7d84a5e239f6befd5a8925b0e726a35c139b27d1dfb5d1ccab68fe9b1e7a8cc0dfe6bdc7897114dcf5ccabffa35e5bed93cf4ecf755649836505da97169c97acc3115eb7f1afcb96725eb5133692ca23fb074516c478a38d5b0a101594f01ad8a548628907038911b852d932c1d4c1345a978a9affb563a0f88a5c150cb5a797c6359df80224d753604cccc0f34c988caeba0f58cf3678986b80979ec5b827c041fedcf1a5849c0ce892e8005e997497c83be818309fe0a6d6e967337e3772ac0807a5a150cbc852b9628fb679ca5975405316f78998b22f85b74b7d874bc070a5b8db98cab8664fd1f90e1a52db809d6a480a6adec5a930a9815f16959b6995e7be921a52f9cacbafc1dca4a7616d887ef24b173a7e478ed9bf4f79296623b956a332f81e72b180e46711a6e5de8f9c36941722fbead66175cf1460db681871e1652fc9be3075108a2bd8369865cb6f17c25db6ee98baa6408bc96fd86ece3eb5b5e65c7875590197bf7b468bf0e61495ffbbf0811f3f893ada6021812ca1a358190826e26bd49c5520326d4892f5f2f5a2d8d832690531ba0c11689ac366a73977b158bec58e1bea3bcc40db1be9ea24bf6b2a34201e2fdd3d0a2e9b6ce2dce844acce36a8ece88528d92d276d48775430153cc18476fb1e9a08783a45a453691ef2018ad8dd57dd62eb36947ced756ba650b49ec626c245ab316f35bc55cf84af8cf0585ddb218e744eb59e4bdbdade1c349679daaee136f191eada98687603f5b9e2ffd34a91a1d59a8ebc714d19cbafff9ab06b889ef7a1f58fd797c89c7662dbb8729dcb96168baf45d6ba78dd725e48e229f65aaeea4420502b7794ee9e0a4dc8092c55aa74f8cc950c0243936ca1c59dccddd4cb4722a1159817d176fa3e3792e2af689f0b60385ee8ef20a0bbc5ff431fa15387caa335c475926b9b491afe6870d630d5fe1c71b2ec894efd6688a67b9343a8906240d3890f0c78eb3b6f1353a8cd8d4d1b42c0342889f656dfe593b9b05bacd414a3a196564f1b3424cf850dfa82be1e4e8b72a50be21c32d8849eaa69f0a264106bcc562a15a8ad6de029d287437296b4be76e177beaef996a5ac62f4d562392eadcdc716fede758e69fe011e7406618ff28b6fb3b6264b36e725936fe6ee46806d878846c9a116d53ec64e02f59baf56e68fe8036775c271657b39f0c893a543b380880ad4724b945feec9389a674edd09a4124d8b1688127b747f95b08a0a0c1dad3bc92b10506594e21b814cd3bf085dabf235e594daed70bb8ed56544417d9c6d9dd8bea0b3d6a26da991d6c39664b87108d5594d718575dd15954a2506473d52ef67778af7133077e19b82fcd6822181bb5fb56778e238881b647db6b17584a3c85d26691f83ec571e65c99113f87045f68fad1e462b41249cb479a54bae1bb74ad3db08206c8400a810dfea72c2ae8b0adb8e851846ae67cb82a8297a18487330cb16c0c6bf3df2451933f5e9e109577015f9d67a32116b0302c61135a2705f7e2a76be9917be829d2645f4499cd950c83abed0da4c83276f9773b249ebfd672af6896f5e9fcbc8112efc8503d6bb418f7f62a196e001798b29d209bf47204f16e9dd29ad0c08283e4b4a85591710c9b45644693467815afc4b0ddccfa1afe030771f85c79ec4d7705532004f10fd1f72018c3fb6b598418514dd0b98d801886c6905bcccc4b800dfa7b0c72030f5fbb92cfd6e15a8df14900a675a5e82f6b4ba5d365e54c293bf32d2f993b39f54b0d00ad1b21624cdf6ef13a3132005160cdccf286fc5a933ffcc32455b5eeb5bb861b722ee647735d92b128eae65f43df13aa71b0523bb6fcc59fe9b1329ed8d805079244495f738db9434e1fbd6e24f18e3ec04c50e5a72d9624dda4d5a785fae2c3c77fe8b4fbd460b2d33c0af8ef905aa15b8bfb9202693f1b90b37b38f0f1fe0940a558343a813274c38190ed8120e9e9b882d8c278d3e5971735135bfe307c778f7be0cecf5954bd95752bb78d19a132ca96b22b39a588b9d21ded21460d2cc6df5e8e8516126eb6a71b1a1d13c426d31dffbabc675d1832625b76820187dd6989fb7d4b3621a70beda1e3adf18d89f66063443aae1228b216f45ad9018472c7c52fe0fc26dd599138db2c9936a2d1ad01ee890a3f51826f5eeed275af0d0c628ecbf205837f770607fd1c567b7d0bf3cf021d17e1c34f0a36ddf85d5fa05d04b9cfa0415b89621b42aeeb686eba327c86841ff00b001bea31eeda184da8e2bcb709f4992b90fc20c694450df5405eca994c27cf8c4ff6cf996e63514d0cb97c54829bc7ac811ee07ded5ef36443f3e238e1ebf42f01b93ab3ae7adb8141feb25dcd024f5bb88f36a8dd0442df85a43fc96c8e9f3160f141c2c02c56c7879f567188cfba680e73446b882a76b228bb6cda9e667383999a7b267e05d5d7febe9920229b01ad37d91821f4f5010a4d24adffc627962c999bf22a5fff543e75d8d4f25368ed57c35c00b01057da5aa65480186b6c8c2803780fffa7922ef2a379ded57a8889639af775557e490851fd73897eaae3fa36c9763bd33718e7ac3369753de779755479193ed5b853883bffb2db057f2b42658c5cc10d7d5714fcd88e83d01afede4a9cf8e5a035a71bd936ff5ccfc1c28afcc38cee4f573769bf655c1a07e194c0468eec7050df954d1d1d8d73e15525d75d4d9d1c7064534debefcd84c154d7e782735dec035edb7b2dde3d0d3888382001d8209189a840993bf0b1c6db32884f85d496fde9d08a1d85b4df6f524bcba72c52507c4f5c5d5c4f12cc88b6efe69b70a22f627c81d70d1965248af0822d7b7d1c5b08d4b2b68f7ac3db94c39d0d8f0140eb6142dec51e82df4e8b7048294b2f2b2f2064259cdbb13f78ff02297d193c42c98b90b9e19a0303b51e2d8c4f38c6515b45725889de52b6fa5554360f052d81175b88f1a23c73792be0bdc80bc4f7f7a315efe8204243449fdfa2593a308e51a608808920be8c03035169ee00f785b95a986a816950d9a8e2c4a05bc26ff872c2d325fcf968de1cd09e4994e59c3a6055a1a3c0de8aa2e876c0c3dbae2205e1c30b6499219657d487288b926b2ea6eff6c6cf2e46dd8549acc00870c2de43822f68cc43a4a27c33e7c8f9981602193166b0097ca2eaea28fdafbdc860ff5d8bee80c51f31c2e3e44f099aea5209762e772ae10bc0fc26e4bc4091958e763c5e8ca0745184745d12d10c30de0f9521ca68711679bfb6908d3194cbf3c6194db57a7f064036e04fbbd9704feb18f6b01887b5187e01b8e02950ca58ba48fc0fe447cfae5e2c3c52601c9e2e1ab2bb335b7c1a7edf5bcc78f3fd869c4acd6816af6a31fb1a0be3ec1558aa33d08d4dbc0a190d9f870c863dd3a62afbea14ebf3f63795a275bccf011eda2077c1b209bf7c713f8f83784159778746a9a07f53b28504c6cda93973eda7a27819360bd6deaf1cbffb5eea3ce993f5ba9c05ce13a8140c13c18ecd4b95b69b2f220ab19b360d8b6a1c004a721b62bfdbe16ccf83c4d68bf78cfc9d6d96aa745e9ccee231f8dba7dba54941659afaf022ddaf7136fdc4595ebaeb3020ac10de67c934894420d3d2e78710b3a10ce6adc2289397d43fd622d24b4ff6aa84d0f1e942c079b9972c0032eebb80fab4ddf11c62ac231325e918745ed7601aa0529e04b1abff239b9657fe6cf9a2a5f79bc55f496d89d986ea9f7061aba268884e19ffe573e8625caed4283e3ec6d6b92c4e7dd1b76dd897026433e2ad971484c28cbc68bb6a6484350caec9365b94fb8b7a3168d30c9f3a02dc84dd3c40786894c242b08963d02636f056dd4b4e49bca73954ff1c54f67681e8123beccc13051cbf159a0f0019f2214945510f8b2ee031ad0185ada0330e830570e251ed83a9019d7eef2d2a7a889563baeb178dc2d2799e5f24fd18042c464fbe282d206bf251022e1a0cd8e5acff863d388b74d62c806577855f7871ba3aef0e014c1377d979b57f05ade2adde8caccf123178f47d185363b53a956a9c559dd77fe4a4e9582fe817358afcf7f08736a8b953af20910048cf4bee6fca4f5e374084f33c6fa3141facb994cbb9469f4d7cfc71d3053339fdf4d6b68efef06c8e10f69c3e04a6edbef18e9d021cccb4fe8d4e142a9b4c4fb24532b0bc8d05ee71bbdc67573644848a6bcf1a11e52d8ceab34562721b0aabdb2226d84e8be79c6a9d42187abc6df4b24414cf2574f3cd8fde6bbc64c9fa36379d2fc4a9b2750dd2b400014ebe9b641d420a60377bedea53b9823955fcaad52e44262fc3588bc015a184a5f6d6359b7becb356ffc8cb8f5aabfd6e242c41e6f78a8ecb3c69349f4cb80a98fb7874c6112a3a6778b08403b55ab2c3d1f6a0ea60bf1cc8fe046eefa7dfa481370cac62ab83154c335322cdc3e1eb29b11a4f0056c387661f4f354082c0cd97bba3ced5e326d8b0fb3956eb55e76d3bbe787090015146539d51453faa49d70da85de53d63c492a3921406384dd74298ee860ac1e1b25ed9564ebb1ed4b9b3c7fa2e60078843388d245b647049e31b8ee05827831209baea7043c5a4be667509fa09578e0a95cdf20c26f9f4ed621be644836112f916161ee9d7a84c37be0bdfb46c2ccde2bc6c38a402987cb24d3d2317406ccb5534e58eccf6707f6a05903a651b6048586cb2d31e5a25b08d221ca0eeb5ad4a6b3e3895300b058411e9da27856b11b1ca0bb9683f2cc6d9975d9cce224a1e1febd02793ad88711f126772df2fabcbfdc903d8130ea4e1bee6f4b22aeaa1cd5612dd2cdd464db22c15f8861ba547266c4b51cc59ecbf7778a23407613ab79bc654a936bdc7f2672c19ab0aa793927565a218600edd1221e4879d8f4ddc399e55c73867e87ff7f47f736ce3f377447991fd5db75c5b4c1daf9846641e8c084ce786b291ae112d03c047230c71c7f0c99bfc2eeb26cd8e3e180d1876566b847f7de463c9c5d02233abaa5e4e85edada446898c8e04ccbfe5fcd4a6d4604ca0a4dbba518354af6a47e23f58692b1a58df3e0ba22ae1759ff52165d99ba2550955fb83e8dc43b08fedfe1ca7a5c4ccc5c842f1e590031fd70ea61d0b8205a7edfd9a6aaf7ef34dfd06396a3a9085761d079e40532bfdfbafd367e7d43285f3e4d620e558ee3821ca74cc8c32389c18d13c3a2a06dda9a5de16cebfd79ff6708a8014c3cca527d06b326cd19dc504237eec814b28aacc31acecf4f1af2032e8b82df0342aba907af0ec3392bd08f1c7670cdc29e745731cd98d2ea0467cf7d2fba1afa622863f22b54c12e37500ad6f7331759483062a7560768f05c43441fbea1f8992d28b3b3fc71e44c224d0853bb5b371ac91303527c5ccfe721c01de0d30e900367481f4d61b81f2697f1defa9ad25cd6c374b13c675956b2088469b349194a6441ddced35ca2b829a966dd9ab37255e302496372c6f10f7972b34b7b2b7381afaa69dd019f2955559bb724e9f6cdc6d6e7fb68f310dd0125b53af4b518f9e922d1a5d36707a1cb93c1cb8173af621fed4baac7d66ee7c22630a1e3d0ba7081d867e97c63d8f7dac4b0d2bf0c5dbebbd602ad1ed6f53de62cf8977454078b9bd6c8178e7a7ac3c89abe80a0d2c4c976c590bf5488fabdfafc464f5cda775d72a21aa8928871d1c176539eeed14fd71ce6e780bd359dd12c4a2b595253375eaa92dced1d69922ba4fa7c73dcaf3b01aa7e4ae528a04d9b5a2d319ac52e2549362f4ca6c732f1433c316f57dd14e3b62f49e4cbb4ba894d29120d49ce819dacaedb6ee7edb578b8d93ff4d19e9e72a8c48e2629de741e8640b3aee38d86a408e7f23d1961c247d46ea7bd3dec7f3aea5dae127e9b5f78ddebee6a1d93a3f3c28c728e9ca6ee5cf1718f1146453269b7d0bc71d59268db30d56c22e8aab0446183e0333c8fbd9c3cb17023fd8ec287dae8b0d86c452a395f95d8f19d97412b5fc82580adcfba47634cf580f03b87e3c8a16834ac74f9ba536ab39ae3eaf006e293fd321fc3875a9e2a4dd129994e7310c17ef30a0a8277de1bc9726a0d0cfe9750549229f0637d32e9c87b972367d5b4d922bdbaec64e28057be9c54ddab1473c4906482e39c46e7d65a497d1cfe16ea70efd87d9bedb0100b16c3ca688f1f5ad99412670a01690c39db082bc5215a1b7e92103a83a2b57ca832839d2588d1978134e2d9aea0577199e82469367b8f926b79dda60a71c11e6a6967167bcb81517dc92f4b53d2a8581fc0c507dc9e0f20b073f66cc15cb6adbbc8567628ebad355bb5f2f1a7a477444ae943894ed77b6d03340796917eba451e88df16a248135e66c3ce9ca7bb1cb6b6d6a6c0ab1b94307b30081b8bff1f4bf05fc650536d04a9687499627eebec05393568bf6b61ec73a824c4695d77bcdabe9ba94a935eb622d0af14d354d8d8238ea3b28e55706c521989e2303b29e808b3e490c6c213df1db7000fb030977adb9e5667dc3ea0a69df485eb3989d144e5af9a0f7890ea35cf4e16d40550f6f4071433da177a2988e5b4eb6962b64ebccdc5c8e54248027dfafaab8c3175bd83a4e4b43bbb1537b83e561db4c333775c4ba4419c86e2336a559174711d025a0c637e9f7ba3d6fa03d4eaad299d80de1ec7078df7de02935ff417725ef30a812002b4359b9e302a19477578a30f3bf30ea856aec6a35da93e0533c3c43dc7e8b46c21cf0e510760e751d023bc7b3c32f3ee17adf6f6dc6e10adf280645293a2b66142631f528b494fb6e897663c8526f8b66d11f4d574c73b128625d56122bf2625e27b54d706589e8d779cad611876af31d0eca9bb01a4f36fef6260b62228277b00d8de9b4599d3c61ef168ad942285dbc586953fd2b45b05b315bff74cf69c833e47e378a99c5e41d5f19023a678490268403c7e892bf041a678cfc68094c760b3108ea24a16a7f0a4d2e4a4d9e8d70e6abadfbb91b03c6ec08f6170cb08af9154ffe1e04d40e27ca80f402ab68646d1781f28d8d0bacbb5743ec2985fbfda8fb985b5ef6d4024a8880cccb2d41efcd47154ec25bbc728cb9c89df446186789c7a92225194473d3d28873b6ab9bdf974b62f32d44c51093c4b8277ed95cba6860059d341ab2a06c59264e79cfe0a9e9de0e6e19b52aef1064183c8048602041dc6a70d3f04c08a6b32492ce308d4a9a44c3dcf74cd4856231443a888c0abf04d37e93f5698cfc0f55dcadc62ee1ceead614bd787950ff13872164e8c90031f66c65c079bffb518cc3aa9073ac21c0d8fd1165ed9aaffccc200e743f17bbe8f68362db21a371b5794d3e9057d39596f0659774a59ab21dcae0b79c794d044cc4b4454f44e02e4fb66dca613f71538f09bdd9b6c17cc62a8f95275282a8c25bde49f13f2f1b6cec08202b33f0712331e4f77122563192f21bae3b74d0a966bb21b1f9376c82636bc9b8c98cd1d587803ac9950f7029c75935195cf01fc48cf8b8583f42c6f2abcc8189812a10db9a0e8366ed97683fee6c5ad1560f498e940c83b5a872720f5f9aed7a0801698ad357f6d0cfd6744ca9fae4b45d23adfd5714c53128058c1b58e656a55e0e1f3edf9ff5efcf768fdedae953320764dbd348b2d29ed91a18b5d57a574e65755beeccb091f21e46adaefe5cf032507818e2e71cf62a4c3f455eed26600d41d33f0f8c8ce061ec3e5dd6824e9a5b862365745c20a2398d990ad7c5b46e4ce047f37d43c9a7cefbda1abfb82734fd8dbeedbaaea68033a25cad7f1dd369033abaeef156d157c029c97fe251fd4c83c26392a8dc11f0739f6dfd522b4d463ff719b52b5c2103934a05ec294dcbc8e4ac197b792a47a6e756e84dd2d38bb16a8727726eb456768d5dc380c7beb7c2c048400e756c3f2ccada569d4af4833343cea38ad574a6d7dc037d1e9a0830a46a1b1dd7ad61c5c7281955508a9820d8d8e6706627d7b7a7068eeb49921ab67bbb9e6ce83d0d7bff763e28603ceb67b22f01581602f5ca795478aae8a6ce354139ab1573d802405123cd7c6589495ef78b933c240ddce7357b02a538a4a5e8cb7b68700f228aa9439f594dfe79f4ccff0fd64e1691b0309e0a0da9e7dbd13b832edc988d4f70cde23acc44119d59947becb2db8f6bfd41107c09b450f9dcd7492fe961b8165ad9abe0aea7e96386325b12af48f607ca23c5ce52bd9b3b04344dbbdb8cb701083374dc394c39ddfde2af57583c63c3f9c15866ff23b919ae08aca61c949abb18ecc4a551d9a745183397f13000d112169ed11aa772b0eb84cfd374c3b54da50e146d13ace27f36073394151e98d0e562a1429ab88e166778bc626f679b2aa48eaccb4437365f88321d56bf33dfc3122725785927dd876fa0308e5fdae20756796ff6992b78f29e7be8711bfcbe7b4cee337eb42253527b66d9841d4c646183f19954c908690cb00af864f0b5c6690066ee898b71e3c82d0dea4cbf4a68dcc3ba21b8cd19db12df377cf6426ae312ed28608fdcaecc37e549e4ecadb547f0592f6ceb0f8abf4d91041073d6d93c0c4beac3fd86696e8acbf614da8af73e285a7a17855c29b1024036c8cc7329bd389e62b64a0e883845dff84b14d8f416aff3406aff62d29d77b7471a30850ba0c4fd807acb3f8dc930e2c1988ad3cba2c89d05e8c47d826831f42b1b1153f4eab4622920056fb32bdfcd6a87956f012948f7f12bd8daadf003b501719f2bec13ee6cd67f09f74f4237a70321fdbf8ee303455899a15ca61e7359636504d29c9e284c8aa99a892d320646109460788de9efe6ef19a9a7ddbbc816304057a1f0731f8ab44f41378cb768b03d3331b2ade6a2ff7ac53fb8c798deac11d7e6381d6fdc36b6336ef9bdfcb6070b319efebee716793d6641788e420606f47895a993c0fabfe81901f868cc4ef002cd6da10f388979e28b9159bd12ffcefee258d1b92478cf0bacb5d8cc71956463c1c65cc25632b11ecb281fce59f9b3596b9fe6a15e1fd011ab445d9334c8d73f74139f3e6abeb3a138cd254ccb6cf24c2ebcf0cb8b102ff8ebfe064a650a0ab8b0261c4ec6bd8786cd254633f82b5794a3122191945bf762ca290a6f9a16a54ea17be63a55771affa5eccd6674e0cd52b7da12649e37c2e1d63197b9923142039be23be86239bdb55f58d5edeef9dc77447bd456b66ab766d71ce826cab1fe7a1dc5ba671d67bcb2bf98be2a5b786fe7b0d26848a652ddf60a28bb18e7979dca99f392230f15aea35a70f97e78ba32121eb1ad6738a6a97afa37e2f4e22dccad3443feef3a0a1cc2b1e4b71fdb10874455aa4c6d5a8c75c32fd0f15ab24dc75133c60703589aac8d9c72980ea2b9b5be370321d28f51d40ff862e2b5fe81f403c2425508ac0cad5aa95a0518f60f5fbbad8570579e8cde4babe6c2472cf52f3db33fd922f6a22df5c3f7ada5dc979a2e161843733816ef6cfba19e139afd359d7e8264aa57e54620a5a3a66220d1fae8f02b9195f322d3ea452e9ff6edcd56091956b1bf07ecdf7a4f15f7cdb2840ea3a1883767357b3ea9ec900979cbc746edf09c7f6d62cbf54113b7874233909d2e77f14b51ab0b5f2bb203d420355a935df61cf0851229e4da3e5511e39aecffcb832906010102abc59786892e02ab9d876bf366f79cc0ce6c2756181bd155e54bbad38dec658a1670ae0c13c61b0beba2ed55b3859ac0346a2a6fce0f1be4ef17c358e97e5357e3423c4bef8d177742fc9bd2ba6d982acd5a957e2bf11a8fc23d6721ea1853929b55240f028227bb10366541a447958b27b7482f60b9b37ae5e2fe6b7e94cbb6ccb5ad1927b3c345db1a53469006001e87f61f08dd74b02f69824f0317e24aca9f52e28ca597dbc6ed4801ae9bc637bcd7434b05ac647f2aeaadc7012f8faa7a9dbc4172413d14cd3647553e618382dab91a525fa065f1ea50ef1706d4b6f1fbfdafd72007e7543a0e7a2ff134b42afd87504164063980aec79880c6ca56b718cbe987f3140a9a55300093111f43e660a85c0e82d3057bdda695246f64e9b6c7996bf1ed50f02b21399acc4425706555c50e91e85a60cce271e8e09e9b3bcbf51dc71e0905ca2951b061562991e4ebee00340041711bed5c26ed04a8f2183581117eeb90d9f2b1fec4d3f051af938697f0c0896de1c7ac12f787fa1a9e3d0758791995f0a9d07a744b8b635967e591c84461ec8212c19700734d49e1b2e4167df0d1ab5fb1286b2e8862ed498e4a2c16270ce3be313ed457b05a502df439e284870c9903eb403cd06160479ba5053a428325a904046b5180060898d4533ce4993d63117a32753e4ea243c93facc48ffe2e46af50d43642d2072ee0b6c520bec0c54e1f17e9468de57fd058decb57a66406189f5e0ff3c4981a24a330c9849d2f7c4307475161657acf6e5e17c8add5b6b014a093bb384c0cde8777ef1c385f6e79cea604538946a94d415fabfea7e7256c5272d2005e08f98e394fd736f5055a6ec75ed6cd94e09d900dc91635148b0064554a49def5b7a941b81b63f236141a915119d35f0fcbeab669767a904a0cb1b5598011d8b575ab5b11c4959a85fa78fe96c3b3cdeb29aebf9df8a14e9d5ec77c96679181d483260e375e17f024283cffbeb2057bfd50f0d645c120ac96c0de252d892f91aa12bb2bf3e9f4abed038ad1782142a652996feaf8769a1636c4b5608edb1188e0df632fc1f7828b837031db6380675bfda6629826e9c4f3836a16d7eb81d6a9013b8b0429dd37af32b9c26296367a8f2df6f83e09f0ed60c3250171a4086d4b526c3808da5c53f72fdda2e6e7470fb673bab89c9651d6fa5395c5413c9213e1cd774a914de19f1fe9ef695d5fccc3b55e265ee55be35b0ed209bb1a4303ffab069f8a9418bb2ccda9d977ec551e251c39521c7cbf3200ab0284ce413fe9bc1da423c3b680c0003b10342709e0e6b677c4b17abe2341768668da748cd80ac2b63b25ce2be6df0472c5cc937a38ded29af2a3482fcd1c07fc5ecee5f400dfb617ee64a41d3c214d3b55d9ae5155624f184a5cf372e2b10f0cf1f450ec394d3a08e1a5c1370c5b1370e1a414cb7c5b8d21ba1ad80683d1082698af748465bb4aa79269f645b93b69df842fe889ec423b4bad0d44bb98d9a6a7736efb6758afd572d18372373ec9d96f63b01bee89fa1e5e1b7f3dcf76c88fbeb60462b1a09817c8c11029a1f268e973e87e47b137c8be633feb6d0ee4e93ac63ad8ae8c7bc6e57bcd040e8f161510ae8048f1c6d59f2e50a6a4b258bd1a5d58561fd69c7afa87fbfb9fc18434fb5567498b0fb8ad01f90670b7b190036ce800ce8d490cac1cfe3f369a3c56303c3bcc68ed2778b2bd6df0d6f387561241d2e3bf18de63be2c816e304db738be3a98bf00b3ff93afa0088f20714c04b43414f7af626d01c2b030364066fa68a584adc761274745034a214ee144cf3e3aa589b5982691e7eae1e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
