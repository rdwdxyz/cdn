<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0753eff74d0e3ef75aee209b4f83618c02195cd2b404c2f61fc1e0dc564eb4a282ad3ac5c799f0415483f4f24e09ae0bf66df226c4b4f6aba2336b65a728719805dcec96b91132729f9530edb85c88ab8226472ccbd226465212ade96fa966854fa24e496efadc9db827f129947dc73a46a936c4fa9bbd01a98ec4d4cab45404760aa2474ade7f8fb7a3eca6b8c177a8c9ba3fd0f36d544a2ff3bdf294b6883401909b82a8f7a623da747c509e981f6d35068a8dd5197ce69b558d6c36af233e22e0a50ee216d57e4533aa8c094ab04cf8e9684c63f0d5ee1682168bfa725c6f2b7d9b6037a68cba0307b0214f373ded2e3df079699c1c3a729ab2abe6175c3526ee330f0fe1edb8bb37f7eb8de60d87351a41bcb0cef49f4b11605838474560bb0f480bb9966b9e3ef7f0ee1555bff0236020b3a9ec6b33f05c17681b883659407c8eaf95b009e74c7dc7eb875b063086e94b338e5b472e081b693551fc2b5036468f32b74faa2f859aa977cfefcca806cce8bb22a84ec1641413b987b9ccc096e15eefecc7f1e8115d2a83e192d4b1886d3e07b853947b0eea43a8b05e56014faadd136aaf7511aefb860e8e8c0ae10b2430113975eb99a0472a574b32e3a7189b35daa9a3081c739714851df344bd8252f308b9ddabc4dc6bd1f70d95d6c23c1280a19678b131e6d824ae48b84b07c98b324516099b5991c324310ba5c685c5529f61d8b499cf9ae6f5a26a67fca2b0754865f7fe47cfe2245e320a000fcaecafc757394f4f710eb4f193325b0db450926240b6c5f2a2fbc81ccfb27d3f0586f8c808f52467cb71ba222f16661572ecc93d0be55a1568b59998359a06d6442f52efeefd703d0cedbfaf383c67c633a0c2058e1cae0bf6f4ab2cf5aee03a887858937ceda5694e04837e8b9a80368249676a0bdbcb11820a9375e9c2e4f6e83b8da5c68cf2af1ae77e193ae33fb4a6baa4ec4508aed1b60867218bf250a7d0d3dab2fbed564e955c179a2047d4db64279664de960c250e4aeee2e45b77afa9181a6b27c04d2ade136abc042868610fda05b9a3c3d2db94a2f2d8052c54097a98a640dd4fe003d9a881b66d3f472ef1074b16a140b75c98523942c6d9621f0b814c6b2352ebc4b7549159dbeb480ffaa917503e558260a1cece206cf54e5a50357e7f96db061be9369093e30353dd56e535a3d149734849581b65989a28bfae765d89abad4de9d8953c284d714a6dfa4e77b77929461230ff6e0e89ed88b6bab4fff3d9c4989d95016cb4be6469c1955691c2cc01806e68c9e826f69c9481f1a6190aa8be83bcd0f36529251d16d314ef1c874e724a65de79e1ccd7fcacde5130b9d162ed4caaeedcc2d8e23e3e6ab63d322c0e517e921ab0ded5a5a6cb863e4337586f48425a5b24d3bbdf4bcec4c315d07290e1558d949618d311727d5185303848fdb751b91bbe0b3a2847c50b6fe213e1a8093a48ad5d4da7affe310e3f35d2013c987658a7d0a89655a78a41bf82253ac912b7c22e4df1624d8f24d6161054429bb6c4727b704dfe7698932b3afcfbc72552faca1feffd1477193dde86fe1936a2f5de5b2ec2e1ba311491b71ad88ff915276644aba35f915631cea944c779c05e780f17befde0aa91498a8d28227490cf8f8abfabb81b5fb03b53b7417159ad761187b234f54d008a6ec9e9123c67fe3c584f142a356f2c64356eb8bf65485ca52c5cafc43f675128864e83777c054f1c45597369639a51eed48de4e6e31454f2cde8826e15f9b6d82120d7735b53d13d4b5e0445b1361c577455b93c1814a75f71ec3c962876ad76a589859df87a2a080875de6e99e0b2b81683e75575fb62a32f47b4caf0d44aadf557855358cb34ec5c2a2c30bc2a4ab6be0baec2aadd2538d5c0ae5cd9dfcd6b7acf9cc294a2d87ddd511094a10528d4eb9ca56c3d743bce1bb68de386bd1df57f2468d5202c5e6e0c5a82ada1020d5c6f8284c95e3f8425362e5c31da2446df207be3e3962e4f07702675c9c7c8f46925d7cf18881521b42172a0d3d4f4b522b8a45d1b98bd0febd37ad1c3275f0a1faae36a9f59a80caf3c0aea8081c711c694f93f355f43f2642995efb86aef89192323b0e3401ab4e29a5e9e0cc5ff3ef834dee4766f49df7cc6a82af9d9a67748ba6a16b6c13f753165fd0807243ceedb440fc3772230a7f768e2c6c47c748dcc651e419ce9952383a53730ada3fc6e81e1fe4e7e9b38305bb4d5767757d553be7e5c9d6cc88e57566f2966f141003383569eb934fbefcafb14ead06fd7de027267514016e44c680c3cf8b8851c4dced8b0e79e7ebfc60f45ecf9daef99974bdeaf0edc4eeb71d8525cb932477264fe9b8e7df402d354c6cde2ac589d56da2ac3558824d63910cb2015eaf0b5ebf16889b61a663100654f8db01e8028c3448c5e002b18dc2f0fd05548fc4679bea416f5905410429b4f1f939db420b91e2bc74afb239751eafda65a87061a1faef2a410e620531b5f13d21a23232963bf505d1d3dd424356bc8ee8bc2ee1ed08a2a80ec86f65e6bfb6ccdc30d7510f38d0e51db6b25eec83eff111305455cc02d82c8428611882afd9a911aebc34e51b607db3a50956743d5db57089f25556112ecca31aa2a0a183ef6924d06f199cd3e66fc214ad59da3f1da8887e16277a64d262afacbf1fb3ef6d91815b6046edf342be788c1ba088b8d5883a97a8ea3701ba7a74fc313115cdd3c5bdcaeb6aea9ce630b50336a1dd8699135b270f225597702920a109cc7e46bf40384b75bd6add9fc6c825b17d9fe6652eea5759eb889b9feb730adcfb3ae30549a5b7ae03382d769cea6075036f64dcb6c3d8884b26ced4fc62b4d73a829badce93044bcc62b2b0a60a0d57bbb7993b063858dc21d0dfa0fd51c596c751d2ddc5f3c3bc16257954a1950fbcef7022c3903f4a687fee710932c79a86a11130521302e8c3c333f507eabf60251e4be3bd4a330b2e4980494ad3cf6b0a9eca4cf5438d8d3609719819261d643517ca0d1b8f85fcd9b12fb3dfb77c66427dd7f1607b7d0c7bc3119989fdd891d507fed422c48266bb9a80926f5d1a8dae1267592271e3050e76c4b464645a535c04de2860c8ce65eb19c71e3eab601e8d7add877951ca7020160f02c96097ffbbb1bb51a8f6c892805e2fe96189b8798d1ebf6b6223af3102af4ed84c1d8c68a796af593ac88247686aeecf774f9e42fdcab8c89631093e9618c2380b3edd7d2046957401e3f15358e7fb36985e72eb74ba698ef4f5210914cddad5a707928e90e4341c1fd9985742f27a5b2d0a526a5ccfaf301a9793fcfdc483c3cb59855ce84fafbb95a78d50abcb65c2a23d6f7e7747be7c58c00ce26b4141cf0fe7565e471a0e44f44b2da643fa1b7e1bc6638ce38b2df6c4e5f622f858cb262b8552f0c14c2d869ac523f0a62a94fc83931728f98a20d1b9f2b397372db4eb2bcc50b1c3fa43b14985f258797d50f52f0375ef1f0cc00eee2d3866490a33a4229a2f9da04f1c005f565fcb84406079bdc260b7441dcca00ffda74f537a536bdc500497c295593edc0394099fa18bc38dc731ab19b10c1a6d57c5b4c16810a7bbbaad96c08dc5b5e7670cac7a5a87e7c1f03c719a54a2b4f8737a60bcad78066bb4398254b0683116541bce0d1e917e024c4b17a174a59ed287d49079470df981887e5ab1e17598c19fd092eefb197ea9577a659563a952271d5421ddbcdede0103edc9ea06e7956a09f364c734a7bb8ac73076fd8d09996da2e7522af620a702cb78b546b7b5cdf5829d5218bb22a9888b1e94bbe7f163e4ef2bef3e7beb96b15fc4bcd9d4dfd4aceba704d112004322b09f3fab0a5c041e1d6d5cef963a0df6bf47d5abd05dad10ba3bb6aadc4b4cced5b515111364ddffdaa87a6397a882fa593f6d5c6a82c464885cf3c1f4f0de599c070e69c85c4f0139d025e44a4da081568c344aa1fa4beb6ceabefd43cfb06b3a295b521ce8f44bf68bbb8e17888a7a387c3075038adc1aba10204ab27a58233bddcd04802d95c67a7967f4dc2cf79c77a7dac96bfa3c9e9dcfa9fa67069313004574187298477d162b655c14d52b1316d8a91f0ca8be9da67b21b791632057c59158f5cd1f10d809c3763ec2e4d76ab9e90d3723bde403e02a33be3b1a3d85f0c8e6aa0e24ec5228af5e4ca0e809485b6f14320097494837b651191240b8961bb7728752657129441b086a24b932379b98a4f033d809a8a8a02e3ce6bcaf0f46970f457955a44583f04b3b2b9ff86c8aac57d6f9f7eeb67d01d74c159636ca3314ae28293a55f75ddf20ed17aa5104a899f58d40368539e98a27d07f77fa270da25f7c0fb07f652a9b1222328255456c6a36fd1e6f8c3767bc02c3dad08f001192b50b97f12caab5adc9fee08235e4ef6e9a5bb240ef2c53e0703a1f4c5149760be48d2777220740792641909f072a6369d81381ef946818e6cae0f4e497a1b9a0ec65f4052c83e4e2233586c50d5363cfc0ebcb64190fdfd250238c7a7c63db64f2cec4e18f5810f8605fc625749a6da42505c74844d8ca2b3c290fa17f11eba691ac0beb114840a4a110f46e878c05f05f4608d899e42387669c78506440d686d02ba93d369dd15e9a3f766c7c055217dd4ead9e121a7cc0d2d4ed9ca2f72208ada651ff111645990b2f005a93ca8dc9cc588f0ad35ff1b533081a319a36a14d7d604c6b33cbb43b7ca36ebb6564f49309f7033921aec50d04a935f21b6d3373288bf133c6ac7dfb41e19f7b828187ada16e781fd09d557cf35cc089cd3c808e092e784887057fac4f15800d237c1f4af40af956cc976d48ac0f8e5379523da66555f9d21f87d84751d4a3f36d8c79cd16c43a4fa2c771b5027df0b1682cd07a864a9968dc4e379c1e785edfc7cae1c9b169f216c92c89d27087b2614df92ab8e9b26390942f2567722c67edc12e5bdb3ce572352f01de469a7233d3ad6a17d422867be4733a296dbdcd0050074b9c132c4b8ead5c6d85be4cb98897d291ad758dfaa2b1a94311562046d64353937137cc291c86f46ec9e4a9ffd4dfa10a62b89e3c063c27744ee7d3cd197f38dedb236f50b9fe0fc19e3a5b15934d734b7659b871639772e89b54933ab4e2f4d2180f5666a01301a44041504f633cf39939c4a803b11f92a54da11e6b51b281f43620570805449096264e8ab92269fd9ee3a10b12cde5ad4f3651bb7821278c3a0528596e023595423ed1c8645d927b09bb0175a4ff8a456fdc65430c2ced45a906b486c74abc2aa408f9b8dc1427dbe6d4b26e64d52d85ed0ac497ab166da0952369e902f1ea95e73a14e5770070b5e51eb01cf82cad3093e9e273d427d9772461d800164dd373bd3a98d1d26d813f5033ab7bbed3dc3c09b0ab50619c42a67e79d6de98216814f0695c352125669039e41cb8d73b0356679486459abe0f2006002da8672539739c2c06c54fc97fe1e9574b3474f5d38f3975a25fcbba62160ff0970aec7094a3eff50c854a1921776219c819e08227e11fea319b5b806c59a25164ba82e3e29b1eaf96c2694b5a01557e215af08d9f5f203a794d048b9f2458408083f8923f6be076e562c3c61bd1b5b0b10500ca2d71da07beef41e62f57cea2a01ef535fedd2ec9256c1eec5816904e8835c6bb2291f1196513fdadcb0cc17f90876c0e78a2289bfbd38c977d2035c22b53517254ee285617c474aa9c65093743a2e9bcb5c876baf623e953435467826132b0c76fef2418a8639aadaa5743cfdadece1532e9c67512665adaebfc411dfa02d22bc5effacabe49fe2232d30b6d25f9f88198690dfad0399ac9ae05d6fba6334f6c5839a22776abe77d8901c7b0e35d50a24eaab487909d161642c104aa1975be8fc95fe04d6235c8fbaa11dc57ba82b98930f29bd71ba2a623c096798a39a767f6bfc8f7e2b2347fd0c022687b54a4e39555ca3e76e47791ba09666e2b45554a4e125672c85ac05d64616e53d4e05de773e97d1d89e8b1b16911fdd33368dbd0675fe2135262154274cbb62848a0a25d3e36f83cd1e68d647aefedc3ae6bb74f5706da8f67f817c4e6091427f7242a14522fedb780fe0f9ab6a82757107649e72912d339b630f8e573fc61f6f64c6803b21fe33029a24b9aeb1fd088730df106e891ee903d20dd5bb2ce58655790ecfc0189216c3f6be2df399a71abd2deda662b964df646ef0b3999f2db7d6378037de5384228af6a508deb3c705373b9334ab54c5bc6cafea903fe41adb3f87ab66578620614525ba5e572331397c7d408e76bd2e2928028e8926e8aa6ad66359671818161d10fd47db6ca32e7a11f18db28f34bfe69427555d3b868b9b112aa92d3c3a3e6462bcda49afa7ddf1da99d8f1a59afd48b1b1b729647f2b797de99f980bc886f6b41ac7758af1662603946eb30ebc09f66ec1bf55d1c721f731cd59db6aabeac880d86574e44fc1077b6daf07bcd3c9cfa95297925a99cb40f3e3c002290942f118373667b022ba15b1cdb2c99838a6b4a8578ba41695c9f0c4e195e18fd96d63031539ed129ea2403e3d46a6a9445bc48f7d353dff02685956ae1665e74069a3c3f4f68d34950f36999c48da824bc642b9ee83fc194a0f362867ebf9f9e40ebea5da0ca45092f44819e4482fe0b08c2cdb5106b0589b1fb0f8f259b9d59739f8ce93f8fed7f9b49e130741097fcb7aac95421e49e640ad7ac66ab9e0d4e0cbdd26f55559d4844daa1b7b13fdaaf29aba6bdbf223b985989e54332051e0089cfed26f18b5aea74bd47fa01deb54ed03528970ff1d185a294035ff99dea6e34a5946ff2686da8b1052cce41158d35ac15a261d0e4ba88b88263097c2bcc258b611529304f412a32095e97232dd3fb7595f5edbb52c4f6a41359ef6c10b67a656ce9da0c4195a9b25203d0e51d7eac4a5dc171d81789d59dc6480d2b29b09b261fbcaeea9379fccd51edd198ac66a51f9901169aa1919e65273f2fadf9c5e10cb6712e9acae8c2fa5dfb3f1fd8a5f891acf5793aa0b68f0dd9335c0addcb9c853927101656f5f14e92ff7509b1dd4c3d9ac7131b8c2d52a548b224e27ae8e9e880d07af298142c600abb92f2995add0953429bb2acfc78126af3c07dc8a6a27146fb45baf12b9fa9846c920e8ef68901277de48f21ccad660e7271810d56de4883561d771df3cd73ca160134f22c8e19104041496bd4f7f9f6946995bcece0629e799f34edf988ea71b2556c2f9b5185862114d34f598bfb344e2c0214113a4f639304ea78eb250764ea063cc8c5069bc1276ab896f5d85086206fa986ec18c3ffb2344ae04a29c3b69c531c785558e50948dca6741247f08cfe7943f95d0b13cbd39dd0c6b038af1f24b29b05b7d1af6dbb9517d55eb90ec706d60a2affbb94fc45e56ee2da95956322f11c5d32174aa4b2a6c821a05896f693687e99012ed62b4600e932b40d513e043e295ed98fbf34681cf2610166c89d7120e396c56226898082b61de138d69e4574774d150fe234b617c6601c5c367f7c85d85a0d34e3057dd3129069493c61fcb8a39d59247f64a976163a123a158d25dc4da76849015c575d899fd0e95493b2c75ee458e08d255465d1dd925edd191985dbf50b85b35db7e0eaf43101f620ede7810a1211b97c653b3d68ddcc090f7237a46e01abccdf54bf22c8b5d93724105d0ffd64d7acf38c8cdcfbcdf71b9234399121b5135f5d4c44a17faf4861c8df9b5c3d5870066f6c87c078111b4195d46fc3e21ae2a35bc914c0283787727c3a187b3e07ab9c43b807411b10f73034d1d276025054cef511dcf8d08fd3135562457dbf93b6fa0d656e54453ca8ac2967329b0d29f517cdba49a4063e1b530db26c6c13a6e786d938eb78fe7cd1d730b553f48b89cc04b525bc82cf36d5349beaf0496751904c3855fb3f0999df0f6da26bf0e0bdce440b0d329b698688b8d5120349b15d3628251f1cf52ea98f8e48261830276f473426d3f5192b90eea32c71af0c1fdfaf049c2a4e4e36a733bb96f8c7edeccc86b59ca7ccce08e86d6fae85ba2c65de65459da3ca82f2561c0980229f270ae6f7fdfbf907b03ab670c3478f73b4df67ac93f5ce465cada4cbe7ef9724866800636f58d8bf2475491c18589d9ef1ef3a0831cb40f0e1949848e327897f1c5ca7306543497c5498b636094e45462a78d8a1f1b880a4279e849179f598e8912b7e7208ec9ea15741e2256f475d3e050cc3e9330ef49ac74565bc0e7490cd52ef9a9160b68352501e17d839e85459b7fe8e4e8a5ccf90d31b044b48c103c4c0a361507d2f1423f2bf978437677952352d356e62f753f49cb6db4f880470191f93766489f4bc63f8a3b211b790eac905e5f7e3c95c65356b3164cc0acb536ed98dd22588e3dc9eba462ca055097ed0b9e9dccf22f0f4122fe3c1db2ecb6fd19d19105aa803971ff9a6439f66c07324ca981297430616b73cd67be01ef9b1d7ff1328f78ea385de1073e17a11603c6d8fecda79d2c7bc3eada99bfe9aa81510dbed0a919f454f4e209df8fcd761479fa7d09b3231f84c6eecbed1d6c7c371709e4e3aab7bd8cb56ce54331576f06a3724d429c9392adf770a930b73413854f29f1c61fa47a6f288f9101381fdd74c6b298d78ddccbdb0f1c4eafdad18443fa137f8b4798c9b0b9f08b086c0ee6bbfcaa26eeb26ccf9b8733719fcc2a367d8d66d1cc353ba1e36a7c1594ab9cfa5b122534230fbf135887c32c2b071c26263db8ce5f63a2a7b4bc33a18ea32236977c6eb42476f3f964737d916656f01adcd1fa69a79392b13e17abec37a925a95ab80c1389c435d8679e489432711a7802870847fb0818a55ded9a95aed18cb2a5cf3588e2a1cac58af69e121a4a35a09b9d43fe36222029ee3ef19e5f2be09e2b1a705cd599f66f66de3e61e5f64a914d9ad78174f7f92635895fc4a05fef7a76c906393db2e780bce8dd476129fd06eb42e23259ec208538260e7637d707b6999fe1f9b2846d7c43bccf03aac3145b957935bfc757d8ea8b5ac7e756b624233cbdff3b64b342801c56615db37d643aade772fb73ec8fe55c2c93b653df03b53ee54500f09af6322908ecfc2f2d8266cee8a96bf6baae6db9d4faf6040e443091ebba4749c2e5509831e08b72c4724e231c3c4bcb8c24553ab5230907086998c8ae84e0cfe3f7240f2267e4240a74e2becc9c0fd640be4167dd4dd571a2dac6b92b2ec91780f578178fc8f882dee3da882e58c839a4e09cebfb0eda6710c1e5006e911f4569a7ae6b99886c284ccb614e3e473284f30c4ba925876231e8ba041343363487c131f500a78bcbe4db4848f46802dea4cce5bff05b736338d00943443efddd7d70fa2f8a4ea8f3fce7be87e7aeb190384baef0b99af4592bd8e922b5e403b18b636e189ab7cff76b855a1b65b2aa04941e87bed0661372e0ef831f5cf26440cd51273e09ac77e8076b0b58326133013282d8391cac15936c67382e50e6422d8cdafa022901a1b81bbdd1a8d73010ff437869309773ee6bce5fb01d46b5d38313db3ae7f767483e24b1896f66f05ca679407f6de01899a465889281056ef526be5c3a751abb52dccce63ff547b42a2c0afb2f046d9e3ee84cd143c7173b8686c53adff1d92aa13e0735fc191d48d55fddbbdda30d4eedde290e93dfc76c3ac5ae4d7cc581f95a8c49ca7a0861339742e234dfbcf80423394dc94401820818437e2a509dc27f0a02d2cb9794f22dde81a018eb46d0c4157bdd8b0d361eff42b74539807955e30fa28f29ba8c0c93bb2d31d63fc8349e24804950b526a795fbf903e600a218557f0de29770454a0e5e773280d454e303e612fe32799f104c3ffc6e1ab282d9d74dd93df9d16e16d82fe2169ebe0ffd97cdfadf2698a758fd149382e845de29221ab4056bd9c5b6234c4c4d2063565dbda47e2b86a69b860c4b87dc20631a65caec51cf08330c6b5ab12ad202c45a575eaed8aebce0d7abee199cae6462943f72b7bfdf4c0243aaad45596e62628fa49c10ce31fb3296f6ebee72fe3088bdb9025294028df5055898d5660f3e2bb4dc08c98e3f53d076f79ca23dafd2da327c5b425747131a9216fe712ae54be7fe3fc1a8cd56b17f19f870739e47d8693ae0c4c4ecff5864af6e89a85711b19391f67e4bb5ee44ada699f6b75715cff1d51b4d56a9abaa8461ee3b2727176efc36d91658169a7d91de30268d980eae6e0adbfe6710a3533ad6a40e362637bfc0800a90b2f681e7a50ae11f179402fc278a11c89e5fe2fa438293582bf72630cd44a5c2d9f109f00d78af18cc9bbdd00a0ce66899d6d1d204e0751af1b7fafa420fe814b3d98b2fa8f8f2271134f06ae8617806c9c4d95047c91bd33ee24e4aa2978342259526efcf340bf94ecab56348993fd7657075c3182057de6dd632ae5563fe6e709421f67e3b8e4393e1490b9aa16cdce69809be6f8493ddf93b531b3df6a26a1d7bbab376c3f5a5f09ab2b2b1a5696aba15db0bc44f3e18cda4232388f5732788adbe3b0a0701e6b82996bd42f31c6dbd4c3e36ffc0c7045233b56bcbd3ca5c50e7feca1d10b104ae1c9a7b317a4a5d99b65948202e9b824f56e3fbae05f1ae06828bfee108c4f9cbd5f24d9a82991bc2757ce4519264ab330e88d2d4bfaff6c7e96f8c2fdf898b64c68919eb51c5117b484135c4ed713ac157443f5af063057bc97fadee9cd90bc12f1dced8a812d146a01dc7b762d4de10c6c7faa38ee18373eca7b70ba0bdf5a084e9c9c381a061a926e5559893146fc9b0f44873015ce5deb892b0482ba98065d7becb0300628501412318203b279340f207b51e3fe706b1c39499b4b0b0b46e1017de6d3719a79fd1db2dbaaf9ef61fcaf51a941ba93e68f94f62c58b75760474834c6b9a2d339ad2a39f97ac20ad57b1af6f5f9dcb4322435b9a43dce491e302023a657bb6ee3c31daecfd26db66752c51d007cffce50165f7ba1f78974b18f5eb07cd72166ec8ccd03e5804892d01d6ca3c55eb15b07b176259782763589bc7143833e2b39ae4d3801352cfb051a94c86afdf8f9f3fb5d538e7160b3e8e586a33cb01ae22b6b2db89492f9044d620c77e90bbc175a7f1a877dc00fef31cea78e5b5f7200826f82d08a5d52691c208887a1955e4d5e8a1a1036a1a4f8134a8b5a0b024529bc848cbe1be12538b8c3b806b4db279f698848e6f27040c62d58898d5b4d83a0084c54527c5f3812d60552d5eb6257767c44acede2f84122d924569acfac2aaaea60cf0eede3724222bad5c98d6aa17f60947a4527db986838b11f6beaceb22b9bdacc225cc6c56c9e2f27320160a9e53234cc8f4b20923eaa33e8756e76999f5eaa7aa0f6864dd8f33e4f63143066cf489dc081e35ce3224dd1b6d44d9582a96bad862cc99688fb179bbd22d438dbbcd033d090ed79e322df697b9274081f4592e291a3e21e48a2b8f5361c526fb95852757668ca84e0dbf303923adf6afcd36fac1564c91889c874f0ff12c821ff61ee97dc0fd70fc74dc4040ad7c973a32813805de880f6cd17965eea9ad6147d7efec6f45b4efb397772226eb9dae46fff1cee22023927dfcc92a5e4963e134eedd547206f075c23afae558cf22bd5bce2c74490a1a9f2488dc4dd1da9465d31302786175e0376ae177d5451746b629803dbc829c4603c986782e110a59cc51f7bdfe1cc4c84f2edeba03dbaa2f63282c82ffff170beca5b7cbefe4141ee9f7e1eb151f0dc63bf289ecd7bd6ea8bb28b122f30690da99b7811883c82067085a52996daba81bce1f5e822b7e6f5ae5aa6fe1cc999e993d20e5aaa5666a764875edc06f2ff09f69d86132b9f196c57736365188cac0ea03d577e975240fbadd06f1e102ae86e7f89c1cddcfac440b7e7e487be44a1503bf7dd15ef8d215ff16b747caad14c2e2fb6916cdde67007a177e364c27b185f5c6891eb0460743c82bdbe34d7b2b87d9f5627c1f6fb7f287f321a94b174f46e9a18f8f53b326b4bf43563b8433b22928e0fcae00adb7a47b4997fd7f33cf9ef373f374297a3ea57c4011cadc407ef555bc9608c7da8470ac39b7c35cfb7429cf60f2f296e61e0c8d25823034024fc5389b554898146ade367a6babcdeec0b6053034aae8fe1743960ad7551eb62108e906336db849a516cac7c8c83c0cf025449846bba56f6a1d0e0bd2127848ed8691eb0756b70603e99d66c4f052a44c338f7c9f55f2674f1f9cdca0d1aeda8b7af5ad968561399b71375920bcbb46d3eea99a1ed92df4d832aab67b83b88d4420068a2e8e9fcf257832206db9c814c9dc57ba4a088054a2100b78fc6201dd6c58194477c9d8d4e3ffb7510ee0464fae0f482ff43e5154f7dfd50ed0efa2e60917d3c2f34c07fb234d98404027ee561fd0b44438e99679e6eb817b5e52ed1bfe34478075ea02074abdc34a8b5eea949a8e2d88a9628e8bc4dec847608f810eba5d3e80033d17edaed1349c4278f745f9df2a8b2f35ae43872ef35af3cc9dfd00b7b31b349987063600d732eb22a90c690f5f19b5233afc70bbf6263f2598ed4c1cb16afe3e701dfd0a37598737806b34c1c26814fa17022979cd3a8ffe8be5cd8d30ce5b4342304401171a0c319c265a8bdf13b90d0f8d29ca8400a997a8912085ca13e538e87ffa28d42dfcd8c1eb9265cc4f3058bfab7deec3e6c26d0955ccb2ea0cb921318fb83a0f4bf208add33e7076488408ed7acc6dc5ee9ba121324c990a85662b3d835e4cfd0a0bf58ceed5968235db8a6e9ba91f913b1856b749d45e50ea57774bc017ac497f0096cee5438c58f8e063cf5be69a2751f9a236b7b5dc7ee36f19e28632635e77c42351a2a6c6a606fba99144521376900d2e025f34139a7b5c170b703f8c45bf00517105cb59e7b69f1f28db121896273df8ef0d3c514468101ddbaf8f15fabfa2ce5174533729cb9600a1caa556260c6a8a7bcb5be15fbef4158b7809f97e539e6eb9013c5280d1e0dbe8e1270dc57e600d685875862ab3300ecc5a0bba7100f0896f6ab726333d4b81169b45868baa6e01c266ef746d62bcb0aa4339d87a02159e552ae9f1faed3cb49a0f61145598650decef03e8394e15e6d4e4812af3118e6bb7a3462cb43e15d719f8299a5e30fcd4cd42b9c8400226c80adc238d6e6a3db549f8731cf9a15539a410e8fea4ead1c6b9f8cb7c4413ac37fe732c346cd454e59e96c7412410ec71f51eafefca3d54425a22ce7f507484994aa5d9a1b59971c688aa2a006d96ec53828acd911de56c7291716475fe74cff5577cee0293251edf5b53a6e6faf8f0205093eec7c286ad2bf63823589be043916d680d1413f44ce49c187a0bb9dbf6c7f7b9a650a660ba90ac48866a7158b60a25c53320ec79d47bd8abbe5def2b4a007d27d13076c1a14a6e5d10d394c3159a887da6a9a241c056491fd32cdcbe3204c61d409197572e9d708e501da5fd049c07098e29c67c648cf5f650ae476a05230387c45c448449b1e5fdbf3f2553e38dfa60937fc3fc6186ad15fcb6f24344851dc0b48e208906e89bc0f21b3d955c1e2014e8c6157b7a257532f456043501a23419934b9f4be62474d999fab4704101001e79144e7addd5296bf7609ac3e542b772733f7e6c3bda6059ff27e524e9d7a36480f1af6c05b02f6ddf44375ab149c1fb81af7b7277879dccfd39dc4faf7daebf869b16e01e57c923e6fbd2037a4fb1ffeff080d301052e2f932bc29fe2b210d317d67b6ec142090a71034f98afd5056bc5f04d95fa8ccfec69f3085bff0da249d36bb7889b8ebce435b45c50e7342ac581f9650cd8447a06f860ab9103345dd9d3062d824a1c476347182c44880cf82cb8c26e4459c0ce72745b69586897ac1b3af799f38bf1ef9de3d8224cdd4eb02491498bf8c1b577940255caedbf89dc59c1f7d18046d4a263bb6bafb4376827922d346ed18be01a215c45e5d6e638a7ba3a0db8a5f3a212272a21aab228c423ba5f5f1dad803047218b7df66ac2556729096241b70571f36bc29db5d0e1fa37ed567ee7ed9c6380c2224b752e7d9e8b3b505e415054440b9e75d106c31e60598f7a29d0d527a72290a21c45ecb526d1456bf56d6de2899919ac9743d2e536d361b0d5cf14f4e7463f99c17473c7aee5dc8ef0cc876d9ac98973179c8d60ecba3c6448b34d4b9569e4030543557b163d0ae84cc63a00eefcd50fb15ce50df57c37330ad7eec6263754671614f8b0db27327d8abba16396bd219f3829852386cdc50a7cb710fd4602261454ab3c9c3fe10fb4de59606a1b93ce1b4f5959203c10828e10b1bd3f89d24dc4902c259ecebb8284179ea955c4dda8f8d7b48243c976cb03ec0cedc800c08198b42e92af481683303317cf890eddc9281f8a90b3c824f0776909d5b4b435accc550e83238d010e313f4f54a4c617abe5afe20e37c8b01bc60bb5b86a1c0531afb3dd9b5a121b98e41a86b99ad88f9c435d1aa026684449b85dd51520987e35a2ddfa53684abdc29c1110b0e2c6f73972dbe3af48a8c8fd9bf803f3066b0bd8fbc0ea4b78da3853774792820a115d6df21f556155e38c87cccdc9307dd5515218db3e6cef35760e7199b29414e9ee9ad73af24cc1dafc740acc1bd094f9e70e62908180b36273ca3bef46ca9e99c3cc879fe6d45248486cc9c8cccdfad77245bad1e930c9ee6c3ee95f56c458fa1e773ddea87cade9246864d3e266ea84f4a2df2cdd639f05a47769dddf9fe2afa2aa656d5b28443667f657d25cb1816dd243c74e8cb1cdca8a06c4d94d69127d3e574a1b958bedb71942935af91ffa84c2d4ed1c7ccb32df0d6cf9c87e5dd75d4f385731d0e1cb16afe8f85fc193f7ad6c87b8f751d035674e7c19008d2dc90353fa499e7bd57bc064da717e7d89f40d80ed1dd455e5764a74c5445e821e13e1a6839543a2e0fb6c18b43bbd63260b7fe8b8e66b88b0e285dd866a1c21db1644ceb3a4e5a65f8125771cabb250d46483f185aa822c96ee6063f6f6afc0abbe5b7d99eff8005cf3c20e9aa49ce0d52eb41093a2dd8da5a1b108fc94d0f2a7be9ea1d1c25dfee406deed69742864c4b0f5c40a2315351dab182f7845ee38eca92a3516b09ef29a47a5e171f58599f745692fa87b1a1ca8cc77b5bacba1eb9a5d2bd5c70a400bcbee80b67fecb712cc5d16925a0cb3913a5fb83ee9f3cdd3dbaedbf0bb96df78e27c3e583a8cb1eb2696a616e4bea69decec503b74a6ecc630902a9a2baae4322e8da41dbe3a770209079f8f53adc8d0d3f6fc7ff3b287af93de605b44368015d541f1cfd3468dff9af96c05003e2ab236bce6d9b04316a3719c45b8d92e9c30368e1f224d977af5e3f558bce51647fa60a1088cd336194a234d7f1af0581c5d3b73a962c3e35bada29dc6ebfe6c1f59b7e8d68c62133418a9b19c391bb79622d99bdeb5e9524575e5747f1b27efbb4b5087a859dff706985cbbcf2428d71aaece9b4904910d6363f8f8019a160fbb0b858a90dd57ec6e77e6e46a99e50bdacba219d92a46d07961211813960402a7f44b059d454ee01d700ed93dbaa5ef137fcb6fc40625c328baa91c90cf04cc27cc08532dd33d61bf6194115565c385ac4330fc45c692481eb1f1a2ede1f48c60c86659b00ad62456099c58d2806a2f73e472c576f444afbe3784c586960970ee16f28dd3eb8e6b9f3c1979c7420aca3add64e9c4d0a9d6a9ac6946e5028cd3bd5cdbdb6f6c7b45c722b74a4603b6bf78ab636375fa276b4e56902aa982ab72dda7443aef3ea7cfda2086ce371f665c40b2388748d8cd888bae6a4cbe30fe07ec8ceaeb522b59b3578271ed126b12c7755d0023d10a1704e63ef36267b5ae4ea8b1b0ffb69efd261ea0bf50536f7af0dbb02f1e019d63d5ebb1870756cc9c6a46979c45cc6e40092c30afc35252485f7fba47915af4c73f4dc24a30797cfd471e8fcf3757c4aee2477441af6f352f9b2ae50db4dd72f9df3a3ae521dee22690dad6b6766714f1e63d0fb44f597407b45aa41372f7a8efbd852a5c9f9ddae162b9027810697c72829193238d6870c068b19e072e3e649da4feff9321afa0b2ab849fea5d974c980c889c4e7c6f90050ceb5961ba02ad883a755670c72ae99197f6d775a4b1e7390254ac28947357daec1a4568466b713bf47b359ff02dc80ed37d5c31871afa52025b2c35235b7eb0f894f025e5a2e8f38578f76bbd7a2afe78c50e5a605671b94ef138bb4625b49c18982fe6254a980aabadd1f681e22414a1098bbad511beff1802362cc3f64b625320b371e7d84dbcd0ca9e81e95236b1c44c246479772f3971084367b80f8532700cd237af3aa3e4e9ae7d1f48adb7506fd2413862641ce331120a4652bc17e9da57437a41f3649fae0cc6b7dc25e9850f86d26c60fb3eb63839377d67e01a39eb97e3aed065afa50b4b49925fe91c7a31c431a8018a6dfe19e0ddd026b3b9ded41f4122f87a77d7769985cb7bf6aa96369ce3990198b92bbfbb75a92d4d485bc6303b3a364e5f0be507608b72704c8d200212b39522239d57bb439965826cebafe04eeb5b7db6521cae2999e46866d2035e90d3a7697a1e0bdc9897ab067038810f6b26fdda404a12b72fd3aa5200504bdebbaa20b6ad1c3595b96bcd62ba2710531cdad7c1ab3618106910c4cac3192e4c731dda0c3d76fa978f32c0b1df1e332feb4400664addc5a9e34253b8e8b2f12d3880a0f02db1b9810eb3ebdf7eba27b1eb71bab696785d1086df77ecd26401f5d5782c0be5c6309acbc125ffcb3558e2ae77b11c99929fc03cb2ed89fdb3dd870ae78fc1692c65a3863a46c9690d274a6968f38b26339a76c6353da878f8d344780d840e2d366906fa959937694d87597c305e5eb947731563ae81c22a002bcd2369ac52ff729095ee38b1fb20fc25c53439557efbfdc4e31412cacde4f38c71ece47e8b5247a8532e8479704d8e9b94a0e903297b064313de098765ee1e37211e9c10c176a70c7ca76066f27ef2d5eafb5c3527ac631c0b45ef9912ba6ed205092dbd5fdb28e94ab711b1ae1b3ea759a9e41eba695477a467cf1e761233902de04650f4f67b3b1f5d1853b5569afb910a021de9b24c8dcc6d006c2c40616b193c99bc414236917ad41ae1b674b1e16a4b75ae090146917d707aba47d679183d92221e9d1063dd2622bf68393ce7a4fc08583d8a2549ccc2a22db2fb778ac14bfbfa7ce067c72395cc3cd36d4de0c9e97833ce9874851c5fb34afab93b313e98c0eba43dfcf71a21eb1df83bc10696017a9525550d3c42b8148e5e6a73e5934af0cad73912067e81058b64fbb533908757b3b8088b0e545a0283c1b98a04b520e28f58f3442077f7eb319d193794ba39a269d6d36b2d834064954d04c036df27819d197ed6f7ca8b37097ea6c1fcf447e9d4e5d767c5dcdeaf3236db8e62e57b297c9784a4941d55f035db51f7ef751c83564d1bb1f29d7f139b42dcab5cf572d00a28a744bbbc657be9894d3a489fd01b0a5c05df6c4ad6efe9fd2a6c77ef4bbc38303d3ceff88d5fe6f6a06ff356dd5ba8452d022d00f71a54641248d3961f225ea342f33032a0cbabcff2b585e4abc94a17e429cd1c89787e3fd33e0be9395f43ea6e77a14740957267ea2c38f5f81319eb9d353c28b579cbc7030c73be536811feed913d3e23b1b96031c506ed2e42f7faf88dae6dc852d35032f969a9fbc1d5808d138ba41f719be9a5e8bb3a33530738d9e2940892c10c56c6f33ac4a402e4deaabb1c92818c136a6a723abbb2c9b0b0f148775d84315f968065579e320e652a25e67f5331247652212d391ae6997de153e03b2ee6ebda8b3bbe4f53a1307576537fcb6e409d22eacb860ad9b13f52711a0071a9269180467e423217da62da93e27f4477eb6df010d7aa5ae83fde820cba0e8947ec6352c012f69f7d51254ca7962203ddc98ef7c07548c946c8c1ca9ed3f40206df028c7dfa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
