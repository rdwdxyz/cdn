<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2d7ff81e8020f6b2821ae2bb989634be90cd410feb65437ead36a9e0517b9169190a8a443bb46d245caacc78e7801549f4c6746927ae62b28c3b94140ad85a8474e63730def3c59200e7354bbe9f6a15b0d591699767c403c0ccfb635f041cf74dc06e56217bc0f69161af38a7f03394cc375fdecda01e5a49283664dfa8bbf8898bf02c367dde0da371999f01dab40178a7bf47c773daac41f3f23c3b6db16622892ceb7080c72c93f73dd4e91af4d09e9b195e3cdb66268da0922a6a89df84c3191fa84c5bcab437b90067a5de7a1b5b8c90b3a3220e0c29d65684bf91542f913121d014db12dd228a515290890b79ec8514a25e1e70e05f6222c1348e03936dc7ad8837dafe7fbcb4640336da36e85378ddc7abd3ab5fa632a608ec6d0255248a4b46072489c89390c73c319f40f8cc365f88f9b449e5bc5908e46a30a5cc23ca8f1112f8b436c4ae3c439867f4213f0003da3111b5c7fed4811bb04871fc875242b3fc199bd240f7185695ef68f3fbd71b9dc552b71b8e506a7130a83d88a6c6ae4e6c33f78a13e7d4a747ccc7a2958905ac25889316235cbe151de18cc185412d2520fbca56f4e3e49907742b062be934f50ca1811ea8c3f562a433ba51c9f51444194df7d76f211b05a9e236715bbf291f9099568a7c4f24c933b2771ccaec314a994894ff393bfe70e24703218a6d00bf5c1188718fb97d52e91d1349b67a2f018085d1ecfc9d28f8ebb2879b4f264f89ddf9847f886920f9dd6dd672a447b0947f7efa622b44bbc8d109774f05337a479badb5b11f76acb4c5336a26df1591dc6031964c731e7f16ef3198eb02b4a182db9dc935b136478022f99b1063f3e04be2285935ed1ffed6fef3ea55525fd0950815970b5bfc55cc162d5b268f1a44b174ae12e0af87c4131625686b90fc7917a54e427e071a9b255ffc29f8f9641943d63d9f2e35fc4a19d2a65e18a0724c483759eb6b4ebdbde2d74328b4afe438c9023aa3f3592a7030af3f47d552101226f09b49acdd7b281307021a448ab42260a1938fe09c28e2857dd27c83867fe3df6ee8ea7028e01e9e765f43dbd8f53217d0d604516e60a8e5b838388e47ee1fe30732331515c206fb352eeb9a03918d8d3fa83cad496842d14e82162003808ea4d0566437d3aff29e34af4397c60c96ce6b6f2056011042e4e1a6369e36f09ea51354fcb147c1fa8df583b1f8747afcbb7dd2804775d4b9124785c62303cbce63b38ca8f8e0ae6053403b1c9c4059397171e52a2585398f3cc587057891ba3385c0aae3be21ee77cba3117e6a0354f0d12e8d38b3b8fe2f9804e19017ef7cb2dd89ac71a24db2fa047ebf70b54dab97bc3bef71d4e4bbae69a5e81998d54df5de2c34afaef5a3ff59ad6c87045eac12d47537c695a80cf6964cda031eb7f4fd1d473a37445f6fcca64a36251289266ba04a3701ec065737965c97ba0425beaff6f7e9d2d51c2131d68b6208e5d7870731aaac5db29c381fb71e398fa2fbd1b6d3707b7fa93ca7cfde31efd112c3f3af006d01e3103862254bfbd6ffe64e17f5b6352ce5b3ae61604dd46d105988e649999d5342fc24cde93c2f1e39225865004fbe0b528d920ea3938637509178d67ae40a4827f555ecbe4fdf70b8013ff97af6e40e2e225b7729df19a62d64f17261cef2e0666718508196839027c02b94f898c2e4a12e4409c345bac8fe99ad52bda3fb38fcff97e97f0e0ca64620af361cc7aaf232783334e0f91d305a5539e82e24df809be48336e0fc8da56b5034ebeb8588b7b908f45099072e6896b3e637543f09448826a1ac6eca795a594a834735bdbf686aff6182bc35d83d89676bfdf69026d9c1c5c0464f6612e5d5e3cd6dc878ae547afc184019f7f2029cd2ae32701a3dc4aa1d33d0cbb750c388916c34e8da656f996916950be2b3014d96b57822915e588e2bf1893fe2dd2cec098421bbe3873ff5594edfec94722c53f99fd409ed854b8e035755aa9dc337dfea80be037048c4306d9c2d62b5d908df43afd8ed9862463efbb76f9f333e8478719cd6345a4be4dd1d193c3377205a8aee556daa2ac80999d1c36a9a0dd738f06874bdeffef176ee7f075cc2c54bccd6810ee41a3b275fd2bbfe364340defb900e3b9a2acc4ada3fbc72eca1ce4708ffd6b4f0f4ee4120a31493f804b306bace51bf8ee0aab83ce59d19f25a5ba9fa404faf4764e52c279d7e1027ad12807ca2ecd42af8ec798929bbdcaa0c8be047df8186598b9e2c69b0f2cbf781c15c4aa61576a56929057ce1ac043bb655d1ae58454204defcbd67225294a6a5f401eea327718edd9e5c3db0ee0f910d046da73f2bc1266d9b07105709d48b544760214e6accdc432f83e2b3a033469ae2d74a355b19b85a292a7d42ca5f0a9b91950151e28e200383087be7d8d397457136ef9911c20c63d579bca1e00557ee1b1712efebb0f7b856a3aa91b171b56790e701c6e5b75592b24f14f673856d5c044b1b79f2245537abc4654186c8708ca17dfaa75e8c4da07bd1c25ad9d8a43948b579b93568da57332c6683280579165c31e82321579675d24e19bb8997951119aeaafa82eeb5c0a4a335b34c2aa6921531cf162b81c6795c578e1b38ccc1aecaed227e512ea8115428b858f965f2d152a6c82cda5210105fb6db40df695fed134c30f71a8d06b6933b0569566cbd2c24aba1e8de6ffa68c6a515264da8934d0aa1cd65d489e5baf71b0a6e2ebb94244fc6c769420a408d2cbdfae34648e2829f81950073dc737419502edec1117ba662505d3f64ca15d696cc94cd1d9e865dbcfe5a7f5280223a4c0553c5222f7e6ba5940b0ac6a07f087701d300bb0a216c98e35ca2d5cdd26db03e51fe3527d657a96e185bcc844c237da80462f2e2434429ad4723c49756e19009c5e02a2b264f5c1dbcc29597bd78a4199af1548dd9cd5c77a599186830f8afd6385aed1378adb62f5c928f19b64c823f5972351636ee3c07d40cbc4f39bcbbc52dde1aebe910f1099ee6df149dfd7841ca55c632e4f4d372250c627478048bce78923b1849721b093558c983197db419a4bf73d690e260a9328adc29edb182c25645866e30d453bacd7df4b8f23a2d145622868ff4aa2c4debd374681db5849cbb2f250d159f6f1732ad316752936d165f49e2b8d41134a51229fb3b19dced08a918850a0fc6e26462c8bcea500210d5bb73c0e07e91b5272acede24139f9920302301adb1429f3a071b5cdf1ee072c85524d1894c3e3caefdfe1c5b910c2cba3bdbde22f186a3d4c905127d06f86e65e53f71388647793ca1e98a7da3fc8c990dffcf225b57a90a75f82845df00f31c4cf4e9db1c57802314c45c1e306a4fee21be5fcb2a6804ea579496e6a819eaf58542259c1d7134ce383a7f35b9270f7a180be2b1450438f388e0ee8ac281e10877c4a85813448d656f3c3e57e774e05af7c2cbcd747bd70f11a8329096787ef214416a2184453d45a885d7cb9c9c807a45e13d6c8613c27a44a40d81c61f67e6b308ade2af86fae0e86c5f9c5ce1761f35358af44cea7d7eb537068b00cab12cb5865da76228d7b97c63680d3f79992008fd5a715740c21198d2a7c6e24201266b32372ffbac947f437f1198470b5e76899063432558c874c38aaa914448ef50eee2a8ec606d614bf180db9167e1df8094c9252a7e2b320de0a3fee56400f9b1ef5ba28555baf64dc1a2bc4aaf2c7755603c6ea4e26417f7f78a918a048f00e33aa71e15ee5de82de27b3d3847a7748ef4928a49b708c4270f738379974e081b7f89fd1bf75d19714fcf4b257abd00946d5953b459fd5edfff1b80d62a5847e63df03bd02652eb1c06b2e6a528dcf1a0896e73521c8a79d0255d6cf4c045d42ad49365e192d25224bfed9bf3e16d3f80ff1b61bfedce19f9b112af42d8b98bd4a0dbd490382592a16404b249c7e4093aad6deec30b333bbd7aff9fe3c27acf14a5e92954596c7ae4372bdf5d0c5673fef4f64bcf3db4113ba0d164fb4b1bfd14c7146ee36558f27a31170aa08833eb1585fd221f4aaf7bd05aedbaf02d85a31c0cc1b36fae4e516cc8606f77936af0ca7fcc372140c9f6691f32abd32e60e3fd3c86aa4d52e531fff1364f733642dc7a06b5387c4bd8c01d3e43cc4982718fc912c471d2cb2dadfa0c5335016e68d217cfa796eb8907529dee46e4b9b34e47ed2b2d58187a09b1c963818d0e6d106fb4b62760ee7b3e2c39a1131bd42a9683037318d98fa5b95736e2f737bc76c47a4aaa30c34dd9a6ca32c0511406cea7bec2a2e45d3f5e7d74845a077e0605999299aab16dd36bb1b2aae588d05d18835cd55990d4fee2b3dc060b447f0412e77ac5792a896950fd48431697d3f3caf41d0470270cc0ec55d9ddceec59fe01cc5c2718ee5d4830d75ac11020698156ab6d0328a4d69b96c16a30175cfbe24bea4ad526dfb3ae49f6c5b355faee5a00c05853e3072a91d70cf2e02667ceb3f3cd3ac70ed7251e4bf154784d2775073245f67a0afae38b8e36f9da99628e57300a48316860e54487c86689ba252667acb38de5bef49065eb966ecb25f47f56e07e2dc2b6bfdf6c8e6f09c84f522de49dbd74fd999b67363feb3b8e6b942b72a56af68fee79bbf55a1d619b5aa1fd42573e6d7e5566cbb882f32e85f423b6354f8f0bbdcce5b1a1b58fdfe054e0866d250e6de287a15c6703d7e4d4a9eeb4e030a4386af1309ed91a2646cc3fbe2b2d71804b51696f925e01a9be98fb9b5d719d4ed1b56257452dffea3f1e18b713c2c8463ea382becaa09b7cc496805b936c76beacf5b67dd0cc5ab337c3029dcacb06ff3b97306bfe158d6d4ffafee488054eec11bf8c8a5476a5d1095872f08858d94c456613700e8de3c1207d8b2f8a1f2472ca84f76382b1ab2b154b48ecb81430621c928be733578d32cb10646eeb8ef4b3e646c43d9e1b773baaf1ba2105dcd81b8b0a7eb5e43d002da62859e58f55f2896d40e873e9ee50ff623f5e8b24277b3e9360a64e45ce629cf37fc64b2a6b62c50fc7dbc09062b219a3c41f3ac892bded3aded8314f35c3576be433572fdd352a16d7fde2dfc832d6bb2ad0da0d55fff0caabcf0100178f6c4d6212cf4472b150d2f28c038bdf73b2529ce56e885fc64aadca6ec536b919393e643598072ba1fcb78b43d841eed2007a7f195787b7dc5dc2dfe67d81acd550165ba48186bb5e6d184073408b6b296c54e1f80701d2bd69c18608a60060642f2986a1abad09b7b756c2797d80e8fcd2097228f6984602165a811d68bbdf7eed675a0ea1ab051945b032c91d855d55f62204c2aaf5bdd3a61cd79decd12220978acac08e1a27bdd199efb16903693e731d56163b8664d21f15460b634a144424574af29706e27472c5dbc8fbe59669956d354a603a9ae76d37ba0a1215f4be61bddde9a7c39e6a3392285b9240605ffe04c1a0356411e716917c273a951440ddd6207e503e0b4a48769cdc819542681018884111ac79dcc6af4d7bd42c506790f27da81f0cde50c8bdfa5959f783c504157a4b428b9e0bff28370e46d42755f40c606da7fd1df71b510cea0e412b745702853910e6064e30f4fcd0d262c104dd2901d6624e5975e45f7bde67793006a23a6edee5a4c38c60b43f79b844d9953eae7aea91da5b2a45c722d7d751ba26860707725d298391127d8d86aadbdd8a296db2f554d0f4bafcb02c7c93d91da96b41733ad1c0ca1df289092773c3a6ad927998e08b63ec910a83b2b87cf0c1f48c6c943737a5ee7c1eb01e3aa583fd24a479bf566c63f84c06b20d521d27a6e94b2045d55f54e393787b814466fba5d37aca88c92440e618ce0c5de03b23e80bea97c13dbf021e760c97bc16018503aca752f3307735577a8da3dfcdd30e97ca2bca73796b8ff65b9c91bdb9193d260b2d1efe995579f8d73c3686a6df7ae6df6eb7f2364ded960c2ae268283793c21e9bc4d064cc4ad2e2782c6f3ba7f75e5eb48b530d195cc143821d8bbbffea1d9b1d5c6a75a39f2363592ef08b22950893c5e35ed0cb7f56b29009cfa5da221987b881add856f7ea8940d888c1db3cc64c531e64c5b76c31cb8db0f727a732b84d13eda63621ccf36c59f27c2b0e636e4ab6642cac582cec77c1ecbd095764a6b039e4caea5388ace9c3702a4c46e6a983453eb5f264383b562e45c7e7e41986197616d15602ca2d33325a8900b6006210e6d6f339c879cf67a56dad8b4c6b17b264b89fbebe21172989423749fae125ceccbe7456d8aa1c0ef882786144ce7cbd7c01558e44a193dc34c5ea6d6954c15f67b90797cdf0110f27d3385d805e1b4646167186aab0da7507254c511785da9563054ec8aa763df0179fee7fdeb4ad38c2e4dba8e2ddee95992a2706895ac6e7e3b2b17e0254685f7f1e8155254ef9ed936ed65b4f6076e8018f072c9f1d1c24c1e2011bb9c1ad4419772bb20d9431e9a30b7559d8d3dfd0f6ef269b26deeb5e0c976a2bde87c57ed60abb571ae2f91deda6b13baee5a8e50dfbfb06168ffb4ede7a63bae20e1ce58521c2f69947a0208e266d2c817394f93eed33bb4d8157509bc67e6b7016689f7be79f0ba431173fb337aa169c2ad89a4719eef2814ca0f5ff1fd08352b2047132bdc427bd207a2e29b7d82fa71b606bfae7880cf161dae1bc2ce8b2d5865e80bbb8a63055689f0a09cb7d187f60a134af8f47dff1df5ba6eef5eb238c2aa5f2e8210df2a59cdda7a62e2030ecd6d3f7206c238a14b79f45be3fc176c27ebdb38114c655f686cb2e580985bdcc67e29dcdcc3845df7202d074d0c81b8cc182844150cd56708bb46aa57d8143c92fd82644d1c969c4fe3895274484f5a781744b1d92df32d3df56aaf3bd06ff3efb5c6d850c78556be294a0fabf4db7b602773e86d4cc37d6412bd43766a93a8e1d0efa387daffcec1c3c0377d29daf284a79e01ba44221614175f490b95318d85f7374db2a4cd0ba36e43f80857215dbd36a843e93c609612dfceb173399e94a76330e8692028b88e4fde2d8c8072985483dbd4e2acbb9553f4b698dc0f83cb5a7eee3bf13bf9af358dab13a87fa5825fb1dab0bb7378b7528b29e608b6937a04251e480d5ad01e2904d6aa239f8466b7e96bf3a3808269e2be2520d59ad24a3e6701e995c4a9ae1efb2efd8f2e6a410579fd153a2b44939bca4108bf7a572aca5ae0f6bf3dbe5176f54e5ff1e0e982eb655dfb9112d1a467f26360b0fbe517df76c06c2d3661e86f305441dc017a53538f61e3f82f00c161b2e68962c3a85b19c0907a8c487a29e8dc059bc027acde10ab58c612e71d7bb757263fdbe922da83d1af7047914fd2aec163430143ab48e40ff52fd3bb5b4ff137f9d150c5fd4f6261f3e4d5a7f110cf4b7268013acb525e9c57c805efc05b22d34888d87ed3850d1cdd4755d8f6d12487a58a6f99fc4ae27e4af1f91fed3c83f3e6e7cb830ad28fa64c0d70975469407c968f967b51ed2dbe27085c5384f43d69ced06a16990df58463cf57e69dfb045543e22568b464a2aec3950e5208fc3f77a3ff0ec4c46cf724f156906e0eba74ae350c852f9eecf7259a0892b44448a1618e0d18da6366b2792d6aba87ae21271ee38abeabf9273e1a481eb1b2996b0b31e81862ff8b76127cbed47f79f936be8fe521a54a2d10ff55d445dadc22c0da606691366a44ff1af9abd515d6031b7d3252a63076c99170b833e004cbe2dfb47900b1520e3fc3a846f7a3a4ef95f198911a58d36f6070973a7253d9fb09577f66b893f84d8a9498503eaa52e4852ad1078b1782a2afadd6d33f850992fdc5fe02ddae64fdce3c273b2c5eea1f04036a2ad476ce909f91f8b752ae7b57eca4cab203117d6311baa05aa13f3b65e96676b8c83f22f1fe0748f2f1a67db25bac0b0c1db25a5c5cd0a77e3d0cff0580d2b60a26ab9052c9eaf7fd0719679c401e976137e1646eb81d9e431606c2c679dff01c75bef8a71651fc16e0296fe962b4a62c4e38e7699bff031db4a7f65916700cf9afe749aa2e5d7571303a8b353ddf8f2c891f49ff6c8c53a36884c9dcecb0ae0f42c562ad433749e03cc36bb4e9453d1ddbc33e93763fd1ae7d5d4519df90c3e0b0c2c229418e15cb4c4d36d4173ab70590186f9852feb755b53ed3045e28991b21cbd4ff41520c58ce766a83a4972e5a3c634aec970e2ca8611e49952c00869f3e265b0c4fa15b04ac53e1d0940afc816d1bc93d33bcedee10c1771cadb1a3effe824a82264c6764380665062e0b6d23087629c710cd7dfab61ceacc6e45836a2e9b009718b6660be7533424854ed390b764a398e80f98ee4da7c88379d675bbd0b95148f64de7568e00b484de736c10e717c636d0049bf026d2744582f501d49f86e2b55d9f7dcd46a4deed9c30bdcbb1c06028ac014cb08a8e224feeb54e386985e6af9d4f2a410a3acba43580807036d820fa3a604b27d327a12f4f0b9bffe78fa7ee5c994ad08dc00f46c21c019aa846a33fc70faa49a0c593cb7ba957d91dda3e6ba7bc0395246c11b03286829a663c4b9a10cc5ed7b459415768cfa7e79a9c77fd10fd86ed6f601f3cbaf0bd052bc361e8e37d3c5c218d5068d19f302cdc94518e24d7919da8cbe31b3d5ddeb21842b19d32b628a05f9875d5d27443b351d3fd53f7be67f2534cb8b4b0af918eba8e6fe4cde752c700e15f30055a995054016b59b1b9a8fc47756ff3f7f8a5c2e5232b0cd33b6cec035a7ac87bb58d381a04a1957531db253a3f1e034771165c356eae18a16a1c19f1064a257972bf55ad7ece459350fc508d8b910f6431ed3f654db1b5015e86710488af7b2e2faa2dcd192c4977ad9300ede59510f4ab6f4970a02f0325356ae4bb88f10ae6348210e6922b10a999906dda29b160e6e6cedaf66ce59556a32540404cd88a36105cf5c46dc14d405ecb7d99545da249d8ef3ea0e7ae90e84012f5b219613044ac14dc8d15874831e46266163e157aa6250bef74d9d2968baade70858a1b4d298368af202fb14df51294e6c3b36df68a77900920d0d2607a9a6e43ae1c716910b628a514720f1a80182bcf4de986d21a3473e5352c34cb516515880942b43e87cc23dce55b9c93243ca1543171b0fc8abdbef8522271967f777de40a0e3073e2f3570d662a4b2919e2d89df7c25a94b456305c6c8021d416129931a0da08c64d19cf56ab3c11df27d3b1605c3548954e606c38dbc86dad5ce900edf17affb009db4df9a32a18b43fc0e05be386e2f6e0e8d835efd097705d4712a29506f11f0ab82d586b96825ceba88d1aeef2c3a16258413319f47a21368d655438792223f80a2483b7b5af6a85e38dc0beae5f0f7888ce825d508a85054dcd59520ef1c077d5df3e3843625f1b280284a7aa680009ac4550ee43493855350927190991a5122d0280576eb67b35798d5971340fa3229f1045abfa16c6e1e7e4880f152fdac213286c582b6fed2cb120a9c06587badc75d2ac024aa4f416a3a71743a07fccf88edebcfdc6b074f5984dab69d87e0581d7d1b131ab5820ad9598a2f3a8c68f17e35f17bdf5b2a249d451bc47ec906c9493399c991ae5acc22e9ecf01db0e04edbae7a0dc4d25674b56a8027b285b92c64ee35c959117bc92d1cc6d281bd823c5a8411f6f1dc5cee1c7bece120fb16c98aa2a24ac25c4598c29f7c2a5dfb5ac49af4c0aee231b9aade730af1e28e09cb6b19568ac7a7e75425c7c73e58f2a4f4dc8aa04877f795224e8a419d69eebea6fbaba797b3c0f1b15711409e165ead47b66d9d2c4631eed867cf0de47a538d2f67e6994cec087f42d029ab08f1d12b7c10edc97ad24c5ab7e3a43f745b3af3aa6e57cfc46debf6874f849ce0b358029bab36cfb772947b164bdda20af42e8869247347eb483719eb8bce113226113a59965a015ba3ede7c80eca66a637dcdc37b376c4b16f424cc176c7c80621c4c47316da9ec65625de1dae6d6f6f0393d55a5a11ec135e85a599d94b280fc6663fe82ae3b236056551712899e7662c224fd8875bbf7bbf118fe95962c70a4626d658e59895a8f25bc6af54316b04e1644ff42b81d96413e344aef2db9322b92cba6e1ebaf1959190befc28d390331f52b56d6e11ff5a1f3a5e6130bc755d3c2eb8ea4bd83dde6b7888197f239dbad04acb2ee6c7f6ba8d565896758622df77ea134ab7b6d8450dc889cfa2ab77cfb5cca1566acc0326d2f852f5830b927ee6e24c59045a2f16b8360019e926f7d3cd63bba3d118a9c7f4647861cf6ba4997370139be9258ddc89c65a8dc651fa8c23861f6c435e1b7da33e5d550228e4c1ec105164f8b18cd99bd89de21c694e543464aad08ca8eee4c0c142d12972ca561e06ba4e6af7af60fa24b78da24f8cffa7b5ef6331b2ce35003feb6848f2e64b56a5361f42761accbd94df0781e3235894668c95b9c5fbedc21c553f8046411e78ed247b5292d4cf955fcb893d3396e4133ef781d0fe45c26b8dc2e4a1be135ddf8a465cbcd92dfc9db83ee3d3abf98ecec49df05290f8e0d806e3fff6031ed19191b4b97d09e67e9b26eb3c35eb5d71cf7ac196110a5906653a17c6a24e3753d64d851baa9e135a40f3f27990010648b0be9f6123b6687df858e836fcd2793a9bc02b8acdb8f9f2dcabd31ea30afe981f653b904b2f289134a8263dcd0279fa317515b5e93426abebbbee4d871fb3ec6a251a7b67d1865ec7ccc0051856f44a08af0f109b2d3e208526514bca899a38aba741415e523bad6b7d5984d89df26959c15af306ebf95464b0ba3ac9a40f5d60cc9aa57f8bbe44a4de8a12c12b2321bd474dc633b75e076a6475cccd16e349673b1d78bdbc927798360ac04dd9d3e550cef60104933f33ce868ac0b7b8ec4f0b28df113172916952d4c1469271055d316657356d454dac7f0e5c1b60b9541e86855af09ac8e7e83f26fbb17dab5b266563cebb447335f6376b890a96e2465c6565eed19ac7733e7969d2801ce0ceca2c9f84365621ee2ecf898a7d48db539782a0081f66d908b12b4896f9df12b087e64864696881dd1e37a457bf237da57b2db1b7f2eb27c0e542d2f4252b7296e631829fa2b82c02074c2aa831ce08ee25b0a441659c3cb9e6d81ea642c4bd88a97f9f3145c5836bf8b1fb26fe4488fc7140d2a774dac85ffb8e02ec606be514369c719cf2ff2ad3703e0b5a64a789779e4f2d362f0e227072eb768bf2c5d7e95327a69ea744f77ec9b83681b256401029c9bf72ea6ae4f7ad9c7d418377b1358175325ccfb842b4fadbf565b0687a2f0c0d1d7d537497a879009d8c3cc9b091d97b620e3fe69b2c7a91fb61cbb09046f5d14517bb07cff94f7efa3ca3157f505bc3d8897158de12512600a2c07476e8c57901b799664ec33d22765b945cd7f667b38dd73520a5733bbc074bc40ec5246ad33a92120dd66e81bbb4d223fe00763d42267567cd2a4c4fd1631fd75da5ca25e49f37f96063327fd6b28ec7095866fb15e922399755bd37d8132a3744486d96eee963168c15f0a7d4423bd8eaf7016dfdedcafd065f3adb564c54dc633ce0da2d667421b3c5f1961cfcb1eb5792ad5f2326ffaf1efe983dbc9a2b40118610ceac1d4d221c650411042f9c7bcc9dca3c35b0969857bd01b74a3681485f5685853d76b13e269a31f6c8ac3376961ad170607f0851de7c10c523f5fd5a41578b20c6572d48e8dbaa6cfac0ea9b237cecab8d6969a750678caaf6fb2c6ccb08bfdd4305cf73f317d2e92538782efe87fe105d4c12d8d9bd1e914830de53a58a17b0ed518577b020c681b5f5df7f01941721411b681a286e7b6a9f7cfeaca3f8d43d02dbe6d0df169f522bdc339a818c19eb35b40303496e82f4900b00171387411d4a05deb50fcfb5d71c0f8ae992bde8d5233480fc0dd72deb4e03d9e4bcc4489a2f883f22674e7361953b5e57ae28a935c5afa36f46fb0629ae7aa4d0b5416a85f8ddbf947afb6d4550d95fcfe7badf511b609276ffdbed32d210cbcbb9c5f9ffb1ab612d7bced6343ef4e11128e44d58c54092129b740b92d103aadd43b75b0ec205f2e7b28e20051c9dc420e9338d87093f52cf952093ccfe99f6f97d716fd6f19010adebf5af15af59cffe7c4763ed984201fe3c42aeb091ac3be85472dcc4c53effa4e7126d1b23fd0077c16c9f98e847a64a66ee4032d1273fea9a55bbe9e85a1879138adee7bfe928c4b0607c278c6ef9e660066c34ee473ae60b59a4770136cc848ad69726258f58ebed8560774edbaee2dff087fbcea296b3904e05cf9e9c86409a691bb375404b18e91038a07a0484316688f663a588a945c6aae900cdabd7007ee53504853c881852067cba225606c6797cdba58d54be2d22999c3fac9d2bad23e997befd1f704d112fca15226948999a4bfa71ce7056abd258c54462cc8abbf80f4552095387f8fa6cba81ef3adcdc9357ae0bd05496fc9d0ce8b03fe5a65903fc7e1e9c8e5f2eaa1ea306732a34c46a3c2d0ecdff47a9a7463798cc8ca581ace14e274764c58389b90c72797b0506200841c0e2aaa22905f7cbbdccd7503b92e4f03082a9c45aa08456362168a9c271a12209dbd64cc2eb341a1f8749f8535320672b3e0ef65d073855d7c4508d66b833662ed84f8843491c49dc95eac58e79f39951b381253262ea30a94c800711c595cf993543c1bac69f64473db056093cd5f790349ad7ef375f260097c48679193af0c41c58496b15764ed465e53cce7c69bc7523a64505f528e016a7520a5f4650c7aa4583548f6761ef9e908ba5c42b489ba076704fc804a6e1cbbdb4ee19919ede6e83b71d159a9938da38ae6dfedf54db984485cb0b3bd151a45274d45ad98cd55f4649c0f4ff0fcaff0c962f7de0e7f90fc953ef6af49a3348fe9f1c6563c67646f4d8af022e69ba76402ac61e3bcaf43afad6b017464ea6ccfd5794ea18d8864c45c9e6cf712c596667ef26e20ec93a332526de27a6e08bbc0537c4d72d5a4362cc479ca44ec012c8fac928f2c3d67a8ff197f837d9f9412d124f875c0959a8f16c6556f6b9710f46287164dded261221dddbde3bd664b86fc0f24c6e22c53710c840c33561696b152d6fa6a2c97bb7a02043de28daf71b7a2ed7a1d9ed1a7d48e18bc880b2ecd0653658ad7cdf5408d962595a2c0cc0f9563da789a65771585756e6132e7a2a4380ac237f159da50527f6ff5cb249a6d51f3a7bdc18448239d08e78eefab96cac4c0fda600ee12235ce6724a31b4d080af18ed8684c0a187d8729f9cde225ab605c2d323618c5b9fbfe2d0cf5c245f4ff8cefe7910de347439b749af23b7cb49aef0a7b2e70cf292e169a9f6ba48c9d896eb470f75bb6308ad03509bc2ce8b2838cbf51a44981d4d9dcf8590aa82903a48ade4abefb822758f55df5333bffd6525877e1c2c643f55a17e4474f2feb4ea294ba33cde42a6328243877d4fac18139d7d2bf02c2a352b09c321ce55c28ae952feca52be3abdd4d75506716df495298a9108a8a013ca962f00f1c66a6facbf34d3f3b08e524aef7593d87d762e5ccb8896fdb159d499a8a0fb90024d133650469871f13f8d47edf9399f01e69ca5c53ecca53ebd3e7ad8c3259d8b67f8d45f2fac5303e8c396a45f486b77d1c3c776b251c3d88c9e3749a778847d1c1c1074f667e0b7c0cd7e1250cfdc8b61c582c4b30f5174f57d902acbeeb4c2d6768cbbb5153028c5b84b6bf05adb6dd4bdb1eeb19a367bc881d004b0b9e623d154ea580427ace12ad608a54fda7072ab76bd96e6d3435dce9188b56a60df509f518848f119d1f94417f76974dd62beec3fdaf75842af26c720050018c77531b8618f338d3fe60c03a72e6ea9640fd3194a5f62ba0a00aba29b81c1537c85f488cb491689001ed37eef165234dccc9b612d9b814028533085e943e5f81387b2f65ea2b218ae0115313d286b7651ce05ba1123055bd3c327cb5a1effdb15eaec1ff9f91b890aa32dc699e9e7a0bd9e737f5f423b91ed914030b1a2821c144be9a0181bc0e8df76771f36075e8cd22b92c5b865075d119d6ca39c6859099ffa1bcaf97bc30b259ccd55491074021df7ce38647e487fcf098bd74e88cdb7082531ab0c173ea49bad888a3563971e8c329ca3d8c5e262d908a84b63c49ad945e5575177ee3777f2e5567e77ccdd7eb2c34ec925a55389618e61af63ef389c00e4da5b4e485c8481fc43c5bfcfc54ca3d9edbcbab53242089e5f530b33ac228001ba73cc1fee7c9943164d17a7223b364edcae3c952860ebde628ebe261c24fd10a478a0b172b98f16e4719cf3d3442c04fc2907583c05246d6d0e4a98deb9f028ad8ff1b67b32f3b986662ffb80b106d9bba78515d08d6e7aafe42a89f6767f99d902ab08532763f7cffd6e4d591a22b9d55b481f9fde03c7091b11c171fd6d889aa4a627a9abe85b218b1e21b0da2e49c9cc29f46fa8d96aa764e3a047fd12f07503c2b71ee2d537e9863705660d66caf44278ec919cdf5ee00aa49c5f498f00971d1357005f67ee1d6c520b65c87c16411576dcc40c0df03fcbf00d3cd984342e9d0b09dbd97dd1207a12c60e78ca2dc92315a707b39628111397cc676059544dbff751f1b2e973a37e415d8c493f9dde95c8a7e7596b851cf4b006b01bd201f27b3912cae51cc231c0ad056960bc026220ca2047234d4774218a8ef93aa48d03e8a24d0bc9aeb0696a92b4c224077bb204f09f77a9969624a23cb5f43614aa253e75734a8803f1bf36785879b707b5701cae1a9f1afbfc261ce41544b9457385b564efa27206869baa84a9549a253667bc2f1b258d376e50f43f8b57ebb081273d4c121c03945c8f27702a21d4dca3bccefb3617fceacd301248065da435c4edcbc2ca4ada072c0bd6e5e1ba01ad8ef3a3906f534eb8eb7f3caf49d73b9e303f24cccfb44917ac539cff49a43a01a5cac1e0027d269a142925840fa2cf0378768dc60b6b2e5e39cdae0651889348d84c6fcffa967f1c14214ff2344df8dcd97f4f0121e4a514d579dc04180f52c17caaeb9c6fbc0a75815f9ad55a65439355f8005fcb3f86e158591f9722a4be1a9e105ce77edded8f3cd9c285e929dea57d504b34ec7188a1304bec096f9a695d361a65840d6530e0aacae824ffc624e56a534affe1f6137960d346fbefe991525979c2ddc39768f524740521195e42a9ca671a85c9a7b6645018cb28575ebf1fbb9ea1a8080eddf97947b4641b961c069230553063bb3ad90c9a75107bfb5071252e42e8242bfc3bf1b43de0422624b8a2d0fa38dad59460ad8e5cd29dc951a30bda91a6361ea12777800ffe65daa74cf4c215d5279bca2e3041761d65b24154f40b8e27e314ce9e652fbb78b5fb88b17edb3720abd6cd367f0df0e3ec6385de1ca149fa8fe58a6403fd62891d406a266e13c82f01f73585af81c1c682bf26084dabaf2982326d88c25a527765f8bf0f4e27b44a9f6b58d3d41fecd27195b84a1b0b99a521788fe8af6b89b0254acbbb126fa2e0d88c4ff52f4a3443533f4754aa84679113da873ab617e2e3df0f29aaddc01956f61d41c2644bcfc5f1e7fab7253a4ff14c85ea90694fbcf076e602e6de546ced32188767270832c90ccf567ef02ef7452494d9f126d9cf330b7178a25c210306cc24e8e98543188a94b9686c860bd5f2d997b30893444b9349136add0d9b27872b091ccb39b7915936641525ea715367072fa5b0d6b0f0acbbc8dafd47ace0af400cc30a63ca511bdaf64eb971802e4618762f37317882182749dcebd6e81d41ec7bee779c9623a71ecc395787394663734e4064a704acd6b574dd8927a309133b4e16e76d1f07a8817be2620be4a6f92cde85af23339d2dfc0e961687eb99b14151cc30d39188c987571c358beb9fadd6d865f74102f633787ef24bbe58b27eca839155d1573fe3d6d5c5c8d90a72d9e30d4c476680ffe36d289c84f947be79b51c65b7f71d98b77d1c429203d84d805d4dded8e79e9cfb1500bf6eaeb165a4d2efec1064506731974d5736d4b6fbf0cf91538f22a2ac72bdbf2b058cc04b57c25db0f99a70a84e6e39a5baf4eaf96e5b1db51773b65a6c0b76c8488d3b685c7395b0a3bf92e5743b18d8bdf844ad2ef98756816a46f7c787e90cdd33d928ecbeb2496ed20a25b22fab1be8200a5d25b1f399d994a9335a5aaa2519035912759f7f2e28cdb27d423da949e7238774d5d134a6f938c7cdbe734d7165663106d4b2cb59ea18101245f24a10016466b7a92c47ce8bb38d95e6ce29d3186c5b23c0871482dca3ff437ff309eb05d26c8f2af74141f8d11b1033e92f0aabeb8425479577996a0280cb2df15832ed3798b1daf5d478cd7ee8ad4f8c5ea92f98c4db7e5715c0b937733a79ce48e3093dc4d5f5b513a8620eff8bdd70053064238b38d08c119290168cb4bc7d14d4dfe61efcdffeab34ddd4fe1cf4fef27f427824cc6c22adcf002c44bc2b6453f5cd178032d78be42ad1a03ec8f45c45bca0aa2635b933f9640e94c416191c9bf5925ccedc24b09117a5bc1a7913f8699b33b247c4a157bb51214d1f0569756b9a11eb7abc6904356b005b661d15b0e2eecb6b5c75690bdaf5d2b862b2d45b31277a06a6a432581c124ee8cd5672a52ff758dacc552f22a07a5e8ddda0e6c9953704fe6e9793d4f48732eabfe049066cbe0b0f7842e75b60d344a9242559dc95412f0933f5d31a58c2d0a032fc19db1a8331aa9451345a91cee40743e4190a914b1494a0afd74803999672486680336846380f6396edff4b0850651856791e89662aa8018e41c607f74cdd0447f8eb35a2202d1ab6cfb199319853837d17fb8b931b09decefa6b58df06d7133060cb323dbf4f435f09836f3ddaec8f2f7e0705e7c218dc74c9e4060a72f81a08cc5006510a81dd6935545f0af798d2973164f36b2cbc220de8ea18eeb6349e449a7b10adde08ed910574eada16ee883f8e37f6f384f6997dba5c1b527a3d5fe85644f23cab71bca563ab4fdc65a2680b22740257f1021b4bfdecbd336d2e56e5886d8c30b604d682b91ad854f06b469e8f7efe02342c7ed3e12c89fda7286d62d0d482cbde62d8b0b8eb26b8cb844eba136cd1cc10d242b81c3dc5c7d6383c545ecf8005982c9634e1f40efad4a5199c8892a468a9ec68cd5ac9cda1a9656d8ed67c0fcae29b52764d8233b453817300644a10a3b77d6d6f2b5ce15be3a4e64c845ac34d62b0623e97973fdc30ffdaa9211ce6614463b0ca293cadf87a35349fd704b171e4295db019aa8b2090b592855e6a974ca9a2f77c6e8865623dddc5cc6346fad3b118f1d69c0586baa19f70dfbdc62b8fe28dfaf0327c907a2f34913f58a7e273e91dc7f537970b326f43f14321da4b191fed9380c92a15d39b3316277d676059a37d994f9bdd0f6c23f8a4f8fc040bedf31d2fb84c1a7d3f97629408887215b6e2e19bc4d96ee42d999fd51470df71abb2e75f2a1e5fea314c82621c5cafbc5e6e560287d81f5adb263c93563a89c41b96314f450d518c2b9d149a15fa45ae269caf66e140f27ef994db51a34002b2962a98f91c7ba31349aa3e68587bb0695b49932b20fb0a3af9e3169695e41d087f432eaf6bb29ce5e0dbc96b51a9c1cb30b5afc7aa6667cb477a844eb15d157f8a4499c9082e025c69a0f4d2c08aebfa28fddd97429a93ccfe9bbed8c0b9a0804e60cccd9c761d0dd34a6a3ee5aa109c9a35456ad704da891f66f77ab2ab47f14285e24487139238e7f5aae01b780dfb9c682f598b362437504c97daf61280958a4a0abad716e7b63792b4505b44b691e68ec99e7316fa7468f295877cb818b604c2d155ac27f742a3a60e8e8f5fedbc320742ea8d9bbf44682f6bb851e19192c6797a293204aa76a2c56e4d7ca37261dbf5c76f1bcb5fd008c27a35b780fe05d0f804512aeaf7c45e3b4740ab2dc32b9b5be02c008706f63019b910b742e4368e4393e9788462b2d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
