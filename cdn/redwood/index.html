<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5e417a3afd20523af9da5695a73c2eb2f2bab3a2196595e73d4da154ffd97292db0e2d98f79b2cf2ba74d6cf8b90cd3eea0ad0ff740700a419487211ca1463fcf6bc3768a58ccf882f28d93282ff7f3af037ba9ca36b9f57c26eba35d9932ce85ff3a5ecc9da9b3c4049350e9d53ed8b1727f9bfdfe69c42a35d51345aae85c015ab5da9b355276ea66013dd2c5613c22524b140d6f1511e9fcc7e61fba3552f1e01cb5db149e72f6432610946b1ab05a06485124b794161f599ecb320cc37a2aef87542efa77e290e13c3e199aa0c6c7d4751d6e1a262ea708914f255fceb93220040bf39a95943ed2e1cc7299f844879a8278c6e3ddf4432766907acf174e53fc90f941203874a78ffbd90e652290f9827bfca09f15600b81486185a1ecfcf0486e65673fdf3e69110f6a6f07c1a85655f9a17ea1289909026a3f1cc3ffa1ddee8cb075923d523a397684c8c5be097a757d6227b84eeea5dadfd049c5898974bf48ddee0cfdb21522e8a2e0078db8a6b345de35384d859d404b994b9b0012dd609289f2f40dd917f8475c95b982da58444c9df6e9aeeec370cc326c0569cc010296e2fe771c71d5164c303fc47d64294c5845a2717dcab1051581e3fe8dc87455a5186fcb15923da4c2d667992e7009e9913dde4eb9f051478ef3e2f76ce71bfc94cb93f498728ee2e8cdf2c07f8e73fb734205432dad82db4f7e0cfca9e9ad3a6ca8052ffa428a2bdb0d89fe66e62bec75f4dcbe3a5a636e4bcfd05bbc81f7b01ef39c1840e554eca61c1b8e10627b61fc563e7e8cdde7bad134d9274b0b8a32d4473306fd979c3c621d0b0dc4b0901c6eabacd56e9385db333c97a3bffb83890da1641cbe92bea8ebc9199f47bf302df16a21c8c6d6dbf423676f32e3d3835539b4c4f6d76cb8f763857b338701af7c9359b098c673ddb404b744d9f66e15c6b720847c05de82e902d958cae076d20c8a2c2c85e1a6d04a37d8fc9ae6f5ad3cccf8aa6013ab20fe2b3af07d9eba2ddfdc18b8ed577e7ea4fc7ccf86e3d71dbb10e63e7416fb2c079a8e40600a4b3906dd8a2644b9d3974b2c4a50476d4a00027624c505d5d9bcffffac48cb17d7dd340901c0c59b4e6dbf805e0e32d024eb0e432299001394feb9e9c7f9b8249df5de85a3e88bf74fa6c37107dd71553a5a61cce493af6134afcea4fd7fdefca81b1303e2671ad014de5f99c02f4c4a66fd9788231226da0af1f3ab5c7ed73b98d44da3e991fdf48bc5357d1f97c19a13885f84606a8f1f49ed2df0d4fe4ecf3b55b9c254dc59e521038ddad3f311a9f2e45a472701443ca6bc368b2cad21fdd69367841e125a2a6adf84c8cf7eed34d092edd59441d156646fef68d9c69e98df7ecfc7a73d29d609b5af9ff03522d04493905b43d0e567b51c586353d9c93e438a186d740841dd74ae088cbc1d36f705f01d01df664f61996bc1dbeca91bd94950f29617bd24435f37da03830ff6b122d1c1a629a61665eedbb522260f17c3152edb87c45e14555da48660a588e361ce3027b31cb1953329524f3a12ae076e9b7e2b7196f585b5f7bc699dedaa2c5410e38e6c8b5cc136ad9447c80976356dc1217a7468648906b21a3126b5c7f7ddf443708b24703b090f3fc0b8f292b8ae363ae86c116417e0cda5f2d411c1fc8b78f6ec553ab125de5d40980fa5f2a33ad4a9e96c3d617faa797a2c7afc3e36eb7a87ba114508375150ba2f14bdb66d3833a7a0dbc57078024f5f8e12a54024d8b38979a463c254c17ff64bc226ef79cf9a2d0ce3a90979cc70bbd1f236e181b05fd34036b3c1193bbfd3503e906144a2c1e4393d03e8393dad96bd635c0a6478806082131df5d8374299bc62f9af3c5d70cf3a64d7c1f1a083ca52b5e4104a27d9d2f4047df8a622699c1e410622600994af007c6a8163a5269ffa97ba777a4afbe531b4de67d18d2492628753af8ae8cbf84a60636fb1f978e5fd50b8f4656a730f1132204568fd6870a6940694a023cea3e5a4d0dfaf663017bf0c7d8fe8605fd85f54a059106bb2077ffa8921908375b4582bb40b14b21aa535dd5e8a230ba14e85e4968a79b0e37a49d3075d7997472567c2fc5998c43a7e0fe561143db9ef9f17791b1738e38450756f8316865648cba8ad764d2da541ecb03cc8a518c7cfe52fdfd68e268ec049ca1f2b7ab58d82f911c60e852dd81daa6f51e1e5deb3ae1ceccee79e50f841f9e97ace8cbc5d02dfb3850d39a7232ab5a5d754ba1c0a9b5387c14ecf33f08a9297bd273c8e1ddbc61026fde6b96cdb7260a13e9fe781a70e738ac1a87cf086a786ba4872f9e9e54c78198818270440f9e1c5d0581b80fb36720ce3199a163a725e36f057915adbcd828066a52ec4adf268ca126cd43a6fd9a92a3177662aeaa74792e5b4830c6836917a91d8147d338cb7707d415dc8311417115d1b1248a4f5ea7cc84c1fe6c76718c1af3548c485089c2b5fb0a6f7b4d796b24d65265b2621608053d99f0f85e35386064be73b39e3ac0611ea7ad6b03f2afd30640c583200e7ee184dc0b617aae2633d27993d79437a88a5c738821a61b497604f224eda69b520b1747f5316464c32263e8fb2c82149dba98a3163ba5f717aab8e08a92c42a886bfd190f0267e62310f9d824dca945e37e312b28b6883388494e43f8f4beebd70a6f493971950ccde4aea93c1dc560a886636e519c5600b002aa544f68df81113c6a44ae8b5a676b8ceffde254c1f491d5aa5fa5b432e50967c1f05438a86e4f86565686f1da92d25406dd6bb3eb285a995a7416216537755873aa2876264da8d2a84807ffba5287b70f2d6c19281d9e1fa96468fe64eaafaf662f467b4bc9128110103e9da953f28d7a259f243ada4ade69a4ddbc22de74e20f58bb4f31073936a16be077a92588a37ab64541aa7230b866d9646548be9ad1ae15d9e7ee2a5643acc3212436ffc6b23abf8f9ee82c46374d63fc1bedfe728880f3b3faadbd98080ca2bcba2bd0709d7cf68bec5c5674f8291aecf9be4ce300850bcb8dc0140b632dc4a386ac0a9dd695bc37f9686487d1cf82a7e96da22f6b0ef73a92784c95cfae4c8568d8283cbea22a35e15c8f484e3564334f8ebcc86875f4b09bd762c374d4f5fbb046255f88624fc841e7b63188471233a970969cbc24c01ff2647ca07afb937c2a61f635a7e587150d1140df010775e52656aa7fbc77015a7b33af1ac83e9ad77516a6d5702ee2f8cee0084e74641653802600aaea035755a819dd8ad7592b4cda0c35f6cfd05c167f469cafa6b8200efdbab7aba780d01c24d95493c3ed175d40961bfe2ba23018c583e13bede3ced9e4d9b57a90c6fcf39424d08fbf0cc7cb52ec356d9264f23d36158f3c0c72e845935a28aaf639625b4bbea0f08dba01609f223eff964b20ba7fd907726939ebaf1dfa545f3be922781d25231882f7685f1bc3d257c25aa68d1e38d889d9747483ab38ca50f3557ee8575441f085afa658b0c749de61cc998af05c44edd9908e0dd4518697f63f2d5225773aa22aef34d649f53a2763b4b716585ef2836b00664bd69f429a5e3150a65e72f053e08e37cd28e04e127992c399a185f8f762651bdc0b52ad71d6dc7a7f52dee442e7ccebb10e2b3d9343b3f202c2f711300475a647b2bd89da82893594c62d59fece15f1e1e09c95a27b16c49d07bf3942ab8953676b4f3ef30fa7041fcc1f249fb8426bd6e8b81c90ca8fcf57c955ac95f97d5a21a333054d6d148169ce9047476635a3fe63b89aa1d40685be79eabed87df6e4bc26f85cc418b24bc15ea0c14e18e38d0babb5001b060b9702fdcb25d1c53eaa37ad323d88b9ea19fe0a3c31476b10df4a774e49a0ae81af56a35f3446c7f8a0122bee4f6361f503a90680660a0a1caf629f8dee35387472af7d28e57b35470bd68983fafbf194105ac51c642a98cf883232c6f3763ccecf80e98763b265faeca803588190127b515d6ed4bcce8b9b94799c0a0d9ae0a37ade57c9ca7ba394493d28f8f4c754339f14d17e57468d3d7fa296ca1d373cc690678ed61f3153c134584c775b291c30d6415b43a66845a2ee77b4ac490a4820cb34ae66beb900fd6ccc9b0dd1dfa6623e99320f87b8f10e9f83a592e92196b4814c652d1027c7926f89c5f7ab85d1709c5524c698df743daf808d54d06f8a671c64a949d57f1602eb61030a48c828cb7329cac4f5a8dcc659325bed48469427ff44f42a74cf03a3ae71b21cf482eaf8efb136cb5ef94baad1a735a630939e3cc704359482d94c7fd314b3f2399c7491466743df6b7fcaecaac9a328073dcfe2acd1b6402c23c9b40760a682f752b63439bf845b35cd84dbec73b0228a6f00e9d0faf344487b75b562909951ed1b1eab09b746d19917456169b45ad52d9fad0bc9a63b017d12a07930a05a67e6c33d3af972c295704509bba2a2fb52093ddb43ab5d24a34a6391b0bda109110bd8cd59850aa229520671d408b7c6c969ea32e47384ac37f5be53323fdb66625b89ab9f474976123178548b8c1629b258bad83d0835548990a35390e9193dc866ffd65e438becd007e59f8e01753e6de6bcc5899e38b9d4e9cbfe5c974093aa58b832300df9a123d852e70bd8d357a822e527b7403a6cad9332a9b7aee80b845aab2ef5c7bbaed0534ef130db2e2abb26ce918f65cf5236e2d090726d602fdbac4d064ed648c7786c7ef91e25d811f49bc701556793244c1132a3519c000cd7c5cfc7ce4e32fc7315d5ad8493ed05053af988a3ab3bee00c4a88a114e555fa2c63109171c1d03640674f26cbe0f661c7e64ba59bd675081425bc98262043857ae836d4781fad5f720e4e0ebb0470a792cf5dcef69b7d07316373eb8c46109098f051be8821b39d4b562494685bdf3c65833c0d9a8a5723c516696bb406b74e01c22304eed14657d86392214a6f6166bce918fdd12083a3ef8660e9843b6990291def7ad6fcc046c7029d471ca982e32e26aca5362d81531daec61c92face3aed0e4533c203c53237cf71d0fa9509ebed7148f3a9fe96bca6173081fe2d8c06d92e87a748cfa85e3255fd24efd31f88355838f6a04a90d25c07c5d6fb544bf89a2e0ecd35da140adcfd84ed4acc339f317c98cd6bb34507d23f14e4b50ba0b7f8baab8559c3830b8bc897aa2e1991a249ce5d590c6b273f6d9c9986a9d395e7c7541d16a13223d21eac171a501233dbdb24c76c9c6b0986e47075e7e996b861e99314e598bab4b3c922e443e5f715e7a9f51ddbbeaa447b14e64c737a78f772edbb33e8b4f855dc75c150ac8813d47604b89a76dfb5eb7c573cf068e48813f216a0b27d33bd97aee1fd8d1b67b4aa1d54b8f140dee60d18cc4b4e957d446a7951d19b9c11f4801bc0c618bf2b5a570bda719a248c2046f592144e60d302996a913154b5517b09f490879a849c1ed358fb27f981867ab2d7ba946cda6c297fc45ffd7502397729d9e19ce78f182c1de5e707d16630f769a42603d07cbea5fc4d03848e87f180ca6dcf1d078a28012e3e6a6cb186e42f47dbdd7a9f1c9dbab07862e38553e1e69c9ae23b92cee6ffbf38de9a9f82ebd098aea53db439181d319e685e6208c5c42fdd29f86da3380ea23c89271f7552028a11fafad29f6ae82624db488a002b3135379eee4ffcd6f737df54bcd940732c3f34eafadaf153ccf624082924eb6035928cd2e4248820bf4ccf73ce7f511121d1867363f0d7f20e1bf14633029c5a572bd083c99dd060bc6aad60d0e4be7635c68389380aaf58e608cc0a79cd3f5c99e607d737d679925f60b80c06b09970e884267e1581e9f50dd9a7e7281227251b190b66e36fdfc6c1164077cd48931d84ffe562098d48ff8ffe6c9f24f2904770bba0d5df609ca90f212726af240527c454b34e16d6f5e70a473ff7a0bafc099a17e0b0f6297055059a1f4d9a864702f1e6c97f8fb7bc717e6d75fc208deac79b95e971d9e87638f550f305de5402c3d7e48ff0756cab62f6e18d3ce3f14c037f42b7487de0ec218a4e77dddceee3c0d51f0aa363b60e0c8abfaa05463e0f5d355a4a8eca5301082f8aee335d0a70592377215a3c09c61cbe3de9bfbcda5c65116c688bab78364432244ce8114967258af70d0b1f6b4114aa241e197ca6b5d75c8942c2111e14631adcf38f324dec535075404d3700daeb97d9c91ebf6f74d6e0931051594098a61d9ea459fd9f6ad94d060e24ea55ec7e4249f81350f8f8e06d35df2172914dc82f100dd9e6768d3ad128b74163241f167f06e8e1461148050d02bd5e4c30eacd37c01a81c029c32aa300075214a5f61f86ebaa2971650e7787d23a4a0c1553f11cdc85911f7cad4e72e39e9191accde7c93e6ebd80336743fe5e2dbf6dac44711f4cfdd34618e4d2b00a109747f2e1501ac450d710502e536101cac87be3790c01a48f20ce4d4c866de97bed8230fa1dd5faeb13d34203e6ba81e4741139aa910bfd592eea72e913013d3f61a849846711e7252fc0925d4b0ce90577cab09863f92cdb55dbcaa97979b61994f6e02be2ce4f0faadeba1860ba377e6d21ddc0c802204d9dcf6bbd382159fea82c2ddccb6db1bae9d708c1ba2355b1ab01b32c49b809b0a53c616e244e407bbd5b537e8e959d6f9ec9314e8d7bee67eb66cb790aede0b587e142677021fc6bd1c7658287b188122954889baf72c1d813eaa6aed75af5e8bff7e6e33156ef8cccc6d794d9b06a898a82900b27940cc691cae534aa83460870bc8f017e1a892983232a47ad717c8a5f88fe45f542dc4626142ed6767401d9e51d44d250df84983f88d550ded7eda5d967e38ee95baf381408ebca1ae234a16c53923e377c505669b541238554431aa3ad624f765a9605bae33f9740774330cabdea1c058456b367bfd93f239f536a67503807ede332f6256f8d3496367ead434ae87ed54e83fed7a4b2d937b6f655f39323cbb54a440a6251141c6219c1f39a602e449adc103e412bb136a9badac3e0c57e013243ecfaf686d8e16b7213a09fd61f35c19d95489ad218fe94ad3e81815cb6326c97c95cc599851d1bfe058fb535f3d14d25a9fb7e52537eadfb5f6d97c025ec7d03b5c9e63cdb7dbb6888081eeadb3ec305d643e9527ebcdfcf51b9e7a660e4e35c7cf086abc7a3ff1f885bae4bcef04bd4a44ce3fcead3a4913b02db8aaf5b1ca662b4f97546f51fc84ee12c1c4663affa51933877fa3c79407f7d2f4b534faeffc66a23c2f238d01de711b5d1eaa9d1c9ab6f53560dd2589163defbbfc9eb07f0045079328ec62d46e89c54f6c128702b56c0a09d13c28f0bba01ea062a6a4c8225a9d623c84c96ba688ade848d59d42ba051601bd56d134b9b99a8d6c1e0dc6c3b991f0609bd0a830e3a8810e7308a80cfae88591cb81c00be0b67444795e268dd0065f5b7eb8b41dd884d00628e1fff66b1062ad53acd01e6d9066b531b467590dc5f1f51bd82246b65199c0d20889107afb7c885d5aa32607f7d2f10339d253104dd6852a02dc7dbaf5d86ec13a506bb24049fd848868e10431078f5192f64625dcfe5645430ba39e04a5151b945ec175905135c8dfa9e2956d3b1970128d6a4fd073b0388d4e7691e7f07c8be2bc2635534cc3ec8c0de8bb24a084ddd64f7df27cc425edab297fcb5b785d020ab69e104089e6a56e8b382746fee19b969710c25e4ced15b5851aaf570ee5d9b25dba12b6b3edbf958e0c018d60e93d6ee38378fb1515536a8f79a3bc8012ac7a759bcce75a2544f3246a8563e8c9b247f585d566e0cadb80b0c6ec779fe76dded861c8edaef3cda7f2194c08d1b533f87bc4f540d998f626d291bd715dc1fb9c0886298327ef3df9c54424f74198af16bed1f180de39abe32c2075b4775c54d16b54081af487705fd3428719bc0f3bc17c46268deb6f86aecce1957df4e994fc8b8501055b51f638b2f43df9e83ff0177b934b23b53dac36764466088f66633ab18cffef83c597bd3df70c1fc1658bcbcbc0ace7d30b43858e1852f79e47933476e7cb4fff9ecf466bb21be33a9ffcad1683586b70cc11c947dc58ac28cd0d83697757ad57b9a066af835d64759b458e35cc7e03553c0a9ccdfc5693cf3150326d9161e2875be9cbeda650d6a0e2aaaffd800969bbfaa65a07bedf05888595c1e31dbb5e3dba1f8f55bb688ab9a9e82a109212736e0e1122607234bbb76efaf84c24352e9a87ebe43114316bdf0aa23aa81ca9dd6c6365f25ab6644abc09ba502a985281ef1dce9a9ca4f63c5bd60b0eaaef693e877e282cb2e2f5a0f57c2af1634993dbc3a969669e1ca39156f6f536d20b68801eacd3b33021d55b8a7882cb678f7877d35928963b5f0d2fb9b15d03648d33f95d0465a2f5a521d0d5a88df1fd559cb000ed322ba784804b89dd0fe9214203d2e1cd83211e7640d48882585bd95fec913f995fefe30ea89f87d72864e37f0d7866b1479e50adef06831b94a1c0d0f00748731c2ce2e5b70cc3930cd43d863f8ccd617be3875bfb18f775f6de2e7883d3fd5e9afa30d85915aa100b7a59ea24d787c700e68d8aae5db52860b28651135eb85c60a8e576b6c576390d0ac8020585cd14ecd18c8bd01092dfd725c07cd3dd6f6b736d445bad104efe8f6d7c49e9968b89a106f19ab9032838ba136246fd838d7797a39549ca41ffc05806b70c10e5e160303a759e0211c893f4faf4e51afc9489a7ed1383af692bcc1217aebf3756ad97f02b728107aba89931495e3eed37cf8782b0c0ce6f4779afb28825cc8f88d5d63578cb3a9e5c8a3b59c7091364245400a4afbb8ab5f5fa0aed1492427fed36a6eb2b2618adf79b43ee35b06224c0eb9e6a9ddd340627349caf782bb9e99388b2de374b49dfb2688e0c6aee5d35da8289c2799a11d89a70a3dda1f93018c2b95145a1d6ae580878a8edfec38c1a552cd3ee2163c0944c6c1e0a88a7a7a172ed81bbb07e447a8d22d48c0a3ef42844b205d0a1f1382fe33aaa7a3cca4cb8f51df8b6dc7e0a4fd1b071e949a07e819c9e76137ef090ca95751b55a44ade9b5b65814f520424587334127439192874c53dc12ed3c2eb5562fc6f8362ffdbf151ae5171ca02caf8c574386481ac0ee65e13bbf04de1ade3ec7d2b9b06114c7f19ac6d6bf6dbe41ae931065c610d3c1d0342713b3fcb4977a747dc4327e6379125985419cb146114a63339017ce03e0d564ae3958fc2faf28685f9590821fd9db9f658ae0c93a8c4f49a314118e7be09da444f7e140bcffe928ea576747d78fb523905b4968c5dc956811705e55308e3771d4841439d6008ceec43bf94bbcbc5025c92f990b296905afaabee5b663384ea22510ecc68d54693382d04e4a8cd1faef9f3e5bbe17abeee904ddfc569e85f6ce81377f9eecd5d6ed5cd49ae3f1c58afd35b66f883cab121a8c03d9045eee8b65424b32198cc41ae9d2f3af96fa59e8f2b2e59e2771a49bf94ffbb87136357e06b51098b0420032a11fb227c6941137b4dac91896e402363cf5776aab89fe938bcce20cf647cd8c8b839f7155a6e27525152b2e6c23cb8021aa97fd752fbf85aac85a7dfba365a16f78bbbb94620c7e3688c67ff618cff7a4cf96281d8eac5f79368a0f59f62de780a3c2eac7b9bcd1a9f8129fe3f36b6dd30759dc30bf3bd0f8cc527ff9f876c43d3721a576e68472512b42effb42057a524094ec541dbff6e7036f3570aa08193d925f28111cc547cdd7bfd736fa59f4b0f8b8f4430174a4b92ba99e40a0020e624cc540cf416ecebcf0bb50e213120e33f5aa5148e856db69770bd4f077737dbcd21a6bb16670143cfd964b199b2925a26810169f3a986e704fe3532e6d65f6fe85d46e467c3acc5b5f0ff1b70b2e7f622a593ff59b6dc70a6b56045084c043af521ade5de0e17ee2bbb006a2a9d6e8c355c1211ee19101d0feecb0a352d37b3f9c31dcc93e6dafb11384248c5b88b0390c679e0c8f83415c5661e92912d30a182fb211d7b5e4991146c982f00c2b0032a7eee73d94ae35d17d6f5f644a3a9575d9048e800c7ded7ccddd9d6b08d913e9d131f5cd77c4d16e9dc6cd593f0299ed86ed02efff25acb449521e29109e3770693c04bdcb5b91d691ac8c57d2e194cfbb37fe246c0877eaa8ff9863fcb0d1a571dfc94d85fb6e6b92d4c52cc04a16d85192666dc3a04ad5a45902b096df136facc85fece07a357665ce17648f895545564275904513477f80baac73fded15cb779fcc6d90f0352e6360d5cf9d59ead46c2b2ebacc47564f183b5c403d0f9255c208cc311b5e1b6708a411632ed9d263a4b02c4f203d87fb638d3316d59b1ffe022164d98b330a877ae50338ce1736b4260d0ec5d88ff30641e47cda35a3737514b6bb480752e1edac76bab66cc11f749965b6563fa11e117f1c5f3081151d8eb56c6b35d2a57af921bd1032fc4ca4211763226855f6cf8c93769ee5fc044e1120d9f459f97c50d6c8aef792486f02509dc8cf627d4578b1a91ad6ec3d25a3b7218f36b51aaf4d22807c0740ef1c059897f3badea01d1c57233294ffa22d144ddc9e81c6550bc32929a6691c9f5859e332a35dbc5ea55aa6d3eb9b4b504e007d46e65e740a823a86c4a1239808763e480d049f61ef7619c010d87e55622f1900140883e537094be9f1338c3ac1996170299e1aa11bfd02e3593fcd0fe572b9f30e5748a7c96b7a9b54dfe2eebe1d92599e91b8d90e28b3007f9035f61c5d7f362f184c9db78aa0f39a2cb94b381fd12650aa00565973f98324d4228b7de854c3825f35f4dbd41fa7cd6852218f3647aeeedd6ce5c6f0f0d6e00f4df2dae4db706f02009bbcc1eb6ee9e17d40f833091116c1dc68eeba8d81927d3f34be2fe0ae5ead5f5a3b0130c0b5e2c10a39830a654646df2ca555a392d365f9d45dd9a0c623b66bd1a10455bed13673bdcee80953d29ecaf6fec70aa41fd7238f1bdd9b33a1e6aae87539eba9218a01cd15fb5a24a8ae11bbef1ca327e775bf67afac514cbec2a58ed6772b20f16a7902923f02f298dba72b385f5de2ea1890fc61100e4bec3106841cb4d36154af84c2f260be0bde97e3a96ae7fb45e15063f285c50e1279997086fd9df9842a296c131e72478ace954d74423c2c4726cb7a82672edde4886b5845c521f41777894300adbd175cf6fdd30b15976af0627c827620bfd3f26003aa107bbfd6889f8866b16c45137c4bce7e82cdf3d6d41d16c83d466324062c629ea29dc4f54a86b57584424ec7012fd67cc4faf6fca8c3037177b4afc0d44c05567eaa8a7c4bba97f544df85015460b1044977f410cac8b312621e8d8d834778ed0be84b4f7bdb78fcec7752bb633b6913a8a12309edc3326edd768d218d920e0928e2783b20331f0d40778e8503a1c4cb0f8e5add7dbe2909917fd5af6216714af420125415ff8228efc48c47dc373e0f81db1488fb99de63fde2bd40c7b6c4b6ac8e795dcb3b7505863305a6164c2e2106d9cf0c7b0b6cbd92b8a20d01fc84b52b26cdaad1cf21dcf9ae3636eccf6fbc26efd52c6909fa125ef65c7d6227de6a2b1f4d15ebec7f8744a620e53e37efbd18c7edee6de67c7fb855fe066dd0a6787f5be61c25976469c188cebfc2ac8eed07b0e5ec154db6e0e3b6c71d51d82bcc55c23862d0d6df94ff6e67f26463aee10c375ca5f7fe2587bf6738acd1ac8add38aa16c42c14443f45bfacc17a534003a454c481d8c703d814fe580c86220c7db0c295d9d54b304c81fd5e8375aaffd453a45b8492ac75b1c3086827283cc29383bd1d1467225c880319c69051a207e945793ef2d6d6b25361791040e7a4b218063df1c97c785df6b2619f59f34ee63537db8e4208ddd9f047d47ecdb99f7f11f059ae52f398ca587e37f847a72e3ae1e4f175e22e4b566dfec07195c2d7b346deb7bb715f43be544e865e2572b621ba80a01584ef1b74f8eff3ddb782d647ad7cb4174c9d2dc589820ada460d2c7e8c4da3e070fe019f93715d6ce6773ed14a456397a604680513bfe34448ba4879dad2eab5813d6fb8f79a55818141c3a5ed822cd8739a7c8ff802e3259a0525a0709651d0ebe80b89351cee502bf1ff86325bccbe9f9d67aaee56c8d7fa18819ac0b635226a1c724ff84d6d2564dc61f9224de8a1e6e70a5e8256f0ff1f50da250f1e30184c1d8a298da63c01d08d50a3dccc5647c2293a98a874b2aae4852ec863ced8bff96c0e84314c02fd6e34a2c389bf0fe03dac961dc4e4becd6086ab828a28864ae8e8c01703a05d0a24baccf5a0072486832feab8de22280e340a2d5644deb8b28a8cdab32c7966e24f9f36050391593673a8541a9df010d31a9c0e0469f81d2cc9c8f3500a4db711d7ccd9a317f100ed235bda5b44e416da61cfcd8e4d53bb344c1ec942d505f95fccc5e38a4568be998b68e1e0dacb6c4cfcf0aaf28d0fd50f6b7c1df5b6d2f8d46857ae65d65133047978296fd425642c000b608d276fd46c4a2af0294517a7c6b949dc2df440851bc417a69cc33cdc0ed63aacc5921e171f7d8008d05ef9b0e8a689801bd4f6f806a1e67405c21d64415b6ef9349a024384823fc18b7487f91882cdafd20598f38a0dafe6e9b5a69a5d2ec72558723f00c4abc3c779c4e5f32971c09b42b1386ac60947e8e404ff0e5894a6a6a84e8178f5330b97a95acb4050c146acd15769445b821cca802ddcd7e69fdc250f23939a880ed9b8b17d512dc6940e5870afd665a42b0d4a5d54abfa534e917a3e8789873d993d06119b16371d47577ad66a1d3e9e7f99c497efb7c3eebc552c6c703a78ce333276b4d8ca98f1e4297d86ce858378094b76376920e0b024e05c02e64ae95cbc81216beec739ef8e54188d7f12e199c8b0c5a93fa4c88591a49701cb26a19e9ec5d4e7a8a9c5de20b9bfa9b3e99e216d4fe7001730b05f5ccd307fb962edf44bfc2939c29976adf267fa8b4a56d133f288a9b6bfed718e8b564fd269a11bc8e38fe05e1d31aa2ce85eaf5adf0573eff37bbbc49b939783222f8a9ba1434dd6e283934ccb2d6ef3bd49f658993a9a07db479147206a5db362ded341ac7089a298aed56c3e18130b8f99ceb566ae49c37bb2ed03f75468b268f7e939063b8328ad31cc269674961504720c3121abb8fffbf61cb741734d418aaea02f798d1b87565f67b710039c187f78d515e38c57fc7bb9df3bee4bc9be395ff134c84057a46d554c4b019d41eeeada76ba0cf8b62305d7318ca77638e3852aa5c98d54dc91928a6601550c523dfc3a7996f9ed21db78f2a5ebead27bcd28136d0b8cedc32915cd12d4577804a73ab11092a74814a456340fcb0a7d23ab377a8bee07f9866d0a9c295aaf9f41845e981511f6c3c4b736778d24ba0f62219a03492c74be7386d70b332d111d729de8a1c992dfff63d16b55fca14002bb9cf30428aca794b5bf832e21eaaacf0bd45e1990dd02a330b8509ea43efd042df1ad842f674cfba7980bd5fe02892321599d907496dda4a77e44efd3da084524eef7db904b6cfa6be56c825fb5e83d5f671036704367b227f3c119929b1b7a583aa4fc2119ddf68221f3c4a30c39af9571be93d38cb2cf43479a1fa339a5bfc8e42238c97e9c4735d9deb0b41c5dec67b5b7db1bc35a352885bee096e0bcb983dec058623ba35577b74b23c51b91230dbf5b2ad7edc21e9e6f54154bab0f9838333ea6aad408ee22272c9e8c64cf70a2c5500f1fefe0163d1474857e8a17ade8154b5a3fd6a101dfdbeee9b66263f96890a2001ee9af79835047a27fedb7d92fb7a8ed0a331e81b6eda5e98200ab385e0619d85ddbb6774eee4d1928b73cb02139c1ff1af7b498f061124635b5b96a56b19313d8e22fc4ce94f83d2e26606c48743e901b97e94b51161e7ed15a37c411f984fe223d76d6814c33cc8157077a977b3cd2259df3e4679139062559997b7719be771cf889aa00646f34a08b60d0dd054b5eb461d67e95f38f58bf331ae0e196338f494082396f56853eb91e839480547a26f545c37ed21eb43993c290d28dcbdf0376a294beebece2f032e9b1fcff7e4371f102a80a016aab8313c706f419be1e2bab45375281717e310eba1194566512b2b38c3207bc6e258e7c2743025a0d7aeb1da2573e89f195f0c84fd05abdcfb6618084f26f85de950235a9f43a72f5dd9e690aa7063b14abd23518e3da6644b77d7e1d3424eb2066bafd9033c9d12f376b0a165de87cf5839cae592e0c9006eaf1431a28f9b3460e238821b25178052e126ea25e9eee611cc89f634835a79e45f9a07306ad1786206af2c7ca99f8a727b5086861ffffd170ae81b5f2f8fceb330739eb7cfe09133304251731c5d087cdfbd5050edb27f9b11ea2a9fa298d3a187d4909c958cb397079c1ee05d623566df4bd3fc8de26b3629236b4f775e6b51e965b53d02bc87e6994b6c169bb18f6451e4eafa95b2d17ee42701d95958172d1cdef7e566aa01eefeaa846bf9731e05bf0569e7a5fd6b1f9739f216b7b7c311339737583cc41fd201620035533adfdb46828e7e654f137dce3ab3e5774c80ee1d71797e031865f72a09dc58dc64cb1bf95a4f707fbf4465ffdc34543d17e8f20278233eabc3d4e7aa3ce0d462279c0546a8402366369e123c0f7530a828541bae4354709d4ea684bfe2b2a434abae334b96de9fd6f6211f4a60538e6e79c0f7debdd349155f41bb8214456f8fbd110a1bc8cee35b20e4b78100ffba7633099d8dffdf767b081c53e9d11aeaee60e3ef2fdd7eb0f4f13536027d6fcdbf8937dc7b8f75adff72496d361678809fdfb5c46efb466b81f359d7cb6d843bf44b13853d77163efd74bc6b0abc91878c5ed261c2ccc71a99d4d6dc99d540b04cab38f2a561c9bf508e468aa29828b23989e7771110de537737cd5107c515311031277704d06a04ed18c52d8dd8d5d4f7375a4bafa890ad4f3cde2a0729dbcda444c3469288d2b95085bc9b10d0fce8b98a7881f8b852b1cb8c2204c822efd898ac04e47e793111e9da0b8d8bd5bce6aed048fab741bbc01350ebaad33cb6c99cf76d7a1b252428d5b6a3db867a564e9bcb1db19f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
