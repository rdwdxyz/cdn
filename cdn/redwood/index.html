<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b56b22924f4e87f376ce3be3dbee432593f8a820aa83a242f75b4bc10029fc70d5b1af3236153ba3c104b15f486d5015c6558005d911142d32780c5eb25d61c6a82aa51fe14db2845af0c763d87e64e24e58f7804d7661726b481791472b4a541f1ef5dc673ad5211f01a14070bc3600145ace1337d1228fb9753a656a82716c95085a45e1f2e9babfd6f8d1a190b47f694cb89f594f2026290771b6dac4f10d57e5629ea85fe8f21816a5661879cb8d0bbe2fc6ccf69165ab30a428858ab32875f9371836743b9a23faf993277b06ba0da76f730a281b2c85f0d25bec32e699d89cec94995f712c8b31c2b5a3b59005a87d1f15a456320d9ee133fd77a80350fd12528487225ce437620fb53ff5bc50b911afdc4ac18fff83d75150e6183f73112ec5efa8b76b3284dcbf5d1d95cd7d70bfff39369804491624689fb7f22780a7e3efe1e5aae68155f359ad9aed9fdf9dcef66eb0740d2b35603048ed705f5fa2385cd20dc726e05726ae69d04853721bcc2d9365ef94996ab054e205c2233403f9adb0d0db828f4b397c76ca759afc95dc695f8b6bf813a77f75e4958581bc54d428d0d067442f2245f87e221f5e27455c4ca6c2c3c99d0fda6460b68a320314970cc536db34cea52114e3a0deabd4f4f7737a064a86143609d485a9ab7c6600a54f33fa931a4dbaff20140493088081908e46538352da9c5e9a54aa8ac0d89f1c1eab59105e7114060417651089710360a499e63cdd8825b8dc4119e3b7c0e5ede7440c483e831ee6ca9982ff5eed75acd9caa6c705b58e9f1d838506c5ed31f04edf4d9b70549b6f32f16bfb18320faf6c2a6c8dc195226d10dcc48ec03337b62e0d3b4ae7f78feb66db085f6d11e2ad899b040c4faa36e104306931a47d8d968df90f7e5a5fd67b6e66b1e8757d3a678b74a0b2ada52a632413b4b6d1dae9ffac220f7fc27f490ec6963632ae68c095970b79535496d817b1f2167f22d6958804bbf06c12b87552a5a126cfef39fdaa482e6b9762db6e54c87a926be416652c7bfc7752f37b0bee71d4e3abd472849362b981f473469afeaceb3c2ddde6cc7fce667a87404d23d438b635cb14910d6e155b98b0fde91241efc72eb24ce00d9e331a2f5954706dd9fc7950ae55aa0845484f7c3d853288f23aa34bd12a5157deb1ba678bc1fa3c20337fd06035473bed52631c8c563ecf1481e86a0ceb73e7c23295b61909271845935919b1279716a521518d6a4620a3a8216d8aefb63647a6d5814dedb1b89da8b56177c71fbfff19409cf7381573f5999d59d6d591ca11097ae8e5a8142a75be3916bfc7cb0654e3d9cdb6412034fe9d748d2cc8e1efd0671e264cbd28604f203947c167f7b3b3ad0edd69d0b52b13a1cc0ea6444d2bb2fb75285028ab3fdf881015909ff6901bf3789fc7801f4de9bf2a00da2d33df4fc953841c1d953cfd7fd28037357cbfd68c1d6f6794daf702e5b8939b9e104fe3a6afcf74220c4e54e37234c6498d9dec71a593df709bdc7c47877e40c12f429abe505150a9fb2ebd68adde6c9f4749e605d60f36ac551f78ce3ac9bbfdaa8a7701b9f5001f82c83e061d5cf2817461074a0c101f8a90a6b5fba68a1f9000fa794eb03f932db0476ef026599242f65f42f70c9dacd007d6961d86c3bca86c2c5529085c5b3c2470a1c1c495f3d7228e6eaf141c3bfbe2dd094f14bf899a8a3f410d41cc2ba824e7ac57e8b1779d305255766f470935d3cba0d17d2dd0e440513eefb68bfebbe8814211737b4dc0a33c65eb6abeec593c9de76cf578f2620afd2298c97497fa80faa60dbef06a9f443a34a9bbd1d2bcd2e51fc5e924326162c7bd60cdaa250483372f8a8bd97948d412cf1bc60aebeb55176e03a7694e610d99e302e8c4c43715d2a857d90ca273fd4dcb7b050a29dccd52e9fbe28f9fda1904324e2ecdde718726692d8d6dad021d95f85df8926647239114bc09820772b713a190207fa2d6440a9ed4f1dcf06010d137d371ebf478456f4eafe7a327b273dd3c09d607277ddd11edaefe8eeae5652af5344d5082c840d9bf9e1dd4730cab52e39364235c31584a6acef6f470ba0751fbff0ec4542e25647e1d06b8dfd24909780f0e893ab735a378c309f04117e8854297588e6bb7b3e44bb4caa82ae181c9d3d83866eb61511642f3063c2c233dfb1107f362a7f7f5ae8f1e3153e57f61fbd22b105530b1654c6a2be6723a8f034e96ea5c7298a73f58fa03afe668ef333b96ab73c420228a8e98f31087b5dd9b93ad164e50d9af04fe0b180fcff9666a76e8a422ac401fc21547cd154e3894b82154e85fe0a1342eec605c2535f39f09ea689bbdb858d2a3d4768be10649e2b7d67a5af8d324319e3cabc0c3b2399b96732031e2018be5ef295dc7f9291623c09e699c1c0565a5fb0fa2f07207865cc8b4de8833636728cc4e4ff9bc29e3965572a9348dcb24378aca1e81e23ae114b921e021e39419e601be1ad1cab506e63ed5c71860b3ab6eaeb87af20c19c121820c619ee8c2f673a3fae48a6a049b6c2de59938913c3d0311dc4d5a2474c5bec25463398f5a3f12a9e80c3ca6b56d9b34d4739d5eb49dce4d5e33d393cf0da541cfd9cbacdc928f30286a7b0c922357053574fc6ac660d08a9af14517ffac337e537e0d0198bf754aa6d0e47a2c570b50e9f5c37afdccd596f9d5d6c3127a640d491b851a77ca2e59ed5d93cd26802d0f374d3a1719fab653f5a7a4a0ee3c588788a8b0b0e4378902b29912234b5b474dac8e611486b62853c48be3f29655c1c97fdbb872076c88511521e43f73f10d5f7ccef8abda348a5b685ca9621ddcf45015a0c07abe8232d9e4c3b6b5ef41c5ea9e92d936ec03bedacddabdaacb2e5ef0e4822f54a8e1bfcaa609cb872e44a4905fccd781aad6fe824ebdc3c8691d845d7a627fb7472f7796f3c9f6e3299b2a740d1acca49e43c2fed598e5ab85791e5e99f78c9458d2a82a7f086f811fb483030ae51047ec8e4b85647354e2b77d84a7630b21f5750665e3d3fdc3e52029efd5c34ec559713544e31288032415f6dc1878c9e3994e7e9edd2f2fa3feb5502be8c030de17fdc75ffbf556e025b80214c487f2157955e2aed2b692e3af06b132a48d109c67dfe21a3f642d485d5c5731ee3cbb5d01b431f514567596b33caa007b21ddad9e719a31359d2db66720ef2809399f193d531c057d01821c1a8c46a4c3d9881d0d7763b25350fa90a626f04d836d15c11ec780800d44477ba1199245f01d726054006359e57c237529f1015b776f57f51e5efe18696b86b88aa8d3847025eb55f8c66e86366cfaa6c0ea8868bc20d5f51dc5165c8d41115da772e03f82db05d3dd6dd093d7cbb3b351785727bca6c0fd9f73170d423c1aa012e6c1742bb8be7357707be786be31712fce0c38243153e2b1343bd3ba3e1eb22011c77388dd1f4b034805522793e30baa059a3fed4fd7a992f35cf71d35170e90c7b883fa6bbab96b3d413f28497ada64d5c5656c796fd4785b207adaaf3356e06f1d9ac4a670d88316aa05b8e666c22ced1640d820ccd65624b5c6c8dd0bce990e27aa482889899e4267cf8fc92873c2ae5d7b98899114521f857bfd9219baf443ad6d8892a2ac5430a1e8dfbd7bf3dfc2234ba5826e126dff47a078b6e1e12fe8b0871cba4c2e6dbd3d2b87be83fc1e7661530bd93d052cd8f42a879c7a3d089d65261d07e15b366117cb0fc65bae733ef89902e5be8731c131ce23358b3be6a43738956c6c1202c57372532fa0245c141a5889083111f117478e302eef4bcf74e21daf9a918c7b32c481fbae89e3d5023dfa6e9814ee653bf16d781ee6971d2b1d4fdb2047a348b57679de7fe5053a9da3cafeab649b4277320306e3de970647d75a26a456577de2a3127e4b38ad42f34392d14af18cf5666b91cb5f49a4491bc3120d12552ba113b0419ea1a33819a42413510357766248ebdb99a0212c6a4d0c12157d8c23f361d7f3060421c30a7f1c0147c70c64cca65add664296a211174c12bba36df5e5bac3f1bceb8cd560f92330e9044a29d1c261012e3af55873cedcf89476a12fc1cabb1f376cb4b585c5c1a28000ca6c8531aa22bcd2379e152099dcf65edf7385835fc75fb5ad4db6404c7b22be624b755539cf73546ab7cd0954e9d261f5e232828e2871424ffd73e06fdf01a214c6129a091690a8e2485c1b9d1606901e9248a2201082005225c4172e1189f5cd31a3c4ce13f231345c9443a505c1b978e83d5b3f53597a2a3c3ef8cb8dd7f29200a8f149d6f496f5d8bae4be7321e40458bb7955d96f103bb7ee8652f1eec1a3c29c80c6081510e2d4ff509cf61335f2a7a010e8308042a407dc725ea0d71f1d1030ed9e87497c262a0a6bd8e9a58c7e9fe8e6783f7d7cf194c852faa3cea4a924c8c52eba53aabe9e022c2b29600279eb58fceb764217edbada11768a76239822c6bb454d1a53a53d1f3c66011b58d43a7725b7feb26dd268435c84fde6e4291222b777dbf60c71f068ca4452b948246d4293e0974bfa86ba6bd6474199eb1b8b5fcd94a570818ce639187552d025e39372b2d321a8d86cb7c7d5b0c26e7c7a2ba780b951f70bb6d99e4377c3af75757a8696c8715ce3442ae0e693183d1cdca64d005fc1614f9078b72886c6621738c42e1bdcc39aeef231559a1ad36368217904233523eeb6976d1da5a48ff2a23673eddc2652869d09172922dd8c14bd513ebd481e7bf9fe8e62e7ea22d8d160d7ed8ca010949fabf7f1dd62ec726962df6635879e6dbb858f3b706f1bd9b03487ff31b61a053e32a48df838b034a5d88cf202f34dd8031b362f9689722bc779de0be8b4fbef56c85600808809bc33ea242ea4507c73ceadab7c8a726a25b21acf27e437408c2282f5a63f9d944ff00aaad05b134f478c9907bc0f7609488240c881fee072f207887e59901b289da01eb3831e994de9a7c602a8d4c513138d3c759835ae6c9f4d3b3ef7f7c3118abf45a07c1351531042bfe8566c83a08fedec89fa42a8e98746fbc90aa04dcebd5ee822c86bd25bff6dbd6b680a531959b3c2e5388d25a9bc1095203e577f5d1b9d6f859ca2ce5081fd3c34e58ae8ffe920fe4ac3f06e32c41a8f43fecb749ae914c7ee850a91fd1b6600283b80874d4674fad7b5099771fadbd8b8bfae38f9f417f7acae4891f1d5dac8dbb60364be2590add2ce5c7051c4253c51aa355f010204a6c2ac6bdcc3346fdeb902ad6bbf820c67a222e8123152658d0a00bb9bf260bdaf85122987ddc2113cf340da767316dd5ea906608e92c12d29ba196fd0ef0d3796c7ee42de7084c2ff5e54db1e27f3c0f8bbd870d5b5efe58bc864a2b76831d827043f976c80c523e3788747701d98bd6e43f61afbdf33efcfa02582b5b43df4c3fa9bcf2cb76a5add46f4f026a762c2f2beea337f958483c45a367a4a46ba6bd498d75397235883943dfc0165ee3f9df86f8f59292f0c4a8d1714e50cb45af96d57d37b401db296c0c74d7c1a637420dcae5603dff67353d2e9b3b5be3299b1c2983ab3e8a0cd13d026e56ae3c6f723a55814962d0a4e1b93798b32d621170c922f15bbfadd91b61a251c58857339c74df46992a3cc93f36d232475c1faecb8435346ffc65f341d60d3ef98100134eab249a946abded8e9c7e5a680a1e598cbc84c326b009b5cdeccdaff3f455d8cbae6a24a2a74a51bdb73b80561f17eb2cb5aea6edb2601e979fde5da47953198ba54444438db81241a0ce3b0e00c156307cc96e5505175a06b657092414bcbe27105ef2637bb3c00979ec88f74b294d45c5ff659d55bf0ed4ff4665f1e99c0c9ae70ecec741b921f1a53cfab6201deb1180fc47346996f9cb20fc3cddc96b4a215a4d670d248da74ba993cb39e61d475bd4a1c26a194a45424485a87c12c65848e0782164ba477985d320c8e9ee2123a2203418734e4bfd5f1d29e90d599706f43b05858ace3d08e4d6d30ddb173485b7ddc8ab9e6647b5be3367a3af16d6e03809182cfdc35362c3b1b2bb335d3f3fbae51439948536cd7aa6c8ff7eb0ddae1ab6d67d071937633c55fdce778a485aecfca6fad6a70ee7f6863dc10fac84acdaeecce28e6486bfebc90fbb14ac2037e8590b1882b7733a1d32271667b6705be4d4a1fae2b663699838621420904268983a8479d0e858244e1e72917b3e64499d2a636623317bc813e3e4d314d9ed102185309cf4e21d19756d97f327d232c8fe96fb4312019df07ac8a8636a30b3a7b4a6d532d5d32d20964d54adb873af63adb5c2302a832ac819ca9d3fbcf76226565ad06494f8da920e4ec66b3909d43a895bbe8f22be7557817bb46e613cf14888647417095a70596c83680117fc4e10d45d9d37c11c0d77d3d55e7cd008a5d26ef8e3c3b608889a24db534f2e8fb79b97a93bb5af35f67bde4a1e58af5bb0865d5153725eeb746c71d847aca7669fe8adbd14e182c4987c3382480cf40530531a40fa6bec440827a9b374254df71d2bf9b46b0634e48cf8f85d55720eb58ea62b5ce35a026819c1d54eb4faa3ad76dc6b453aba8f883583e1dea8217fdb93624d512dd7f8abe55d7c8884b66c71cd53601cfcee7be6b4e675bd2294885b9618c62f1011e1d8c4719f7830caf2ae3956bbea141e7b4c9262d9672835a8e041e35152d64c7cb1ab52715387b574b3ce7bf048ab73bc819a242a8c95c451f220bb5f12d4d6387e32c7c2fb580baa3eed5c3240dc4afffcc0945ae1127aec60e04acbbf2642e9256e9e954234d658851b39ec005bbb9b022a3833ad67b2599fac7337596f3fd3c9feffe683841479d4b144ebb3129e61ee73123411d9647aa3825ff124e45eb8a5bc5c8f3c5d1d2fd48962cf061c13fd8f95c2525ae519327afbf17ea4dcdecbde22690b0e1c020675f2ccbfed2257175898efa3897fc968102af488e6bb1d49a8f0e35678c631464c28bebee4be9611309284da4409646ccea65e3dd0e0c70f9908800080d5e0a250b55ea5ef0e177e4321e82d8c20c38c047cc3affbc1d41b29ce1929a4cebadb228cd02623af614454a4657a64977caf1441e99f8ff0d61a33d59623aa5c16d854021efd9e89f2406612ced80fb19ea6c18099ac1c42628aa72d7e1352e5139387e08db8378cd69a066d8011c229d6c71d8b74080f2a93eba84df045887f730a62f57755747093583db933c986c2359f82c487f95deef6626379997dbc3d060db4e050cef25735474b02aecab83cb1fbc9cffeb6bd7d68c376b9c0d3e3e2692c6e8b9b425646942e38ca9447fddc370c946409c6dc689b4dd6096906c0c1bcc8b8b0742c91144bf7afd250062995eeed633d44d5002849e951a841637b8b01819736b52d6690f019f1da2cc8958300abced7ebd559d1c496adc67567475d6a03f1307558a34fdd317ad552911eac3fa17839b273149315429298ad9f68df160531829e8fd5c223f376b9507f114f2294b791ecc9aae0e470e4f11081dc0f42bc6e9b1bcd0358b191f1c915599b1642fdb90e0f15bbc01f54fc57d912da4ab59fc32780b2fe3a6ccea0bcacddd1a54acb18ece5ca3692ef23e5b18a7e450e3ffe738fe2630c22009ed91c4fab7c9ad280408620c2b86e32eaeaca1dfcffbb0f7c75db83350a6e35c871e8066c4d7c5583963898cf3cf9daf0e51dfaf5e35535f63ecc49959e2cadccc5b867aba6b43daad34cc5f65d0ab8c705ac59aaccc34869db0dba25a4a0e7cac523934af6582dcaf854b782fff945c96c097c9a154474b03c31718b5f556a4086dc49aa54744a3d35031899d42c11d9f819a10f8599811a579b6a4fa9e91fc5bb9ddb146eca5ddbf6699b8b4e978b09f023cfe736fa066dab971a4456c85a77f30652635faeea261464513ec3e2a4a11fe65f081fcf6ce5da92881dd2de7e3ef3134240bc0b2e8c014479c68d43e42831bece7c312664104cead98c59bb755f4e295be557184eeaab514282e99b4d9da25176f486c5d46dad93f349da2d47040d3b89736f6440b6485dd26ce90287cccebe157d9c29ea6de4cb90b78551bee958508c0c3f2e0a41f6b2dc8aacd4084e926529d56d2def1a239eba914cf65fdae20a0e305607cb134d78a00e8ef5a64ba8dc4e9b019a92268f40024b8a628286cf2533a7891b17c755e0d10e4c648a4f8dacacdf9517822218e167cc3f78543eb1d3ebd5c793dcf9a6deb987536f8d39df9d1919198282541a2ee7a033613d9249bc244647960000efef76531714e03d6a4c9f377b01cfac12eaba5beb374450492408bc3f7f49095904f04966abe4a85b74d363ccef15df547255487620b0cbf59a88cba8575cd5259aea8c756d87f45ffe713a19ffff576103eb4c99b818435851f613d6eaa94f9d70c331258f14b3487c18c0f9c48cabb9605ec821543f0f3ca2cfe2601498cb252c4a494aedc8360efdef4ef43da8f0b65d82bb850eecf7c7dce14e14f9823c02375cbada0f6fe4ebfc5f4739afe4f9a42f771e8fd1f3eaaef8434b16d3c8ee04b3be9af8d0ffff7e1ac45f7a6d6ceb91b02a48c5bb17fb97f9f78c0296522013e7c28e58ba27d289af2ce7ecd4b59ac975deb4636960b5b6d59fc76a2bbf0adc19b02bb0f5fe590dcad836ba099fb4508939a9daaf5d7b7c40af6807e33c3f9a69edbef33d19f869bb5a15af57b235e83db1cbda7e6d87c7d05837bb2efb2065fd988b84523a8ab8d01c6d7362d50ef83dd50393f0cff83172df9a589f1276b14a6433819f0b4bcd2b24bc1fd7f11eedbc6ca53e9572809b5b4f8707860fd52fe48e0905ef5380932732a2a624a0d731600c469233db773b846115c74af54bf3a14f5c70e38831eae975f54015361781b7fdc095effee7fa832cc10567efcd0d92904674fb8d18ebd4113a31487214fb51213b08f1263abe80fd2b4dfee141830f159ca0a4addc193c04b9fd1b4c4a9ac437622cc4e144e2e9ec08e81991a12bba02c5bdd0417fe4ca72d5d6f3781581858826c5743c70e2a96cf626bdaae4310f5f480a49effcc095c2f3f104c7fd4076b56e4db66b8fcaade4c5b2fb285a5a200eabd79a25c0f5302f93c2872c9e9395ea4269094748feba2066153f73e5348f8b023fc7c8c3c31bdfe4e0fe58b160a93eb1b48e7752fd3594215ff61e03243fa10801d7d4ef2f9d9a1c7db67961ca220f918a022e0212098316c24d287e03c53e21c7dd6d699b15d19bd005b0871d9385e37a51311d7b5bd77838f24be93a0d980bfa6358bc0f9f23c0214a4a962a55520175d2990aee77807f6446d5685fb4da273b45e2f3f12e70f4af8f41017f58460d4b4273164420b3db8d50aa405649e1b13f7f5f5908daa04bffd4504239e6dff49d91729ffc20ea1797faa92addf645520b570c75d86fde6ca664e55e60b678f58befd9b497d1c6aecb8a2550d839466d6f49bbdc2ea20ea5f3b3e28de38be71f7847961cf67101a2fdfdc1ccf76fd9332cf77bc7b30ce6a8de38c996b3537df9c2224f39ce7614aa0c2406a75def405ee787e8c8cda83af49eec2e1de0249af4ba81ef70fb285c56d7a2e57d9408402a1afd341543ffedae0056cd122e6c106bfdce0c82f257c8bacf75233014344963e5daa0883b305c630ae2a7aecaa8869d81a23b4e2848ed88dc7ea4610c93617032a665c82e14f7cc4c2889ff0f6d8c5b722346f2a6126a25c0018803d952398db19354bab56edda0104a69f7953b2d433cd32b8945b8b3d11a1f0aecacce5964de8157d1d66fafe020338998bbdc050429e155cccdca1c19df973226ddcc819b9bf26e7cff3263398c1102afc35a098d8096d2181c8253521d6f82ee3100b257ab675ea7955d100f896712fa1043241b12c4868efcec1982500b78cf253b8295378183be1fafed8b38907e1d0526c06e7054fa682ea25d2ac3fcefd6c2b237d861b3822f60b3c7c638729ab292c052c5ab679cdfe30aa4770405b944eceb88bd6efcbf501c8a8909796cd255c66260915115627ef79f40f52c1814300d5240709ba7be20ebdc7fa2124e6c577d2548423f0f364d94bb7f14c0b2bc72770e92f31beeb20f56d1697b547bb53495e31c94bab2a507db2398ff6b7f3651f1299b2111e44697746786fc585f760ef15207f96e055b98ad620bc6457dab9575c85862826fa6cd9632a701b6d92b9fd560d87418b46ec39d7b3f87580ff49a3e2e60cae245042e03ceeeff1052d7455ffdf83c43532a87b8ef973d2872b9f1cf94957c740b2b026910e4419885b810730eeb07c312ab72025d3a31a45d606003ebe3972bd2a0f8ea4f8c761d69b2ec62ad96cb1ebcdf0a6466d3388b3874808d06f48dcd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
