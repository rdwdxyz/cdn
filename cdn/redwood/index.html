<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7f13623cecaa1dd01e06e996d5f38ae3e2a5bb82fd5ecc303f0b1ac4c0bb39300bdd84c1eca96ce9ed771e3d32742a3c8fd1fd54b17b234d28b11844e393f7958f73f61d33e9b9b81450fa9fc79aeda89255f288e841e9e43e3e868885c37726c5621a3abef94d83b4f64d7c786321bcf81aa5465b603acb6bcf164a78562403db12772e95f8d2c080f41574a77ba383b783bced90ac88af4b44f2acd8516ae895016dbfdc4e4d636a2f66edb285fa700f5c8c183b8a68be958f40bd324f0831901c89cec6d5c78549fa644411bc7e604c57d2e3f149260b0f4e073d0ac682bf2018af1f2051bf70cfff37dc1787578b4584ce76f88361f75307502de8fc45f45fd9086956cd61e4241d40dffbc729333e10141a95b6f1d2901b658258930e39eb22cf20da9891c4de00cbe4ff875f1c7bb31f305a7c05307500278a11d6c2f8bfc146f436a049e92e8946e060c9ad93bf845170183f22790c347e63ca76fd5df3e0ac8246039482a53e244b8d7f935293dd3217c9f84913b6399170582ca1cb7db60e943a7b29d8a58b5b2317d9a69b9077800257f62c700d519019a7035cd8deb4de16802225ff47cd7b235e0ae9fc16dd5b965d3266ac4f67bb59318af06bfd03942a06155898aa578d024ecc202e06cd35a7a21d635b5663a2a27bb666e8e2a5abf97b6a1535182169ce55c7c02409baab79ee0a950e3c3406eb0c522d88b1aefe98028c812b4bfa663077a957f4e403f9c0af316be856d96e62963bea6281f93b39fbe83d6dd9847449ee304dc3c217c277fa06b7b0c42a6cbf0c4cd3a9e4879291a3856dc23ae4e8619246e923f591e2638cd928c591eb63e54b6de3f8b6b83c08bf6edb3e1cfea7307d1b81e1d8f0cf43a18dd95b52c1e2ab079db19c8f665dd09b833202178b683da4abce038ea0681aa5c64f9b9dcf9cf0747cfa49bffb1cac94c78dbdf6ac7f01b31e1d9e2ab38ca88aba4b3c361e0a2fc260dd43f0e60947bb6f6f80f01ea6aae397f55692206fbfdc5865e3b212673ee5919accbf82710303b19a739ccd0f717ccbdda934d780784a8b03d0eb00b8c295fe82a5a3628cf48587a7545e2d72d26283c7b2c2e873a55abf6b5d220ac8a9219f0b3e3c487f4264de46927e9f73ccc4694194be44673ec2d8a5771ada841cb7f9b8b5ae9e4ed8cf7f5491da2f3950ff2da83c7a2b6def51a8e94fcb4e634a1dd4089c24636a98598fba8be5844ebcaef10e5d0558e9143275f466b404b4326fdff877cb70fd342d5d8e378c55a0d90e4f2d13e133a4c72530a8d2eaea9003ebc403bfe4bc137fdb2a9c858cd900ca03c963a69a5b1d5959202e3fe476a18aea874b6b313a91a0e7263afa36d377ad374152051ba93db90ac8803df778b2abcb838ab03984ec1a58eaa7df973168171bc80128bdcdc23e9a4b8b480330cdf60a681144f4fae05fd3289d4d5ffe2a08133f1e8a54d38ee9395c24a19ea128e33d14c160cdcc593373fcd10a199b56e3b40aad343a6bebddbc78ec318910ee5d454e5bfde26e65eb99d46d52bf9e875f9312bf8205fecf5d0ae7f2df095055d0dcb721ce75ce695c16f1ef962cbf7534fa27dae751e9a08172cc62b655f44c9db89731b4cb58ecd9cf7db15c7bb22f4f99bb90332b60ffbd0471f39244a288734a58f870707cd2cb029ae5aece1bd8eaba9b1a1b68449257a3b46e47110f03af6d7bdaac427e7fb3cd7c65ffa05d5cf6c42ce8fbafc5dd1d58278cbb682af32f89aa932b94f647c720c1d2664382602208dc16ef1f6f9943bf684adcc257dfeb9cae691c94e8f6003a9ab1565b3a9b7a6029dad99952c546b0b8ea91db418c07f0711e5548aedc52f4105c3d36dee80c3d2ee37ac85d9923de6913b677cc55e947ae5f304e5532987b47547f554035efdc07f4b850b36b25727ff5fd490e516fb70cab1643ab0f0b83a6f58347b9b0d4d6e157b37538f81a4a0a45d17f8ae731082a2f987162ae1481c6f1d76ceb2ed465d32f3ee1d03eda85cd7a2567b4c4eeaa8016e2e4a47ac8e610a8a9ffd781d28fd630af5982f450473727a4147222a103843b6b7c83be5256c6b7588c8b4ec7ab6941a6290a5011675f238fe7aeca663486872be2df60c584f9fa6f959c5011de7f5095eefa218fa85e921bebaf09f76918df32b377bb644c1d13e7f3b1e86b7ac710767577be3fa7b3cd0443a01f6e4455ed20ff10ca1ff36af6064c50beee9c516d126a1143d7b03f1fb181ccc2e10f1ba886f39edf8c38bfa6ac9722298d48a1eee22fb126bb47ea739ae21faf2fd205212ce468a3b399da7d069e59d1ed6af6760ebbdfc852a343eb461f15cb3c9bd3d61fc69a1a6f5bee341dc5d2a5c1b8aa69d40b65917d8666ed1acf1bc99b8f6f4de6f9930023b5e5fcd927c8e762957840bf11bfb8c876785cc3f44c8ef1dfdd2a41fd1854fe7ac49a00e1e8b6510605dbb48799771dae7408dc5b1cadaace8c0cc9bced781b44881117e0b27c3b1b1ea4cfbdce60962c059737aac80814a5d86654cab1de7ce10eb48d2875ef7f7a00e0b63d892645e4d5bdfb7f7abcea5667f118531610a6c8614a20acbe18bd1d10ac07e25642e532c50140cb9a385b4f1cfe37674e6f9a765d62c370a44d7ec8f8f53e57944b9a5d1721eef1852be61a20d552df775a16f0f782cf125debf73d7646495100e928267b939a0bae57315b1d7a84bfb01266ac4e55d10c49e9fa5b419a0e33a47c1a8f7c9107426786f76aa77f97141117f87eebf56a49312f89965b64906ac5eb77f5ffea788e4bfea6cab395867767834034511009bed9a7354c830cb52d82fe0817d16e69182d0f790bc34feaedd7b9407b9bef2e3a2c0419a5d1917abbddcf1a4532f4ea6f0ed81200aeb1e4aea57939fcef5f57f01345013b32264671e7c86507cbe4ace3b5cedd5839e20cbdc77fe50738895b4f7d192ec2630f1c953a9ac38b0c3ada128da0ed8231904a7bb8f6be7c9729269c491d55683b27f301dd6bf16809a92decb191c5125a3bc62d810f09e9b45453b4d5319b7deaa3ca7c266fd2b53eebc8f6230c9b76644d7986f33912d5d25e452fa9ba1b5ca1aad0186f1829d01c770778a069242229edbc63d62823b1c0c178466df6574b6a035489ee252e2498925485a4abccfc57869d1e72cbd1a3567f47889df0675cf570f33a3771fe0482c6cbefe89d83d575236d2eca7bdc349226673ed36582fcab1cec6bc49207d12a92aaa997e226043c945c63c8de42001f7e94107a37603916ede4702b43225f3e719d8dada7de12d1b768d07af5db1ce77678f9217948ed57c3a8f02ae419e995b36dcaf2c4d3d88d8f5b36e6ef4c14769c22bda6ca7df81ca8bd740f1bbe9f6c45e8c2dd760075a1e5ec558638fe9049ae39c8c76a313889599d75af09d3d4957fed60c7fddcef57f16e732c943857c613cef3934e5d4023a44066dcc5e682dfe41f83b4066517874af1e46b6a271ff130e16d9fd235ae688d34a86a8783d2f5761d9e1b051185964034c563263d30d39e6466185d702b84d0e3f95595740c71b7dc7bf6a27dc3752a285fa3fef42f6eebc3fc83f250f8bb2683339400884017bd61bf291908d015767e0949db432d072d995f3bb52ba0fce7d1097bfd521927d100477ffc6f65338bbe2d0d829b0d2d23fdf611bc5fc0f65974fd87c049ef22a9f7fdff6a7a92bd6a801e73d99baba622a1ff8ba2415f60e0d82da59a03d98bfc9c3a6b3f54d54b773ccdfb6b2486d66e9b9cbe0155afd49889e1a8e3a70ab27697e917c0dbf413ea25197121e89f7eab1628a500d967a8892b848aa3d44ffc4b65218260b66c235fa6c20e4b64da2e6e9e191ee4483b68367280a8e2ee7507f3733ed3e121e7dd302b6819a2145a1f7310b19ba4f05ef6242c3d66f01b9544bfd79f08c0eeebfac112249d4b3aeab5ebed6489a1567f62edbee00ad981a00410d5dc61fc034355bb59bc918591bd915b294b1518366fccbe85fa461de62cfd1450c63315885b2067766fc44d2e901f2a92aec2e19f8b89201de773a0578ec7e7def027945a03c0f87443e7dfd5d2ad1b6d2889fa61a71eda0fa1587c838f1606e32586556c900d2d817d492d66d0f129694021fd1fc7fb7e136d70aee9972c38c947c6c0efafc6ca4310fbcf41d3520c942f2b0db5cc46b77c2ce0c2e9856d53b811540074361fd3b2e0a6ca48e1c115c9c09f6764c1a027b77c90d5baadedde8e2abea7dbf685471aed74dadde1bc8cecd9eaf920fb294352685c66906b83991282959470e3c2d42bf14b35170900be04cde74217c7ffb3b5aadfc19723c306bfdbbd31b6eb4a553a0e542d464cb97b008d025bc5c04c36646a4b2def151e2090b0cd4033f7e510836ecc21bf0721cd56e58a84bd7f31d5d699b84997d23f870b2cc6a1c0d2f1cbbc5fee3c3b95334f2d96b5c29cb57f37330d9eb88ba0740e56cfe278f6d635632b8c551f28508fd2b37cf8f0c8ad07c4b5fdb4e97a5183ad521c657a9a629bacd810b13cc6baa65a0820f351cfb5a7997b815413c6d485298624de8e54a9bf9218a3da642be6b9be1ac396ee533514b33feb1fb311f1eb395e55eeec7ac1239f928aa05aea0b4f7ed35c8d65492aedcf136c0bb3fea5c8912cb16e12de26ac84922cf829a2694166ec8bc6bd62cead6600780ce788b615f686f767bc21a305aa14cf0cdeb4887cdcb2833ce5aa5b4119fc8b08108bdb16e8c6c4e481054f12ff2aabff3aae10b2b8dceaff8707df18e9fee70f641718a3dcaa1c1cba69e13c299f649b7fed82cd7cf7cbddbfac0cd42c2d1b684ff5ef76a3deab5c734dd6d4e21bfc438ce9374d78b4e1ca6cc6578b2d0504f6be53d96e2d984707e9ee6cd170f7c0a7330f6c8a65ace89656466256a99116d5c00c45a0aa5fa254c13f7dbe3c1f84ab89d171b2893beb08084bb7b7c8a4eba572d3b220b49f910c167e491c3034f4d256314d6d3a9a89a80b83ecb22d73afd17953e3027c4b9187d68411cf63ccaf8796e57755c714dda2ff11a237bd18ebb6d4e75a341594c24f7ff8d3d71b1a778c3b454fa517f00d87e6e605c532c9b7ac0f1d8343456b6d69c8a655bc24ee68177993e394ddfbf498d4e68888277d15bdf001b9a3f3b7c89503effabbe36d58f582929029fb6b097d8846fa52b89ceff498d10b768746fb985b15a5345166f980059c381d67fa54a5c3869068902c5f036aaaba8cb1910014905aa42542977a96700ca8e31fdb4e7c2bb4a87067ba6adcf8bd4fece3b4254e744465c04ec6b98de41ab0a29b55230222d287734ca024bed88be5dcc59264e77abb0aed9b6d78cce5a5ad33d969bd81a417a6b4ea5f8468d60a58bf1e0862b11035786accd8e2015731778456ca3a98a362efbbc166cdb95481328958624373c368aab62cccb76f29371066b1372c8bd3b00f5d97b79825c35c579b80dad5b62e3c16cc2ae6988ac860565f3dbda618831d94adca92ea1ca4550dcd2f10c5e6c306c793ae340fe09e78321e1ee159662867f06ccb3ae0cb1a6500b2e177cf2aaa7b93b10a45e59875d29413138e5ff5ba8cd70a3a78aab627ff5c61b28d94f752fb0cc1ef664664e5f05544842d0bc26bdd06ca69c4b2592e547761199754362ea85442363270de55d3d79d0cbbfcd902e6da7e6409e1ca6ac5acfc365e4c158a0ef93fd731b821a2360486825a41a00109d00317cf5cb7d587c1fbc8aa0a274a16218210e21627d7ef245b06118392ec07fefacfc433d8cc25b0d7621fd3dd4b8603a8c29b08fd6124395359ee4398b89de1e05d054590eec305068b250ee3c8ed6f501e9c5da7ef0f547ac9ba448241eb96d3612536d95eaf603a8bcb7471683a5498e25748b8c6e1bd678f590e36ad28067e028a92e7a4f35a36c7694ffaf6a3513586b33fdfd0e2d950a90bfdeac54179eeb4c2cae7fcfd5fd88898986953847939e1c99bc4e01e493fd2bc02dfb01763aa3c58a11a7b3353859369aa54b827a8bc8061d6df1bc80c434f1cc226b12546fd207ca9e62ba0081869939e30a389665ca9bc1a92d38852ff175364062f281def7cc603b93b26e658505f0b0965de17f26a7bcccb627ba98d1473c7f459a7793ad9708fd47e91bc1d82c888717677c12793ddadf084320e86e2a93df0eabb6884e8474ba695da691cdcf839465efaf3f03adfee309f2e1b6a5997a26734e450a1a198fb0a25170ca3ab60ef6caf16eda5cc4a678b2a05897b049060cff25f411080c7dee125df7d9ac03505d52b8965c8a1d6c6679bc545439821e957b484129242a1af2e627319642ed8373d549665e5068d6a6a43a18e2ae71720c32d1553760dcd0a9d5c6d982c79ae9fa0f8a6e2c8890c617bbe7ed978777f21b88a6345bc55cf4e82e29780fd2972fc4e547837bc06c066c3b9ad50ef1ee9cae8dba083498c2ef65af727016b0c4929bfa8c39b3535a89bc749720c27b620100b072a1721feaf6c7ddd96ce4597ddf9911a0b8791c717c398ad6ec062aa52b610960b76f1ef50e0ec2702086909ec83c7594446f90b3852f9a2682c7c206d5251ccace2879b83a3df4ea4495ff19ec61110d4cdb5085e60e00cef6f648c823a96c3fb1e9c3ee19947d17a46d415a946a1ae8f06031616a1d3f4a38d5aa9ac0294b1cc35896f33fb79aef1b583f363f4bd0981d4147f786b319dadb7a9b8a74c1c751cb8290f36e91c291a143af4ee84c40410de9f8218e7c86b09a35aae07959c9468cb4c9e606b722ecde0477bfb509fd9f0c26c7d2d81f80a25619d9c3d9cea6b93f32a7b8c65ee91e0d80b1e570e181e74fff53a0ef4bb24fbf391fbde4e2eecd3b8c17cb5d7649035eb57592bb5a921ae0286eb5ac926187ff230b0cf2548fa4abd6c571c1aced1595ef03db570b6b46733b72cae9c1945e22aa9bd58721c55e705dbe79001f619353ed25e7e6b7a84b9b96b606330fcb3afca8250192d8e7a66f4c9b002cdb40a4df13c5172febcc4e261e52ffcef5c50e86ad1dadeb8e75f0220a5a94c13988fd727a4afb4d0f6c1d6981bad8a52f6320413a99e5e411c38062736de0a0ad63afd3cf7abd16912f4c9f29840f193991843486b971c79b4b21462ae9a26d605d2571cb270333011d0fd3326fb427f224676804034b5fddd1b5a31ea70b85118caec22151049f17f05e4e9d64874214d6680fc0a61d667a06e468eaa667a5c0060c79ef96ecdd3da804e3e2443e4b55d86e6a3d88dea18e2b0fbe093ff0b5ad834e189e103ca66006e6044bc668e705dae8d024524aca249d66de9c465b30fda777b8b8bcce612f139a2f763224215e0e134818e2f940ccd5906e037bd797ddbaac3238f8ede5c3effdb7b7ec87deec0fa2150111987612816329d5ba28121a3ee39cc40bb064c87d1d752e9dc80943683ec705dd116c5c5e625e97ab5bc59530046e2ce101a5207fb7c1e4eefe7f176fb1f73e74e732d86afe2355d09273567e122c79aa496cd14ad79a897f9e17edba8d47fa30bafdd6bc9dbdbebb4398e3039ae847e79bda3b2d61f4e46cade7f675363a1198389c8576232d726d867759873dcabf696d59d6a931d571bb7c4db80566227187e5a3cd5bae1b3a34a566853ef74d06356e48d4cd3c09fd5cce91e3647bb73ed7665e69d352d732f86fddfb4418c7556c2aacb7a97e0682a0a08c9569bb58bc12c439c8634074a35a34374c325295848469d074d455d93e5b85c8cbd108fd2e02a4a266b22c1ebd1d8039331d5d3089d87afb72a597737dd0aba9e1640e2072025a3f1818517d0cda5f9dbe7d248ccab947a775877ece8679a7a2d3985ebaee1344f1519a6d54b455ef2399191a592d2d24ba11aa03e8b58557338b6f6ec17c3eed6f3d2c843b879ad4b64caa10e7a131249c6067da0a7fb1f019fbbeefa6f0a6566ebef220c235691e687f7fc76a704b75e209cee13f9237c3ef991bfc7cf831b12542887e397e1c9eb4d226daf9dab74cade3fbee5c3ca82b75122b423820eda13a34cfb5f2fc6f37d759c6ea930e6974ff37cd111113750a4c8c9418f81f8d42d8650c65238e22ccf3b6612185a7ec34d0768e23d38c804ad5b66c508bf799926e639b471a4c7bb1de8080aa548b03a2c050e9f6181fee6329982a49584040ec014aa5273faa7ca7c8ea0c876f4cb30e1af0f0d6d830ac27e320021d7b7565d731b53072a5284a7a988012f500199ebdcab5800fc8be7f0f9627c5ed26f15a41d4481031590b52cf39358c7d5b1b72f313de2c8357ff30efd5a12a682697f4dc6b1952ae99ffa0ee64499d21a8c2613c0ead8a052e68f7062e44b8397d0d8073b142ec00dea50548f2cbc17eaa4d3e5d2caa6191ae13e2830a5641f4687b1f3f7449408032c68e21e8e0a10bea890e7ae0bb41ded7f2f42c8001b22e75f0ccb2f71c3964f6fbd262402f63507857118a8fd063aae0768c2e381ba47bc6d43d708ea9a1cf8c3a081804b536f0c3cd4dd85655e98fcf2212a8dae2e4bb18487353e42708dc436a0c1d93508c8db8f865aca57a3085a6e53cf6ad907eaea440a995a09de90eedf393ffbfedb5a8d1c93f34d92a112be476a0224ef9705e4a1aacc0f78c0edb5b4551027ee5b415b611441cdf3fedb37a4b96cb5b8bb0a72f9f29030fe831e0ebdd08eeaba730801bf09cf787a0fc4c043349a7ea1b6f1f4ed7c9d63e143cf509c32ff322141f18a392bedfbcf1d977103dac708cb1699b535a9e2e7dd3c2bf9d9bc96c67a8b51bfdc2b46760691bcf47a7de8dc4e8b9675aafba43450e70ded9101acbaa3aa0ab6886c6fd6de44084275e4854a5564fa593a613dbb92bf06be2adbb596585a1ea909f8ffa2096f5e9e5a4d3b08d2838810e5fa5622d6d842d37b4240d77946e63e44693884b664c022491c9cb8ac046953d3c0b9cca63719f96d7e25a238e059f435f43292aa059b2806dd9df20c8ce2a244e782cba8adc6b6f76fde1451a13e174be29bf6eda7fa92d27c5024d54f602c320618d7b713684c0a332a670f05e88f1e2027c6bfa58b20403dff7ab1201f6529156971b3ac145d5058e36c299b9e8f129df766389c02b3af5a2c976bae5862903ed3c2e4780b6041fe666eb2cc19c7058db3d0fcfd7c5cbfc540914048acaf595e6a319db6c4a84202654e4a4814b98e91718e2a814936642036549c0a7053ba663e555e6521721dbe2dedc8eccf1eca416832fe6464a1a16383fb7be1b1e4c3c38dd8db8192268a5c329e31eeb6b68bcb3fd91712e4dd8205d0b01509704e3ba1a83c3d1f899cb113e94999c4deaa7f90058bc80a3cfc981db6495532079ed04d775357fcf5abfc28acaf7467c6bb90aff7be21efd810f61d52181376814667b1f4f4bf68c92ede40e7b469f8107d7bd21d57b2c5298a21fe2d5688686f702f7ce0e18a97ff7ad854514fddd9c17b0369364872a83703dd4c3cdfd25ad0cd41c7bdf89a6b6a06b48d8ad01f47bc3fd35663d63309217de6ae73da4c38ffbd42b1d135c3826d72bc06d51934dfab17b7640a5244b5b94d404fa948fd46cdfba4718de752942c09df3f45cc85f28c538aa1bcc0d3e51b51567b85928851f991cabea19d37cbb5c310252524d3d18b3dca904e1f6c4cfeb37a42d8b65d7fa427f1ae25e31de3bbfae2ef55212b8d691ce5402e2f59756fd04a3ebbe92a71745aee94fc661f07b27136d980fd887a3758875aaeea698e142bc09590a53fbb9fcb940bacbcf6b4c733e4daa2936a216d213680fe2ffea3dff96dc742856f36659f64fc682f249de2aa8a897abd8f696d52f1574decbc457766d14a99a37d5525e7fc9698cac56d07c162718366a921517fc42a9acba7c3771bf8cd3c1bef1b0516fcbd2155361a8d636036aea85f33b0cf01704bcbb55c3b2b391b30e2860ffb42cd4646442ef3206c784fa105b90801257e0a671f986dc1b248e95a4f74a9556437f8af6334b295aea9769eaa26c971118ad92656c96c44cfb89bdab8177d0f1fface7ac0ff7248541348edd4ece5282bb46f6ba4ce56f3dc7370e3b09cd4ac7dbb64e213e9109674850621db46436559cb8e0e6e8f9685e9bf9a95cbece0ade7a813c6b903c785caf5ba6e23e83819fb1c368050d8910e42ed4aae6712d60e35245a7fedd389f3f8e3e84bffcabb5e48061f478b7d4847e9f97b364c24f03f859e03569859fc8b5abb943a5faec00e1cb1b73a4b4fdb8303e4ca8a616b31245f98be97c62b883db61441e10f37fa2353fe4a97525ba5cfbeed6fd2a33ad2a31224f5259a1fee826a3b0bae6810cb6c029b9c69da81b6c15dbd1513f7450635d0d2bb49e582bda46162fe8bf5cd1fda420be7e44ce2039359ad47f59376770587d575e5cce7a691c897de8446803fec661c232aa57c2972a19f070ce53a3cc5b510ab900922ac9687a3a3554d5b45cab1ffaabcb24de1268cca28169d5e3f753e07bcc87be8011230995b92b73138927849432d988c575026a519bcfd187a95e085546c162d2d3c7e1835ccb239e31042db23e0f9efe5cbf80c9ecf94fcf59b08a2c6de66669d8f75e80caf2452ac507692b10feef44d2ceedf3c5fbfc26af8a115d81747bdc1ef49de0bdf415f78f255305ada2b3ea50ab94bce864e7c7c62ce2646f8a0c1d8370de5bd869daee0385b7c3b4540af29b1894b55047f8c58cad7d2857de08463ef582204e710621c63a58faf3d31f104aaa0c404b1a62f48689833e87366b70f8dddff4e5dcfcc7e67bc6b0a01a3b218d5aa9431e106c0c570de1ea9aa1ec8b8d0d8e5a9fc55f2d9713cd0680c8b43a2b958b2931662a6e475491ba37a1ec2c3e9477c32fd3417b621c746a3a4a3ba9748139d170e75f28b8c819259c699a0f00270f9fc2e636ea6cb7b8de796fb31170f71c1fa214b73fde7cfa5de3c9c0edd31dea77d77ae174d2e2189587bbebd0f1225c98cb3c9ced4c1bd8c7efa1fd97493b5ce7966fc27780a6fc9311ce8fedc65c7dc522e1002ca4e57ef068cc7e84cdd9c977b5ea3d9e5cec578b8f09bb8ce1a9b03c819fbf24895669d1714c1c2a1cd753a22a7ce68a879ed18df58d3481376c9f4ec94435b811b9c1589bbe49e2ec1cf91cb0fd990dca73b58fab81e0aad5c680f98e6ee32659fb0438b9abbca489f7b9cbb5f06fa2dd38609a3167ba6da198a25d6e253ed54aa7c3e928bda61880de3a4ae858df1dd0c2432f0371646d416bd0649dd66f426be721be3c77e5b5192d7da4d4fb927f857ac9057b65a37825f14fbb9eddca34ce91ab6e3e51f0351d1ba8e2edc7c656fa53fdab06fe9d45500686e5ab17f51a7dfc9c5d26926b0b5ed765359e3bfd890650432d50efd4b8bacca779557c65eb3a16f40afb283cc5a22bfea77d4d6280dd9a57dbc12533aff5b41948fd0fb488843e144fc8615b37485ae412b632edf0a62bce974212253aa86b42f0f9eec11c97b8ba37f994483be8aad74ef6c883c2b5306c90f7a756109605ae66bbe9c608c8ee8109f3d2082397ddc9358eb0dd60ae3d0f43f998841725f4fa499f6a702b1242074f712b198a7205b27e358a3a7d59d1b024b06382e683372a1cab3c1759039fcda8b86ec5e1cfb3b46f0b3530f16df591e711520f996509e97e96df2658950358d59a70eeac9987e2c76079dc2b067a1c7aaae0f169e753c577596528c3d98a40e6135e94ec7587770e1045a4a56335c505f726ee123640788ad139b232bd743ed7bccef0c6f7f5d6365f9fc3ac736b69a90e0eb1ca9962cacf77dcaeacab304e70eee8b6562814cbe9e861f9882ab72774949829481c45962f26805f322ae4c9cfa33b2af554503fa36e3cb18f5090f6f403a6a081e5c56cf6188d280346de03bba01d08b55a82c6876b4047eeeac31b7c540f2967f96684eceee6614bbe06b6677c9982c57c80d791d8b24c0e7def8100df0039bacc9b88c53e1398b308aca6b8e299e779563668fe48c5a8cb041bae26583b3cf91f847c1b35465405d1a19390fdf34adaebf19833ab0f35b1a6d8307ec176952a502a68b8fe8327ef23f1db856ebae21cb7556cb169a7e0cf102cd039924691605a3651507c9aa1f19f873f3192babce115aec0ff45a90c4ec4cec4b1f792452680716f0fd2dccda1002185b1ccc47ab4fe4e8538da1f3f5130997ab3ca7282eb35fe2b0864e649f0f2728b604c1e612784e90caf86d09b99daec6c8e8f4dc012e58c1194973db7fc36f45bff5dc4db66189c91231e6fbd5160ac368f5d4b7ea4566b65b01e0885e43ee28c630aac821142dbe33ef4513fa1e7dd14c0636b9418308612890fb90e7bf331d8f01068916a362ff11e2df575c39b59f4686a08d9876c1a5274290d66e33afd3da56b68105743698b953d7d69491ba657ade7ceb0590dc240e57b17f9062103f6443d7e0307162ccbfe71208def8bfba2a0eb2abb41ee50c01d0995d7939b8d2f2453e43c0eb769a121974d86abc221802eee44596499e386c7c3427cc2172f78f23747fdbf92b6bba2a96ae754e21012aa02dcbdfae306843c3bd180a4f99bd6b4b7b08c1a28092a33aeaf091be7f743e0f8ad3a80e7663ea0a04778e8cab6d53d914847802e7b0204ea01ccee94e317877af02d013cd3abb9c5db4fb295cf5e890515845be1bb7d8eba4392837dcfcc8bb75799a6165d6e167f44425c374ad94dc69f6285152aaa472eb4e07e2f65d63beb2f814993d702fc65811e6ac0f32f628baec22944cc3b5060161a3c7016b87676faeed60e251e81fab4504978116ebdf9c4de4d86dba6ff1a4e8e0c3ee2820391d4bbdbd381079f52d9f057ab2404b10cd11318d64d94cc0b9e1bc60ab3299603da3feb94376cd04ce40c1a8387199f25710a215c06b6ce3e78fb4dde6cbc7ec263d45842a6511aa7c2d179970d3635a7b54e409d587b8f36c98dee167aae84c31f402c849857f88c05127670961c898653b1e6b8fdb7694fad59a3314465469fba22beea9e9bd681fd74cf85275f667d69d613d7c993210db0751932a7a424d7b0443205d2796f458abc6e200417914fa4a1a773a9dbe3b5ead6d0cf6ba0ef61b6ec0cdbddf1812450559f073c1c3dcbdf843c6fa90e3f9d5e73607886150830383970886fccb586dee13f5480f408710c7a15045ce07ac9c1cb736944897317ad3ce003fc58f080dc978b5ac6ef5bc0b2c3431392bc3782b508f8346b772b1e979f35561d10f315d5b945a41d100b0b5e602f018c92cc02d9b8045976fa8b9c4068f3b54fcdd466753413fdbac9dc2e7f7b1908a13e510b5a0418748ba713a31e6b06a77b0cfce4357b54ec723bffe6298c460f7cca60e9294aabc8a8ae79ae1a2489ea82c6a27198c7bb35acbe4c4d874efcfd54a52b4ff43bb2e9513ddb8bec019050d30d74591571cb76b1a0802b46c0f87ee1d6ffce6690b8b94cdffcd9b8d4d9ec43551e726d78e9d0940f84509e48e65032fab41e405b0cfe98d948d34e98193ceae1a74168d5c4170522a0a5a36c78ad595edde0d0cfac38ade7f32476b9c6fe5a0e9c24fa6ce79ffc8d314a54e8e3ded63e942b489d0d6b3705c5b2006bfa2f05916a3f7b8b29af256a767178ec415b5c036d438cf89cd695e2a73dc6c4af1e20b6f46029b51f96354dfae06f05b38c5cebb73d561d248edd1bed05261c0f2ac9b54e0bff777a0e855a4cac8cafd9f125b01832f0e640dd651ad831ca19dc81dd9905e841d35966c0e3ee9c5e3bd0d137293e7685b7748fd7c7b1d8d0dcd3aedfd0da4faff86f1d0f7df0dc59789537955bb9bfa8e515c27dda238ea752c896a567b3fa45ca2a5737d56a6473b3cc87f6e25274b06986c30f49aff898f55c2e3325d4e1fc4ca9d986dfdb6e471d9ecea710f7c6bc5cfed662bd863d0d6319b4d80226250508de97017c8f1e2a056b8a48be21000db42e23e95538a7bc89d6eed3511430b59e32d9e94a4699b92778d2aeede2d9b820a0b3e7ba23513e64de6bacf32cae97d40aab14389540d0e7b1e21622671d2f91ee4aa5e26600102ebfbf5501a471ed70613017ce30c11763a4da60941ac785ba3c90874926f00a73f7b5984716ad94bf378d4f85811955b8678e2faa752bbbe015ba8240713d24a1d85c985c737c8a763d8e684d3ea85a9305ae930cc2909e728b8aa3a267ceae1b37ea91a12d24702d81698a934e5a6eb774c73d0f758f1c32c593e64b183894f88b2fd9bf5a01687d9b37951246cffed352296ac49033dfdd0290e37b2a5fda31569187c131b837cd09e4715901c30e7b20890acad7dbf71287608e9e2505ee8b3efc91052b336cd712c331f6bc58941909c9982437f723c3499974b490fb5c509f09113159cc7bcf53b9f9be54947e846a735dffc5fb67033cc3fa0de643f8a17ff8b5ce37dfbcf37524fe3583e397d7f5294a31a0dd2da01eec932009a9b85f6c745f4beaac55be1bfc47907ea91bf9c9b03b46327677e18f17db945330b4d5c8aede588be219ccf57885f372e5da0ab3d9d0b7ddcd0d093c00a692736789a06de5488de6d2a1a07382269e429cc8ba26d2ffa5793167e0abf421553253bc9422f01638d275991f73f0dc47850a597431677c7ad9e2ce4867f6585823fb3248df87cf73891c1f30b5d503525f428e36d3e14baf34eea90e3c54c69b6caac8bdba02ca2c14af9f066cba6838c92f1197926fa43baff942a728a0118dbf48503817bd88e6ea53e7b42924d86ed90829a70837e7b02387b323f5f5f61e74cec0286e17efd41bea31d00f4aff7ce4d18778e199859f7da012907bcb7daf58e6752974b39d1cc7ad329aa0e324ac6b1dc68caddf1331880bf1b73437e788fa9cc72eaa4280976788b6c5ada2513290471ae129a984704fcb73743b02bcbebd8bed00c0a97c84d984203eb22fa1d549f5b587a94b013951e3e65d39c40e971663dc54d1e50f3cbf45556fb087a5ec558b721481771c5618f8eaf59b491665eb9311ba98977fc1bb53b610853fc3b88b02d579a350e27464bd1e1c55d55ef8743e2c3ffbf3057e04c44b68ab44e4daa757035126545569d57252a9370e84ee8048bb5ca6383bf78ee63cc7e42f013be485b5b699828c00929afd8ddcc921d14867dd574796df5043e6719344c2e198d6576884dcb83174cc62cee6c497d0808770f35c529a163e3b42aded3053494def7c4a962910e080068126564dc894cc1b9c12ba94a41f1e8e2d2bfc2baa69644ff8a6c0ff1f51317e285a980790e1ab5b2ed32cfefa5bb3989995b710a79a0d22f48fe7a02a79b5434c0e9201b1caa386f50a8fe1879b494b277c38628ca819356b5e5747f482ba4ca6e50864667a216898c462dc1a177d54109c5d023be8a40bb0b38d8926d259fcf05a8d4f466a9ea969f289bdcc806974283004bc33d4ad3db944371b101e7261d1ca1cffef481754a1e7838c17adadc07793ff25f80bc2d0e499033cceabf587fbaf826c015567a9942d53bd788ed6ab145fc49b3d0e0e6d259f115692ed024212c837f440ed187ce0e5950d98b549d568d96568d316802ad72e5211fed4349552a829eed6b360f594a1001cb2da4ffb2c0ae89ea9798980a48718cf8f5592a83c8b8e4912eb21ba4f02f4b10d4dc8944434214094f2e5d969641041ebc6734eaf9a43ad17f65fc7d6a6b4bf4e183d2d101940bde5dbe7503b6875b52be2a3c3d1c75de05914b522bc802e62332f4c6d52c1a3ed0f08522ef9a40f534407c96425fa2e04bd97265f57bf5d7d16339bd0248de083abc9b7546927451e573d0a750e408b62120d33ad235bec30e2b7056d89579174f18913553704369c6d49c1fa0ed79ff0eb16dc21848c693ad1461a4172808b4175e207e6735786a502ef05855e270a52c3ae14775131b53fdd44150c4c6111bb6041c3dd3f4429ab86d35dfb888a9225ca33a40f2b0568e30c13103f9514549c91ea5ef9e9e6ce1d40114bf4a165dc421c09688b2433987bac1281b9021432116a750c1382dc6302729523a608aebd92c787616b7f24e75edc304804f2d85c7b760803320aa65b836fafe6f149a845a219889bff67f5412e37646399394383505deae9e4db6833894e8186b96baf7283c811b77da1148e21ef34f1f237fe917ed195b763ef2d5189e4bcf0e00f5bec5d1996ce7f63ad458973d38892b13bc711b891644260933bba8797511e222d5e1a4d0e398125e2a1251d627384b1d7420fa3057ac611a3b6bf246d93991ede2d1661dc8e4cee0be310431840de2e33f2bf957946da71665c4624a758fd8d166aa68e47bd28c57491d8080d12ff63ebf6b7a338ee36bf23d698ad6cd5bf2e4cb2c3e26e42e541e90d0e91577d23250355bceab1d6f3bc73cc2e74c5c3d2149e15eac09bc570b03bc46ad2436db97d130ee775ed17ec1cf14152699e856ab869d5ed79fb55ee6745b39c0d8026063376a4dc82fd7256ff38cfb473f1791780237cb0e163e8b6ac4b41b3ce5de83f9fe72429373f66b113f6f4bd07238f55a01f0f72300255935297fc9f3b9252605a3fb44926d5c277fd8f4a36468212f0a34c3737c26a80e20072cf03f825c8d08b63e03f5dfba3e6f5c0b1293829c78e89f5623944d0219949d54fad283560389e27be2093001a8cd6476fbe3b8274cd01970d67aeecfe29cd97ed7eef0a34b5191de1126964b20df47c6a5f3a543a4b98b2d3425b025609e96124ec1c7af3be97e48e4c3109cc741023aa831689312a4e57595d6a1e5aa32f8d90e4d19e3f3ca71236abbb5bc5fd4da974edfe3c13677615a264ce0bea1beadeecd54b96158e2688188918e63efc09f73888024814ec628481ddbcf7d61f62c26792513d271ca3fee5be083cfa0de7d82bd040a5435e9a909074897363414691d05666de03ca7b475c26e51dcecd969f0fa95bba385fec92824a5f10837ed5c2802f33597ed30cfc7707d7b738d7179bc418d710df2968b8720031a0b426caa85dd0bbf983e6c42c6b0700542d9fce48d437f7ad92fd25e539bf2406fcb9eaeabf71cdc1454249d7536fe56e0c6ad65ce25f9d4420d92bc7e9c3a64642774c39789bc295bd5f699ddd5fb24fa020167ee4a2629a4a0faac70958863916d70ba8084e6d62ab25fd58b3577a2eb93b285ed6d644f04de87ea9fb93212090a4aef3e0297db8bed2ec0f29a53734e3e27f791ceac0a877bec2c1d60f4af00db0ce42ae2d99d737706daaf6f7acd14738d6220385eb9ec61126f2936f7c70d0f08c50b930aa61a779d9ac2065b615b19d6dfc9dd056c7bf0fb70412b31f93fbad707b57b7071b47f7a0558b1a559f16bba039cf2473736c48c316f572f7e5df4adbe847a8fddcddb15b4151f791de49e05a74d4e9d94af290d3b6ed0bf5dfc2c7e191ebba56490847dd90d5cf758304048529e3a77aca3cb4cf9dd16c039eacfcc62fcb419c2ec10fb8b9dbefae732fbe6bc11da4635340e901e523e3169336f39a012a3d4ac69af11110564cffe7f468a6140954841a66989d3dda1e893dc8d7bd824de8beb1313b0fb4409a9f3c54475030806800ce4a0e93a25503d464f55b1f2ac19e451005a4e708b8f0ff987eff8777ab6c39a867df71ecc45be4b2b80f1eccbfa6e23e0379c26d676555b42e8df0179c568faaee9757a5f239adb5faab71977cfa5682640761d2d6ee4e850c6b65c631124940bdf098f3570d354cca70f8b87888ef8c5075b05d4d83c4d1f4bff348e983939c03e9bbbff58b89e39464b55641b9e904847931974f330b7732c4776543e55107637dd1eed600d8e038d8ba2891d252d011b03e206c808697c3125e1fdd4c440c819f52b4ca0b02d1753bdb85f20b1425e7f1b906dd510c1a143f9a1baaae66a547fb97a75607765551869d59a736bb8a196db658c33ec6905a7e4edcab6f842ad6249a72c6db380e0adee1a5a453b871c2647134e2dc2ae451377bba065ce021206377fea5ebe0a0ea0bdd0f2fc6ec0a616cf13a65cb5249b14c84bf55598b5b9a372d6e651f65a2ece5d92714b748294b96fb14d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
