<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1c1d2660243c6f265697502874841bf68c46dc0a4d16c45442fadc326cac3d94406e57c1567e1b176422062e1a411cba025ad21b4f9d905d6092eb61051b41e74cd9f1d7a6c8af65f6187da07e8285b3cd42c2ae31a9afab5d3c91f4447fcf0bcf0ec448b3dd52c68b66fa66922a28711855f2c8a7d450f042d6e5b4401eadca9b4fa218c53d37455157f82a6855819f9e6ebd3fc48ddfdd3a33341951346b75626c0f2286fa71e63158cf680b37f9caf53fc3d57abcba8ae3752217e1734c1462703bd720d876b0db8934373fe746609e4525456bbacc2e00cd505104ca893c45fe482e45118fc5b8b0adddd8bdcfa6d7357f83c14e6961af443a898f6298774deaa5afbf45feb94b59a5bdcc06bfb4065b907578f8e3e816dc72afe644e7598dccef1b7f199518464d78c40bc201754c83c47234ca4cf0f65a15c72240d05fd89d49da21519c4cad030d2b69f8e84bd6132147fbbe1707a17757dec05ad7fa208424ca9d655ff3cd47267e8fcc9ea69176aec081724d07cddf0a4299739bc6d2a45cd437da6c51fea449f7ca9b36492af4edba36a1beca30a64b75a91ee8b1a795226ac4dc92b5c92673182baba05c603387a7b5f080dafb3a4c3ed940f59c67d04ecdeffe2e0c1d2d4a94114e869631136fbb0cbc1b1a1b6d1363094a160a5a201104d4bc268159fe4537d8fe1d9bf993221e3b2f4918a6618a87e19022d7a15430224e72a84386744655cef881a6b5633e45b5f075ca018695e45fb1d848e25042b2c3f4afd10681e3f749b151aa62d7360b5a4c540c47bf6c6a2b4a86110ace1520e7d0510697113debf7e428bdf786e8a453056fcc1458272371fa1f326cf64b80c6412e7b14c391cae931090d122e10e650963fe513e8a9effcc46908e3b325eca1942d2d78da42f2b81713c182ed501ba29de32f08df6bd4c35ea0008cc194f795fc78c14c8a7d02c10d7b711944ca761f79ab60ff190bfa57552a81dfb1cd0ab87c06a80d82b100c333c86584f78b25f69e5bb8d7a59df0e22684a48cc900a4e4826e187f81027aaa8a8baca107b357b7300646aabf9825b1bd79bd5aba3055c0ed8c77e45323e3a9e0df156d701e0f21bdc53f972db9c1159bdf6e5811dac9506d04ee573af8e4687b5580562c7796f74aab334e7278267ef80263d1c321f6cbd54049794a890ac8daa29f85594f657b4c6be1048d5da950125170e5285c99c980af6d5471476d350b6ad5fd8815a5940799514bc02d565828a973a77758f1f1127fe6723f20b563ebf91a772b0f6037f033d2b624ccbc7e9d55a9e894990872cfe7a3af16fd3bbf26b1f84fee6b40371a4f5cf38acc995f9fa27875c475a41714a130f2ae26552b3235e2ae239e17b3d5fb2b10fe1315f56e6e967b6c01cc7ffa505bf1bade2e5fdb283d42e979c817c6b3cbba0d3653aa791e07c2fc2c1b3ed8e0f6bce3e128d63915f1621fa36cd2519f2bee0041876902d79f14abab740a12cd0bba13d58ed5429f1a504d0d78d95618faaaddb1a0b6b62b35cf49a79e5e1b7e97fd052aeea96ece044e45baec2fd7254d0012b61328dd6baddf0120d2f3ada4243bd5e355803057e79d28f917bf331c142cca997f6d3c0c8657c04c16d555e7cc0ab839d903917c702d2bf66812a580ac6dce4cde370971857d571a2367e57bee1eaffcfe87b0371eddbbcc1eb7eba7f1bd01b05f47774016f378470acbe5cc0027c3f1732124dc086d52adee2576a86fe0d70d0a3f3aa7a0ba3a5eae226a1edca908a5b38494b22695b6ceb5cf9a5db710ca4c89090947ba44cadced4941cee9923702ca433ef7a617980f9aa26fc28fe70e10653ff367ffd76467f649e0c49aba29d35e928d651b449ccb95f9e4f84f1e6ebecd3d1e15c947b6b916c2e5b427875582440c0bd33682253b74370bafc5c30c0d60785cdd9c22ab972fb3d54439a8bd255a870eac8453a26a82226ecd7fb02a890b729689384645489f90b41f634ac6b6b52e419ca00f0d5bed1c648e4a941c38e5a5f1bf4eb74de173131a05f6a2fb7467b6c64a1a5f5263126bf19acfdc2aa17401588ddb7eed36fb1dc84d238e148b6cd0eb3794dc6016d907b68c0eabed11b3f4fc26e75f637c834cba3bb46431df2f685ad427c6af5c679441827564f9bb576ba0f1fc592c28d1e159c43791c8fe065189d7c025d26b20b01cdcf3f87861899bc803863bed89ac7f148b4b19400c438d452c97e1f0a91aa3eca061a0817964e55a7418aab7518eb31502e9dc525cda246f777d6c6a7320e75633c6f495e337e4ac1cfde7ac7f7cc9a8973e67f1226e52527eb8fa6bdcaa0a37fe111ad200217b3d42b8008e035d727bb1b33712b1c3d090557e05a84e7f2306591148454ab9d9627f4dd291e337d752655eec931e475d03e35f9e461070beb4520231b59ba5fb9003d23dcd71a7f93409152db2726540acf96701a92a4916128e9c5b068f0c3d833026fcba8b870b4329858b14b0f7439269c174c46504d0b2d3c7361b8f1ba6ec1812729776d22cecad14faa869bf307d3cb852fea533eedefba7065c3dbe744e26929bc0302c7cb758a0530bcf4c92d862a3fad7bc033442e689cd6426163f1d8f774e6bca0093d3e90de8552fb7c100c21c28670564e40083715b6aeb4a96a13db31fa07649e9ce6d47a138f899676814239bc5b54d40c56545f7df702d043f9375f359c38c60c7310673e1dd39a4a58908b6ce8312de99e67e5fcda54dcf0a340b64b16b121dd9cc8b2a55c3b77b40f8af499f4ff0cd143d65650171fbf91a08666c48260f574b92c980a9aae8520759f108172e2eb37081505d43fb0892b50c465a44717a491cd8a681d8d600c2c3c075930c9c1cfba0b66cbce85c03ce2f2e6744db666d9c985eed585c39f0f40b72ffb817fe4e009156019f45c928a71807fa225262b7189caf8886b444bf9462d81306bb32150c2e324f107b6299d96c8355d02871ad679d2614b5c5fe491cb18cc7ab55e93c0f733a428240bfac743d095c4ccd58a53069394f16d70fd002e467cdd2b97f65a9dfa8f0b571c29ce56708880c18581097512f575e78527255779a2ab014d4df1aff74c016ee9a20113bafb36f2b2f0ee99b92ce0841c1dc5f4b03cb106e8aa021420bc953e38f4afd7a89a25a2007b7b86810af35c50e7b5fd93d311b59a47b4b4c370ebdac171ccbf54643ff73557016e5d7d3de8436aeea68ce038b89593f760cfa7d43aa0619521b76d33f17bfb2ae308bbfd9091d1e20d5daa6ab99f1ede0c1ef74e1e9a3a95cea090107905929415c149a5907f729b7284470f1b6107e39c64174db1877274821b7dccf14a98156a6b21b89f4c039d7b79c95f7034017fd50fbd72cee1669ccaeeff9b0de6092eae3712189065f3a51d2f9d9593844b6376baa03093aff738b2c118bfb90a5fe93bbba0f329fbe0a1fa1f793645b241304b1fec886562d6dc0d3ca98b692f52bbea3b1d4b0bd972155c3ecc79676a98e0cd423ce2990394f261e00327f613c6989629931eb30b643be995caa47a5ee19cee31c929717fa0901428804deeb71fb7cc41d893ed1e0fdd871446e846091952deb77a63da86aa5253c1b1a28c4cf71e1a46f902993d6f05675fac637b49f2947133cf4aba74dcbe80258d8735e7e95988e22308e56c87f5567d235830063450454792aaf74e9c3b1823fc17bcd40facff796a217d6f9e186b79de6842181067469524eaa75af8aa6361b1b0bd302e888b52155c2d3022081a1e43aa19da9a7ffe4c00c58d21402903159f7a1d803db2363a32607010d47119290264907b456f59ab17be4b158f2ec49f06028b94b4287f77ff793abb6642ffcf1dafe02b4262b572535b39516c6d1739b3bb65ba8c46081c1cba03b0caebb09b5e23cfbd00bde4a598167b6b36811ce28b57d6e47d672c3dd28117bf9343ece66baab3f44b3afb7f3470f068ff23957d950f266419f538637cfd050193519d82b4393a6c14c345839f306a338ba372603d3bbbe24676b785fe078ca15063f34bc1117d2e2dc038fd09a1f65237f725143a84cd3f8012883c47e459cd84f59aacaadb3c6feba9bc545672f90391bcc63706a96073b6ffdb1fb7a98df5a2f73fb61198cc9eec72e3cfc07dfa8f9b5e275f24419790d5c4404dd4df6202bfd6875bcefa85f062c8a69c08f74badf00498d32c7165a8eca7d046001fc3af8cc37bef7d17314b73515742cbdceadfea95c563b774ac74df06790280447eed0bd3c3b902f032431920f314ed2ac5e456cd83ca33edc7e61ab093c435c74b2ea274705496bbace43bfd4f7090a6e569f5b3eef6cd95949acb314282bfeecda497e9da2aacd5c5c665b77ea48765dfee9fd2d4d09127f4fb872d9f0b12d96a28b439470b5335f021b900dcbd3dd4d80a552c4f0342da50cac900bcbee7bb0fd702c0226d35cd306e717aa4541dbd62b6157b1ff3abe962701fe98c5146f9d18cdb801320677cbd07366a6473b6f583518d38a4b9917df329b68f4c833ab8b9a2a73ae3cd745ec227e088cff0fbbfe6c2ccdb7020539c53750c5c283681de71951e3e770ce68102e9a2592b1fb1abebade1769323953965994ab9181aee4dc9fc6332ab0ff305ccb91aed0dee84a5b984018b7cd9a2cc15521e71a73266521218925de9bebc6e0d91f398154c6bae12921ac3ed76342f3d6ca86917eb2091b995245c81fda8cf996b7da9d9eea8246bde8320e44da2d75031124260672346ec87f1cf6788fe814790077de8dfaabe526468237e625e8e21ac3d83a78d9a178dabf758df543c8748647e0f73f8e4199a4962abc5a6ef8de4bc185443ad69349a55c3d0b7874b677488beeeb58d245f6def8c348dbf1372f046f8c61556f6890bb3afc67f434c6572a6a4750582901158a72bcb580d98296892dbdb0c5ae9a3115cf4acaf8fc9dab5b9c700cba7ba9cb682183aad27971df3ad348c52122b845c55fe84f830ccf14fb47c50a0af3c6050bb911a4781e1823791c238106e1680de3d9f164ff37a4a68d98083061d85f87b1ba82d61d7e6200937ea0b25e75d9c425837d755154998cd4eb293029ce640444973300b4425df0fda562f762a527fa5e8776347a1e7b329b55dc31399598e4b5f7e43983b6e9952d550ca0e46dd20574f25ede775a534cb9de6ab7251bdaa8d5a8732468b379983c246a237445c1bf61f7e95df9c4e0bea6e07d0a664a5b7a5b3cca6bcf2460eaab2e9fff29d1715242104355bc17dc55236c2a481475d64d59cd0a10e37696ed7a6ab7a0e481bf3c37191bffb1b9b4a4d53492fbbd835ea6a48142f1acec67e60fc9d7c9a031b85691bc439b299956f52f776925c9dd74e8d56b8df423b598db9211caf25eb24e62910eeaa09da759309ab91a131c89c36f8a3d15ee4bbdc756ee6df49d269df26e459f4c8a3e28005f0c6bb8ae6ea7a0a435488d664a3f219543eeedaf5852dc2d0ace8149b8a470ccb518fabfa2782d2f45e0e5c1aa0d7e2cd6732d72cb51f3c629e913ea87bef8cbcbe488cd65be901b25e2a33afe051c8b8de3d7a8a7674bb1de771abc2d2ebdf10a2e0b874a186bec762e8f6e31b464cbe92efa0b705d754ed73a4847d6e7ef038d29376b893565c3534a9f94f7be176787b4188f0848f50067d060d4e427bd4b1dd5baca26bb70974884039f6224c63c0807f32261499e931ee18095920a991fcb43e086f11dc358a34dc54e6d2c22e94562d9f872f6b44d40fc1be439c2b5d797cd207a05435f48bb7965797125c15deb23280d85117df8277009ea435ec5e76503a7bed115fcc4e769f631f94877ec13e6767d25cd7c5899216ffeca070d2c42d8047a958b2ae70e5ea943139eebd4dfe1f786b0f9e593da1c78e19ccb102062a64c6dca909f1d4e1a946e53653a542138b93409d0d050bf378ea066151b5976cbb70100aed5be7e9a41eae826b492dd4fbd18286566241112559ff14189374c74454854909d80dbd9166af8e63ae64cef3e599050cf20f5d901f9edc68c15405efc506b40f3dbcb7fe05ad7234c4fd7eb20297587a02b8c58136549329237be23533115fe34d88d08e4e3985380a3c38c38e2489372106f88dc001597c55ae52a4e9b44427cb14bdd4054d65107579f8fa631cd67ebd31b8078bd58c0925c22a13ef11e8d02f744b0b47424f0dd3d0376cec9064d838fd64a16ad7f3f74a873eacd692e00a04d74af228c74f82d77d7a827619d494fbdc7f99a5d653e9d03e59ab0a4cded57f62cb6cd853c7b8eba6ed02d8ca5e0d6ea9f81bdc66892d7ca766bf7d32d2e54988c080da949403fd819cd29ee54cb278969034e60a8cf79b2c60b156dde03fbb5d802680e4207d202fbdf5326c5c193b5eab43910ab7cbe39e0844d9ab1242591d581e678b5da725a9f35b2d197c57354ddf7c5d02a6886bb9581929f7c14c459d1d45c955ba13fbd3b64da84efdd221388456fdd447b9e33e05954f46257241f82ee18fc7e89341579aaa1551190b0afd25a52632af5fcdb8b38d0e5b9a57cd31be2853a4e31eecf58d09f8c4ff40e0a6afadd706b6c37634ce22fbe72185547b7c495deb3438703744451d547c1732765c723edb15ffc9da1f8a143b1689febb71522647a94ea0c0a2700f9f1b0c299c81257edbafc7ccd687a11d014eedb0fcf9d22364d7d98e22d0cce3786a99e2afb4a5165a11340d00cf43519fa242db2d03f412f4a3810252b55be23333e502745265892123db87306e1ee0b739854c5ce52e4f5531481d11962c2ce8e76b34dc0b61f34757657dc7bd9e1d6ec1d868f83f041c8597a31a4e08bc547f7b7ed94bd8ea2b4a25e7e759fd92ce0cb41c5ff5a19b317d78ab36e00ab423656617ae2bc37ec8854d2590554eacc9e1b024c701fe7ca1f95238104f8a9c501c8367d20d5c963a4054e78d6a3f682f626f48789b6f24be5d5de64e9b945fa30b223c7788758beae661208cc7a31052d594011fa1a5d3cd03e7caf4d07add4a0f6103bb9120de1c0ce032280b18d75168d625d48789370734c71de9dbc081f2f924cb12f674c450a7d73e9205a85f0cb9166f1b313f0d5fbdd49665a44b0d2842b5d7f3fe1e31a49431c72de3e9f2455c80e2de1601cb3cd63ca8beae2574ffd474b3083d212428a261e81383465df446259502d2fd30246dfab65464ff9b06512a8ad94ff026507ec9bb420a7c4fa7f1a517092ed04d2e8ae5d9434a906d50a0c4f4ec9944da93ddda9421bdeac07600cedcb133995f9ca5aa3bd049f9f7aba1e5b33d1cbe072670b945f03a817c69f7ecb8f9450d8e73ddf80aa7d576d8da34204f76aafa9c2bee120a15ab3803c0c1c4d2a4735618b8a877b7a8cdcb0847914aa0c840ad259a5c17d27a4c6deeb29cd0933d25e34c4ae1de6d48ca0a14c7c4a6a1958feb2a3bd6e7556427e5e5a02878681ae06e531c09041254b3ff072e640bfcfd21fee717b389c3568a01d4d0ce20afdebc10f86175514ac2c9f540d8d31e916bf4428a03f2a1dad79338373ae29ed92c747f712b7b0c3517e94a299ff8352bb15cf9ff9373d5cc9ba844e36202fa734fa1575fd0cbe0d4855d4856c0a4531c2aa330a333ed70b63565ccc2fc9063bc82912658b1b557a469ce421ce93c324a993a695b85a25543a9539a4e69708a727c18060512c395c3e06fd05b236a50eb77c6a6daf9c82edea5c1c93afa50b81d96db5afd7ac24bcfe7496e5a0847be1168eab16670c65589243381889b834ed311520710a470e659aa3dbedc643e8c1f910d7feb835e7624b60edae5fa43c38536024f8500661df627de189c94a4fced2ea47c41a7ebb3012117c40df146a1032e545d4eeea8be54391acc947c958c3e6a6154f9f3cfc008443ec1fd5ce4f54b0a75ecc5a3a65c7716dafc365c63cf7abbc62de9c7a252a613fe491ef9a1ba606e6d83797c2537ea98d003208621bc64d427bceaecf1a190345fb8c19e8ccc778f7b9810a999465ebdee8a0c7f25e9773320430d7fec08f603fdc1902077b0e2e28146248c9cf370b84ac4eb2c63de9ebfd31187693325e6f70e3298ed6b18b1ee45e842474fa9a29019aedf48c7d0cc89e3a6351670795292c4e837480c1f91510bfcd2463b34ca07318e59d40a02c0c4d70c4394402809b1248679647d20d98d44ee48b8ae5ea6a5fa90106d7c2a21fe049f34d1da31a76fa78fe232f8779ebfd911c9bda7db7e3b0c15a8da1a5ed6d571cda397e00ce1bc3889053dc06688e84f2c28f675637c743df25d0f9729847dca3ffca63807f391b9ea1144422df3a4801d0a456ffa9a9af04ded233d58f530fe07d39c2b3d845c10cace55b0d2381720da2dcb01b514f585ebebc43b7edeeea33a4aec1543ad85f27b6bb0335f6ff219042faa6e6f5bcc45b60d4cbb0fe8bfd0829801567b4e8f132e57ff5d1e6295d0202b5e5dd93f9a9b131c05ae638f2a93311f2f1d4a70578effe8f3304e3e3c2faec03ab7f0dd30fcb0d78871367dea6b55b08335c6aba9a45449bba1c06bbd1df7e96376c50038faaa021d59e742d6d0ae61ac8781ed0be14e132c22fe1186effacc3862dbe02e7879dc255a275fef140908024132ec5de7ee165f296aca8c3f7dac9495c479e8a5d7a456db2cd35e1d26ff21b04baab2ae12523535a0a1a96dd0a560b64dee51568294d27c528808be5d939aa7515e924ad7919e52d334ff4af97da436202bacf7580218a8a7bdbd09b8cbc73a7d2918694ca7083878e0d23867a5f43ba86fb231432a79fadeea0575e4d6cda0cf9bb4ab0e46058f35c48ce312e22fa6285c04ac95c21cf9e6371c7955020ed6f83e0c55a4d955700b08cd21319a1d8958e3394b49df82ccb197e24b5887bbb768c5ef3af8244c97577de78033e0bdd4a09427797c30ec2b5f526e8da2980d1233716b76bf87d94280c14587f18b27fb588a2d0b0006e384a31a5fd56ad822cd3eb62507a8a1d44bf7955305127f6b458338c0e8e08c1a01b0b1326e6db07a6913a25c626c3b20f4f74d0de218b7bec9d719a73cf48beb91503b2a1ab17a2538bfb8a26edb1f0bfc023b5b3f402b0bce981470a665f2af1ffeea622dadcebaf7a904cbfa14df00d1233c8e102b75511be86298409fe6fbcaae2e6900aec42496b84f63caec51897af362438192e5bda92f3978ab9a102901db74ca242d8a7727e10e47059851b04510b33d00588ec15e7ed5e02cf8d883c66c0823ffe685f97043a793c0965e4bfacf9e3ac47fb9f913d9d7cdd9ff70f1f4e84453eebdc56fbe2b85245740dabbb14e8e0e46c711534c5756cf3dc337ab59827be67bd98333c7d03fc19e4d934cb2bb81d1b92857d1f88826efb3504d553ec3a2fb0d9da371700ed4dc7fb5f4c45e03693f12fb173f5a1698181d60672f68cbfe3ef6ee1603856fdda478bcb786346d7511c52dced532178677f3d0abc8b121d252237436c9c56861b657a99ec1db88edc3ce73e0cf5ea71d00cba488d9a3f7444c5ec3a0e8f099863f20cff5a667fa5351ad17bc7687d9a241bfcb8db16e6d5010f8d52aa1753dd42b29a00e8950f053f302b69478b4a1a8196374f62c86c5e727794f0f08595729d09b2039afaacd4c3ea9dcfcd6dc3a431a13ad813c7a2dfc67d3590c8308b5dd0a5d9876ea1d9452ed02144c75eb620c502d6f6c0adadfd26abdc9d027fe1fad9c057e38d17b589ed588ed30a209fb561584d0235668eb59e2582e2b37d52b674e124aaef297edb6a79022dd5c381d80fcaead9c83d1452036486499527463dd9ffface6b637d014e21c7175eb6931f1814f5d0b4b4975715164f22b8d4a1c53d4a9fcacc0ff889768b2373a56b00a3b89e109c6de38e7b0a9c87141ce8040d5fe3adff80c72451f01e16c5994ffa28a6b5e386f22391505d63c3d5af942774e2f29cf64d290108dcf45563b25fa14fa135eed9006dc4a9f338625e88ac37a4c6dd9cbabd998e063fb89ebde151ae710e1b4df176edae9944bf472739363c8cd5be5b8932a76a900e45f7e49c5b01c9d49ffb7cb97d9ed17f493b18fa394247f519333ea32c4097884cad1917cdb0213a507281d6e52fcae8719fd608b71e9612cfccbfdd9e9fd246f47263e62cff3a1841b8cb6574f03fae7adc5c1366c39ebed03b54f427eca22269e7ec9865eb23830b378efa866cf001b0f6d09345bbf5546926fc5aa348606e52cdb8d75d0ed472e5bcf4f1b810b8360f0ebfc58056f5fc8c9b888f905e69af1d0817ae7d6aafc6a89b6acc8bf8a896504765a4b8634c7cf2a897411d9a01f257e0c5ad64182b59812730fa0902cb2fa34b409d65fd73c22fe4b58b4fba1ec897f4ce8da584787838fdf39ed01fb26ee59b3a3cdfd4ad1ae65f5758322c84ec65d6db945554b2928a60a911ae6039c00f8e003ac5acd1488e3986f4b8af6b2940d18da19c9bd0cde54e5d0c3ebe45d910884e289ba922309067551711b470e9e630abfdaa349353f3688b833c8b6f175743940d9cd891790bc163ef3f4d46750a7adadaa9986ef728531c0ce24d08f1f905c82ac11110f0362dc8c968bff83f320d7ab5172580671737d002beae56b6612a3d14ce5cfdab7304b2a8b4f0b97d775b5ca3990b6fc1335df4b66e8ffe2ce23e4343e67c800083251e6078b529ae5e5ec3013e05b1ba5f349d4f66981330f9cab643c76fb66a882dc62981458bb4dffdae68309df336bf519df89d7f093698a50ca846d1bf71302a857f54f862561715f5e3f54100523bdc26dd60c8782d6fc3b16dc9d85f1683596979b3d36391f5bf9f4f2dc4571a9b43af4daae535811b1ca7049dc0d242623d0a88c0d52aa428b9852e55b3673be17dd2000d495b057df37949750a328f2decc8097b72a463ba51f9655b8f03a70ad75b6cfe4dbe76d9fc54d3d17f86a10d2df99457437d422e78c3f2963beb45d97d22cca10f7b6373cf71ec5834489aed8e09bc0eed77e203fc8b977111ca13e98d7e11b7b0e1a56cab0c3a4c740c7e9cbdd8c48c2d03ef59780a632c75ae2146cfb852d5950b0ad7976c4a8323ad99d6c6fe01a9af0f4c7e985a10d19b646c440b158aafa33f9857af076a37d9ca8955c722795bfbd8c6d441e7790b8511d6c0193bc1899dbccd270c7d90d1a893cb55d2dbc5822bfb5eff6a690456f8df3d76b25583c50a1e6dcb22f43071e94be8b43107c662449b5b03e266dcc7f942b8816cc29edabb937c7fdae1b7c0f98021ca86af3786449e61902f30f2df8c584d130b744bd2b8ef792549755068716734a53964b203eff9624bd7e299b73891adb3382513522f1798f408f3764663f89f5fd6ceda71222b027b8a29e189f08fb680f0e7e20ef35554988d521a27bf10d5c9b44d91e96343d4cc3283bf662bac7acba68af079b4a21438bceb32b54a25affe0d9d1796e34cf2042720f247cd1e0d3e4e4fd656d0878147369c0f8a84b9369a3480fecfcbc9be36908825edc4edf9f880626cbab7c2a63502c244e864b4ab54be51e59bc28d7c6b117dc549cca5ce89ba2050ce1c87b943590bbd842db6ffd3a6050b4d10a1e2e4053e067811a077d648588945043b411d8eb8a3c2b5473383532f550d792df6e8f8f71802956a17b517984a34bec275515b8c1287a12bf853e3cffe540682b97484754d60477121643f9e9e7fa1b3eb44a7157722b820f4f9a5dc4ffc46e3602450e60a72fcd22139c4d8f4148859a726611034de853add2aaff07309509a4bf87993b50352dc06db2519ba01d0c03eb07ad054d1510c55854976400260eb3976042f72858fdc5abc4763b10edb96b20a05aec71f40a9d829b3d633843588fb725ed57b01795984fcf5286d17bc9a4a782ce13d60bc19c4398c8458f975a26f0a7b9b9fd408ddf53ab844e23df88ccc22cc2be5ab95caa112c754e2cf56562b572cf1aa1e590ae6dff22bdc9211c3cb243d817b2550c26d37bc14a3cc3852298b1d6f77d704b53837f65e875ed92783a331083dac8532541ed08d6ed6360980814c6166233bba819d42c4c6c853642f5659be22b54d71e9dbb70b25fff41ccc9f7c2ff29f52a03dcc587267b1be9f1491ba8d2e2081eb5dc14c1785417a68ebe796636f14d63dfe2916e2cdd8deff1ce195e92a549205b8ec1ca90f02ed01d29d688a8032ba5e1c7cafd9d5571838221fa50af31897ef29e8303096a77608874f17201ef0be95ae4a4f1c99b31f73d4617c54fa848924495a362a9801021e4bbe4e5d7860c84669c346da5a6a648607fc5ed1ec2c2fa69b1b2f7af2394a014189529479314863f0ba8e6ec8c88205eb09fa8a6fc6eb3f39be1f6f6cb2b4a7a6b25f288ec216762e52fad47e4dcfb326c656f39d40f52c2f4bdd4b58b7ce8f44ee9f1b6c98cdf4e51ba9930eae9f3e2a58e6b5dc7f4606bebad46262fd4b467a909b28231b1d416b2745adbfe2441dd84f1d9ad12e7f0b58d05160b15ff1480262c6bacc32d12293531ea1c71d7c521239a93b73d6747e906438f2931450b010b1b05b656f8fbc0cfa41cd328ea5b1017f1dd6d17ae0cc226b17f5f5882e12cb1f2ddb4b283d85e3283e51513323c8482340e2984013b8c22a4201fc73dd5f2f81e979038ff9828869284b29aedcd0d241c0093828da7fd3cff9cc384609037d824bf05457205d93ed8130a7f3dd41cee0b0a966036621810fe7ae2099ffd621ba4c9065bce22c2a64038aa0553af30b9451067608a788b39bb420b4ad1319e6bb95bd3b6d5d11c1f6130d6afdfac48d7e0db53b5be3d9f2d9dadc9f635c978fba088acb2acdb197494ecb345108d5e3ec6c5a3791ee52845d4fe2d04c87993b71c2feae4ac518f1666b8127216d7508d887cb31f1b88ec21f5d2d12550e6a96d45e2d092d5e13bc3d6af08f2c8b6bf350fbd76dcb1581737823365eb1a36b9d1824d1ca1d32a14323d32c3e8a5abe2d904ee79e22bf2c008fc028d17c5c42a01e35f653d7b0759cc0325c67264ac99bae78e82f7b2670621a74952ea8e1f2996ecedffc1407aed8b6bc685903df01742eacab60f29da11ca363ec15910d739c8b511e1ce58f120d3279b187982b6626cd4a5443cdfcd8108c396d5b1bfd75f0846331f7eed13668ee752e4029a88800dc1b228f13213cb43ed44f6a7460a2cf27b35299e6bd0ee4d3553a315f3a9247c3623ac9c84b3c4d0a0621437e020cb156fffbcb8303ea55eca6568936b49c3e6ab37f72620647c7391a1fe289e1bf26d770e60c96354409e3c9abb766df7af3806e963eae913364c261e654894e5cd379f5cceac42612ba57f167c5d390e647a78da972dc8cbf5897be2ff63dd0c05103d68d1cc5f1e4cbe06890c3793be5806780eec68e24d3035850f9f7cfec9d3cd5e3cecce668e0017b31930f77bb12eb5f6807ad977f43fa7fe799354fe1c81e356e04c983535df988fc7b61255b4025ffdf798dd12de5fdba31eb89d0adeac5aa43bbf6deac883df7b3e93815a18cff8e2bee64674986fdc724303b0dc1776a63ccf285760baf51577b052887edbb203144acd54296f9524295c62ae84acc3595d96325556506b2f5ca51f74c69896dcbb1ae6d771ec0c3e16280b452a3c8b5f104ca59a463ae08b2df1744429fc30dab34ed010d3e4c7283e52dfcaa6991e684afb401c1530ff05ef7aa61eaf659de02a39c1eef993254acb3d3c1330179758db527b3fd43fe34a7441eb5d2ac3cb3adea77e0a121bfb0ff06a85b1600e7d89f65c0b66d479be08f9f1cc5605ca210bb21aa0bf5b420478c044be0104a9aa61781f6024f2aa70f6f2aa4a6620b8adc4ec341681dcd2412cb9ca7e0034b199eb30402fd045c0abf1faa8e0e168f4ec5c58b86c2f79249391eb18b44e17ad27f7dda1b0fb3667a76a676962839ac9d574b5b7d71517a46b079ce94dfbb129d04a13c17c8bbb5057bd41d061a75cbfcd3555411bd6b2d1ac1477f3838bd276d0c950d471a081133a55369cb4bd893bd8f1341a888d76ffa56c97b815ff38cb4f0138996ddf8dfe3f32e11e7d65fa3d2fca2d0d0abe174a3122b77e0e2adb58ebaae31d73afeb327eca9de4b29743220db0b9e8e14534b3a72dd705807253604b3a0f11d1348f1b56345413a5c4ebd52beb774b2af94492726d92f0517241506f15d6a5b54c8c84860035172f8a2db9a6e52beb7f90d70e1164c28753709f89cf0a77f851335f04ecf2ee6300dcbfadb42f6c997b36d07925a2ad5a7e57a0ed1cb9176b15098354f0c60beef6ccae3fe12355e49c0aedabe068a4dd222ab6b80abfbee8fe290bfd4626655452daf2d4fe5ce2ad0ec7e7e608bc128ed9382c3c5465eec1c4d76c0c201671bff90944aeab26fcd4c3c84680a03efddabcaa96ee46ea9b044ca0d8f8d6a53c1b6d86252c12bd8dbda3a3370c2ee93c6e93ef33d94ed78ca1a3391bb5113104cbf87306bd0cd588aaa62cf978725251e69c4840cb7b040f08639c1fe5dcfbc08753724410d6b7f6931d13a9dcf6f318de9c5773bb6a418cdeb10f8b86aa4a5e61db195988f3ac12dcfc913e5bd6ccb2bb8a3e834171045f0fd58ab8cbfd230b86aaf58441bc03ea13c6294dc5e0ab5f46872b17ac1a705d91fb2305074db447ae2c20fbb7fd7a7d79c5ff62b81c0612a5233514052e5d206f08ee14ddab7dfa5d8119ba1bd878e19fd3da91cddba5846ebcb9a922b2d5f9a54019f7ca8623e3feb77f0c86efa2a3e8562997ea53631d5c77cbf7e1ff2f06d37f129d8b393bbe01eb1bc8068731c0a4e7503da29130564e228ce8c6c97ed92eca99b91ae441de5ce9d1b5bb126aea318dcc2f2872ac37392d3b9e1b231c190b1089f8b1e8e815a34ac3c989e5fb8eeb52d41779194d225c0485f35a1b308c77436479500a7047cfabb0e3f44e01956c9220f74c90331ea1460c9880aff80c70b2106284e8e3e37b6e7891a69baaebf1998c54ef375c93195924057e9d212530a1bf9264b690db676d156d90b51f7342fe0909db665a27402362d93eef754a6d0f05545b86fe9f9f89081e698ec4d5970c91a4a6a33ce27a39c2da7b063b2936faa202a9f4135b1bb52bb8ba83461230e0cf8267d2f41e9384c085b471267baf9e6f01a485e95b80c6f5d62d830e37b81fe485adc301ee7f4b7e3e9f0434d8b59576f9401999de64377025fdb0560d1bda0b4a33400dece0e2d5e9c4bc89860ac784f024f841f2b7f683bfb83288ec529eaf0570e7dad556d8ae6ad273ac05e594db066d356de4302d95f7ddbb40eaf78dfaf6a50e3865cc01214f6f0b521a19a963a98d3672e48a8a79229dc6622cfec2584d1dd534eb7e1280f5e4d55e5bfa6dde0223577c6c9a6b1fda9738ff05917b14c3e261c8862ed3110e7340d363d9847de58389ce096bdbd75b0d4be09ab5e59640ea6889ecac2dcc6e5fba0639566025ed34fcb7343f0232ca3c7063dff3f684c264fd3d66d476c5f185d01e1cd08a8dd59ad947124d5dbe530afd07167e54f49683b1b7f7278fb5ebccfbd92fe1fe23f48a43826881ab3f8c4895104b8218d6729aa23164f979c866c9b698ce941def257cc085e3e85a4e75d101672a69bd3bb9e452d58c91ca763c78e0253c1ba51b8290c8724d9f02d7465d1fd2e637882c15635005142438fed06aada7cadb1ab0019260dc4d5535a4bdf05efdbed84a6df33f047027e114cae40bae84d30c72c3a06b1cf7abd281886c417e0d692bf4242d406f3a93f8f749323c447922c06331b64941fd34ba03d7b781e3d0f34faaba3e9659d6501b519959bdbcb9d95cf0b6d09fd6e886d5336759b9e7dfaaf5caebbc59f942c575e95c95e71f3d1f27cd94e5c294213c9f5c74069d8affe99d5fbe23325afe3a8088fc58fc1112c9a8d772691df4cc4f397511304af2392a5db4c302826f6b35ce5bcb3479ac1f122f12c11f85a612af569e4eaba47bda9d103dc187c09e78e9adfd4ec8e23077de2c5b441f3b281733d7804b4c03ea979b4dfca17b40292cde475ee936f81651056041131ccffa97544c19352cb20bc80bc22bcf231bf1a84dfaaf358a4d6943cdb231c61f0eb0a32c6ad143413050b50f572f7377de9aa6525eedfd8f3321e299b47e4c9a6cb7dad24ddfb216337ea6f38ac6f9941fafe481131e9f1982847340ea0e90933bb0a19414b4e33566e1691f47d3d003b7f5fc63bb8cca7de4823bb032a9691beccecb78dee7d6e7d5f814a453c97a960ef5f965fa43619110cf2ef403358941f890895b280f28ab87bf52d6322417c27a15e5d9c1273e43770caa5c394b2a395ddb5b80efd3183b088ae2f063ca3d27d5effdca7945d19bde4538d4b99b490fe4430c02e7d001df30004a88f878380cd6de92ff6da0be541d15ddef5681125f393d7cedf11868dcd0deca305d8629e4480fcd0754e4523dd3f31cf7602e1d5835d4bb408f8b8064af35dfcdeb1f47d28693fafd29055cd8eaff8c73d9b933a9900c0dce2de98aa824e63e0e6bc9e3958616d68228b34ce5f9e2b730c11a3a20cfc7a12ad8925b9eb90aa7a20b654e175d37b5b9ab0c2eb610bfe6b5721a3ca11d84ffde44cffb4860b728a4d3f84bcc7b742624283693f734cb84056cdf0da63cc40a96dd33726fb63e90cdf060216d5c1cf93e866f7744abae05249a29a4543291b114b918e0a0691630b9d4b4e5a2639feeac4b39300e181291523c84259e6709691c4712e7b044083564b3826cb06a22367e135e19afbbbcccac78a263b8d3e89ed70473ac2be74d5ea85534699162109808b8781556160626575871fc51f882fb7e6e656ae8286496a0e32094ae2d2bc44e725385e7b48c535fbedf99b7872df2c2d25f9a6d815ae31011a7c238ff1ae98eb627f6c190587790059f42306f9e936983329c8307371ee662d99e803c2bf5e5ee184a41e82181c891aa0fdad0a00e2d6e307380bad8e831d3be9177e4719425347ecec7dfb49474a328f1e15bedc73ca2e9094c627bfe844040a156796605559ef2ab2ab3d70a9d5b665c332a7825caef26d3feca938627536eb6c3889f46f2d8fa2695a3499db7db2e9702d66dcc095b1b89e7516b4c5bfb166a4cf990ada050e277ee541bb3a85acb6ce774e41ec011e7bb076b2e960c4e740e866880eab066582ced98f881a83a1be75ba7222148ebd3fdea665e987baca30fa4e9d50b50dff9ca7d0531b3beafe3cbe0d45079f1bbe2757a7eb4406bf20c464527bea01b89ad213d19e5bd60255b47986d5211a16ad9f392a9d6423e52330bca13e2b923e09258cef2bd8e0174a4c9a9d71fe8edd17325cdb9636dcceec797e458becca01e70b8b3b90b33ec6c9e5a264242af4e5770f2239b388ffbd170e2302ca9670c7a0b83f6441ab671438ab260035a8cb5e15123bc2f3972681dfe5559b2b787c80b24608b86e195be715a7e2dd29d4adbacf550d4cf01de2b4c8de64a02fbfcc4e26c6b1817f98194e4849545653c3eed4edbf7f41260cdef01532e3dd9b4cbee42e50cce8dcb4271a9dfe97246f2c0cacd3b8e9d5a2b6b1265ae15656b30a972cd170fa5bdea6633a03ee79105945a300f281295265489de7546b99053a3354560c54f030b701cedc77f39ebe64935cf0317ffb89c42f6cd047a0ac0d759f553ccdf791707acf6c9de99c64ceb26204f90b5f2a9f48ac010c5a5e97a7a6e8f04af692ec46e066824ab1736f26142483a471131dc323ef28ad14c7363ff93723b223a03a4978f0ebaae5005a0d86846e19065b31f43117b999c9a18b1bae627081ecf1e8d1f3abf17f9fac00d98b72c7a31e1c80e3ae08b920e4dd06c801631ccda6aa5d98d552287a00027017c71d52be4533d9fb1889a204b804100ce1c87a73eaba0a3b2a2b36613ccc85d8e9a0e0ec71009120899c0a23768529f605d282cd1c520532e48112e308fa87871afda0b400049dd8d3665a7c7dc469074d0b3bca076287d334b5931eeb9cff026aaaa12984815b8599b5f4e5bc9757d50586a94dcf33cd5621ae4c08b2c463e16cb0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
