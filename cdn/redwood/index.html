<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"77be6dfd03869657f6ddec257e09630c8c23711983caae8f434fbd6151eb195d6036411259e794d1e09b241196e14f7cd311c3f0e77ee57058dcaabc7f6d1c3143c4c7ecb08740b4d77a527eb86d6f542bdacb44a9857a18f42d7b483e38e776a073fa953d4dc05cb0a9a74f72981eba66cb35c50e3cd2ae6c70e9043f30c53284f9adaae77069fbfecd35f334a19a884169e713c72148b67863e7bc9e5479c3b40b3f27ff1d288c4f5361239c48ccd1958a7e71c6dc318a745606073a8f31f18a0edc11995c6d4aebc83e2b3abd3dcc257809b6c1cbbaeb347df9d77525f0df61316f27e959cde65c8c401fdf65f404d2db35bb2c67d1b9442e53bcc8ad840008ec3a9593943880443785f05a990cbbf29d11ddb8d8b92e5f2a9ec5ee9e07b7e03c43f49911aaa21899f00cafdb3d01306e87b955f10c2f02fb7329204385609b083599bd29c084e4907e0f8a04ab25a15f0ca908b5ddcbd7fe5babc11b225465902fbd1f0d22e698593f0520fec6df4edd99915cdbe54ffa0ae75ca5176f37a70975ea863cf696158a53a7d20b09e76f4da2b7a3e79952b1d68201161ef041e3a077b3b2eff6eb4b2410a7fc7fceecea55a36faab67f21017d32045d4fc3cb10f494d64847d4db6efe2c97c4492d046cd6d8045f455518215eaf96b605108ceb0a0a3d076fcfeb0a045d4e122f16729e4351a5a7e67e69cd492e8acbcd0d28a05d5d78a459b9388cb5eb42a0776813c360db84d2d43b51863ba4e917a12295405b3941e997e80c26e1593e50616d51726325711ebbe8802cccf4b9182b05fd9760a15d43afb978d96d11df9834d33d4061c45c3c3dfc570a74f9830cf32a48dd4a1c592c9ee30b23f429d7a8f9d0aa3dac9236c05397f518ddfb1db029600515dd1f14f7bb2a0a347e9b94cef6f7624390beccdc1acdbcd70bcf627a574f641d32d36e1e69baaa89e7341b0f435665258ffd9533a77dc7938b29d2910da4aa80cf4ad291cf7d3a47fc05439740f99ce5e51fedc45ef45d5650ca7d37facdfdd1a44bc94d08fb2e59ca81540610ba43568df351491bb6a53f77912c1a69d425787c8ae2dc7a280aa658b9e0a40795524ab4e93cc66688a1cc095bf7539b7f28125909069995f95714c28b3d4af283bbfa2be6f32e5c396f279371eec27c89a2e50fb2f479116aaaa82c2a800d1997fdcc32ba55b3c7802953c28acae06d288185ab4925ed6fe5e8a5cbb26f45c61e1b20bee4cad410a95da1630503bc4d2232b355282a2c42a98b412ecd13394036073419940a77a85bb4c0dbca3ef175b3b1a7f3ff30f7959c42cc9bea3efca7146cd9190a9354af7a236d58e0f00631518cd270b05436704ff0961f527f643123de7778304f81752beff34b3774801a48e44d5d4f4d9c0485d86d4c10ab30e4c47b185f2705f0c38a7ffeb9cdb48af1b629f0f8f9ab040bc5c9ca8e0fe9a9edeeb25cb26e0177dd711520513db89d717ecc19b5015972eb72cb51ed1e92bfe5aabac81ca69542decaa10c921054c8a82fce54b32363004c6d0e3d883f9bd3fc3cbefb771b577061a990314f7d143fdd8001a8298bc2e6b68fa143d45866c3f43593bdcf4302162acc1f6912ebc1eb0ce183fdc76adeb7990e807df7d1d854cee3a1bd91b9fe630fa1b17d962aea0e04e7ba28a3a71b33c84037f6ccbc461a67b419bb3d720660b22957f75ad3c42bba427bec26e876314f0cf5f9130ef9e371d5926eb88066a39c262b29ad9c30b1f5b6f682489a9621dc3026a67d4c5e24a81c12398091ab52287534e6fccd18b06c09b52f05deb07d2d0aa01aecb54e876373ca8849385ffa57daa543c23dd79f7a3939e881e4e282bfc257706de32b303569def55509670c1728da59378063c7a5b81b845c597f444835d7ea36c3ea731a208d0ccc42db9148d597f0f1da9b4fc3e04209d2236ff7613c532b82bbdbc5830ac1d44fd70aa1a96ab02d44e6874f371ba395d44a840ece8aa0a63025616164c152387f23f43b8164707bd65b467c86a94709807560568540c225a89df4c9f5c18c7a0552caeccae59f4f6faff3333a07dd967e7f788b2b06395726cc2b60a3887e034da3910ab626d250fb8a7024536cfe18dacf59a82b2695b4fbc535212cff52825d9ca144b21bff51786f13ee8ebb5602767d99b096d03053af04959811ba983aa7e011e5e6de334d748c0144a2ab9435da5806964524a013ef73f26e6b550b6a29e246bab90fe182b6e05df49e2ba1d5c9ca825c3efc56f118b3cd6910fc3ae5a68b45d2568fbad962e5550de91773593e5612ca7145a2f7962948ab4ad0ca1fc7879e4b26e1cd72f418278667898a0449538fa7606638bdcdeec76ec97f6fd859055b30bcd826159a32397a5f4afef70a74d261d993a3192b180cc2e1381a58af5d55d977ca10308bf33d418869f7c378e6a2476928698ab4e0c61ecd81b056aa46855900cb5fdf42eac2022ff8683d13c589c7b8a41aaeaf8bea381f90e7740809ebfaf2281e3e89834f101e332f593742a50c25a5d8c74177fde894fbbb6ef44a640dadff767662bec2209b7479e57a95e662fe0596b84b746e5193ee6861e73dd8fdbd5028814e6e749bc3af7e55d107bc7b525590cc271263c5029db8d13bb8d0a67474e9cd2c575d7ff3e627bae37d14bca7bc49f92ff1db4c8bfed0cdd5275a2178155024d933811d45de75969a309cc779d3283d7e93e35a18509efd43f0f666772e06bc7c8c4a1c392e37a41b2c4439ce6380b45066b301d87869469b068f5a0debc1c6422e6fab26bdcf8405a6a3c6649c3e71430d06363fec8f800c316ccf1265e2cdf11f3f872369f1d7c8680a33293c7d0d2af069c6025c91a38319f329c6c7bbfcfdcf6041f8490019924e4dafafeefe98ecf94c33bf9053945fe4205bf330a60801a0b2d7572d9748f05a541eb64cb6222212f81a819dc684cd8cbced82091f5256a0d53bb72e56b4749a0af576f99238d29f82008817f151da03945b7166f327d1e38c600101121fea47b4c7cf1d0ea0d64a13f139d3fca07cccd47811a00e1c584524000058f5bcc531ad9dc357c26750a2859de9e5c3104a27a7ae3269fb397a2203aa0ce38cc74bde7066d52ea6fe5d06297cf5bc0d3382904797e43d6ff3f6b26429c3e66b66acf1198b8c330989b2a4d375d213ce66d1a01a02ff42f1bd638cb4f30dda5421f55ef069ddfaed3142b89665897d4877875f44fde4bb460a24d92edf01209daf299a9da88237bf3bb04c82fe24d9cfec00e88dc78fcb8b8a0ffe7634875ac9d5c4c55726d4d48cecb4af82bbd53e254010b01411dd221c0434ee00e665bd12335eda690d9872cb5c1e2a1585ef93a3457a4597f4fc4d457920b2ebf7d119cd723a0a64521621b310e4e98dbf6d03e5894e066f9348d86e8b5314909a56e6dfe59abb3afc1e23d43d35ef66688ef767377aa864be4c30c9d5b3e43c2b9f03874eab460dd69dcce9a9c11d70108fe8c498227b7fc324b1e8afe92b27c61621fd9f0a57c5c71dfcb3fee56bbf084f87134000bbe1f9ad2c3b611bc9a440272d6b973735be7fa09fbb7192fb9ba2e2bb148972694d81187d494e849375d96dcf1b58536fe6322c1440c7db3eaabb8d4af7cd7b77bfc03558ba334b33fe6f8642ad727dde1ff4c5888533a02b60f82e874dc5f9855427452cfcc77f1d888bb5c14edaf742051472093853c14d1489054ea6e3691c4be69a3ee22fc4ee5612c25f6cfa2817fbd5bd613e904bb8bcd9ceb83da9c9783b7bcc6ce7b76148a4264bb4f3df1949d413bcaf08b4f3270ba6e4f8337ce7453dab3d21709ce6a794836c670e763289c911f00091320a82c516345689f8906ef280a5f18f44110766378c20a1a957cbd56b1d6ab9f155a042e69f0ac17c903b7f4fd190be17120f60b1acdde4cb5f28ee61dd5a0f7b03143889dcfd8cc403e4f2000007bc6a79242bfd3d53831bebd90568b08f593c4eee21e31a71b790db0143ccc3caf066760ac9bc27dceda80c9c78a77332ed32fc66f76be461296587276428cd6b26d1c46db7c4feba917a500feeed2c974e694e1ec1f37237a96d8bd94e3fe6925a86cff2e3a15255f2fabc53362ef2e2afae380c28a91aa991e9410bbb7343b0e992577b9360d8ae0c1e641e2ef33e26f008026f66a237b9d1a3a2c90b953fa0e8110680f93ef3080fe7ebb65b2c5228e1acd8815c6c4b6aa5b80629e39bf0424526e6ead891d907630f28d65880901cb75c36735f613bf2a15c42f6d15b091f19a09a44d6c2fddc257ffa7c6abf790f637024e811f74947e93482635ec940f55e98a66e96b69e0823f093b2d2ff384f55254cfde092d8de45be1e535be5f9d0d5a1f830cb7b8db30c72411052f055d8e2aa7104d993670636dedc09449d1356a986f6b1a979d29cf191fca5ef6fb629974a2a9809303e07358e28d90afb3ce63033a268446583ad4994ab5df18583480aa1ce837fc075da4b413bfca091fa7761dded66cc6e1545b01a3a2a3ac9b1ba2c4d6a93c1f50bb02b074220bc217adc28d72616f8a5f341d1462fa7d5008225fc50adbd83cc45ba878ee412e66d072e93eb85de3f033cb0fe9da79f6240b38275613fb7722ba7619b40a3c986df8f78d97fe33d073a5f667f3b77afb482433797e8deb8da140001ffee8b04141bdf5fc1e3876c060327b2dc36795b9684129d23d04d7180c6d762909cd707aafcd34ed7e070442394264401aee81535a8cf6534f201d8cbd68bdf7ad5b207ee76e49d95181f937155d07f250e4d4528de7383703f97434c369b1439c28f87c031595defc57a0b8d5156815c2e24261a61cc77d018d9e643a869efb9cf43ff6c1988fec4311495dd8bed976a526b4e196a3ada98211aac8cadbeaccd8406044ab9476574f9de20d153bb4de6389c706ddcc159d70a0f89bdc3c9a0ff30f794425d4730e5b12378ff2ad4b966445db79b79c98207dfcc1d8b7f5942d6b60f1dbda73d855434e5b17e9c036889b03eb73807691e55ec579b55eff5fa937eca7b58f0500788b6f070ca7e6f7ce29dee202e41bcde6e98a59d2febc140f0aa3157ecb7fae5a13526bef27bbdba7e5a03e69ae67c8063a10be3000d3e9e9dd48dd2fb6f93752da86bc6df97b954ea5593d5489eb22ca624bb1f6e5fdd1ac62fd0ffe9ba0c5ac0ee67ce45feec64315e6d9df577e14a684d2e10e2d9f3742b1aa44fe4043247f692f39182271b599bfb8012713bbcbd94c2392a8e79cbb38bd65dc098654fa4cba420a52eceb0c64917fefb248f36f7df75b8158bee339d73b2fe30092f609511b095e7818b03289f0a289745daf132d54a46aca8aada24b5420ffd3436896e367e55c9ff1753b5b282a9fd56561b3edb73f9732b98048de0546feb5ac01a84d269016531ce60b5d039e616f5ecd1366bcddd172f5c5f404c9a6c5dfda9537fddcf74dd330be470863206525b52189c7c96fd3636ae78617f27a084f2b9877b8a7a570c4554e9206a13dec2e880e16c7b4f90fdc471a63134256048d1a53dd1092b56a9dd87a2bd32e12e3343579a2e9c0b7846c9aef8391ae1d6cb2243045e3ab9d1726dd51c5e0d629c85987802aa191eabab4095d10c771129434e4a891812ec1dafe1816df51da08880545d1434561c637e21c5f89c3e0aecd9303352b1e9f04baa62171498dbae67dcb64852b7b21b78a4f623718bf23f9413e0408e0190c844deb897c0c25d3463a51b9e0f4b524f15dc846e069a92415c7cf922d08d5e1e77f59fd6543f8d2af4b1dbbb60abd902fac72290e32182cfa734e386b2460ffa4a54a67b418602c85407b2e47c3f7c1d5776e2c7a704fe769e733092ccb8ab9f5e880ade79d2236bebaeceb64b26b0426e969895a618f9793ddc8de975a3f3693a27908fdc85b3bc7c94dd65551b50bec3c45b89ee748fc177aba2b11e790aa43474567c257ede31f2d3b72aa31ed4b36068d5841c8182d817862a9fc944b7893271697ca415d279485ac1f4d874529b3944367a9395e0b8bb1a3c05c75c851adcbbf3fdf3e21d48b7ff2cc1df3a15a400447088bf625bee7cf7729d910879a60b7e9b7ef94d58a7e58f6324942615b69857f262087c0faa7e729961e7876a4bc7dcb8bfd65615197987854cf6c9494cd373412c3aaba8ae86b994fb8a596d5aba798a7229a3354814afd203965c3558260de8700f1114a95f2e05b94f0018d4f860b79975a5f2357427aeba962d9ee58dca7f7509badede8b648e8885ef0fd9f37eeb6d5004fb256f26e35f4bc76cd663ce9119e4831e25ee9f360d8af63f272c731f8fb7bf58ed70cc0e2b8e62d76c68feec9d9c2e68c4b14edfeef660236bce048e4e55cf4c7c39028a0f72b863d73e6d42fbf29cc49d4a6e59af6017c833a7c6e2ef142036b07d97d37284dcf976e7d69eb5cd17d8808e48d5451f5843da1d74cf3f3d32f2d92953dc573a039da8c4da2fcd1b1b7699976c26a6f8f4f09e4b7396e9ecc6b1155b6393be044cf8c9e916a0a43f25155700d017af9526dfc1f2fa2dadbab60abbd5611c6962275709dc381e41fb3a0d4b0574a473cd1c57c372138b6df22ebb03128f77436702f550b8a9d20e455fb23b4c89a721a1719ca7a2e968d1513992902bff4641f6c59c4ad98d59543723c6033fcff1d21e0d9b95f4bb89e60f5ef700f8d35071eda40bdc63645793e5dfdfa0d85ca2571e5a6446cbc5f23a92e3db8043a7315d35ad85c29a6b4349805de5a61d55e9f6aa347f46d2dc61d3c82f396a4ace0cf92dc91e74a884068241ca5a1f6ecec1a3291a4796aad5b1b3e92c12f0dfca83383e0717d4dd7de9cb4d39ddd2727501d2f1c309a05311afefcfb91f89272f26eae03bbc7ce0c5cd3992bcb59fdbbb72204f3a04646f5588175092126e0cf8436e717f64d90c762af6f48ae04d4c8ea90b2a227e47ec52b77bbcb3501d3e0215cdb0360c8625ca2f78fe044b41e56a476e851a0030b666349f842266d52b46a8358c9880169a9f82e5d9522a316de0759d16b98577d8192247d310a718263a27f273e4fd9be5e6f31db14e957a49e740422a29d378859d22f84e85fe1899627a1acc725a9bebe291264dbef4c21bbfba9ea1638e6077b409064ed3bbee8951c0d891cb4121bd6cc843f169797e0f3d6f7950e2f3ad0eeff84be7ab77a34629676822bd431f3b25ba0c506352266a89f58824e1700f33b38992f34f1ec3f26f977901c70f2cdfe2b12b9895002a056a3f30958e08271c6ee584e2cdafca0f4b179fd0f3af16c8f2b5f58f5b3c733ebe9ebe04e905577f5e286fddfb2b849b6c872ee6897dcc9d0cf40b40b8f2c4f46ad316c1882f426eca68181792b6187f0e1a090c35715fbc359e69e117a3b963179148be89727c819b49ad7c33fa7a04631f511789df3e51247c8ac77ed98979e8f9079931477ea95f97a7dfeecd523cc6cb6d8aafa6048856c600fceb948a8c443acce271d2da243f80d13bb975e6599daf2e89edf9147885a4259060100ac41e426a7c64cca4c969e17b162e2d1fa4c7455b53145d7442d2e1092f7f81eab407838b74bf452d403d076c6bf2291663c6c28de5d4cfbfebf6e918ded609868a5d7cf744775c2e4c1845b264e75d900e6d6a075c6f4d601643ce6e7ee71bf335a90473ffb29d51563d8c29a853fb6122885009b5766fd793c13aa43281024f5c440c53ddbbd880eb21352101e7345546e076ebdad287fe26f2323f478a29327f515454606e01076503f09a856eff0e897f8d26f03ac5d5eaf270aa919386f36a10b1315698642a2de8d6f26d595f77c788d7b9ffd4b5a40d0672c9c73117269df420149e4a40670723da788a10a9351c3043ef9341e919c4e32bbf9948e9e78d32ffc72003840f821799113204404e7fbc5b1c2598f0bb12bf0caa95f5ff276e697e072af0802732bb153c70551728ed5c71e289b414e401e7286ab9cd1ff45ae835df489ebe28a0a45b6ff414bd4e614fed1de437131ab1f03b108b5bb982fae3e1a83d290cddf62ce9a1f5187bdfe38e0adf0ef866847f507d5125f23a68c34e949978378573ba00808d9128126cf6992fdd66fa131f469dda322cfa8053322282100f1e582175186490aefdd0b9465a5773c236a44b35f51ec7b85c80ffbfe927712557e36557cff606894f90c47c2c277001eee7a0a1765ade09b4c4ff87abc8062961ef2fc5121a29d9a38a95b53bbd04ed126c3d7c4b6256dd56be3b26dcffadb91360a6a85aafa574b9d8c971d378c642fc54ba49a848cfc4c4bdafe35d33637ecdf8f80d904286399648725c5ab9c80787b914abaf851efb597fcb161f5bf32ade5114ddbbb45c020030968165ad8b2f1fba24f3c40bca6389c683bde2ec17b454319f1e53840ce93a24949a32f801391f7efd71431b6de341f510759d4534e26ea1b8f8dd6395aa6adb47f06c2d24cb2cf683debbdfcabb32821514a0f6e0f5b9a0f4bf3a5451696392e68fa565cefb6ebfaaba157be8a058e12f42abfca443cc3acd78ed1a25326bfbcc45a7e3759eebe044908ca2b506f8ee22c2968eaf8b49b7cd7d5106d9710dd7172fddd19478d67aa96532a4b11c56016d03c62b878132a0b8285e3741cae4b33fbbfd3f09ca9a8f80921fc32b00a2e2f73daa48eb52ce787c886f8e84fd2b0e6d2e871e75e3e6269950e9a76b4b983490b2f475496a18324533af434494819f7a44cac9ab8fe0b0f475218e27d72589bf4fc0dd3dabbe8fb927371d7d5065b511766eb195c9f29d10e2e14a0dc2cbac8f34ade0d71c527a5ecba858fee5cd43cb185a67c78e5255af96c1fd14070e59787e75dc13726893360d7414052231658576eb3a39a09ee38cf5710e1dbe21aaf6b0990f3ea2dc4a61683f4edded4304e604f62dea1b5335626b153b6e38150858358ac00185898504895b15c4c06ea023302682bd294013c872735c0885f5e979169a54cd7dc795661f979840b0b6ea991287dd426e080c79cfa84b6202c158716bf0cd5692189b1a45d689155c473a960f2b061c1b156c64278b4ee0262cfeb554b2cb24dce550ccf1d97c3a3ac0b7f6202e4cedb46174091c51e90c1c10fddf34a979ad590c511514bac1ee2180879516870448e83b70e5a38c1164010262f49839ed8b4292d4e1b0dca9491b52f2ce5bf927eb086e6e571bdf22748574dcd3c968da3a6d8e14f1c928ed301b2e1b76d68a6ec8ed12ef0ccff30b15873088f63eaf21ef70a492c0799f34c4b5bb508951b0ee5a74f21449375e95e697cbc31000f3acd841110e78b6da54b60c7e6175eafd7b54cce0507176a600d9bd7a04b52a96914338f9ed029fa502629b566210255240460a8cf805809ca6f66d748527429d3042fd0fdf4e1b06891cd8e12078a591bae6c4235c1e903e4ab4e5e1884910c33cfacbe0bed1abe9b687a196bf24dda4c4cb0f289aa257b98a9aa8d49111d7d59d0b28166e072c7e61569a4efb2a07c049b752de1ebad2c846cc77a494af67f2831d292513af5d7d0944d6d3475aa65276a1ae1202969a19fc1fc84b64fa470673f2439098bafd6f1fd52ed234e4c349d2dbcfc6229560f7f6db20a8062f3ae12c75f5de15b852d8e023891797dae48ce0f684c9cc074d7a8229dbc3738364561e544762cdde2edfe3bb7cf4e0c93958af8b50f2770f6ecc79e738c2cad6843dd6661f72657d8404e981078ce2ee745432274626ee5399e6cdb4a9550469c5faf47f1132c3a73f3d7d96e3a39378750deb99157daf8eedb51f47de4991def50dfe17473fb6889eef7df7bda79eba48ade04285eab32a9d0144b941c5a67408152ea0c19b3e7dbee804b3e86c6f986797f24bfb8a6086617d46f81adeb36146e4e38c89672ccf4388f9d93af39ccca554c600d2face7b5d0d89c0be8e4efd9855221ebcde72dc433e9d233f016dce57d54687d2e44712ca60f2ab28906c0e255a907a3d82212e90b88e048c26aa5d11a23e8fec9e7dd46c9d7eb1f8b5da228e933018ace88b9b4db201ca9ea5be5b25975b2905647327f6e7d869d4bac5f0eec0f2d54d92fbe9d17d1ae2c8f8efdfdc98980eafaa17c140f7c94ae5f7d0d0c35af001137fe85d131fd7d86736d0d859a3893477cf4bacd2046b82da970bdaa053126c42f8b7f9e271ffe6310ca080e26767228eceaecd5cf140abfbfadb8408399672ce31d296e73acabca320c103d52e2c243544533f882d2164483920d97070cd3571963edfbf53e116637a42fa5f74e65300858359bfc908f86fd863dc15784cac61bd4c1cdcd47ae9f7760c383195d3b77f5c64f9e77edc252381c26ac873e3541bfcba95de1d3d3a0463aa8213680b0edb72c06c0eeb46afa2caf28cf18d1d0b26ab4a725b399487990ded03d82ba60d2432686065889068c864c423a3a0be13e85132d42229e1a6ef114c8827e6576d9ee482ea93b4a4b74615f92021344a5b9e0de973866fdd647054a63249d69d9e74907041157fd70463b7fa50fc5e0636bddaef0a8820a5ba8011604e5a9d505ca217bdc899017d06d2e617ed9a68d9a7ea81bfd52610d2ec353fbf358a05917bb8c8d5d1e10325c9e9ea6469eb3e574bb897c4492da1ce598a8f81a559641d6f409723905e7feb6d6b9b24a41ec4299ac71abd9ab7e4ada56c1a5cb3719286e851e38873ca2e146be574848895c7e9d289dfc9846f6ccbad2ae8cbe24f9612e1bcb6579156e1c2e5549edefc00baf9f4e47d9e068c268a0965367ec23334c0a00fc117a9fa7efda0fd12e04e0c3f0c0186003aebd11fb930728943b04069c3e11765f3f0409a6550b80f36b8b7915a2e350c86e6f209dbb36668398ee567ff8bb9b23213f9076b36cb3bef54c6786117fed83ccdb6e1fe5a9255bc446ec4ac679aa0d5cef883dce512485816c38cb56e0db296c1c2e477889294ae8498721d893f6607bb1cf424148f0615dc9304d77ebe1a2e6095895b29c2bb40fdf994bfdeb0206472401163e607b6b721cc1083fc358a3e4bba49a6e0327c15ea433fd974caae819e72f0ed855257cad62fc41c4c54d901a9d0336539dc4612fe3f3f87aca0a8f183f541f17d73cb34d21b52dd3957bb687deb2338e87b05269f70eab2307e5d8faf0e796efcb333d4cd00082a3d17be3f95224edf86c1cbef46880335cd3f4b19eec902f0baac841fc4d2588d9407f171815040a152be5ba050c21b2d474ad1b9c492964fe212ca505d6b7868fd4f1d98a8f13e87b307a1ca3923d4773d7d531e751a3e28f7be2fff9f6442cf1f9a1d0d0c8335fbdc9e3d243bbb875db3aface250c8860d45ae55c58eeac17ba45f19195c03cc48da6c17985820646139b094d0220b7c2389e1c754f27f945b414df96150906c05548a14cba18d180d27732da5a2c70d493c640843f05efe0e51c8664ec11a874fce23f42b0e9e7408af9154a52bec31effeeee0efc8c58c1bcedde13a981a80a65c637c5d073bae8cb70b9a6f66d8ccf8120046817d4f5627c532c67930420bc13bbfc9456f5908f0bcd1e5e935ee663870bb64d107f0479f355f66a64970159f6457077e106e31b016f6570d1fab5f45e415ba3934cb591963da72833fdff1eb9f5b394a5c1c7d9c0a0a123c9e2db6a0c6144954baa95cd8d2b561ad3db25a32350fdd951157c7bf4f1bdc10396ca36651891a78427499f265782a448ff13c533bacd5b9244dd3d350d00fd11b1f21dcc45ce5aac22eda9d8d623753a61721c98ba8c658dcceed489287e931d3c20e6880b7fb260c27ec4bb34c81a72436b8315bb3216115c95e1bce5a32044790138656592d13293f6da6033924a5b2163f3bd89ce423fb9a9a2e342c5d552fc3e606b37227325689ff11c62b016ddac40fe3e7a71a1e2b0e9c8f7187b07597574517e4c237e6d0cf31ad3a131868bce530badfcd9fc7cf81cd39c488c2731294fc9c3a25afbae615c241cc2472d3c3477118572f4e9ce9761a46312594172cf6a61487ebea3c9735624c4909a13a351eaba582287580d05bda643378efb9b30518e068c9c7569720889a7ff2ae945d9848a0f0ca834093a84e9078b368d392d9b004c2c025ed0588cda616864b59283617eb2dc43a63d23199c9a94fa57a78690ad803effdadac74d4288df46cf15e39baee016a0fce5923bc331753abe5df9262ddd254cd42fb9fc60935045bee5ef6e47d00d9e88726d4c948df50d136f20c9b5a21fb8ab4e2874544e6e3ac8db5a7d63f0b6bbed60cd171650ab250eb5a2383b35a76e9e246fc480a07cc59c58672b013adee41c6012bf39347b5bd1ff9032d2ba9414f300212477ab68641bfc4344b2c3795a476de433ef75e0d701d2a34399c0f346cfca9e8d6a861cb69c972ee1f436fa0a8a48911ba07d341e27ff4bc6586a7ae647b8eb5be1af54e43664bfac4a0ba397ae3088f5c41553401c33e313a657f6f93643acff0633aca6979a890b2090e790c8d19d36d7f897e06b11a4e773381d8fcbc969e1712e36afad3b8c66dc953b487c4a0faf4f0c1c6145c31f15d6c0107a5ed72c06af1572e22441ea5005a98a1e74405f81f541195a8b399f180c1b5f7e49832e2ff67425bdaa4125c7dce00489dc65f4b56a43ee5ac16295262f64f238157cdb9410acacaddba51bc4b26cb3c2f35c0d44002a548b9f39cc7086264728e60f4bdbed344e861deb4bf5948deece5e5872132a0891f30589675902fd3baa0c457e463a3bd280c5326251152df79f8628ca9165762a210de73bcfe9baeb4d895864f257238d77ab6bed2f8c941b378bb501923c39966a89af0f84958f9325572b267f3b2b31dcc539ed14c564771a9368a8b180ba37546c6d04193faeee35ecbeed83c1c2a9a9168ca5cf3ed9c683c7ed34946b871cf22449070e0d363128e7dae5bf08c1659c951691f281f00e22ea95c0a6855bdb356b5b0a71f2063b7114262b165728afed5bbf617a79b80015e1c65e150b3d34cb5dd9349e652a87f5c0e6e698b20a0861d3b775afefad6693f071e53709274544fb6fe5b68a3f90d3dbb08d8b83a5cb1ff6039fa9ce899511f07243339d9d44b0a277136ee07252da028e116f3a4baa24df8f93e2a0841135072841ddb5d9a635dc0332419274b76806f59d7127cc7c3e57d6850d13ef6565e6275c0dc0a272e7be54dc20c59f4b6ebc6353b17012e507df3cea0193dfcdd2d467afbd21c34e33797717e892970bdc680c317328b667418208d54d3983d37ae3b7da06ecbd51e8ff2691789f3ab7b74d3769ba9371c4696da4b24c8c70fd743882713aa82434e82fab5b617f9ec60fa3db667dfb0bf4add893313333ed16e46376f3d20b6878cd8c934d3b261b9ca4c889571be269d5d86633182aaa742502bfe298a682e8879750f1f3513d8bd168eec678a71e1719e7832a769c629ab9f3172a8927bd22316e2e44ed3d2958adb2f3375393b468a838e28b7c9556aa610fb4796b8f4fd92e280e552de39b41c6a5381ca346edd06dd2a9a3bc795a6f2ccbdb99bcf681314187878c7fdda43abdb8593f313cfbf27ce48d1fe09c470603a40c2ad40fe5f0e41aa1e48e893b206e78ada4cb34aac39f3dc0989700cf60efe183098a10e0fc32a4254dd59730cfcc7d6c2c5b4f2f12cbdebf66e085eeabb7a087c58d4186b5a824d91281b11be36f6094dcd7a5b8c402ce64cad942e6a4c9d46871f11ed742f0fcb91e5e40f28ccc87d20f4e5896b26e562b8a47a5fb4f3d60a36f3704331986c422373555897bc0e72b054659b8907fa1d6982d50268a892581097cd0d406f8e3b075fab852f8fbf36e1d746b0f5db53f82dac1ad88b4aaf216ee8804a1af80568815214276d9c78313cd1be4c91ca7faff3f69741595103ed3e0b2739601bb95ffae73899e518b409bca499595f3d1a5dcaef00e4f62299d030559b6d0002875b6c396b8c8afff4775621097f78b26415abc36fabe9de2fca61c0790046d6cd448bb314f7635bdeb6828ae39daf8f3670df2491fa47f99e1b179ea27df8584e46e2b3d7cdd8d7f7eebda2791ac3741564e34d627b451ce2bf9ef4d70a8959aa16a508510f9be292615c965e1c95bba3e99c7c2f5b03e0eeceba66ccf4307c6c43145413bf109ed4f51dd0a4a7244b5bf3f06ce4d5a4e3adb1c3ad25238be8ae1d7d61612f6f05733f0b8fa8b773ff14263d180a75c8a04737bc742d6be338d2061e7ca22f54c0d26d579d9b02667d5029836103184fca0d4f285bc0f2e805d1a06b851c181355ac7c164f72dfcd5ebb7b7b483cc6d2166d786e9c4d7af77e6f5b1290b74005c5cf1f2fd6df93303b5b9076885c9828fd83089642756e7c90e25ec3d9265be542c23ca74ad6b96d2875c61b280618d7380a9b7dc4be5e9b829c8a23e177259cf39c995df368e17aa674ac61b2da7bf60633241297aa84833ccbc9d32badf9153091a50893231a13bdb8b23f8da0be55ec33345c3ba0bb44d55654c4dd03447c5ebd6c24891705e3e80a0c099713b1935ff011ae219ac37d468676ac345b6d1a94289acc185dd01392a9c3004a8c5110701610dac5b47f6353e70db5fb3a9283901d1e7fbefc262da9986164bcaa54aa3f771afd813ed646a8371cf69506253f0da36db932daa989689f2daaac720fa3a1dd92ad0d3ef7eb4c35ec72e3d1a0ad9b4ec330f8e4abcee42667bfe2f85242dc17efaf51731be2f09c0e91fb81cbd14491040649b0089cb0831e68f3133a24d94f32dca7ac326f1f95e9ca2b26a8f52775c02fa6a21def271a0aac670cc0214c570c057d53da982b00f829c62a7d4ac7a4d5bfbeb7da8b7f0d2cd8fa94ce46ac995efe0be78c3a5684f8c0566f003c4f8ec15d19399d0283a4604ad4654f315abea344360cfc3434c4fd58104247b4f7ec9c5ee12dd8750f969193655bb6073199a40ce110ad65d50698c6deea1b1fa714087b794f399d5dd6545d38c16d9ea6d6e54491a65a7433d4752daed1d1c68e6479a74da7dc202db029c0e1fcf9e0f837604e81a18ace5b9c5a638d90f4dc3e029ac595866e39c4f57ac23c1c9e843b576ee9f1906c49ce3f38c652b70afafa968ae5dbce3812c1c6109bbc051322d2d38b211498af099a52c1664237794812c51357f3f9b500cbf10a311471156e9663b15d4555f5e5fb0bc252c85f3f74cb0bc8af99667bb0fb49c692a7472829d340f88c7400b813facd3c965e033de8f841e8cbcbc86c94040b1a1136aa71eec1d66043656117a4525ed8960ec5f531d251e40f89163de8fee9e32a33ee9903824c63ee254d211726365675b1a9e77f7885100f9017535f8153e09ca49c5d85d2850ac419fbf19791c1003574a73164c259393bd11c02fccfa999d955543e1803276d078ca27201bf9079c31c57388261784b65c7f3ebe37073ab8ddd35fe089f0b6e6d8d34ff90117c3a7961db516276b5262ef624546cdac2577c032ae2789e98fa6b728a6dd89e54657c2a3ccd54e19810a28f7f20f7c3a975de4f6d36058dd079a01db9f9c03cc4157840dbc44038059b8b652aada8ed7367717312550f69f20101a6582785373d8966028a0aea4360ce56559ed8189e1e89750d5d221e83b25cd285361d28f2c1fb1460cc6f99667c0086de8bfb87c314efe95c5fdeeffa179a48d216d37ba86f5d0b992b0e15683525b9f7265de486a28a2784ba02e54ce408f906d9b7d523298def1da7db12498754e0194ad759fe9458e6b528abf1af68a7ac3d2b8710d8292974c859d8c0c288112528d83d3af1bf6d4b129c97204bf6596eb6256fba7388a32ca92e8bf7fc013d7d22f52cbbf70f983f1caedf997e7e27dfaef1c48a909b85b0a2981b720decd01473234a10ebb24390bbc846cc456660fcd007d7d480e7edba56f724777bc1edc6f0916ecb8d3251fb907e70de9d127aa6ddb1e4410eae30bf0d07667bddfc6a38e9c76d7aaec02c625309055bad2e4eba635b242a241533faac3d9df989849a0dbc3b5155d00ed780dbd83ca8fbac94f0846104227c2c33c706c8519e8be647e7ac20be733d96b0f79233cc6dd787b99183d3752c131174df3fe484e6586e2f5b553655a68eb549e01def6e6e9d09cc776fcc49c248184c28dca160f21b1e8e327e60f40c0a774d40ca2dd992cd40cea2829ec891d4d82d36fbc5c543a2662dcd8778ffb5b87d316fc4f6c9725e6cc53158b1985b8e8d95fbc0ba10148bd555dfa7483fb54a56b1d822320d012ccb273f67d82c73db7654c56780d1f7344eef10cafbc168e0f065cb7a894bacac5b3bf41a6533780cbacdd77448b5a94158e228fc558dba5bd0abe8c6189ba358d95d3028f9e215df91a46d01d3cad700c892830b60c1c0a0cf8c689fbe8b51bd16a17f220667881c066bded0da28af9da0432bcddb8b3c2d55a730cde3957739fb3ab866da8ce5ba021a482da9d131cb6531a4b9b4648a236dd2a88d4c757593038957c6c7575448c19cea88bd944fe37feb5b8cf4e009a8ac8bfaa05d9f39b16f7dd65fcbb7f84bb34b74e7dd7b95abad2bade2f91bdf65df53cf1d24ff59620a71d440524983cb1db627baa45d185d6385ae89f222584e7424d5d35f3bcdf71cc509e088f6bfda4c9b1b0e931ef94bf7846fd51f0eccdd1d94b3c0f6d137a4d2a19d7de77d7579b16ebf4e9646ad49dde67ce6e5e7da4b3b648144b08355e853d5d22cb2f5e494b92f6915d98d95cc50a19003495885dbc6fe3d828224d248f9ea97bb4c24360b6f4e3bc036d69a847513cfc1b1c24f8f7b6a4b8068c8a3087a04ca00e652e80fa017168edcb076e5eb0fc0a705ad834e9236b078f504faa5d4b7c47858ecf7f6d7ad11fab9c67d9ba9abba27b9c74647e658353bd91d51647ff7d6bb53d70ce4a3e90db0c264637c18af9a2bd40a46f8de80f4306988b63874077327c43a0079d4a3dc42d644a8d716a1ed13781c1f0598905e28989193defcccf01c583e7585d3d00708c75bc232ed339e644b6de2a8cf86a1201228667a69515e9ee27c66187623d2d62b4c4feb5cdb6071bfa097b26c81022abb6c50aabfa470bc09966dbcb964c623bbc7cda0e03aab65db5e60abd1235f434ee8562fb52c78212cfc8ba71164f283c07abe1a8bd3f8ede8b2e5a1ebc60183f156ba5ebd1332ca62650928c4a8ac75939eb6f7e6ef7356b6ccbb3e23190de2c967e52695da8651b42359166cef8fd28085462fef5682df07bceaf18a38c57a4127b0bbb667f7797c92650935464731412ba53ac2fec47a0d5cae29743f66a188d4b7a9c90d19379b20b37f6fe4d3cae779611ee1276d7db863a3c8761c7a85bb518e0d76061bca60c4e151b1ef417a15502d353f05e80fd523648f6015df1bedd8560ce4cea3a1810cd9df85468aa24dca604dcc7a041ad0bd884b2ee0b8ab9e29b14c981400cb9e889fe537b04de2bd1a3a1ce5ce8c8145539d008d0130cdd8e699a1a85817ce57957c9912218f46b1b0b5f23c08ce535b189b46dc7a59e9068d2d5bdae3df56243f58860e10f6097e44358337ced209074ee56b87eb6d2d210644d6b8a96e639a11d81808fd441def30bb65d846de2a0933ad66af4ecfff82e3761e6d108392d602d95a358041877c54af8bf9ba6b16b1cee334071a884533109f1855137686e04a35eb4bdf0e34db63143a0266587a16c2ce1e976a5fe95e8c920810a30d33dc56cc842f7ad3a53eedf681b4d8442b9741053a184b60090186ae8cc8b74a42a09050abe99acd2bacb8e205f28326dce2e6b504f7153400a5e21ad68c273bbec231652856051ad2c711ed63edfffc6c40400e0c8238d6f0d045b7b8db5e9ce8ecb1baa408b6465d46cba5a905544548aec2c7d43314928b2d85733650991e2a0fb0063a359d59a6ebc56ff15104016b7777e7055039b78a0c358b35b3242cf31450946bf5cbef760919cca8f9c71bf4d40400e96fcde9c9e37de7a204d0b698ae405ab1c3737430d07ed8f48834a56e8ae00ab13393ace57c424c9f7cf0ad","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
