<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e90c972ffa59a4a7c48addd7297733b947124ec6ca1701e8f4aaf1058c8e4ac1b99b50dba3924a1b559f3c089148d1d613f5918c707a891b992a8cc15248db5ca23c500980fd1e0eecc4c6c6ef244ba50a1867e7a65572536d9aa2acaac77c001c2cf3c128df97b622b8330e3917d65d10d0842ed5b3287631f3843b75c15360c7e1ab3503efed73978511eb68fbb09433cc181c7bb1331a782ac4fcddbfc0f518c6378e6ee3a3c7c307318db6f6a0d795d9783155aeb6c6a294c074a59b531d2bdb4d56fed9772a27809808f8c99a720e7b5cfcf1c01c3a13089aeed363bbd1738d038a5dbdbc5cb5cf450dfcf8635f35cc133d2b100bc2b26f4b0a684e48473e7148e944a8d0c4e4e1b3ff27b418f0e14374b8d27637559a27ce53e45805a3b689beee9a782223c2ddbf52297fe0ad4961a0aee7088092952f8d52ac4b6032ed7f4d12e67026e8b94ac7e0bd6b583efcb92291899c0ea174bb99f4f6adfa3ec2574a927ba61c491ed98efc6867b37cd643f584593bbd85bd1e9b597aa9f9299d3450f8677098003091b4d409220d9c45faef0da2bd01fca394f0e8598ed2a476c00f48917964b2f551c39abd63af033fc595b80ed9c3c0493824a9474f123e82d49c0a11427405499ade8950c3fc4ff72ed945961bf38eac852a92d2ce49f5abacb8ced974001399d504a3850c21e99d02fa576eb442766965e757d73b459a20f911e5125094979a4f303b002ee52e75c7cc7c2db14cb180ceac9bb713f0bf303b90bb82e49728b7bbf93f6928f973eda7cc1dd57873cfa9c57b0498a14897f37604fcf387d4a61f310edb0886135067529dbf51c45fc0f667d5330a4ff4907bb81eacdd384a15f6a65ee0223e7f3a0ae96477072063f76ed621f8822742bf1992a60b3489748ded338a24c3bb7420e7e9683328225acdd43179c67db759d52f0c66f1f4761487d789afe7ec23bf6cd16abbb60fdff95258776765b18608d9da70697ec012abf09dec2f9ae78da94a757198560497e2bd09dbc722594a85914a4835d3424cfe5ebd1df04764df82ce4976ece5f39694bc841e1df44dea3253e214a1e3ad3b24d69158aaf32d19caa7dde0b12d8a31016c6dcd567f2dfee5d37856a279cf292eda9381516ca7d6a7b84bebf3c8f1e67c944d45fddd38ebc3fdce7360496cf9830632ed525da0b2375b037ef36e9d1015e4ff9485e4580f382b753c97f67c854aaf6d55a7ddcae61d332b4da2ac8b0b18960141b4f1b3502ff0136d149f5a4118ae3e7d4a25961a04cd76f10775a010e9be8d29edbe6b7ab0ca2df783f0e599e3b5b82e9728684a7c07d0c1d1c63217b3cf513c7855751b98a8142d8f05ae50ffd2bf1c7a5efdf9155d6ee252f695908134ca21ddbc96e76efa0603fea3d61f483ef52f057c9e51abaf4888e6feac784041365d37ca5c71888e2c593f2bdd2e4ccb44ed4cfea441314d7c475e796da05d686dd78601dbe63ee8bc1f5e0138956e1e33df014599f2da99117c4ed4eb40ba41a1ce8f6f3750df2da74dc550a4f6e9a42378ce36999b7b45708b988608cb0e8b8b66c1a8e6457279a7b3efd00eea6e328b6bf123cf26391bbd03976f14c073198c3d7a8bf49cfe5654458b7c089ba52ca2dacd82ca5046dc6a2f188752e312b7d3917ffac789cea6d6e7409f1ca6bac9371ae461060be9870f69e5987df21d167fbad00284e9512a50fcfecea4b81b9ba69b4684203baa4544b6ab807dc32fa6bf7eadf5fb726a8763fd5cf2daadcec78f444c829cb641fb89c23ea958a64f533e82cb26f6131eafcc6235c7b094be2f5dfccb89b0e8f41b5d0631f8900176547814931d89a357a9d42065f567249c60b51133a5a23b8b8a816841fce68cbbbef0bc4cb9804048bfd3d450c9d2e7ffd96c40e928451a7aa36d9ecb9334dfa8140826d6f5509e9badbe8205a800ba2b2be9d72e359969b1791485e046283c5d9b5a0064a5a1ed079ab83b210b23998552966a72b12e2244f390bee5e4a8df83ed1b0f667919ad048adb0c6e594089bc1d40703cd26ba8d09e64d41af472e5e66b47ad7d63a4dcb4fb78f9c2f6ee9a234f9b7f27f19119546f27e970747dd7c12231d21de92e33b914182ce2d9d6648c48bc7eeeafc4bae11395ae70700c74fdc66c9e3cdb41aab018ffa1153ab3a1db54fae742aeabb6020b5887dd4861981b430fbcf14d585e0c7a6738cb58a81784adb823e4986c17728b49b6172a12bbb56996a6c8755300e2d6b3413af9e2f8e9ae7b637d1acb6f0230d512ff1976e43479ba57211a801dd878022e276c29a57d7f4a19cf19b5d2572bbe327d48a9036a2477cf6de832c11e4d22a4b1411a2453b658e2c58aed82bc1453bf3c1d1ceda30fde9c425c5d71cff5d6c7ad1fa5e1ce9e886bf38cbb1e0258c11f479b16a85715c556a737490bf5e587b86373759b4735f9e58dccd43ec40e09fa28fa53f11ec299d7c55c07627ab6ad91f331dccad8aec993569747805b4a372fe22aafb1e805865067a70091a515c68595491d566026027c91b9f816e3abf8b6d887aa289e65a281ea6e91d5dfed3f781fbcef0009d0ba335d8c1733762401aacea79763fd0b73687100f0f5663b700b4181b14a3f4025998e8cec87e29992b4cf0de5614177ddcd0ac5e0f706c2c203d9eb506a4725554a7fc817aff0121a6003598a6b3a38c55bd19192bbe102746ef389d72996af49705b630767faed8dadda11c750d4549b73bb4822464ba132d5a3107f21798653dde5e0d994d0edf3c16c252da841a24faf005c304916d5de1ad96be320c85c52b8ccb83ec9330c668ef259f0eb996db43204397a31377bcb4b931469f136794c6ea79dfa430119707220e650d3296eacd458d41031762492ee3ce09c568e6a60a612b80ade477a3ad58b2875ac2122955c2789dbb5f2ba43754d2e425cb4492d338a37e225dd0b63688bf7611c23ca5dbc7d47d3068c00125e06caca30fc19c1e0f1a5296972388d63b26a509001592b13cea6be19e5c3e234e959c31433a39868b28c98ff845b35e5f62f7270e0411cfaf837f1a4d6bdf219dbbf5c17a3e869a9d98851fb7591603f9e90d7b4d124fd07a5e9be9e7861597ab4c05ce32f97012c67b5582043cbb2eb72d9c82a90aec732ea28db42e2195eb9e280a3432dd6229d06c3e25fae132dac10664ab5edcd1a97760fbe8898023217cc87b67f3e2ec1eff767c24e27a04071f0031eb6ed412b4d12f5c68d24dbbda74b1389ad44294c5c01afe44a007f6ebf32c46ac0501686e1d590a46120241febdf9105668d6e10d367d116aa558a97b9a36a9100b72f6c5a380c50d2749f15ec7e5ae8cbf4e03b02cded2706afd0206f21b99fd0e21a15edb42a9c7edb202a1a8988a88fcdaf3de6049d5f8a26ef5279593630560abc21ad9be40080b4296bcf8cbcbc7c03a36efd4b32af3a7a5f4f39ab5ec93235277c4c064405f196edd553694ce5058bb7152188426bcd1dcc120973cf358edc2e7224161890b1f1c3a86354d905889ac2144ec31b001d4f1035615480d94f5bea78f4134d420818a15f8235095a2b6d934c35fde42cd7369f9dd01889c5b82b8db1afb3eff6c9a4f1640b6c48def899863d2c7941e168287de6e3a3157fb7d3a10d0aa2dbe9da72e16f60199ff076b18697885b00e5b7746d10764d0c7da2fe7737c729f5d783623da936296d65eb3aeb022b1fc6e09c9403eff8595d399bd63b63b0a9731429afbf8bc27457a914d189bb73a66184b4757b727d6a03bfbe5751822dd083a93e3fa33296856a2fff4b50bf317f782dfa8418af1842c40d6e2063ce1f3d12027a3d54b27e18a17e73f0161917e1c1febd74124657393c1d1415899711535c9757120ef54fe72f11d511e2a555f2c36f5da3afffbde0c70dd7b6d327cded9b3c4a3525f0fca6f19b625a37b52ea86fc86da1253e4c9c0f199eee298ce0f0307acb3f52e09c17728395b4b555403fe37b774ace49db17b5800e90ab7a650865dfc46e7a900ed4da065c81b80596011b564646f37903ba7044b2fee41682a873e703173771af27b4ad4798958a35bc78ad366982acefb39a9b84f1fc0374150e22b4c6c1e4ae295a0293cd5f635b18ad6751bf2e8e76a578df5c4054ec7fd20e1e73943eff01e078029a092a77622f0bd0c2b7ed567c60682166b7fe85d8198c27df5aa483101c978314b4f16110bd56e337ece22d421c366018219914fe5e7155e2142f04364dcd5dcd733eef49c2e40818876acc9ca8c3d7eed662fe5615bdf5c4690d69654827876ae7038f941f61a5ac4b4b097e2855c9f358de9c968e4b479da7a6ab116b19f27374ef951c2c013c580291f2d6305344d39951e6f1d697bbeaf789e9fe65aea6ee64e8cd083b91b970536be6ab3a6d63236a9abc29a9cc4c928a37890f5ceb7ebbd52df4e90a6487504dadbdc74429780511222ca9540cb0c13cb033b3954368e829a34f4308ffd06c6fbfdae8771cf7824e195cc2c295b93e8881de170c96eaa652005b7be48ad912e8461a5c384420c7b1514eb1d6559b57b045e3a2c57bcf5bf7d5f1d69b04001ebb1013af817a55e01c1f1adc04f4b3d12601ac56d139ffdc69dc04b18cba2ea6b9634834ed52308405028be9fa6c5c04fc2ad76b29537d24c51bd3ff32b0547a374292e1a147785762665c62e97781214d344f39bd23fefc5340aa805aa05cc22caba82f30f494452e0f2713df8095141b5d5a2f0a04a05e933c3a0c8554e08b6a00658db2660c078847cb462a1ac4673fb4c2878a02b86cf12c2a1d8ba83cbc8535a3f3501cfe83542b48caed0947af55680c252a49b27b8e78f644932cbff5c53684197b02d049ed5b2f1423d1277e4ce0c1d2609495414cccc61e7721c044e9cb2bf71291edb0dff06b5137746b2f38039a074492b5fd0b9706c0f593ad1e23b3234547cdde8e42231dd593a5386cf1913ba27a61bb5c2497e4e0cd499551c9252e57acf584c78b0b8c0cdf8f22fd5ed6d7404b3ab30d238b0fbd61a5bab3deaa05541bb8f1cd27727bb9c39695c04e0bdac773baa421c6c3f64b394afb230d9697a24ec799acb60d49dfe3c78f00049c9f400b6065d33daac04d8fe178d4743144c222526b392ffb3dafb022598675888f1bcab0725795ffc5ce3cfe5cef8d62cead127dc24a13ae032e5851cda076334519159948efd2f559aab4859a0a505aea3acb6217784aaa00cb071c35aa688cd68a72d350f1344783fc86be441aa018a22a6bb4e858efe2398c97f6d7952d87115b5cb866f66022eed39890007da19a47a41ad4d54a96247898b21d5e89ae2421985f047c3adc45902158b6f24bd8f06556f51da5d6268c435fc02d8a2bdd416fe0e27bf6235cc61f266dd6baab649c265d5548de2ce0d5eea096dc194b0066f4bd13d43020ffc2cdd2bdc4ac0ea4afce9933ac43ab346e9864473531bc0b3f8612b71c65cb8bc35cc3d3ee150485d91c5d4806fe5e3954ebd379750678cb3feefb8b7fda9df7215431106d54a181983cf64b9384dd34f75054af380b299dbc3500d2a9bd380ffe1b1586e6ff470cd414b202d051e54dcd07445dafb57b2e0100fadac3e2a7144b585df70e221c6c568f5325fb51bd7f317cf61be1c624140a50421a2a435ce15c148eaf2113584a3a8bfe39ec8149e34dc91f2ff07a3fda074baad0f80c03728d440524c29074f81f257612870abb230ea5446191b50b4c014f4d026c262b4e57173bc25e33d1ca53b7d913b0f841586a14025b9c20ef1104ed9711ba82836d5d8084caa8c7b95db9edc286b6da850b3be1bcd40fa2e2aedf42348b067e585df84405a723c1814de82158907bed7e052c34fec20121a375d090316210ad78da3add17f8d9977b349a25e49ddfe5370898ac22b6818b5005b55f488f7a099128e7087712f4bc2291308e99f077524b7c8d5625a95b7e41d3d7ed3e85605b9476120ee241b36b6cd857ec6319e606564395c4c859d162b5e5402a687c03964dbbb18ec2a5d5cdaf99fff5c1d657cec96cd93391336e17e092414552176b7aaa873187f549e3c9776e64eccc17a498836ff706492dd972236b272a1003121098eb3b62132b4da856a9e1317d9894876d279c8e5ae75b0509f3e049646cda91f6161113787503969d1c61635471f40feff29c60053f3eb37d43c8bd3dccf69b7b815e49260d7db58b0f56a7451c8003cd2fcdb6043fe7b7d2d8ed76cca163741fd15f81a7ce7bed98eda6a1aa567b054515b0f6e26eda42e4f6430f98bedaf75afb82f12acda804f2d4488586e5eb083edb7a6628ce5ea9fd91716c8b3f4e3a71ad8a85ddedcffe680ec5e5e1638cf632782d2431ad42d46bdf902833832138f2601faa111560090e663552a751df94c802228f11c77834b56e6e3102b42cf0d4cf47bc481f97a367770f75f8daa5b0895bc5c817d702f3029de92fc656471fc88f0c0a82ed1bd7f0fa03c2a8de5f56d75d305412835b76027587259919e1046b5c813caf8aac7a9bb7bce180e063d9f34654faaee45735d5aebfedf918edb9f757050357cd5d5c5282ff523effd4ff12705b0640e68ebc669758ad209ec8dfe5ffda109f6748389323821bdb2257b039ec7e9d27876f02ef90b68fc7ea53ccf6765547720de5605891d781f63e47f190888e831f4d704b3999483f3b7a67a2fd4c108765dd0a5071e9041af7c5b4900174d009f42ed658b90630b4979a76f70c7b99d5064dec66b96442285c6e9da4efed31fedc3bdafcf223242ce42a5443ac34ac6215a58149046f6426fd38014df0489eb6b1758f38f471b7448c513e1ea395dbc4fccdba60d4094552854c2c218ee09abe79c6835c784926b304c5fc50a5c0e7ec87cbe69503b2f41c18b8790281391627835bf9b757a51db3d14d26259159c300e4090971bde000ca6387b104e73f9ce834f9a02324139470c93f9ef7bebee0250f584fd107517ef192c749844c9ab710bc22195dd419c09a2ff1ad8af31243fe77fa68fac5b93148787b95bd72392bed48adef82ed7af564e6716d21eecc22e5bd26d003ed26d997dcd34670bbdaab2681f56f108125cb98d443ab8084dbe4fbff0400dc42ecd9a3dc2a46f4dd1df6989db1e539abc54b8801019cd6e9839bb31c8f0edfa8c819da22a54287d30c25deb7ea4ff116acf544fcd812504b138ae276a4ec76646d4d8fb0082bdb2ca97a45f2978069f19f961f62dab3fb0ce817d6704c00f02069f0bdb6b3f77322bac3a695ddecae3ba63a2d9d1bbb24b7c99de122b0b0988dc9d247f91508201e2994b867e711fb15b97f28112001ca26d4083562182269f6ea46dceb3496328d79b10216697f00502d5132f38fb0e212f8cd67502dab09621382809d4b84691569bbdb8a11fdbdbb78cee2b89c02e1345abd1e5642dbeccc6ba45f385a78deb6af1668b865ea520ef5215944ce4112391cea56f5848daecf3446f23304ff07d2ecdbe7a07af45b9323e01cff37676251d01d4e92ed0b04f6cd05e7ff5e6b7b3a21204dd4e91cbe875b2bcb5339bf03179f5374227d01384359039c60251f57ee03c82638c53960a0a408f6ed1ce852e620f021f599413760e1210db6d3965f29364bdc4d133e50d057ccb1beab15d0c9275dfde4b6ce276bfbe8a44386552f64bb21b1e43172f88114aae223e2eaea03798007ff61d563e59957f317a2abbc4dd168d3576ab15f3ab68a19b9fccc73b960d1aa9e202dfe6e9b7df22c8fbe2de8e205e4f709e167eda9c4c014843efaebbecda04ecef79d9e113823c9717a37915725026b326e57ab96d93b8505d77bec3710eff5bcc3aeb6adbd1f13b733192bb41fc4888e540fd26f13955848bb9b8995b67fabb3267bfb09b93f3a30e8929a608951e93703c49938f16b5f68bfd6aa24071e28627cffe6e98117940043deae7db6bb7ba84e289b1c10d4c7a1ffaa1791f75a5f479a4159342e29f45679ad456208aa7b85ea5a8c096d5a8a4bbf48578303b60fce413b91936f404e001971a670fc247219b140d0e1381f0fa4eef33a72a8e4dca935b64db19775893d77c6ff2317f363e62f03ebdbb7cb78de6fb93b83607e1a3c0dc3b740b6c2aafa1b76af3cb6326995692078e7096cb1cd6275f2658ad1f378a5a45e847e04bfe277dd96a53acfa2cd88c14bc470a2216388437c00d6c471b56fb3480d61596ac40d2fda56e135e773065320bd691c2b2dcc47cdd089371914dbacf228566bd6e3ee798e0e754ac5c44cbc6ad0f6f38f752118ca7b0fe2bd2bb3fd859ccd0a28a5b98b481c8f01d706dc2765514f126163419b6a26366d19be75745639da45c1b61138188da187d1e3ad315b649b1bc58ff17449d03f19c00149c26c6238ada279df4c6dabf571c104a4ce5243cfe2b0751ae69de6e8541f5120363831f78e84f07e9d4f0db49f9971bc1475cef7e69e5a26296ec65b7f20090f4add582682c059d6f04f223295f87614e90b1f598bd339d1838afffdefe8cb9f95b40879f69a378693bb88d1f38d22038d0feed0e9bca2abf05094531a40d4a0fc0acef6e2361b89700e05dbc866621553c746c6a28a17d79b87d00be0597d6f7bfc4e4c80e4e8499cd3cef7ac45b953d8ab094276353fa96dc24752a0787fdff02e61733f25a7f97b98ec1ea89e604d4da75e6bc3b4023adf2324cd78f067425baf24bd89834be008b03f254efa1c0dca576290b9835b9dd7fb2252211db7359765376a925a1030aade6c4b1e37913580ff6029114390d553545e0594f69403c1ddc6b9ae3774c62a3ce3c8c1b75d17c6d73b44b8b4a95eda04f5974dcd0c4aae993682fccf5911c17ae2096bf1575dfb8919aacb1b45bd0d07d0c1555744f823cc2d1e0e1ed72c8592114ebf43cd2b98c901b1f3781ce56abe4fadb9b7cd2cb790bb15ae6f67521f5b7b2380aafc1d77faa203b39e7f0dd0b0b4b403a35b9e966e0821073f9912a2e40d8dd28838eb00e06cb6b5241e59ee29ceb27633c8b5dae4c8a3e1ed7cc8c51f2f221f27e8d24f551987a912417ca81c6c48ca50e3fa799c000d182c3d4536b5612f3c1a6b7addf28c03726616afc359e289715188f6e8143fdc966fcab10cd64b19a0a6dba3e9c7aae28594a696d7e41631084d0d2ab10b68157b031fe3872e7fa4bc1faf2ddcc656ed83df91c510ba312e11b28b0f9d4013e2e88381af3f8064e239bec94db0789cde568615dfdb6b8403dee5ee18ebef71d2ac867ff53d82e6e0f70b4af4fc3814e54e052305ac6cecdba0eb1407bc9d42ae91125c96465d8fdf6d19ccd8325187b914bda5e51097364a0fa8d86d76a735fee2b90bb3fb4cb33422b6d09774a3d36dafd9aa4359cbcda7d1ce0284d12ab43f1e11a36775ce4d898e4d712c9f101456c7ae99ddfe61f733504edf32d7dfdb90e657fd73be0cf3ede2dad00c64281e76ec9fe9b6563987f284d832a6b453a1a2cf80180cfdd27ea32a6c61d898389e23ab9ca18f5b2d1577ab2e791fc3a289392acaa586964c57f11e9cebe5092ebbd49a1ba925564bb51fcfeba7fea02661d04a1a9a0557c2bd05c7f778dd6517b4bb3f32a4a7cf80e7095449eaab04d5a1b00aebf5be8ab8f79be02ccfbfa8d1a36a8f5e1d8b6a84ce70cdfda73142a99d58ccf93dce97e2f79ab357927cb509272096a8765f362a33f92cac300868028d2045077a6ad04a94f73c60c31623d508851e0fc9e542fdc6dd7418401a3f6d50b2ef4c75d40e28a7d848d53ca76aba45242a1fe05ae24ffe1d69b9c33b3cf7af21b15095176f454af30a004149ea099366e65731625b7f6da4bc7b64c92259cf80cd9968e87fcceb355f00d50ce83d4185d2d76b1503a5280a0e639ecc420c7cdd186f24d69adc71562138aef8aa762f80dc0d5239f7f1b0e49c2e7976bb469361a2df4e0e8cfea778ddcf433210a667a8991b0b767ba254faa13656c7941e457312ae4d3be98e336c5a6396e3bf5fb91de578b44289fb371f892567aaabd5434aaaa67fa957a853d023f1e0f2b25f15704757966e6efab83d06b104e79be88ceb0d874d440a409cca35849765f8deb768d2ad66389f14f4759b2a1b01c4ea307d992352669f338600dac77546980468783fb2eba1bc94b173a4b1a94fdfa841cf21d7416442502d0a664f06f9981a61bd7551591f9ae71b0395e1c1f4ebea391580007b2c804ed81851bded8ce9a646a82d71b5088cde675adcb00b5453efdaf5c935bb0483e637736a844c31cfdcc637f65503ccf456c4fc0d7a923906e5618a221ef3930a4c9604dc82215709ccbc5bad8b960152c17ceb413ce0885f189a1c658958214370839089f5748dee617458615ad1695d31eb05bae7c327608511e1f9d66ebdc5b3a41a5ddee3f567671e131de4ff3bf845e8e408b59d786192e379792eb85e4dddcbbec8e0e225e586f0b8f845740df7946c6c0828e8bef001b8daf0bc6729d34804e7a5bc2b67ee67db22d546d395de7fab8c124a91f9a3736c5b8dbf7da79a2d1f7bf18b71483884fea660e636233d75c8b86f73f188b9c95b9ebc1b5570be456614b0cee65dd1936cbc632a4a896e7f39e56784cd6acd8d18ac2b491bc0bac9d0b59a368a20bb3dacebb9e264cf1ae18159e583e479576b86381f42903a71d48b14b377eee79add6ad067653a36f52f9fe3b8c2ccf7ee97764e8d3c7dfdba67694883bdea1f269eda3bfc0dffa46cd0a7e8888c216d9c574cdf638b58ec597be6093ec909e9e9bd0497fdf668b5c814bbfa51bf16ddae0e7325d653d4646be83ca36e3befd460e385d76d18b8edf5090de87ca2974c60681e0d8a38cfe2cdc0b1febc651fcaa948c7e6b857829c1b87e48f36a0cf1059b43fe42d8609e06548bb27d30abe658252a3cad9a3d41c597afc385df5e7a164d7da3ecbfa67e1dd9d4370fe9ff726a6442ef95d51bf80d8c6b1ea94acf839a2482c2cbb57cd704f381af2bfdfd8388d2fae4c5112c03242e924012bc8b3e128bd0ac23443021310526b23183d1d631c99a416880003ff8f49ac51e7d8ee4ed25ef8954f2612d90eed598594cda323f522df7209e143391cc48a563cf15d920d4ec7535e618e32b7411a42faf22d6b6cf578d9cab5d180e0fd3619fcd323762992ee4b1de316b110dee881b21c31edd7b3e9ed5f4acdf57f926758570b56334574435ef52507b2bd01b93f5359990ab0b5fb3f6db06c982729002dd44333c9fbe9f568557fa5d679db87a20bb855ee35cd801d6ba2468c4c67edf7fbe741d786636f10d6105d28bf9aee00cd4a123102ac78b2fa447d426f3227b2b128cd0fe9cee1caacd25ab5866d001f852ab2b3fcb5414482b0c9d160df88bc0f1f28d4d2cda2bb40459b58fff2c6d4fbff8afa0e3e68b2caacd019d1082af47da523055a2b18ba68b94d14e7cc699cfb9797bf519ce347f306ddba6906490ffddc47b6ec1db4e5e39252cb38c7de899996a1d4ea89cbd5ee8d88abbf5f3b4042e355d5b148279de17e8be91fca2fb84d7908a8220329e08f7480fbd44298d54b71cebcaee9d2fcc918f106495cad22067e27396bd744c0a0272bf84ee57b4275bfc2e765619d67f0516767dfc1367ef1176993d93a804b137e2df3464e2f863b2fab440cc0dd49601c9c750f785062d1a8d5c423305ce0f935c839dd2586232b6e380b792b52cf90ec4a115968b75f695f4cd9b0a074ef92baf75003e2971f4e07ebe2daa6f6812b795921daa26a3227d4de8d3807acd459d30113650db29d86d79a560d8f38c87cf3b93ab5adb3447f2a192d24a9db8b205e702cb14c9497eda2083d20d9b59ec5e8bcec21c66cae4d2a4e52463dd5e055f9143be40aae50da2abdf3551772e94a41937416481acc0c24852fb144dbfd4c01775d3580326e41a20eba725462be08fa2adf41416de46e6af251025cc19224f51457774cedbaee075dac26f4275585c96277bf373771f21f08201894d8dfa5a76aace7c5f4ac0f3c58c973bbcf223eb6beab434a337fc5fd817de43d050096c164c2d75947b26ab5be55f8603936bd722efdbc0319eaf4a907175a66e60f61702796cb924cc6fe638c8de1c272f58cd7b0cba4b7287c648bce1df51198d75d8806d3bc9fba9bd704a12fa3e3223e8756fb5c295d2cbf4dd72b83fd6c227ce45431af95145fbf231b54d92472c325cea075d92e024e760e2df39c758a9680660b3e306cee2d89feda20b9ea4f3ab1ea5e8914d8bdf4d17de4b933555b6b9af89bda1bc5944c5aba249251fa5941eed4a1e929c307331c531a974e9a2bf32832cea400a004ac4fbdde53f838ebf2402f9e0786aa90d7cf328a98306a350addc3f05c7a6c66ef32f9697b952205b661808cb00708c2c58254f8da2704924ddd1d7c919182d19fdf59c3c5e5b8af060402b03178c2dcbd4c6fd307020e9cdb11378b0762f9200068322035f99b194b0af8e5e7ce368e57ffe27fd4b83fe9c43dc14407713b784fbeb10a1a4fbc67edafd1bcbea9a839ceede92f982bd126cf336c7a5a62ea559742ecfcb043dfa99878ac96f19f632104404e3bc838ffc4c80188456b6b38e9da4c67738fcd19771f7f29bd2a0bdb85d2823094f4d2d5b38b26a08f3f9b42534bedbbbb4cadb0649a4e6334da8b0343906214c74aba2435ca19fc831c1ebc951735341748b97f8ea99bf4b2dcb688dc6765758704aec0e87741b5d1138f39c9162962461d07ac780318e416406272b62bf328866a0a37df25270429fc68ef8689a97746454934090b515203ffed7ad28562ddc65af158b75bb1ba854e1b32d99a431446b022993086d67b9539a104b5fc5731260ba048206214e45953bd3835f7ee21027078d4a046e1a50b75a3a427820ed4d2dca449fcca9fa887f71b895c32c358049f02b9bffdc6980ec61e3025937da73521e50954e7c2719ce8c93b3261260a29ec30d9178c7884b2b32b1af427293ff8df55c14d2b13532d48163f6db1946f89f92e204867b3cdbdf7170846496fbde019b6da8f0375a686a4c5d35bf901fb08ecae4f079cd987e2a2a18619f3f3e22393bd14a44ddbe31e241b903c44a828d23f9ca34724655b940767fdcef4c7566cc1925b630b825c0743086a035739a3f67c451bef748de44663fd306dadc1b930a39ed95153caa2a5da5c430437ad4696e98b86dd63a68a20d50a9d4505d21c0d5a70f9c65b2782a756240b5012d9ae280ff469ce682e6541248324060eaa3b3cfcbc33927cbbf932f573c512a3ef20830a8aef9cbf68838fcfe18c167f44197af0125be552232da6a45ca75314f1b82679f929314b717bae606931c4d2cf6e4a1fc77d74e9079c705b4efe95185376444f7844111185d6bd99d53abc64feeda92811f5b9ed1a7eb19fe171dc10807b3e2cd0b5d82eea686e1a5d1969e891c87d093ecca3f635095001a38c6700a08e2d4617dd4aff292f2806a69c61d4bdb608c8620381c1a11fa966a72a82608e95b834390e7c3956416e8061c6462e23ef5921788743d1d42d60f08790dbf8b671f2a4804cd0831d0fa3a38ffa7127f2220008945dc0c8922e76a10f2431ea511b4d152c223b9d09010fec00323671461157de958ed96084cdd1fd2a6ec9ca17bfcf704050e26d164e75f83a7a6c862d13600717a630257e0c6a60b7e7443f49db4e601838adf19b842f6aef22cbefb8825470f15d08a04c6b439be34d646c4f57c5e2a1eaf6363605764b21bad8df4f3ac08c257e01829a34a54130788011b5619cd59108a4df9285fda373939e4ee4a4549fb9642178bd8f3efe033598299462470cc4b05709c258a637050d040170a3b7de5bf349a663c2619498a5e028eee705eeda38c84824a6514d3675b0b24f574a753ecdef88ed01a79fe3f91b53f3b9761af4e135d9026911129319b63ef1087e71cbd329cae7d92ab6d6e2dd7739932dc678f8ce6820007bd817a1f1683a0d4b1e01cacf0a6d4e6ef69be04779d1dbabb77f5fd1bc874d195624db120d408407601ed5bf8c6d36d68f11aa290aa9c69caf606b177cea1897c66cd572425fa7c2e147d3d7b64a8c2135e7fd5105795bf3ae1ce40f776468e8e7789a7a5d67bc3fcfb3e5ae5b829ad716945cd3aa84744b093464e807cc5b8f865dd4968a2a94b9d86562f36b1e072f1638bbbd5da30b24faad45dfa1b22831a41edc9a72ebea74f90c613de042ec82b4d0c4585e008c4ee5b687604fa0db724efe1618e56d60ade7f83508ba0177b324c81dde300c21c0e0735d7dc59fa491edb5e45de22023e6adfb5fc9ee23c222e617bd05af1900222e3f693e68d160135f54f56d3076f4c69574525ee3f2a163f18c09d969180bb8a536794e34f455949abd3473177153bff664bea8fd75a343c4107cd0efc2834dd7d676c565091723323978c32fd66bd6f5d00b09f6909dffe84f2d285c3282085395a543b822b7f211bc0172007c56f36b76544c273ebd73b268ca407d9487e50e54c1096645aa4a8a1d1d2dfb4b4f0dd1180345c89f465277e86f6bc47327597cd0f535dce40d7a9e01040707115638d34ea33fb1e77198956d19271f101da039d7fc05dc111a0e60fc1e9a4cdf0130d8321b8b077924deb2e7f0bb3e2ba892f1bc88f2b8a430cc852eb5980e07ecfcb0bea27ea5b925041aebfe6a3238f9f28edd2dc43e15caac7312bb33e617985d99ab640aca75a9550a76bef5dc5fe43a75c65fa5f4923bd175d0f561daf7b264a93d4732fdeda51ab68462a7532b0ac08a2c12dac1da90a3ab6ebbcb5d131d0f6c9d56c57e1fe041c70ff2d3a1472e362da4af2ca4d5315ce2edd37636492a5e2ca382757b9f2e2c7b6f2812f7bc8fd9d5d157fdaef9caf1c2d45024d56cf21e1a5a4ae9d56221eb07ff3f93c3de8c5d5a3e74e087d3e67ce5ce27e287b382dfe71b6b51ea6b144f93054e66aed5c5121c13c462f9fdda8b060f43cc7ed9c9bcefb2d3830d1c915158d1baa056f239108b611e4102ccfd8d329aac9ea1650b49386062e8ec92183c73a3f3c884eaac8ded16a606616c318268a2989441b04564a90849ac1eb34bce6bf52a9aa1fa4d555538bbd825b013f901b83ee419194cc4864f9ddbb6977c1c9546a33a0cb5e2ad3e368b44742510a11f8e267d539b6b0a1f414966a8c72089862de80a2679ee425e7bddc170482f0853187a0a8bfc82530312746af969521c8cee2a17a98ba9b2ef22925645abc5ed310482e31315deed8df650bfc89f2b8e486001a9d5f611eaf2b0299b9d03d31ed42a239b9b8677e754a6d44b0df51d8cd4e19eb503b7c0e479d5a4428a59eeeee38fa879732be91c04bbbdbaa463dda2e0ed2799c1135a21c463558c988ae5fa7b4d820d8d41e32e9abfc72a5cf690b38f8c88391914d54c85ca462c9bd7328f3af3bee1e02885a40b251b14ce64707777633c6bb38f4c976e13bfc9db12097620e369222a3e0ae3196296c742de8f90ce69da81167ae951db85590f97bbd98dde237ee75a812ddc0426676a3e184e56bbe974b0268964d9a0f894f085ee6098255e6f6164f13289191a70690406fd675b1f2c1983abd9ddee370f861fa294bd6ffc9ddfc6d6b070f256bbd3df2a34214817de7d736ebf6adf0c257bef76c0b11d62f8015ea3d29ffc36d6058aecb2da509bf9997c2e3d146b4ea16627089eb16bc31d395dc1a805e1c7348ba106950cafb61ac4a6559cc1bc72d015c98edd3028a0f41798e3c53dae991365e309ef2d48bf93073cbb92da356c778300ebea8f178993e58f71d8ffc7f6648ec288259b7da8b13909119f4cec0dcab280d9adfb4ebd6f721e200f6cec76990c8e5248e73fc3159ad07b6f3127582422f2201291a3b9b510a5478697c22c05e32a54f44844579038d7b4c511a1f1a4a65eb7797cf2e664ba4ad5c02289f4a3c7a2c5696dcc452c49c364af081f8cad51927e1f1291aad9c2f85fd18d6302b77f513895900f373e08702aa0258f94bf5fcbee5920187358a02e210a654e114ba7ec318bffdc477e39050d198afe714422d46adb8f595830df150f5e7869cad696e335f2fe6e277242003282a6420970b6e8385e33877acb6f716cbc760aab6d868a4588949d0c3f06a03d92f6868e81f0c1feb803212e6e6ce55d679b4c83c48b2e1ef04fee247643c9c2275efb7846151e5a811f3c96adbedb30f70654e26ae2965de14d77b2f00254873faa9842a28e249a1ffa2dd1f660325b9cf5c40355e40186ec9a6abdc160dadecd096c66c16581ddd324fb3c0f861bf0ccf9ee83f8311894018420708b7225ec2214263df0cfa983f6acba7d0c6ff6a00a2aa839b3c00abaaf0670e429c7261b9c0ff9ade84455c23af252a38ef6e310912a7dc660dfaca55c4434b5588f315e1d7469e39e254ab44dc97d11124cc30577329f05a8526e455f47e6606c4f3298e71159362f58da77dfad88d0c5063d96b555bdd8594e7d71f607ac2892be3aa86f3472f3a175ff0a79fe08f1d4606c19a4a90e1d9f0c132a5f9456d2d6a716e81b2664c9ac7b5b1fdadfafe49b14fa1cee9cc186d5b0fbfa6a4b370b957b27b4701c7229f575c57d865aeaaf0cd79fe6640b1f1a7f65aa3a13a03c97b78e7f13e0153b5203d1a63e419346b62f59865d4e4be3651efc3d4cf854a0765551a9a80bb4d306a804645d84ee9dd42383d5cc75784336edb14292e9849555753d7fe533ed6c6a25dc69e7956b845fda6255b99df470948825cca0590c943d438de38d5319b33487cdb92aabe39db2d644668539d6c247da68ca9887a40d501dd04f061f347dda672ec18fd41d46d981290492d25ff5d7c6e88d81e0fea71c12d80c8a751970316123c14f758a90d08396b8774ef0fbffe0b6ee3a943c9c63958c531f030bead9ad55621cd2d4dedd6908ca5d87bcea9a8c4153841beb5641fa0fc54aa069e5a6d69937cb72289410f8680a1d0c240c1c4e4892925be39d735f9d742e89d640f3f5c0de60e13fc86bfeead5a4668f538b2eba2776c0c478c9b103bf1bf308711a358263cb0ad6fb2d89a61eb9e065ae3f934f8ee99dd61989bcc52e87f363ffe4338f46b38b7b128e14168bf2972501e09d12c99a5824fdcb962b699528abd3bc00f1a024df6bb835fb66df69f974fc5ccd5d11dd2cf67354319219fc97856126631a24cd0cf637550986505ee7bd6f62f690590bc5026e89de7efcfcf3c67150c0cf8da5cbe660143d4441b08a97d13993fc6a38d0718533f3a5d47e90bb2355b1137ee317fac3f9467bcc23566bca1a2ad18f4e15e5c9faa4dde595a5af2dd05a89d5d0147b7c6248af9bede82c9804172bddcd947149b29169b4516e25123dadf2046edb05abf23d54aa8e386c3b65f999d8dd31863f0a8f37877ef54de3f8f52800590eda34f616d9f377fe5d98ecdcd5b53359bb6db7603bd90e520a30a4ecdd71e41cfc7937560d4a83705ac851d2b4573bd331fc9c1c2066c2ea2ff13a88510736a78a760ebd862112902d61f2150ab28f00737e46dc5bfe0080112db28710837ade83952263a171029d91ab91a1d0b0a3fdaf08de44be287210bc8a77ad2d3b5ecc679ec07c59d99005cf2cb032f2199f84de35639ffe1c4abb55cb7f3d061e82f95bc58f50dff58452876d0ec1b6f5c9ecc11d35ee3bca0f18babfd1568d4f86caf1bb190d4918685229924ca112ce2fc19b1072263a4ba2bbe9680bb18484838b0e96e16fbb260a827235727d6fa489629f231ef28e392989ccd32871ffdf0df2ab6d264dad1dbd94440a7543c2624ccc5a9fdfbc76322260ba966b768f332b3267c19c352a70204309cda304b23255082b61a9456d773ea78f7291fe2551ebdbd3714a40f3deb44fd32972bf40a507cc76e0e8bdabad3a8926235419499f1f09339cee96ac4d6d1e72f0c06b2968d3ee65eaac116460125097c5597010fe048439695dd89f6a5fbb326f6948b781d57e74971652a1d5232c8ddfe6b33693bbd3a19d1ab43707ecce748c91c6fa836b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
