<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bea3bb34cdc65472df44e16bc7083c7cd472def8faf22b38ac75337f08365de4dc87c08434f8e752266e22081f5d52f43eff2b7d99b26d2e62d346952f7a3a219c0b7364bde693011a5afdd0b88abaefd74552e06762df200ff5d18dfd5a56ee62737c22a1c26e48a31abf1105276227395f7f4250a50b2cc1251da4b97a6d4a365f9cee3d284f83acea566d6bf63af317313971cfa220a0b47be9e063d8240ec817af8bbce4c723fdd8cf9c6457093c1acee3d66b7b12a16f86136b2e02233d1e18121d36a0ca1e1af97cfed940be35521cdec284d3d0d33b8d8134dfdce68cb1251b3609ff91b27f2057e917a07bb2c011e582878edcfc8b2994704e1191249072bf562573cbb8bb84cd72b212a493535bdd5e229eea9b10b842e3562d1763c23b2238cbf34680165c327ea4764479a72fc35fe6f909a447acf0f9c5147ad7ca7451f30b6a6b297c35f7cb96e402c56070bfcf07a6f338c06209fc5d524cf68a83d26bb5a207d0d37e1e359fa7fd2c051f02749876ede6325e747a32977e95aedaa1dce879004b6ad8b55f0f7d013c75dfe5cc3cf090728e6edd5a2e34844d6deb1efbe07cfdb46631e84c31012439eef959def6ca81056bc573c7b8d4d2f95bee318f30eb64e0be25c1f41100d1257fa982096d19cad8160692893bd3b77e1dbcfa23c8846373b190f8e79101a97cb6e0be8e03510376fa889819367d996407e33d232f9f8e80561cd8fde9ebc45194f58943ed18a4b66d51e1e20045cd82aa741d8f5e38f43a2f283eff176f9ea776c3c92a170e456e06aa28093ce4b0180590040c7febd8e3ec7b9f58c3bf1f951bc76c1343f853e1e6ee95f7222087587d5974966a6ce15a7d454b514d5fd2b5260fab47b282c8475f976245ea02eeecffebd25f86ca21f216eecce01fccfe1f3e0ceed3b9331c144878c4c3846dfae8db843f9258fe7a0a0033680e9cef38e4d45c44812dda5897c343b0e93c5a30387a7f28963bfa77d583d99b83fb82c254b1e3757fa4e2222cef1019eca23020353131acae8663714a41143c3602d1bda834a05874588313e7f69d5862facc8d15ab004cad05efed45b63d060023dcc95dba7d5a07d06583aeda861b5c853e41c314fde09d09b2e39360522aa5fd21686fa60d32b390c039b773a7a8b1a75061318725eeca727d47e4734ae14975e723b45f06317ab27e5b9d2b72e63f1e04432913f6905b86a86c161e1c27d797cc20a7e135785081bf16c16747569cc09f488c35b04142bf11aec46d360c60656585626c791f99082a35eb160ad7b5992b8d780f9620d175b023ed81263b1e8890ef7443abb6c43aa0564369daa8cf78ca6e9728119e59b0040d0d411852078250c23fd34d20ab1d501e9baa288d52760d916935fac2a4a43b818c0f308ddb4c97aa852a21004bc3011b5b937a7756e3121c4c81b0c3490b3aedabcadd040b7682816ad90ce8dc6aa8fae6c6d41e27ed91211494dd3b982589df068cb85575cf447df6cde0fb455e3f8e996f43bb75343ad15e6df7714188ff43a09dd695982122817d48201d27a2d7935f6f082a30322e75bef6c770cf147016e1cda831e57fbbc96d4bf60879d74ea2d25e88254b466f6383e61221c43812aaff3028f326f140b7c5c2d87767ada0a9769fab80592da510e594b9d7aca7873ac199c796893ed0cbf25be5c1f73139d04827fa87a230869345e00156ce4a3df03bd5c0e9cb65f2b53d83bbedccaed1026e6c64371920d87eeb39707d24f5d0c9dd6f8a7d63a6351f315ef66a9b427e19bc1e810ede68e9e065e8a982b357666a3e85600f9301125b9687b718ed579f4418af746db2db3c505058a83b5667fcc32bb2b6c25794f054d228cbe8a807046f59b0e90d6e4ce963df1b0764cb2405cfc9b166efd3eb570d562707345a1621e5e57a9c4e43fff1ebbeb2a863d8534722961a73134994aeb6c72e4a1692894f1febe9e387e92519b59b8d333b961b0fdf4a4bedcba7d4f8573f87907eaece139436b9a3566f2ab85c63be232102cc850cb419db0d116fcf4c7a3175d73e2d46b9f4d4a64d5c5f866800c97c7a81cfe9819079a79ea2e7697e21910742eb9f9678e7fddc52153d62f7b1eab2af0a2d9debbb6f049e6277dc65fb44b20eb1f6f8c7522e15b7de3023a7bc5f311e1ee78fa13c6b5cf987f17d3fbff535cf3b0bcde4454d8e6e1067cb340a81336fa1c5b9d0ddc6013be1bddf739d95bc3f8a5ed25e4249bb4c2d1eb98d30082856e0aafb822d4aa562261ade1fb9621624b75c750d402d68ff087d95cce2874468655bf843641e7ae47e9a8cee28362879a6b183a4d04398769ccdd3e40a3e9b158a4595e104c872c1c00d0f81bc07489847be6aee28156ea947ed5a4095ec6271b1e609f33a2b5a3f90eec2da69613508392d6d11eeea3420ae1396356a48d51bf9bae06934f12056b67f9958d92ff50917f0958252d17a0ed841a506cdeccfdd492a02706b42ec29967f8f9b55d33496db1d05c399d93fb730bff8b8f84ece8b1e5a165e7526d1e055acc0062e64761aca436f9006ea8ea470378cfdd48358aba8adaa23d479a7cac9bc4a520e3ffe5a74d3d165e7703a9600b1daf9764240a663c4f4a72d17bdeea884afe0388609287bb0a1fcc396ad3001a5ae7af53f72943c0be6cf55d6d74b8075bd013949df32ed35c43225b699450f325e42e692dd8e52bb3d3a48a0b529f6097a4753a14d6bcbfbb36b114563164cd3f7c3c2042340f9e828cf4ac981c31d0252e806d065ad30acbbece53aa941caf539362b256bd79769e658213050522024def11d90c544a921661fde6edae4102ec28c2538f92b4828d8b6ed9b79e0e7eb03b787da5a8c26bec000e79c3d08f38342ad232a9f0a062cd68512f2b3a6b6065b5659f253023e2bcf12085232a77a667c2165ac2d1bc5831f14f22f6c48b78b331727b1e39a80684b538a2b51bf3bd14897972874c9aa637120a77e8bcba983d40f769a81acd164b5c3807e7a70510e4fad2f62faf23a9b758c238e4810260f441a8bcf344a7ca8eedc56e3764604764951cff583343c5aa695e23a129fd17f202a5c0baf7a1d13ad2407eb7345423376b19e03b82dce148690f112a042a490074fbdd9763cc62fbe492704c988090930656fedc34f68c9ff922fda6b4dd238cc1a30526c3088ed8a9812dbc5afafbacb88535b66ac71ff1aec89b66728c3dbb6651ecb175aafaa8696ed91283496132fcfa6e0ce3736a8ed1c34328aa6d547e3dd2be854cacfb54e4c9da91fe55069ff780d46151c0a5b111a27ac0f12ce91e42a2306200dad7b36354e0d5556911938a0f3fadbddd5a60b6d60da55b4f013c53e6b39365ebad453603670da4f3b3b4b89dcc876c81b71325ee1b2bce7256914dcb6a88e2a779b4d0a789b74cdcadc986eddb7d365b0fbe17e3c5cb5a4a663469846755ad89d2c818ac716e58bc0ea4d16a43068654b250d4bc386257db0b1551e6b2882f5e9f8f68661562a0174c2d3aa26e9d7e4aa7ab1c9263e44f932485d334b460be713a20bc8074dc52dcfd0cd6872a12ff7e38092043d6aabbd0435fecfcee9a3540e3f3df52e38faac3845c412ec4ad364d73e463c9043ce7f0b3cfe2a223972fc440164a78a12e2ac9f6cb10967a95f2c2f820fdbd439a667010ff40bfad225571db8157a39c659360e648cc2cb4ab848b37114e00743f0571e292255311032332047a1fc86e53a7f1d03d2e6ef35188d213889605cea45c682fc886aed13b462a04d34d0c1fe8198fd8a6fc160320124326d3f36c36d084f8e269cd0b8eb921061fe716c89496c5f8188b48cc50262f8b3c2f5b7c09d483f34f744fffd835d312126ea3eca46014e570aac08ca10a7e8169e211311b5555f05dc013caf2bf43aecad9a6ce0c0c830d1c72910e8bfe26f0068da6bf64bca25723d00412007fd06ffc295e8b823b786294958d1e1ed2d78eee8d90cba7181b8df2ed79057d0720cdc4fd3385a3704f06b2bba5489156e612a2c6311106f790ce9439f7a437fa45e475b5c1276766b8ce56e96ff4a498b1f8d9be199d632a645d1f1846b53e168dbb26474fd4b5dcb8b17a20f0b7335d5cc482f07d8f347634e9f78c44027530e381a1d67565f88b5674c3da820d5029eb3abe96c82519a769c78d28540d2c8703e338bf25d2f33ecd5f189a97ef7a88b8d68cd8621f1a79c18169ee53c304aab9249460cc156a36e93fd12e5589491e6c2cea87a9ba0fcfbd2ea3990b2c365a02f531ba36de5641334d8f1754e273e48efc4e7cd9ad436b126844db11e0508ee43b14193a4fe34ae7e5e9eaa44139b1f791bf2994a66ce2eecde3c6bc467ed0b3ffbb1233030e7fccb39958a65610a6157ead9ea2d50726f9724450f45f81af107bb5844bf2017ddb25e7f51a37f4b9523e7c4497036fa40cee6eef80a5a04bd56ce03e18d320009e7a513426635443f1436355956b55aab7d32327b7fd5325fe3bf3a8491aac60997fabdbeb1c76fe6929aaeecc8b4a8cf7b5f6c419ef3a2f79e07d51600fe4826d98f5cfbf557a0bdece116bfca6d588cdf378c3493a61159756eb032e4ef64b51c3ccfa9494a6cc082165007782868d24871e42a98c8462c74d866eae488e290533747e5bc7ad631f18017b24264a86de1627beb474d4317125aa7947aa973124d9f90766110d925ab7b1de7c5711c56b7cb2eb00e01cd5675340dea85459a9d14f90a944d83c1dbbd6f403f02b3cc7f635a248200e047e6ec9a491e155996b0a72a0c2a04ca7383adaa57635f16039cb165b037d8c24c9028792406ed1bf9b5e1bcd84ee695e02fa220cbb07133e3eb1f97088d7577cc7ba774b856ad194903b22ba8a33e0b8bcc060e11a0b2050971ac0993a4001397f1df67baa44bac994b4b27ef8b12d15d13573b36e16be55870a1ccee64fb60dded93fa653c473ae4ad609e12ffce273b27b83f47dc8f22d66b8d99548115b351bfbeb1b8c9ca2f2da82ee12e9b75ea48a5e180126ed9b462dece8e68eb40802adca1a794cf0eba77691f8e5e6ffd1d6acd313c83ee9905d5f396fef5e4b945a56b254ca20a2677b515d33b81f74e3f4a68e91b8118a2eca4f4c451a4cb4995ca1eadd0fe5089bfada12c7496f72f073b8b8567fee2b7e209143cfc53dd8ec77b0b274f68444744d9d4228c49cefd65f4fe92d7a7186c86a3bacb5a804a20f51d3b1d12602a65b153a4ea37eeed6cf1e8c7411d61f90a8cd0db826e9de12691474b6b31d51a638f357d30812325a0056161c09ec72bd1462b83eb84ca7f34be85d6e0319214e2d848ebf8c38e553309f8c939c38367cc97a6df81b7b19a3351027c60d3b3ecfc3d9fce82cab45b7033da83c01af5b80c5d18fe566f03510d67c325537439c530e397107aed026c7a8efd27997ba81a39bea2b0573d2a73ef8a5d309aa9e836f63511db9ea914efb8cd286e07fe8c21f7ec82816ce8bd492be999de5ff4cebddbec74cfeb777a0e0bbafe1ed97591ea216a33645456361cde6667c6ed79b5f3cc86bf1c57a535204aa603fc9612c7904743cffa5a4f889c826b76dc9799cfa2ca3558aa1ca876d7c3a49cebb0c9be9a2173bb698888d0bdb2f30f592530a6ebca8daea1bf9771988dc4a72ac4b899256f3a832042988d4ee602af894ac6a4f225dcdcf867422951e545ce29a358886c88efc2a919d42c9c147f2a877d5269cf58a5cd34461cec3a1ae5e482e16ceb7e755e041486104d0eb78709b0b75be0ab2e3f58158e0b098bd23ed534d694152898c39f06aed2dcc22ff994e3ffd8ae8c1e38bed9651880a17545c1768426372ca46f1e875a160699af611a6f979dc41f83516c71ae756ec870f2e96dcba965a397e610c1309a4965810ec6dabc780923dc586712c1bc3a9ede918524ee591bf30b2ecb8f21ec179cf22cc61b34786ff32232cdf97d8b898c96322ced7bfde533ba285daac3fe079265dc141e9d5a03f7bcdcf500cf58db314da5c762664168a77af8739203b6457d35a579a0c5f11254e708d2f306c207af93f26dbebc4257b2adacef021b65a01eec85364b4fbba53acb027eabee7d5ad8831075593c79c7ab9d07e0de8312eb58dfa8ffe05655396d56dadeab12dd96b4347caff21fe890b988c228cb9c0006d266e49adbb107db44aa6302526fdea19a5b99e507bb0a03689062f19e7d45250db82d500cff1a770ea9cd19333d81351cc68c40567f26894bf460da3ddfff1e92fd071faed852d0a593233a6e9d977f9b0873d5fc53235e1b64ef9403ccd7dd7dd7a15e6f4eaa254b03fd17dae9dfdfc6c0b0c29ab4f4d224259059b3f915383d52ebd859a468503f8b819d31598580344ed16a563a2bca54884a42f4b68af1f2ea840a87828de00ab3a32412a21c63b2b37bf030e2b458a713257c7bb08a3a04f4e21956d17520dcbd79fa3dcf3cead2b75c9f98ffe9d4e476abcdd8ab6102cc343ce27ccfdd06a1f69673ce9ccd087d3821d3bbca449c7a914ca9adda769c60962cda6a551402ffb407fe973ac5b4f6f2ea203d7c96f3ecd30bc08974b332f6016f96f5c702f513a295cd6d657d6188d898aaa47e259fe3077bb7b8f5df05d9c32bb73fe24a2f7108fae403d10ee3fc1e51c6282c31ae10dc318eeffb595427e3c037d40bc7733306a851131e39bf59fdc0805fd2afd7befcd7f52181237092d1027ffa61c6df5295b5bc6f0f78a030c96fe5420b8cb47ff97c8e361005367c941e1045ab2de97ea3018606e3417c4cf6133a4dc95077870fe8f6135657bdb1a15d3ec418c840153c36f5fb632cba89873365414d7513861377369010caaab7b0337050e328a6843d8e2e59caa76fbff3e48304ae0830e34024d13320d97e3c83f0aa84d4e8989aafc32c8027e9b9919d17cb4114ca7c96ce24de7223136799ab355d5bb52ff1f783fad15fb80d96a138346f3f30a568610b2071623522485340a4a8f0fe96cb3e089c99ade67af6f489ec93e147db87a13e183164c7cfd50eee1cdb2cf90eb329f646343b5831a5134a2ccfb4169f5657b1d0d3d127855cbba2f3398bf5853c4d59dd88ae07bf10a26dbe5f22c0b86c0085293c0faf2527a712e02d8e1999d3f33a3c366ffa154856df9942d7babc5a4d071ab3c15962e06e44aee9e0ecbc20fff6af4d33551aa45de89c6b06548855fbd1d77211531ba82cb5271d56c5b1bcf0f2dbd201b651f866594aad7cc6484f3ed32d5a3256a6ab0299bf9a70ab872c4299a1c7c9834650a058315b996600b4457b58839f02ba8841e013e371de7ef68f59bac9db53a166ed9f2c599a7989bf6f53704e345f70d3b46eb599693942fc46486c4593f9b6a652d1e17484520da7b9c66276517bbfeb9373c53c65d51d68e7442a5f2330d458a6b1425f351811f16382ac038416cf1f67451fcd5367322ec51c77f67ffd856b2d781063b09c82684937b228131c279d776aea42ffcaa5ef156e918b6a94b5e14c911d8cd89d568d1aadf12d19a6e179447ba21775c9bd63613fa1c2f453004029943117c53af21f3601751783d4400d5d75289907b1d357577f1180cadd3d29f5ae1f1711786c5013ee0f14359668dfdaa6663f09e9c7f98fde5ab6ca0bfb6c909a891c244af4f76f8c8ed495751960fc7bb5181feb7f04fd1c33f3e9eb2dc478d632ca129f3d345cb812a28b228a6e90e163678a32ba9d084a759734eee203a4c49ab5f3360b675b8add5f12b1c0799d800fee3789e03e8d83a64d1cfbd74373b079d90ea81d3c0b18cd73ffe45644d4c26938103e82525efa10049b78dc333cb8c2182a1de5f923d1bf327adc7307475cf5685a2fa0c7c94c650a33bd8d1627091f83f6cd319e6fc5ce38c91009b05f5344d4a73482af0cf4d707828eba56d54a73c26d39a0d3b9a1fbc7a00538b0d9c8349f3e99ecad6e12ce034caf3e419558945f32f066eb59dacfe5e82a119be470b597fa66e498fee7ec7c5b1ca0ae19eb99f73043acdf960ea510ab64a64c3f3aa33cb2ec0236905bb829fc33c4648cee9a03f7749f8b0296edab9cc8567b3419b8a3b3d6b12ecd85b53983e1ee0e509d1f427c91c1247d52168505ad7519773f12926fb10329f3ac92c9b7dafca17a5fcbbfb0f1b37bb09de4851b0e59018d6c242dd63d87df4d3e514115685eee0d83bdc8a3656bc6fcac5257355ce06994dcd18739fe8a740290cb69f28bfa95b48858fdaa6013de5150e55e1c5fc841059c79e0619e295072c0f659050ad94baafdeef3c4183b5ee340cf4ee21d0094e2399a6db2b3cfa4edcb7cb95628fbf0dcf4f313062c28a713f08efa2e2e84b9b5cc009f86ccaf8f0c18b3fbb46713b64d47ea005136ecd5fc0a0bdb80bd3d1787615dfc4b285340dccba925b0b7eba2db2b33781394639c88ec8c6138ea6637d92337bb456638767ff6f9ac41ed78078e2075bb2a752ad975ee724ad01de1ef4a419085d38b5ef7922530719d20d6e7b12168d86748f8c88581fed035e2fb617673b90d428b379b2646244295eefe5924dd95f05ccd6afae0d074c228cb4cda3fc03cb9212c74d7c469b676af9df66439966bae8a72068e6df575bcd783bc744ace4461ae9be5828115fb9c960f0ff844318ae6ffa200a1cb846c5b1f28561b8089bf02c5657494e6662230d9a3838a8f8bd327f39b14025f17adffbcb44e3916fe25da4e57e3e3eb1fd5d8a68a96d0c615c423a88b8a8c58f8c56b261a7497f371b47cbe912fc1540118fa569932a1529615ca5f57f4588e6c51193e827769c62b3739cd8f44c56d34489736552574eda56b88767b3bcd33bb91d0f7ee28e1d6104d786a1ab2313f2d93b9c3c9106d63aa2070e7d7e4ee10892b78118c721d966bead1036015a865a014a0dee70124dacc28583d9a9b754892b8640cc66541e4e1ef2a84b418652fb8529a812d3a844197b159faaa659b2eba7f7373a05190b8c8367e7bb01ab6ab512fe0a4d4d4344f7af36aa4d8d025fef4091fa59936a0e1c5c456fbd79bcb3e410623f65fc2c53c7567bc48e682a1b70ef4424f76737a5a82448c7a97d594fcd6afc7905e99fc52f10992b6d98cf9f3f5e2877f671393ec11ea7c405c051508ddac79cbe460ce18c9dd722af5c9f9b9209f06ab5ff855948088f19ca5d0d7e0924a6400b973db61ce58aaa2e290a25c363b0e32922a5f76be8a0a21f00704be562f87af525c4ebfd24b0b6b051373f1ca1f443d2cdb710aebbc8d4d36ec2cbf7032122ec4f3dde1347a1fc76bafdf262beb6effc606dda56cfb10500eeb35e3d62e82e22242f44fe1e71b87f0a9798470340c641de19ebd1bf0a18c61e1e1a8deff6e3d99f934be9e8fd6e26d7e011547f4e25ad8f4150a0691f3dd0a24f189d36189dce47585a1752c7dc7df7d3b9f77c4b5151052af201663fbc4a7aa918d65016d2e5ace1a4889fc26386656e3ee1e1ec8e9ffc621fbc972b0b91a72b7bbf096d274214fa3616a350f7da821c91ea2cd7a55df6eaf82675470997aa3a12212d28a96fac75501eadcc56ed01083f33ea631d58cbe338dc1074f1cfb677930e4b123c619a71d0cd7f3e73cd5b84200f9388c0d1d56a9a0063ab67a238f8e6f46b0c8c85a23608e08f142a65fc3f607b578163a76591c3f621ea7140c8eb5bd7a6b8f06b2badd9c2826f49a4b8906ca8dcda6afedbd5ea9acf879c0bc5eb4d3d968977ee2cc88be25a89507ce0c91da32053d1bd692e408588ad4ae12d722da1f4f50743d87d6065d02a8c59e53a95bf0382511cdd7ea3bbfb674062b30b01223a8c96b94d6bf60b29b6a1d8e899b4ead5a4a6e4a7c44507c018aa8d4a56ec00afb5825b30bf4f1232f3e47c0fb7c2c7f7ac2657a7c682112cbc18b08b88d0408417379b3f83c21f2071127e0a6cfd38b110210cbcebb68a6e44cb0746093c8344be577c157c160861945722bd8b93b13660f1557252414d92badb7afe441a17f74e98ba9e84f3da7705d567f576ddaa8023188dd7cd0988a7f0c0cced50fed6a7fe47302bc90c8b0f9ce4b92a2b039e0e2dcf7d25be0c905b167e7402ced4a96dc8c1f4823b49ff7a91d24ae3d6270ccc3be897169983d72352b663a7e7e7727d2c6e42027c04bfa39d46bd29950735f8c49b52a4629aebb965ee95edc951fa76b9adaa49711f9394264a887850dc8836842de136aec944f554d89c3ab178854c7d923f59c350843b092b7a6dba700c8828d31ca5604d9eafd59fe095cbfc3c60ed7224eead2f1f12bd84e2ea4229480609481668bbc71f63c65fc8713be4aa334e13ce31537a7af3ed3fb6d8b5893b486d4dcb5c692b0238b7b878de4862c0fb4eb3a153ce891bb98ceda66a7a148155880da149a4c4cfe93241709a7e4478e3c44f6b65a7eafce770ff8edb6faac3a3b5f79a2a1d09f9337d4c98db83ecb43ed10ac6a511f991feabe2e9364752722033d4ae2534c955fa048075acc8a33918c4967d549d2773b0fc998fa6606caba3a7c073e4f99a5d19296620c4b62a09e81a3ffbaeaf8c9a1aa55ae08889f6b8792710ca9371dda91753e3229d384307148716af90a5334430d5b0ec006c69c05b28284dd9fabf81da6271c5bd5715e83bfd3314875a1ce0b300b577bf994cc29385a89739d234f2740986bea9f3fb23ba5dc5c351e899651d41d39dc2158d74f0ecdb1685225c678bbf88b0ed8190b8e89a90b31b844f5e29b727b21c04317c9d7f273e469835f532921358dc60c0d8a156728e8365701427732e3754ee954d1c4b710c948bb335e4bbbf750f82cb86955cdce6c0493223f8daf0865b19f6ae5981b70ccef9780e69d28ebbf18a325312b442f74256a3392c65b69db961932b7ffe4af135f24c352224fd750599f1b032a217c89fbe9c3fb6256acf40289d3c3d8ec4eae7a1659551873cff494f2c19f7e3bb0ef35abcd91101ae56962c06cb559ca7320876dec151f302d3c0fa5d00c59502683515688f7996021143bc687a411557b7fa320c8b17fa37aa59459f9d9fd1380520a26d47669980aa8205c3d08972f4ba1190545a63f787a2eabb6587dd929d66a2da75bfb619f7205a793def4c46ed5847ea8b57c7c554e4a6bccdd8a16ed48525ed83a328f1d0f1eb55e103dd9dea90bf91794899d1f29a353206d868cf1ab7a6239637625ddd3c7d4b09dd9d79b2ddcd9ed7d632019d173ba34f703cbe751c88941d360fa278a4d3b9824bb7cd061b3e1a513502fd4b70fff59d6564abd946141219278402dd5e0d5da3207b583cc91209a472aa61ac3fdd1b55905f18e6e1fa482ffb5620acdc7bdb985a63f16899cadf7e376f0629ede905359cdd7a35ee4a547f760f3515e7df04067a79a3b3f58457b9e23bf5730d3000125417bbd525d0b04405005f8f47ae15ba7cf9031c3b58aea4e0102be120ec8f07a87c68fe672129c39985a5b435f2ff861ef7a0042c9ed91d334e10eb8de39c3123c62f3caedb469636e21dfc853073acd31f6d95ee6809a41807bb712c41f3214717af9ab99e328767f09364252ff1a295d64369a94b1112b202700c55558b8020ef1727f4652c3a3ce4d4a909429e3c0d6081944e90ba428f5c6b633f08497650938233cc1f1e5b4e51603aa5231cce28cffb0eed00e4edd0956451f094f294a062c1a44636960824846d7c98ceddfa217f19f41d8a66f2e01eda31ea05e9113132e4a1ea486340e874e98af0ea678b0ed592ce03d7c65e65299a6a50de3c45320d2aa63be0217eb0607fd647fb5cf43e581d6a648ce038a522ca03b098c8d6807374eeba07200d4c21568d0d6c5a05cbae69956bdf58a1e5a3aa13c03c23893a6b53dcf541293a75074771df05df64fba70c55b419589cefdf2f5a007fca54a4cfc7f254b4198680b61db70d09779d5bf8af27c1803787c8dd5091e2b40a08a5c2ce55b0c8d7a0933c1249c92b72d2d2cdadeb7379846ccbfec4dfa87795bbac690be097e3c72b9db3bbedb7c9e52e27e176cc25b0f4bfc018f87cd78dfec5bf6a4400cf31efeacabae30b18e9578a71ffdc5a596b361c02f28df9ca87d5ee368b9fbe379eec5af8734e0f2f70bb00d3d1e9a4bf0bc62855db7defe6a0e4b44c4a8f1948aec8715099dc8d02a9e7f0fc118b3c6da14a796a322d0f94bf405f73aa1a23a05c8d3d6a5839dfb615fabc2817fb4c2bfb54e029daa92f1dc055be91181f3d173a1278f3b9385d13c98fb00b60b8248da01536d7d1a2db781edc5e497e20268c6461a434da84926799926a58cce5c0205651e6f657ec61537730cd6f282b935445e0ce9a1ac1c9603d80ed8e7bee2c07c6b9639883403bcb88ea7091442d3a42e1ae8c10eda61cf9dee7c26c1a3982a8791afe9a50e80733b510e84a445f0974ee42748907a6a25888c18dd342ef1a8cae4ec4d5abf432f21c0e0f76cc49760a9b219fe5a1b3ee7fe1632d1f0b492c4caccfd17fbf42aa4fd2a215934a4cd721b6e4c3a7cb62c320ab06af1aa431bbe79f09986869cf757d0876b3a4c4096847d3d061adeb9752a7533b94dd0511f6c1f194d1c5de1a16a655c49f1a2d7637b34e69db4e8e50564d1ea03c601753632b9089e5d2b04d2a599450da3770a692415569ec58811312756193a20007f1d2d4f0aa11ad2db751453c68e66bfb5f88e09db7c81b3d236cd63c914ef77559eec8efeabaf4ad3a37517c87cad17da89d123a22bd79cafce0590e6d82f42fd8b58b574a04b99a77bdb5d46851d2ac0d68abe5b61d5a9573c938976fbc9a0b204dcb1beb219fdbe708d56d27115a1436ba55ef05e7b22c9d16b1aac820437902cfadbb52cc7fe61a94625b357eeed0e32d05b7d5f7225309f3fa3fc20ff76b7b7610fcfb1ec08f1c9c82557c9a96e7e4791f1538e68212838bb182bd4988fd3b4fb2eaf8a19ff48899cc067db0afcf71124b98c2fa58cbd82de7ec2f3787f5ffd1a83eadfc0789daef1e01e2e8cf490872afa85741cdd75c7e8a3093751bd86168c5eb6f0ed62253fb4f378f31b68baa0a435556443c3fb3875d368eb3fbc4bcba5c8e422006a7367ea463a5e1947b6f17a0ccde940622086664e7a6bf868bfe7c875ddd5f90c9b155e08e0d20edfe09cfcca0f4cccdf311b052d605e6dd484cad8e5f2f532c5449dd76c269718c6c6b4c354001b5708492e087d55626ec2808d7954016cc0bc6a7ef3e14a83d7bcc4e1e05d5450fe8f953238ffa7f87d0e3ae6608fc5de5285bc946b8ce7608a2278b224eeafb5389a3b92341181d4c3dc72cb8742a285368000c5cb64b399d82d936ec878c3993812e73b9899b5e85a3a0f7e8fcd80f67558554c511e25be6fe9c2c779f58d6d37a70f73a04304fcd3a26c3a74a938acf53f707a783d72cb404b055148064913f9b225e2469a771013af821544fe850647796982e420757ea0112a8762abb45cb433f796df52713b4423a76a90be6e4862f2821af1b99146e5f90ae303d9068ca291306d365ae20b42eb08756af886331efdde0b9d14adeb9682b89c6fa6418ffd16154a1f7aa25302a5dc0b53489d90587b208bba22ee122aa958fcb063cb52771f4aca44505096b6b2220e8bcfe80b28c5ad01ad8b922d4862a3a04095cc62338fae3d4d4c0fdfd9cae78cd0c76331381d4d1f9fa56dbc56049b1baded713071f88ee78255c9e0d450262835d147d7fb7b7490b97dc2d9205a9dd0f85ed273785122745cbec8ee7a8eb7a63669ac419ddb2af072d5c0a337edda616253d1b9d6cb82996839cee55bb4ba9d12b6c65b3645b422ef7fdb6b642e7096184a794fe76379bb064d2196a772cf547cef088cc2f6fedadd15f1a2fb86bc63fb0a9515d56954f48dbb959edcf5b8757847c406bf21096207b3310b69fd98486978107d913de230e7e26db3fea2ba3fa61b76fb9020de0d370bf670899431ecaba7980264d2e48845e1379f297b290a842bbb533d3b5a165bd0db1fb28d2ce6c3dfb647b8c88358150bd32a956d0ac7df736f2c29ff5c205a03f2e2a5fdcba47c2ad7a1274f4f3b36eaa68221871643bb94d04676291cfaa36a26a0606c9f200ddf7e839b16c5fbddfd1e42eeed456141436f1a55853263af7b01e47f0e539e55fb188ebfb16838925508c7ff608c7e8701e56023c8dc1027d0e85c9f096ea0b465e447262b55964f1d07450d697571d250c6d75588e3389eb43f768abe105e994ba77a1a0c343763c0d0ddf20125e4568b667a3b02b2be1eeaa6dd7a62e0fda5a6b890d305e1ec23cfefc30d728b48649f34a54aabbdf7c746acf6724d22ebcb37da4910533318c49f7b2ee66306823a1ef31a56d3d58668e9b0f76679ef654265a77069d34ff06d3ca61ef6c9203a3714fba07937b76e22ad60989e4a395a3b613a76aa350a969861a767c0bfe6c1fc5af4923f8846ead1c21af9ed4c81adeac85ef89522ae304b62cc6444e6b093d8d87580e75b6936883f8e751f3690fd37dc16ca34f48d5259835ecb4a23ce1f28c967d0aa65ffcc1ea664c09287e5b9b3f89d98fed8a1ccfd283fa2268a3c828a50a31ba2a4baa17189cba75d3031d5128d340ebd506daba119d806582eb629bfae8fd11e5cbdee75ecbccd6e1cba79ff0a6d62e071dac417ad0b75c2a6fc5b949348c629d33470eddbf2337dce14e8c90db3240d82483058bb5a9a061273a5b209dfd3c3be4b35d94ac8cf9a3b7b64eb0b8039a0f5c3c54e651557f5d292394de6fd27c9dda7f7d5783ec3df194782b24eb2703f2887e99b6a691c8ba4e1ec85f8d08d1c5f5495b9b37e282a9d7338ac8ca8abbf0ab8b8273ca917a0cfa544b96efccfed5cd442c37764c57eeb69fcdfd8d1fb601fee7f9f38471a71c555ce6df4b219bcc0db074b48bbafbf584c738b9780b719a6e6259cdb11ab2c3dcd7166203122c51375e6e89297ab3187dfc994c921a6ba7549ba1ee6a7458d70270740b9363d230ebd0c66f62c816470c25ee2d9716588fff22308d78a8f7ffd99fd0125396f0a8bdf58898760f003fa1abaf5988e608bdcf52d1d59d3cfce3608c76effe1d799d10267c20d364bc64225fdf2fe8b684c07858e7c687e5f58913666f9354f926e176caffa668c39a3432fbed12c95bda01acd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
