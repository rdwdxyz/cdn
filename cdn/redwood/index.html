<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1fac62ac2eb31a5f2f176f108f1cb0baf0f332d5bcddba51175c5f5f72b98ca1c5be31cd2a996bdcc1a2876801031e143e5c6c700e17863a124652fbe2d13fd42786b6fe130f3ddf58db6aae11c8cbbc2646281254fee0d4e1d93886355ba74fe283640d3dee8622e7358aa1254b1aab4049db193953d2eb3586362e7c44791c3aae22615175e2fd115e21d323d42d2257b71ca01c55eda4619986e396ded827624068aec4ee7fad34976e4f17797a8c54c0dc6818e17eae4f79eaa7460abe258e376bd1c55c16740de322c53e8a5378367866bf4b6ab82c802ae27cc241a3d4aff34221b42c6c87bdcfe1f5b0510a424a18c43546e39120cfcea068bd5e874ce3263db6254c217de633b061a974531924ac7c0aa7ede2f2c948b29692c8211772ce04fa9038f050d6108fbef6bed4f7aa01f2d3616057b9705f3cfaef4104529de23d391cc1aeb12d2b3ef035eff942a61c986d8e71af0647b2faf9e49d7804854cc77f0ebcfc6d29df8230230266b69d6e5954e4ce710ac661e8a7802214bdb82f8fc97e28cee7b569efc48398fd2629c2d2bdbbb961ce224959db52709a4d243364eaed3ab1899b002d96923bc9a212ac6a1bbb696e5ad71a9f010c174ceeeb62209eb4c3a943e8dcb66e41f2fbff6b7d50941bafc03c62287b7822dba08a16a12ee1a2a369bc2f7715f3b1896fffabaf19a29f8835bfe32e3ffa5ab8eccee966e3444d7c7ef25fe3517fac2e1509e96ec91fd6df132c17150a6d4ca59fd9366640a60cbaaf1019dc47ab8f30caeaba2c1ea211b7599c9918331ec6847df5bd7ed56093ade33e40017c3e1ad77dac5edf60983d7fc7887288f0b22d787223d8eae7ee08ca15a79c6171410bb25cfb283ae606dd0c7671dab0d106534892ad070b1ab7e9cdf212c5865ed134b2bb18a3d354f256b7f29696d1f4a8dcc9a4067084a601f99a16e1c58e6ffa8615e1223af2c031d8733ba2acee4b6e6eda7cb91e85779e1fcca6841300a49d3744c78129526e3bb84c50ba80cd507bec1e8dbcdc15579d6c1efc09536f464a670fc1533459b17ad2a3d4cdd03118d3fe9d78ef64cb9b703cbd9823ead9c547083e080f5249f95c2ba94f986686500432cee463bea39d9812fe71b12a8977c9e88c9f46c970a6f57c4c5cfe5b8078acbd4e053417b1ae6a8b2d765e81f641aeeac4b757dde5b867cbc5165c8d3b77659ae9feaceaba2cc7187b7fea2d6dd5580dbc5008d8e4a6e4389f95520f4639c73ca652648822279f464997882740de1338de16bf801ba751391577414972638667317afd671f89a3ab75535793b4e1cc4f40407ebf1895b44d760f72730adb38e514a7c1c2bc257bb717e024706fcb14b073ed44100a19812d8b543b02308d1df9d8b6e5ed3a4ad3e3c69cf57c391a455338527defa47551eea5216864a09cca8c8ea6cb13c53c6831bd783d43d4cad97c27ed5b879b09cdc678f9ae27509423f7a92ce495c42243fb9987adccd2a318b7ecf7001230e38b599c6542d4330230589d7c12191cfbf6d82bb13eb35bf2fdf9ec73b5faf878029ef6bc98897a978365033742a648ae365a4857ab55013fbc07eb40bec68f8a29ccc867897ffdb3f5792ab6e63b2744c0bc6f54960a9041298a56b17c88ae36b8effc5344a02762215047349bf7788ff08fc1029f2a13ba36eb85f2a4e4302377a05759577ddf4a8460f6852102b094d78fc761d766e0fdeeaac88791d6c63e638f8719aa76f81b5fb02652b474dfbf0abc3dd2e65684b067af4bc0f1274b799415cfba20d567b1f6d095ec4f71205d599eaf1025f11236a11021e1c8b3a1830df97a66c213bc5dbb0b111643a0d8b24249b1fc703d375935cb423eaf51bb6877d5e8e56e3a832c852b05452b1560ce1388c9ed0e9f6fbcae74219b4d06f5400ce7b1c2027a681f3be0d46a8637520ed0a7b81ed36fd57589ee5e98f86a2edb6d3761ccf3b028ca72ea17c97c2cc74175eb6b3620ae6b49f376c1fb88075f94571b70fc139c15ec2c0f32b597895c9c3a0ac83af83db46de6ccf48439b68425349c1f907a23eb80e238413d9ce68ed170bc71ac9a79cd6b4ec197f65d016a2cac381c7d269f9f3cef092f873677975c141e11847591b39d4f83df60f1700d226fc022e75b74cda93a2ddcaf69671dfdbd2cc8161436164cd75d59d9b9af061a2e13369047053ad917bc904b63db5c5445691ff2c57b4b9eecb055558a85beb0f9b50a95e1263f5f91f95658d4de434b1c4e687fba5320301ac66025d0f448a06b2df4cbd77164dbb69601dcedfcbbc680a8f2eca5f300d97952bb0d9fc48478e0b413daa60a743d7054d49b140ec24cdd3c514905461087f34cacab3ea60ce0d6ed18d17e58e0c59e464026f004918ec2139be69c9ac15f7ec0840025f3ef7dcd3b6877d47dfe38ead97070b7043e3518fb6d8c12ec380d2581af23bd6700cf7fbed2e370ebd28d3849f241de499722c8086bfb54deeda94bc8e83340de715e3bfa828d9b1a43ea986d027d91fbb9851749eeb01bc1818890186b5a4954ba2a471badea0f327c2d9f715032a531f4e0cac92aa8143ad506c72d68241acedfeb12738ee0b0719070750fccf1580d9312509a8af0f53e726498269cb1098d70b25a2024c1290d6c0d4c80e8d0e7506cf3c29cc5721018342c343ce3dc78749a312f72a0706efa49a833f8c3336c3247f4fed31753b52b9d5b8ac2d8df60d991b01ea09bd5426780655235d1ff54ce2da099184c0a711a7b1c649dfe25ef862497b4f7d8a10674a1c1f9595e92c3d2a8a275c44642391624c3fa52b1dff6f11e8eb2be0f5d0b3aa80b1dec0e26e5eed218af8afa0172c76a1c973b7fe1301f272bfae7a86c154e147651a4c2fb3b14f7156ca93b909a50c04955a980e6f8e8d67fac7a52abd4daab238be412cb8e91f406ec61987f6f1de079a81429bcc536cd623b47f678b32f37ca1994ff7fb38d69d44cfa02bde1e854354b002be209c6509606f3241dc5e6ce23f64983bce4abf5f35dc37c814b9467263c2f9723f1584d26d54e8a3c20f07fdce42dbc8d5c2a81233a93b7b620ea3a2e96a856c5def9d23dc5c0cc931152c8c33aa7813789c53d3320bbf5f05b3af87eff20c7b40f9352475a7e81c9f14b384a825228c69f9c2ce352989c1bea9e204a7e8c0393ac6cc49522cd8689c3feba05a1143f63908c5877c747f55492ee6b5039eecfe6bc2ea9b305ba78c8e2ba76baccea84544e723242a84ef52904e1ffeb1fb4fe79b0b6affe0fbfc046ba289426191e872f656ee960218ce52ef889d9b939ff540189a2c94fa08efc873d6050383139fc9b44c840603d9256706de662c9cc424cf3c0c8e5e2cc06a1436ba6f86f92327dce6090743d68f027e6baaaf44001c032944d09fac9ccad0fcd25c505fd0281a232cd2dd61715cef653b4ae8f35a8a4387a474e572a8a99701ed6f26b461bdeb8825973061333b014442e12bcc0812598c12f1f65244422bfb71ff22a1d8e9a2dc2af42fd185cc1c9a00ed856b362b3d14c8919e36cd69670385a706b3aa9b29e14bb8a327bd3287c45327d1a4063cc3a12b283e4c5fea920889b1620587851d72707c37abaeb2c355f5473db44d13bba6767d1cbb85cd165d37a77da4332fe063d67fdcecc339d2214d80af42a28007688ac73135b0ba415f8751d2cf563c0eb6439be4ceb784fe25c0c2a89ee4b72626b9dfe47c3bcfdc523bec0a50b38a62c381d68100b1198ed4d1a8ccde43f373f51b349b10a772604d829b5c47737a9aec3729947a6051677d3d37a7ba52b2f46871dc6acb760a80fd73d7b39c7675cafd88b9eee935991d6ebf117e2fff8a731550bf7714d569ac0a8799ac8f6abc82602561bdcac5b7bc3ee017f028d7d9b441f6ea1dea16269846f40433dcbaf8b1995debef5d028b4e30dd4581a3478d99cf5e9d5ecd48ee8fcaee3cf6a7ab206c3bc5c2c1a0adfd18a973bc43c6abeb2a68161a776a4fbe3b32b4cb99a27ba7fbba927354be2b1b7a683f346cc9aab686609ab30c413d7db9c4a8de4d9e27ba7f651ec97e6754f52b06fa47dc6cec01c39fb1206b1630c5d41220494d92e6a83976c25a5464bdadb8596d12bc393ee186e0683c3c9e6636c47ca9dfbfbdae3845358036184e8ad2225eebd0e52cb9d72967a298f06e9513216efc9eaa82bd4c2a5b8c00c661b9318013c0480d72f686e72b62cae9d82b0c9db4b4130eab0c25c4ce2ef80a6a7bb0a6187c59b40142c16284c9fac04ac3f4445707a649edf2675cf520d132602765a17820c2b74b5bbca26d9c67ded63bbb428b8ad471994aaca70e1d4ab1497c72ab5798bcc08c234a1487b90536948a1c603628242d009448c790de76eb847eaea4e3372398c136fd9c5b210adb16d720d4f143b83d52d3d2decb3c7094e1325209cfa560162e8c51dc5abce041976c4e716f4aeb282553f95686f3ca2c83274e5f5db57ad53d8d900be719b38efd2ea24d1b6c6ddce00648ee22a579ba13f823feae6d4ad29eea406518155680a2c840d55d02e7f67bd060815bed28f233c424750b4ddf6c02bc14425478cb0898ae76e5102887f688c70d7f6c076ef5541a6b221c17f0043eb8aff5883f5fe0cec17c62bb99c70b256976adcab60176edbd6db8b9dd7b923be96baa5c5042d0f81f3eeb679d6e47c07b976643afa2103d4888760f632d2ae71195b2fc89e788f3a473384f27eef44f951dba1de4be81b8e96fdf153580495976e0454d557f97076367e2c08446d20ead86d53683b51005cf7eda1f30b8f8287e567d1413d7eac9f5673ddb44b8b17565a6b97624e54ee563abe69fcc4c8159d91cd5c74cc35e8fea94b9b8aa7e64a03cfd5a7a4c076a3f3b85c03502e387579698b3ea6fd8eabf3ec232d06c9a450a8a9e670fcaa75df8c8dcffa0240dbd7f33cd2f87351c35f33ca64960a9b72f7e03ef8489cf692fa47e4cc48c4ccd57674ccec1e5579b16b8a08948bc5f45fb67708c61631924c85374727375d70c5d926ce3bcc15a1d590884bee66e7b5b264a4460b63dbbab59cf3a2b414ba8727ac9180c800708865b166fa12e1161b0f37a51cac799b419e8046bad72c7a0a72691249e3913204f5aa55dc85042712da690bb565f9592acf547bcc9db0bc866253274b36df182ca8fea3977fb9f98335a5657657904bbf82ac1f8fe3319dc599c05b8701d60dcb45c61b399b7cb4f5af27ce1437eebd56e8231fbc032640e7bdeb8bde769e1793f5fcb66177805b70d09a1747e8ee4540a1b9fe1dc8bba90b582ed3b18ed6367fa6ec15c53bc42eade86a011630a2f650cbc542fb95f65d9b2ffdcc0819391011663a354027d76326693da5e19ac607b1cff565ab12cf33b5d0941ca425f05a49bcf198e2e425eaf0626ac049034b52b64d323404a5e5132ca8f6913bbb7316afda5779280096601fb84fe6fd85473a3ce93d5d48e6e5d6b47cd10d2120f1d592ec013d96845e01c81e1dbbae73a06119b3502fbb09f64d438da8a0be4993468d0768f668d6a16cddc48a1fbe73b353a6a5bf943fcedd4e3019811d9ce5d874493ed035d6ae1819a63e423dcedd69cfdc384260a98a873b5f72cf872835225db017fd199a1f965814551ba9c6ba528744c13686a8b9566bd521294ea28299d9578391634cc0fa872e70cbdb6211313a807b4690373404acf2256edc70da1138abd3f6c8216086e1ae2ae1c7fd9787e38f56d5c96dbd10b56b2f2b0a1a81f1d759164203b05ce305be0b5cfaa6af4c53e1fae752966b950f42f25c8b598c8e5424cdfe4484700790114a1aa03c6962e3507c8638763405fae4f074e29dc8cebf3293d1a9957d5c7508c570c71d5fda9a8c2ca5c2e3b4c3a608cec61e9464fa3298f78bf89cf1276b77ce7261a55be9080552e213b4ba790e76bb6fda2d89bb9eea2645b809a8cc9c9bd2f6b4245c8e85ecce53d44c803e104522174ae00b39fbf30ae3ec176346c9895e81ad19273d4379679e95721823ba2fe67092b20f6e92018d47191ef95cb4832f302f5a93d589edb88c698b6a99bb3eaefdfb2003622ce0fb459299cbfee11054f390aaac78a2dda7a10a5edc07ee307e844cc40916d26118b3a563c7dfc8471d7613d6820f22a6296dd02046249e2639a2ef953602e613bd334b4866d1ddd6b193f2f48d2987b4f30936320c1cd30323df21bff76ef8771bd1a9e589c9c580b797a1ffa07a60dda247a0d9b5d82a96e62f1987982aada092fe1f640f3ad4681fe822ca90c0a87326a670546e107e6226cd66c12be619cf90a1114608ead9734ea9d4ee159e9dd4c35d39c47dd2d5b8d4e96c6ec2709de8b276d147d3b8113baf19f0af697241ea2c6e12442d0c8c47c4a48eaf6f638c68c2d5692fec0363cf55f38301625ff50f61f3757a2fee400ce31d7a48ea3b887d9c5bc94b68c4bfde7d979d82271900ef859d1d193b75e86361fdcfa173c38e0935ed95ad53b074dba1750713994b69716c1464a2663c05e9b5f3e66bd26ee19e22a4093b5fbd61c4eea1f1fcf87c8b4d22d840cb7f4125109535a198fedec54cfd78de2fbf9a62556c844aabf964bbe26944b934fa708f77db1449910cf085dc04c642a82562187468c9efd5aeaf0f8b379e5244bcdfafc18718c9668a1213446c74a6dae662e663dd17be4c895cb530633483175c2fdc76ae2e6b77bd520ff22e8841bd8a8db991dc9675a852c73ea7ae440b36f4c1cfd03739a4bc2a48a2637cd5ea5dac683e09ad27a4e401229c7fcf6f36d1eddbd0a1fb1128dca482f375fa5b19ba425b4589f9189c1a272aead984cd423caeb8ac78159876b2cb79fd1250fa0c6f5edca48cd58750f3d10d051b0b6c666696660ae30a781b5789e37605082f2fba98092d86429abf4b4d120b5e138ade0755cdd1f37130f953e16c5ed055e3a18bb2b639577af817d545d1df517eb41778565210a28c7e912ba80d6cf573d20e2a4de41592230d1f464bec4bb2441c10246395cc9b73b087ca197229b3cce0fcf696ac0a5ef672965d66aed4ef67ca95c31279a00ec25978632cace3e9eb8e7d1ca0ffae10e18b54d43c4e2dcf555a0ff410fec8366a2eb5c1be7ead36c1eeeb6b74c07193e398529d203b884df863be4cbc0cbb282a56293034edc391c5863f54a55876bf0cdac1e67acf3bf38d0caf375af77ca515e1cf559eee8bbf1ede663ca82d0b66a170ad7787b19213882935a71432efbad152868214428916c280a7f3185ef4a28c66ae2009ae065cfb4e04329756ef6282d9d6e46f4871069375113425141f704c04c10d5ac15fa2bc46c91dddca5fee62824857d26e257b0a2221e1204b2ff0255492d9d8b48ac31a396ed38501edd4979c41aab3412ad4f500b51efcab2a44fceea9e586517c7c531c63bbcd46df8ccc66a6709fada583f60c1b25bb8f2ff334aecc665f3b75ad62efd8255b6bb06d7a9c309088f96d15c113067b104dff2bc360447231be1b935976373b8dd32cc1b6c9bd861a96555e9050fa85f1863d6f59f87b3e0b9f13454b4bd2758521f66173eea1737f9d61534014f53114dd065ec8dd26957f8805e6cd19bf0c672a0cfb1569cae2146c9a9b9e8e2956c3ca345c1b65b2ff7a418eb099992fe0fdb7470accbec26ff927e9f00eb49c3b8acace983ec4261c270775a99e1ed85314f7a903607daa26584d7e4e9fe7042124d5b1f3828fd7178e01465241a1abdee81507cdcc0a9db70f6a84b1ad5c1792370dc387d386486cc6c2dbc1d43760e9cf4f9a71b93cc7f3b6fcd0c9b5ec02565efd4e1d43cf442c8f556adf4e54ad8aae649e30e7809f5fcfc93ecfae76c8796864449534be558b830b16537a2be450bf2f9a907be55f8669d73cdd56301d0d69c1eeca5c4a593d89c0ed65f37747fdc00f00447e5eb0b8139727cc0f21203b56f9a9712e499522d2dd9b8e1427f9a53e99ac703f12f4597f5f38b46170d394382091ecfa02e90292061921dd2e375b457c089ded1887a51e091aa0c910a0b6ef34f1453dd13ad88388ab6e40d941ae198b7dc52c94cfda3551ab8ed7a4e14128be3397af6672e8b74b195fc83b163481001f9e51f54f0558e292a1c51a0a30b20407212cd9852a1de1aef2a1c8cfacf33ed8c58b8dbd69ea8e7bc82004bbbd437c4883f19edd05e63422d8db24f27fceea3dc24339ce3302c33504e66c7e690787567d09c866028f046689249d9aeee47eb5281e0e73084e6556e5ee2d2cbd7cca58462d74cf949cb157f9fdeccbec7df49b929017a4fb818e2c0f9dbfe5287f56bf375a537a9786d5b0b4eca99c9613bdb03b729447cbb7d7157fcc372e3cea9b293b26de281c7f10d5529e99b37eeb15f5712fede50f5da3efcabfee3bd13900202285b5c9486a5a18eeebc6d356280940db1dabc83d5a7acb714d75b2d4626f2862e4751c61b788490e697c817ab325ed01b1f1274252462779bfc22f3d11f10c7ba4be02b9d5dd7bf942fb9a8ec2b1adb9ed509d3ab596a8c40d4d84ff0a72115c610dbf6ffaaca2f1ed7da6e85234a72361d041f913f27f5d017c99f6d47172263f0439e08fd89116ba6d95f5a5ca684c3c30e0b38c1bb86baef80d577ad0f4b3ca4474aaf4d87fe83977c3bfe891b9f4f63a6c1e9a5f477fa4a8ce432f55ab297461b71a7501819ee7f7f3d6bc207d3558a91b9dd12d69adb81f531463f3679a246014a464b38d440311c8976dd9222b53fd64aff201cb1b55c1426ac0a227566d9cfe8123cf42181dc4c5d7e4367a68f83752e11054946ea58943332a8c0ce927bf31caecead33487a071b700ef20dce47184308d3262acca9c7f6620f5b1916c444dfafa21d3534dd282985d71d4b3b545a9dbcd2c1c44a8b51db366a55da7a659b7d267482532415141c9b1d6532d6c67897fac8275391f9688c27aedf7c40404f13d41ec96e8e7015f7459c96eaf2cef0da2a2339bbd13ddc2fa84d74b2d97f592e53b1a938837e756dbdb0cfc43e4b29e8f96214fc69cea0a8c6b91fc1400d2fef97d23745c9a51c5163beafa54b6af1b767f24c18d7cb3c5a5603dfd3654a937af21ea812970fb14616ce230583a6b4f9da827cd8682400e4e26925d4fca3cec1b2136689414f559ee0bcea50940139c2a82be17c3e595358749726150e06e55d1f7c70a54f7fa3abf38e7598d3493f2db6b0a74c4e0592dff05c521c7dd1da15c85c93627f8d48914f8fafde2dfdf97ff889f910a1a97b168a4540a6aad7b5c54d00ea1bfa6245b36b22e17f8feb994ea7a235950a48250d4bebf68cebaa308e247113ec208ff7039a9cc135579506424653b8d2ff8d2c7a61ee743a0fdaa9861fbe96331c2237737fb6d8c232083e5acb32066a2f860923cfc1972f8ca0207921f99992b7d06da9dff81d4870492092722bb33acf6e9eadd1a04a4e3bad2f47ccd13625348fefaa6b5d588bb95d215770aa889ba44edb38bf556c49d2fb3badaf66cadb9e469797c2c610b82b78b0a77562009797a89dc327533650d205de1bf74c7d6170a04f85b6994fd48510378d23d863990509be82334ca3c7ad32b5011d1cb0d3711a23245119fb23a91c7a067af6500719b7ee9088909423ac5e0655ac81179ee1d6ea5e93cd7d72e7058dc9bc3bf5faa47e8bafb222df7a0a92689338ce09c0e07043467d5961fd9a69923b8075ec0e98689559e8990363fac4ece0f3dd64712bf56ab01134213808adbb0d62628ba2ced2314473ad7ebd8c93d928e65d44d1c399f4a52543d4680ff4142b6d884be9c3e21ab025766cbcf5de71006ed72e0ebf5ff339c5e3660a6070b7676fae69bd44200f74cf63819d5d3814bd4df346109931bd45b954cc19227c3335dc5120d654ad18bafb78370b0fd648507056ce5948448d804602edb2d24d43dbbb5eac2b754461739e8c2e6abef28a5f10d47bb2c9ba8c5ae2be9b067011f1002ffb5aba14a4975db1c0a59369777649498038c12d3db1230df7c3607a00157d81d3c1a0516d058c00003ac47329ad37649086c2600728bb3628947c263144061238894f0e8bec20acded2fed12d28f20f2708310f2eec2913ec9299ac96a5a01541dff1ba03dc068351d5712d0da4e3060d1c44ea618a204a9c00e6f11caf02f8c9fb17ab5870baf5b2ec3c6fd3f204923c4c492b2d73a447113b36d01734cd684ffa4d2a0535265f0ed420238d3ea740137b15292f082c15188734e569def729d761dec16f09e414704686860e9bfd1449b9800c1aefffdae156932db88357dd37a448af21a3d275e658ffd2741478681970bb5bc78a89cf8b5846d2a39f24a1876d804d645c24e14d1b6788e9523ed0eb1191a20cc26d1d7c25ca1abe9c7d72d4de05200b1a2bfb209fb033e32225dafea3bcb6820efe335b5b4d9f384f05587539ed8c70fa9bab52c9a4279d7fbd20459cbb684d63925128888193431e9f6c9b0527a938129e98a8f9cff43fbdf0ea1cc2419b472edb6df1824dff5edb2e83a27e0a534eeb5a3d68d0eda04a4e0e8fbf2ee323468372374d35ec778ade304f6f7d5475be147c76668f74c068124b68e045da8cdf124886a55370c17aa445653d53383137ac6116e610af402f2569fb8c3b4022e10952df0f3efbf6b698d103e0ae68904e625f730c93686d068bf5bd2b965fdf0c22e13c0295c834c24f8798a4be1c90ff5de62dbeae258391be71d2a8ba0a0abd931af32abf3b6df45ca6f44b59188b2fd4d833efa8d1b0301687b41344994e605b0bf96630d31ddba0d2b03be5bcce296153661b44bc388178fb00f4b0078edfdb950620d7eb718900b9413c8e044c0d33a0998b83d1289a9cf1ba51a15625dce54140951c1d98687d6249d109997f2c99ea680fd9ef08dca2ab70236d02272b0881db0fadba5fe4ef1752ed5ceb43c5d3a19123fc6cbc300e5d62c73300888be7c608da9228dfcdad3d4585dd810ee0a44cc2ebbb741e1e6fa4f67eb1babe6c45b684b8092130cb3613f9cedb3341ab93e32e02ffaa3f9487841b47865fdaf549ffd99eb271512c8a6ec4063c27411d330480c3d6d1e38a782d8843eb3cfaa03281f281337d1ceb9c5e596b88e16d48772bc216b997e51b4c7567bcf63ea00d894be8cace6c37dd9990683479830902516f686b9e90121a39b919c70ee8c3cb1fe54a5e7eec6e2b06228c09659074b4c653ad4b53fe0a6fbb4e1ccf657752676f3411fb9faa7b20396468d75a114eb85841f76b66b4680ecfb946b165ad38397893ec1fb26cc24cf478102abd29bf7742d65a1835d382843b69f8da6f2c194fa47ca9217d443c157028a159e0d90953ddd10d1c04ca0112cf10c0c05112927db529babb84bd549aa49008ec5f7ce07610c6aab29c4a0044eb0b5ce5d7bde24a83b972cb419942c9817c5f662b5b64616ecdb45cde321ba1d83a5a5cc57ce56eeaa018b3c1dcf44d8dbf55af71f2882c12ea32836ae726423eca0a6f065356a9200eb76bc79077a7abfdc347ad1539278fe6929775b547aa008bc343b1420126b001343904001386dbbeea75f4d10bacef6620a0276b7a38e67c3d06841f0a9c28cc8a746aca17f3776bc26f9da892f45afbc225371ae7a040d87e2a06e1301e51cc0245a5b8c4181bf961899e402e82eff2ceda1dc3b568b170b9a565f428aac3bad3b179eebf627131189099b8b86bf863d10a362ecf8d232f7b16aa4b55a7afd6f18673dfbb5ea90690dd69ad87a3ba30811e62b07601ba02bae9a86df5166eb29d7f47548d864116d3d8e413aa2d11e46d74072141bc2fb5d7b27af012340b1be509a0623df90458d17bf8c3d23590beba9dd5d2cb67d76d9a7f59fa2a127652e7944bd8c77924e613e19f266d31f6600fdd131adc6620793b511cc6d78fe3d760de8a05344a23f1fa3b0abbe6084aecfb9beb14828729e85988691ba744eaa776267da14ba1182f2e0735e5f649bf51133114ad83a836ba2f7c6141062ec62102c970c3ca50b5e74f4abb64b468edb17bd9fa4324bf02ff3bc7186b5f9cced4f9ae671e18e414e234e0a7b49ea5162197f91c34d20974b31e7056d9c04f0d734b9729de8f7cf9d009c0140bbb9aa6db193ff5c873b615da5da93fa9020fd44bc937209a8e4f9e39c1cbaf80d18c6c5847f7bf365894907739408a6d03f7cdd34e4960bc04241f64ff2bc4e4c6b03f3f022f8e265b153092486a7941502d3e246fd995958778c964fefbeb7fe8f31a7b37433b27249384e4743247463cd9fcd95225ee081b1ffe586e44f8eec9c7854f9d002f57b0055d9525b04231f1f0ba4839d81207af1534049a69cd79df709605707edf0a07970a5b3ed0328c1d446c752b889ee7ce49aeba694925dcfa90b5a83d6a1005465664cd6183f8186dd8e782fb992cd752e076a6caf38a4b6d94f90c6e758fedf687e78e0a173e22c615986399997cbf07503e095fd4154dbe6dcd9e2e4c062b8cabe87ad0d74bdbe74d1bb7ffcfe024afecf400f532c0540cbdb8ddeca4cc9af0aea89e4b370bf54ef7d183dfcf844f343b5ff25c2ebe645ca0d9a47a6b644eaff2ffef34c3b0b35dc7bffaaa5f4c1f0ab4dbbb44b5a3828048851761e796cfb0367e150237fc5b58f48fafb8586311226eed5693d1d3469d1fd1ac93dd8af4c10e079d5f00285b5c9c1e29dcac450353fc6539952e1a60a508fcad5b5ab03517c5fcc3bd2fc7f326421788b22edade7d0324ebefbd5ad4fc14cf5a6562e9df08c6cd6bcfdb0881753bdaf3dd9a156b3d47dd4c11411ab6f6a9560552840827719cc294c148561dbace35990bfe4b897fce52ae2ac228e6cc49764534a4f68f64d4e42fa8ff0b393733d54399c8762533002d61cdc27989b3079cf17bfa876396bc99e11af7758520ddc65dc361ce0081a7078f114017843025976c7d4eecfca4ffd6df8f7f8c2a91aab46688b4fb3f2f4027368122bf99e8fe21ff9bbcc66c92ff134efd8492bc6f15d8cd0d5954a91c1801a259c178c0997cc9751b9a2d7e96b5d7ae784a40eb51c697a2767d9e6401a2209de80875be84d90df3eafaeb372545fd1bafb6db21bab969fbaa1df4ed95d49e9b2dddd8e9d9c290f73c8874dd5e499919178cf0a3e70921047b88234f4231ce2c49db83be010f31aca2d05a08ba3fdc7fccf351ea23b9e1ffb867349146b3c5ffc313eec7e8942a9c49f7a643d9c436dc201dc967f71e881b5ba3b4431afc1f9923687989ae0cb06f9568afc83daf4fdbfe41618a8be490dfbcb5dc9b905720c4c4cf9feaec87d10438dce76b3013db9734b570ac846add09676927a8cbed9d839afc114fcd232672549aacdf27d49689b9bd2df18f8b66f4a08608300bde122a26f64ac1adb4a44a8af9969c3405ece0fc55f5c870b29f692c1246cc1cd5fffe4a06f966657ff6df2355bf382fe4e84934e5a42c3c12b497db5ce032b835566c4b47f8c8d2e84e969067db60461a9fcd1c66f6fd7f1dc1073194d0dcab898af73236b6e7638494a273e0d5c11f1b824f23c81cf6843fae43272dc61a45fce09ad056e72e162ffd5340fa323e6b90af847332a540bccc87a1dc617c3ee2abd4eaa5e4540b8cb5017e26ec2674014b3a4cfe93b5548ccd105e86ce557280bd4d152da2151a149ce9c3ae060d3b973dd0d34084ae06fc8afd4d5af2ead1d8da4f5fe316a6501537d97754a25e605db6a220b7d55ade9e531c080186a5dd9383b3f41120d406a77d8c714e643f0ee3ea438cb636c99a484439133b9f7ee81e0b2509fe45c974c22a33c6e0ca263627c31feb9ab79d025f2af97b900269af3cbee26e3254c6c97e2fa404e8093e9447e7ebe107072694e1ae4d3616bbf47c1770ff52ef7e850f9888242758e7344482369c522ca9f55476565224e51402b14c41c89c8d71b0554fc5aa4a1e2759ebe48f45b8ed65c234d0fb3e6e531b0d349fc9315f70124400c5f33b7c5e6c7b24afafeba6625ea0e07941129c0528384fb5f7944bd76c41d4b4d115ab5eb5a3e091b42ba90484e86c054519ba7b6fbf7c5402393de7e6c38dfb0d61c742871a33f4cce023a0a88ef4618e1a49b063e716cb1ae696cca34ed05c657fd006c77fbff94fa872977154dfdf9c4614dc253e270a43c8869691f9b0e9311bebd3f3fa03b8cbead233fba0fc7fe08bcf8b225233622a88299033205f1f6a21b32f20088e94c0e28ca2621b96c49c86126422d38354ceff83fb4b3f898c84f96e610c7960af8efa3ceb0dcda3b57fd29588ebc475d008de90f57ad5b091df8b16db2cc625be4cde702a5f5052b8f1eeadc17ed4da5e7b9515324eee8d8ed3f6d572f9a7bdde4c38db0c3c9ce720bf76b2f5dc679c58e1098cd2b24d1b5ce1b678634ec1c75e5878273d93a32028e2e9784d38c17afdfa7fd9dfe753953aca3ee9bbe72f0d25e8c97a8e1884ef57d47cc449745d537f9d66599f4af9c1149403b84c2c3a181a15548bcf397a7bbf0de261edb5399b1b0d8e6b89e6a8758303f6c683cd826933bb47cd7dc4208f0c8dac704fe6bb9fdcee01297bfcbc2b3711401491376da4705a097a48b5842d91ec9ea12bfe20afa5b2837724473b7611a64c53e13b815e1e9b794afb59724758013474a547e519670dbab7ce7cec18cc999860ea3149ae49c13c4f985956fe647e8d9a3f48e6a07e6aff722c2a4cd9e3d0c68b1d3320da868ecbaf297b6a3a58330786ee0e11e1a0337312843e693119d39539a8a7e866b38b8bcc5f9e7cb621649a67f6ce1bbb6f7dc3f791e3255f11a0dcacd45550d1766dfd4b5fbb563a3ac025ae2ea765cd0373284de35a1ccf0de5c90883e38d2445c08cf7464cfcac35d7800beba942eb461fd8dd5d89db3b418bb48f3c4c4d4dedfbd9088da3e9d3bc6d88da907a7b205a3e91f2cddfd98293e22248ae5d8151a28e0aff66de476aecca05b2e501ba7cd43fe6332e1a96fea352ac4d248ac6eb273e91a17380ab1b1bb6c4571e237c205e6b4b96a29c2d345a1cd11e1129ea2f7d513963e2a15ad3b9560336755da014c60e77fc31cd7232a63f6a6321e297fc0da6a96b5a6f7ff3fa032913b36025811acbfa7b3fd3ed7d9a9c7acfc43ff0204821e5fec31049789717050485561f30077052705cc81780f8a409e9ba8c02a5e3cd5230faf5468e64318dcd713190411a8ae23a5212963f3d27d18334eaec48f69722474ff2e6f182ea94cead9704e0c258181593f76895e2745e8f0e60ad852c9811ebd8eeebe4fb5b4b93cdf311021cfaf3c5c98bb90a97c212e055d1420a2e0ec3c47164b12221fcf5c5305e2c547ecb236fb99a2eefc79a197bca4fbc8da3b791187b04b784d3deb242edddfca94f2567c01db395362466a8fdab07298a3796477e90e8b50878816ae21c048b9cbf070bc725bb433ef36d45ff03cb4a5fb6ed0e765169b044db548c7eb43c60c7e0082311342fd049c2ef94400df1c43f9107414e82063088df26c55efccc9e1e68e793f7ddda6a3c37498c309e7aba677a26d7e2c59cb5fde0789ba749e559dbdc9dfebca679e86d2b6c9956a0d116b22db3c51ea00e8b0017d0f6183124e2105035a9f3994e2487cd866c5f08ae9f49b560a6f9818ca05a2fa6a52790c8b3d516738237a5a3b3ceed27909f30551d35b88806fa724254ff1fa74ff3fbb7d51fc8b9b648127828b62ed84cacd7afa3f1a2da2d472a7a099d37f3edc5d869a9e5de4d02df2b1283ab11bdd71cf54a92e1c6cba4fe6d764d348367db5da2a563f3eba1be46ac782e19d9b6be91a4ea0cdd44276bdf243d5e7e93c994e029b1b7d35517d5d737c0b280bd08fc42aecd2c7534b2b8d23c7e4ed7813989a2559c1468028fa6e340301bd83469050b8f36fca47df27e632d81b4d7754ad9be31eaa4ed793b5a1bca0ad50c5bc1d8a7aa9ac8eda7015e72c389f8f0d2515f3d569e43291ed06d0f12ee6408c334a789f7aa4dc498e98e8882ba08aa0262abd599af6e719258afa6a8b81c34f853ae6d64c220f291f3f2f90436f4ee97da3778ca10aeec731dcabac3a7c4e7f4e1f788bed3656dc8cc3872309ea1ea0252c4f229b7b559ed5216c2fba4adc91b6dfc0bfbdef887fe23545590705e983c1160e46624d802c68fde9f68812d96731ebbe826efdf1a758f244f31f216d3184ad7162d2ab578888e8798ac746611625f59da9a5ee79f74bc601b26bb3a8e55c4d477388c4a459d176d6bb477bc6ba0d46ab898c794a2ba48c2941d018efd5c03cdf7735b18b23bd884a4c92267e67c11477756156ff89945ea5b87252de41a33fa517a69de0fa38aef9af45edaa0d50e2385bf953cb110ac4d5dc661364624ae29c73a1217dddf46f0956695c543c6915a8c457ef1190257dce922f257d69d03af34d97705a67588eb11bc8763a50302fce232bf15a2b2d037d648eb563e9d83f38dc4c7395168628b5b9920fc13a0ad886f2a2e1d9059ede522ab880c8b31feb0be6f30ac46599396e1d55522549f48a6405de45935a0d0f3ab369f994a9a90ccdd20aaaaf942d742a71f9edd0f84be8e935f6915fb0c6b303d9f11a0745fc91fcd2d1f4de98ad1c67d2c1da001e270917af54b652a875a426c42a5fb93c0bb17248006ef433daee8d182f6a8017dece23d3b61fc2f2b362ada6d83ad45f633d6e95009bc91dca92ff3f8f5dd39e3e6f20e24c913fed645eb88bfc51c50a70b4d5bcff34588a67aa9317089fe95552a0db0b4615cb80cf8e820e4d435f56c6b5f472758cb36023ed2e9cf83831d5ce267fc95cb55674bc44531d18f6fcd66fea67d812f90a0f5245c5591e7f7817f4574ddc2006a7df4127a3107abf50cdea149e186abf2c201aa8b8a6cc3ada54c7fffed7bf68d78ffbf2289d2782d0f6b2e4996396ad4fd783708d40eaf69d9fee3d96cd0bd418f43026cf9b10a4c4cd91593c5ede023bac07dcdd3be691828f6ebcd5e61bacc1ff11afa7a30cee7ff772a643fde0c8bfc35826ccc4b6346b8d20b7825891d9338417102ab3723b383fb87938141bfea3c7e4beb165a6f6956844cd6f08be4adae19855f1b86b374550b0efcb3d4d77d3f7a425dc819f0e6b0ca9773387a648a499a4ee84fa3bb6c8726d2dc9528da145f318be472d3c38b4c4252eaab390f3c215024d6568dd1afeec53596f6b958430c259edf65f8a9c45cd99ee17fb7f01da98b1e8fd514bd7cdb3c86d37d95e2f1a0a587b0ee3d73d4464bba3705d37e53f08906b685499be49fd516ebee366e6b14f7bcd3bd83a3a5f7e7283935bbb4a3c619cfa04bc8091243bb9b358b48b24563daea364d21eab0dfe5f0e40079870cb4b4885e6bd2a4ead030d9bac2496732f2f5cda38f850c8bfbce24c229001701cef9d9aa335ad4cba1564b6defab03a934c8e8622804a1da0a78e71a6cbd1e60281f106cd6c44f82feac04fe9c4e1428f6a3bcff8fe293d1420ecad55b4ad2220938c5f0ec7a9207e19ef5037653ead705cf7a883ad1c8a265708045660613b15fa57f05a5dd3ad523e9fad0d65f379859e5db34193fdd23197a08c75dbc880bcc6b38f0ed065bfdcc77604e471b7ae1b8b107a62ef89125c19c2702d2fbbdad1e3925a24a16f22a230f68ec0a7cd5626b54c87c18e0f0f767d1c4cfb649c953408447ef5a0ad0a7268195f2449c268baf91541c40914d1d3a6d333ca3adcb3880a8f66d84ec35ae668489639c4beca3490853f8daba3c4499c5ec487c07abe963e4de5eded339a528759c2fdf7abd21e500a85d310d7b802c7b9229e14228b258176937974bc04388a31647d8033686f72827f599d0b47ef101d0a72d1e536d7143900d64698cd16bec0ddaded7657951a268ddd8de18b95bddd84c96ab5cc92ef7ef5aad1923d303f29a0102586c449e555e732787fed8777cfaaf18a6a963cf91802ea6a77091fbe8ec9a1ec495ae6c2b598474149c3bd1cb6d0322f354f514d31a3dab623deafbf1404d53f631d3adf978bc4ae27b277d203c2ea6236b38ad5fb89a216ca89f917","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
