<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c2abeea8d1901567672b2b2d84bc9dde245006af6e6460a36107bdfe4477cc4be6fe89040a4da0e6b6ee8abfb19df8793f0f032f9206b9767eccc5d6ad14cec4d2c6c57536ebc1ac2f5741ea4f2843cfd9f8e33820549ba60f55e0785e01908715ae5ba04d9e83a29c6903939959ab25df08403fb7a783ef3710e5d3af78fa283afee8f136dbacf924e75a08ae0b79777b993d45bdc129c49b696a9613d952e7933b5452a0bc68c0a1f133933dfa967adbffd2f5c495fae90e50fb94e5044101ccc2100b88c0b45359ca2faa0f7b144dc19296a0f6676148a33bda11ee4232f4d6d82957e3c56153576b45d81dc990e6eb28c35f625e7e6868cdb0538e05688c75564ab8a207d91bc1f08a83536c3b81157bce675c3d53be0d734ca9a7c9501dce4f1a0b47faf097d326aa674822a9f8682a15422c70c20f71b8c8c6ec44b231838844c2492ae628e8a9aed1be1f7788459fca05c2075a3cf34ca6cce9061c62ec2e32438664deb71ab84e927546a412b4b2c634aeb2d4e362d63f1b96c6be7756d1044d74bfa9aa99fc8ca5ef3abc440ae7a045e2b6fde0d26294d4ef279ffc8eb1c3d2e1e3fb1f6c9580cb1c1347808ba7d2ffa5ba7d6e8f5b90a52f70913698e1b584637c15118284f29f82ff4aaa41588b428fb054d1b5d257ce062c6c581ee0ed1b1bdd1bfcd37865c94ad261b2770cfc5682a59c027c4f53810e665fba31ed911d883b8d237fa6c6130e790f286c628cc91e02f636d8d285a5ecf9f65fa9c2e70fe5c475ada412c7de0234939bc3665e0bad110f73df604efcbacc35aa257889b588eaf2eaba739cac0fe506ed2ba4cbc388a01298a1510391df06c0c1afc63850afbc0d042a07edb0dc85d3f41779088952f446a00f0d3f630494edbaed74dd185d70b06fd0a5d14391849ab2731556480d4e2be3913fe8c9aa5b8599f9d4ecdb442d15a003d76698a8de407163955d5b3271856caa48c3dab957f037740b01efdc6a7f132155eec759cc3cad7702a176e3f13e029a861364fb4be75334416802c3c6ab0bc37d54826bb9db51e904977af41c5b2c0e512c9875ba37554615ce7913b555fa460dd8ff6a44ac4b9674ad949fdea54344d537cf6eab99f58b83c7669887a6d50bf2e108a2a69b26416ab940c2cf96b68adb670c110728c295d8529310cc63d7b7589432dadfb750d10fd7499e6acee457449f528555f6b267eabe875ba8dfd2fc62de19795afb7617ce9caff536af0fb77ccee645637b11419d169979ca22972083621fdceb8c34441e5bba6df233578a01c80f3dc594e10e2bfb7682734f8e3f8451eed4ee7b01be346997670a42632e546abf5b401328aca7847c8b7d32f59106c9f081271f92a4df4031a1339533a6d18986f68818e3cc88772c40d8d27406a8a1e1b1c7aae1f0d22f812994450b37d0cfe89a6a2436a2747150c3323fda9dd1aa07c643728f787d690e3d580f407b66b52b14c17ed91f1918c5edfca1a7c054570158ed2fda83e9358e9c54972c6e6f588554891020e54ebaa646f7b29fc912ce04075ade1c69861c6d82519f9af4bc050cf08f7c013347b67e2a5341a93d2eb09ead4f8a22111dd59d2d2b4871a49f6f16289d0b8ed6e46c0ad88bdbae75bd6a3bc297b583ac57150692ae7f46961f470016b439863b3c2b63048e4847c0f6c065e51d8647073e5db22989fe6ea7be1a48175ca6d1542cbda7445517d54e7b538e3fc63913cd2e0e680cac18b56369baa6574de976531e1561ca5de150204c9d5e9ea15a98abb36c3dbc23cc89be68471f36efc31b19aa940f5c4d23e39758271cd76e5c48951eed903eb29994bcac076b7902de5305a4ec616fd52f19699985c8fdc8930d086e08706bfdf2141db8698a65646ee2c26ccd9d951d1ba80da9f788b3b46c90915fecc59db3dd81576944c49a2cc2f35f6de9671a4c738ab09c0770a7a682d038541149c5469760ac3ad1a93ff8ea2f4c73023209ce3ea61031e4542e37e01b8446e7df5a6baf17cbcdb2dd13cd7173815daa1e91ccc46684be84ddb55bfb03efcc2fff5940a42f45f6a74c0b550ac31a5d7d6780546ae0725fc83a5fa18718e2eec4dfdd6f8caa085199688cac43baf72a6cefcd081e306189811707d73e632ec8e8d74a2e409550050320cc892d3ad23969ef35d23c21604f68ba097f2ae239cc012378a11c9a376d5d3912da44c49ba45c4d51d9e8f718718acd22f151df275b5a62ffd2c6ad8df4decf4283b3849988a3c9049083a9234c41a2e7c2c25b423c62cb23798818a207e4b7ac19ae7f556e016eea3af5ce35a6e21fb642c0cc33e71d3439dd1934296da11e60ac5ab149effd0181ba6dc7c3745fd19461d56cffbcdde36da352585cf2ca67274261c65d541b8c114139d3818ffa06e21f7508711e7749541f45434a592d0f6a15058511dc24293e2afb9400b861e9ffc71e12473f47ffa51757756917cc6f91c7a4f7812931dea33404c179e00ddaf782affc1f2ac52dd68701690b0f41cb08a63209ffc90ea99ae701e6da175c9641a20b5cd561bf69ca2124a5e6b66bda78a68e802709093f04af626d04d37707c90e408a9f13ab24298f941d0a93cc081e204d915dbcdd8eea9adbaae64f3a8470ac5f6abce7514804960b84b09b5f3c49fc1e746a972781c43c8a5ea69100a56c8b75240d32b691decc53c88fbb30403c4bcbb87fdfe070f7fe2c176aab4787813ce9edd036bba0b2cdb8f9ef8887fea5dc2324947e3f43dfc7da05584c89700ef14580e0ea69ab1034a09fb44d49ba0d665c41385a14b244f9e5d7186ee278ab3140b5005295d5a60579a572ae3c21562d87429c94dd85438a0c0942ae0863226fc0201ee6beb480b69e927e0f3f8959a8c29dafa20ea709f8c56268fc77c2d1659f12a38fcde1c525aad5f2940349b7109338aec4a4b09a710745d8547693c6d32a251531ce397a4cb93b966e4b561aa75413681d608741d6bdcba4690c2c45107872ceca6a8fc7c23be5b1029a88867f3e5dbe99e41c7cc149d4ea6e6209d9a5463ee7a4f22c5c52416e1821d822018d5a5dc3dffedee6ca08ecd898d0cd538b2ac4d2da3c5ee667ff1705e18282440b0da9e3161decb2b4cbfcc54405b23c2737d7740c8c453364b5f90b76dc2071afba1a53d6e49dcf8159187a0443d4a452089b4266e82fb8712bb8f6c5fdec988e819714a762d140c38130bd60e8ae6fe427e93b5bb5cdfa2be34375a440d62dae14cb4f2ed61956d2ca271976ac15ca412a5365f76d28e5be35a85e79b1d2cd1f37cf6cdfa631ed76e2bc950dccec3d3cac56c8830fa81b875aa71e21a12375d5be4b7a4e79e61d26d0ac0b3ffbbcd6ea1ea129da107dc3a467638ccd0191a3352acc267e4e0d1ba994a3ba2a6e28a06f2473a8e9875f18bc06e20932a8c76f08ea35970aadb58465920b6fdf1a53fae1b9f1d8cb039a1ff9ce2bf0009aef14061c6aecb32591320d0fe3bdb0cc60b8fcdf3026752bfd9b2ba135c0681732016d891f093ec19633b400c74ed92fbb3aa7d778fa59512c1f49f539c08539b1a5a92cd7e2c27e12fc0a20af4d93b929d0d898115a816492c065cab441f1eb18e3d11215f7df1105a8c23d20e2684cafa06d840a9c01b844eb88c2cafc9ebbd3009cf356eaf80d08a1893ec820618986ece41ea8ca6e74243707a11f250dd9dfa5f0e703c8b3ed051b050cb9dcc14e2c4eab3458473464e7544853891bfca8e05bb0fd7e884b12ef66682a047f550948ccfe5e3383b0a698c7597d8b701a17e9947872981075cf2e70ab7f6c7a427b2dce422352730557d71e7ba5689b00e2cbd340a202d1aaaccb482308f6ef2f77e96790c83e84ef405433dbc2235d900605dfc59314a1e0b5276d727dc5be224db8732b6d12fdbc7ad5dac7cd53bbc40160d3107a41ccc26eb90674ebaf7ca8abbe47c78c9709dadd2a420e31e16fcbd20ccf4f75bf702690b2cf9c5acef551df890e8a414a42ac12102a2f7c6e587750e8cbba23e602f02d4da13e606eaa4f3a08cdd12cdb27ab239474618a205f9015a5e1159a9593b7c34a5b7555f31e4476ae9f5931e89352cbb36c62aac391ba6f97a5effbf4591dea2ff3a48d839ff5d9fc9a10844ae839b513c6084319f8141935c4b9ee796128f6702d8e79cb84de1df2664c3a2760ac0444cf690309dab8f78dfc1d7cbca8277d2abdb7ae402e5eebf4396207c4bfc20d828b9a3e9b43772fbfb7354b5a224eb750207d65d5b97176234fcd650adb7183cf1a16098530d9f34cf3729e282f9a665c5c5d63d7145578fc9787cc4bb59812607c52f3df3587cfb10e0691d2bfabf2492d53d41840141bcbe9924a2e6f0d6f5e0e94e769575e8a504dd0931de7bde4df8c49a18090682aee3aa9096baee3b46f2f475e0fa2423fd832f455acc5750e679d986b911925dc72dbdcce6bb757e56c2f96f22d71f677518c00403c3094536599509c15ad86d1b4d72234b3ff6a54026283c2aebf3916485537ec56034fb17df3e407d82dde30daaab989a3bf440cbc48a8ff8a522b7bd31316cdb16a846f78aa961641630643425c8e108bbe9aec88bf80fdce56cce436950186e8a931be19d959fa4c552078f5dbf3dcb3b5590219419a782a7c6cba2939997040a27ebe2ce0a5a06eebb035fb10ac5ccad256334e7e65722079f02feff476eccc0c1b5c7c63bb906b1c75a3e5d21b1d3beaf9765b95cf893729d9f6cea436f4e41dada4a69c126eb893b9bece7da60dc423c3caf1d99c249cb80c5c361647385e6489e5c366bae5b33b8d1e5d43d698533db273eeaa4b95ac0c573ba7cb1744fb96e1dc99d667a3f94872b434849e9faba62247b5e7c982ab4b34d0cca1f2b2500ed7ab1327dabe1a24b98012437bfb25efa77e003e37412e73cb3d2b8707de569b79670c51ac9872e2316a6fc28a38919c645a442a3d31baa3187cb3f77bce393071280fda1aa5aa81173a92e6bbd2fe3a7450991b4f3735de3dc761bb9e6a2e063e4c6b7f2e272b31d643f81437983df9bd04204edd947815f1b25b64baf10d2e5e446a9d10ee7371213f54c60b7f7f9c7a9d1ba8adb89469a0b3ec9944ac49f8999552f94d90cc508db58a78d4dcdda5795535f9f327d94200973192345dc01438711e1d7b8025a995948238cadf5e72ef1e727eb892170fd1129742e74e42229de414b914d41de7a78eef9f25e4469ecd0641c3eebc9870dde4ffdb397558cdef39a76ae02d5edb636c2cf4fe02d21dbab10eff2ae4faacb09424b29f420d6ba8b75fe7cf251d18f5dc9b90c282e96e2b4fdc60467cbb2a984d56fa3c99d109f88d4efb116cd6f5e24d04c21717dc51415bb3c19a90cb38301287733e4c4cb37f50111b7b4c38119883cbfa9c3d9f57bd8ed250a149669d48dffd170014df6adce606216ab9a31751251da2d7a4728d00bc256ad42038ee137ed63b6a5c890899fa8e02cebaf6097aa21f6d99e52a6ef2a3decf3f053ad3c4811f139d9149ff5e1630cb487004bbc14e93fb7dcd38c28ce897a1a2361749f4b0f5be361f45050fcaff322b33a5708086bf9f978beef7b87e9d7c293048eecd417574c2567eddc873c389d873a3793420fbc627e030591b69a7748e6679343f77b8bb3833cec09d266b22a77e1232d0d98c64d41924f07602437b64918dc7a3f89a09ad2b5b239749d077593b6fbd24ea1f2c5350a48b30177efebc0a8536302c4dd536aa692326dac3ebfd799c4db1b5280056a8cc0f6c5bf2087f53370f44db1232b9943388e9b19080dd20dad2c1f84e3c23c5e738b28f19d0d794f26cf6fea71aca845c1999524b077fcb5a04717c9a86eab749eb172370ab7b96a250508207d22f3f775af022b653c649e0cdef0daba260629538fb761e2a7e8e5ff6ef17c9875d38981e953e3720fca3181edd8eb2bfdd06c83335c5b44c88a4d5939cc6202ab4c5f27810dd26d258797cc6cfcf197f82c3cae0f5b40d3944891201b0f68436555f05ecf2508c98e456ea8bcd58d860738fb30b4564fa133870a2a8649267a328b91b2f4a71d9272d224293bbd15b3390405b8cae25267f55ceaf5f1eb058084698e59886f5325d6a59cae2b365535d8e41cd56501ec1629bd70d87ebdc0de0a2dbd2cae460704e252ba6719de5aa89ad7a2fcb969fab1541f381540504a8aae5fa8f1cc036486e2d6a587b8b786b124846bf00f31f874192382528c62540c14851da09dcdd4cc6f302cce2952db4a9c59e0a0935b36df5bec1147f36ccf8ec7f79245b2cec03a0793c9244de2f16de77c07b16977798ad7fafe80ec7b191fd1cdb7f8bedf1900c33a2774e83014b479ec7fd40dd83c05ea46a574f4c8f01cbf1abec03cca8f09799ad44b8d21b60dbbbfd4cf8acae8c2eb0a6bb509ad2cec5b242b578de88bc5d6581dd6566ef873583a919b701473b2d0d39d44099e1955f33bdcdea39451ddc663a17186b7e955b96713d7a0546e1e3cc40e164d762e54db3d940c72ba7a3641139b42d2d4fc517df615653bfb2a23e1aa1ba87405fb3908e798edee77b5a3999ae1917d71bacebbf287650e3f8cc14339a9eb38394caa259198fa6f9b3d576eec1bd9b1d8f7f445e3c2a7239ebeb4a8cb9ed7981ee26bda46c71828e21816d0bd684b106db440ed5f609109c60bd8176d60ec5700843ec659f47155c623dd410e78470a949953899c5d0cb200f8565f9f754b670e36a1caed80e02193d94a1512988cf161a3d0072e4d0709dcc6752489f0a702ddf6e8e39ce0e137da49b77cc7e1cfd4930053479237e0b90b2fe2865a78aa2095852f0a7285b2bc7563cc0b595c11619755a16e93e83710eb79e302c09abdf5653e7c4999519d75896d774954230cbe49be9af2d8b77b73de6b3b8396194a9897e3586a49d3e10195024b1c5612554ac7596476bfa8c028a0a25d356ff5ce5349ac3ea9bc0beb011ae6c2bb161485113976c3c74479254e78ee0fc18f9a9697511f6df73905b3a69e3ce5f2b130f620d23362103e91776527756fe9ce370cc1ed5adb99b6b2a902ee16ae70661301ab97fa94c7b743635353b27fd8fdbb9ba91f1b48a122c93e04b301e9c3c38f4fd03a9ff9fa334fb4fd03628a6867bc16b2aac65b4fce482b0731d6591c815eff09a1c98e0acd034589198f1598d2f0c002817172803d383ad8c34701a501f6cdc91292022d5b1002a58d86543e917038f9df76022cadcdd39bd61261c5ab39f8cf9e48cfe75e8890778b22650109e008ecf5239cb41b6ca9ea2e5e90bcc2777dd22b34df51eb39b2eb160e1d9a0204773cf4074719a4cb37455f087d6e5b1c45648bcdaa3b3f7f67bade5e6671528c5cba2a9fb5133b522fd736f360d9634ef33e08943ce6b483a3fe02579f482c8aa44d731b409cb842e65ba808a3fb1ca54d5b1f8b4569922584cab17eefeaccbecc20487ef5c52b2f157bce0a0d52155dda31483bba78d09c410b3fd123400da218a7473909e76ee3cd20c2115970cd5f140abe3c70f8b9c4fded7ffd1394e69ae4244c14fbde8e9ac9deebdfa4a84d3b0cbff3ebfc3d02c46d2fece16dcc7cb6854d3c83e704b309cfd2576757cd9a39d619c66117c587961d7ec6565f66ba1eaa1d75bb09c55f76e20731d571576cb30f258ffcad60f242e4c0f268521d2574790796adb2d05569d040899eb2be7f25137add793e937698d2a4f87a20668ebcf2e236a069e29f914b4acff31379ba0b0d8995286d02b75413f6d7dba2fd28b80f37deb71a1fa85081685b05997944a25eff8c973445ebb8c4bee22caf0d092784bcafb8b313319ace4b1397c9f67a8f0cbd32b583456aee317c75bb8758097da09692d98008bbcee74f32bbba68b9b728a62aac6b3f0742518834512eff239e2ed69680f6f2dbb47238ad74670e31870a0808975183326d1644e7ac2e5d91131dad2f23d11cee41c0f6bb51edc830f877c649b9515d1f31d803cf88b34962b544ca1df651a6e9446fd0969e82d838d7a3d787223b3dc5c04a660fe278880e8443285784f312bb2297b55bfe0c5d7f28b6dc9eb08e1e2637d4d3292b0febbe3d01d57b5acbef6a7c6dedc161f93070663f3c2f3c8a9328da661d1c1a92577dcd6fb0606f85bdc1c29b3401c6bd9851e57efb4574e1aeb15026f069d07e657f145c25bdf8ce23134415955127761fd06bdf6432ae63f6dc5a72706633aa1a8bca118d1c454f715d6235aaf0ae4269f682f7532b41c98baa282507fae249eafb43fa6cf9e32129097c8b5d9398485fc310bb09662bc42834683c052f43d4ffba1c31ef78a850a3d852cf4c881d9166667849c5ba6d6c02f51c87827302179788eb3c2cbceb24bb62059249a671e3486ad86c3d202912df7be4458c6d9031015de93c75efd40558e2dcbe9da7d4faad06efa45503d790a55ffe4926dbb75f7c3da45261983772c57a4d661c3e2f3af3a05f28dffbca7b2c296117f49f2c3187b01b66b2fe5208d877f5fd36a17820912d1884bb02d9374f6b67e64b2d4ec4f33dbd7cc678e28c07b969d8a13d7705ea0df3dab561b6a23162e464e8b472bdbbd95186126908e07903586e4ce252828c53955561eb99382c07d0d733f93338957bc641728ee97690696ffe6d8e961f9d9db45ed29efedfcca21345fbbd3a30c50393e0c56a520c394bcbf63e2e3335e1b1a2493070a3d3654eb169ff1a5b2336ed579e0bfa97812ddd2e3bf0b4560050367299513b94e9ceabccd0efd7a8b3e0d8277c6bdc27d7b21618ee249be2b7a5ab3253ab0abf885a4705129b2def0b7d71318848860eb1348180b997a6bde2c6f8b73be17d63306dd3da5a482f16b7fc052557c54a8a028befc093ffbc49512bbd9a4a879bca2023275b4c4757bfd8a4845db4e746fa40c77b94419f995cb3527eb9779be4b191144864ea9be568f790a5f543ba4c3061acdd7138336d5d6cf15f51d87ec33c0f793c8cfc4ff3d5e6c63fbc96962a75631290cfec8620c0aa3c0e658490cee9f1a82c6ca8c4beffcdd3f2f027a0d855b247de2749523e5b8cd68384ed8d3a813a3b0635e567bec89e28fadbf4243601eca8eb071059ffe0d462fc696a0bda315b2f5919e1718c6eaa835d88c4044970169c13cfc4ea1ba8c8a4359e2eb62df0ac95bc47bf86db17eaa481d7e2e8007d76c2258afeef3bb1080b324f571fc81c16662aea2a991fe14277b29ed92f9fd962ad86c9ac4412991710c6330367a2f8f4106c4552297632b735f56a14f2a417ea751b61c5bbc34ca0d768c5e3f606baa472e7551cbfc92c1588de2c49f5e3f50a9871ff1f49089718b4a149197abcff2d74990b88bc36a36eb951b7e4211bc19e0eaf36991677f10258ef050ee7f8845fb3c1a12788159deac0147980cb036836edd01d3022331b51c97fc2db4920193a3ebf4790c8a1672556b918419cd3bb71343dc552860c9670986358333931e38e714a142b92c57972226e2b5227fd0fb58ab802d9099eef3a4f9d49b2fa81fd825cc646b28523b271ee707fc2939a7e3ac7e945d5734ea637bea20fbeda15016d01d681cdfc0bc61431783182fa9c447e26630ddf06c99f6c80413f0029fe7c0215d986e530515a3f7edd5f4ec6dbb3c8398d8d94b27696a23a6d87af6b65750fed979b1998dc5b7d18b878f023110ae1b02db99edb903600700d684551e60ab05abf8eebd6f193a28535765f4f4a27a1fdc7c761c39adc18af03acacef2662b07fa6b3a4254337d72cdcab29d3d52447f03cf64a7f0442d0c72db97dd4b768b369d0a448a8ba3d7523d53d59e4447bdfecb5ce4a83484a804a4ee1a86d31e3f6b8a970666fb19817490559984692605cc5f5213c048b2a57a461af66c66389172342c587930346a36b648aec28031592d08881424dffc2cb0fb134212c7f099d830b0ae15e425f266dcb0ea79e187c3d52653fbc2d2cae63c90c3ac046eb669cee0aa03e1324739074ffc64edcd2d8c163fa535a1197301b83f54525236384d390f7f45072e125e5455a53106f12dc31b6443756fcf7790f1806e54294880cdb95eab66f7e6721312c2b60f401480b9b4816719e53db710047b05d7238f397e5de271d7bd1ac742bb82da90ad9679af3e3929b8b4646ff631ad91b424b23401fda6a47eb6017dfb7b3b2dc0fb40f45c11aeb8d895e74f36ab8c80a7adc05d325ff3f137c7c2a9f6d131d04bf8d00543f07f48e6bb4188e0df73b48de99edf291a95907dd5fbe3a2c134c44d1b40850c9e0a74c939a19d749a75e82b5e163f4c67da288c6c1e9855cd959f3fdc062e43fef41bab2d359f0dde8a8167ff2c890fd20164116d11157fcdaee8916c03a79cbfd14245ed553b5d450e0dbe98c87e9ab14a9d27889d65250673a8f02454b6a153d747c28fc39f358353c0881f215415098f79820e874d6b4d966f631de482e345db046fb78052cb5378bec8e355cef0f84b35715205e9d27481f1e4929b7379ed38401621652322022ffdffc6287e08a0222aa2e676c7f4204562ba7c0621cc846d14961a813ee34709133b2f7f90978a17947736feb321160c779a35b60527cdf0d9a1dd0d94a42b0efb8882ec7f180710d6859f92262c931dd7403cc7f9689437905a25ed0ef49cbd8912a19964968c990d9051aa5c41f5bc4f5324c68f2ed0d8543927f3644d6093e038fba28cec8b3756d5091f1c4b51633f01acee14f52a81a9984ab59ea5e30f3b1746f2fbb6d522ee7d1bafb9fac8ccaa82d9f43b00b27d61a51fc11d3ffd3566ff52a275d27c235804f9fafb239d239bd9d921e8c753ea0a60d583ffc334827a75f649cd4a925cd7cd7724c07c206dcc7202fbcab33e16e49151a0370248cde42d9a63a12c2d9a406090f30cccd0d741dcb0f869bf9ccbc90fbe0c0731ab78401a5ce083b05d483ba803aa48228c21b7b6b75b6e017fc3b55a264a0a21ea98d5fda53cec068d6d09512f5ae175548bfebcfd8b8e2946676c0ba41cc0a7747b2aa4b86a599bb38a8813b425e39b979515ead6fed7f1141b5e05c04725d8c22c2f5c81747f601134b2384dd9b10f4b0a9b1ca51873adcaba827219dd86d74e4325780cad8a293aa56f18aaf94267086cc210944d2abac09be5934d23f9c60cd5bda6bd73a314a2aa4d0c31e253a317b36e259006056a847d65335d26ed5fa1c844d77c3fd4a14b03053cd5802e56139152f6f7d441dcac874946f46133c5992eae15e7c5ab5d03b1a30a05e69db77c0e5a0f031be284fc12e3d91da4a377e890b745f4490f72990aa8629796c85a86706b95fee835426061e669a4a2a4dbd08c643b2c05393300b6a2de7e34338aa3f7f440a085bdecd0968fb7555139e290ce899e86d638a4f8f19b5f046826be13c92207a33421b05a92bf82d8ef6e00968791fb1b5e2e40a153043d55f52f4a09dc6df5f20b07ff087783ef8796f0a58760c105b9da82e58397e0900feb296fde784fff69abb4092c5c65afcb110a07e1e95a7c70c613bb94617d39c099d904609e762da69f33b5c0244a0081c2e0e3f17393ed8e8d267919b4e19c5a59b92a9a32334c06eddd0665c77a83b8af2d419bcb902529d604eea4a7fb2ebd36eb67b44ec4f718c85b71ab8b699d6f53c422de0a010939eb6b20d16180cccddbe0486659f85d5ef00e21ded08e2029554e1b3fbcc1876e4fb8ea57cf0cc767115625351ee70740785b522ec84af821cae81652f084a8e4d022463ccb20fc3376ad8cef9ef95dc561b29b4bbfe7a6498f4310cbb7988dee133b9886eb53456c94df0f4854f9200b564973dc750f4a9110a28b203ecb77edc4bba98f7ee20e3cdc998e654a09dca6180297e3265ed135f27c466024a5ece4fe281f2342427cf2aa4281f90c89c3a34e00b366d939a162bd1f914c0854fb8c03e0381906e617c6a7dc0e299fc7ac906cc300a5f7d822ab278a1ec21cb48a691381fb586777a57277b911d5e268f56bf79c3827d523d538266f3f80d404d6b968023c00f28059d97fcb7f2fc6259e419da159e23e364bf311aca124d26adc7b02ab0b1c660f4372b9e964d47a421209698a0cb4ec6df35679d976a424b224641d879b7d7650dbb615a60d7eac614c4dff4c458a6b923228522836d769cb1d1ba60e8c9bec58836adc450b94d3be4ef0e00196008309c7503490d4c372d8f6d9cbc07aba9a991c3ae359f9df1577f232a69fae51a725b6f92c2fde6e872b49a24f5aff9ee7bdbbb3169008a716998609fafb4adac14373b1fd3bea01834b1c5aa4bee2909a7dcb6bc4ad596997b315cb5157aa911260d8a2e16f018052a64c8af65c6d2d7cb7d8dc22c1596887f424f8d41226e951f54593bcb3122035a57379affc151f752ce123f0c18e782a83fd07c5e18e6c59e180090d4fda4415220f4f31bce105edad4d9eec7703cc1199ed1766a5de8a5b26cb9cff46ff7df1bdda2fcae3d17a884465a0403ea970b9a9ba71ff4a5b2c23135b74a2deb37115b5e2b26208555c2b878012ed6d5249002b3439c1bb29be1fc1454891e81dc5a1ffbc4e0c77475929f1b555e8435553cdf18110e528c8da0ab739df9cdd37ba4c6b987ce0c594735c491b80d61b1bf3917e1463cb6da0e7f4e6f40d3648d283c27f62b6da1bbf356ab766a5a6182269e652e97b58a07045e4bcbf6f6e721a033bc5ae52da060f43093eb4d60b39fcee85011876bf81cbac45a886e19dcc15a55e8066f1b4ab2d26f37d8cfb9b7d3c1421cf36ea7987969059cc9a3bedcfce8c0d0229272f72d64e3a29efbaec893fd95462fa31c98dbf23e460fbf3fccbcc7def55ea2596d2d79d7e4604ab4bc93e264b6edc3498e6ab355a0ead95111d779bc09c062e132ff71f69332f5f100326610f52eece9f2b7c49816b1b6f73bd85359e58b248385750cace8a8e51120e7341c731fdf43afaec229f8f0ebbe804d698d69a390c943f71702b54f7f0b36d7261326a5d038eab509812a9738410dc9f68f1372940c5eb8fdd3f872739943e102654b83d83238c2dcf3d78e75049c5db2b2719f0dec0ba62534529821cda80d33aa6d94f1666bf774b6e21aa4790d964ebd10f849ce56880f103917242c8ed1bbdd32ddda431ce65c3c761359a6fc2e8e2251f8c28be1ca91913ec55359644e855713175def35714d21002313c16a8294c249c3950282274b54bc9453857dde14875ce8eadf23a1969a17a6bf63c9ffb9f5fe309635bd128be7a2bc89666ef0636dd9600a22a7f8b1b59fdb910d1976d2c2c3c3717f588c09b7b9af5c0ebced833fb1dcbbc17f571dea8026ee9f9efd3395e3d6eb9efd8b3fec62676de5ab35f4781ed1bed3e495394f89c5fcbfaf5d932acd42335494b03d03ea567c630101b68e7827597eff1ef8c7710822494e8de705136748961b8918113e5840f7f50c4064b3dd66e84403bd8e246a059df20cedcac428ba409663c705f618859bce324d376bae83f54b1b82e03189426de0198e208813e15cce36ef8c484e25fce86a51543f9f6803af0d792b12393b6afa8962264dc7c625e5c23d0b14dac5eb0de2225f30fa2c71464676b1fcb4191b7886f56108b0b4c412361990bb1d04ea0ee00597849187989b4ee9afa7ed3adb98b37946df890c81f200261f3421bbb6eb1a69ca8e1f233dc4584e3b983aa184a992f351b704456f2b36dcf2fa037a8276a8b2b05d36ef7ad9a16d41da7f0a1766fad384eaab97f7056fa629f8a1197a991d7de21db3f2e7720fc9311832a381b96588cf2a6fb8de809ebb627deb03596d19bbac037f3bcf2925b48b6e7652a1b93f70df435cfc1113ced3025aef59bfeb521e3e93078dcb1e5edd0649f9ec8c0c7adaaad7fd575f061e75a6ab5db2020c1a6e83052767c893d284692c7ef229785f868aed024256973aa5ade17fc2fde05f0a958eaf3f3bdc40ca51f9aa41d0e437d79dc70a7aa622083703bc45e98f3627b93570d92c464e0c31d17d35c57e5f7b13762c67ac7417f1a7f57044b3b6a05bc2c8d66374d23caf65d4ebb8be52b052be835a6d7b2cdcbd2506e922b9dc70d92ba16fc2b5e84146e92ac52d25f2fead15a633915cd8d9788ed6a7f157358ff7d80ed1ef7836af3a8675f0c6dd0ec9657d64a5648ec4b580d567fae956d4380c7137852f6ef4a963a08dc7240470086a41718dac7b08edf7a241626b1ece271833ab5bc7188240f45e4fa071bb02f467af318405a7ab24243144025ed4bb26e3dadef40f81316be97c432c2988c74a3fb984f56ea7c8ba508a3c7b8da88c6ed8c1805c5be5b4723b05238db4cdfa5ca9584471452bdadc5333ff409f6ad4aed0911bdff5c39147e0b22db37f232778df7c5f6414666d594757ac92fb32869052a2eacbbd401dd81b09746c1ed9a7189238d837e1a72b92e43480481120a6dba44d12a30c41fd8bc7d85980e33bcff693cae60dd65d82b81131fc0a702d3691a1e6d65e84c620af5c36032b038493b28c0a858c94ade7869c21e260c746fff870b44cde0c029f2ca64f43de6ff9953104592fec255b505994cf3bcaf8bc0b67fbf70f42778e548b86a9fe5fc06b562f8943044290ef897af6923932af792f5315b3485c86c98fb2cb20d70f05dc138e391672a2a2e40ce50456b927f80bd468af4607e1a3c08f8fa792e4fce1d0c180c5f6ea079322506c9ca656ccb809a03f9999f1306f43dc18669aa48b0dbaa500c34ece781fa91915652514a8689febe0761e346b352cabb8226456b8bdd52fb479ce1ab9a64faab60198cc6e116950c26c82c414c9df296ac5831d50a687e721345f17d6c2649404e0c0c030465185811379236f9dbda8c62e1d44bb645d3f9bfe785bcd01a7b2124dd297a9d83582140d2c64ac97c105249b17fd1bfd87c764e49d5269616f5c26eda04e2ee53efe26dd471e6fa14e965807f8b4a9ddaa1ca0134c7d49d8a353bed0d4e393bcbff08ae7ccd2b57bad99a9c6ff82bbb104c655ad6889c001134685fe8b6daaed0ccf4a63141cb6d502a4b56d13637c871c13421eb116ea7995c80268ccbb2e18fad66a15b693a1b1ece3771e64d15cd4b9ea3ba4d438bfde84fc74aa554f8c834","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
