<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"698a084c0aa6aa7e6bb8d832a6e044ff9c01eba5d30e83c31ada4ea6522ff14be221c94f2c6e6db06c7eb4987fc3b490be3898195f5981013fab329bae37c8a4cbc1878c9e9c288fbad88b97825d3145e1f6cf8b469cc2302ac797b256d11e0dad2ce9626bf1d70e4812d5c394d5c8f886e22063d2e0b729d0c85a29f405157b0532b27573473f342ea39615b732a121a7ef0ad150d862a8273578d17e84f08999be1bfa7620410812121d86777f146bce1acd50fdf5c22754b1a08c1aea064b2e0eccb398b1053bb0f05aa8d6d5c21caf67d465739021e60dc3627dce5656d99141678ca02ad1dcdad3f0948772eba4553d744659aea26754b0fc70afd5e8fe9e654725ac0524195e5b13079d47df0e8ce1030d5c4897cdfe09fae42e416e81d5ce33e64f264722db2a649b1bb04cf465d5cee6dfb3df3b322317c47c924231303c30142012d7b544e1e879071bce2392e86321b87e332083bb06a8204dd9f4d9ee2963a472982c4075507be3544d1c7b977766113c5edbc1c387f25f869eef3d6230ca9080fc3d4a1507cea3359e4a1785d1800f2175bf4ba5006dff19d772b14ff17014cc0c6d8c285f8dced8ea63bd4aeab6e8e355bfce2fcb48c581954804da0997f7a19d1eea08a63447dec7f74c807019d0c1bb86ee87424478e6e44ba5f135ab866948f169da2b966d41c4152b393e906dbacf6b6a4c6f601e5f8115c963e2f09bf27614ed9c94f77f0dcc455a069c4ad92c9ad260433e398f5936c21969e2e7c779c4c605d37f71c00b9d2483b67854c844bbf0fdb57bbfcb5f1cf09bd9fe307346cfbedb794993c53249eb035cfbcb1b9dd4b609521d4254f85fd4777617d89ac32572a34f5caddab8e9465eb87974e7ca07d6da109e25a74ef15d1cc2818d3922bf8ed71a435625c174c627f24d7f06cdb904688f1f0f119fd1a202cd7d282fc4b67be8e34ad92b36c267a64410ad6a506fd0f284259fa8779bf4cc86bcede9963c9f13a664a602372d82c814a1b0e43ffe7d4c5d389efe0837249e421588e49c96fbab99f4c927871a571592b7dce481df19d75f91c060ed953ac14fab103e1985868e21d78410df2a22379fa717507ba3a20ad9e499fa77812000b589574e2f50d716c5056b51e503851f267fff4dff560196f6c35a5d4a2ed9b8eb5d2df478ec309261e7e28a2c746dc9741bee16b013b56d66858e65465388622a065c3016408c417ad3e664f5414d8b99a082f122876d9255d1326771951af40684549b8d23a3019c60caabf46bb589ce63dfc6a61c49ab5dee7ce3a51e74ad0b7d0e4c5609480b95140861bfb83521249d1be0bc1f5bedc14b88b785efd95724f8395d0ecf930b9442b5056a536a92039aa663421ea814bb178e40a3976f0f128bd89b671085ec09785ce93403e5f17a3092f73b9378eba6b384acd527600984d60df428a00a15acdf678a8f46f4279c43437d3cccc9b037e4228b9f32280300b654bd29198fc31d1893a752f3b61a9664eefdb45a964a8cca40277e1a835f70e9f462507b9cdfc7a10ac5550c6731993afbfcbcfefa9151c2cd3a749d73fb6b7c2275c20d1795f191661e011c366365db457d0b18b2c92f2b0984b2626c681901c315f05bc470ad4546027df8032782c98d06ba67ca980c8d8935bb9082c4ce4c91643496d2477ee48bbf96e22afd54d38b5ab3437ee857c671f45643ad23ad146b9d02d2e8cb101a4bfc08225d77b48798570b6861a7d1f239b64087e2c9d73251eb6459ae89e6db4d45bc35fa6b5366264137e3c1a1c91ad50f1ae7d0b4212a97219edbdab58388676b12e0fafb2d5ec436acbad539151f1e7108b2c2f38207c0a89e72c586a630ad79b088b7a2943d76b8291b6e54afa75ba754cb736cc3b8514b65cca6f0c879ede7bf62c4a7188a3106b7aef5c5bfdacde9567ecd4d3e660a2cae02b21b19a47b9434b8f7767f6408e9864c2db9fc9d958728767a00054a3eb091616b21468e6701c34a5a8f00203554a7eb3e508aafb28cbbb4bcbf6a05c4c4150e14f3d369b690bc66b7c54d0653dca8e31f27f3add7c44e4bc4f04af664798043fa38e452f576991855a205c96de43c7e4b46be5fe0d605ba5af865159ad32fd73bc20aa9e0de18e2a8aff6c7e33731f3c1bfa859b93dfbc3d2813608007e74bebcad0c283efea2e59f220003c590c4c80c133a5c81ce9dd6378b7099785eb78c866b77582defa94b6ea33a11eb093ad049294f0d3bea6f06a885845de2f5e07a24f1a8a8e6aacbba8e546fe0b0b7b27b10777fcdaf3e2a8322168c648a58dfafb6954d9c086a5176bf1e2a367fae6d893bbf0fc3672703bee2c73d661b81bf6bb159570486810ec3a3ffaa183619b320c3a309c92aa07057b4d741d4b503bff3e94993bab67a7c7403060c2f4235c210cdd75b0442fe13ac7721fb4da7b0d31a3e3f87f5174acac9eddfcb479c2c3912503da233cb49f48f938e29a9b0f657127569b39263613ff96354b0cb4ba0e36f155cc73d6f52bfa3d26c04becfa071b5f89b7c024451ecd9e567b9793831f72a0e1a70ab4e950989fb8fe15fca7a918ead78be1a6a9adb4be022b4390a99d1d903b547fb57cbd8b50ef60db4270529ac77ab5e6b26bdd949fce6be641d6cd160767d8731f03131be682e10dafb6ade1cf0f3494de0e803740945435a914fbd8db29627e7a8e8e16ddb2417ad6e3f522defc9792656dc08e3d52a10242ca1f290d80613b1e781a3107d0de96b29dd8709d4e7d214af1ce5b54493db83589a9bcc2383ae275cf8789e8cb5428c8482de9120d4eb9b79d84d12e477943f689881389b3ed6eddd05df1aed53b2cda6e157d3ede2a40b1c827da4df020b3213335de29ac8df9de87db8fd8307fa4569ccda4a19bf920734b0e7ec8e1472cf2bfcb16027ccc47596441b20534ff70f38baccea17c3892e70f82eafe311512f2b8b55b1bcc0212a19628ec6100cf13c293892d76deffecde49b0ee0c406b91e6b275743fccda4085c3294581dd5f10d2559946f2bc3d19ad6db37ce7b745ed4e8a567ea8ee2cfbec99a8c4f5491770273553bfae0822e995983b56b307175e3dc8ac54a7fd801e0d5bf741eda8a509932f9696b578da4beb2dee578ceb2766d0f8d3d55b9a5ac89865d4c8ff679377ca4421bcebb9089552b788fc2c104a7328bfe9e736740c9b426bf4d54bf8f2dcb2236f0583117e6ac8c9bd31f991e18bd98eb5bc7cab1fb94cd3d2685c6e38bccf6101dc33bf67b96365ff1b195716097a2e354ca33bb4effc900a1dee82985289cda639ad0f7b8bbe56831275dfd59a42714422799f47fd5353836e4a29e89b3cc34569fdf6fbff6cc3243336d1b0d83997e0fb10ec690b6e317608b2a9fcb472c290aec608ced9e70eb3a6519c606152bf2ba9f2441fce34072b733a154c01a3793858fd420e20eb7ac96b4928b1528eff6d54df628a73e19a18f9b4ab070eb26209c4a9b029883b10101c4da4f340547bc07c738a963e6fb8e22f4fe419b0cc99415d51fa20cdf56ab06acc15d62e65ee17cc6d0767e7d77f8e0dce6156282c581c39afde2d70c3aac0eefd6dd73bac8798a9d1863c86f1b5f0d32e4e21a3d268d5497e759c08cfd162edd92f9e5f75c77f31f8567ffe825e73b86c3d9e34b6ac45ae723676bd91c0701e9004afc9c2b26a7ddfd00f8e205985d5dba630c474331876fdb45ee78d4f290d0486cf4526c621ffba62506da1f154ace6352189bd19247d94760b495ed683ddc0e207d685f5c6f604157230c7c1b57f391826303ce96ed2962e37add568e4fdf67f1ba1b67d0dc3ac4cf462df1f32a1b47812f915c8923f8475aa39ccdf367c91796379216916f3ce1a42f2543e374b6c3fd006812e807a2b8b5519e8021bd8bc800918e382e65184a16a206fb3cce8cc813ce5941a2d42618bd8d2c964994dd5bd00aa6b74dcefeacd6badbda49e9a9a9545d33f3fa6cbb4c0c5599de73a29658bcd5a99db778d02acfafedbc97f4dc6c962c744e990d5aec6148172ac84b22aa555336a88b9a6e20cea889a833966d74bece23f046e8dd2922dbe24e73fd757c842d1bb445bbe4d5721e1ad7b9a6721eaddf1c98f49957f97f8d9c6a9da4cfebc080e1adc5a5e59e6e3444e5e8f4c73f22f36eda77adf8761db5cfcea4cf84199644eaf4c12e43caae92a8c30fdb613b8d0245fa8237c78598d2ad33e9aa2c58bd0e4f5ac5474fe954dd8a5041312f78221ed1ac4d623c02b2a8d53531eb53c7f26129c48dd14703a044e24b61078ca9a8be5c2f852b9696c014272d393a07c177de5f70939e2fd5236c30ed9e3cee59b662f6aaa730c546ab085877de93c23121261b88f94094fe4f66bc52c0000c0f17737a4e02503b03a221279ef2c61dba9479a0bd87b2234f9341a34d114ae3a9c4b5b5360b300a6a8e1bb846b6ff919ade8a388fd67bb19448f638a766cee5cc5fd0c37ed3d427d943ee7b3ade4e29163b584d0f7136f7943049160aeb27d780cea712127fc485646c9be67e6e264768626dfe2dea62e55acf5bbe2139d38666409f433eb4b8ad3c5ad69bb07154f15691d67cd263c3eb4abf4ba1a27f81137deaa73d1120c0ec50f781ed84b1d25e5a42077a3098cb625c620a9681063c88a41ffc4f0f21d880aa920891c4c990614c39f714644415bd14a4b1d11a08f1d1b32b2efaf1ea7075c7a055fe3c9172696731008d3901327f33e5034d0176507b95a7f04bd69df4f396c98ae43ea2dd0455fb0d4c42d88f8143d49d2539b67d2d2bea1d12d12e08763ec6cc5d5eecd61feea1c403fa57da950f7ba751df4c11283d6e5bf812ce72a02b1fce1b1c7b68987ee5991a19662d515f12ff2ede7b934a1df748d0435a766d7f3314dccdb5ffcfa75828eede55ba75a17122ede93fbb37f689b76701cf92c231604de6b597070d10457287f741f9471292af4c492d41392d5f986a7341429ec52a0f66ba3686ce951c7234310e6c724b0f95306bcbb90acb5b4c53c625925ef9bef4ffcd9609066164de3da18c13b92d642e6cd9fc1b3179e344ece84a1976a95f3d64b276dd5ea57edcf1fece57e8761e2bb74e322cc424aed306b346979478f8b764d4488113e78f99901dbd73cf106f463143861595b57483dd56677d3c77b5d1ae9df86007efeb24c843d2085a945f42070c78d24654df8d1ad582e3880edc8e706ab07f36ce874c170efd1dad229dc732824aa796d2ba02aba03112a6b9d72465ca2065cff6d6081b5b25b340a98ba1cc10eec344292fd5e77f7c8e7ca54a2e06ce47b4f073ef408f55c97d3c24a98d3542b23b73ae7128addf0bfb5e4931611839d607292079241efd8ae9f4dccfd06a10cb476814419b9b106d2771e9ddc9836786bde81aff5ec87f16532a8c3fa08b193baba0db69ee775f36995e7d6e70d8c1fdfe3b19a0b5f8145b4fbad454dcb8e68e5f49756f00cb8d99e7ba168a21fe608d7d2041e64a813986d2ad3d655496c1f4d72fcdf8150b4a5c483f2092206966544f6fa3bb292d17e81cf6c7960de7ac76cc92bf760c9912a7b4a5514811ef4648feab184cb21294c36d66f974408c136b078a3cf54609849832f4473cb8a0ff489b2ccfd648c94bce0921c3bf5c7ffbd88f08498561db7c8e4cc13e7c87bac05d81f2e7a3be1281660c24505707b337f947c4b3f7284f6648f11c5cc81314e4c96f3767cf3a5f38af91c5e8182578b65c5b4f8d9a9133e7ff56ba8ceb7fd14521725d4f757e7ff457710c1d8f4bedb74503be7c1eb5061d24d884dee076756b2477d9c3ea344a3f75436a59030c136617a2ab3caf43d77dbbe84ec48ae6644f7a97f203feedf3a81805ff52264fd21d50383dc212c178b99ec216f561b0fe656cd3c9e10899455472816327912b29781d13c0fcff1142feb43ec59a718954a5d10afdd46778e5c2c845c7338dfe3e682764ac732f9fcb1baeffb82e0b825a9ec2b7ea1aa69d750d0608dc0ae7d1647666a8fbe963e247913ca8d01da73090c0240a46ee7a42dac87d294a6513f90a22edcb5b71cfb59bd8e72807a843820dfa7f12340cb52fc68b1b72736c58456a445afb2dc33743227b76421e05b191ffc102352497c6d0f25b7e63a1509a4a80bc64254c87bb0f3df001d5273efc541f1744fb7469a274997467cba0986724ba8aabaa83ab7a4889d60be75e98d1fe3390b09b73f8decfca9465c082de8264faa2044102b5386b747687513e927f7ec8ff7b219a607b2c05c1a09e9c73946e5432daedd62aa51aa2617ff1671b9a216a53cebbb4a9ad827f4d673cd93ccf2acf8e476ed8893c07478eefbe20a1d8aede856e2f54ef080cd597d2e5808bdf732cb645c544146f4ad179a580ddb5118a2d902fed0d53a178e8594f15a76b192ac1a9c4fc5372a2bfba1b94b7ef7181021ffca2ef742c5a166e5af35cbea5cff38a902b9ad44991b57bfe448682acacfff49ced201128bde36977d585cf3c607fc1b98cde64443eea77e57adb10f2d3369694c1ffa815fd56e5a7666f4d9aeec5746c1344990c75552ffb8c4e9d17a403bb4eedaa520b30a3dfda242532920839c51ae8a3fd582aa721fcfdb0c11ca625097bf2e03924abf3888271eb4a23fc4bbc31793419a7003ebdbc31d5c79670f8b1427b59248ff0dabe44cbb2466bc25458c9f50289fef4d589e7610689ad97a96881098ba8796cdd884816a63044b2328f98b2bd87ad60fa76eae887a629dfacb6903e7402a083e8c328954efd3e6fbc88a620343b91f2469216bdf8b5ece64c0400baf5987416c7c0752f34aafd2e67ff217c07ae4311b55bb27dce584f3c940548b6fd09f16b4d048b22f2cc575dc33474565d1d12e7f214495d113302f183273ca89291f4f22573c088a52e1831698cb5bd972e1e71152a422a43e159f76a497e126e84d2a634318a9250b4cfb78920639c71e09489a8d1e5f2d64346e5e6168c11c88f5087608e85505c627abb45ede6a667cd80a09934242ad7738ec890ab9b07d7def93a7d8abcd8017446638acb65adf597b906953fa604076ece6f1db03f693760907fab87be3d29021521b16b43bf846cc37bd8e7ba8f6bd0df95545b21e034e7ba33329a98677f7239958bedfee5949ad5becccb24038ffea1c6e125d91b86cd0ad004ec495963017d9626f59486b4b7582ac0d3504a5e9a82bc34ede4590db3ee103335175684d72cb1aafd414b5ebb99a9fe24160a04bc3dfc3da9d378013945db4932aa4962b8a0b08bcfa32923da0d1b082a84817b300efb898c2b4d249a11069dc6a9ea99d79cf08ee18c87893be66990f48a03583f7b23a57402d0b529268a4debbddb1fbe311a6eb4bd09ade1a17e8490d90cc3790dceef92915f1b828b5e5c03a1c33602e31f7faf8d4f9b53efff81c91c9e69b080448aa8470a1c73ad2b9b336b86191886757cec85fac2e0de82e6f4cd78858a0dd6a84c6593d4e0ab361bbb206d59da57716548d3e8f556189a5eb6a32bac46ffc6983f5d26f4d5b7e56ee6114d5de6fdbaef2649ebebbc1c9313a9f919e7c7a9c8660a18eba3a81984dc836d80f622d1103023baab8900644c9c8b0c96999026d9c90fca67dbdca2ecb197c28b2e2a7cf831910090883229348b83454138e1f36373a741d0b5762f94be7bfc22702a915e480bbef6ac791aea8c1a6c629c4d65e4824ec323d96bf8df7f2bf40d94df4545fa6b4feac253b1ab8f899e317e80dd88ba324375c5979fcac6fd25feaed583c1720930eef6981a88da7dae5c9b6f8c3ba9283edde5a72759683e4ab3a47c4ac5698fcf621095259c25bb9f8d0504a588b04de7b079302090df2939e4aa94aea79d4bb7fe31e89bf54992a51e4c82bd5f933350feb7c68458601fa089fd18ce028031f41843d985b2d7cc3baf6074d6bae7cdb7d4df6dd8df831d8fe5439b038b6ee03ec2ed086e7b3862501d3563a8d8a22938bd5fa6e054f26c292da9dae9970f0e70858ecc9da69344dc91d0c74037a4f6798422de066a1869d88c0f8fe46660cc2ed67d06e33d3320cad0a9fb6603cdf9817141003b603d3086b1c7c034f2b198dbf961339e0cb91009d5e62e717eff714921ec5b59dd8e6006cd9aaf59177a715a88bdf56b59feeb9e2737a54eba14ed858a362f218e988acaebaf943de2ce4217010a2630852a35cfd73e5c10b386f4963d238d1755d49939a5b990f854479b05395009294abbdf7165a369b4073da081de96f5aca6e88892ec0c85a10ef015fff010325fb0ce2f00f455a4e5f39a9a6b6f373f3a0de7adc3661c1887c10c736a29d4add45fee85c1da118283bcdba60893621f5ab164dcccfb3d5655eafb44bd452d8ba7865a8548f874653598c4e00ac063fea8ac6ea55301d1ef246b2e03964a56a9e9c0f83f162112974dee6f9537362e7009d1e02adcda9740d7eed1347256303246039b1e8cc0262c07216b7773ff2333b3259497f92bc1bd2e8c6f20d93967c4d20fc6906995370e44afd4ce819004aa27ff4d932408dbc5662770ac4a3b40f5768a88dcd7bca9f12086e7794de2e78e13737e9f6b2d2356c12d7d3d308f9e18255ec3a071c220bc7bc890b442af9a1591dfc2257520582f59af767d246eb90f4f0b4b6a18244b756303bc13ee6eabf2e81a009aecbdf69ee7428575cfef4a693c08f9604060ac1213105432d3402a276afc4380c678d48d7cbd7be32464f14711e09fbe4283463372074c517486d4f2d5a26d5d100fb7b1508e62a314010e6d8e1533160aca2f613dcaf57218345ebf8332a341df0ddf1288f81a485a9ff57b137994bf42983186850efd3a5804c6b7df8b77d34fc274194904e7199252fecd861cd83465f735f4decf6b90ae92b0d46a610350090fb56be7793fd31e0adf2f1cb81a95b359991a4c39da78c336893c969afa9cdffc414f7b5db8c3131766e9dd5db29de8f76d1efd1fbef2ed7cf718ee7b435676799ceafecaa5eedfcde940c701fe934e53e7fcca664415ed88e475b5eb34353cc915ac04e7ae965f6061873973ed0bcce171d276ecca4556dc82bdb16847a6aef75d343ff1533ede737ddc6c19b587e0db61a00acc1b756b18bd5af5a44b41079765ddcec6232c440f0ba36ac805d21a22d3207016c7d84a88626b867ab0ca791a414868e921f5c80d3037d006a4ceef48e3428f0316f7c794ca27d3fbaecd2bb0af366f033b8ba21cb298d364a9921e29596b744391ed18e5228ada00cb97eeb6520c0ea5460c6010dc776e99baf4d23164766f04464c53b61acd8ebdf1d30181aabd3e9ab6e2ce663a5c2c996a4418c12ebb21881e23a5579f9f3c7b9bd0cfaf67123e49341b7ab1cefe1c37f27a999896c23731994a4b9a3051d88794c4c6ca175b50781a2f762ba87e8803663bf4428daad031d0c50c382054522eaff7e2e28e5f777d9a5d045e6cb39901ce38e6a34675109e08c9103c88a5b7f6dc826e4275343377443efcbb85cc889ebb01cc1d1407926df57a8bc45786874ab6ee0b022bc49bcf944e0187fe3561382d77769721a6a4a490b383ad6de4d49e02368d379f06ea914113e626865971db126e19cd8e5283e99bb508cba9a244d969da5de05a710bfb4518f9fcdaec21f54a57a3177c49961bd390d88b5b97141cc0994fdfb7e576732acc9a44efda84c153e36639627c15844de24dd64a980703eceb0fc6bdcdf6608d172514e1b97f8208d1c2061cf31d076fecc7326cbfffe2aeb7de3bec6ae699eaed1b427cd55e99582afba56db8e72fa640d9aeb0e32121b9ca96faf2cc0732c14f2f01cb9b700787df18b8bb800ed1a98b4037bff22708c0bad3aa5a619e7f93d4f1cb1b7191d6ee817746d04af89a5c32285ecc8552273fc7c839eb3d525c9013aca0d0664c5195d3b4c42a1c32b8b1d8d3e4d9c5e7d0c6292e36641f86ad180274f6b1a312a125ffe8c4b0a012ec4b33d771c23ce8a7b4e6c2be34d1456e1d36718b41b0a5e18337befc4f333875f889c3eb4f909338a52d9a0b8c5ecae480b7c3481d9ba76b118c4628a5ff5d13427dbf87743610fcf63d3bca2bba4cad161f24c1d3907de92ec7e9b2ac13e1c345a2743f0a31ad4d81c3e418b63fd44bee8b8dc6796bf143ba80fb21ba2e05889ed8b7910e712e016535b137562729441c4a25aec97008e078eb6f7ff82e743bc9900453d6b7c3b3ab27899ca79df4f32d704bf1a31e0d05b3631398f49127a9f7efb89589286606ebc072ae4349f2c4fbcdd3b13a14bc3af06c18514b34e166072ea0f6c7f44af3c0801df0c165bf7f589456c07d340808b4b16553850f0a9ef54a1f7a444c34fe541f522910fb21a3c586c8bf8e60569ec96dd09e7d169fc6b82c6c510e568e2fc58329306dda3fd11cc9f385cd84296a6c5ddf74dbe66668a516a45e5035797382b1f55b8eb8d90bcb92533a118f140fb7ec2e083c6d02d64f8736da01f8df5a3e815ed5107a964f56c0f35325bf0dc41460147fc7044b5db72a1472a118a742ca2167ac83632723d4cc076ca9934f89fe6c5df410ce3728f2345aead0075194ef394fb7089e74e5432e63001b10bd80c3af1849ef04e5df7176734e9a4633be69f8e7d2456aeeaf9ffb808d14f5097d9d472e73400205e70604e5ce1b43102f49895f81d57d94854d468a39b93c2aa45d1ad912b3fc7d58627972753c943df62e8d2fadecacc7da1ca60e29d2c2e05466d77a12431a32b240fa4d6e313cdc39c748e5bf354d246a9901a4486b0ff0b8b2da7ac5cc14f3be9ba8501020251ce6fadc591df196df790f53ff198d420e4f03641cdb544f638b5d336bf9fc9b526a174b9f1727579a7ba48b6903be75dd7dd44d3d8283be861eacd762f54a0c66d96053f297d3c21cd4fdd9aeff626c6f51c3592b70b13a010416c51c6019f6115f7ba7c178ce8f0b27c0f1757f1df93df9e3626a13bd2def35554017736b651da30dbf027d4fdbdc396ed69f580cc14e1566a90a60011c14351f5e0a45b3aaf129fd4b03403556ca2c6aad05a6b5fc92992d2efaab08b9a57721bad55e5ddd1c9daf568c7700b471859bc1c0886bf278a5b9580f9225b0f7ed37207f2688dc5499bf9d610252b093596b60550d531345939105bfb20584e35004531582338364f68729bdb5f0588408e254f2cd5864b8a360a1e2ba0e55326e2a22a2643727b7c44fcf9a66478be8676124a43ca953a62cf4f1f3c0e1911b9d9fb1eb9bceed0db7434ba150da5ec57a777990176e71113bb90961c53e96b60c51b1c47ef4253f352f385adab22876303d0389ab438408ebb54168adc8189cef0f024eba8a9313f04d84ac0a9be48676e71ca4bef3a7897bef40f912beb86c9322034c8fece002c16e607b8c1edbe2ff7b15eb31e0340b234561cf93c69812556502366523c3abefd55015790e5926cd9869a9b28eb33208f469f3f63e79edafc9fc812eff110b679aaed6ea58579e8d46e072d940fc775607b76d30b1ea3bde3f6e9b93bd67da8df31111260e221235803822875c8854f87c95ed8ca9c2876b43cd53b4cc4fd553058e6c7896ba861ce6db02b88d63a6f6590eef63bf6c431fd41a12ef62f194fc8e1d7863033f62afce9ca1bcda22ee6550a6845e7123ed65a54d258f7d709cde001b02204df8a85f9503c8b3d9f4eff86c312bc228d44caf7ce8fbf1192fb5a651a4f15189f3aebce6182886fbb92da4825b863b4d4571c8432facdb2055e444f5cfb05bebdfe36e72c429faee2b0280aecf9951ace3e248255bddd424aeb846f5704cf735d0933b62cc3487fe5be9b545665538fad9293c56af5dc5476e4cf5426ec18da67c90f6f392c9a98c3e36e6b0a79b9964cc97be7ce2cdcf3d727d3c637621c9d3baa7bdec69b53a6e5dd0ab1090ad0adc8511abd80f6123f03c9ddd7d0f5bb4c01de47597ec2518b452fea5cf2b52cc4fa4523f468b8d98d24fea2b90ef44f5df5feec518e145f4ac1496af830c79d17322eafef426275083a5a65975e628016ae2c1c14f805f50d51046fe1f960c1889fab7934484d3374f3436c96d99a9356ca9441d40e9ff75aae369d67e0ae5e9ec995a255ae808aa520f7fa4e4f5b6a6413bb99801c1b9839204d24b3fff46e0808b15ac33b2dc46a3088c2d39906353df864c06e2cd8d594910f1a6664e4f54fd77096aa0467bcdaf6f3e5a281ff03658baca03f7b3f6a656978c173d514a09afdd3a7da1513008cabcebe96ad013ed2e1a143378f353b832ab452e325d7e2352c962cce3639e52c16deb0c51ad7186efd38538cd6fde7cea32a58ebe0dbaedd17f5ed1c6b604c6199f17be54fb2eb0df0f6502159b428161e4d28f59ba260b5f480ac8143e1ccd87635d2d99e30aaa9b2f63db62f282d80174a817cc1195b584c7fd811a257a65b30fd4ced6c24d26cf74e73733ed7d143a85929455e43167e8997e1ae4005d8f796494322d3866c1d6ed004d3d4c0a03f407fbc66b8e6af0d023a22b83b23bac5001bee63fdee3ccb39912eb6d9ac4e4ac62d8a275b30c2755978e95150a2e061e705c8d5855f4fbe3e1c6c4ee1e0c9fe36cbfc9b1276559007a26128d164c7b93898499e185fa46f4cbd5fff3279c367bc57f3ebbeb00e826797ee79928d43e44565e7c7783bc2aa2e9a446d0abd096d5e7ed5048fc04b358760a58edeed9224365e0079026b7d7d087caa70e3c2bad2e1c820236d3a5adfe4fa86f444a1f102ccf1da162585947a363ccc97ce4fc7fdb68cbe4f417f0ff0739b2e837ef4f55f9d1873352e342035b379f4d4b724c4dba4a54ae44f8b78eaef2beb5c3f6ad8563d17f2ece409ddd4cb96014f66dfa82197f60f928b651cd4ad4e522daeadf0811a898c88c16e38a520fc67db6fafc4521d9257b61d6d4a437def9322c7d7588df18cc926b03e5a837a2cfc1359fd85cbbd56b61bb439687b388d0ebfe8644f319c50b9c865c6f7b585676266bed01d6d49c4e155f7de7ce944b334e4dfa8c1cec8e493fd71ad916a34b072e08b7c37d048603ea580376fe856f3909065d491dc69a5ac4812b38dc117253948189f4c0861a1bc7848fae74069c811aaebe351b5f61b54b116c26a55d720e5cf752bea25f739877c6d9f77b36e17b959b1e48c2f8870f5547bc44a38cec9a6a680a1264d5ecf7dd607f40b134ee3af13258d5f389d9d747c70bbaf5f0e5fdbc428b8055a6f02e4f1bc98d2676745d4f24399d8aacf345c826a145aab5503449e462378ab219c571f4d9ca57aa2c6fe0a3d4b99f826a370f863566d13a33c9b8e16af2d622a43462afa3b8c2ccfe889f5dd095f9097e4c1bad0d89f167cdde0fc8038be150e727a4299fa749606d68eec270a64460fb21c22078b4bbebb77dda2ba25b1f9e4834716b0c8548b2cd1491029642e66f8d8bbf3a6d8eedc95207200fa149972f2691a7e531b8e639778f872729c860087d3d72a7475a18e705bbe23c2b67ce8eb3fc05c9b185405de1e1a0aaa92193f03e03c6b993d7d66b148b6637788393130213cd13c15b63e737fa3ee34da4396510d43f12a7c75dfb09f95a166c3227906d50eba6e3d38b5ded94d78544e645429132038253f5b644dbc179074929a3d409af22d83bebffd9992fb61a7926ac1f3f1a80ab79a849feff3ac9fb3b6d84debc8bc939934633cb3e0ba4756e99e61ed96bdceb901aeaf2589e30f8710e48cda53195089831ac9710358a60041e46e7610ceafb434a509a789b8e187cc05a4e32ce5978419c54467a2c869e72a103bc18199155637dc59b5a3b3b27c9c7eaba427c87dcbcaac48c9ff77738213265ddb9ab75c871ffcda500067d028e8baa61267577435dab3d41afe290b17520d3d581d0f3ffee01c2838dfc1ad397247b3f185cfe01e18ae8e0ab3046c7baf5cb64615efee52f3b8b50641618c5226dc069b6b0bd4bc350f1c42ab36bf5c919afb530ffdd156584d76d674b885f3f5b3572e61441edb115ba0efbd93d1937a034efa8ea6b61915595d3f04f388a1fd50735acd128d40bf77d47f17b3587713496c6f0f066024c10d87979a66c0a59a4fcf2051541be1a31724fa80763d7ca08f7d13203a4266254087e8dff63f2af526df8dae0f10c837692f32c873ef0acc090c317f40bea4694b9543d547ceb2e69f0f3177533ff93c17cbe33cd94bf13a763636429cf4f68302878db1d4e6fcddd069dc36496b973da0db5d08ecfddacd66327f0563d1fe4cad8d35fc56f4634c2a6273affc0317dfd549b26009dcebcbe4364eccdd9440f239daa850e3ed802b267e5f14ae0c148963417617d81219fc6442ec78e205e86b2e249cb6f47eee6d731bc2b85f734b24614085127c66453d48871a1c1f982a7d5e028d413cd6f8e181d3a0c51d023e90e49f929f71a19c42ad734f6a2c9240c0fd5977e6e3a206279f02c254928725989730cfb6f21a409fec08262f96d78efa053c4cb3d37e01c59f2a083dd388acae3e0a45a27a623b8a79a520f7006bea2418da22446ca0e8a08e7d9606b0726b6e3927bad7b0367388c5e94449847eca4623cbf95a2c69751cd12cacbcf9b081fd9bee53362f4aa90659f59dcfea4f62737df2f3b88dbd3d45218854baf34cef202f78a089d04a3e34279fc6b6f0c454afee702530e2788c7ec255470de77a4e0fce28d218474a8dfec68f8cd4db2c282636781461415307384c70cbb18033ed5ab632484b44a618d6cff36071d198eeffaf560bed9206e63ce912af652fda154911ec13ccc3561686564e5aa7d945cd80eb6dde596d81241e3b2fed5cc4681bb5f1fc4868bd3824e7865829c295a8d156e8045f5b737479ae95230acc43331c807a5ca1b3bc0c094b4904129e35e371a845b19163dc0521c3b7c40c4d4fdb0e8dd46ee0f6bc7e04f3c582eb05b4cca7e5a49827f7698b739b697e71971eb94a0e0df1507caa3e7091afec265eda2736758f08bdf384517a4234cb47b8c62e3ee85b5cee2d4c8a790042039b9f74e59730dfb96eb919b194c3a2cbcd6c24a6b37327890cf12021d5a19232650a670fff1a88f2cd154a4b785fd5f36ce16d82d14c70fcf281a46af15dc6eaad4535a0d5288d1630dd08c72db61a6e6d558","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
