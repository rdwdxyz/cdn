<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"61d8f0f0db275c534a7474716dcfafe46bc7f57cdca542c46bba0128468b744bdc0e5a14c2c0bf015d3b78502ef262e1d7541d1cd0b4cb13699ceb14e0d2b75da31b48e985dcd573a3635c8870a87a9636ce6bbf0d42331fbae0c8a1a01e58b0c4d3fde55ce947622722a0ae3b3b17980d92b8c0a786e3ce84a909fd609d75dc60ac6c44c684239407fdc2d52400a039b1aabe053f2828f3761f9a6024be5ea5dd3c28b83a7726235e1769fe1ccf82d2659f7d28ff84cf39df52f05742a131bdc0243b9083b232e12f0567d87618208aaeca5673d672b0a41315d5546f8303678d1a8149c411ccfdfb6adc34fddbda2fa587a8b53c77727f5346cb79c137772eaf4be601b4e5c27c6917b7708056837651ed35b88b489f3416c806126978640c49a31d0a7bb4ee7137652ecc9455e165ffe0a794d13be42b9d534583aa37d8fb19751bd5d12878f632f5a55a762bcf092f110fd431390e30eda5ad95f7ddc2cd6f2be335e91ff4b7f96fcaf685e7dc24ddf734accdff003ffb4e564a14a9bb715d51b22d25bc0558eafeb7b1e9c4216ec6efd78760354cc414bd752eac4bd7f9533e8e2e4f6b7044ecab7476ba40805f5c13651afa03888d6481e3ca2c149ff513538022a9ba9d5c19fd39d976e83d38c6c0deb197ca9fa456186223a8677a7a0c735cf93b495438a563b7983ea1cba9189ef6ab6bea7d7d0f3342620c82dd3d96c00cd3c0a8dc8540cb4c0d3590b7f87771a723555ed2a6e6461c20a91a34c3fa3988d7bce74be9f0f2310aa12616102078be947eccc3ea4279e8a2ca0ec3b26a98f9d38e17e7d24673a754081a07a485aa3de96900bb23fd04ca054e7975c6d914a3c8f74d0aa48f52a83ea342677a28258544de3edfc8810579b799e9f881978236347d15c6afc0ee91946d38d23c91ba69f202ef6b77498188151362b446a713b5ceb6cee010cd417d700cd450034fd42387bc31d21b3ce0fb1fb7de67cd30daa1c2e8bc28a57d4e2923c03ea5618ed5ca8ef5d3b249957b3e2c94712b8cf856fc94dc127d424ddddc54ea501713d1d4f8bddd5af79041c96fd3869729c6137fd3c0d48d6d0b9e725a3b0efe11346e4b0324636a655bc1b9245da1b5145fc36bb6b7a083b4c40a42e9c40e403055692adfde53caae3678206143b9a30ebd8efed6e15e1384dda8d500f5316beb11eb8f7977fe16dbe65a0093ab5de53792f7634f79b8ac9b232071a65e68e23003de2cd022854a56f23d58eda25ba3add06f10b3e74b58dbac7c1645b1a74b4792c9c81b1d8b58ee1c738e97aa0d59150270b89c20c4e19ac1293859b84e331bf82f239213d1699cb2bd04715196bc8c836048b26c1fed2900150c0b1b1802c3f09352d48b3b27222e3c740d94845d811953cdef1de75f012d0f7ea2789cbbaacce3a4b4b4c37ec7c840d38b1fda86c093da39741595ec772a7674ef894bc3ab8c9f6774d774b377a08f99b5c42aeff02a731139947bf2515a6566e4903fab4e0e9b84e7fbc3557135ae72ddb9a0455061e5afa20d5c18162d3225dab1186f98758a15d4d6f0d2de0db1abb5c9a92cc3b54a43ccdb25ade908775be2234a9d29231cf440cf9f122ea585f9f841e6c59cf48e4c931e9031e1be56eec31eaca4e9fc6749163b7cb1e63fc56c7f827a2ea8605dc54fceb1f03da792aa8e38c9081b6bb8abca36a8b91939936c925a5b2da580fbe6b1a4a363888f3ad499d8afc9a5243ce4eef0d0485ee864e30353a70d9e6c51accf8fb4b93f93a524fc0b9a425adad5f295c6f605f05cc7355321d75b03ebcb236b4a069d40436972b602d179d0824d505a62257a6d903e74a8fa9923dda6369ac5e08dd46e94fcdcb81d2b82c5cefdf560c7ee907e29e99fe40ea9786d71d12c08fab85947f883ec0dfb596c30692f934b4437d7a7fd0fd9833275b832ef6fe30c3867da8febf8ed4a11a763135201b5a931f70e0fef87743207d0efb622bdbd16e8b6db09d8c1a9783f0deda9c901812c23df7c3ef34457838dc510235f538fe37510c339f925d65f921066c557e6d0b483091795e8f55eb1a50c14d2e52800d1c87e8b43a1d9837359763a871a032e519c467090f7c05788f5dcba749b6f1795ee8a6bc40112410c5563cc3c7b24c3622ad5006c4a40c26aeec5a7306fa5528d0472a3fb411676d8ccb495de7bbefaf0d0e374b64d7021bc0071b33c367e8b600280498352636b47add8f47208888fef81754aac2e47be355b47da473b826988a1083e0ad0b1e87becf7c764b827f14cc6436860e429c11351153b3c9d0384050ffc58655fd467b8563127c0b330d19daf771ab899d4cb8f4c3825cfc13af73d4739462e4bcc7ca58bab13eff06bd56566a682b001d4c42196edbc85333cf4091706c1b44e3b87db9d1c78d6b85b789d73d571d00b17409bc0f1f68116a775b339df9208a08afbc58a83c9572c2090e247865e259883330babc931b2259820d85a649b80f9cc75784461ddb848195b8036ef387f67258834eaf1faac5fc63ae481ba8c101f141ac64561fce6ed929206e998de927615b160672726971a08d459a22e4bed54294aa6830ab8fa623b80bc9d4a1a36f94041a3e2e89d64d8b7c6d7a1c9c6834e402f185c9975cb13c1838183aefc75faa07101457600d6051662bef8a7f150833eb317d1a41f5f2a4e21303ce0b714ff20b8bc2942a2bff76ed3507552e90f236d9c8a46155504a70c45221bf1a3efe21edaf727f533fc8c9c5b835634e5ae69af8e6dbb94dc31164fc4aa0634b0bf1e33ccf8495435106bae4608b9caa70efb606e97898f1430d79f538cc1b5a331b6edb1fdc9922bf075e0fc653d21e90078d15183ff2b6faba8eec360fc107954840be8c3ab465f701a00447f19ed8e1db4716827fd71915ea796704e7299b781a2af63fbbed11df08e5b0b9ab3b76963ab47025c02fb18867f7cd4f9dbfcda74e14d640eae53e84b34a2b1165a181331cc6836cc63200f93d8e40747c312d5831a2556bcf24822579989423ad174e2b81a6be0ac0945491329db9843966f63e30a96b0206d993ff8e6c3bd7f76ec65c7cc3dcc3c2340ba441e5daf679e3b33b2759d46fc7a8d46707ae1033b4d391084e25e011b5e88759d3311f3931cb84f5f6f075a218046b50c32992f5d5b1a650fa1b9a55220b6e51b9328ba6bd75633a24d6229cc1b5268b5c52519fef3f01a0a29db0381dddaa83d2ce44b5b8eb9154294b4a34465d64f73edd59cbd017669571ef4f1cc3c33d6c05ad7305ba6a69e190f63cf3dde9e105999cabc2673c26b269c5082bb4a6a921bdb302a566339aa4ce16c7f0fc0244b524bb5b7e2ab091c642db57fab4faa4e94d4c4272d89a63adfbf6621789a8d0458e53822d1ed20155ec1e36138364872838c98b021ba19b722746d619b205e6c2deba5a8fb610e7d34b4b93c4946e0011bd4f4960e51bcfeae6172550d058cd3057a701355bdef61ff70d234a71e797086f8e0bb0d8a2a6054750936137f3cedf9bc5dac44fe80786e1d3fe7a5100f198681b0bcd70227c3184bf88a88794da01d5419c70207505d30f92ad326afd788161446af413e70392aa100dc940dc4989765b5f6238f2bb33c30722c322bae51714fccb7ec98d3c2d2dc48adc45832d86c1382410169f48a390f80b4d10f375d03fa2d86be39eac095aea9463fff507198d9312d57926350395fad73b861ac4ca1aaf908052b33c863cc78756aa150eed767d780131024cfa08ac84fc3a45c29e3935c3a387f827372b84496bfb62c915aff32138884f79fb3e4e288f599b0d1d62b9b031f84d858b3c130fb4e302a77ccc55035ee7fb979b64fb39775b97e65af3a3fa119c0b5262de4382599d96a267288a62c3a111f8f47411fdcdc7937fea7b2c8a1d1f74ecb97cde24b410db16e7de9651a04259185628126ed4b57efe838f53ea5c1c9fc90b828ae3ad80b7354f1d1f02bcaaa806e1536e385094bb486b494dd66265353f6011e36180684b2e7c57250cc391c1709bea115d16dbdec1f2d1cb009f96e33c97413612b55716013783514c987d7a0d217d405823e01dde4543c710f748042d887cc565370a8031ef2fca31b66d1495e0a28a4e90c660da0eba650276fbd38beee9251e91cc99533c888d4fd8984b5f8642a1eba277f458c662e3c965cfb2d587aac4ee68724f799470517977cc1af78acd9a8d19c8c1ec3d91facbcda3e090b081f953e110bcb4e1f4bf3b5d591f0924a74f9a7714821a4d602361ed339bc4a304951d8245b5cbf44d3e126121a0c0bfc5812113be8ef0120860978e5c12f1a2eda89207c2ddefdd75af4f8765df144ee51663f5f882badafb2ec2246ce3a13cca314e83af3c80435dbd9a6c3d90d2d19ba0d8d43cfe5a7b8d717e949b343c7f2919715873d8a1d01279d12bf95bea3c16cd6802e008c5c95377b4f9cbedcaea3508f3982dc18fe862ebbee5e9ef8b9dc41a47922bc0e1837a53e65f7222b4b3d1b57daa97c579cf7145f5d82e32eccfe533e5a2f331c067c3563aa49c5c6316ff0974b2773f02fb2869c80ff4b0cb317203e2ca15173f21040465901af65d45f5cfed17ff0c1133d989f765d307d89eac8c1ec446bbccae042d624c35d8fe08efa74b1d8eb1b01807a292d80da2b4828e8f72dd735e812f416efa31d3f8fbea2362e9970251e012b77692d6b1e21ecf15e97302f611e5a721eb1d67f6024dc2e80a92000572affe6fe6c6d5dda374745bf15c2a1567e01425d9eff2db87fea25dde94942195ebffe60b03727948e8ba939153d6d3f7671363886a9bd65879a2ec83df0fdd51fc9c4e5bcabad494949e8faff09d917e3d8ae4a23d9177720bda5f4a67fcfeb4f7d1184b45a142e0037baff71bc3f3dac3288f80cacc0bc18427cd3ebaf381989ac79598e31f90671a31c3cea4b53919fdaad2068bb785b5098f8d5d1aec616b970ff5239153c6fe6aae81a1fbdc540130494ed8f2e9c88211443cd7ca6a79d0ff5f5246f42566471e9850a60545b24e45a20b3948dbf2c5e4a4f45a570b06a722da1a90bb362d555e54d33353df21ad607b8e7dbce2e41fe4276db216dae9e853f3e8dad14a5117f633126192740d22144218043a56fa2acb07f817a3897c042197f4a2ef0660e9f46158e102e178b66e2481b010bc30f3db609a011b09da2102914396f60b87362be505c81170d3c461359ed64e778eecccbaa329b2b384b6802c111a4d7cb40125055d8fcb8d77ea83e70e7681eaccbb4a5b74f887a44fcfd6e69fbfcbd39f12331965cb86c7eff83049d463f992705bcf80e6df44111566984d1915dc3b34213fb76830804fa4206d5fd8c141a16ea3ce7b7e454cbe1d67d4103104cd9f32224fadc8fc104d423e9e8159f4f332a86750ecc859a3ff222da43c2884dc99eb9f0336d9da220d6f91bff2aaf1d616775c5583909b3f0f913d1cea2f3f255fdb0ae95dbd07300b599aeb790e02ce22c638dc5020d05013f01e6c46f959cd65538a0d0f74bbff8c9dde4efe66562259fd72a3ca9a8e6ac1e904e6112e4d75a733e92a7a49a4614e9a89631707933b18fe417b76aaf16061df6a95c9974be249b64bb8462041e51ba2ffaf4247b3a38e64c0277e50b64bc84404b6be29b91bbbb2a36b6c9360b440a206648962f7f7799c3613fab125158f24a9320f036fef8cda4597f73d88e0e5398be8643b1b183f14bfc07f1132f7ee265c48786d5373a78e0f5c44efe58bf00ba83828edb7328c5d4d435ce96d3a3deea3c1e908bc6a05889adbedfa3e759de7bf0fc0ec807bffc1317afef539b45b318031cea46c14578c7495542c5d35dee5856a2d4f08a0aaef20b4be7a6ba53aaa67747cb6d08939d409e3f37fd64bc9a04df3b5ef1e9b0281ec8811e81e839f274d162d95ad642981937605245ef4a0c594983d6f591445a0b4baed6188a09f72c25b784c94a0a7e92b9073a05e4931f73d5cc5f119a8bd3040a7906f20610f7b0b1bb2985faca6d86926fbe06e420879721bd886d79332f877a7c53c73e72323fd25696851a5c2e6fe4b60f4d733c4a575ba5ec45e29c364058e28970ac5f3c05d37a01b84cfb47af5ae2c91732e788d788672e2ee1f090da9e7dc5772f9d0e5a561db7b0809167ac0087c633889c95891b1b70a56ce510c10939ce5ced85fafa085770fd0408b7daa5ffe60745856463be8e40676f4dbe0c1c6009e3c4fc88d441375c8efd2117477f9e87abf4ab52e5b6d0b72f88ae736b37f02d3a29b5ece0d3f5d8ea12eb18960d7fd5c1a3cf3cfc5cae71a222f4c217a38e3a9753bbea5c53d55cea6552fcc19bc798644871faa0a19ca85889fde00f1be4d1a16bf42fc0946e8a2d806320246eb6a00f83cac0cc396a5ceb8225bde79c9d6ec3cc1910b3e60f64e5f250e91949649f5df99b4435fea0412f0f55c904062e2600de7d9ebb1400a04cf808db06bba532a8c8d0ff6599bf31027a2197bdb895d14b71caf1bbaf0c33d7570430d3e7d67f6d7b5e664387f4a5d0acbef3374d8c10a08f7c5cba45d0f9591f6b47e682462f9681dc8799e85ec076d478afbce96c3957af05c267d16f08ec6c89dcebdca17bde01aec2323755c6e8168b54261881f03409457040b6d4adf0e7e84e215f00c6170eb9c4dc5edd04beaad835559e1aeb8c20a4e419b7c37b609cb8cdb9c9da115a3c367947fb146384ee6d4c0c86cbb1d6d45213d656479c50f30baa42a63df001603b0f4ae28e9b9ceed820393e5b63ca120ca0f46e1f36787a9d83b0e4ea94e208177c6c27c1ed41c0e175b5db772451c0e5378511d071753211dca1f82f3dd37175d21f637d611ed3845dec27b07bb617e441bb60e9005c7d6c759cf25648ddbb06bbea628f00b495ae3f6313bbe555899e9ad0449a0d3e94845720cc961adfddd56926f65aaef9dbcb921ddc1bfb9fb59f69895b536cf2d7c88320cc3b907feed8f4423753e18f3fd51a5940afc11920fe62e525320b033048cfab4fec70b3abd2f4320dda16c34b3aa02e4de893950d3adecd135eb8284ced275d7d66d9816220f7d552f710d4ea4086e1fa2a24c9dabef3924c5cac5d3941ee9c71a5ff77ae71c00d6d95065a3dcc9e1d56212fe380372fbdc1af78efd6b4df6b4241eb11e9034e0155b35ee59dee74b36115ae16c845afd386efc9b044fd82205071899ae2addf53168cb9badfe1411a670cb48c122f48393516e629b6887bfd1b40a10d20a45b45a041fbd41871f87b52e3c0febcf286faa5db157b9d964ea64c0df8757f71ebff38279d5928bbf52e721b34b0d24839ea1be8db3f73d2e52aa38d8718fb8ef46332f0ab0055b2030a8397f79c209eeb12b2e0f59f125ea4781095380315b5e00caf2aef59687ceb87382e9ac11af4798587d32088bf0b2000dba60f034093019ad6211d942674e1dd5341ab1c10fb666bdf9c571a8993cc8a357daada8d15766e7bc16f126d1e627695b0c62ddb97c7332c3e34eae3b2448cd3a6c35810c6ada2f86ce9dfb0e60353659cfc056c5d17634f0a761fc6f56221c7a1be877e032e5ba081be4651a2004cfcd8d59a1511742ef445da5189621f18a2475cd0874cb0c7d69aed31c38ba621e0f6c4be47d54d50a2cb97b132a9a10419a88da02601db377a3915be82a8788c9158b17a08b340101a4d49587de71b59e225d5c239748c1ff1d4d71056843ba5036bce60fc417dafad9c10d4db1a87e721ea560c6c7fc798c66b7ab2b43a51ba97cc71172286c5c2ff09cb50529280049152f250c6af10adf4f8acf37768164fc12b60ee0d84ca0191581d593dc7405657618126d2761dd3f9ff74a96314ecb78e259671012aaa78a35619533bb72b3c2caf56c1218286c3983cad575789083631e8dcae74d472abe39d9704dbcdef8f77cd248ecfde3a254aa3953a9eaf81eb4a6da818724c3dc011a159a6ed10d9ca94c5703aff9860b0ee603001c1d53be1bde38ecdff70b5ed9171ae4e8906f3b72e367e422f0ce217f2d99a13e55bc832045d55244a6f08b722ec2b3419f7cd95e06f7a2746c60b09475cee4b64a1d826313e9c5059e40fcda2d393b7d20f9090396d5d57a4b630fbc53e3245f3e532d0c84f27c8b2bdb5f4a5b1e2e163e1682120c159b210822c7415c47bf186a02af1bb5ed7dd23f0e16b0c33437a932b6dd4811ab6a15e257b16ea04dc834f6eb31ebdc73c088f0b739bc56779d4522d7f62a5039ebdbed937957606e48749a622cb6aeb9a3df36d1c40bab9953c4493cc8d5123308dcaa07dcac1ccba507ea35c4005246ede9109ca7571259ae589e15ba216811570e224eedf2171418f444e06af2fd0fd19483d448cedada40f62334cc288c45039de63767080171a2e586655e0e59fe4386206e1e2b9faa465858b7a18ccd2b869753b25248e5665f590fce24ef73b66ccf597ebf443bc352624c2248eba3e7fc4362754a6ebb5ea43716325e54892136bbf1c30f8309163226eea8ca2477a15e95a40cdcc20c76d0801e39af41e7c5efed34c804e721ba147686e944560420bce9edc06fc948a083e489a30969b1e97dcc02546aecb9057b6f198bc4c83f6c150f31748086ff52153728c99408a15d353aa11c36de8bf8de1a973b44dca4ef97ca66371379d870c2bd96cb0db2a17fbf2c8b8860f4f50561a148989f957e8b2e91aadc6da7af14306ad7a8bdc92db59f4e39289648abf4c5f13e35c6d8a1365bd53b1647d9c24b5b85accb8257ad5e2371184a9f1e0edeecd7684651668ced8519ae1adef2a370edd049d1c30e1c0ad69693bf1826df38eaf1a2e6ed63f05e6055f54521c0fe5abac8d20b1d68ae043c85e1644fcc01b102e490ccd3422cab040b20fd1c470b9ce2deb1fc6f3f1e902b6f4addc57c40b2e5bb1ac7af1792f64b4e8e59727ed8e30bcb1d057c426080a9523fb3e7f44021e776fd1f185ee32c692ac86cbe5a1eb3078f0fed789dcdce84041895096b7281327cbe70f4ece39dbe962c6877a0fb767029d48d851a31171d221d6a2df1a0befe43a0144af88dee858fa5b52d4be06a629b418a5f9f21f305c8975feeffe1e92ab1240fbf59d72371222844eb95b86ba70e127ec9d2492c1e7d018daa2b2b9884ebbf58991f71452b6198034177c7d1c444aa821865ff58787c195fd35e02c58838417ca7bd08ef3e8c49b0a6dfb9c2f3e94a2fb48720a6c761e7bdde6c624ceb557335be5cbb8be25b59a2541afdecde71862718dd0641b4f2ff78f2e1be9164c6a632927851afd4793c40a83bc236f67a576c00fe81e5066e85b5ba16d9db172743863b1407221c459f3331e6b9d76d0c5e3d7ef3da0e3346f0139794fb414f597bcaea2da0a044d8edc9364b7e4e743284d47d9f01698f4b6e4b92f013f77801826651580c5ecf566c626317088ff16b4209a5de892f72883c9e9a90a048e8081d02e987c6a00ae448e13741076e0111d004ef97b9de69ab047cd53a24a26326b27d7aedfa8b28c0d28e13db617a96091930712b6480630b0daf87f879e4893982eef4f43038593c11a63ef6d9afec13ccf1b7b0f5f066d7138c7ddad3b5941c6ffea18aaff88f2152717ab5bc3e51054efb05ffb8cf96bc059bd0ab8f4176a28ee5856c287cec507f073564d391704b839483ac028e64322fbee15806cb65e4888d898a2a87909f16168bc23590db95b41d894c47436f65fe6de7981d85f9764a92798ddac2cf2750688db5493b0e0d2308f06d012dbf5787214e72cb7fdfcd0dc49db98f886a018bbe81eaf1f53f81af8275b5d3235769bbbdc4765018f2eaf76586d3122ec8c6454a91bcafcd900960fc1e94b1585ce41abe5c8848ca327b25921fa5c79a096a548c6f4937423126682b333ffb85b6cd339c62772fe88b4b04fef9881cf226258eecee93df5f3de3477e8fc6b0c617e3a61772ff4e69ef56aa9d0b780f2908f711efeb77e46a6a5d37d13067c3616653e29c831d2c89e8f0f3efa1ef6d17e16c1f09e675d095d7a20ef14b19cf838e6102c57aef93cc13071b3e46c71996ad360d94c0405a1f608909186f879381b55254f5568cc5b706a155c5cb4fb4e3ba385b77cc7345294cc070735df54130780be9e1f5e4d41d5ab530a1c93c5b2b310d321b25ab918dbfada51df78f2a44f3db57c89de99eb7a002618c4e726145f8414fdc544f461eeace8e38a9a59d7aaeec2361b5db8d01605c23dd0e620f09676ee803b346968b141d87e0ae723613338fac5e47a79686138eba7da5768b2c5254d4b798ca3988967df0bde57fd17436003034cf359d84c49f484bbda0a6812163357d59226ad0ee71dba97c65295c9930165cddaee6a52ca94d8356054fd60dd840e35b08af7483a87833a4c039c2ef9305fdfec1185dc9b22ea4bb132ff9e2198087e69baa642632a7efd10bbf45b74570a818bcdbad09cc075f50d433701d3beb115d70db24650517dedebdb64908a68aaa288b269ed8ad8bfed7c4906fea29eadd175df02cb2ec7aaab396fde3038c9fe6bbfdebe30eb3be3dda396e8ebbedfbab793a89689b81dd234a675ae027b7fc401c157d3c48d7bdb4f3e67157ac13d7960b76a1532f87542d6fd34553dddab30ebbbd5c5d642d89cdd5f84db29e3822cd78eb36ca14a50c6b4e2d7164fe1f5bec63ac9b13ed7ae7eb6329f95f56cf0dcbe9d280bca4fbde88803f4d3d0e06196ed4ab7af5b5d6c9268c2887d1ec4e5be199b12faab2daaa502d6ddec39021f29e06e71ba11e7f01af6e16a97c925009158dfdc39afbe4a8f62dafe6c28f1f8ea1ecc0b3316be93e35149a492b70acd84f19fa6b2961fe03ba4c276e678631bebd780aae0907d45f27a4c7c37bb8ec9dc808ba42cc1a4f59d10dd5b353987b5f3d8ac82535fca6bc5ab2d138ae298380b1599da64bc4778a2d27e16e3694d3892a57600ebc426e14ce80315e08446a0d6cc4a382507f367b52fe9a57683cfc7bf682076091fb81285bfb0126aa01499cc9ed205c9d90f400e7568a90003df57aa000888a3d867d8af52e5a416ebaf3354b6670c5ee25e1c39d0107cd3e735fb4bfc654a1dc69f34afeb4265955a9c8c76901cf5dba7b615094c6db629b5bc6f9e5dc8709754579ea5680be8062e94328f3501298e3b6945a5d15885207ab064a39228a55921b9fdd0a5a57d895e25eca02f1e84053ecef681324a8259a52c3a00506426c55fdc97d45e7ca5b1ef54fca1f1eb5446050434708fe82dfd2e6720e18b899066ab05085218260c423d3168acf0743d89746b089b0b9da66683f1912cc107835fac225f851630b226b12b0d57b8773b31f534fe87d2a4349b47f698721eee6493546faa8b248c467caa9003fe8bfe3122c6e84b555617c2a6bcfe294da6fc706f074956a3d811cb73cce73fd81c11682b186db34cf889accc56972784b09a5264029fff933b593f11b5b7754e0215945d46568d1fb21f940331d8adce8abc037b51faf6eaeb4dc3b0a5f0021308cef39c13ef8eb8a00fda3049f0f91fe73c35769c89bb16bc3ed7528cb51bdfcbd6e443d6f4725587c39a57293def775d6c6717adb544bbabce9ec426acea40528a490c63ca1c967bbedf37fd8204127fe2a38b12ec40379021ac6e9ca33aa23e06858865ec3f8f3db5e4e6e4ad558b1ff902c0dc3a78e2dbc88e71223f83e085a38f08479f32555ea83974096f0d8e0ff7004e7003cda8b6239ecc8eb6b648f6c333904a952c24da990a8baa461d043b6fa40ef6b4abc94977a0de653553f017e6697c8bbdc419f0469224868c5bf38f1278a0b227bd51ed5bd2bc1f451a6aff3ab6beb0cf73c61b09559795ee7f678b602630611ad616e51ac63c4160c2696756683099bd7da5a7351c593268417e740539e24b8186cad3e790625611f1f5cb2618767e1ba4b3d692b31dd903bcec77372549c5c1a7130338460db80de6235eafba070ac3e1f9957cf0e307179508b0ab1d1f93998a0c7480b4c183ef7a55052f79bfab5051e3dbc8789cc6283db6b5d46dfa3e6b02227fb144d7ca146d5e1636b1a1e5703a158ed473fd8aec8701a03269b71e6fd16c7c809800184e0ba6f8f6e428cc89f285190985713415463d60ae899f360c1082c28df0c85dc5fc35e71697f849483f2b442137702676da4a6757eb05f665f5ea578abdb785bcc9fa0b345f1186a6920c271bdc54978f2641ade0925a85e3fabf792d391b172ac2139cc290dac871c873fe7668d3d2a2769c00873d4804c58549abe630dd6c280e6882891faad77b03a3c7e154256f8ef2e95e12557a4e60e4373a4103a87a8ff6d588d417b66472a8f90385968660bf0f46fd24eec730eb7d6ac67dd970cd459ef020cab0ae4e1cd4ad55fc2f0add1ec06f5dc1eb6cbf1f78bd9afb0cd2fe73a8d9e45c3005807f99783a7d34c8a7e90f834ad26034e93fa06228896804d0d4698b74d76b876773b05804759d3715fffbbed79c5780ae1e176598cc8b15d76e58c32b1a171164cfb5d0e7be6c51e0cf2d8f69f053700c630c19558f8ed8fbde1d0f672e22e506b87876c44b171beaa8a37433239245b7a6fc744842018bbbefe46708b1ebdcd026de14f20ac2a23b197bfa26d1080e29d5d71f7a879dab38dc9fabba4b234501c51a9110b905709da0c548fa52aa80eb3423a39d569a0b72c657d43e8fae2e96c4fe9bf89167d9d3a511d0a286ef883eac8f90ce81271e80bd3811064e116942547fe6c7908f91e93a2856212aa5d708ab8897f86f305405d852f6a9b74aba144e3cd3f532b6829c6469d50da52884374560af0d3620215b6f587b4fbfeb0bffad57d3e7156e8bc11be6d7b6ad0a5f6d214335bb0d40785bd6c800d62242f777e422d9cf07e5a67c7456a91e05444f7e7468418747a4bc388b1fdeaf40d22f0de8c150d733e491d203f915ae96bcacf81866eece09c630fe230f515bc6636b05d9f42e67b8621404978763766a8623674cdaa2783699c5e41cdc02acdeb4c7eda5fb09c67a012aaa7a1bdd8dbfb41fd7650b363eb550d05ed25ea85c897997bc024099bc0dc6b076be8f17953824097b2efdf3a31934b9ad71fc205de14d1e0872620855b5972a7d07dedc48ee1537a841e7c838924b5b04adc9327efe2d1cd7ff8136d9ab3f3355e5c9415d4bdfe2d15c2e9778244081ddac144a86f9f2442cef8d373c684000c7dc79193b63d1975c1c9da9b40a902e60999e56eeef444b09a5ee027e55ccea51a78ead2d4508a7ff6f2e0ae9a7a9b5204d3b4bb4565b299168e1ac8198ab404bcf48d969fbb8c52b2d0c4dca6ae753c567dae443a94779eef4ce3659444ba37d0a7b5c015f422c80446cefd6219439cd8e1be9a203110c8c39d788d3f3bfa022a6901d5e1d80e42b7707d7399810309864c8a20b221a9ccf394e7bd5521c0dc32b92a4ccd214e147c54c2865b01d9e572f9c13bc0f011668dc6eaccb7dbd7dcbaf08566d3a98a9b617808128bbb2ec1628b098a606e69b970114f2649edcf36db8087e247707216497521b03453a881902f23a9ecaf6d724d45170675a41ab29d8c1e4e3093dfe6850d685f0dcfa02b883759b1a0ef4483373924ffe4dbdbf988223eee421b59e9094abfe5c78a4bb206be1e58112892c30e550764e74ea3bf0d8893bc10ebaea71eaf3c6cdd4b0e2231108934c70c07105a66f02245f4e0c803fb139bde368ac507744d005579e6a6ce423a75b98c0d6c5e9fcfa2ea744166bebe7750140d87975aa5857c6e6cc1a920ec92ab9e7bf8dee6927f7a7f9279e624982e5381cd1580a9c6ba3b49c2013cc3d82ad4a4991bf4986effa44887a67501326c529cd317427b697865d93c923faf59d21a17d5ad51d56af5bd47271a91ebddc82a3a321e8367eabd47d3673e0bd546f1911262b680322c6c4764046d4048b9dec8b6a8e4b433ff453bfc5f29432c9cfce9b7bb38a0d70e7626829493214af04c83714c96dcc9b2f43b84cb8bd96e7f1bc24bca6f0d0ce09c4a4a547d9c1432fdd59ef48b939a8a39a96d090a761579c1456826eddafe967310391189e82333b838b4e87be2c32a54199a6119883452fd2c2a42c35a68fa53bd3d77083ccd41187b16e3bf111bc08457955b552606e3189fd8ec94b9fc9c12150bbdbdca21ffbeb77cb8c237a71719945e35a205491d443dc7e37afd88c511ced520b07dfa2818270008c9bb649f832d0e2a5ee4aa279c82fa94adb91d3c1e0b0470614bf58b18a732fd4fd39085f9e6ddb57e8dbaf24f39402794154d91707e8d7c2f549821ced7ec46c04910f706bfe4249d326395781ada50e0a87f840734e415cad5f0080a4e76d1b033bffbc714df607018dae0468f6bf8f01810a77dc0f8b348b9b2a36427a819412a0c6832eb7bc5026a83ea0002e660a87b41696150767ee830dadddcd72cf5bc9f41efc7dc6336243bcb0dad3d3a8ff9c4f80cee211fb40da6a1e7667a04a7dbd02ad7be3be5780f748e5309c86db89ce44887eec2cbf98aa5e79ceb70687887d6b94470db1db0856f4a003f72e8acd75c5294a818cb45071d26056ddfedb5b464f48a2be1c6d957011c062613b0cd6131e678e6c82839dab8f96bc42fcfd759f8eeddf9fb256ccf5d1b9e9709e0f7dad4b101b00948b4743b1181d53457f1972849bc47ee2c73925876608affc131bd763dd816375e2c8bc1afc5f926b6b4566b0d8747950210646c7d584a9be39311cac88a19dd8234255c898c801488681d00369e11e3539254c1930ea8097a130b400c2d40f8c40291e91c6e4d304271711d0d38bb5b0852fd233a7ca3e70ace61a053d4a177b093c8765f34f809a54e53c9c5845f355aa3d2bb2169b9a859100fb8162e3b33a0f3e16189b78bdaf302ea9af759e8d612a9d2902be076ca00f89ddda4024b6a669498ba7a0f460b97b70f9dd27c5d1982d2627be88b1a2c9e2956c478a6b909f089817d10c39f0264f739883b2a554e62e5b2655f2072dd70ffe5cf6f72132739074d93031e50969c33a14774b2ef1daf274781281c2cc440430ef87ec2ca659bc8637e336e0a4f74389a84bbebd2f4125b5e62429a0b285e6f47383d4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
