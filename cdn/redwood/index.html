<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"824ea6f88e64783916a451d4adb2ae2b82e3b2da8aea96e866b570ec8f3d0f9760c0f1f91e714f4ddc73172be72418251fe4418478955c5bf7d41358f614696c52015a69b09b9589368f0ecd56d4b5eed2d3312d933b6cac7e7e3a035186787838746f136b60f3d60d6d4fdb30886c46e12e166c0ad2bec05e8ba99691a57c3f2ce5ee53f72a37f04b790e0637ae8555adc2bae960737558db42a07e73757c2bb7b2047ce6185c60e62f7d55545257dc22addf6ea29282fa602702478bf75ff820da93a5da82a41b23c832eec58ad9a76df73d2c607be472bb30950453026eed1c908463d3f3367e48fcf7f4c39509069f16107706dc0a5261e0d2abd5084c30d5c5acb849a501b6b172aadf12578450672d27ddb0d143e829df81a03213e4f621c8a7c11fea44e116693c2d7bc571081ca9463032d55bac271e07af935b7987169d6bab9ac166f60d4d24f279e3d54099c1369a5b3af7f2b4c5fbacb0b9c17b28f0fada5a57e358b6c556ba3f50751c14c237b7b434c552fc058e73af7c0f2f4fddace6fd43a7cf377db14e79f729aa0b3874c2a05fd07c4b7f4d8bee56d58cc1dd36a40beaae2b37ab45e4269921ffe3ccf5d483519239087f38ac2e194864740c2232361bc9f86b7e84cb5d474060caae8250f41441e679ddb40de253eeab533212958559b28f54e91dbf55714d74a854f926c2e76175204c9ec85b2105297b1ee64a22fcb3cc86ce9257990a2a6a1a9ef23c558bb23a6c519e7d3163e8c3f9b056ebd8d0077573c40f1d6b2877a8a50a20b83a38bb7df0040b3ee2609830a05b42f44afbd2db509738b09238bfb541f4195daa0e26a89dfebdca0833dc01b15e426fef26bfd3419f740f32019d1b125f7a5c8e3e712ef8dcea95b55f7af77577540493bb84f97d4bfa9b387c4cc88396050c543baad2c1c7f45be597f29427dc13db91e489998141a4a33b91146ee37ec75ef14002fb6b095cad21ccaca355cd7ecea606b954fe8c87ac4d134bd363f4c6d664a2b0279f9746453408519ccac01ac4abe964750501023a3ea6dd72ad08fa9875be75d1e5738009678ce0503961cdd78bca3d0a31610490701bb4cfa1026c9126edccdec5d363659c0d7e8e68e0265b2edcaac2114baf9eeab9a9bcc1da92cd423b6c81808cb6e5e97383991c08cc30e8c45d02a09819b729bafaa0b5ddcbefcba71489a7bcf545b33cea8fd1b2a6e92e02f8753397e7f061e9f6c953c2b383ae530aad5ac93d4319d529535f3aa70243aa32ee113b849a3ee05bce5a0c7b1a8243e68869c78258363eeec5d282341aa92ad507bbf4a974e5d561449dd5653136c4a3a4e09abb1a7bd31384768bf0668afa297b2972b6bff77b5ddf6ad2d3f4345c197184cbf75925b08460ad9e863dfe2af2d6de3f3a17dd85ab3e2d6c9668c75620a426d614814da0079c82cfbc65a0bf0dc0789ab6818b63c66d238a423d2bd4069ec18b6becdd0681b9653c97409dc8b13c92b50a07042ee0a726451037eafdc337c301d0697f831e043e07674cb68c6dd038f0acd20ca96150fa1f6d727671ba58b73631713e0560cce794ed3c136bedb347e1fd9e381bf213d3903941722e3628f742f217f5ea967f697f0a8c605488efff9678320d2d6e0044f415df160279afc96f2422503bc6349f2967070be14787ae52e152bc344bb59e31f5c16ecb0c68c246e5e69cd2ad71da05e8507addbeefc813b26555d15aa64e9f18acf774770da0322fcd8ce0926cc6b836b5e3b1abd6e9723401270d42bb0a07f4c8e537e8e8401405505cf775ae4fc6361a8d86fc3508985fc6629a99041fd6c15925d041c869e8a0509a635e8f6af5b397c51ec65392c9d8426c1b2ad02f64a13c280a68c58e0487cb37aeb5ead7c929e9d21854373788cc10c18f0737a97a80c85d5f6ac157041ef0cff58f01b1111c1b3d9abbd27941ba8cdf7c77cf73ebf8f2060a8082a4c907b2a452a720c5144bdea0e5a7abeeb1d3db815baccac250082235d3b8ed83b5b99a7ff07fc8a145bccf2ac2b914fd728e11773eeb6a021284bb8f9a958e42631ebf56b3c31fd6fad714c6c7e41b62e8d98144fb6659a25f5da5a035fd263b11cdf6247534007d2bbe5ea859d064201407c6392895474a74723787c289a1e92c3015208eaac22399881d19584e57a5453123a61d6e19138d7c7a0ee0df2fc0007a68da438350c537c14baa4e02f8ccb019a9f55021566395069b50486a46d04438c93d450b13fc8b01037e293b82f808115219b4293a0cf7593c35f42349e6e4a98363e4596a1b43d7ea2d559e9d249bb5003501b627268ae927dac1317dcea136dcc2383b690052a318555e79ab2cb5f03ad4668088c78ec26a621d7280cab8d1aeae5e4a801d597e4ca939e70bdd452d1fae44c21ac866687733dc4cb1b1c3bc8b383d429371c4864b8058fe07b86296e9e723a95d6dfb35f386f1f631b0ffa043602e5551c271c0265dee1ec94c2945c99adae5d424f927168637a43bafdd5c261680984ef05e68ae6d6d3f37d4b8b9b86a767c1087403f5c44637060e165483eb6bef6f61669c5f3956aeb34bda6d57f2edf5a90e67cbed918cebb1cf9904c6d5ab0ff6bc97c4d1672f2c4b5b3b0e643baef9bbf8a808f99f747a3626f4b638891124794789137f0e9d870e3e8121d7fb6c07db20e8987addcc3efeea12e7fdbdf23817c8ca751f6a78de898a42994c7ab93adce8a0d22cad5065e74d0341295ff43d9be8580cc6b76f795b8cfab1675750ab88a548eeeef8232c51bfd26d4451daae16c86223543a7ee34c40cbc66ace4fb4c8f4a09dbe4ae98a1d35c630dd90e46205739ccb63a18031a7dc1275fce60ad5a10de7b6e49e9039bd0e0c1964449225a5259b9b85ea3dbebccb7e74dd6f74bf0d6d4c2eff7e9d5222ed4aa4259ce078455fe2eab5c1ea28677b80cda4fe05f8952a1c9840012b3c4baec602bfb996508db25be2e0317ea4ead3fb986b82dbc8c48a13519357d1f94faccbc3658ef2e1a9558c6e72f5fcb17b1ee010ddf6d19dd4b31f1612f824359db61f33b0fbeaf439a6e63b237c4b04d4e773b552817e61166580a6d48cad883518f43bc0889eace04bce72b7d3f117a9724cd315cf6e71fd5fb9695f4a21cc216dd27db5530247c82b1d55c93c81395f589d146ff49540fd3845270d8e2089ee13610bc2b36604094dc717ff8389b9d0c3416900a8e193a25c616ec06a42f2973c6294524924a55ba1b3ff84441b8cae609deadace6842c6c997c698b6c2c6ea06f793f12ee3374c0af853abae8a8aae5e30e2cfa1a0118c94520f2e44c7368eeb54ebf2e8fedbe0ee1a63655e9ec722781f218521d2d43c1dfba1dbf845dfc0e8dbc545b97cdefc7eb75fa615222512bedf6a5f18b8320c472716f5b265a60dca2358c15d887e7f047acb55811bc3cdc0824e12db1ab5238a5467d0a8a9a1ca8d37086a719b89f8bba2db11a4562b6150222b494f91dfe1aac2a5fba0570c263514369cbb3ce511fc5acceb83183f989e84649a9c48574ec04ea43b112a2ed8c8962e3d5a0817fdf59659cd853bf6db6fab69b6962bdaf6c3a51a8925a36aeef80c2d37646e0e0bc61cf727c302ee80c6e99a5ba007319f1b14267e21995b3f4a379f32c0bb5810d27c69924de08930375a76a489a8c4e9681e790b0a344edec87f997f1ca0b5a1b8a4b72a913880ceac29e8ea6ffeb3ca59f97092803a67d63e5715e1cf8d1266f250caedabde42a05cd655525319295f8c802445e9e7b699f4506463ecec1f376849f9ce10afd3405169a851998907ed81bd0aa7b56eea613d7429b8b40113926ad48a2c19cad955f0b9ba358544768e062d0d42fb42dee26fe9baac0783b27e8229114e9cbf667dd1e80bd5aee0443998c086b7156e6a8d733d93c3e7cd60da16c4c6f75f1ce0bf3f04b779d55ba95f0d8864ea4500a01bbbf25a876699692bfb79eaf1d6af0989974e63c17dabe2903c4a1d1858bc902d67f0b9908c073594ada0a9969721c0cde054a3578ef7a4accb5363bc9b0912a4fc73784d0311a60b1c1eee8b2b834c48e6aa17fd705c5e817db805c7e0edba14ee26b11424e9cf02f3d237006bbd3153224b31c787ba420ed0c2f4b8bf04e1cc0b4d80dedb93b4426a36b36f71e2e0198887c2fe8f43ebbe6a8c07e69c2c865772d4568022365e14f7dd1583ac95feffa2a6cc5b908cf7d6668f66a85ba4b283d2f97ff5934a575dbbc16c4cb8a56917d0d468a0c2e7f2daf73d858d3bd9439a70b092e30a73f69af98f6f3172132d7e3708aa7d28336bdc79a4dc6be851ca1b1c2f7295582f77c3bd44c2cd216fce39c2f081086ceb3b034154e1881494ed0956742c3c0da5c35ed8ac21dec9a1f7e574c569630a5a09fe5a7a263a1fd92d19208494fd769cc63ee7ffb6b1530270dd1b0af25bd310ce255c62d9022acd372d67fd47519edb2684a6315b85cbd1c2593a85397e71f9f46c5a4dc64f56a1b67092ecd8eb19a4725ab0ae327ec095d7ba162f0abf8aba5ac46441eb0901ff8c14d5d5c66f37d2c6cc8ca06737cee42434c4350bfb42a978029ec6617de0911e7eb5044ab570b2f5e4f3e3d4dd2de08231b55c2947cbf20d5902eed249fae989bdb55b666d48bcc83b7486d92b3e6c3618a9a312180bef939e6cae21bbe3a5e9b4131d28924a981e2b37d23d821265f1c286b80978b2db531cf8d845832f0f47f05148d3141685aa449b7401f4a416666ac7bc3405c8155b33ffbcf2328658237b4cea35bdf5a253b03a28969f0be4f8c527952d49953404e06216e1a8173802afa50a70e48e0898c6d89480ebb8e20c0c31a625c902d2bdf5fae8cfbc3ee41dc981663896fba847de754449b443aad23cf1a6e87851841e31afc9894a5ba42a86d186182a79c764a75bc522142c594ccd5d985f60f7417338a3643b99e8789e702bd85370065595e1e210c599ec03fa62834139e518d2dd7cad79e0886fbc315ed1079598c6670759a08bcc26681c10cdc4f731323544d89a6dd652c1d563d8bdbff09e3d7a7be3bbc8ea7561d42a983bcc673a5dd3ab8dc9323e9aa60e66a8b0077cf013c84d56fae03c62267df02881d19da3ef61082fabb55a4a496991080efc076d5ce0112fd1840b10e9dd16efa3d2d923fcb74075003174b87cba9300d06213f55e430bbbf6a2517971988c493e877ccb077c96a83c8042a3bd796f54d61bbf732871a563fd6a78a964dada83a15818a522d25c9971a9488f664c1ac842f708fcf967b908dd24544a190697f1ef21b1c1c78760fa6e12431cd0ee09d041c7787f94987d46cd8489f1a16976a2811c4fc8e8e41917a5c0a56896f300aa1aa9a894d00f168758376b0577b85c9ed63d03322634f5027929a03f4ab04e17315c656a805b26b6032ad6f6d80d2e544d51c9ae571ccb1f24025c0b167e84196c366d5c27effacede0923c6b52ebfdccf4b5a2c22d341c2b620ff07207decc5dea8bb2226f3a5d7cb664c03b8317002ef978e434a94141ffcccaea3b23e40dd9f4b39496fa19506a0fe9355adcb06439c312f6bb8cdf245889e560c9ed80e1b039e1078e32b31844b1c44d02e2b4b557f02c941657116214e03cf38e5c1a027456e25a6979c75a55f5d9be67d237c604d3f9589064c80c9903d1a8f10ae558b9e9fdb5f58bf0dc29b08c059e79d47448b8bc445512f44b0cdc26f7df42539390c7bb57bef5a2a9621268d02709fe33633755aaefb5fbbfa61e95c681c27c8ee3b9e38b27da682041c13cefd073fb41dbc2ed13a21d234d81c5055f461b841b0b4558e3d4b77f9a2f6f9054a5e76e1e65e5552346827b157b30351fd068a354e9f3c6d536a01b14b392e2317b143fe9ac7101be248a23ccaf65099e35995daeafd40bbb633793d2347cd4c1dff0c969a7c43289dcffc268db7b38d2696ce9da22ac2844a34a5ae686b980f7adc2db019f24f4424639939b1ce72e96674947f2578fe0eee5631088c87c1f3f28bdbc6c2b07537966c85855223b981b852c607639f7d06cd67b775a23b3e41dbfeb2de2d6a5dae5f1097b92ee445a8334e240c8e6e2e086bf0845ae1ef476104021fdf18e9af489632ded918a3df0426782e1908d914d7ab831a823d56927939ecd1d516705f3d4c199ab07b58f78db5376a638ea7e27571f13fd991559ab79e1796a3b1d6827512a3c36745cd375f247f8e8f55f285925245b43e8905f8ec763f7648ae9bfb2eed029f7d16abe925d7ec819a5db7878355835f093ee9957877b5f2aec368ab288611a2e4bdcffa1054baf3f2aa58f6fb4232324bac894970eed01d85b7fdbeca5ac6d3c5d4b82b3863cd60464b9479acdc2c38d4d6900550630866f3a7a79766e4025979cf189dae73d792f17b7561a60ab78c31a5c04cc0ebe16703cc728bbe619d0035b27cd825234c06932abd85a23f4b3dd4fba269b696d97103f094c99fbc1b335e267a4c493f1963da99e65ff013a4a23d82aab6bcb4c72f25c5b49e188998328804ae616d84b3e4b2e40ec3c8b6c1060fbef250d9fc648a2d31d59a89c8b866f471dec581776274cd8a307d9d822c50a553aa8aeb04b78faa1a0d5916ca4dedd9cfafd68932d4470c4a8a92e95274d83356d2df017fe1c28c83bfae5c0a7eefdabd86bf2d17a53d19201e0cb8db890793bb7471509dceb65f92146983b22d1921854106d75047b4eec3a18566fe465854f597abf169579ed2ec02c1c1709611ca941243c0a960396b26b2bbec6b41502502ec86f52e86da5c1449ef76d63095c4b59cb5c51be75f29cdb5dae17c09462d5d72c3ee19a7be1b0a4cc9eef250797921175c2ad14287e718a30f9f0ecc6ade8ce1f4199c73712357bd1b4c109844ee908ca6f64f61a631367b30b38685ca223d0cc8e62086beaed2f3a2f8ec8e230b33b434afee01a8eb36fd287dec3cd1ec156545151b177bd966d860d81e468df9273fb2c2fc15452988520b1e48f2e9730d44cdeaf8dc39c50e011b8933f1ed63963022cc4112eb98cda77ba79a0f05602eb0a4e64e6d5e1d03129690bd58a399cdd7bd187196f7e39584bea6cda72946dbfa296a244772c149662ffecd3d9c22e932233b77e5f2e9f431d88fa6dcdf65573f0478fc5f2a0f7226936d4963a60dbf321a4141545867e44f44700b55240c0f3754910d4b2c41251654d8fd3e2864d78805f433b07cd3ee793396bafad0c8b7379163854d14652dfc99cf21df8bb2476be7245aec68acb809a94e74c0aa09038eabd78b75a3e19631a5b92f614956bc48a7327d62ba620c31520281f0674fce6354bd0a87b549b6d23b23dd1cb0713f172e06cea7c82950942653ad75410257d26ed4760d79cbe4f3ec0d32848188aee1a2a7794286155483012e541b07acc2f2ad70f961d8b29139dbe35d606ec6378477f740990473760f21410d6d8ba5c99ac65f823f38cc616ebc91087af80c27f33786a4c8d2ebd31e19a981564b50707606db21afd76650e1202993237c1be1a64377ddebfff74526b7ad52a49cf996acd9c0da112f0720b3933449e3048f486e71876516f2184d51ae9f7e60dc1780abbab4a4e6e6d5d34d0301033d0b2217ea49545721fc3c29d9c989fee846d923b7c30929b976d52700434e352596eb40b0cf10a60dced66a1c92583547696b72017568f3f9616e2963bbe9bc6f7415e49afb7047a48bc0e56081b58d21138360dc97c6a36b65f3cb9d602ff9fcc55af1e2712c037aca806b7e3312b4e255bd1b63e454cd9c96d18aaa65bb70c06d5bcf1b0893d9b054c75051cddeba0d27b18c481b9ad7983a270124840b981927869d779050d7674b01480fa8b51a8947937fe4c56d440c1734c254316a706ffbb74a5b6d8bc0d3302310a457ed59b445be4a027d04a151bacdf8a55f9c9ee3bb5543e636d6172021635d9371c37c399773db7994a770903c7a48e4cf1a80b2c0fd18c485cd42e03f7d8e69fbc9a3094eb6728c9383c186f0fb124d864a97fff122bfc733eed57688d1342cdfefc75f68a099db5f6465fe4634a71de6f9d79b3f58be0d57b94b03be2fad3d55ab650237c609adfe528bde1e5944d0c8d9b57873b61c21babc7788497806f9cb3d80d1f5633a9891eba39b725a877d6eb69ad10fa3d1a177f25b3cce0be63103a7d801f5ee53627a887062f429640c0d83ecc49e64cffebeae5d9b812a0c6e41332d9d8a348723ee4d449b05e3101a5955ab78165bd8847f775a9c39e12079835d915ce9917af944e6eccec29c4be59e49baa4f2c91388c63e181aae1dab571fe157eee6036a096ea6e04c88b8507d459b19323c290d15260e6da1de1ad7f8ae1c7eeaeac7968a43645c1faa6d05b3283142f5e6776507898bc2c33ba43ad984cb4e9902d95caf66073fc8303939f5a5722a2cccbded41f797f2d88bb4a8fb84c61e97f2edeb284fcf95eed1cb716f2b7cc2fcf556f8d07b302a1262c5091a1dd4fd7e684f200ad0960b7debb54deea6db47fb47ef03a3ab8e1b51925cf05097c19dbf1b0314b869140ee4f822e7b3ee41e5522388abc3209fe9728c1af1b95ecbbf3bea6ea01ab1a66473478a8b33875deed02d7c20e203b894458b26602ec737a63418c0dba8cbfc7c9c890536b6045c0c8a058b3776d15fc8c443888388cc24e79025bd29a3764b1a74e0f0783f79a271bdb60a94b06cb63d1e59b6e7699bf263238c68e42327642260a3dac96025d9cc7fa391e7944ae3b8bd800d394bd67b248c9077836647cf13c463caca157e32f547995f1006b00949a2f4ee6a3baa08e25c5b997717a33aea5de8d28d9e704b814a0c8c20417399d8b34dcd056de2700b16430ef9a5daf0a05b237236eba2653d16fa6bf433ba3ee2d2b7d69d5c6bf0eedaafa5547eb5a59e990fe381467d218a5879af09c6d34b4ab667ca266099769e49f2a422ab7859529cc1996d04787b64c22b35a065adf528f099fcdce598a1244b47ffa3d325ec9da16116a50b89d02d6285e435f22d6bf6d315ff7271eb2f4e6e88695df1c3ad485bf33c9d0163a60de5d9d9bdc381b7d37c38a5c28518b90f5061a639089af3e1c2a3b36fe55fed9a7e0e4aa6fcef244667afae001684626337372ef0bb34b7e0f6677a27fca4d78a04025822cf56872510b0f60928f2c133dfd0d5338c5c205a03c6b9a58c442a64b820c94a65e6e9d9590bbf36ed24f801f4366e7d88708e91b675b448b3bad6ec0cf4d947e1096db2eaec2faea375a88e88eb17eaaf078332c51ec8dbc3818213ef5aa0f681cb0ce594999c8b0cf4cf279b14efd4699813d99d1595c291a42250950c2e684319ff225c8feb9121edd5e7362e601b9bfe9758ca2aa95078ffa9e03e8983b353368707bf92d54fd6201d818cbf4269e74d2b7d8f56f24c0e20256ed5ae92721e2d0741952924204b26a744366bfbcc38632688285c86ec0b9903b628bb3c5ec0d08a509d2bd5161283797af0784f1a7e826b3966933cb38db0ce2d125a8e1c0d3c5c349cec572a0cf30fb5cd25e58c3c6a2e2ce451d203705a2b65475b2aadf569abaa93ccd37c68f2d20de83d3605e7e930f3b74f7779ceef59078020dd221fc5f1a90cd381e63385292d2473d9c3600e99d5446517cbdb69550cd5003a10647a02be417e62947734515b955f018b7d63d79e055f238c8a5d22f7783739f171af3d3eb0f621bd9eb9bbd6bde6ffb9b03c7dfc69e498bb5b7a4b5126c92f23d12f58dfe0896d6a0efc9fc8d8f62da2080830d58efcf01c82aca9f1f0f34f4adfdf53c5f4148ec31529f0245536c0c1f6fc056b7e7c97dff40bb3f4b05c0b8447ed952bbf344cd44be04350e5c9630d23296d6d5ed4ad9c18b19cbb5440f334f6ce416fff9db2cdc5133cc36934d942001e18602be7e19051a672110a797c403f5a32428dfbaea4fa81686380754200bbb98203b2d8b092bbbe7f83014130b3f8e4595e1a1479d3e6b596bcab21aae28ed1937c9482aee104f758a9ac07023a173e0d1b3f46964730a80f9a654effa86bd35b46775bd98cb8c1c44fd08f3771189f4ba221e4ff3bb353a209a3388fdf9315c7866373f94aca2b1d1cfdda697b680e3b3a5c466ecdfdcd28a48c012ce0f814843dc1bcb473b24dabcc17fbe2144e0661e4cfbb2267ccf7ed3aabddad2ee528cacacf7e31dec9fefa46f554298fcc872860bd634038a93062f851c0fe2693735c12adf548dc7037c03a6025c0ae6bf705dbc1fe9e3ea2481def16d97d3229ebb678a95c8995e4958716e6a4558883ffe20767d041130d4ae5b779b15ec3d61cf7441169e3c392da83fd00fa635151caffb6b97545661afbbd1060b33a0b21a8761d81a644369598e4267bf879201333c1e2e833ab3776f65ee73386a82934f9d356619018888d2a4da4826b4c00303557b82cd3f8dbdfeba523777e5640c0d186219227409f02e081fc0f2857ea3adf48a4e6fc98438fb4b653493d0315660512ae1e3e3eb7d32d30c0617da138ec25fc1734765d0e7f260e8b941754e36ef66c54c2c380ae2b4af06912b9c768edf319a280f7234eb1371d188759002a9bd1e44ff83203960c29063d0ca42f0929853392c4108f4823123062b1d486edfc50ac6863d05cd6f5ca74f54529cee823793d7ab1d9351529338bdeaba69eef01797aa8d4f7e70154a168fc56e010230375abecda6b61624488bc449c688e073c09b0744f79e4f1a32a00a826ab1178349c8b7ed73da0f6dddd769ef8f12e057584f0f51f405dea4e88e36f141cc2de38ad5dedb81d0e7cb44b011ce40ec19a43ae0f958a14dd500f5866216f2969a845defb0a08fbd88c4c60260f8d28632fefa7218c00b7df6c0cb8c23b4633f210e2c4349efbb78f5ff2f4e1071a403f52d2ad76d65f85acc69919af5cffb3fccc68e38d75d0014ec971bd419d13330a6ae7c0245425ca139cc19b2972721ab216eee48f2b4263007bbdea1c9da9ad7984d0ee0bce851bfe410a42f82d9328ba8ca9a354f0037e5fc650d4b8d654b79ddd9d638cd7d0ed44b9eb25961c73fa44b1f9e4de0dbb8fd19b9d45931bb8bd03111651f7cf68c7a4281082e1852c4f0ee9d122956fd70a22a784f21939224beb999d90311da4ecf2a65727ed30d3fab34dafd50d683703c4c219d8531ec38d1400aa5ac1d3cde69267177a044a04acada831e35bde31ae33b650df0c95ea2d8d8cdd90fdb94d4943419486e086c867c06ae9f9c2eb2fba5cfb243c1ed27b6d5d3e9dfa84f8af83c9c12668ffc91e10ad58ec1a223689ebc8e706e248a07ace6444ec0e3083c95b6708ad1a4c3a4e0b8ee74fe7200fd02a523ddc4534ff3f82ea93b55983db565bfe726604d0f5ded0f83656dc2a185a1dda872f5d244cd59b009107ca3dc94b08ad457a2edf40ce28018919e58d96e9d2dd24dfd84f381e01e12833c4d520de72dcc090fc31475ea918d59dde57c339b0c44634338da72f906f94ef7d756e99e3959992cfef6ed2274df43910631862877a2f8e14909d029d3a81ff6590ac28f8c07818e546d50e0b7b7662ab722a6040ecb979f21c619a4e4ff83fe5df8d949cf19258ffe9d79c23ecf1e3342071f87dc0a08e00a7582897e9f1efeec7e32547be034f6f37f66a25ccd433c06d61853c0ef0eb5a5e00bfdc32764c698fb80c3bcf63de5eecca585a6ede027dd3f8c1cf6451433fd4df2bd9af6ae1deec331dcfbbd2d6ac1243923b005b66af6ce32f010fc24249289f55dfe3bb01d6979f6efb7ed50ac782df1df806e02c7e74866e855d518bfbf06d105b964633a726b96f67d2dbbe639bfc470ee6c653ebf1ef76a7d52992edc73aecae190337a15741f86f5a8e9ed3ca6a31d153ccebba8d84727cf0db34dc043244b4c9c8426e8443a5e2637c07782412907533e000024610ab6bef2f742d40ea4cc64a396f80aac124eb34df216abc7e0a5245badad13d7cec332a2d9253ff259dd1c2c5eb294202e3e5faa98430bc35e4d6d4da13660caf8f76f436024e7ffa0b738e51c1c1a01f37d19a484481d7f2793517584301965f1ab3382e1bb9527711ea47ca094e2139043d4861ee0fedd0b7473010c97dbf08487fa66a17c7c1f00a57420ba5e6ac7f4f16d04b097b941ae8620badaaee53134e391ff0b8382f14f11c5fef352c8aa679d9f58c920e8ff606a3e422cf0e34045b8f4ac1241c5158ffeb02a3c0d24ff4c86fba29f789508db2e17df66485c3f3e4d75f99c4f1b65130213a2fb2bef642b74cc7797e9e6d5933dd5645aede8cad6a6b93a4734f6d8def7651c419563d0db2c12942897b940d56481e1289803be184595e516761fae24560bdbe6f337392dc43944d5038ba1beadcd9de978a8ecbb8d0910ab3f5c2225199924ef9f15f272ee5749834099fd5f1450f9c705680c93f5f19da00996fadba39907c57d9541c68bd5f0332d7ff88be431304ce14385b417ac2fb19755bbd9ca827a4d1bfd00488013c2519b7f52b842b08c33206feff0d89d1541a523126bfecf6b6ccc5b6774451c46b0041ce8be2a5301f990d26a3f26de655c3f6e0ddc5dc525c7d3b876ac170e58ad2eef619069e12c5c5a253663ae2584281ee4118b420d374229c1a31faee3ded911e300ddb066015f0f42e3bcf082b163b2aa121bf8f0a61253cbdf3664d718f3e8dadb972924af25958d974f15c47b813eacf5e2b72879e8efd7086a6d32a35fabfaa48a32751c2d4d538361f5029687f4e200d6683496a772bb6a5dd659286bee49e250f2c72c3fe737b2f34618ef1dc4b22c2c87d79b4bb988cdd12c18ade514e0fdb092214222456643303bae82e66b169faa3f3610371e2d34779395694e26640d75016cb19fbafd8b4b9fbce80a1b023f7f43e8e4f823843d7f2c31f02e57fd4c9e5c8269f8081b6f729a04b0481e45c84a2bd03a890ca6567ac002a3392ba028d69a89cd6c38b19a0bf0e4fe0649ea7bedf960deaa4abc4b53deaa9bfc487e3b33306f36243877f7aedc7149843de4926577643021ba0f5fa6c44b4253175630bef8ef55197e344f61d8612bc11263466e0bd6dea556f4ad70ee64dbff9f3942b2dfd3890ce8f1c262addf4484f462c7c85ab0a9c85193e6b50dbdfd520e2f8003fdcf9d720c43a7410d6288b5daa05b07db50b59de06cb785ce3c0a3a615659abebdbafc9b3d16419d27b1194d59fd581239e0a6632f15969d96eb0869d6b961918179f9d255cadb0dfb7189a2f4ddc2eb0336fca7959591b696fc268cbf9ced8dbbfa3c23ed56510ec3cbbc0ed0445626568fc7fb2b5335aa4cd9db796b298587905bd55cdda4ae51df77d5a92573ce6d5d7f37cdf5694f666d9a13d05251517c33e5962b566e3dd5c697cf389f64f83d2a6db962f55cbbfb017fc98d1ad39df741f1f39bcd6f9c0a8759b5c86f863471fe3c84f8f6fb6c2a86e805dbefebc94109d1392dd745530fb54d6a35934555aedab55f1e2d42144a2da91b36ffdf15bfc54b31921bad7ed4d462aa822a014ce16ddba5202bde84301654845467819b93c7bbc7dbe40d715990bf962d393a422f36f5e519de02e1f3a4aa4ae7e509d36a13b56899dabfdfdbef2e84178f68a1a54240adc7b484f6f22604cebebf011a2ed7cf527a7619fbde8bbf5a8353b3cef1c4848964e0bc3d4212b00e6a3aa3feb0cf98fe3e989e6f5c76b090a68880ca168707e800b91d1cc0e56960e00648de3e5e53b58239937ae061162ad6a354586371b8ec7f6a26baa48f1b222897dc2a7230b4489c6f9dfba5400790089ba9b4f172762d16fc4c974b980cd807eabe6e4c71e77f57c3cc37e0df5a58e066ceda767e7dcb9be3c206f93e6c583f7f1dc1eeb215863015c9d30a93dee81f9933fe31e62c51e233716b163493917b8e0557d25959b2d8b3cec919f2056840a2cfd4ce170be39faa0dfd486d852e15b73c62156f9fe9230bb24a8931be3a7d25ce4d094da8ac282f205779154d7b7dcce3e827b7d69831c427401c9638e08dc11f227dfd404312ed81565982c9ed21ff6b9385f1c6a75c7df4227a6fe54406cd6c3df4dac419968a56548efb265e1eec60fe360e76f3319a1b48bb7711b222641675f4db95c0a4ca34e4b4d08891e0eb4a7302c3a3382fd3c7ae080145a3195040995bb6b6e526361f14615148851ed7f14e1e05f1cc038e9d480df20c37c9b287992f154d96462b3e0b0476537beeab13f8478df56484def78f3aa62fc5a623382ffb6bd1f53eef3ae33bc7223bf5cf3862269c74748b1bc94d52e673872a7083769b503f240a903970d2139447599651836aabb006c94686a33b1117e9709e96427f01fd8b9d3a20c7a32d2543ac29c49ac15e9c585e0ce09f3a85e690131555475a0c396516215f0b566110425226743fccb769f7b5522782ad427173354447330ca56e09cbe7bd94bb2009d20ac6e4ac73064c30160f0ac2dcf0a9babd60eacd2126b1402c45f503b478e5c76ae8fd15057d2476f0ba0c9a2ec43a74f0125471b96fc816e4e2310b12a041e937e6193f918fae578b5b7995e38aafd2e9dc4fd7a6655855535585bc89aa213e9fb4ed75f066689fbaeaacc71d40245dc3ae4e62aebbcb2667eec200c2add2b169c38518f9b55c851bf819adf990ba85474dd3b344cd38929bfe63eac6c08dcc7ff2f5f733ec22b815a127872b0b013326dd11583b2f5d3342ef9ad9556aa7347cea10271254b7aba9e1b5816929c12cd97c50ab99166050ee073943cb197c7e3b734ab1668f3aaa8fbf21f87fb06462ee14c48634a44019a0ce946cc896b3e264493afdc315ba2a858f12f323fe4a9f734dc5a792be7c56177fdb0f2742e1caebb1ad56c7d50a1fbe583a5e1c2de7c1b0f6b64c14427e470861d21c8dd90fc41870a97935d67b46038945d1f76bac4f5983ca71714f0737862a9747ba2c63532a4492fab989c0c4b775620c6831bc9ca240f16004227c9b299a9f138ef8d938991a981455d50f30101d3d1c25c25b7433656bb838d02afb7bacf4f3980c243f9e51c75e0fede5033ec5b68a1a4378760b5b7cf17137a886d9ec7c4a44bf2bc35788b8e408140640e4299cf226c217360af6b2e18076a7c6891eda5ebf6af1e8567a49dd26a535df2a3e7aa7919c165dfb05fa8f6fa50cebe543d15ed0f0ffeee2be68eb9f5b2298cb755789d8e3a81733be773caa673fbb2efaddebb996e7b8ca797d8cd0d06fd707b598616763e8975cd799cea79aec00b7c6b01e102a0b515186f67248ba30522fe4cfba01b686d296736ffbfc788f80991179c244f120b4b3c4cdf286c6cba7efa201d99fa64f592cb7b7d446948ba3ddc64186a81ffb0cbb9d7597f990ec8b9d4a7206da4ed5e8496763022e33b9ecc3318d2b4c834b1775b58b02ca49ed9ce53c3e0853fb7226f95ac2b8af6dfa1642499999b0ad6e72af18b8e2cf578cb59f264eff19f6fbd494fcc940422c430669b85b1a67b21e597063c54fcf28d4578cf4324e2fb6f8736e27fd027162c70138d825c201f9b797c518bb5661c6e5b5160f4094db3f6b5faada27992dd13285290d7f40dbe6afb6c0d3b4cab077c1cf4790e0a8087e90c4c16dd3cdb7a56dbbc2a8f7eb9ca6bfa0c04168a87c3d08763e1612a6672fc1a4e2e6e7a4f57c8b265fa20e999c7733524a1cf1772882ec65b531dc7f77ba3710a0424ad1fab2bb10552e2ce14f41c4f2a425eab54acd64aa7af82a340585344aa5ace5474052179d1b352bc4763b4eada35386890ee988f30759f7803b01e72f5ba95695d2fda338ea78a0e4c0407d8e6cd435bb2316e7e6a94f5e671d66191dba1afba32193a261e780327b5d29b5c25f8df0c56a48b7590210e5a062b1e1c6141faf6a092485c4fcd3f13bfab811d8ed5a20d6aa6429632cd5350426f839796ad24e3bbba59aa05c738b8dadbdf007969deabefcfb17ffd56fb4afee20d53bdac1d835bd3f580ced33b808bc8bfc4e816fb85297782011156b3583c4010974cea352ebf0da16947d6cbf91e12c73b7e9938a231939ca4a664d58fbb8c45c36cef122127a700550206fdc2a87882b3e66a5238356c7e3bed233f00aa2a68b29c03c71e7ec46e07659b0b0b831546184e309c84968bdccfcc5373428bd1d3024930d074a082917fc957f675c47d4cd8740bb8939ac0d0105e5c10c0ad5e3d3afad4a3b92711adda1344bee0617a613467ec5c3b8ebf5e6fbf9d452c11a42b89bcd037f59301d092cb961a7b02ad9eea13921bd45c15ece0e7d2cc163af7fa5e34ad76179385d33e5eda03ab8f1b1c39a730c0d338278c2db563535dbccad364e30d94eff9a2829e6f77e55d282fae3b00b6624c0684e7710a49ecbac955c744e2e07f7e6e8241a8c7ed0e3051dac0bc2fe3a118210560d60f1d512a78cd03241226358767d7335f380ff5b241ec45e385c7fab8238d1c0008d0f3564c111ee416235c04c28bab11d2771360128c6caf3d4bafeeb24e77b8a5135d0516597f1f4c023eff831811d45f5d7f7530c334affb0f0d33de3a8f63963b14b42af830ac1086389ce0ef5f4e5f962b2392cdb0d6e8245ddd24b35fe981f7c2b9d999fbe6730779248f450c6fceea86c71519ecea9017152c9063b0f5f77a64c4817317608392b9baf8415e279fba3e5c22f1f6fa49a88e02f3db76191a263f000565d679779ef74053b833f00d7a792345135d89a5167c55af7e6c285a9eef922e7da60d8ef3b2c61212bba485db0dfb2e36e39c22aa7d2980a7f53f2eef5e118defcd631ea3f87e48995ab8c7f1e71458acdbfae77bfd0c8d63df01907177653135f9bba1553250a13ebd76f8344640bdfcadfd7fd574dcdcf133d902f3698f43d62a7ab3e9798dfdff6343100cfa49f69b9947ed942f8f5f262e9550c727e8f894a997d793c281056b92c881b23be338081ae1c3c110d4618e43d28693afa1b75328a8d5770f5479145aa83e330b6b694f9a0f4a6ec4cd599db998cb862bbfc294076b2a5627f3fe6b5af94363c141426425146ce58ed31cbb9a344acd3c5c856edaa89b199f0bb312f65cb18947016d07aee82018e84e9c7f6aa1f774ba27972c47bc0d412975803d57793e842e790be2bd8b1e2e12ff947dcaedd862d88d20c87dcce78fe697c6bb4cadfccf54a553daca12ca92b3d5a518b1b37b0d69769f10cc54b8a7da5ea9944614ce77a78f2e15f9db6438d23ed31342bc8ea0819052b635562b22df3eec693dfb4dc7d162624ed4437bfe262ad50b1e5108f3bd0752e8641d95665baba5b10877e4de26fa1bd27586c3885a8ace2b300dd435e7fcb755a80b3fc7cc2fcb7b96ad699936f9320b4788ff48ce52bb79240dc1130a1017211861d0412d8163487b11b91df6c3c45312c2df0b9642fb7f76b160cea0b36e96c4d929dc5490d3463349477bd516257052715dbc92b3c8008a902e4738abbfad9b2d54a694266df06d49f5fb87ade96bc1b3722eade82768709218e75390d0391f5a3f0f129ee5ac59b018b0b31e9dd98b11c66dd9ee9a8dd54308662b25711e58cd814a6973732f7c22c9656b43b8426ae8c0918521ed3b3730398d2e2b1535c9ac9c3f7341d0144d03053b730530a5761a4c195ea5f83ae2b7f14c2ab57ec29c0cb2c077f32756a406dc07a7e5c4b687bc73fea195c7075d3d8c0dd7c0aab0b0c41f192382667f37bd577400ecdd91b3ee87e0ed6ab4a0d57f4005e62e857df0aa68371c84a0208b5b9bdc879729b32f7451c90e0bdc6aff4f4a83a438a6ef634c9bc1d1d609f39380611c554757248d9938c21bf09433a50de72e8f7d6bb536a72b44cc23a59e39979517f5a3cbb968dca0afba04572629e4da7cdc1e6609b00f6d0de6f395d97e041576e8c89ef85938ab7ca4388381f5a2aad7bca4cde2a5020133f56dcca9300371987cd71a6ea6d0848bf04e77f5afa6e093dae2b49eea6476347e0452a4d114e726e21a096325132c1bc42435f240ce8efa85b3246b055d7e33ca131ab4b56069e5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
