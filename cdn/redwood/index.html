<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cabde00822992ef7cd96f1e06d012c89a08265823840e14778c8d2293309934718c99b93bd219079751f73e1340c5c381132db6557e6e6c07aee07261909220c1b1c0420546b0687f013ef7ca6eae095bf62909871344aeddc7075ad9f71891f01fa39f603f12b5199d30757317087928ac779a74091e3764f40c87b9454b3b5694886c603286a9015a67d32ffa476e5becde2c07899ef363ab1572f2174f18a82ffe42e4ca3f58983363095ba6764d0c26bd541f89da4dde799d40ae96bf0b28cb167a3b0150cb78520179637846d45519c8b9de549499af1763c34a8b6107b26ebb513e997ec16a24464ebbdbde304a8ba4b108e875e22f93801b172c9d4b3e8627972b9956b1291fdac487e2135099e1f68b6935323e5baba5315eec3b6d95d27b556c0bfcdab1bd9b84e01dcb30607ff1ae2be3446ea3b73c57eeecf06ed82ebd47532060fd7b99d404360b3a657c0f6c8c6683af9fe829072f8edeacb586e52effacad64da1507199301d2d707f6e19086359f0ec3ad33bedcb3a09c14a4418e1e20dad72c3bf1899bcf8bcdec86d52213c1271e5472d0df236ec164c3cbd36006d7f4303cb3dab4956e5ed72c4d1dde621dc4a306a29f159c0600e1a916112b3dc92dc9ad3c866878200a425f6ec2a2f42fb6ecd0906f5d72e9e1a52bc5a677745e4c52a5e9f9131b2ced1305348084bcc0165915a8941a7b310f97b8010bbc55a3f7d5e2301c9bf3925d53c8cf95451017a231a7efba53759503136c39ea2e4385441618f11b5d924036576f3ea50d11689bc2b8ebea16a47a8e92323db22567107d5c83c1dce10ca5eb44ba6c90c76ab9894306c9f60f9b89d59a9327accbfe2304348f2b5f609bf1ae51252c34258f71161527f29ea929c8d5528d066bbb7947496497f5ee8784dcd30b39ee67742cbb8fd15f65c44aa724721a71e01ad530a3026103cf29b6ed8f082732b0ad52890c211bd081f1d90f23a198249d8fe4d354318e1fa72e2f2888054bacd88ae460aebd6ababf28f59a2453bdbf7b7128c018322214d24f0fb60c5bf74328e335646c4dd1cdb3db460a6f3b9a66fbba3f06153aa8bcc1334e6f4fa054b89796a57c664a2e55c723f52a56c5bffde08044d3ff3fc2a70583ac561a44061d65e43c6372ef37924295569e547e7a8fa7e2765afad9b69d8f278ebcdb016926f9c4973ba903d90a1bbbeae86a7ecf8c5820b47a8684a456e6083974db2bd082c9031a31941ad6603482604f6787e6c5a6dfe544bac6bfdedd593be19368d48a2ea31ae92a54c77b0aa40c218ed3ffcddb2bfc80196258d8b6ac8c71ead6a562dba99f693576341a99defc94abf1695645111a13b1750f2ef94f00d48daff9b9f8d1cf250045ac8071ea16aaf1267e41623bb164d57818e556cc242c3a1fca53969109761693d3ffbe5e3efcd602e4c587cc9c2e87774aeca96977f3f4bbe5ca1f520c2bfd36f39c1913a532d66a3edd45535f1d5bd1abce848b7f030fff26845e67cee472052141ad5cbf5e761c192471f05d9d4375906a5ec8fac7a6eb477c552ed567a8259ce6d2cda2b6fcf649200b6da1f2dced350a3934032e620970d5f554c214c95543d1a8568dcb2336df41c69dffae1a553c0993886a34c893ec3a3221d1b19dd73028854e50e955640dc7c4781be688df3b2074dc0db8d4a0ea3db20f3f596ddfceddff9a88c113cbc810b327a809ff190b0c5a4fd9b3155961f4f0d0042f3720de582346d9f6ba185830eafbff77716da4fde0201ec6036aa538b77e174594e9623169863b75929e05d9fc0f3a65a931f2d8a4166d9ede9c19e2c123f29a97dc5db732ac7157e7be50231bd45fbe020ae2b33b7513b13b474d60340d2a5360b3ba146122c1d7d40c5f8e0c2513c91fb08ea50e9a0eba563251ad04fbf3bb0eca35cb2457a99a860c769896b1010f9c39702fe004a56ae3fcb0e4a1f94485f563d7a6e8d17259a95dc16dcb47887d2575783c9227e451aaf4d4853f7c8cf7a9609592480d07df1bea6869ce8c9c4a03851d313599c6cba3bdcae9bfd56eb41257db7e2c97f5e4410787b7328051161514c5de346c444edb10ef39fb82ff9642fded6ad6b686de2be42e3fc1865614be623193eaf5350593ae8e32fe6b88ac33901e0a9fc0640bddef2098676ff1b9436d22f3e6b3c02ef375b2547d15173e3992f36ab85877c3cba5558516bee493803e5dbff95f5103582fc6896f0d9c07486271bcfc26f52d287eab13d39d1991ffb0ef45d8823653bbb2e8497d01e1532f98babe0c0f6bdd9ecc8ae25adc9fc657f276122bab38003962c308f356b5837be48e29787e6f8b521765774d612a8ccb9de4be445cfb8145ba547a869fdc9168b276f478cd0cfdf63280a7a35612cd874c2b4a10bd6be2f344fd58ece7bc89594d59e9e83f0eb042c582508fd09ea6ef7b958c930af3c0191d586d6027c2be496e8234c31d76333b91a3edff8cd4847abcadd637191c832726903c9751e6d5c32c964b6bde48036512a47dd1b57303df920f6162e3783a6935b2a3e43d4b1d00718c53774ba9f08a9552424f296edba0b3b75d545cc2863f3a2bfa25e15deb4fb4575c8b46f5cc93071f3c9fbd6daf20fe010c2864b8f8ee676f2c3d947da51e6466912438ff7e5b24588c39c3e4679dded14c7542d5b2280bf9689e144208165d7bf467d18920a79a8c5afdf5117f128d2f3d136850c8404aa98de2861840f078e36e27a8dd88e4fd4936985d13c179d05a7f323a70d5e9138445761ede7b60e35e170558ea8b5e72e33de0e6930228e47d98d0e7e01871b8aa51ba78560f85e136ce24a7dae777811133d4441dd7046558b065ba6a19febd52f9cb8a63b11f7c55528e5646dd268ad67bca5097a998cbf0eb6778705a003a8b38e5f535de9562c31af1abcb5174a2101b61803a134427c93f144bc76f0663237db0824c9ab17b9acb37456b357ade20df21353362b9d1e56fa83a8f4e1f7fae7a67e68dd799847d8b26d221a142b9ff41fd91510f943eb8f27630846dafd5f63762a00c78381573eb6cfc3c6e0a1e588296e0f7d216b2789978423d37e09f115999893a53af29976194a7985737e8d651f8a712a0ce378cc97b20b4715372e145e46c256a2152919df2de9b8732381a9d16f5b3b98d4825325fc3940c128fe5bd9eff07ccf9106a7ec93c2f6426d9f0672b8844f7345d9d46941f8a95b3e3198f509d40f7ec0053afff256ebbb5175dd00c71ebf7e02e5d269926fc266b1030aa65b4920c28f17d8d8fe53ff9bbbdd97e9730149089df324ce95aaf8434cf521aac0cc36217a045642bd0cf174fe658fdf5e8359d2bdf351ba1f77fc11a0a397e562cf45c22edc7d8586bbdb480a6fbac0c8635fc20e5202d0689b908e510d35b97523fb8d3502c7b7d4fc202d87ec89a34de3cd20228cc9e9fd4aeae27c106e32f64b429326a2a29b76bfc95026ed0a05a3f8c75fd6257a049aa07e9ef7a7fef0fb0aa5bce308895c19d48cda38f9cd4ed630f3849db32d1871c75e15d497113a059a51da7b20ea69c06ec2182c5dde6f66084819504e3b49dc5f2bffc72aea781dc7ae5344ae03427654b886850b13ddf0df00af8836fd1e64dfc160d27596d684b8c2d971a426dfe1c121eed5a226c0c4ae7bbbae2f0e09655e478d35bfdcfe2dc5bb6bebdba3974c5eaf5b0fe14e7c85eb5eb528ac79d7cdd5facd24273a93f05b0fac575b38ed4da125b4bf40ca8fff33f20e38c0e8e3d294cdfe097b384ab6b3d5aed131f6ab872760a3ca1ca644975c40c53cee331438bc0ed71cd7956acbdbee0878f91a39a62adfe4878f15295a8d2a946a533ff74facc06afad3e97bf041522b700744d3fec50aab36fe315b9cdc8725c81bdfe2905a11c8a235bdcd9e4a34046c95349c5e0db8582dcf977efae6201aba55ce97799cc80194cf9496130cdefa49fefa4da18a96c28918f5b24766f8369a44f8e06fabd5c6127a494903844d3125c8196ea8deac4702d2e262562fc84b2e62b7f100d733cde3ee4c8df54d1c9884e3f7b60c1c15212e77d8d129dcb6c30cdd30e3509d8154b09d902f31a1bbf80a42bb99f3c21c6947946e665209c504b6372b3939b3f6e5d14265735eced5da8e13a07cfca8cc3101a4fcfa828c19dcb4a6abdef7a3ea09ec54988e300fd784ab50547eec01c64b02ad9cf7d734a8612f480f472825f9ab9523bd2f343554cdb1f2f0825be323f0c5bc0a0d95a47fe9bceda39dc06da2b7ee2d735e15ca6f2e5e89fa340ed312c05ae49e7e7cfbfe5afb52abb833f653186171e6d17cb8e33ac0063c7824072ea4c988d147527b66d056d53995f553b2f85e12f475ea20a74ebe91a8c096ddced8e1b475aff2231e6b244521a73e2128d6b217bfef6ba7d305a32118f69036b04b3716fa8ccf02ec45aa94118fd9c3a02ed3db680a3b597903c1f46c013215f85c4eb0034ba1c28b64314c15343617765b2a7b4fd2e63f62402fc765ff983868cc491843438f760c594f08438c5375050110a62c3ff74e831cc3d4639669be27482a8679ce77db768116789f048742f6c6fa475322f665a74a55d59fb4e8309dd9630349efd952826799e956fc0f9aa683592fc9aa7595d33ae2e1c9c7e69f967bcba4c6dfc1071cf439023b0bb5548cff1f11a53cef64d49f52b7496af324a907aa2a0fc0b69ddcc3e8b520a47466409f9c19b1eeb8ebf0280ae8cbf09090e553d5c97b259008334b2de993c0af8add043761ba59c4128bf283f8603498e24adce4798da5c77bf599a57b8c5298de1a5c5cbb85af79ba4a55ac09f647796012cc8132527ba3a69a7a299899b7e86607e00d77a21e002804186d05ae174bb9fa33249fd3d3193e592399a65cbf9a1e3af7c0ba5563da25226adb0bbd28dd553fa42a8352f0792cf417a083875d6feaf19a6c1c8f30d33973657cb17ce9562e6504a39d6f5de85056efa3771dc2044ecbca6d5e010986c4648cc237229f98b296ace53cec06b15a7018b6e74615233d057c0017507c63e2826a52e9a6a814fc1986592f3f6b95f72f28cc344bc75286e94c8d2ea9eeb875cc83e06369c25dfb527ab785c58f9e396a65c8f79c4ef28149291e5a5fb01fc4629b449c7bbf4a421f8c7e5bea497a0a9673b247be5828d7e516f6adbeb09e0381b244f4eeb58818149512f0e0841b22dec1aa72a4185c1767ad1deb5c4e19ad35ba48540d0954981f6267b84e3fde26e39c326bdc603650791a17d1ad4d77ea0fc99b505476156e655b6c098e0b32440d4056914599a5852ddbb88409b8773c3ac10b7237a28758919145ce4b370471af19ffc9c640ed5b7beb9dd744945dbd27478a829de2cbdc54d44c05b1153dda955744015da971a41f212a2fc0ab3f44aba211793bc748bec84b6aa8c56e3d80b60d5db2e28f6e7694d5ab9c003036bfd50c3d499468c67d95ca8b6bdb72f2c47ac971bc0bdd415441a58bd34d285b5573a1c67c01a6f932f1a7ad569507b338fb143281542c8a58a4039729003e08d907042b13c1e9f44669b7ed8dc3951adbad333027258e868558d8fc6bbb745ce229d1a6d4ec18269973069e53285d4138e91efc75958f600da5c3f48b3a924e033de3e99bcf4d2e5a8e800f97af3fa44c3ca38f5a0c5e7b9a34f98e950e6bc8f6fa1c1fc052e47ad5dd00814b1a8350b052ebe03e18ea3978a731877ba4c4181f9c5a3946a0a9d307e9f74048323cb13a15fdad0beb388d1ce54c6640692c0bd249335d04f5ec5ee16e36a3c3fc09431c12899174fd59dc1a8e1ae36a6e6daa42c4c5604d90eb2855daf1c55c91ac7924e4eef32b37afedbc470f9f6f3fe777924b1959b328a751fd0ebf11710320435bea6b6f7769658725d09e28f5bc4b149f5ca1f834e5b41c6cc21329128f1563d01df49cea18903f46d5d09b0985503235d1e9bd5199845ce1eb0c7280841ad6bb60b4f8f3176a618f03a54094f66292657806f1b9ed83a9b0e4d60fc33d0b2c6ed47bd4e3094ca64a40cd36b5348f0a43661480ca8efde2b6038a5940bebb91034290730d571cf53523ebd8a1bdcd6a8f80dd7e9031e9be3e8cf0818964a698502d6fd1c409b495890fa812b9b591868262f9ba64f714c40f52e25b0351c7480dd4822b37dca6272252fb05ba81b33e22d5a4c13075f4512882bd6f5ee653a72e3fa82d40fb97d1d5417a08cb3abcd7159d60aa5168134aab89c779d3245bcbf86b562c4784479e9939c6e08c7ddf49114e58db0fe84e51043de1db1fb4c6abe257cee5c2751963c226cb02e51aef173a725bdabe13c07551e55d9b8bc1e156ebf2e39553a6c274fef235b7b0309ba6bf591f5ced2a114733fbfe8b6526fe93c0843f2c5ce449d6e7585108dca0454ce3fcbd81a80295f093afcf9d002a918cca412226ad95934b0abf2c53dcfa17d332e4d9d6be670c40f7c98492f887cf466d2f59082351622b61ca3bfb269177f15b5a635611d314cb749adfe23b70d7a28b8897180e6a13c77d055c21028c373abcc27652c9236e3c65ad82d86f6f29213eaee1140630faa6e26f646c996c257f39839620017a51698d2ba6a9be8f52794380d2e3a558344737b2ba08414990f78676113a6bc502487b71643af9a9a4b9fdaf14123853928d43f57ada644d4ffeb2592b03a292928107528fdfb86f950ed5d505e078fdfb96110dd8047bf7632a534601c1da962218f5060f7c609ad099ca86ae25ed9e1031e4f2e89b7cfc855802b5a4d0b41fecc379833c1b31bcf7f7f5a1952a878db82b872525ada8c1edf58bfeb932d3c00162c8d13b7e770919bc4fd28f6e7d7fe435979cacf1d38d2e84aef076bbd80eb15546ccc9a80a63b95c389a5770fa3a97c270c284161fbbda8086c3c502f5586e2ebc2b7a761b7057c2bb4ca08634edbfeac02921471c7440e9486640f2c3ebb530f9f1a63db82fda641fd02fee8a0b1dd8a8a3d143289ac6d90098269007505b8000a35ea795ae0cd57097fd01a3d1df2eaf2d1cb86bf9ef76fd4449ba3f34dae319986ac1b3600d6e8aac6a6b54b057a4e1e33a14f175ab4582889bf053898eef31215a67245112f12df252882467bd530c7fe930a4ee5181df55261e07981d7d00cb40a0928cf4996bb66a63c02ed4c2a1151107629c5c68bb8ecee5925f3bf1d5dfd81e1915ab5ac24f97d36d27e871fa46932035690d60305f2f268534f3200eff88a24ca8519c87f264295973a01c13c686c92d0ded108cf8af025d84b1a6f1d4c7571b6ab5126a02dd6745f6ce61d59519bdc933ec0019ca6df2e592c4ca7cb7bd0f5724b197e5ed3ba77e2c06c6e887fce8cf628cc11fdfa0832da1417f9106c19d5f1596467c5d70044231d2e92325a406966828e611869c12358e99683fc238783ef485ea87413a04152c9a2d28eb3b8aa2624221c88bdfee96138a39ea45b005594928472190b582d166e59dc94b3024d566dd332c83d9d268d5700e87bc6c7afb04a8f7b838066382ef96500e9c015d7e71e523063a3b21b1b3bddaef9377fd2f35798fa5465f8b59e72ba70d9bd2fd855d55c5230e5527f7f442b5216ebfddba27674cd3f22752ada801f17d0f060450daea4035c7baecd87bd2e06b8ac2b92b1153f087640806033c218c79d1ac21ca9a2a88b42b8623a19c41d9a8fd2b1d9c4483d5ca76362f17d399c064866c192f0506fb8496752198f04c929d259e76cb96606b3b5187b89754a35974e62b1a9af6d6562d6f695729fd195f94672fcf27c9b5fb6420660472c590c60f21c2b913e6c1c2779c6141b39efa5f5e8ab8a8fc595904f44e5eed8996b15d5189a8123fb9b4c554ab74553e1eed8c90479b1ab4ee52d47c0e210b209f345dbcb99275547bf04758cded6bc2f9a1be87bbd0b64eceb6d0a76845075a9473f5f46bc5af5a88a6fd9eb3a01c8e157ca7c9aba2ba31dcc90951eca39f8d4fe5d65179c6c83686608ea6f68bd4b7376b93d17fc16fe3aa99efa7f84b60d13ad39d2ba8f7ec35360e98f5e81d9bda02b5b00381864d6dc23afef02477075e8e136a99eb0600f19dec2b333b04b927ddb31d5cf098bdb01d982448061acbcf76dfdacd7fd66ec8fc12e30a6ad5e4b16f6682f9279ca69ea2081f2b6b7aaa6c699f42250b6c0af75e070316e9041814b1172c8b5fcf8a56259be65822d3531ac3fd182b29579194bbbc974c29579af50c4fc854e2c7b8807810c649921f4f37a4808b9156373b3ad37c2649e11e4c81e3f3092a4c6bd9dc3a667fd47844c8b8bfb83b73fc1ecff608165316bbf854bc60afc2267688412a0d61ebf08719868a609352ca504ee9ccab3965162e3221b5caa5c609d25faec2873ce91d606adea97939db34fe72c849000d6391c7d4f1bd0ff391f666dba96ebcce77ac956a4fbc34718413b6d19fbd805ea54f36bac74fd448e4826e97d114dbad18549c18a9aa7fb5f4a7e00d227d2c3d3120e96c8568338297ec5b0d615b6188469d7d65a54ffdb13608db59664dbcf05fe31f19bd07380579772be23d799a042571973d60e4b2d84cdd2ca951e5c1bbd9a9b5705fe210ef1441ec83e444eea91b77bccacd1cf6effbfd15f03fa25fa9586c2aac14e06043c1ea08f7833764e14a64365fe69256d915b207990b670db72485ef649eec8847bc1fa8088830a54947545e79ae0062ecbb9bae87b026a3081f6bd5a85c56656d1554920725b09af34b8aa80b1aa62322419a6d0e9a3892f7c010c929c43c37133347783ae6ad9d8c6926d12aa48bd47a1f1d3da5bcb8bc8f5d0201424d8c6e55f03bcfc9179b6cef5619234f26fd067cd9ead087306eaa72459a51ca56ca7ae50b6f0663ccbd02b705e9e03758acc8be8afd38debdc61a49b9f9c41be9aa7d7e830c9d6a58896fe211a8389cab367d2e64ca49d2e46b96669ef5a0b38d2870acf27222b7cdffe7c8d69aa8e4548cdcd26db4046a11ba53c8c02cf4fbf6feea3173cbe07c4c964fdbcdf36eddf74a024f925785bcb92206cbae3378ae16704b9f7bdcb8c9fbdb9e5ff1835f96b9dfc4fd473732ed3ba4387519cbde176da6a8d99f63b9abf8580395b6ec5b4db76496fab424fd1fa8dd748e9cd3b64597d9f1894f0e966a798cd3a5f8938ca0c12161d2cc8af8fd6eeaaa6b1070d08caaf5fa680791f7444a9235d0455a706f238876abfca7acd437c650cadff55bd174fb04d81ef42e73d60bcbf46bc71bdd4ef797e9659feabd5f0ec6059223ef852a861aab0a2aed5889df282f84249805e25cf7b3eb3ddf4b42836d9f8a04d137c1235c1df95a77f2767d5db2a982cdd882335e3edd020cfc2eba326d3f5964fa1ffc37a8f5417cc07ec0e2af0e6c923aeb3fdaf42499e8d592e38084a2cd2130f564afd8c6c641dd890621004a347d59e0c7664f6e1cceca522d5ce57d2d7175dff573bd9b94e17736502f0bcc69f8553e6d45f84824e6510cf6d030870a514055c34867c2eb79a02429ec679e0bf01e05d9d85419f551029b698144f66d73d537be11af9c892dca2f24bd9d61538899a6e555560b8530d6c6fde654069ce0edcdd6dc3477bee82d1704af16103a7960967086cd8645db9d2b39ddc5b4364981895875eb3a4191cd7e2bd12e4779162151c4611d61a492c28efdeb3984f25a8a62be499ae46cd06cf251ec467f74308f3d3a02cbd8800f3cb27042e10f005a5859bd6ef370437d2707cab725cfc4a6ced23d0e631b29f89fe33073b9b39c973613dff4c8dc796cd9e64235b21a5fe40ffee829c6fef9602098c5700dc60adcaf54d4d8a4357e292decc8a55fe7d7f618db2dda978f268805c40b5004e6af14f965ee6062bc4060ba2dd8842f67696b327d54bd3a16ea3190c90843a082b3480e9adabed9e014d75d36802955a6ff1bc86f70248e29c337515707d18bbd8d37f304e66726c35fe2c098695c4f64b0ab0b7e30095631a3ff0cee8e2ddf7374fc9703d08304f45e3f439670b2d13ee2d0f0071de5e2f5667ecb80181283ad0c871b733f012484f1c0c7b5063a0b6e040f4effb2cf615fe30522815e8c9bcb057e1c4a84274da3c2010b1254ba529816397f84e8e95c3318a5218de7f7fc09ae0f928b71f75d502c1def8393df5ac77c1796e4e36c59613ee9198a4a1f9dbc285740c967fd872dfac74d052df1295094df3d284239ae1768e5e98f513a347e3c5a9d008e065064acf8ed76da3f301c8d45028ace07fc624fc07807faf1cae5ee8f24cb42695bdbff584259e1df60d8d4fa5b9be59dc75202fa40f796fcfb6a160dd270fb94f4569d6437a9692230979c992443b914c60e6f97588d1636b578e67c2c9c212ade0c0938c6eb7035626398a14a7a1f9963152bdf278a4d7b079ae17d4f90c9f9f253f2bcc6fc4c06d23d61847893a623a5f2bf599553a5c3fd053b81d6f77584d56296fb65aad68d022db905ba0935d3ea6ccc7b8f89c58b18ed898b66f3be2e23437f1c4b82bbf6ac2b68cf0b0f3f9100f8a8437b43d6229bec7a109827fbad74cb0692ee420d1d9da0b51a1559d5a242000ed2d8e02006ebac4b408d72e361edbfe6174d5a70d2c9564b88071b47cce98d5766d09ecd869d0c92b7e89b1578365236020b7eef14e781d78e2e23dd3edc3a7b25ed18b11e45457a921758fa3ee81dea51685756604a3d04f88afdc7d6e07246b138465ae9b95302762f5d283df3fcdb551ed80e463a5ce9c0118af25537912bd765ccd49dd71004250ab2f4e36bf4622c436e432966146bbe548a123c45d0cbcd525d9e104d7c70d8ffe3022a7193dc09d633fe678e942430f60db5caafdaa009bb999f73fd5c7dbefb204c42ac47148d2a9b3c2347c486feb7e285bc02ad3a1a58a9d4b894f78caeaad3c3812238c9b5336cba1989b5ba471531f99b876412ed7cf129d01778988924484ac220f2473180263961b90f301c30dd21873dbb38f85ed64f801b28a9bd0fed8f5b6835ab64a369d2aa61e197ae355803a64f4e3a2102060d539923a66203706e695dc36d920e67c5515bc171cf2502c2d878d817f2deccd89cb2b4709fc344747ae1d2328db53f4aa3798f0d34dfab65f344fc5f8d72cfe19085aeda595b45fe5e8a2f7907b5c3cc914fc7aaaf116197903fc5a55bf21c9ec1f8279ddf9b4adde8c7165b82738e8d18ecb19cd4a6f99cb611a381c111caeade43d7e500f7d9c31d19a0c27f2813d5e6a9ba8d4bd7fa8a2155c45bc3d8836e8af370dce69f3d16f091d1d02d5c732c00a73ecefdaef9332212f04386b4f0c6b564d14f289535520b0879ba27c6725ba5201007463e441b6a485baee6398a0cf411f04a976da6ea93dbf5be7c8384a7c84889fda6769323a0d9655cb45385bbffc522f70e23e81acd5ea51d38fa300739ee48518133af9ea6634312a14bb5fe72d2227804346332e14d49259640451102ccdef434197d6405b506940f5b961df7ad60d3b64142cbf58e42e8121bcb1886320f10fdf9429094b3d22084edad15da30d41219e0a09cfd4d8965edbb58a09f867d103e5e9241c06951fa49c7a5ce5d36260fdfb361e95414a47aa4dc7617371e135eff18962a8ac864e633fb80b84804d0d316f3e5b4f4cd7d908ffc63347d560fa186cedf65430c5d5e666739b08cae5d3781cee53f640bf4852d0f4c64f4ff8712edcbc43c39a4679749d407497162f252f7fe11f766bd9ba8cccdc151b698d74ef53ee0b4fbb6048fe8fb1d0e12ca5b63ed97e9d41b7048898b0327559b44f9e61a0eb299346be5f3793d8c1e80c09237600de3d713ccf81067cc40e28624bbc8e0e666554f1d3fd3955362bc4c59966b2bc34efe57dfcad719a6b58e58e3f86feede56a97d623e081a76b9240887e9da3cf46b522569a396b0f374e950fd4b37a9ef5581f5fc3e22ca0a03d10eefa6c10102332a7828f78a8e62d8c5bbe6190b192c004688ff725b3d490a9210e0d17fabddeaae3fcb25db8438d8380aaaefa7f73da39eeb3ad7d30184968fe280a4eccb64c89e6c509df656fffd4f69071d30f57d4c3d16d739fc9ca3b0b0ce4ae8be23dab57b6f4fbaf663b2ed7a1bfc26cada9267b6cf58d4ef2aa1eae9e8a62f76145603a6591d2a94f71c3be686a6e90688084215cf1e6e6011b9a59a44fec4ab2b9cae0a8e854866ce712c6fea434c2304dea6c473f58c8e3c795183af0d2a7144a509583868b032d4fbe1adb304fce0b9eea05064b45ea3db542b220953bdc436074bc526ad8098a86a9c6391c03f12bcee22c8d93e125d52bd718d3a1724a129f3a5cacfe4e4a0e9199be102343987fdb5189255eee4a9571ca2783baa73d5d4af3b9326fd8ca40623d0e92b019b5a3c84837f87f8176b60e1aad2750b71e0b6b7027ffd08d11db4cbe8179fcd81363d6985cf24061adc863b9a84c876fd2f33702fd9a5de50461eeb5bcaa3c174671b466a655a40e4d007c965f61b19d7b8e10d722dd10d86bddf1d919b7965698acf49f5c112ee92d2836ee91096f6e8fb55609f239000bc7189d8cea5ff6db30771913813b25a51615ea8978f4332c1ffacf1d6e4d7abc04316bd96665d4f38e357e0e93f9c01fb65ae35eed3183c21de0ac596f5bf7ed723c013f6b83d05fb24bc4367c2e9d3350bc80805470c654a1c96e2a670c148c7d36be583b52c8cccd4b4a997e4073230c6db071f9c5bf5b818f8a2bb8246eda341bbede498c01c743e740a5fded05023ff154c14c7db0dd5bea44966b357a1cadb7006d7b5b86790903cc482a3ab4e8dfd07929e08b4849b1c09bcb453fb7eb0f9efec4d5d67f49e820c78a47f8fdda37fc44161064de0d0d393a2f2ff4a2fc984f9cd436ccd15d19c991bfe579f85304c707210f58308e2665fbfa13a125bf380e06302d8f1fee2a167815b9a6b1fc947bd27a9bfdc823f2cc3acd3b8c1275926d897f31fd2aadd6e21af142bf72df632b629e7af3c932881c506b42966487684b4eef12580993ffc6b636ff89a1b84642c3352a40067b0ab6b2400685024eec03b4cd91a4ebff6ddf7907ce0a87ff052090159284cab7b440071e9b7931b0bf7b21f100baaa5dcc42d6adf2281d8cfea78b988437b3da5781b6df3025e5fa2c1b552321e0fe1eeb850760f3b0cb38c0f3e9c9826ed11bc51e551ffb1b212ad4bbe66a854a15310f9bd1b5569da195c8eb4553530637e3c3f234c36c00f58736f169a72496ca0deeee8fe1c7b9281280eaf505e5300f44939a9f6843d2349a6fbfd413423cfb2b272c9bc6da43092445dc80f707e9cc3e47647b41f201a94d57ab828fcc3938522097e787837ff41037d3d17cc2c7f2da3a52a8f54b0bc7f54d73064a57e1445b657f5592075f66efb3f84ab28d0afcc40e2f35273751252857e568eb7543b8bbe5823686efb7b533a2823c5876d5b2e09fee3a34f23733e49db75e6a756127d33cc9e7cd103aaf86a364239ed158b8dc50810528c5d9b85418e3ecb4a522c0b8c8f9bbfdcebea5e47b20d4d438b6f304ee23e958ab1c5bbcfd114bfa618f80a71f239ea1760151f558c33aeb7acd3a505b516490d7e13fa880e6c28d17a176e38718987e5f0b3bde708f74116876d0d1cd45b65effc8c34ee63eb40e661f54f9915c8fb7b67298241da59b6dcc8298705a67f57acd2904aeeaf7b8f44547ad870ac3f2daab8cc3f3ea4b07d10efcc8d434dc7bd6178a46326fc028344274b8bc67cdde18c0a0ebc4ac9de867432d7c1d447e8230cd2e4cc8341c61d16058c1550d64059cdfba8834a821cf4e67c25e786a9443926a603e80d7a4eb5f46f90b0e4f330d03dcca9bc9d9f4a9c20ec193510edb68829d615bd35ba3fd184ff7c550da05443e16efef56f6e016cd10c481c8b495ffa29d769a9620eb8db3c804ee8ea3de2516b0a28220447263dbfc023fb92b90b7beba151061f557fe76c34d4796505592e65648cc785fca9a0c1913f623de0ef768a551182e0fa80124b2a2172f00c0fa514c02afb2eb9c592d8ddd573f20d610b2b24b72ba952a03b2a0cb13e7e1e97600da185ab5f7a8726fbe4d223d6a85b8331915c819d62b57d0a4e73b9ebcc975b828d3ea02a32532fd2ce37d8d20d9c96724ad4aa0ffac231996c4034e3ea51fa2b1657baed5f07084d7bef0b3aeb910e89bb767247b145f528d2ebf6ddae8e6df5ab0702cadef3bc4cbde13d3bff622c27400b150edf52b6b045abaea0f4f8a2f6008c8b5100ede12d7e444462bb56e04338e83b00dd25d6a24d74172c87572b1b0dff5326f75d729dcb852d6387bd28f692e49b5167d3c3455f305e0e516da14e67cad95cf9d9abfd7261c2f469a8cba4bf6fa22d81a8cc6166e9c225d7ed070feabd09374bc727c07cb70a31c9641562d7cd1d1918f500624d5d47c5447c267b1eea8fb4716109d82c310a4f739b8cf8ce350dd66462e2b103ad477ec3d0a4c2b53bd2196e3c0eac08269c033c8b8d20b92aee8024924dfef64a98586e571a3ae0a677ead51add228a002e00deb4f63db345a4018398e4dcaf748d126adb98af38018b9fb05eafcbb594e91cfd1d6de2ee1d57d12948165d4a8951d3086e1281a088109dee949c9cf8c313c9864d9e6164c1e64387f20e1c61b7f6581d0d7dd0ee79f52787a56c3740b28a0fead3bdb30d5ce211b1a46630faacf15259cb3db1be72112e5c4ba0ec00e35ff170e378824347ccc4c96d49bf635be88925aec614195ad41e4f297dd99a317415536b8295cf5931104be6e390859965a0d84ce04cdd4875d8ba603eb02d206923b49dc4d581228dea3f4505396cbca560fd9a2f7a40e819746adcf5ffde0fb20b64e8555e20d9928332ce61351402ec86f3c73d180b87ac1c6a29827843b044da1a77e59d148622dd139f4e4a8f9febc5011502c91ed67893fbc16f54d3146253133dd4a1f57dedf14d95ab38745bd206297137144eb622d082cd7d5c771c5f1f9cb8ea791a57b0c6a2ee3c1982f7752a611c9e8634884a1cf0d213496d0f6d91806645872ea26942d18b604f519abd653982e4acd07c6f60e4259f0d4dfe776049862ad93ad0150af29aaa7bc6e35f0cdc7b06ce00dc9d42cdb344a2152c587c4ba710d8cc229b6a8166a96afb0bc1c401e30b1b073d264216e7d6eeac4f93109e5fba58d31fd23d336fc1d2b6870823bdc5408fd6cc971bd41eaf23f1bddd730904c0068331df07e6ea0378d1fbcfa1e9102cb236b79827eb39186bb61a9adcdee695c1bb668eeb8450f2940d5a9fe2bb21c7afcb0e16c764171fe1a02c4e72c1ec88b76cccf02195955ff90784d7e6c629c0c1121b6619c5ad8f1832d4fd52365479b4642a40ef73c1960a42359d4915fc4255f7fdd7c6473e79577c8d158252e88d75ba617b1736c76cb4be4a51c905184b5e67c88b27cc13d2ff77ddf5fa557f61c848f0da84c891c42ea681d705e7e9fa6396719cb4922cc4083e52b4100286f4cc6fc676d8f7fd44645addcff29eb3f6caeee0b5ef2ce1b0f56e48d1748f8ca127debc2f61bb001b9f9a40886d2214bad29e6323886349d96042256b96cd14cc361151bfce353780f4d6eee1d4d35b749b9e881421cbb25fce32d829894cbe8e9de36f6d7e01558fcee06c7d319102dca0423fdd050b29205a4ea4f27d7942602fa7f13205e2545cb3dc9e1c741dcd99049e8edac301b83b5bd7cc5445374b2296441bdc78bed332527817861eb2bc39defb03a653c6f6822cddbeeab20594407f89bd0b23d5d4f9668ed036ea599e7df7b9a2c69101444f1d2cfb7163b1a8891bd4cc50ee1986e8936292a02b4c6588e57ff85cb8dd4ac155b1c699cba6365c5c1e4169ad272260dcef04964a33a69e4946076da7e01681e001c11fdfa5595bde761963f9366326bd2302022dc660870ee0dbc0a0a858e62d97c7ef2e0f2ee9be8b979052b2465c283791d75ee1d989f4054495fbd45f15fcaf760024c9720bb06a388b2ee75dd252f69e573ca01db3152282315fca44e61e031753c575abf41e855411df695cec16c4dadb48ecd7c815dfcd7d8774ae7cd8d38227155df68a47998c0d81dc164d62dbdbe91d58bef8ed6ac877ad7d8d0a6fbf366b2432ef6794a07f387f6c01312efd1a4de6c2d91d8eacabca24b7acfbf0cabc58ff3c114db2f4e7554d91f5c71a7f0dbe028c0e27ca8c620908d15b6591959aea2731dc471c344b41605fca45f40cc459602e6b1cec63020344e30546990f57b0c3181474aa7a8d9f110531299ff4e2d1b28b5800279c5882c9da71f8b50e19c785acaf8db174ae0f8915871e680d89a553b765a07ef067475ab56fb126e4e0fdcb174ceb2418e1399de34b2c5b568c3c6abde21364ac4ab0a5d7fbd7e97895b2afe8d286a3f980076a7a4247c44b5f169616642bbe872c3a023916068e5355c96bec4337f070a2df42dbc30f5981ba6cf1b2ec9c2c6088a29f528d1c32e0bbf25278cfc139ae2eb6f5b4c7d0a9decb41117dfd0300cef0daa1f5f9b35b7aa22bbc6f63f8f77488304f04a66261371e75b9a90d85e8fd68441761c64e71d30677f6aba349ed9ef51b1c741f8f21cdc17275d29376a7c88809a39796214bfcd3d08dab06bdcb0959fd0c9211614bd3a4a41b5e3424af072b4999cdf5e4a70ec970fd1c5556dd4dd78581faeb8dec35abe1b23b59a3d6e0e6caf846ceeb20bee56fd7458e606057c74472006b6033378dd196e0a741c58008c1b29868c135f16697a94894351303ba96eca55080a343321cc4314032709ee50f02e5fbf41c58a34104a3918b7cc53a69de07addf476761a568c951c0a82c7481c92afe368ce00bc4f726447ad223bd3ed57e973f380309c06aab688afd44e7add512d9204368c400eaa404d366bdabc5766ecaf0bd9a676126823c7d34c9987c024d1fbe15394bf9cf5134db367f408ca190e92e9a03f5e8eca16ff8bf40fda87da1e8581fa2647647a787c60ce3da84598c1a4ab9924cd5ef28903541d1ab306c1653ae52ca728f55653cc0358dfb752c25e27baf490c2c537d4d148943c58099ac93c8725b1ba5a8f12b9573318383b6a22d9fa21e45727df0b80f8429047f58432834f1c8c4399e0034b22b69275e362fcb615ea86adf376a19a4336817e02f111c30166e444e00b82e1b78e4a75e8e76f8a689aafb3de7c9efaca1254f4476ac4c8832d2ceaf10e6aee9670da509b87faa0adaf83ebdd43214ab998f424e565bd6371825613dfd265a2f6236d075b739e101fddb1efb97c997d3433ca77c1e693761ac6dbfe5b8f139df4eefb4ef29f8fdba31fc75e26f01fe9b781bf1087df102b490f7dc07f1193bb1e0142a87b84355a6f780ebb3c26b1abc6b6dcc85801ba50155c439556c8db90c6f3edb9f291b743706ee5f014f9eaa9f71c03c003f51d176eed68594bf776f6287e17b09eead28912b7d521e9071bee780428e7705b182cf82a9b5cf5f9792117dfc47389e4b949ee0c59acf4efd60ff18ec5620f3930ab8d04ef2ee1f86adec0022a522668f8aabf60784c1b39001a67a72ed2cbd1e28853f16d61a877aba18a508668a457d29f2ebc12d2feb8c27f0bc5432637a6abb271c9a1aa7890b9f71fee6fa701ab6c9ae0c24b084a89d62943ced759fa20955dc4f175f5687febae4292a178000b74fd695a3c7072daef764d0c0d9afb99f5eab9d25cf0a5766fbae7b009824725904cb55e67f694c8707a61acf480ad0c7c88d3859fbd9d5a3c55f62312acc404e8b29b0f5b7568c92cfc94811e12630ceeb1e9eca876ef996da5566cc2e139b3021feb721f4d7671ecef834a1600221af391c96fd7d99c7113f8c78ab9f107f53df4ce57cca52af6c5cf7ed8416c77dded8ace768a58508778ee23b39224c745e7de66e529da106cff732bb76adf01fadc2c4c207f7d911bf5713b0d83171ee86e44db065d00f6fb0b6b79b08df5a4cd1d870fb97359d7606e31eb7ec7811ef6923af598c4cdd1f1363bb9e16766aed2c2afa19d1b22f466bf56f647cd6435cef679c800209de","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
