<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2db11ca93cf381b1fefdacb13edb3a8b4771e2fe3c1b136da594c10a3bcaa60bd8f29dcfacbfa2bba6d5dc65250fbe69e86ed087cf697b55c2b0021fcc85831cc9e90a8f43abefa8214d5470fdbf8ad5f800b3835b7f1b3682238553ae0b5f77979f065432e50c73ca964bb33a5d8e48c02691287c89327e53d473a7ed524c09ff9ca6f07d956985be81b7f700d538cbfefe45eeae88cfe4c38a3db916cdfce447629608265e8f6fa1ba107f6b2550e1f727f262645cf77b04d9eed1a6f503b08dc3aa3e0150bf6ea1630b894d6a932e68ae0e1aa2c6fd9b38f6bbf995d3c65f3f30cb527eb2145d2518110e34589ff62bdcc4c078fc1324fb9f3eb9535376c4ad2557c422757bd7a269e52ca72bb73fbb07a1482cef7e99491711a6bcb01cc314ba02c22a78039ef063a6aebc80d269efee35acf0b56688807c8662b288649b36fd029f67f69d8277759ab7344463048f353d9451be3cfe50c40b927bd4e75502c05ed70e030d63aed259eef101796af59e6a67049186391a9ebe81b44ea4e9adc8c0d58bb3689bb29a0ed819ba522fb4284521b542a11b805598fbde556748451a38850d466ee05c17a8597130970ab4d1d6eacb96208a4b0ddd9395321e5cfd78d9a6d1e2f4210d95a23b764a3ea6aa56228506ec87cb9817da2887e69e6a5c6603bb1bfd3098f71f2d454af302fec030ba320c2afe8d2e78eb2e04c7d8ba50ee6f4d120c946c6a51a8f9ede4c2dd34d1b0d0dbe453e3fa59441cab3137a6743e8f52b7ad39151a2c8d6d16f50f96158209f08c8d6ebc772e7153f69361c821c51099df9a3f25f058dde2de19afd8d6b7cb6f582fc03812d3be7362418db08eead8b2168b3c6b3f7a2cdc1edd8470f683595b488be2886b8dbeef0a5dcf2dbbf8184fac20e7f2d4d1f10edfc71e3e498e8779f9c9454739c912a9ba47c7dcc24cdcb7cadec099538bde92568635cb56cdfe4436f0e18c7c40e4d7b0acf9278e7891d7bef9570135980e093befb85b64cadb2d8265eee7e9bf1b4fcfc4c60a045ad24bd1d48ebe9eb7fa0d08dd25d9b44529eb36ad0e1e2e15b7fa363252560f62f31e34ce37eea21e70f81658828808c096c6da5759d65e4f482de757f94f9e4a77487ee92e721a153183cd10eed42f7e8c5415145748c1b2b50753a26fdfa73dcc2b180ce69ccc49a62d4c276513d48b2870f3de3deb6710b20754630b2772a0638b02974693a31f81772e71792ef2e7577e4cb15f7a966e9243f132aaa3198f9dbf1b21f653c204b3281fd2bc145adab4daaaae5be46d04e18efdd32953e30ff23812f590c422bae717165e6b2756b963de711ad411430e6bdbe0752930f05f48497b92a941864bd5bce732cc6470e22f91b91462053af1aeac6e17e114fbd5b3f956322b7602d5a07ab7794424f1562ca9641799c3731963089ca9181d55935282e7c559675eb207a00ad81c2c801f8a5125d21491fef75d6022df2a81e6c069c39bcb61361259ad4579d06baf88d1e745bebeb6cff2d3b2841c8f1d563961762662ac959849eebfee341a45631c7060e44578a6690136017dd70c80d22b2d071ce2cf471d99ba531e4bc9aa1dddda8607d9462b9f0005f2071678603bbfe13556940d93ae1e5756a9b80853c2bd5022c75f6054bfae604daf709242307c24b2480a133481e0c9a5da5ea238c50cd9b7b8c9d01a2bf6fbaf08a181a21862c495c6f1487ef74c7a87612d0ceb839596ca318d4c4ac7cad9a4860f10b236052b6bcc309c5c3cab63c7b3ad85e786849608e5c6b132bd523a8fe6dc1b595306a83139b048ee621daab4d5516768edcc3955bae88b5d69c7988cce3effe6a8910c94c9b1a01ebef6d194417c4ea0d1839064ac9f0a078bca5b44336e4a304f1da12478e789c20099197a93f6fb99f94997e8e5a44433b7b449f547d2680b1034b8edc9f38d64180d2f8040bc0a166481697d4c71865c0964f28b619e09ad2df5545356d3f65acb526af86ca957732d03bfe89f3b399a43dd09925a7c85d8166cdb186df4cc315d0945f9196d729aa25c729746d10ae517d900f92c8aba8207facd33f78c818dc77235dffdc1638724fefb057996fb67648877c1ca2c4ca860bf18dfa68989dde8bfaaca9c05907371503efa5b199ed07283e7af390f79a9a3ec07b2032b263b23dcd5a343541ef74e3dd260ca0924a884976453348e2d5101387a48b438633f58db651b9255e01d5f419277b1b5c2fd7eca1455f916e0f6c8ad640be4160017a0933aa463053a3bcb6a225ecc8c91760b8636981208f51c46c88ec5bc66ead84995bd1ce9064acbd5fbbadaf859ed13db099b522dbf23ceddb6c95a9281c1f858a697cc0c7046f314f243c30ef28970dfd527e49b35529f2e3d2ad097fbf0b546efcbc76f09d822c99566802e67c2a885bd30b6098b4310a4577eb6b181d76da91d7b20834dbc2101661ef3d95fe41c6261ad9acf720d37ca66704f4d5ee383aead30d3e222ef74acc32931703354a9defee6f20dc0d315db919c13ec4623c71ec7a94fe7fd7008d4e58db40edc1e1e67b96b713ace3e3b6b15e92455b6347487fb09924e587c76d452325c8f07d7ae47ed668347bb7d5968ba7ad6c9f61c2ade342438aec697b03182566899cfe2ae99c1eade94efa4291f6c23d668ec7823746880f73a29c0fa1e9ef00675d7e59a5ef0e2bd54213c53b2603738004536ebcbf16ae7847bdde790d4aed677a9150f4128f8fced0fcc1f67de792352dcebb1ffac3b554e1c6a4eaabeb4b90b2b452aa052747a67f98293fc6f6ad6404d214eaf15ffcc55c4c103a339fa025b61c6fc8a94c4e80e9ff3407fb82f8ee916e8ccef4a1225763c525d2b013c1339a9e2afdabfbcfbd9646f3e48afedc9b2659464ff7bb040f5831aea1b1927f3fb16b320d2cb59a076014fc07d83844843b478a93fa1645f6e6c7765bdff74e45e2dd1fb3aef91fad7b46b683d41cafb3202292705fc5dab3a0b30d68821c3ed3c51abf15be41f1ff340a5ebadbeb22be146a6ae8efd719300a6bfd97c272862a766fa0d1ced32ca40709f0545a5933e827867917aa64e832d6ddb6dd4950a9c40beabc1b61277d13e6e834c6a211fd28c4d575caddbe1713cefb9f592ddf660a6a639c8705e66a71a9cc3013bcd6c1137c9fa9bf5cf08b2ae467e65d23d7d28ee56c8e92cf9ba1603335916ee6001dd8c3984b81af0ef105ece78a306c728a0fe8503faa3b03ec8f2ca5d3f40c1b6a05318a41284e15af035b19193dc2287f77003299ec958a5f4cf02cef38ba9d4e1fa07c300e74c45a1db94ba7c0640df84b772f38ee7dc6e61b09fa1748fa0f4245fa38392be6e94c23103ccdc819b66a5cce585dda71516176d643455df1b89383d5cbb0b4ad3297b2fc3ef2dcb371fd50a5fdfc91b789355f34327ea52e6ace6f1fa67b3ab31d1541860bbaca2f3feb44d388c9cd23617d36a2a7f196fb36acfe12c3990a526d2cb7435c91fbd39eeffa9f862083e640000d38c683e15fbd5b004a8b9e37f445a1312f4cc25230f711d631d7652aa173537b3e5535f705c35a6e401b013d81b8c8e2ec15c54a792e168d2d1809ea9dde187ef4ef60035b195117404f2c472fa97916b7a5c3f15bef9f28cb987b2cea861c0553e7bd765c2d990bd593c8c023e1e19386b7c405c58ea468813f45efcb6d077aa902d60b209df602dc1b5233dd0bc3d58c6cde84cd2832ad61ea3329bf182b3c405d3a2f84001fc1e9ebcbac51183e18e405ae123d85d39ccf30bfc6b8fe99ee37b48f1d5b1b54049b494425282ea3e9d78db453a05e8e2eebbf8b35d698b3947e4a469b088d6ec617fcc7acc63f31953edb392bea1a670f09a920d62ab4619f10cc7f0312f6b31c3fb0da9cb27a8dd28bf7ec844eb7822d1885d1902a51930515255cb9a04db727c477a705f71f17d0511449d2d915a765c14186202cd492ce69c3040612b51811ca8c6c35d102cad94db100bb5f1cc7092c7194c3152202649f2f1f096b6c69b0701885b46482bf7c8069bedd357d7ba99413963070bcece44832fa0663e23bb0a080e1a9b8ae4a21404f511247491b0882d982ba24323cf6c40f439ba290a2387cee9e038c91ca45f791ecba9ff3b3d71e8aeb79b574437bbdf32e67d4a3285a05056f28ae6b709e05a1eded223a2208ac8946a373a18e3e3d961228d602f94400b4158ce7b85e76ca190b0cfde5da87bcbfcfcf3cac6ab8aba8411543026f4121a9513f330f23b5098a9366a7068c22d86bf89af5704a99677b7f2e66112b3d77074918692ff4e2268227fa7ca0c1efffe9274717d0481bd962459d1f2e4e8c94873b69ae6c0a211b437b2a0911c442386e26f659a0941583c33859ffd322725e29ad8839d40271b37e0870b07e63dddfa0cf1fca3d43955b4c22290f7e7af18b4049de1e98a8c54ab75bdbea6aab1ac68a6adf35c5148ce04a96e5f4c4c807b4b4999e6c3ba813a43a77ed8e919cd78c4282d00ec2e8b603b32ddf3f057e71a55e9189f68806e57b614ed648e9cdb366344176bd84e416e857052d8f54df72e1324cdf461a8f7bfcf27a9d303afc597056c14ac775a49401d5df31e90c385dda35622056d837ac07d8771701188301c31d1370422f8b76365378e59f69885591fadc657c51058760f28aee4809f8427a9fbdbef09243dabd5262af57451b4ceb6ffc76daeaccdbc8cd1f6c833ac20fff3118b92f6ea2b65729343a5ddc5a0c01fdde00695bebcffd9e10c8dc290a5b63b615ee3b92c9332fdf80ad73c453a80034eaf7b25ebb9c9892f1aaa6d6f35e878b674dca23f80b0b5bb6ba94e0a41beb3fb18afcba1b32333fbd12f7c9875be67df2dcc291cd512645c5797407bf87658c8b7305e4888b2414090e2509dacae485e6d952ff22db9d447bb7238fd4360f92c30e9b76598602118776258719c798193edd6a84781ab16fdfefc65fe8ac5bf6ccb3451a0c650e6b6656eba232d0776499f72f0edddf50509883fbf4638d59716482bdbfc17435e74d67d04c8fc81e1dcc8ccf8fefe66d6f51089dcda7338e709591ababf40b5265e23e0be9d981df9e676272a3d8ea1ad591e6ac23795ae529f6294f89328e78d10997b85666092fb3c60d91bb4ac65bd576c5c96c16cc59cee55481a1d3e4f64ef2972524a9f6ced42a3f6c2bb56c5beff68399931aff7296392b03806c31f23730563756a84dffbe6f0efcf48699b945676cbdb2f2a6d5ef214749bc702f0c69ac959c5ae86190471005bf0604313690cfd5fe3aa6051db7aaefe19222b70cfffc9d93974ff750014a69c28a319b71d95391cf5de74ead44f15c3e0c5e4da706bf5a12740982c3c27f93e106b52606691302edc101bd28f332b865b8795e052b07cb6527ae8e06969319d0b0590edd0aeee9702825485f46c657935f05934ec853dc8022789f62e3a2b159b757acfd83a20ec57383a301abd8e739def8cc9cc9075eacbad6776c43094f287098cd4756061ec8a85ad0db68da6d2903a33c43550fdb8fe8f3460247a853f9aa9e161900b94ba9b1aaf1a68b2f9425a4c10cfd3385e4637644b9f9122037e793dea7db9c5ce5ac67852596f7665bfe8f70e20d28bb10a621921e2ef21ae2120200b63b5c765e0c362e6fae789b364dd7cc88949701fefee10695bc347edf1943b09b042c9b3c8e9da0eab554b598977f0a720637d559896fd81de67b4c9590804ea485be7643904972a114a183edc87307fde982dcf27d9ac8d4b1e7a2afcaafbd9c5891f972a091403f98af19680da2f986810603b1a64f784693549aa6a198ca8bcb50f19f786ac5ca18ca0782c79aede47319d3d91826c66955eccf792d7e7afc4d3952a4844c77e55ada6a915c2a85604d9ad918a667d9156f66a80a43df11d3a08aec77c18fcef4ba5b8433de6afc958a87660cad20d7877217aa08d10209128ba8a4c6e73d3981da1200d619ca3ed51b28305f4ed719d2a0142233156ab42e089070704dd2d9c495df7023734a92ac6d1aebe8ee22bb58f90ea5dbd32e05d066beef5ae66395f0bd5c24d348143d329e49f3d7020bf333f664febcff54371f815e14a886b8f848ab288aaa673d85f19571503d86426797075138a132c9192f44e2e8c82a88edc8f725877971eb91b808ee78ec731af00e71dee7dfb432caf58e5d1b162648c66555c13b95d096f9afd2e6a00e79265894d01db7f9eef1858591b5a992ffdaf659a3eb1e64f27d08a3b79d2f288defb480ce9156cf37fba54b261539c946621b08c35b5a5b5fa65b9bcb98fe3dc43e9fcf032e9819fcdcc43e27acea6a44d0bb2149e4796bde720097b8ac6ccd8e574534ecfa10f8f46172d9c63929ef461067fa93426290e7739c6f8c7fb25e5bfab3e7a89622abc7fdd267794b1a4a83769971d353b8076f857c72a1fddcd9144b243bf8dfd54990a40193a216a58520362f42b8c4e807a5b1227bb887d4bf6e8c9cbcff3a49d57da9679e29b8e3998fcb0c0f37d948cf887d6b23ceaede563a13224a1c7afe195ea562341dd4c0dba817927b8733e6c8fd93f59c64ba2f396f4152194a5009287d0f326518344c8cd3ae7b6cb631f2d146f427ff8b988ba4e90ef3aacc46695ffb913b81641811c892552e2f77f031b5bfbb54c6ff6bf208e75ebbf2009f38e199d0078a78e68f374ee6e6dd9a74e78a004b1bcf24b00cdc15aad205a1a8e4504631a667148406d54126b7ac5dc2047bc90d371f49ab1ee0b251f6a597cff663c4e71f55307185f9fbcb8311a126dfc7fb25aeaa46445eca2672512472a214c355480ca3bc3f8f2c992c1304e53cbb680613a9fb03c7d1e4cf76a7afbf83b8d6536712978033b0244935eacecf5c52744c772d0907ee629ed1689fb1cd267701aa8e50587bbf6c9ed31e0d785f97e9f0410b288512e881236710eee76ec884ec7a52e11ac33949cb6f1d353c4d33910564f516fa593dbc18fd6ddd70ea6c7d397720fa4e85ec66c40a095d0587c6f24d57b35599e71edcfc1b2b8d3ac418c44e0a3d6051b18754979567bcf978086394661736443999d0097b94283ec5b41a5ae8060ee2107f3abc4fadede5ed47c21a8425ad0911e8c64f36a05c6715501a16e6814df2f0be8e9d5f8ab0294eb426eedc895cc40d618e2bf0fee762bf4b224b7e1f0fd2fe0bfcf22da420a36eb19f933c6870c4f8260fdd7658e42c20c359a0fcf8fc7df45969e00015c6a6d3d83737971ae248853131e168396c820d8a741d502e4d4d4bf2f805608cde83e61a76582fcef71bd7898956e65ded5180775eabbf158bc7e05c28d3ecda7d82b61001d1457091858ab4d8e1f38e8ed54a15ba5a57a7ea32a4413d502f90ecf4f51b819bd7fca8c715c8d3ced1e6a98a23af231b3eb993f6c1780c0d61feb35264877883c5e50274fd77abc0cc9fd42b8bb8a3853e0a1f48c8acaf32c38b9acf9dcbe08390d1808cea8718ec28a96d1ffe326db1214844f6df0135bd941c28d2a96deb4ba0fbc9c607e6bd7c401c62a3b55170e59a0736d53196f756b64f44f2111e7d6982ba9cfb13868cd2e8a0f658623977473119f292ffd23bb038803b2312d67a7e398ca6311a9d5e0da5830be78867927332b2e88feac94ad5b0d57b828caf4821877b518489a81475287b2759deacd0aad44ce799a285676c66c137ec839bb8c7471916ba8be74a1dc535eea998f9f6cde06789010e658a9b92559c550ce875559dce3bdbe71f7a2379174802bad33532fc81567ea418f1050e2ab887711e49aec365d7e21e0f87a03c87a27ad6dcddd4250fd508740a8b91a9e963035f9165752373fb9b074cb3648ab8e0a11f0a184f8ffbd17e02a78858e7030a22336728a9bd6f3ce45ab842f99d244afe0531425a33f8184e379ca66897205ce146cba19f6094f65551b0376d6e2b516799c0761c4b2e69e8ec1b78aaf212f84faeb915dead43a5e50078ddb9bc0b45372c75db57ef5e378a7fa7de5da82de9a1581ad3dde9fbef6368c796397387a2b5be8112b581553b20c3c1f780128903e59eec8d2c6c749b43ca09539e5eaad9c4a2ee59b1e801f39ec8f43fdac0a998afc37f91393eeccfa87646239f77494a3e13801e05f0cce09c218dd7b9389e5b1a8e1000bf4fcd9b0e048ff77fb01e398a4806f1eae8a06b3d1adef5555604ea2ec2508767a4358c071701514b065f88bd4f588c2ce398a711a274c7c8471f6ded2fd043e02c1b13662597a4cb88706fd173a22d399cb582a45fd8dcd5416d53331d49cf09209a933c993e47fb4a8f83b2ac4d62a5635c446f2659d69482843b4bc8248ba6f7a59c46cbff3e9dd14bf0d5ca2980df02ac856054ee1d2f7b3927650ec2fbd26baa034d459dd2a17e4c326a2dc93cdd41c1a887f0a0b7811982cd5dc3ab53ef28be125ce767c50459bfcc3495c4d6bb599345ad388cc5356cd793d1bbeb06e1cba74ad2067da99c91a71b3885fbf331a972071f714c8a49057afe12371ff94af1980b4a68ed8c0c8899905d7528ccf6a94449c601895a879777048159e7bfcd1c2e391a9ced0a6bc532e6d0238f225da29a3e24e357fabff4b92c3f35137425c771278eda46becbbc50e81214e6700c980184efcb50d8c53d8e4ed70a4f2ab5ebc9675d37398116ae924e7d700109661c8505115aee1f10d7e9f6d4be9ce7a6afe663ae79f7d58dc5c1ba1b17568e9826691fd5eced35bd1842e9bcda89904fae6fbc140d39e3ce7a89e5315ae043ddfa6917f094988094fbb6ffed0430392811a760e746f6766381deea8031350da82f2c1ddf8ee6c61ad8ef2602a6a20894e0a6ee26c9501aae59e455ae95d3a84425d779895e3ec73a75c9973a0a6c9fadfab10ff79b3c6b18a9f93a61d8283973ad270b33f4069f4960e93a2e383a9d4f22420331f2c55452c7542cb7f135ab9d0b2440532678e615a2f7f6bebcebc7a1f68a7b9121a62562b21261ce94c6118b2beff2dc0413abe3ddd870a0e32911fe097c8c449ab4ed12dc106d53365beb8c9db3560c5c39b2a1b7b8313a02b0ecda2de131c32a7db9f560026f5f0a340b363248eab8c10ecfcc377a1d203530729fac6b2100b1a2cbc61049fbb3354792ed92270cf60d50b675af8eb5de9f179fa32bf338c2e3beaf5c12a32cc530deb49f59d2512577615c02b974dfd472aa53129e4183637dbd97e4ea78a39d0b775144e7278e50eeaf6b4105b1094dfac288b86d4f0fec38f7191e02c9b0f60c93996d664457e5555167899348e78c66ebc0608b590a7d429de84ca3862fd000c965c5298d7f3cc14765308f6ed8d3c0025d287af83e99d99a4e905afb53def5b8575c7717ebab36a62d9f442045a4f0405a14262f514a418595abbe5a517e9495cb8af3a881a5044a9d37fb36470358c74d1fdaf0fb8eea9b340b3b56cadfe0e2c740d0d71d9c0c178da986500a1015570652f0c6e4c5548bc093ac771cd5fdf9c423dd5a511a7c5ac337284595a0d5bda315dc6007a4bdae750f17899d3867d2fb35ece75f9b0e19dfe0a67a8a31475ae0e1c73b9526a3382c4b2aa0829b3249f88c00b6d15f65fb5fc8f9c09e5df26aa039f9b4840b87afaaab73c2a38df6a95f7414f694a3fd526a306b80240d2088e6efe6eaa4e492c92ba84469835caaa024becd18b852db896ab97c7bfacd3c33212f801b750f8fd152a6e9c4c45d528720fb862ff3bc70adb6bdabfaa1b5b5121f2af02dd73b90f8c2e1ea2e6a1f5f80203535dc3d76b98a20a6212cce87deed524673f0a6a3eec7db6db49a43021e67e2a7a923529c8228e9056daa3fb48831de152febc7597efb4414b4898b48409f872fffaf5ba6697c0ae6585ae40f13743ace5d4d2c1912894a836a1ef0cbb0ee60bd9f74332d382b2a81a6515b0ccbe47da97f64d0a80afa4b3bfc26f2cc605eb1d4eaddb05e891b5f4d78bb7245e7aa3de549cf6ef349fafbae1faeb8b9d0eee6f0a843869f4caa7acc2666902d81ad72f5f25f4641bc702a2f3c012c875252390c17617621e1af96c90fc9a3b15aff0f4736c92537b37797d2002aba588bc00a8ba3121caf0c19b826c53afb2cc9c5b85572ce8864259a17fdd2858cbee8dc6fb4a3c70fa68e527e5096ecf70874a3415dba02410dd483b288bdee732d2746f5e15666e424015307dc183ebaa3b9a6cbfea223ef3fdc081b1574dd2ef967432e0ebcfd90e4a84bb89ad25efc6634200c0575176316d5851f64688496a1acfbd62a1d66883ebf8d481469b94a6f9d3dd6309741d3c3219d276d23a00f5bce584eb5f979dc3aaaf5efd6b4d1e55c7e110d04d0e2480d8ba779ba54ef6a65f260352fe6c3a7015ca55ed3ab9cc6d0c4d4874472136b663e0c6dd50235d59bc8eebf69cc1942797c5328e771f94da62dee52fcd3a7bd029ebbfc0b0bbd26208cc83249a11e83358a492736b7640590ea86659b8b55a6227237afd193e054aa6f5e58214a92e0a5e4469bd3d8aed9822152cdc48061e3a5ffa62199666dd1689a5dc5155615b420aae892c5d7421fc12c622136cfa3eff97d91450be2e32ba69f53054a86d1f69f144f46cec6e572525e927abad58ae23765c437486ad2b8162f8f96131306700c1fe7c97ae863902427e726719ee390cb600402681434e7127510d0e7b014cb7c731606dff6e6aee9f3a6d36cb318ccd8aa67dec84633a65d72cdcc780783bf4d86c757afa470f52082dbb70417df5fcdd9d94d60c358847b15c4df1cb7a3186813b0f7c34ff449116dcf18c84a930453187ebcd325a8e81c049a3ef5957483a59cb59840695849f4ac8dcf82ac573fa99a276e48f7c06b59e75e1a0f5d880028db491d74f07b0c78e2a5c7a914f9bb933597e654300b8ff259bc3483d336e7dbb720bda0f20e10a67fae2818ce34a8c2f381bfc045aa8140ff92a1f63f45bab69a55bb59c2ae8119e861ad51da95b24e95ba4a6d1086c827e70b76576c3346b898a4a4105c8c3251ebfdd42da3dd81b1505dd95f9794f1b23d9017e85517e8f9c2f698bbada9cd12ef591828805c81026064900182bedd458cac47e3d8470badd93a10bfd805aca28de980683e418562851e0ae10cc1ead1400028a3f61fd3fd13e25416bf4f07f3e11770288e65c0a913e24335be3da22d2107a90cbe799d0f06f4966641cb114c0f32eb6f289572776801d64ebc92be304f5816a5d2a024d6da5b3cfeb14f7124d01a130dbb0aef145372267e3d0186b1a75b55861be4dd5657a44898df8ee50b884d2da6d3b27340c5e3ad34cc0d5f40ee83e6d38d9da11d36f5d9777d2214b9afd15f58243a4eb8a0890076e6c15abda0f635035f64ea4160a9b2202f79a4e2f62fdde53c6fe5977f9f100b4b21635b65b4d715015e84b02c913c2ee30b3da72a8e9f351e2479fb63111e56afcf2e81c0d2a0f07d600c471f16d1e6d31d6ac7aa6dadfe9ef594da0ca8e8f254180e53b84c04be0955e676a6036df1a43f79a91eb1817d8c5f460391f6eb207bdb4a5549866e0a68c4ac8f5b18e2ea97d1819da43ae341eda82a75be360f178e653a564de0597ca63e7f3b191bad7fb97ce0f2b9e23e5c9c8db9235f126d80e555d2141e39d7726e8afac91b0e6610f016e87bf068275dfb28be07ff9874eb3d5f655d2cee5ca3d145c06470712c0896bfafdb66f75991710d001c4da59c17ac8460fa4dce68f06aacfbf059c4861098c935da918e51f409489da94fef44d9c814935118af874998a36da40e5f575a229a8fa9771e9a9061fda22edfc25d99323fec708c91c1e93d0a562e148258d4e32311f74f2fecae12bfcb093f46f8d548f1b81bb638b5c80cddddf37f486da507a41e0ca036abed270c1e377bc87a9e03d283c03165696c717fe710870809a0ecc38b9735fccd911074b7ff89de91f30b6d9b87ccd5ccb3261076d67e032149afef0ee76e70f8b8a60dc2c8bcbc83a4cbc3065408b529ebbe0c1ec58396afd2d3c8e38101a15275cba0f949e7c2e4a2af8fd701370f5c29183af8ad266440cd9aad51a2cbfea6536fd72fcf77a82c3f1d77a386a5af293175dbac299f61e3e1e205338f7e13897668924d2c0036f4316e9df6d05b9fd261e18c583925f194f5fa5952a6cde0e92513308b587ac2bb50dcf247dbb6f599f32c67b2208d8e55780257dfaf73ef9f7560431968fdfbfdf2e5f839bc7a1b31be1e958cfcd378347576099cbfd04ada1a2c576ecdd53abc226cbd33fca788b77830c9752deec93dd785dbbc86ad4aefbfdcd552bf7c203b54088b5fc605bb9efa3dc5366f2c0932294b19d0762069ebdfc7ea01e812a862cb0d6de1140f91fb1de6f610a163bc40692df22784905a1c3dedf813cee50f0990b58ef3220b3c53376021da065a8038076644f4e887901dd8b99507e9ab4059789c7fe5a995a42631527246819fdfda6d2620fde0b07a6785e26dbb5a2294e88f096c85e6de402fef8b476ba3f0e02fe7f6a0db352ddbda748ce6219aa2ee2fe8fa91bebe314ac6247aed77fa87a34fde88e81186652f27261c66edf33e46c7a41a525e38890127cd3684138119e402905ada89203a6d0d8baf1397c11bacfa6a1a229a1cf5a2703bf7b438dbffcf71f17351b1b82e54db66b33834571fcd261bb9f7e13228d55dafaa4e74ee6facf606646ac6f37ae29708412f63526616f1d26e57576a4272e59dcc63898b53ec555dc734c483f23ffe86fad473a7622e6004ca6ecedc80590dd3b804f1364cd95b10152b7ec66a9a9fb90c9dc0ae1d812061507193463715d6ca0e6e4e67eb2301096bd1211d328416ccce56417456f0da711429189e0686c13dd843a63000903606d16f59f971d2ce0bd262b8c7d7e48d4ee81ab90175c079f3000c1219185d5301ea41ae4d8666f1a5841cd56ff28aab0b31e8a355c1e35fec88dedf5c64b0680412f7a10db057295654f7647df06f091b3474bc31445662925583dc0acf39a4efcb21d8617daca99ecc4d72b9df27aae7f23badee94e1eb4f9828ceddeec3225e1721674aa5fc1cfd863dad75d1271b3615e2243970614ae414043d14aa937c51cea8770e103433caf843a3e99fb5b9f3d08f1ab6382a03b7deb986943b561aa13e60561bb33a69f747a4bd4ad38fb2e26645284313ca3ed796da55e6bdb6c9243b98e98ff9cbbbe65969601437268ceb3c11575d28a1b205b34dc63d5af60a3b952b6137d47c06f7ae3df04f966461d917f294113288e097e05edb7f1a1830dafa62de9f600eed1dbc2700f710af2b22ed5e48cbae41a0289aefd2164e9ba46736f52d5a1a98d7e3c3a77d0018ea8d1af035f8f6dfa989620343858a820af1378a81a801eeb9c53ee4a0c499ddfb9b5af733e2b93007c3404ac7a292b01d4f8fd29534dfcc91e5346ce3d6d34d7a25d3c9f29b2c8580cc50edee057dc2e9d301d3a47e25d61baea0eb60d1475bfe8f5d1404b02de2c2c9bd35fc59a5c4a9dafa11bfa963b13dcaba77f5e6b1ee748e970af4ba26df8d61fbdb4e3e3f9d3c1451e689c563e41d7b5ecfdbbcfad1c6a589b0da12d4b97553732594f607a62cabb9e8625e5013738f9ef3483176ee65a0d8290a1454c007e4b9ad2b540d4aed7eb555302458dfbb0ebb92004f01e9227438600516096f37972eb2780da3f275c1d96796fcf28122f70d2a3d0ed2a81f36e31f49e8a5a389b381cf7947794990d1376c11d1479b48feb18934a6c7c3bd8e459e1cdadca096017baac337cbc7d0abce490393ae29b6f1046ad0dd8d21efcd2dfbe48523f3f2106163ccd46535591d98ba483aa2655984df44e24359d4fdb453cda60ab4dbe78e72065c57de9affe466e80254f80f4f699000c9013c9ff7012cf7e3ded0fbdc6df30a3e1b4c1759f48999f2fb1982d6f9ca0f9d301daf994081e99214654d99f6b94fd1b7cf4a566766777c636cee9e8aedb83597a72835c4ab7c58931a746c719675c4043ce47d2da5475ee95216db8dfe16a063ec55d1250fa9b89c60af9164e36002b68e20ee6e25547ffecf8b8bf32761b546d37559461a6f55ca0f038d4b167c2c56f1c953fdf59cd9bee76dfcb5feb69cc5fe01785fbe32615178f6a118f192b0effe3b9196efa8e5b4e7cba783d797a5eb051b0cb6331f42f94ecc2e33dd4f1dc3eda62c304555e6433d1975b3548ff8cfe7d96ee4feaeead17032c422adbcb56d2d12651bd6ca3694089b0fb0c9ae1a931425b2ef83c873a0dda22c44d3853d876e22a2cfcc8b210d709e383f04f9d8cbeaa4bd1e664be4ca8e59a5446a3f8debd6ccba9c7aba6245785d3ec97c141163f00ac1dd5eff0148e41226d1692b10bea590b3a489ebe57e70b28e8e0dd1483f7908f04258d91936654f4300689dea495d296148fa106ec5f726b6331873db36d4bf9d2741117477aafff700d3b838daaf999d1704fa2a7c7cfc383af913ea9667b723dd4603a912785ac1b926b8011c00288f060b71d56a6589bcace370ef8efb2e5b01b271f6c5b1e5cf3c61749daad9ef0799b461c8907ccf088543169b983dc3bc795a17abaaf9bd197c543dd2db159c1398f3bc3e9a12d9e5a037625c812b9a30350953106e050f6bf8bfb219f74cd47f3af16b111fc97be9272582bd927fa8136c8926619fb9dd7d7737106a9880526680b341894c72246f343e1de532a3907c4e24a1c4865ad2b9cfb3a8ffd06d0c1b699f0ce4453d3ea4f28811e2c574ffda4c5a7237095d5c8b1265ee45575b017b3b5364c16635a094d3393f5e3d3fe37fd4977570089c1d73ab80f4fe2d86733781c18e44bc56703d0c2a168a86511a1d0641aa3b6354898f5bf96989fc8aad9b0c701b9caa79542c9878b0846f04d05e45c72dee4c367a96b18dbbe411bee89d0a8a754d1a9147ce86c5ae6cfd5cd215559437807bb08f6d93f37a7adf8b8c598749dc8d30d5f979232ba1d6a5be4eeb9b5340f4c0cac2290bea8aa1a81d18b0a127053fddd901214d62d95afd0574469564bc7da1e0fcddc2e694770379ac85c31c405ecad17ae026c0f0974d2b2dd9575a6c0f64d029a0c30ece0bca4f4a8dd790c86e8407f876e6c5e101ea1b33b89114a6cae425988268b67085bb8e939e81f75a946ce7609d9e62796c4ecd42ea0aa569aeaf2aae5c134561771662457e4466f220e35941294c4f8340dc9ebeb45a2b489b1feaff7cc05bb7b9de86930228841b367b3e5473499de6e91136eaa591848b575d1378cfe4cf5a2162a76e4fe48fc107915d31d2bb0e73e8f076327563f4b37a5360cc8bab24e266cd45b7d043738224d49b2b57db4565d19d881e2d039a38ff2927eda87d40567baf06f55620c087ef3aeea523728e794759adb54413dda9d0d36d2dd69efebb98d3bb594581371a9119fe243fa3e0b1757761685ec6e5ce279d0ff9c8d2677bc418e132bed00b88b2b070dbf2e121d05a560715d08e8141648961f139b0ee6b000727f640eddca90a4432a910e40522811c24d0f9297a38d9f63dc9a1daa68a5deb84059e6d0d67c650a192cd28d067168fd757dd972f1bbed86f2cfa72b3fd8361af17d6d4ca8440da0527c41554a40a53438d79c2578b69ae0fe16df88cd8978632d4bff3882b584ace190ad80a2f9d9239918e4bc15e4ea1bbd3c6810fdeec073ed9638ff9d8ae326e1d7136ec748686d55baa09b55b23da8b52d91c241ea4ab3398b47de51e8eeb89afa6842cbe18dfe81913fd24c433ceabd0036b884aa564eec4842c83a2d7e3517aed6764c565f56507f98e0b863ddad1d765bf4a056266aee3ca8ebb8a15e1d76c4226928cfee928f7d61630ad0078dc93a4a859bb9344182b50dcd4937be34d0a33c6bde176322866cfbd3b86933f4763476be72de2f998b8d267cea8c8827a8bc2088844f54a3ba6dc0a2350fb4afcd2ee74cc95bff86a26a6f718caf675eda5cd675e139a2b780ba05d124472b0fa8f96e5725a821e3965abd83c9c55aec5b9662ef57123f005272c2fffcaf5ba41a233f6320003e4fe39f59cc8bf602c502cca5f971f5aa94808c82679883845bf1b3de2f04a78d027433a290eb7737d5a7ee040d90e79cc9313c7104ce7fc1ee36a697902791b07bf01dd4beaedffc3c8d0bd68d3fca073cac7ee85c79d1f38245ca5732b89283df2745adf1625bca68b025cf1ac7fd456f1dbb7aa9b668363d5b1d08af467fece5f34f42c18c83ab802bb9c8e8821170e43347b763e660708790886b762b67f0f6bd467dc1f7cc1b76eadcc5f4f84f517e98d4b67f9a8705c7e32241b7ac1e9381e8ceb6e7abfec3b4fd8833a51388437ee66f0c33a64ac2865e47537947be9f659607546ed7514fa7a1184e485159a285f3932dfa658cbc8a0150b308dc3614a64779a8b790ae4da625bf7d5bb9aa6886687fda7979be921207c84a8833fd77ea3f39f5f679e07815c761472dc393479d1f60d2cb1232e336fa817b7409259ec5c65c3b6c6bf841f2e9c353b6e3a56998a4aab81822625af0679c2405438bf2ded975cca20dc627922ab5202822dccb8c4bdd626a1ce7002e298006fe0df233aefc8cadee9f59920a9da7239ddf9ecb6eb6798fb5110701e3fcbdfe9e9fb234741a0a4fa2b407b23c623675670d13f6cba8b1a17f509a0c4f90e88343e8dfbb803bf56619c92e0938e45d031da4f4a450c759d6024b0390b4a6c9829a36bd62397075f080b4ed91298f02cb96447dfb888ff28ef42b44c024ec84b4ee9cdf29baba73b085cffa4aa5001301046c2a535e8e5b2f150cf3d8a770044ca7ebcfe79ca43a7ffab2772f064818f59d566383cefb61a5679c38b000de979a02ae2d89d6ffd1becdb4b5fec7b15a271a06a7d5c21e55d23deb5818d1493e6a3d0f610911cf59e5808ef332c94d6995e3a60b0e60833a39b7bc2e83ef8a9e8dd39b796e6de0abf361fa9dbd24dfa2ae57f3281f2665987d9b67edc7e50d98a24e7682102698d9cb764cd8c34d975cb9ec72e1f14ea9f3ba7256e387d57fb7e320209d578bd0f5af57c8d71dfff7bd3ecd9e30b211fa5194697ebde9e345842c1eddbe73a33c085c25f8957371730ed9b8337319159e88f5d7a23b593546f53178bb93c4a776f2f2eb00deacfd318e11b537d2ab2de0868f06f41025d0ce39ad9ff221a70d1ea59aeb4650c8bf19847e2bff83cc34145b2510f5cfb04355e7e2329269219e7ad1549c7a8c2ada8e120696a26ce5dac8eba146922290486e64261e660b03fb43116ee00e7af800981aa6a5d8329a25f92fba429dd92cf7fa41d8b7592f5281842eca58196c5aeb0c1f58adfde6f1ac33bba2bb7d2072fa11c52509c75641eecccb9e5b8e8a3bfff5b5b6ad0f075e1f1ac1b32f75e8d958ff721a8682e7aca175bb470aa25f4dd1262c83e47c595fdc1eabe8470a313ea87501b09b55a1a74d9a52e038f526b1274a7ed4c0f2bb6832ef67cb482ff0fbfdee4b5f76c9caf54fdb619ceb0a5a6d6c1ad1f785440e0762f36b311eb7091b6c4e7cd68d010231c51ed519a662d17b0d012876ca7c88a59bdf765751abb5409904ffe33ff70ac1abb28f572bc6a4b5763c9c468f9eac75a152097e099d04b2d712d6ef768829d279b9db89c54784f33ad34b713165cd3ab5afae5d99b6b3a39ff76ba27559abc1cff8e69b630c1009b81df6d58d2b5e596aa662a4f22b9172bd97d806df273f84cc7e57a6ed1b29ed162b1d26d75b72894eb770730067c682f6847646a1c919c7aafc010017d070301a4347ce72c3e54ac4b5234c82f9fb916cc830d8fd7120993166a3314a532f0d5be715bf47e5e34ec7dcc2f4276d83d540414e26f51509b2dfc0e530ff91b529932149a8fb9623c5f48670f36c45b45d251c3e74f797c0b9067a50197d1fb92fc20e0e35528bc6f69f53ce2794facbc826d323382bced0de98a4fad3113c34d853778d9f21adaf47586e7088a05e7100d9d6eda3908955b29d465032537160ca8905e5790a12d4823ff9e7c8a7a969d60710939ec85668573dd637689f10","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
