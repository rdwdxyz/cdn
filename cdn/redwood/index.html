<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4b23ee5c5a4b55e81b2721d228b523040113456e488cb9e1531a2eb25694bb25d60c79467e6c1a3f0b63a96ad44978b4fa32b9e1c84907595ec571e8d66c1d247094722cf822851b9282affe41d4094810549e7403bef5a13f46d729b4a29029b5dc36ad8560afe807c8d028d676664db1a8279efc00e03689c204b617a9aa0df4294bf6c2e2bf5b6f2322c7faefd82d29e4ac2c2e67438127b0b336c4af44c74a9f439d204af0268dbe67dea2adffe5355d77a5035d8f9a23ab89031ec26642d9a57c32b56340b282f059337bf65e4630f5df497f0fc3f31755d7cebf106aa05e472ed0055fb46a3def990929bd9d7a7912a788e301bea79f3321a4a4aa66662189e38768ff25f0dfcd769eaf308d9f7498ba706c51403e79f86e461cb327397509eca5d8acdc03ab0eb5e57ecb0b26f89882d872316ffd642b1e037dd48e73f03e6b464b32bbb7c8f290e8534cc06c0d45a78359d482fd35ad524181b968a1f975a32adcb3136bd612663ee4ab76f120e329c6dff6fca1b0550e92502ec9b9328a00fb31703b4d56eee4718f1cf7254c6b746cf5e95c40c6847e7ddf9093ce3f2bcb34be8b8e740f174fc4484bf371e1dd2d9d78da631c7f6a087299f1d3f6239db1be98df7e62180f78d5b1ec03aef1a098ce0564b670d4c62c81a9d10a75394179409625ee57959daf585cdbd7be018cad87095ea9991129ef9cc56db56cd6e5dbd9bd7d92fd7ad7583eb8aa03ea97f06512afca596562dd213e616e8605bacffee221616186fcf1e28fcd432b31b57973e4ea666cd50c1e3c8403f18d0dd3c1aa94e40a8a9249eb99178106d1b15affad83eb12b685369a70c2bfc0f94f629539ed6369e6f882f0a806a85a0e9e89737212565f47a840fcb9e1fff3cd8a2598c637e0aaaf04757c5cbaa8e93a56dce56e79e619c85c5ae360fd6d37889e2d92c1a1000be145b3ffb67852fee13e2e6698bc16f32120fb076eb67f898a8a9416b7fc16a158e0be3fbae81d9ea00bdf55b9623d0753112e4d38e67e65830c02aed2644c78e3f3b867e64853e6ee7c93682ecd8b627a595adadfd9021afae0d69e5925752321612cb77b074f917025d7e5f6f3723e3a1da0cdd003eeee5998e13a555c9f4c1ce1d36987f2610324d67d407c6371af491b7d6be6455dee0b54a4eb9e21715b82c26116af6f93149fb1b461c1ff7e80f9c7c516a3c751cf2c9043c2c27562fc2d8c9ea0e12d9bc931a76b34ebc430a4f9fab7558d717218ed7787b5293f5d91fce29739f7dcc81f41456221507eaca3b9b84e3905ee711ddcd346699e74ac96cb9d08b3ae27c94542e2f133fc1675e56d13795100e505ea1024a8ddcdf78f7262c4d1cd9b925f5db78b5752fb51077eb66c0e2bcdcaa043f3681ae4f2547a87d1ab9700e66cbd442cfbbd75ce88c00dacb4079700552c26c46cc23b40e3b5efe0e3a03320ae15c5ac8151289d00c0d969038563cca09ce3508551c6c71c2e52d219f9dc272ee34194987e37dcdd01f9a2a827703eb3ce402b8551c8709ad628ecde2fa02684a0fa465e9c70c9259b0d1712a92271e9adb13df91bfd08ab9c7d3a86323a23a9c93a64d142574a506019602519ae67d8641832103ad37abaef862af2a59742de070d0b9a147dd76464a9da5097725ea3bb145801db2638c1ae9649374e246e4ed04db27bf7c6dd106072e048eeacda343cfbc1751cd63139bed258956bbe024de3a5c5a9fec55da97266e4bf1b2a69e5d4f560cbc7c542f00b5eaf8f66420d38edbee95f73947da3cc54d7b24ab03b7f00231af853290ab3a130629b5470a3570cb4339c41395998ca0cc8a445fde81f03f50003dde7ae73e882622556428906164b18a33f56a6cb6a8cf0c88a5b6bd02cf38eb8761da03eabe9d231ada2854ee1807495bb81ffea13e9c134acf1c2ef3318067eec226efc45eabf0db8214c0df500fc17bd984a72cc1c08b26aa16c2d327da1cac94d25db84915843d52b03dbb1d8a73f5e2e090e715b9610d1552473d08167b2fc30d7d0f3f68417007d94ab4ee1d1af18271a423415347fdad6bf4210270d7c99cb409640ae3702e6d60db70d796faffb35ed52df99b69888a4726accc9313e38dd91158b27479a1ad23691ed70aad1c491f24a857dcd78202aec762ba2248ca39a7569e023f3a1874c885d0a6e0e970ab8f6b5eb18bc972c301279d6b013b3121256e79e059a847086c188b18f2257eba79c6b151a662b027a216f6ba3faa3912eaf79db8554a120e94c6f88db47e960a8a8ef5eabb8c017ba6832dde2e155be1f937daadfee8ea88defa6034ac4f1d2d590b474c49c84fc94eb26136d4c0d49f04fbf4c949881dbeb2857ca762e863d661e538c1cd822f176b644c6cc595a33147ce4ccaf7cc5ec09038c10884a31a4ecd225d66e00a12b5868419d48f769c82b3be3011ac0dc8cd154e2a20e60677ddb9f188b08bec46459ad082c1116961b2077b200001fb2aab30604ceeaf076b85c92164b10f7060883cde6592987c3600ea6469f385e9f05a12cdb51b3bd6707593047ce594e113295656d2c104cb726e5c57d201e7a6ffaa5f991993c2c844383ef01458ab11ba809818ed22bd543944040c59bc37f450cb153acdca5309f257afbed4782206f4a692fdbcf06486abdaca3b3113eb8d832aa79164acefdbf6df063f99a66cccfb5edb123e094b16a2fd1620b676d01b5bf12723afcb62623348609642431ddbdda963a236cd21991c624ebc3c22c16ac636e237fc26e87fcb7af7e6b715a718e21cf52c4f081580b7e163852e1d2c05961003298f74f11803274a31c43cb36dbdc9432cec6a439f04a5efc9acbf8f3ca0f7c000fa5d38d675ec50907aa4cc32749b83f1c5db1d96f1ac42ee74f3d5c08343fd290d132410a2d68926f44e17c62ff2b9cb0c9df0e6372bf423ca7af47a7ec58c00a9368c7cca527df407f1bcc8b7e5705f68ed20d767bbbfbe832063ca772edd57206f78f49774f17dce053c007e063565a7c2d9e877caead6df07e14b64c049a576cfbb4847129b91d7f255cc48c8cede4add2d3a3088995b89a91fe3d7539c030d019413a200550acba9dc9756615293084f35b3f9f461a96b72a39d1cfffb5db6cf21d70f2e37cfee8f0ca4258e514650e778f665dca94a6f93b6ba27d34832a942865581655ade48f0379fb6a55ac53e4279261a56405e82a3ffb9a82ad7f04032c0205ab5c551019d8ace094aec985272d0597b044088efc2d16e9e7f7d287ec5ec0471be359d5c1cfa36032d9fc91bb1b0506e08dc87331909cfc344a698ccd5873f201128479d4f449149ab0d611db473738541a8421ce021d7800d7cc6f479fffcead056b0c17f53caf7ed97736db324709bd1299dc3b477b2536e04af87bc63b48177f08d74363332356114c8267c8220074bcb34f38f3c82c94b9d9ea7fcdb493deeb0bfb71280955787ddd8620384f68250d134a0fb49a6fb312a93400ecd7f42d186db73c2a405cba42abefbc393642da96369fec5ded19aad6f71c091a26c93dc9798c82a13f0e0828847fb0d4a91a88ea088328cd684b80b2af546830eb2b2c3a85d77a26bdf49ae10f6aae0b07d26981085fd9d724ae1d2ed279690295d0bced84636dea98fb4dab841128bfde1e80cc71c93b3348e05ebba0a616f1d2dad42d1a2dd47cd740572bf80447b607c3c8d2d92d8ca556e8b8210a9219e86f38e214e7f4b43907273989ad88f4001e1bfce641deaac3e0fc6c73223f9be88fdbf2b5bff278237ecb5f738ed1377b6e98120ca49749e0a0e7bbf3646d86077706d3b273bf72c5ee9b824e8e1c58ecd5f6c602ca34422ac3c8d8b25bb802fd2d266abeb9d1cbc845179a130fe15888622cf6c9e369682059e13df769e3b0ea5b4410e9fd5df037e162d9f224787a21e74b68c1b8a2a2e2f1bede93764395fb7b35cdabd86c06caadc47b133ae89651a5ae158b31093878ac4e8851137f778922a4238730cdbb3ad21ddd40aa3594b7822af48e6552f22b8bbe323e29b3fdb91bc5a24e44313e0d3d139b28f743ebab63395f83f830beff8a0ee63274ac3432882d701fba58955fe084510f5a2cdbac4e7982579152cd3b9a2cd24e27266e62bbb8e5ca98d8c9f3f714b430d4c4a2f6123751e5106c02a63736ccdbeb22337f6308b7859bfc8cc1755c7c7b6604a24b89050c209bb5485444b602ce0e89d4c04f58463b304c5d7387d8feb5ca240680c7f890a531d846cfdd93d81b2705638aa355fc345f4dd02f2c391d6e63c24343d8333053220f6623aabc83396186b621ddaddfb81a6b150c3bd57fe613a2f744d84e8b6b1b65802e26ea0d5e38eed041ddb1e07efde2e0fbf2c3495260f3ff3039c69f6e036256a81cb0d7f5f1eb624f1297f8c05858685526d27204408e9ae6b2dc16d2c3975e73af55767fd18e6be8392dfb47a15142401ec05a667fefb446e482760ff7a7a015ff29135042602fafeddf5a0d8d3635501d0ae6658cc05b49cfaca120518786da6f8478d9594c070e3f191c08a29f7a50af007a5ac5710f31483eb2c81229a350f534c9e3b581d5dce5dc3a00cbad3bdbe9e3f34005b2a77444b2251f234976de83333a13030538dbdd48547c829e1b0d69dd304ceed4407238d55490565635735d686dc618af97d8cc992fc837c6da373115246f96dcef9ec287a807969f0579829abcedfbe4a5b88e27e08d1c89dee9783886ecf867b0203bb5a1936a176a1c48a61b88cfcdddab20248a54ee8c5990e86f80f958a74b220c22f181fd5acd57746750b8ee5daf31e8ccf1e3639864bf32a097f93e459a78142c911ba506d9fe1ef84b69956e78a53a349b5c6588e9d9a3e5aad8123e195515caa334c2ed3ee830be1211958743c413cc37710f72b923fbe5f879dc455a0f1f63cb0ad12c7e1c3c0e4f79ef77be95f91903d96f0772d9618635f3b56c6bf0043a059658bfdd200b816daad3b26a3532969a0f1b125dcf4a5ccbeb27b48b2b510cda61e134750e79b409cc7e06db5a7604b2c990cfc8be7abc640aaf9ff8b14fc876c4de1c6b30b0f068be8864b210a1af4268233b43278f039a8067a0c171b769e132ef5cece6a8008f048c83bfedbab3fa7be81aca8115e7449f1ef968545580cf3d4c48300a4f3770c9622a44598ca1b2dda35606703a9a2ca712741173bdb71104c57dd79e0cb8d7297ef2c9ba5fd70cf84f8227aa988cefc9b8f16c4f99b618031ab8d8d53d58a1e1c933ff2c06d3d0fb0f968bccacafa95a9f17fe53d04ecef6fbd28db03780eebf1907448f96e33ef20f6221fc442a402484e2fa0455ff2804c3714079ca0eb42b9956d95dbc20ae1d3a03bde54bfce851c51fb24231b7574e90c0ddb3e24dd3b591bb8e2aa639e30bc5fbbdb445930be1999a8413aa975b6e8f0dc6e5f567a404c3da74b422148ed81fa1148011eac627aecc134a8215d0715781d0dbaab3273dc82ae48de288aa41ba51ec883ac82cbca81678587b8b473c4e4722dcb8ae87f09a754ba43e71490a4e2860439827365e88fa3c5e20b8dff5fb6a38e043e2e0e555ad993e0bfee2b5d4ee5865c329ea4864dafef3d12572a4c66a02570774b0e7d0c9d3e6be52281a506c3d1689b52bac29f9c502ca2ebc7fd703a3a94e46a599017ba337135ab51642034d1d76244ea57e5d3eae457386ed4b2e556e5ede52b90f2062f521eabb2df0e460cc0331464ee61cd6589e1f124d09ca7ecf81e0498451e9b3c932f898ad06b37f990a876ffc940cb014da54e62c530801dd0985fd0c44c8a9a0bd643c8dec1d0573f352191f1ee2ad8eeea5fd1f48725f240205cec255f8ed4f6be03ca8becc798d30d67c190dcbb41764483fdb4999eaec637ad35d2f7fbcfb1102729a89c948a208f782c4b18e019fd500bf1dfe64e43553865088af969e254ba8df8601cf2b757e246cd0e8f9bcd57deef5f52ada826bb851d1f9484f5fa33a1dd7de46fad8bb34a5779368005d2f20bae7d2320bb54ca31939cfef4fed21b9a4aef466d1372deea029c3087e843183ac70ccb0ecb7a984077b69a60b8a7f212c4c847bcd2232ee2d77003a934519aa31c4ddc29c99bf937da5ae4c49c8f33879df664f058f73874c1b7b3f46ab411f3169e15524c4b3518117ecc014e2a59d7ed2b8108263fe54d468b474addfb7b9bf5d3d056a368b128cad4e25078abb583c08d9c3f90324a02925d5da4b42103c1c8ff7606a9f07c80f1c5d138e017a8169a2586edc65966f5a14aa0785d654c2f2e80c2e57ff1b809618d88f0040cff2c5abf9ac4d18f812f66a6a47c1dc39b4869ea29001b6458540edaed980a30cf8e593dbd8e58eaf0ffb4cf36b20c7cf4dc2d2054c36f5e826712098ae25fc7afd04d91f047430f573a23fb80e99d1fabb9ca21fa6c3a2d6698636be2315177b647960fa98b88cc6a7262c3bdd4b113b613aaf383bc0e869bf16c9c549560aa11619900d72f30c6e06e750e58208b78e56013b42743dbd9bc32f91f3cc1e215d263d07fcfaa0a4ce8df2e2740d170595f6c4b2f30480efa6cdb3db39fe2bcdf2cdbeaa54e93263de9cdce505212ce4d99df1a43bc8500d903502305ba305a2278272a380a9d9f7703271d704f65228649b65bff115749f99d2f223cf4e3a055a4776aed1c26baacbe3fd53a1fb33d40f9ad44fc3b5e811685b2d6c1032187a24637fe26cf284957bc5e91a18af0ff946243ebcd3d1cb470c2cf7b233c7ce8cacf38ea54c1f3b8797c73d71a1955d97a73917f2414de74f1caa21bdd3fd20e70fdf7c3741c11d21a22246cea6fc74b38455599883521ce251ce80e98c7bafd1535cb2a70984d845980552d943d5bd21b974622161625bbfe875b1a5f2997686c0d469f64021e2573188f5ab119932b0b328b342feacee2f695fc4bc3e6c61b2b5ed6cbb082bb8a915f9060c6691f47b3d5729402df545e0c487f71140b00688163c93ed7b6970ecc8fd5e3dbfbc117c6b6a3366bb84db61ed496c252ad5c67d36988b1ba8693bf456402bba43849fca03c344189ac703ee40a25c84501c03d2c1c886d5066885dba31f614898e2943fef8d91a7f3b8b13deb7c1456d44079264376c0595a967324694ea71dcc1b3bed1024492300ca1883c39ccd7488771548aee9bdbf01fccf032aa9307ffd36635e02b53fc1fe77fadebbd2b175c6b19d790f812f212ffa1b5da001047e715cb671c0968a521555a1a09306114f4af18d8babb2a327a6a8217ac0c33d54762868e8dcc17b1a0e1b8d0cb0fe083f5f5f93fa18df4626df385bf635120f75101ebde7e45a0dfa7cbdccfb63b0cd44025adc80a011625b775253ae36398750cae23c2f679e2139bd0489d7e277b010d1f98a21df5e4a6c8127195c1e7c62924d9fffed528c79c1c2386c60407325296e96ee70059685367fbdd6ccb4634924f0030bdaad49cfdbc3d25a2ba3c48f22b1baa96057e4b3d67cf0cd12a3cf7e4289e317a1ec76fef028f8ebf9f74e704390b6d2f447a483e9205eec67f6d1be096346c7739dd567d0cf4ea04fc6c407739bf707829a2909aab3d7ec66c5ce41a61a39bd160f86d7ec51b7a0fd6874b78e71b5c4643ee4ecae6afe0c7c7e00deb8b01e8563e4a97f9e5be64d5e7268c2d771e61190e059867602bdde8bcc9636a56f0a824aa7e6c353b4b87ea00f1d98bdef914cb37efa23558a8f8ad904f985749342ccbd04d93e7d368d169404478a18ec895b5afb0f0785d5583ec89e4f1969a6c5968106fa72322010591ea18ecc1a73e69a8bff04e9675ac11b97766e2977c47406d79fe2f172b600ae726f6cb73325e626c72a3680b1838ad49b4f1484141a4baae668049a4d62de932edfbf1c3f304259f1588152a917a54430372a92d2abb9021b2cb82cc478b020410d4d0b60b3eabdf1498a9a12763d5948e635c66ee5ff6def421de2efe2394e6fb69a77f5058c13ff448e57565c50e472a20444b631f310a43b6b39395c7c7f0e6fb227c7b3fbc4c9585e0520209afc7a173585d67686b5ab60b30be9fe79cfb0e0ca3c5a8322b44ff3c54e0c4f8f4aa9df41eb103b6fa9748d64ee1eb488f65026c7aba5b4a7e320db3dc055da6fc30cb67456eff48a7d3247febc186d0e95891cbdd35426a2b8eca36f263ea87d6ca5cd6164f2ece130aafedca39a810c0d6cfdb49625967179f558c65a0b80e8b1d119a8282e04fcac598bee1cb2e6ad365612f8867045a4fbd6d0539e704ec870673ac27448db622359a2336a4e9f057561004587c709081f3e307ff523ae01adf45a88896d6458bf245ba24fbca128d30f5d89817ffbf3154343a4bc8b7d10802b0b8790b79111d318889274b2bec4498e05e78558704aef72142babbefad317e20ead6b85d1b7664de4f8419c3bc9f40fff38285fba4d3c3e96f528f98458e0cef018234a815f9e94c1a48dd48fd608bf004d56246af5f18fe2d8878c134e0d9ae182e6e837a2ff5625739f6464dace9384143288a8b1050fe3e0c7dfbea7c2f428ebed6582d1b45973dda518fd3b73869a764155c1104d350c403953a8d470f2b983c763a6616e467f3b64043f7569836bf75c7bdb86c0ca944bb9eabbd59d97e4adfb7c22c24965d1c2791e4ec172de00a061cfff17e282d7d96bd9b1147f3985547d49ee55d1fcd0fef9e7a62e31a1c70e30c0eb5d1425bc9383d3cbce67e5e11e462493c353b5a4bb011e4f49fc5082c508fcc38586b027597590f1862b86dade93b196fad038542a36f00144a6ab9467ef34c79def13c106f718dab0b0bd2f0161ed438e80590fc4173fbef5884357a495d913d64ce9fd7041c9f571ab95347cd645282d0f8a2a6ca66a0cc12931b899c6063021d2cfb3965ddf0a7b140d517782ec8ac165290a1f775fd0628346656584cec4517885a1a330bba8cc7b0d490522da69451139bb9374a11f3df8113ede6067da839529972ec0c5ddcef8e5cdeb6197c74fa062fff18f244313f707c8cb0edfcc5a5baf1aabe0f3dcef1cf7fb44e86f920530528a34c1d48c04ee6722bb4612d9b1a7abe0ed6671779f2db7d7276e2f841a787f171c08112d2bb168f77af3b59ab8792288912fc489567923e5ee22bd10f8ce11ec3cc734333e07b5736b52b0cf8cebe2f48947fe6ab24d64ea19c83603a4b6e36e04ffd0fa966705b43aaa68748360a1c5d644de6db770cf1987527b9d19fde0008fd6efcfdaeab92db9f0cf0555e924f87a192d7464ca57a03f828771d5bcfeb7d43ce43974aa13c0679340cf10a96b4828fb0988ba89ce2c366dc74d2b512b76e1ec1bd43c738ec357bfe6565f5b7c4484d3da0695e64ed56c1b3292a8f8528fdaa549879b4becaeda24efbc509c2ec2eeee9b3252642302554b120d39cb91b24fd6ce020ca531afd0c33248a55513f066fee9f45d8633f277d7e7ac29d11f9da8d73650f462f6d4922996fc705eb9a4ba71cf5aeaced6f9a7131788287945a9932b0340bfe22851b6279a2c6cb17829951a700bd092ae41a1ec56e914f74b51dd564b71b2a640f008ecb7915bc500ccc81333e6d1de62ec7ccb4077e3c9d2f116dee81bb4b29dad61e1e53d1c99e55ec9998419f08f3058cfd8b2e748f63e814c98e73dc9a8591effdbb8eedfe6382bed158453c3e8da840e71f18217d55ffd8d41eac772884bd9f9479eeae7722de27e5e93bb9dbb0d9f01bdf0626966576ad35a06f64145e84a3a814d5bc9aa4f94254c34dff4caad3730154e14f0a8cfa81471003e48b7e589ddf75c61932ee6e88342679462ab3922b9afbc862ab54941d9d3a9aa62db23e7a988d9d9aeab7602a5c26850bf304351e5193f2be85481fd10aab23b3733b602d01561f67b1b8ac547b6d56b5529cda5b5e5a5a9ba0179e0926d1f5b6fc0f50176c5272126305e54ef47af45938a05a6183d3acd10893a21847ee1090bcf2cacdd96608788e4f8b87c95b8cf726ea50374afb610c51323e6f1961ff8e205039265452e0dacfd9be237a6051cf33abfd3f2009c1f57ccecb8eababaf94fc8a7d95c3c32e91fba8358bcb1627e88ac9973e0fd4ed9d3a8045a4b625d3eb5aaa6a44f2f407f8c4fa8e86d34c8f6aa8307dfa0cb3bd26e98e3fb12fe048f00a8a60e629870495236e194c6c25870a3a755a7c2b1bf4a09ef9f95339a9f599ada34e8348ca12c0ccc3b9d3f31bbe8881ca26bd8be6455572fd69ffa56093fcbdb0e71308a4f0c0e610ebf3054fce261efed2f062c7b78694d1b151beea8bf7eabef82992c1291b9237f6ccadfbd98f632d43de6f2d95aaa4a392f2dca121b9802430dc7899a1efbdca18c9d9e9b008cfe7a7010a0bfe22c9a8073a921ed589dbcdb9cbfb336ee09f0a0a6acd6e65153c45a74dd1526eea9d2efcfa7f1f70427570099474e1be123c84d08337f29ce007aaff4df4ed173101c3021d9d4f22052c1fe5eace1f422d3014467e64bfd1d906bac138baf97b44cea8c88fb95a86eb6262c5eb59280a46d0ac22ded37eeeae7ebf156e8047f5df7a4281c5c8be76a4b64683945682dfd67fdc0fc1d87266f8459a95d5933690a55b9b8c53587c91ddf97283101b6d4fe8682b4b7c4c05b34f6cfa5a9104e95048f0463f5c354288af1b40ad87b5866b25fd17f009a34264613dc7cd95c3a602614b4ec3ec2c44489668a75276590ca3ec739e89041365239aa2260b33d8c0e30ca6f8d8cdde33744d2c415a0bd1bb0844655283ba1aa37ddde855ba66255d6297046abbbceb3f28622f7f5b6f0210085f7e2ebeb460e902b7c0c4fc5d4f3662ad2820fb91c5df61482323c90833c878dec2500624765bb0075f8dc0debdb851bbd954a4bd4811150285f30555a0444b16977f7bd57e94b3362135a66d942ef1f097d3e23f4a6c6bf8e502898d58d8a94daf4804456d5112accf31538a3a4cae7bd831c5c8124a4ecaaba79ca6a79e33349218b33d4c29f05f3a7120fbd14159dbe061c8e2c53048f72f4d80aea611774ae18ef67d402e8943f2586f009dfa5f691c1c04abdfce68f39cb13b0d422832826a841cfd3132a564e7fcc9d52bf41173a9d683de5cad989c61a59ca8c986fec214f1e654e2adc090c9f4380752593afb1f30fdaddddbb64c05465ac4e98aadc02105b19007d81c14e63e18da6d76f0bb8b1a2ea5b626647bcf7ad8381b634bc8a6846b2d3002ba8fe3884765fbbb496c248dbe6290037d856bf33007dba2e5d6877cf281ff8f5c76472bc52d0eeaaaddc1407aec45c3e2a3b376dcaba0f7bc39e08eaa94cf25b00b4b9411607dfb584073c0384247e96307ce36704cf726d4e339bea5a49cfcfe6d1244978fc2d9c224e1135819f3848b94a582e86493f0c24f81deb01069467c1ea480516618fb782d53de4c08d9a4141ee44029c2d69e0cc738acc09ecd93f0d01fcda0dcaa340187059bc0bdd64cf65449fc9bf68128d26b35fc28c0febe02c7ff05680ce4a2901639f8783d58531189354ee1b5b20d54b8dded13d2ba6b7fee82245b3087034275fab75bcf2e02700ff84b8e00e2397aad0e1b3d592b098288c6165919baed4e6bb9dbab2b9b92ff400e8330a1fb6642e0fa434fa83dcb1d335b5df47cc32b35fdbe0f3ab0734174c151599c85eb18042f2ebbd39d3aee8534d2d817b165f16643da5deb18ad2dde68323d1844f347ed09041f23af5f543d5dc4e057654f5bc434eff3d12f5382cb1b2f270e6c3901806d36bde0ddc7137647b9c98ff7a2f1b7e2367e821d0b036944807ddebd416ff9360be735d5045cdec16e681dc4bde0fa533fa9966129874e041e9a8a826bc8b2c5585af0bce953d2b9d6270fb12cf3edb80d96cec28f4fd1d481ea92c9399fbfb11d059212140df166cb096484ba56d679e49221f4ac5a992044f2d276a45509138590415574cf73eb506de0d846ec49ee890271136bebd899dc146a4db3969c254da23ae059e0db72ae091294d14c65de1058c2c2a83277d5a57717fcd4271ae6d6fa601ab5a37b2996b0f29645b88c52bbf73267cfcf246de0c3962a5323826bf90215a5f8cd317de4cdb754754cd9b4d5d11cb64e1bbfe1c6264523499285bf52f812f88bce542e97fc49a9ce23a1827871bd2ebcb588c770223e5d061147238ece469f42fdd547c47fbf93d779d67c927ddee599c3389052d9ccb03c1ebb65447463187464037e37da476aa3e08e44016a53ca88234a7a84f23351986711425f5bd794b3caab0df784aa65f91a0124baedce9eeb1e38cbf63aacaf6945470488599ef3a88e630a7ebda67ee1f2bd37182037d27f781f600a530e1b2df4fdd4a426377dc9ef1518dae3ea964e169a99a44425aa5006ef71f1cf7af5556dea7eab971ea2ffb882a7ee2ee97fde64548b62f1376446e893382f3f1b95e0bfce7e899863c3d4938faab375c64127cb16d6bd194b03f019d859f2fca2e823cf83fff46de942e661a92299dc29b917f2d3d650b99ba33af985cf0fccba7e67bc9224dd60b5378674140db00fa3d10c334239a3774069588ab62f86d72fe7a482626240ce25d00d1736aedec87702621e8dd7343489ea275b99216c0b45bc00910445674f91b9b5dc9d787a593a218220b352d00c73fd97bff41cbec86bdd249ca8eb67e131ef49280e5eac469ed40ee9a8589a5012809d87c442c67fa6b55a186ce83e1739e042aa4e3ec071f03018452bf82b36ac1c02e9b5fba8c652ffad72034e8587ba9a553ee318e8870992e6f856f444fc6559c222c20770ec3682d7368a8006a35313165ad912313517d32df0e9939fe1b0c3bf7d4073849a87d2e772cf9c2ce32875d09f89d69ca5812f62646dd89c6d1a5553fb9f24c168849a79d67c3729cde488a33f0c15181ad3ffedee36a494e554ac5d4b304f8cbe612af49a881bbb34cf2440d6145556d4b7c7c6255144f080b58e81b6744ebdfb0155d657e4f2818ee3a51934c7889175712c6e15bdea574e5a46552e036f3b28d86fd5ef90e2e08ef8c0d0d57dcfa908052289bd19ef10126901bad55ef7d4c7d51d32a34c900dc3460e71d1da471db445bfd92f1305a2f2f3ac9a01cb82c90905cae4e002754b2ff39309abfd44583a3b9b86bdd66824f2671e58f9ab581e3021bcb5baff0077d926415bca8f6da0c1f2fbf6ca624e62d8415d259cfcf6a1d9f57e1aff15ca9df66a0829a872bb2ed2e9ed097560f3313dcb2775f06352f0220199b4fde3e334627c2c173f94e310cddb1a81a8923a4b9e0eb832249567553185646c7f2ab65aa3ecad3a48f0224a86710efb86ee35952feaa3890dd103d93afa671f610eb32a62b68fd48d71b0cd279c2a30927996c27d643d7ec1bf8badd1a46fdee5e123127c97c0dfef2c4c0d9f8b50084b0724b6cf002c488dc3fa59225ad919c899d0f99ccaefd9bee226da27d142eeff8ecb77b61b2db7f093596cfeb6d63dc0de74a43c659e035c5dbf4ef7ec09a487eb79be5d0d6e7cafa580e217d40e0ec12ad2153412e2be3f8f16bbaab31c11750ad8b64c3e53272850f26ec0d6b7537fe60c8668314c203fabcfa1ed377c7569de295c92f1f2dcf5c4056c682f6fa63334fcee2769342ea03bb1dd578d1abf09622224a0e7a2a5cbd92ef310dc17751d91289cfaee6a37f848fee505cfc8c6fd56d17dfd67fb68784e67b5adfd6f2d8e7c1b319523c146505f423c095e057de73f34b8f9dc47170ca962bdb12ede0473ed07cb3de5bf278b3dc561746eee1b706abfc8c660296680cb21be7751f5028c3e413075436ac3d175362d8f652cdde8e7d0183b79caa2bfdd1379d63c7badc96d002c3d9d7d19dd7852e3bb6178ab5fb01cadfc94abc45b72f9ba0c95fc75d1662f73294c9bac444835d386c401fe2d27580b11816d0b5b9ab7f7cda09a573f1902b783343518a989c50cbebf01790da6c80d13bf0f1360cd3f4546a339c62937303730ebe8737354adf5c5901d67be9850341df96262e47fb7ebc98c038d79dd5bb717dec264d5be87f63cae9070cb37137e75b4079b1217cd1cf86e01eaf11162b3db3e526368db4b897cd5c38337b423df71c48a0279205316c6109eb08f742bf008f8189d204e692ff621e9e3e709ce8109678f0377374d4877f40029f2a66794e6813d16dc9f3379d414670d00934ec96af8f28e40aa2e3fe48d06ebedf2b596e67211eb5777123ae2263a8678a0a4a514fa8d88166fa8a9bd5a80e0327107cb39d164730766ed56a31eb696b052ee035e7790506dc2f847ad412087de6fa80bedf91133a1a1b27ac5fa45c83d62c2cd8fb8424e104471c4b630c6363f1acb95bc5ff749b1996e16214202d7e0d28b30b66392593eb657a6231a692c4ade60798d11c53f25f854293f41885e327e95c0722a864a2943459f2c3617567f04e74cc966daaefd7065259052b171f1c643e4429077efc1d9388c15dd0f7283d01d39dd3572d04bc65e1b044cb1fb6bf633a036360a8983ae683c786e8142e7661760b83f411d69e8ec2d55f5b3445c1177f7af0ea137f7a5107165719e2737b84ca28c8b16185baf07762b6fc84861f91824300faab463fd42d7e2eee30947c738fc0f732a8c8c8261849430b1552144bd0338ba0ed9e859210c852d3050c33a2cf5be42955d35686d75d24a2c81442bd8c56b6a64eb8d8bcb4cd37778044b5859a70ebfc128d9aa7bf0f2e3d285d0b99c187c7e9d4d8616c4994982f6d3418731eb7a9c59249849fecdb2c0f155ae9aa24c45767c7ba279d85fb8768f8df10cedc02ab2950bd99dcf9e1f591993cfa4c839b970ae2652d7fed839ce33f985de993c13af8e198d160e0063dec0c57746da1d34439e0f6887d1e08f9fe0b7be44767b5d1b8533e2cd4ce01dc74467f7d1140f6951d4b34512dba08f01f3c193e82d54bf15a800f10b1927fedc1153ba0c80e889a21083e1371e44a6c4f8d02ba401a0e74fc324e26c82f04da166d1bf61d3adefc17a06d5de1e702942dac9fd43cf7e67540ccc2bee8b780f78381afdd4c2eb96331c3ce244abdb55894d2c6f472f40e74107205416196beeb2961f5c44e3c5c1780d28e6f7b47cfc96f6867a737bc63d247aa1fe8436e24478b928ad0e45c8c3811005647796d8d515684b25a570ae7f70544877f12eef0c9164b530e4db0d7078fe150bff8f9706dc34bff6fb1ecfe7112d553e3acbe1cde6ed18710b3d304afd61ab1582eaac47cba32b071dec9299af942417255a5ab4b426e92b1775f41aabfee2938e65e035ea90439b87b01e47b464b19999611a85aae441aabfd761845aabfd5ca6164505422062dea9d52ff407e842745d63191b90d7130011b08f7915af145f74b92363411ebe0a5daeafbe0582e752df5c7ad431ec8e3f167fce53470277378a8b79f50774be22930eae477315f89700673c84f1b105fde1473c8c3e1530305c5f22b2454f63566224af4b291fad57517cb3bf27de2552a2a93e11e791eac2525113296c14e851fbaa7622cf490d0413656f13e285c1f8db8d0d2e5be5245e69a9619d49b5144c4fde427df094e192e00a2b0f130cfddd2e5bef3ba1b8a1b8572c43921a56c6c5a97431be68c07150959067ba8d6162fbb1c42ed46db3b83f4748a48d2fddac5cc5bced3d13b967d1a0e3b46b6360fb66f2b02f69136b1b9a139f5886a6e8261243751215205bed67ff80ca715ae5d7e7c5341a2576a874da3dcaaea3d0dcc26c7797d90965aeabf37f006aa023936aea6f847d6500ebf9b04bc75d80f0fa6a2a26b0003d2c82b411a77ffef38fd412e8f22cfe3c971476f93c9f8b62f1deeb41190ae7cf69afd7035534e6805c41ed36c24e38a8e21852c7e4f9761bed1fcf3faffe538b976217d9afde7843248790b5db4562021bf9802b423823a795ad816086850a63e5ac822b803bf7449eddc982a4c2bb35fe6ccd86a95820021ee33df5d844b82067a9ca3a5f98bf58099c7ca75b508f195446438c7a474baa18b57229e6052dbf846d5f1f50a3ead54d676280d8baeaa891931620ff828bd735ced307a55a43c4d00b536ef9777c64c430471a8375a4add11a82f4fc8fa560be9e348a3e6e8c768ba4364b75ce1211678f857c73a3364e35b1fac57f2272fd5d1d80a99f7cd8164b1c1916711bb901b1f50a889910838e572eb484c6f87f6f64b99ba6670ad95b9d5a27d38b2d2037ec4cbb2b2d1e5b86c113a2ff40170d436c25422511b30d99b11628bfde2f002281681fcf1dce3bef51e73aaf431d8b1e015329c7eb4e9ab023bf06ae1146503baea67e1082a0ed7c07d68b92ad901a3b207414014cefa8791702e57a7980bb441a5f2131ca7c117f16da5225735c0d21677e7eec5369640f6911223d3b9765c4aff5ff3750c7a2a3a8baaf31b3935a741e5fe8442fb34cea3f952d8bb50d2025b746a532ad01965a61680d98a25c5ffabc105389d2aa2e3792c083fe0d14a1e9d8bc65098a9430106eb7cdcae3ea1cb9eba97ce6dd54838670abd36c2ec14cf4fd19c2e0dc75c6ac19b816d2f774db9777d47d702cb4d364ba818b468cc4cf7454b0696b4107a87e57e79c10b78774b988b87aaa0756ecea7d2f1c287aaae7ec198c19e28b09cad777fcaabec87579ba445d78c3611fb8956710d54913f1a168237afeb927b33d2cd420c95ffd889e8f8de253d6e3462bbfb6fa67674f53294dc1b367f3ff9e3d3c28e0aac0de71531d220c2d133e0e3aa8894eac23327386e1e72323357b154f4a08c117e5044a624923c5709666f00d622cc4ef9eb4371646f2a9912180b1101b460c32ade91b9dcf281a83c6600fe78adb7fd1ecd4eb0fbc1513ef3633378f0bf1c7a9e11f23bb78ab90c0526824c325c3ba1eb3cf9daef34764f1163290c7519d44911a93c2ef755dca76b8297fceb05e6f7129a944fdadcdf3f524c0cfbf26112151086b04c659f956b029e9c63ddc10504c7b04dbab9e594de87dc48c6bdf38da896a39cec219fb0a45bf64c22a9994fc2c6ed26ab5e02b233c477987eaed021143104591558336edd24f6af0338af831181f2bf066247cc02ba155b4fd7251f0fccbbd1f1eba7796ba08621a315ade08cd8f058b58fea1c8674cf95899b59e207522b41f1a00001ae7939a6b49baf1f974826d9423904ab9f39475a8a2034b8f4bb6f09ae83632a9c1d9086f84ffe5cd8906f5eddab1945dafc483d5898711bffb5b27bced51e79ceff46a41d3592a29f52eae7ec5db2ad5c071c8f0bd6b02c6f0f4a4c4fd663c183e64a3c793686c8e20b80a8034e58c4039f6eb575a8a62134f049f83eefb5c414e97423972afbdb42a5c46fd93666a59dc04981c9ee12a4374a5f84c5522a3e44ce5e754dea528d7ff8f7750f64b9daa3d70a6db1509496454f66f04b31284f26c0771092d20e70d9bae72601bd32b50da4ff0226c336f4d422937777ad1a7f98ff446fe3468abb69511c394615d736f97a16f484ff9d6765bba5c4a3962b0a03a143649654ea09d5c9340ab11f9f82710868802da255456273fa688c783443a50de202185f1917dc8e7a6378870e2ddf23100528043d06a2179021b282fe77a59540ecc4146950c859592ced3475a9fa97d0cb5160987bf759b5c8ec1a23ac804c6ed0f069aced45fa172a64b9999786a2e0b1c975de80f7ee1850981751fafa5aa5000a935db4e7bbac469732ed0b0271d27b4aefa73d88aab51389738a510c85185063e9e117dc3ae1bd11517b5ad2cd329742db634b7b834f3f3d6f2b3cf8fef81a20df75a15975ab194aecdfafde1a8770b4370deb82f74c134ccd6ff5667f46584f9f8798f2176708dbf9d9e50c478f26c9300ed2a063dacc7ea8b047a4f994a90bbe5634ec905a00345d167e29c83bd6a797bedd1cf8de8a73c0ac2f5866ec1d4bdcac537a27fef93ee3c4098d858bbb02500a525d6861951a9eb48da68f2f6381e6ded6514407be6a58c8e6b7ed58874058bf5f16efb69c96a339e8f8236d774942de2955872580b941dbca229fbb51a03463999e2f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
