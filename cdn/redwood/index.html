<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"38de35824661b8436eeb33eb073b5463cc205115cb33520504cf5bcaac923729f822fa1f67a975ce641081d42d112d034a8065f5e629a6dd59c381f697d4ce28f40d884ca2b7697f1171bdc5f991d1bfd5331766e41602405d5840f126765f055b290af4e2ff90f91d98d79a66726d1f63f4703bb828475eff75ed448435cc8f7c5c6fc9e26d33e0a8108ddfde443f407e2cf26315a1db9095ea58b1aba4bda8251d7fe6fe189130f92a1f3d13e92cc1d381865b79335a722f1c5d12a84454beb7180936690b3b96059e59fa30a545787a249a6939c7921fdfe6e454c80848fd47e2ffbff8dbbb9bf3856fe09039fb8e70bc692311fda189a4ab2593d29436ebe2765f776dd0847852b497f25420e45d8104ba868d2106293697703162623b13fa73344af9e66741966ee5149a9cbab186656d1432797c96b499aec1040ebc6693a334c9932ab26066849ceb96c2f3b90b470bacc73c82ce4df665764723cd82254c5528b530c435f4f54096c91fb3cb9086de1b01a1e867cfa85ebdc49b9cf584d2ad8153bbefa0ef28e5e999ee61d4557c4fa82ce6623dd35855599da3497924efc4da337eeee79c949dd2310e81d5cc64b6fdda447c429af796b917794051afb6d4ba53f14fdd323d08ff7e10ee7a3c42f1dac110ac0d526fe9fd7aa203677bffb52da772cfe93749e69f432883f0c88af5bc58cf2c90deeb5114cce6f1986bac59c1085ef5e88be608bf613234eed8a4a3c761200a36321df1bf3eb74b26785245d93b6d94baf8638337af96e3625a979136a903dc637ea5b09007181a068e076b2c89975645c5c0564d0557d40e275078b02a7e0e150b1d47822fa16ca437c33ee27e866be19c53302ee0b19381fad59e36705eb2b416961cbab2f7b611b84dac84ca0869855ada3b7ab057bcfd86b9cb4783dbd810a2da90cbe14c93bc549607657de3ae8b6bf4d2890593f19401ea65f311c634f2a1494ddc5108e1d844bc36fc6b354c3282f9cf6f77810ccc5f7fd151094248667202added8eae849eac92c5892cd230b73740003d26eb3f2b40a82455bd38838de17757f8812d0ba609f94d7cb0e57516d3d4d24f3be2467e7236ee52bf3a2b8c46170922db1ba69eee630f04a247db378172526a6b8af5b93deb0b78b9c3c80e64b111f6339541b34449644fe4795739794ef9a8f39ebc6e32edc19ba39b05bc7c815c28be7ac8183a1896eb44e9853e4d2e23db4c5c2d10b2cef0c7a6c4e83e29e460c1924ddb3a004f878ffc965c2d42639ea2a530a51c8e97fc702e0869439059df3010f54521785e8232c5bc5cfd7b1f308f06417c5600e0d367c43840e9a4bbbf5babbf122951204503781aec6102a9185551d95f930192df46ecf973e72f414d2e705d3ba93fdb7da55ffd3c29dfd46cd49a3e2060c5e5e4ee7f181807e29b530d9f1d06fb18ed9edb318f2f45dba3b430be774d7ab9796805d890e4ac455e54cc6c35b1b60a0c65b1079788a4a19c4dc3e024a60339aa3469c3250eede4fc9f098a9c3590e8fb84a5b3a49ef53adc5f5b8290ea16aec7ce9d4da11de2a5344b9744ddd8d255292ad59321af7621dafe5e8503815578cacb967a4fb95a62a8a3882372e65be4d54a518c7f0f65816581e0389d92b47e696d82a2c7d0ef8338ca53745109b1def17e09f4f2de1bdb41d33753c7b54b7b672cb161f47c3631437273eac758d8b8d379f3399a7a46edfbb360e4a54561a8c1506c826b4678bf62632b377baa8908f07eb71f3b246a2b1f5764b101041bbcaef2267763154b4ab689328d7bbd3b660e4018984ffa20a56ded8dadce9786250a33acc1aaefb336b4ed283ea2d5d6364bb91a028669163e50392aad243d495a70baf9122dfcdeeabf74630a820812dea39f3151037bbbc50879ccbe23360ed22c5cbd52c7d58e4652852d2f6b443d20a3bc4b42c8594d11133b08c94558077592c659e2abd74cad45e6ff631629320679bf6f84ec38a873f9df6c642f790b671851a051616e7b945f726f85ade8ba28662ff9d1c0a261a15eb07309d105ca5c292eb253b1a7acc0e2e2a0f62ff7d36dd6beab105e459830f92547779942042cf3efe9b19bfb5880e5dbb45dfbc131001497733d5bb5669bcb39fb12b74dc5d904d255834597603a08363815ab52a50f19b99e4e71eb7e8fb58b9b2b7da3cbe4a633dc7cca9a6a860ca346e727e55ab2093f861e23cf0b237cd5ee234659802944aa22d10151408983d2e79f37c5b9b4dd2a0ca7594be3543c21d2d74a796eabc1c32b15d457653b585ba9137351da6f7abf15505f65237cdf5a806863ee96bf47e7ca404c750017c9add35d475f52113291afe310fc460fc35e89492579ba72a22cee5a57115b54b85de1ed11241b683977e6ddb9b7e904be3f4e3c0f3a87351f70efe6dfc05a5d3458bf15d85761ff6154f1c5892581bbbc480d3fa29e798ae1c57eb6b19c63c6ea28224464b5d90b64564145156b82774a0d88f923996db078d5cadb3f6507c3c49ca01de0888303cb6bed29cf6c9a0032f0719c682100de31b43cf60ae0cc56ea063d9d8cf929cd43ba7d88ae6c3855180917a2a6f9f21282534ac37b3111d01c474f7deafef6baa20d9c4622f8a2a8f2a699407571206785cf24cdc90a4467232e9e5c932a155d07847ca38fd2615dee4e5fc58e10d0edbcbdee82d49b22bc28e5c1c33a0eb89274be33f23c8ef4274f8672a8820d9bf136eadc0c4e2ac92c40cd632522a82e7287b6b1e9de45c8ef29acbfa2f50f2f710ef519ce5a33bf62c24549b45ed129e40e5f0d42007605f03347ca1a06d13c9510eef79f9b652d7f938dc8aef9a40816024a8ddead504b7385a7c8a61b8148f0bd40eee43c95885f40d4ca1285c0f550e610bf86ed8370dee92ecbbeb11dadb180f14ef5bf61b4e5786fa2abe8bac5a3da050b0662a58ce24037acd7c3efe3accccf08217feaa65aa38c1629eb463c8a930d76a68edb08f1197782ef77109aaa093dfc6ab8d66e1bf1f35f6fba4a16a570567abdd8159da88ca3034a44979825f50aa1dce6128576cc7a60f922e7d3223ff84e93b2328cda7a4efd23e801d08129b474b38f5fbdac90ca02bab12578e98655a5b720cf10bbfe50e198babe4bb96287c73054665f30bd02dc478b8ef211d41ae912c7e48a8bee1e1a68a21d3bc481b92cce6aad640c49e794b463df70090bef3b8f100b4a7d6ae22f038b9af4cdba086df733a0151399ec6f45fc116de57501f9e607a22a4111ce3198302a67eb8f9bbdeeec56580f762457a7b190777b69a38b038d537cc9b26ad215514285514c01b6539ed2bb6d3599a730cc700674a684de52ee402772f916d76bb35190a1dfedd6226749e03184950acbd41bdbebc277db4c47a20084611941915ed2a255f570121b61d8b082c2abcf5149c8dd02cca45a3ccda398da6c43d2493f3160890995293c12d60826e484c5baced6863ec1f27d7aa3588105257d9c58cf44c658a449dcb0d861aae4382f49f539343813d9a007e866e80e6442859c442f4a4d05a0b0dc603c013e65082597bce5b353fe27affc6465513402d7f5ec5514de0636c6ed4dfe8dd0a899460a1e2a94c4dddf1fda3c599ba0bb7d191ec9f28b10a4f0504b1e6e0d745b45dd9b457156719b6dea76ba7bcb6ec779c0516e48eb7f86591fd023a02facfad29309d381e899edc17118ba3bb216d7aeff7e23b230c40aa4d12ea4c928afad8eb6544b8213aeaf2d7274651f528c1960221a4f0dccd4ba26a7241448ef88e27a6876e47568a506421cf1fb3f95952b3a4d2ce05176492dcaf040ef7945cf10e9e954291dae2307e5135e8e19e575e4d092400f5cf0780d9166a4f80da6c28cf4e3d0d7c94e3101dfe371e2d64117e4782cb02fb296fa8bd48e84a7ce757f0d3761113f6915294266c7f3a0d87a2983cc34a5af7269f486f70598150e23a2f78bac091e7865048e15136b487724f3567ee07ce63f8ac01a3009c0e7d014350c797b17f2b6956d04c8a5350fb68ceb127e9f6b3f25ccd00dbcfd79e7b8e6d3086b60dc6d61546730665351731ef6f3d75cb6d5596d5c582dc603254344ff27f33c1af28aeb9be5cd338095c86670bf661982056d8e42c690c149475d73ff330ed6f0653b0ea1d0ae70ec34bb5b65905eedbc69d034f26740e868985c7b4b64a5af8fa3ba42846cf7d9d547b50215477021cdda07ae6545d7f7fba7cd17f041094b2b026d448deb6e76da12bc719d9ffc07036364cf83ee05d7f90c28afdbd5f32ca6b71646cf623d54b193ca5f586b9764d0d51eea485119fd87ceed1d877eb1d6c7776085ca35b494cb18fdb3812d8d06822ae8dd98030945b6071b2aebbfa3387b4a0b84487f39e52a6aedbfe3f16f49076a60d60ce8a9a262e07c64614e55cecda746248d006da1b852fa2e8a183baf591573d67da4b37b74c1e4322ef55e73b18d754709fad95a8380af1a445678da0373a13ec55fc9de0ee75673b1bf756818091907fcda73955e10b3b46d3659e7837f8c38dffc2f85e493f2d50c4e8e7ccd4865e0a27c7d03bc0b8db6a8b76dbfeb128fabe632cf3febfe5185981ae326c8ed3ffe00166e78c6647678ff91a4dd5ab8ec8290a3c7dbb93d67f011c3dbaebb56fd5f032f20923c929ae441accbbd18c5a388f1f312caa4ec2c056d23df7ca8623db89490ecf8e95c8ab295dc426fc9fbec7730290c2d1edc9a4e7a9edea76e0f218f02b85b1b0d951289852df30a9f815f75411f3fd1a098df803178b0bf94828e1439d44169485ff799bc20cc65fe939d59769d47bed258cd9bf4232e0d8e28664e451985997084444fca94220671114ed1ee067850e86d7e636aec97263fc865beb00bf4b9970815d34b3fd9943978e6eeff331a2fb375d23f6eed97fce795840a88b8840c027cd9e4526b8439472a043cdc86f6616e2533d2cb917e53125b1eff6b623b48f15f591413f1c1300d93150b2e3595b46e3e8b2657bca47e71585412b0ddbfa175b7df792544a78036aa356a1eba219a97f5c60612a12118eef84e95326919ea35e3da4d3a30fda45283e8b754f5c6786d65c5dfddb0802e5e940e87e507cc5dbbefd394c62e2a5f341300d4aa2ecb05a3477a095b70775f671fa6f53005a2718c57076396c18fa2ef1e4807f2d993491a5f3be25a07c238488225cabf9f2d86fc8f47c26d223611e7a3eb58ae63eb1a82f74f813007dfde5fb5414db32a88a8d685a43332c706453dc58edae234f7cd6ccb3086a3fba9fcb19124df5aaa60aaba6b22c8dce6c6f389f37a3e4033ee073a1fbf04a70924b30ef0ef3548a753c1baff85c802aa278a502765fb144990078707dddfa2704378b56d2a57ba1bf7cd6717ac5b701e0cc117b5f883484109fc9e1b1699d6311838a79a41a351dc6f9209bc65ee0fb77b39be4987c2dfccd5a4c6fac37e0ae85da27f613f43256c4001f2baa9d6f7973c15142ac2e0c7e7be646cb591c6d7ab62063bf46015b777b84140f1ea490bbf4a621bba487d89b15638232abe1cafdfebda77a2cecd30af4f10c9868dcae76c897b693d4bde6fc3877df3b4cba3865dfe083d77c004a456e7b642b234f4865009f731f26680050598919112b8d304f689c86460aae678711269ef3a0a84d37d60a0a71a7160f7f0d8e32b35cda4109978a20192818c59eeff1b2ecb1e532e664787456ba9555c6548698f1da950a7daf6e91a343572dc0f8a64d10a65721b84e86718256ae9afe489916a5a5b1c534b148221c668c4c98b609be6ad6c0176e30786b18c9cabc876e7f1f0013fb0bb4abee1e64a54bbba4f200267b648facf13d3139f22002854b42193747e6754fa8a59e7ee5a652fe50c66a360ff06c44d6ac1ff1881cb420b45602eb66c07a80bb33e6e5e64d9a2fa2992dbf44f3526402dc1c67e333ced12c80d8396d1c72f43cb4a1e053bdd3f6e8febcbbea0b6ac278d6b02c07d1265435e21cf108f6d62d323d9ef56a03bf9114c692cfee109809f15fcba4b61e6401a8fb57bed2f4f3eb73d1e189617a8fc57d5c0fda24637a98c603eb1d1c38b4fe41280058c8f69cbe4164c613772ac880939786e771684fd4f6a45385d343bf153b09fd503687f1a75c1b98d002f9a39c4b90bf7a3b285ece248c8e67fe5481e7c62c0480b7912e7b25bc43c10439055366bd3623cf5104f16388afe6820f21868cac3b70b7b95ace998a6ef6b1ad141af709f1bcd404171eceaf48739ad14aaf91495af4470105f2b2d010ab747eb0802363eb7b81a366276edb4145821c52d56d77046a55313cd848da0f406bc1f5f3333926d31bddf7b6ad4e2c323b7a472daa3e55d07bd8ed4ac2a05fbebfc4cb0370dea72f819785f4b51ca3812c16dfda4dd0f981ee1820f7e0fb0dd1099d845a761e29adf6d0dfca15c769f35387eb56bbbdc69ee82f4fce6266ca165eee6e580c6dbb8943cf0d02fcb551d54e72f5b26b1b96f4261b3d25d5b87a1b729ab482df00906dfe5a7942caa23d6059b7e1cc6e7af846cd3bc6e97cae21861443b3c77e74376013e6a943282b6fd87bdb6964419f99ff1a2f0a4a3a7ad85005e1b3921de89fed4c779d1ffed2f3ef641551e74286e836ab6caa9b489f17db427d7b535bfb09ee239e5e91bb3db22c7bdde01412f954361592a249cecf54658f3c28ec59fbce62e9e461c479fd35cfecc072fe3418e8ff16bbd3a08518140e6bee8c867afdf046c92cc2e70d66425a926c5c26a24ea2c20332e7fff6fe6013ef84bce75d2b875f59f8883622ebb2a425b03e36e8fe69c35247878a75dc2712a51405b9e9d7865106a5e102388c1c4f1b3179abde24d4dec4df31a85b35a4228e92809fddd32a07dffd1d9a94b74f0a13c0ea024c4f783b08a829adac36361a0995a0261a70f242c20a2f453698c14536e07b28600ea3a34a987de9675cac1e1989a9925225bd9ea3015eab00554624bdeb588d88219d5bea4b2a901bd697c69ff37d53c96dbc423cb9f576c93d2c712f706ef245b499b05d4f7aaad0fb04aa2ca1ae7beeafdd3f15ef01488471e5fd296b5bd877b7abbf9a4ee8efba4b729bb5a5f800a227e90dc127e556d5c37046ed7eea986232c03a9e174af1fc519fdc54dbc4a18dead24a0fca7ae822e7d2e3c71afcb65c104c3d22b94730d50df217507333d98c107c76932ef98429e1e282acad69b4e49aa54f802905b4688763da612c945f96b6d41fef3bbeff66e3fa0ba88baaa056153653e3a48decfbbcf82ac58aa73da4f04ae25000b9416e75c238fd4625db068ade095ce656063642bc5f76e9bc4f56c47db1541b233ea0700c5036cb1f6cfc741a454c94a9cf25e50eccac039c193b666d87eb96d737c916f0f43f2129f6b34b25dc2bd95f661ddf09f2058d047de81ca354f6f2894501ea5c85a3c906d287fd38d8f06bfe3c5bf5b0f9c57d3fa5be82a21a9c0867cf9cdea61b0419ec6826b2996186aa3eab7f94a66861861663e0a2a57e78d492364903a46f58a282b9a180c32988417ebf08c6c66a9dc04b98b71c81cce47fc3fa6ef782bd59bc1a7f9be238617cc100d7380b5dcfc2e98b1daf9c401a7b92e097b5c0047762840dcf383db3fe03844c7995309a84d9f89d14b3f2135ee55022681eab93ece2c9bf051a8fa151ae60ad363de028aabaf77fd4d3abff226415ea89b57f210b823ff81cff1c895901df3225f6e65bc83a89b4275e702511d947f769d4aea9efb5352dd8fe702bc5eba4e650836db862d5e6dd20e653ccd40056f8eaea151d48233315cb8fbfb575a2ea3ad09fbb92eebecc478d848de23dea37c796bc75eaca91e806585e294804655b6e6c05ed007458ccc18e88044eb8bac56afa3a3c9b45451255b8914073037ef5d49ced3c66d06529b9ca663cfef35782a8b44f6428d5dc892034468e821fb33ed376cb86a1b8682e6c8be218f4c99fcd1ae5a195aeb2328e368797a0f022d2f6f90dce591384333e4bf075a7830054def13ab42e8f1d40429c100ca9841376a6f7740f30e524b672f4c784022b8c34796a86a53e34c5124d9c725dad5257ab7e1819ff93461faa2b6dab47bf8859ec884c3255aaf7c130a91f652562631012ab642c2da9ed66ceb1ae470324660e38d8d10c4c4eb524e5f1ad181356091f5a351a5741be8cd7710315ff1253ee1b24a13338cf8a2448ce02d1851253d27ae84ef47abcf8c988be175b0ecaa571f5cb3a6ce004919b02fea94c9d2c874984941ae5b9d5eb6014a56e229dd3597c91f15f9ca8e1b01e58d2d3e71dd2954042028b12275c8aafa720ca7288d9c58d8867954c97d2e9e28cf306a0d54ee99bde0a1e6add240b23ba8a605fa32700cf424936056e82c75f7525563302ca258e3cbbdf648cbcc53d0a32e0ca6d513d9be08ff13f412f5fef328b66db53adc7b0ad0837971bb618ee927459e4b82df562bdb27b9f5a1f29e9c141ae0b1d4bf415923dec723c0353fe8098a2b5ae5ea199ab58cc5cf3f693242dcb6a730a3939958852fc59874d9c6fb3585acbf86467ff4aebdc029b99f1330bc304df4551cc16b429d272b5e96d64680249eb47f0e53afc9fbcac863a4738fc0a5f1676b03c6b46cfce6250a9ee3ee9e433e97cf644d16b145a46bace5aa3aa5f9cf6dc9b516a33e0e14147a459cb71e8fed99a944f3f4db5da376f8ebf36c410f2b17a5810df0493ed8b938974521e745cf26d775822c87d994feb525a28d41ca64ecbd8c009d2bbbf1eb01a44d4225e9e61d280e1afc3eb2e80aca573b7e74a2de9e2e75cc29e047bd5602f8e6107b9e9ae388886594bfda38fbbf1d5978a16f692db380264c1d03fe860225e989142f1316df62b4f95c352cb2e97c3462b75a8b702657f3d9900c8b8baf242cb2839056fa505b90028b0bea765e2df6cdd2d9ae716f6ec1e51f3416681172b948849e8b7ef902678fb200f017e6421e1b07bb54e5439aa96342ff194c64330b29fc0a64f184713efd2a86519276bcfed498bfc090e0d6b48df4b82818e3ef1ac8fac50d0bb8125058e1bf36309d71d6bcbd579a64cab521fa728425d890d662610a19aa86958b2798cf4849f301f139fbbc733a280c4e5df62a4b9b7ccb046080b514c15e5dabbd6d43faa9db277f283b20cf964082f4825649a7c37429b95a15bf89721a077ead692517008aa0384c6d05a83bf5bf3a2d208b42abd9611e4c7e679b600e7753097182b99f1e6c2e01519a0da4c49602ec72b903aef13839ba407140eee5fd4124a025cc929709c6aeb2934fe5505a38dd958fd3c56ed695b4aeff0918a0c0bcafa8e080d7da44fae912eeabf4ab4054cd2dd841cb56e2c14dfb1a030c2882a36880135878ebf608b0df299e74605007db1db0cd803b8b810d38354e660d60789864c74e47b83bf01956301f6fd86a0c7d47b1f21b271d5e84b7f7977cb3a6158097dd7be7c900a96b2052bbc116029683dcb028c3ca6a4b7f1e73b68704ab303681a31b88f13e0b08142f5a4599b175903123238c01c05788c00d5e358f4b58e6469a303067240f7fc32413eb167fba57a9610d8e29917c0217d845b6925e4530869f145e16435942f922051121fffdc468e5bcb8e86b9fd29086e5de9ac8e00e931732719909dd5b45dd1a1a6aabfd179862fa9b8f5f1ca7a7274fcffc2570edf90be07ee1e5abbf37e9c82d109be6c4f8a0569b527d50b1432b0589ece6a83eb43430d27265fef494212f8d39352c24eede9da5c6edb9a5ed02c3d02d344854fdf0ccc634973a1e5905eb847b26317a394bfc93b86b7b659e0a04e1fe078b741299fec8e5b5fe0a0100235eebd719771f1dddcf837fb9aa82468fe57696300b5cd3325860e491d6294a6c9b28215541dfc27c037fb41828c3de33d1298be300d4d210711d5ec9dc1665275fb1ae5de93bd63239cdd795d2a37e21c0736521c9eaafdd029b1a6a0b426aefda4f4cff5f74854b93d006c2f75fdf3bb79bdad761719824f1d9cbef3abc615397eceb8fee5e22c2ddd33c397fb86c66df6687ee3312c35a6348982c96c75769b021e4472ea740db1b4f9344f941e1ebcd548f57be43fbb15e3f0aee3c2f0a76502f75e67368889c752c5961cab8418e5de7b1766eb4ce5d6c24127372866ac31b5f6fec7032792dc0819bf156b5f0adc4541efd6358182b3aeb4071a3dff96785626a0f3e5ee288a3ab8844e1c426722fc106a806b75b2230ca7f499d2d1c10f75f2f38c8b159b922f1f03afa8a7f14e004e59d705de9e261b0b0c74f76ca56c759b1c85fa02494700d0cd0a10c5fc3e5b8c3236e81efaae61df5fbe2e0050522b702d5988b37888d77ad5c717dea69440865e3c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
