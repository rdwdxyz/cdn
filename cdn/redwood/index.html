<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fbffec688f3ae64601f4acca17dd772d32b486ef70810cb9ed51f68ba4dc9a16ebd228696aa6031c7fd40f259cde66543623d01b67454228f414bb24e62a8bb7d448d8369de7fd25c08ab9dc9a43cb07269417b2d2ad94fff54d458d22604b58afc343084dbeba8813b2c5d000549b1458e9d4e0c031fe46564d7106a0223092dd33eb4cd167950cb8c73f4abd883aa9eac67f8e0b7b99fb95be712f58234067f815db561c7781507d41ea62122f25734136d101754240250606e1cc7d89c2f731696c1c4f486065acea581a8e6e968976570ee241acbd7e0083bb1a4d69aa57d33f5a30846a1c8a27af839cabe6b05abe5fc38be19dcd17975c72e27f30a0d6f22304df73f76e418860fc35ea03092dc9fdc579b21b388aa6c7c9a519e46ffea661c33d712cd165674f5a54ba00502fedfc6228a24f6ff73139812d25bfc234e949a638b686498e4e1fd13750f6fa90eabab7575cc3630b3ef8667647637761f7c8c9090a705716d31b4f51c1e84dbb55fc2730d59d9e2c1664b65a38bc406db7ba26f7fd53086de6cb5121faadba845fb38bab72177412f7933d2bc9193552b673088c17971786a22f04eefec9d9d7d541fe3296d8c8c80901d15d93a96b88afbba3adad5018bc72210146468f9f1b9b7850b2a4497b0b8b84da9c46bc7d8c96dde0f4085f0f3442475fa3b9164ab253070ef68c10535fc5556a33589b40ef9cca922eb707aa61c59daa7e4da46a79cf40bde33949081043ce9b88ed48a86923554f7b4b9c99e7613b1c4168ec339f6bbdf1bb4e1b26dd0f242810923bb2f7f26cf03129f35cc5d00d8d6117575c7f86e0c2975783e5136dc2b96263d80205f30ea3c1cba95c1ac66e19106ac77553468e71ab757920881f8ae1924ed7aec9b3d55da5fbd1535b9acb1e7d5a8656f7686591d1bb3ca400287263c0261b8d46daac3afacd4d7327d20d9c7a24413e4ada2ab719c15ccb48c19453c71627979816f91900622db1e016949acde55375bcae71ed8fff533ce2d9c33927f39cc36784502c4e4b120fc17991fa5da29f6e3f2cf01d8948caad2e534ab3019537aa2e648d4349fed4df938a783f1e9016d4339176c1220babbba6eb3bd5d1a75e3bdae159491a98c435474fca0a55c6bb89e029364482064dc4db525e9b35501e6d72c0958d78490e8149f500d9034129262549335a960781d7e887a4501eaebd0b08704f6b2e2ce5807f38cb7d97670a6c956340aaa0e4fcfda8ba62a9553fe9bfb52e82749a424236a48aad2ae718da38ac5fffc6d8614b61c33d775a8eec5085e144773afedc1e48872645d9207e4f10396d191dafc7007da6428fafb31bf86f90fb403c6eb892179976ee4e2f96ff15beffb26cf5ac0e4819fc9623294e82bee1098a360ced9e9e859a3f7e532649ab90e9f2042b1ed4dabc66d5059467df207dec9f67aada0d0267078d5674e078deb14d59dca92d2baafe686ff78dd2ff769491ff0306d03455011ce597a403754c2a7da5614a1b91a60b0bd8930b3b8d633df5d0dceecbd472a35c75a7d7348ea2910ef6a6992417e4ebd8e2af88c7a045bc8bee4af5f05ca05f1291e354e9cbc3311941d71937ac595f6ce54e4eb5362aab7b55039ebf5782f94877e892107abff3ef2e73dd947b65cfa80d98ca70cad00d92642870e1f648f8b00ec9c9efa01bbdef0e0773f54706e2bec27c1ad89081499571ec32b01063121c4768ea4c184f4386ffc8f7d1c935d18ff24fe70fca695cfb8e49f712e87819fb4810f29fcce253631dc5461d1fab5ad3fb1304cd0daac63137138eba5685f93be6d0e02417742b1633306e09d006d7a894be259fcabab8e952ed0bfe162521ba0c3698293905b21f9d0ab557c525e117d5e67cdf2ddc3431d07205813b3a62ad559319088bcb21d170e3f997548be1ca763861e2a67186a8fc5763fc9d8b611b9e717806d33a7d8a86a36bdc995f616e39195492ddf2a641be6ab2f9ccb5242e5ad1e4f4a09375eed92d129cabc0658a33e3c0c1ff0e9a5dd78f77519994a3a52f11e846933380bc3e6fab7ee2cf5804d7e9961f8c000491c0c485830f8bf46e72e47c9b13678f94c98711dacbf644e25b135b6dcf88eccd5a3fb444b462716e2fc13d8c048c49f57d1e2c4c8bb6fe7f4939466b877e8a5cc684bfe1a6565b2d48d8d5b13855a49653ae4c204b06c854abc0d4492ca666005568da78da08b9fc48099dce80bc938bbe221608a09188277de9de709abe5906a67915d30167aba9fe878ed0217f5a51af9d77a3b8eb7e66e14526c22d4c101d17ef5f191a96252c4e01c70bdd13e5f0b2b96e26e5149250b11e9d46e95492cf903e6e3bb572ac7b448a8a161a2767f640d9980b5c6fab10fab14255abab8ebc1a51afeb9445703b001f03ed63a13650e0988c0b52c288cc70d72029d36ca8dd8e9acce7ae2dc90d317dcd1e3d159d899762cc091273d1e95bdf643cdd40089843c483e4c975eb4bb529434cf67235b45b1aa87daee031f894a777c6a72ea13476179f1cef263bb760917348130496104e0b56b22ab3a9b87b550c29fd122975510c74ac0be858c8ef6733d3ee19d072a6bd5085cd6bc5c28702570422f7a686acfbd02f14c61fffbb149b4e1e2f4769447eb367533880b3db616e025a77230ae7c40ba78cd04dbaddedfba23f72cc1b1b27a2743d63fc8750082aee145cd39dd2c3f746ae45e2d431dbb155a75c8fca85a6af9da5fc12677f5f38090f1b3914a06e656942c43d9c8756c8439f03190324f3f2388afa8839e266730bae995202cbe43382c030ee72395d0d114f6f29f21fb8a4468e4279d704b6ceb3445b2a64ca29c177559fece39264c00a24a8e2a2574a578952b80b1860cda7522fe866b68cff3ad7fdb53087e96b697bd6550bf63b450c505e70450286587578317e89de5a4b402953d16e678263c3d49d9bc9e925c3af4256d26a546958670294f30c80c431a74cd3b76ffc9f6a313c53bc5c5c48dcbf13dfebe30cb50f6c36d9cbc3b82212d7526482dc44cca94408ff3620379064fe25c9365e1cbc104fdac40ec5effad8d4c47510e59848fd9b4302d10673b0d152c8849b2f0bdc898a669202a299e7fbec650011e1dfef58bb6f09702f4e13f6271a31d47914ff98300636dd4bbaf62cd5b1b12eef7f4c44b2d8d4a6b67938e00d8a0030494c3730363daf5a1ee277063140549e647f6ffc53816f47b63211b3c14781475f121229484ed8f33738b214bf8e1128be52857cf2cd7a69532e50e1d62935295c1a45e80bb3fbbc36218a1d817296858b118e795de41ea46bb2c51602b9a5fad251dee9fa8f8997c55ff95970f1a5a8d5c9d25fe5b15d34b2090ebdeefeb99bb49e16f42133747beaa0fae687af926c81652c6917c30543f37bffe649cc487bbc08264d5acead623774469cbeaed789d17f4490c694ad9367b532bbd910d4ceb521012ea11567355389036932f3e7e422b97af688d465dfd1177f8dcb7db7a5f98312553b8ee3475c71f9bff547f92ac2f88a2654bc8014efbadeaf6fa30b7079ee2eb3b533cdec46d982ef24be55349c3eab565b4294bda64080ad0a5bca90ba56cb632cf2992cdb170a347e2031c3ea645d12bb39e5d7c072ec7cb9ef827a4956198b0bdc0cbfc9057fbe526c16e661a23dfe136d22f46c51a5d370a1aa6b02d080144769a937d3629ed25f24f4e1b0ddbd55383ae4145711197a818d2b437321c3609f79b39c989ba95f2388f97969093aefefe127720f8fa6ff6b29914a5ae3743b57ec70a49e891ca111d55ad3c343af7f79b86f4baeec516489519dec4786db9d782dcba03b224853d7e987390fc0bcd72273ada0f83153d113bd895380a831818bf3dbef7e0acbd9134ffbd47730f059fdcdc22c2c3b854934327aa104f2f3a7793d7279b5bd64c6071fa5486feea68fdb153ac015c16223d1378b3d58ca2b93c9761294e3a77945d68cca78fe3845a32982cdb58b2de73072af50514aed097803b8a5121d137ae39a21a763520a6b827ed4b1356ae76b15629be0d6fb061b74cb5e97bcfa0cb84572d3e50476a09284e6948ca5599f0954bcfd9a31db68e61da9a80f441541523892bfd93031b768dc0c13e240841a946b57bc50ed77153077bf7092d78ed50465452d01b220d939bcfb9598c025278356d6602677b9a3ab26746d298afc519c0b2940f0554ce80341de49e6a36fdc67823c0baa6d30ab2c1fdb07d07e05960ba7ec6648ba16be66ac0a4759aeef4f4e3040e837f37d5cb4b58ec1cbb0e18d3bfc06ee378ac7c713601450f776c1108fb46b69364bf0dd68b62fc6ce603ee1294422ae3a9387178dc162796ee478b6f629c7fd533de51666288ed24be83eb5d1976abf4507f16036fadd829a7eccde8e4f62d797cb7b0d0a2935b086d4464b88a075d0a86872741ae0877042e6962d1b5a87a0a664fc4964bee911f2166344145af3fcbbce5f6155e9c73184d34ca1c07e5f3077fc90e3fef8313b8decb103b82446f884f6e4c091a18cf1e5c898c5c0f2100f84573c2a45a451c7d2ba0f1790a897f5704b5db176c3a605f341e2893f78afe34a4f07355ec41dfce8602beb47c5d607d5719d7dd93d53790f87c3e9f595574954c676e04d4742539f90f2c63e5b49fd1802ef6d8dea7c6634d868e285ab22382ab91dd2f4d7be91949b3b372bd102ebf11b88d3e079500c27b6107b493d2f55b873c8bcd8457224fb1485e55d96e99d5f35d23fb9249fc8174d016cc98473e1b30aaad229fdf8da4dabd6ecc22d8f2da840867094fecb9fbe44c82d55cbae7d638468e0712e0ba6ea9b3cc0cc368ce8a38bdbac28a4d7d4195b23a539e8c21d54af428b47444f080893fde38ef29fbd6a9a6b9d2050eaac58b65d2d0ed5f116895641e2ebf0f192d05df032c85a35fb0626f144368b3bbf30a00249bf9dac094202d15f09adc917275f7ac4a12646c50446c1cdf419bd23c80789f736119783bcb5a28b8d4de9dcc695fff859201733d4dc5c6302dd8ef0365cba970559fa32fa364ed1c8fa226b725a63a1fa9175a4a6413ea2eff32c644c4d3a32041398a319959d12111409f51c4562ec71d1572cd1301427c1197972542a534012dcb6fa8a31a6f25b908267dc1d03200207ccceaf7920bcd25a5f54b986ba00558a4c77b9277a68338804ba1f23c65f6cbc0e3ab01ef24213fb1f88b3f1ebc45e0220a7c3f39fbf788787273ecfe6948257e544c7d52d68cdc742aeb607ed397e308bfd8612b2a7902a8aa808866157f2824593c969609245e02a0f367daa86fef8621d12ef1ea98267ddabae4faaa058e61984c62e933b186f8fa9c1878be05d1aca774f6f26b45363f31f888dc6c238259343fc5544f84a6e814c0ea73f7fa7c6d9efa89dfecc1dd39892818525f831293fd22bc43adf8d2fdf4c1d760989974220465a79180d2289b88d04d9872ade5edd6bc035513eee9a784ed0c458374e731a4ac478a7549d8c9d2600ffbb0f1b7e51431023f4392e54c9a12df173d45e4df7106112faad7a235ee708a826bd390a42d76e91bc0e5cb41e01423e1c47938e64335e7f0ccd4945f07bf57493179e0c713fbbe4c71e45f3a396c962eabf329f4fc52039b44b10a621977cc3b40d6a1383d4ad379cc568a6b5d3f807f73644906dc48ac68c07868a887a06d2d2616b3b8d6690b3489685cd27294b12ef1f3c3d3a320769aeaa6b07d573f7f197d59124fcb7e117d433dce9cdc54802e537eae73599deb44550555fd0093edd8f5e7c33262fe8b8c6ed5baa644722f94eff66195b68574119133b1d0e420425732d17752b69d1bcbb1f703539351a4f90fccd20e55233dc3c5fadb2b79f64de4b39434e59f1d8c13c2c7c14c837a59e15b4a748a100b13925027d4a20b70d9cfda5281c42ad53f28461b9b5ca9e8c73945341444346c7a34f46a448ad81de62cd8952f98858854df42b4344006f87b80e79e8e880323fa86298b4684bd45bb1358a28d208dc9abbb9240479ad4058dd44e94165b9b8c5886461b7f040efb9ed84a1c497bfa0d6714da7bdda7d36251e760826e10626f3cc8dc73fa59ab1253f2c2e88ad1e507439e85b7ca12f12ff8bb9613f74e820d6921b54c58743a280ee8d7e01720017d213bc4885a78530e135921ec00d9e650faf03311411838d13bae3373a28fc93e1187c4e8d399cb29636fbd2f85ea1c7363806f3009e75c98f6fd3f1d28179994654a7e95b5762a84d38d7ddae6431caa0e172ebd7dc3467f1fb2e29aa01bd10896d335b9bb53beb326e4fa3784c307656f80003458604e2d7c880cb288229744acf177f54d84cb8afe90b51526d63e5aec3a3737ec54f704c13b752334ae42682c0f88bd4dbfbac855a2961d15301e424d5c81259e416f8f84433668f86a07ed74331d3ee15302b92ced1f07f6443fe54857bafcd9ed7ffb6199a3e2735f3db67d65df79db2351dadb50ef39711ed17b111f1d10be07c0e05c373ed76b5d5c85417fea1446208750303892c61d14bcc3aed5f07175ee15cce53b1e9cd93a69537c6cc9d9428cc05c149ed82a90dc1cce055610bcc16a1e34edc81915b301acf7b115f9ddac177ad988e6695f5c2062b2f8a9d16212bc867784dfb6036060be966109ca6b80b187f4c17e89c5171dbedc50a49392a06a7f2bdbe2bea718a8c825a84ea5a9c370c597df6b07796a7a153b8349cc903717bc54b09d34ca6bc1c7d16ab312b4c907ad27705e8f3a155b62857a001dc725da98207b3cfc0a50cd0293d458b4f4abfecf34516f4b6b90aa0249ae0b5aa394e1dd646db04e05e82238eba44bf39eb64f7458c0311764e94607bd3e5af71653e853c83668077f3585c49a170a32443a901c138a7063c790ed3b66c4236027e8b5ea8d217a059d021c0d4c0333fb738e5c609d9d597c6c4c3091be2358c7fa84c55e0f8caab3f762b266b3d48b0ecc001c6d8c8bc54f2f1c04281b7a091eb3f51474228ddbac25149eae8d0b772666fbfd2beddf577012102aa8a46a261115aa83fe5c2031229e41ffcc9ab39ebda6adb50eb2affb5bd1caab318ccdc33fbe766392b8b8a114c8c5423ab027480eb0d5afb29eb1e14956544c0d3e6d3b095e9512a7bef14db974372664bb6b9b51722d86edbfaaa9d7fd60b7c983a58c4dfcbcad872dea6c5e24cc6aacd1bdea6843ef2affb597ab3b1ba9e3850f714d29720c86ac9a140506395d25522a88e9e66c2eb84ffb3ecf3102dc8346fb5805e1bc5ad7eb9a1d7d953e414cc489863cd8076c9c72df8d8cd725f308cfc33f1fd470788f6863bb05f70d18634a99efd1c35ab76280c3540b053dd73772b4cf23e1a22eaba6ed9b1b0bc73128d5b0505673902151317315ac05d0d0352e1f3aaeb0b0ca1d64f82fd96ac59c3265768fb3c5f81ca56de1255ca4d4992b40bb4bf76db39179eab5e3e1c74547c7d21dfbaf316a8f8ae4967bd209c49d64b342967c2a1799f0548220dcacf174b9c005490fde9323ce409d40f9315f955999c059086274b6856ac91c1f84c24c234f6bf10598f6a0d230ab1c159013672e5b13796da285ce302732d7ecd76dbb9ed648001599d6c73999e7cb53e44eab6f016759e3f29e9e9c98cd6774baec099a60e50a160c79ef27e4a7db3371c98c0456e124cd1bf5e18d9492711ed598731b0f226cfb9596e1eb42600829217a2d17db78cbf2610fe624bfb8dd920d32f04ab137159ec7f850bed462b3759b5e347e1568bb78e97da2504d5d47d745b713e2abe1a886565a52aac74ecbb73fb32586a7990bee565352c2d3d5e5e27de3d5128c3f8171a5a5d6d2c6f8b9f3a7923c5958283c522fbb45209e381cbe4f9fd471a3f07622870f2e2e25626e5eb8726879a4591f9db343eac3bf36223997b4e34de07ec630b4a1280f325262b2802c91a70f5bbc0d8615364f42b69b2dca6362b759d401f5faab6c15f9bbbf6fc83e8fee24de091522a9cf75ea5895623c7d60a3353105984d646cdf19ef2694ee7507880e1c06f7c15573e808c770d644b954f82e0d4b745e9824758f783f33f53b6d7cabf9efbda23e3db081d5b8ad7c7e0d9a35160f4119cea2581737621cccc7daa98a1af440942a8f388dd7cfb4760a995b03d12747f7890ed0f21b18b84dad3282eafc2b9542604849b0995a5778d2de1f12c1e63b16b5ef4e21c012eb17b84d6114de8c13cf5376f52452a0660f8e5db038932f7d838c60dceaf938b430502c7a5601e34fa52237dfd0045a1f588cad3064e206745c92b380e42c42d968ec3e50e5befdef47b8b309dafbdd092647eeaa590ca06af6bef135a8b9542e2db3d21ec6efae37715d53c1e6657989305d6286f9e6c5b5f4bf1f2593308d94c7f7869fe281492365d4846d2216f1da3236f0b02ec8ee93eebefb7e477591412bc5ad4f286cd14ff678fa3e9a0f59533fffefca10e61b33d05ece278a8f027ece9ec9aa2aacca9eb66dc6b06969edf5c1eae8628277acb1a05ce057615fffa0dd86793c1e5a60f36610c96577097957a82a686c60b170d20500a01a3ff84d6341caaede63cbe30bc8d52e5c03efcaae3d226949754e5dcf07ce69fced4afda832b787549228b1200b40ecb4f1e5d6da8b55911e425d5fbcc42359823659137a6e2686f695a81d689e47695ba79a7c7a72e346c4a140e3b48913ecd8ac68ffade76063919a677774f57e95934414e425743a34f881f22ffbdadf2ef4aff01b5a8961a3ebd511c07adc5304c44902f11a4077936cb707e449f25591102ac3b5fe8751b7376ea49d1d5803a0e509de8dfea0920e162151dfb2a097a09a4f346ca41ac05c418b360ec89719604c3a98b14633a406e343be5f1044c1519175c326a6ff185bbf1f667691d9e4bf83b38db3dab976e159a25123ddc5fc9f6d106d4b6bbdd6b43a44569b916d409782fc72e85cb60bd1abdc29af16de7b9552b835f56eddacc1079829b839ac41ddcdfb1034a3add91bd590dc264335647409c44686952e8a3dedac31ce62a369df65ec206fe8729373fcf62e293c8afa4d5138830b40edba2095ec68c11316a66e185abff06b06d94b112be8578ebae7a68deb4808ec133a951d02adc0970f674bf467d1b8c37ce9419aa3d9f6150da177364d311cba35d6434767f138a59e080698cf8107ff1532cef2f5875ade59b0b9373ce313825ef655bf3c5a90fcd6771efef82606be8ce804a46cc462872663c020522e38ea7de661db56472a277da0b5d92a68c7de74ed6334cf6c871cc1a14b7667836bb4b8bc0bbf371c9fa01dec50348e70d1a6947fadc18c490a2831fe83fdd5668f05a69d6ea109615b5dbb776ae38b97d0ecd6cc3830f1658d02b56c16c669cdd5516e40dd31a231d0d92aaa912b84c5067268a981e0fa166b247f295c217ef2effc2f7120fecede766f2f23f7df37e0a7737d6333aabc4f5f23d636fcd6cebf4c09153f407dfdce80c39a16600045453cbda3efd3610cbf65edb4395be07fa2e5353491cec97eeb44d1b8cf888d08e34041e1a74933459056a740c842b84cc2252c6f7452e9d5ec302fc4523af0567b358a30aa1afdba48e321b945821cd0ed4444736605f5156efda6f649f443af56f5b26a142f236b05b78a4d60f22451e1e2d97f6ad639ab8997326a4284c876ef3e342255d6e279eb9271c0176080bf6fe2e3b257f6f2859b9b9690506445acc71f8ce4a4b92a54909072d91a0cdd4c04074f1be08d86cefb89456d74b5f05474dce07ad8ca1ca76ba96628668cb32345964af29458091b6c95546b30e784271bc7efc695178b8798bd12683a95c65a3eef7b3f549ca0d907842b6c5cf9439418559a9230b7c49acf21f7bd93ed71a5c39ebe6ad4686e2eb0510ebf3cce1f5d5e1e08f2108c8d01531466555a110d861f7ad6f2983a2b54756647fe71714074b4ff5e231cfcb6063e18d7f109e3c123b4e3a40e6ab382bc659ffee2fc08d55647cd4077e1a6f854e1369da3bc9902d2d62d6c4f3b8cea5ca415f1c813063c50e4d2635ee27d0530b0414c0622f13dfff366c888322d26bd49bf95b997f2183486fab0c75ad00a382e991ecffa8f1c27bb14ec2f0d1e9a5b0c05079f049e3dc455d3b2deb16059e74821d59e9a879bb95750ff41c7783d2657f38afae5df62caa7a867400291179abec989cf003552ab0ebaf8d722074638846b0f355a8626b52aeade5eb71b17b11f158b88e13c67cfdfcd6a5df2fa9397060e59e9358459539629044377f122cc186be8ae28c403d2fdf08ee567120dd23c7e2d786ad2e2850fa822e163f0f855cd7dee21bc5c0f916771b4a6217b2af52eb5dffb28900ad96ff5c7a5149c0f4396cc890379de38ab89267d65a4bb4a048d8c13dbd28317ac628f33c5bca8ba1ab9327a4d57b0488eae48580bf6424874566e04885826ee27f5d8356cbadf1fa3839d902973e078230b9fff25134b1f3c2debdc9224de2c8e2880df652e6965d72c5c00d43e4b7c301d8ca8169316d4c2f3b589e1966aae683c1d0be73e5e1ef69a41de6f9d8e9d7dc7b792868e79502a826abf61f746db7f0c4560b983b0ee11088f1a44c8b6fb8916463e0a4da396a1b55488ac9b8ad6fb0ed1b22184b64dc49d7b0f08491f687f5e65d99d5e07815fa0b93b69f597c88c1c6e1378a7453815d743cbaea2e99848c65c98083f22ab192db906dcfffe570651decc77248f32149f1d01982310c8980775866cd2cec39e4fa313c010e9e04302b747d0024d9b9f47a680c4bfa2b64a51a42ddfaab8fde2e3d8d504b9e0c629ae88a6ec3742b7e0983829c5353aa36cd533ed8323e5ece56e71cc7b84b546c2d7edd38ae90f726158863f087aeb9599ace440b06d831c8b61e6f5719d60fe8259f4dfbef3811a0be7ea80950d9173b88aefbffbfbf49331e14fa1380a2c0bd9d7a3a5e43a1bb4f7007340a899531365e3f53a81860191bcd2bb0acd375c129f1bca13f68b333af18fdc2b177c482e2d0952a6c57b9ad0dffbb4c12f63c0f9f4cac438f5a6145f263d3ab782d418059442e236fd213ff7aeb060bd1a1b91c8dd54c10778e2fa31de7e00b1a1c43e8964499f556c945de3e2bc12ba59e2c8e2bcee0f590daa1c25d59d030d99df2f8fe7e4a7f00f268f725c0d8c819854a0f35321f869add70c80248570966520c017b8654318c870279fff491699aafa78556da8f22668a004d71a3b28dd13f698e4e5509b1568054dd13d80da4be84c90aa7fc0705c3bc50ffdd1208cf4af7298a5ce830d04a1fd4bc3cee6472917c89e888a69a0e1fd2a52a427ac2b4b8b1680220b24f233a4b47650caea79c3dc51f5730b222fd4f7c91c92cd4821c1e87ecd35f5bce1bd32207adaa7f5a54bd4b1e3c3430d28bc4cbbd2d219004b4bbd0b3fea57c51c51fe17d7b0b9f496aaeae04724090cf40104f60d4ea14a82758fdd0f1ead9ef7cbdef7427af0457082b6783ee980b7ff9e464d8309c351cdb683b2e2f937199a51ae0d43720cb69750e3f45d3df9ae4b5bbb50a93c2ec55724a0e9580437d66b5bd34f58d2f7f8902f89de6ec10844f0a4b869ac3e462995a6fb9b00e77e46cc426ee5b73accfe69094308375c5aba8a8f6aafb3ed39338be5bdcc5196273e5f6c5ffe8b80ade68cf6a8cb6d8d5653f6852c5960037703747f6d6c8273ebc94d01604475338f322934524a3ae053d93545e638d2647f73246d5f7b3970fd6c65b0f0e97cde3f59310e75c9335c8d84185096e080a6c02451099067b644748b7e134522e5e082c89984e617332af83a85daf0858dfca3275018c5ed6a0f569e94b70b77c42cbbe4f68e1029fcefd4dd55bbfe3bbfb7fec671ccbda3e9688e1869b9703b7340873cc00d2e3abb1ff9d3d5f4d88bba9613d4ff2a8573adf8f11fbcae5b513a4fccb2d2b7bfa55d9fff9e89cf55cdf707721d416e4c2c09811ac1f0605427ef70d5931a84655010568a037dae2c30cf1eebb6d5785ac4fbf567ce681e82045686c0069a67042187480366edae52386790ae77dfebf8880ae2b1c03c87156f914fc672051986764acd6170a03a8fa3143751bea5bebd4a41bacb41094c57c2d83a39ca64c7d552b2af175687b97569b97ec89de3ea9355a9cdf2842b78b8391e78f40f9de6baebbc577deb31296e8258395819b47ba4a97617647bffa668d4e7e78ca010535d0c9376fb59b8c126c1595336b10f5180caa61f683c9dfea575363bb0fc14773e896233dbbc5e995a3c7054637f8baf3edcbb88c51b61633fc705fe4f0cbed342a7a9e2cf7fb074bc8d1807cfe2c1fab6ee833d41694b7876c5c5477ef920169a1117cc933174e3a897a3c84ebd882ed0f62fe36ab44110ac6187ec10c20aa3ba173bdad3c1afd97a45ad15f3815c8c56f6c2624bf6b98da106df9c3f461a95a4dab400b8259c46f0897e5f17022da280347e121bcbf1072229628ba7aacf3e7a67db8be1a44aa1c7583d5c46fa4a63504678c0706e0fb86cb132c362e15ef818e259d22ddc294d1f4cd3983be88b7b448cedf5dad7a07050d5c030071f9431898806a02d6ed85740de351ce4fd03b6a1c5e47c48c1f6a2dc55e5a00eacac2d576fb16884f7121912bf9f5781c923c9636b449db3363435475613812342a7c259f13d0d1ff998255754b524cc042a313033f2a335cb951de6428354487b139335335dde292ed5ef2b7092b1d883295f5211c6d579e1fb0fab936efc8db8a4e83110f288245971c9903b522436e9bb8f26d424b735093063763d844ee3de62677e980d315337f697c1aa79bde9ae6e0f96f0870aeedd3731e05a50687d2898eda960c7502bdecc237822f2a19bd962b91fe67ca33961da354ebc72f259c4ed0dba17ca8e56325ac89b5f84997ee1bb651929a869a4f270c0870e009fa2f7cc4434db93baa56cd45b37b88e4850e6592a48fc69b912c4150f8b8c92df1e742f70d6f9cf8d0d767ceb07bedb3e6173b210e0222bc758777a0b8543ffbea8e4cbffb0736331ac93712e3bb360a43e18dc9343aad4ce7df762bfbc08b7df745cc85aff136cf1d7a051c4216ac2ff6ce8a5d65035280a2639e6c8d40d56be59a9daf48a8f0e4cbf45b5f49b35fcf384325e1a4d740bb9eca764595de5ccd83c0ad9b1253f0534862956a7a6ef8e987cc777639ea8497edd9050835456daa1b14d20d228a33a9c3349613dfd9a2ca426c13b091fc5185f5541da2eba5d5ee402138927273c399bd6f9fcc5743cf70bfc392746ba2bbb03279d32d76723386d0df38458ebf8202b1e6ae5e8f58ee7dbb5d67392a96c8f7b4a3a02464368eaacc456561733b9f68195a82b6b833ca182a89d4a1cd86992774363aa667f13fdd2834095ba81ff8f773b67a2c338c597fbfc31bb152cd84dfcb1313ddae6bca2c65a4ae96913dad51405e0fbe19c650f83de23d7f15f03dfac2198b34cd5e6d58543249b336de0882b23cd44ca85e6cd56accac221c085cb3db982809ea7ce25b1810cafec92c1a1c13d82a51ae504fee98659b840c370bef472627a758608dec93fab80c36df8b7c6acc0e6a5229b283438591f6626e569db2041ec2fb340565e1fa749fcddb99ed28b67329eea6e20874a210a49a57fea832cdcde49012afad86d631faa332c882a46cc8b4022cf1e18f59cc56d751377724ef6ac849c4e3a2f365b491a6e1416250368ce3f541d10fd09f013892437ca7381b987a7512ac27e4724944ba55265b34ed482602310bcd1c6a69942977bffc89908f2972853e5b873bcece674c25eeac8a90a8a920affa9a13cc9e03e36095d944060531bd1c0d60bf3ccf09163d47fb2b7d949de7054d110c9bd3c3a89ce9dcb9a70c82bf54d277de9a356053777ae6ebc5c3fbea408dfe31b56df4d1a07d4176ec9d87afef7bf01f5ae0a0e13c4188212fdfbf06a9bc0a568e3ad618efd59bd1559ed4686f99f12aeec0d7813d81c5d05eb901fcc2e3b671188614c2c846dae8e53925060c302480f868e8671114cfd3dfc07be49a5b65e7a4a313a7cf94e99b5e8e37fc985307b8622e1d464c46930abcecadc099170a6b43597afa5f6039110ceac81ac7263b56eed7c0585a5dcd2337c0b6f8ef76af9b5870a9e9bbef52f63b82551f896848977d3a3b019fde8277f870f5eebfc20609188993eb9ea86610b0483d7e85137b5bb66b614e5c4c44f187e2fe7c6a08daf8ab06a1492ead9af3c9991ffa78e4e1708b0a2cfff2eaf5217b78e85f425c951a04ca102e2e5ec623d2a239c426ee18c9778b2a9ff39ca86c9e0e71bf977d060ae83ccb2f90bb93fdb4e9c9cf7a684d7b1bb06c3e9480c84c6c0ff2e0fae82827423b95aac10648f9a5e5b8247aa340bf15d8167eed69399d7ce8be8a9ef474d9f897ade3af0f5a0b4fa1d0b30fae46766b4e101eec97d4b54c8ba48f4b4f6472ee4eb655e78cc17f78cc81f478c48d3f0a7bcf6b9d951615e461b39cb78d37cc45702b93489d3aa0f2e543125a5f4aaf975b154dc9d4df266dbc0b90476d3032e682a721033d7987d16a722e581e3f5f46a0e7d5b6e013d36a2ca49155de9d5d9799d19706fc20468fd00c558a8e3ad5421e4f7175525def52fd2d4addc0bd513161df7377e1aa56e18c558948ac9655f558eab2cf7a3b0e9c2ba317fb68c49389d4a30f043da6411181c71e1831ce8576f4ce97a2a0488cbe786674a950c34ec915a634919bcedf687399a0e695def6c8b8805a2ac13ff924f09c5b4fbaec80e003e540c9942c0bd643c8103c08b7d99e9b7dbb601cdd14475b8a5453b08d93f483d84a4aecd3791a3b44dae4b14815d0e23d44569752d1ac259f2aa3ecee8e5c29f250ddb650c3925562986124972ed2a2b6cd526e67ae75318458334a2dbb1c195ccb4046c852f142bae6cc870f790fa0093f09c69dbfe7e14ce78e40b4c7a8e027f64d6a4edfda66bd214d6daf29f0bb95384a0a73f96fe6e488603e86685ea59e6f713894355a95ab925c527bbabd5463a39931e11265260a7046c6be7ae6c00894e67d1234b958e9262d7a488db20919ad695126a425f104f3b405400ff72c868f6592c32014eda8e7f48ec7fa2f56a72f4f6074e66330eed1853c982bae127eab6e5fbeb0430971f53623d6d9b31dc234eab5176f13339e21753d837d7a4f410871d4bf0652c408ef2dd88ba902ff020556d3d0d1169b4ecd5b393fe8683d76d6ea7bee0289d43d2c2e2f0de9f48a9eafdb868b63dc4dc023dc50bb7064dddfc4994fa7a5ff5276b4e241257ec5f8ba644499b7b71718b8274140107ec06f1afc47b730cfac05aedd4e2963dd88c6847955a9196848c727cfa7e3425a925d5fbce9dbf5b8906a3b841ae71888cd78cbb5975e8c04801589218572e74e285a818e50ecd9a0c5b1b413f61c50ae252474aecd881652aeb7b65e432231b70dfd288585db064b64f99f5e28132786ca471ef7cb06f46c5333a2aeb2aa54d514e05d0fae0e2aea40051787561fa224a1c9923d28817d532ae153a76b220e043ca79c14ac772db5dddbbbf258270a398cc7733735c79c11baca8f47dde384315e11dca99f28eea166b38721c69b5c2abee54b1abe539d92255978cba4c3682ea2969e47b76477dd73edd1545863dd0309887638b2547debaa87f3b786e8371e5a1a07dfdae86e1f00737d0a2277d8ceba7c28495e79504b9aa5cbaf1d48f1aa5d401cf7b62ee34ddbe154bb7caa5b8d3a951ca22e2f0086e18ca336e69bb7b54788b4fa83be92435fe1e2ca25fd57943adfd4a15a76d5e4aa61858936d0fe676cd45ea91e9f3afbb4821c8c61ddee3cee33ab28ad422bf0e566fa8669916904ed4e773c8a3fa8279b4861cf9ab76329aa89ae0e5037257b611769af37179c95efaf598b0338293d772a8bc8e3897b786f1cce1cdf226c04d558b5e04d09beaa20602615c69dce2f61053a0313503a5470c22d95cff20cbd01494f89c4d5c324b0276fbab149443bf31c15dee80e96d85d6d10d296d383c2bd5968a1f71eaa77ede3ddd61fb0f07f58cc0e0c2f29aecda12e45f64351ba1d8c52afd0b26292ce4e7adcd5b9366b122c2856586f41f07498cae35c4d71de94a1bd2d28e84d619d06f4a7d3d9421606454246fa9c96edb2ea6a7d9bdddedc56e330a6d6e5c05fac87e8ff0e67c76a4bc69618d63467276c53c6fb9b6f2d8a413989b96e50b38913e554eea56527314ec2e6b1882a9ebf038c9957ae5a4e507ea311d97c1daf68b0a5b7a1598471c3fa9660124781ccb140f4afce999da20e8c1692109f35bb72755b3591b226b0eebf7fe9e20ca6105759b3e250d1eb046b672d400bc64612a8a1b42918d98b5a1437c21c0e23f1aefb8eb49bd019223d289fb3d97a3692b65a6ad4e9e030b12fd7aaefc14e7f44d00d36e690f077d14c90b28e997a1a693b0425cd3b4c001cad1c487c23a14c9a1d2e5fd2f751c77f30bd0e890152e75860c0af1bbb2c2a55d7ac827f54cf28ab6ed65c8a5ce0aad0a1eb6ad605d2177c69fee2f1b5f2ad9c0a70a826a636b733c3e943cc522fbc1c55dbe5c6f03eb5479fb179ea239e34e7bdbfb3c45a48fc18a72617258bc38ca43995b6651225f3fa0538ed04b0b814598ba21c4e62f91085ab953050a7cd98821ec0febc8b142c03196a2e2881147f23cd50090f806b58d810309500bbdd024b4230b66813f4fdb268f4f4ce5e5db5a503e6f6786ece51b5e5b8f4615e8969c1f867d52411eb142989eeb346b9dd448bce3e64f931de464b517146b7d6daa3372f50b8ff774f2536f5efc606d9175550841c998b7574bc4ae858f75dacefcd414ef1408be9411d974cd7ed3bf7be145f43ea399d463eb2cd808078a4b476c4cc238d938ee4c83e6bfffef038dde133caa1221db7bb4483fcfe45415291081cf47d00400d3a3b4edb3e2bf1281cc3175ff9e6bdb306c07e5db8a7975e5c917391b3c601f1eb449382d17556455bdbabba0c74fa728c11c2c202c67bef47dec431cd5d97f40739a5165e03be3376ea04bd28bea61d20ccad9afe130a1823ddb9643b00c4d3b8ec0f0ddad6b7df1970c1ca2a982e18414798b439f209ceb21c0509f5bea6fcc34985d193ffb90cddf29d1135976f52a9654053c963df8c01c45443d2f75d76b55b369491be8baf72765f930500afc7e575d24c007c9592e72a1a35c75a4f10de14602f360ba91fbf32280eeb2dfac4db425133902067d77c74ebd6e9aacc6fd94d84f7caaa6c08e969ff56cabf146aabb92381ce5c4050b49b7f7a46827735dc74aedf2c6368a2f9bcac23ead364126356c84a6a9eb19b9844dd840a965d1c67844ac38172621155c6652bab076b043ab439cdfbdbacfdfc10be2b56cadb4a0825b232ce2c2e4656c0dd75283c613622b7b36c8abc55822eb5c21f0d482ef3a0308034083c7771c219b19b2c40054e0377759bfa6231c0737d06afca893400ce8f5bcc45afffe6a7d31c3de21a2aea56298c526750a3273a9ad75eed0322a93e59c2e99dd703558a0187f082f0b9b40e5cbdcb3377d222f15ca6362e30ab4dc3fe99e7f5d21353c2a04a261cab708fc142a5a7735bd0b6b753b655d2a359b97c06cdda7354e7736fde026e7d3837269d761333b93e29c3ca664f0f0ec9eec81f79d43e75c21207c3521fcd523e49e49fd41596675379ce5e857ef0f977cd74230713dee87f10e206daf0121b858282ae33f0321f13b32bb6a8c46762ce016cc4131171714a164d966e63d232595c8aa893c7770ca116d8b91a156d0ac9b1337b84c4e826d9c329cdcea2125331098db021aee87919bd9bceb9bcb953dbec1501bfe6c72d83bd584fdca6d56d1223b81b431672037fd174523a8c9d9e550e4295be54949aaa128b7b925788c3c1b9fcaf1e8f1530d5e5a42ac1cec40a9f03b5a52b560c3ad2ec0db589881b1ff5963fab46f0364a80ea40f67370826cc77b7223dd918a2ccb3b36427f07a286d00dc5305aa05a8c658c4f9c4b5afa9e168f77822c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
