<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"13bde414f6b834f69bcaa9bd4a322e710989054e9cad6dd1693dbbee63f65438414515b8e79493c194341d8cde9fa8bfc4fc1211c49204aa8db42477c71f9c63db013dd4050e89bb48d80bd3ac0e85b855bf0a737ae93c0e94b7d6664072e44c9c89ba0a48e42d86ba2350143d3cb9c159fd3c3338ebb271a77efcde99fc8128c8c9dd1eaee991d371022a9b91b2ca68633b72dd05f39d96c0272d440c5cd4b67a47cb7ecae5ee3bb94b47ab39be3f01a6c947e82357d4eb118ecc68425a908a9daaac0887ccc274b69963a32b7db2d5fc7df5b945d781d3e968f436e6a14a6a133ff14e12cb9def5296ae7a846f16bee9e8e97591fafa588bb5af134fa0861552c1a7427286e5dd90616b33ef97069b3133de85a1cf2a3b4c78ef4b0658da769e05723cca646e40f8bdd836af5179a1ca9762bd6d4a0943ecbbc81c5a308774c54b76acef77b3dc9e55ed1956268117872c1ff19c101e28d7d870d056e951e0a8919d318d0da2c273fa88c01c910eca50b7bb4afce72c14b59428f62782295614c7c283fb3735a6a27b7e9ef3c63c92d239adfbcf96803ce2e24cbd5a24707f0216487a3a8cbadaad9e1a4f142b4e803d0b3fd1b783e8c10d73b3a2f830e6d25950b43dc78a925aa8c07b480d6ed1665b4f45deb4e5b79bf13204b9c472d6aaa5c7c9e0fd8c8721f1ac72f412a471b2b39496e70566e7f5adc4f689af3198d26bd25bd2beb21d111356629eca15e10e48f9d8d780ac5740eecc3b4fe2e8401b590a800c00c1446352ed5031d113e2f71f8487b82e82a33ee6cbf4f4388816791795ea107c5405486f82066fd8410195717f84c5d4b5f493a2265833e22b1e10d719a9ebfd2f60bfdb76db6b67c304b00379c2510de48b3403527f98faa6ac8a4c852e5aba750e74812631f71e49e23d99cd1ea63d4ebfacda6a12e4c79b09e07c7f5a14d9b61104565dbdfe946b98c3e61fc0d56bebc5f8ce5825c47d056bc9f6ddd291d15c8deca04f612ba7ddd138926eb35dfc1c203236f71836ef3aab2f69a5275e5e0a759da0d4bfc04b51a682d53695be2e350d2606cfb92ecf6092c1c2b9b7beb80efd54d4f1a4e52416ac061b54f7ba2cd838204b2fb3ddbd28fb8fbe077a1999427b33e5efe3c31893406f9c2053f982ba6ecb90ee7f85654e07496b3c0bdc71eb315e32cb09299e3c9d6846a8977c54d5ac35fcb004f7d0504165e849fcd953111f338df739df8745c0aa073e1072374203dd2ab05d23da8c457b37bc26c3df708713836b345176e5694a3e41d394fb7cf90a1f00e6c05e7dbaea0678224a35dfac36b5e7c6b8f88c46ead05bf8ec5297652c232c9b1a008e2b7a4c2ed65ed2d7776954b69a0e5dee8406f6f3fe4dfbc3e91459153900c38d633580b8ecc88472d7e91f0995339c5263f971445c8cec7c1b504a4498a6a9db772d5e3640d6b56649b7f26850ba0d54508a186ab6fce54b736b9262c640655aa3b96d2941b531819b79bbb0139ddd60cc2120e293d266d12420ab1e60b0518b08e611b68b0ba4dce045da9dd3f97aec7e8c49fa51e3ed4427bd43cb8f9c831db94fdafbf3f87df8c50b77fa370da3e5606337facfedde2bd67b2168af257f4fc1f928b49aa2e2ed9ab785817a8e2e79a4e1becb51de23421cb8e35ec6d64bd2c6d015e52154b373be52cc4f633397786a0489fd170bda5502bdf489d7ed84154e4bb32d20d49b709752b00cf7f34c9eca199294585c21c6ab7582de24896cf4251cf477559ccd7634f6c003476a7618bba3f4f6b638005d1d7bc8d721df63a88477f85c4269da93a34c588becc7994d6508a26bfc5783bffeb5cf0ed2ca1daa4fdab2fd483446f1f90f80bd99ac6ab669e6445308f955e5922ec0e74bf025710a61bdc700d9e7a4023619bd4507c23032e2a6bd4aa85dd7275a3ce5eb418fd8d05361c0cbf8bb39d30757d92d0c965c31ad4efcafd9c9bf4bb8ae9e0006c9864e1c5ace715ca36823ff49cd8d9d6f90d9ac224b065ca5694cf59163a5010d34cb3d8624e4b2f292846b3633da11251d705a4c3fa66b63a4976f585dfe9913ea6d3a6ede443acb71ce8b38c6ebcfc05aae680500ed4e5ea7985a1042b394af326284ba6e49ce88c12a65052222ab961e97bdfed7ccec0e2b539487098d9d62ffca74b2d413b0fd0f91c337900cb01bbf21562aeaed8ddd971d03bc75fd32b38c2901841024558791e4547cf0ca84fb25a1b7ccf5b01ea583c4db58bafe77d5610762956a174b624705183a0c3a8b1b06774da0858bf9d0e51978a98ca059961c551ff405aa181c3df6eecf0f2d49cdb57b3f202a6864518535bc1ea6f79b70d42fefdf5d5c9f2dba18276ddc0e692632ba3ad0929e4bb2b44600ff1630bf98e0d96714847c4b09c97432151a5d2f2320a8fe40b7fe0223b48a8d2e19d705a0904ab2a6a13c1100d1deebc97b7214fb02a519e29124699166244672dd7c6ae676419dd0457c5217c613a6cdd229a15bcb5747d43090031468e860af7743c93d9c7df8f42833b3404650a5b1ebe508d1a0df84e430201356b09d5176ffedb3b7e57804d1adddefda788977de404e1515ed9a17f8478f3b1fa452c28d553515505ec815bb6dad62421b2115de062221419500f408e4fd034418b89a38fbd69f45d5b350a008a4e269ce22320c6f687b462567978b0a09cd85fe56063ca906eff7f551dc727044e71d4f166d6e07f2b2165521452a8220e92fa558244fdedba06530acf73cb1f6ec1a5423db35b91c94c1e93ceccf7d7d37b21eb07c76831466d34801d59f28a8fa5ce707d167187b424fdeda9ef8822d9a51aecc82ef31254aa53beb93714a8b68134419718d9987b28372661d1dabcf3f93a2d969c80a08c2ad306e637da6c03165acfc867dfb46eca2405b3b12dfd4f7d7dfdc4770e034036d98ae750ede7a38e7345d5db398e506fcb5f978c5662b66de3e9ddce2759af9477f46dc85f3bf9912a6dbe550eff7f7a1f55af1aec49d89e828b663f1e855693314d40ac646e9e976fbd5fa67fb9da941bed3a9c86551f98cee3dbda1260f87f605a1d3876b0ef1bb2af1b70fa57d5bb9327151bb1ce675983ea005f1072d3c9f23174bee88b49aafdd3ce0ce6ac262afb674b48da6112b478e3cc84b840e7e861e319d66e5ceca0a14ae616ab6632d95a482f7bb1f710e64a047228caa264da052d9b48e26457e800a45a702c6485d9bd2207ce9b667fcdab4e81bce701d0bc983a820fa7ab5fc30633cdddc2dec7ac713172160d520019a498213f2227a1fcba8328b8aeb0b77e0ee4c81428d76190f17b2c10caab2c026ec15dce6e7dd03bb99cf564f61a3d8da1ff02744465139203eecc4dcc7d91428bd78e432e6b9960de2e808880f91d2fa034c5260f77aa6223d0e2cf164003b5cb5197c407a81e14b1c02b28360f8482845a13d1869cccdb6f5b543e2159ac4f0192e879a8d22c07866b2335fd11b890bacda67748b6883a9c5164c3c83296f4eac95938fbd228e9c7ed556542739c22b0720b837bdba27fe0bb67236582f689cac3d685af83a49eaad5ce1c6bf7ba7e394c2b599a5c720b432247b62fe01f8710ab1e646343d971d3f3ce67d8b366612419ae54d9a4fe590080a05505112fabcb45fd8ac0ffc5fc429c84102cc8083030804638c7e2bf03a4e9fa473c20364572b188e02afe7bfa0635a08767f5c3ef8f1e896e4ee2d5cf44587bb6073c2eb357758a55e69283596ac8ae91473a50ff34f956425ea819bc85287be652d5b3447fc5858436f85cb559236890c6bede6ae1479f7068f6723b4d7f343a3569d4115ce0b461d2aa7abdc61f22a6c4f3c5c78b2d71ab5c3e5bbd09ded44eb5bbf299bfe79333983fc0c39c797331194ebe1325e4bcf90005db091f705a2b0eedb6678a379f32efc7b22974e74bc97976a359fdb0a5512eece809b93ffcabdb4e8c08aaded2affb06141495554e83dafa001518403f9a0b8f9dfb2e285fe75bdca407e7912a1afb5cdcea4b1a99c98f8f1447aea8821516c4eda2d2b3b530c71b588a8915d01ef657bb312dfb3015519bec8aa30da610c06396f5f092fedae3ceff55ffe627cf29fc8e929ebedff44a541b111f8d9aa61156c7825b9131e98f1d1a2c7cc0630c95de8b0334112c7f3edada3f169f3773edf902533f8f482963f616ebf81bf2856295d80e5a9011d0efd6c55af34ef3b9a412a1a4a9e6fd7e45ab0b0de4af4528b1e660be3f11d005d0ec7ac8a5ac1c9041808ed8c8268eaf01f01eaba0b3b6013602b80cd3f7ca3490cf336619e6566aa1d16fd0ccc1c7e1950cb8204a29367febbf30474b73d4cc7197fc02502db15e1f34a6b8b28759a5b04f3661bf3460888625fab72ba06e38fb683177b31e48d0a015b933a7c9c36f469ee2295793ae0687e0e356f562f8a67605d9e7dd93fd42d9a86634cd626b1823833630ba998b095dc18a6d4ec166f09fcaf4d701d30824946baeda352bbec7f3abf7e48cd7725c8667c574447ee2bfec1792aeae598ff8a8c2a3e860beec6fd3ef7fb3cec24e47a1b58efaafc44696ba48d3b0262d3c4fa106157b5276c9f410b0f7380dffa135ff9bfb514e34809a367a6593526f79c9d64701e97b278c5bedb5345ceb3ed0dcadc2863c0fdb7048fcdf29a2bd1725b125cf440a950a7d7e758acb843d40b8d9bb90f70bb498677dcb384619cb1e64d3f9f6c4c45fcd9d9f8b6c3e37a935e54fd5835bc9f588b6544301fcf316a753668581d9377b9c3b78454d85b323efeb8a12cc2c662ea319852697f25bb891a38df89fa7547e58a1fe6636ea54e9b91fc815c1ef22859e4c3175c365bbfe584a8ebc110ba0b9a44d8c27235c927770702b8172f0b2f99f39f675707fd3c369531c35d34dab3ac1514af26d197dce3be25b3f3910d0b62d5a54179123fe48fe4df8c568a22cc52782d7b381923861876cb98fe5d0ef61f8d2f306b55f67a51407f2159b6f576d9355d77c36affa7e542296ea283fe226490954ccc4a1efbb37882db3a28a6c6423601d3e401376b5526866e1bb8f6419d684b4ff5a8c0958fb0de4b2adc8193a36706261bb65c8c11a1a16bf9839603da9b90474bb0fb091940731d1ff55eb9d08da9fb13cf11e289879fa4173f912f804a20f67b8d11517d9630ee436b05ad9b1a16438e21ac07d26b29d1e957f53364c8b74704b4824556cd1810b1f8c282acea895a1b56b8442311453c604fb4919e95397f0151ff6853cbc93817ae7c2402ccdea6fc7b6928685d9801363ddb94bdf8e2fa3654ef0ad249da83462433d9832cf6776051a5b48e9b494364081a73d479e6385f15e5a381b627b65a075d934c667b94bd527cf6c49e7d924851f8f9d5edab23f6a192671c543811a38cb1031dfb03a889d36d53609f88608b422d4d05caa83b0184aae089a0da0c09c9d98165fdd12681eabe2c28895caca8c68a77273f0a5cdfda7948845ab7912a99f6bc159310ce93266ad525afc87c3cb3ab25d9ee7b52372477b273f6daa535b8195e73116101f5683f452c3c61dc263895883fa099aa70d1ce3a554b8dce1b92ff2cc648864e7244a73eaa75b4bcccfc5d70250218b26b1d468c282b862a007daacc8a8ca0ecf26919776c8ee3384c215ca525ad9511fc597510b6c322225ae6c5a5e928eb0c8ee5e5c572e5f699712c34de0ec2c808c536db918ab531069ae2167e49aeb4ce83ba2ba15d2072c9321c256f2265c923ff2926d60e032deb9bd23cd42dd0a7e2b5640ec7520a6126b3f994c71efaef4ee2a1f0503562ecb58f61d1e6bb69ec713622b3556ef4d7991a14f866d2a9c782f10ba7b21ed599e679a69708c1968a62e0c4e260f012257dcfb8e5844bfa8d5048dd0f9fa6e02badca8e720b22f8e25dcd3d806c453a58ca42dc141ed8517fa2d19b4d408e2bd1b3a5050b477c3673156f49511d4371272e83de665f1eab1e56fabe3fe7e4f237502d0593509d291d262eda9494f8adcdb8c971e175896bf92bb259416e9f05ec975965d367cec6c1d639446acba354bf0b75fd8eec17356bb7515c231fa4c9e8c7196622e68b3b284a38bc79ca0c616e02f11f5f52d6015bfc605a2ecc57249ebd6e9fd360cd701195edb04faddb1e627aee14c63b6112d27c248de2ddba9c170b1070de61880b6de61b073314eaa770e0b5984499c12d47d4e9170c366b25762a28d73e6a0e96cb7c0619004719399e828232bdc16f6756dadb74fb55c312423ec3667ab586f5208061ccf0e3365d1e53dde97fdd209a980a170e76720e5f519fda760893c68914fa85f566b941aea8e7d4faf35d75b894b76b681222d148c82179a0173b86a4ebbf27962fd508a5d1ba7d7bf27bf8bde261a52bc6f659557a52316a564e380201b3db7cdf17738037a72df18b03bbd758921dc18de40bd1bbb348a2432fe6be00c72bf7dbd9d22f9bd47da1fd0ada4d1dd9f262ff6a0b71038b66c2d2520038d1c754728d761ec00045046fd324343ff0a3b66066f60b3b49856e1875159ea0aed5dc7810399c9a3bfa572981dd8eab27e050e4560d9d2813f0c431bf82b467d634b2a2ca169d5ade843336c8ec0335b29f73de51263c56969ceb55781a1f8e8b64092882916c5ce157418a9e7dc78b7f62538ff803851b7900cda379d85961e23bcc146390b07ba17b686e3d224d5ae8ddc905f7cc70398f0cedcc182b9cac0d8b059cbde8bed681c1c3fa883521c1ae3bd1d9d3b1650ac7bd524bb29e0280b6ed94685a6d8372255016845ef242d8a9aa881f3bb37ed793a1c87b01415cc15588117acfc8b2c2b5957c1d924365a03a64780d15b6602f574f3f0c0b06415ae58ba412924489af8a19f90c6386662159132b4045025f34e78c38ed9f16074f97de877527c1abc758c3dc755f6fb771530945f39864a8c98dd419462b8f2e4533c40a45acdebb06e0167863867f72c44315471c59d7bcbdd8ad7a114b89b133dd3bfda3a757160394afea2fbd3fb022585ae938312696d83a1d20084c0ff876ddd3f20b95db6cb4c39f87634f64518e91db360392d3124b405690c5b370c672f87cda924be5c6e04abb381295984dd9842fbaa328856b4c78db71ac7a02f260cd9dace44e29d171c4fb946342abf3472c740c424a10acb6eb0375f8ac5cf968f4c311015d8ae9ea75a2fb2653c7be8665ae010a780d35731fc66bd16517230917569b283053968f34d98c638ca303c0343939b0ce33ad86358bb5aa4c1b859b44211d70b3642ca53dea37c78fcd9797e157e317cc541e09011b17862d18622fddded46fc6e8ef8a12e3d9502f64025c73bb04aed7b7cd7f529fa6986ca0c0331cabf9061a6b36cb2d840259625ad6839d34ef18f8268409c4ea0996778445b711500a3e6ffcc0032775adb62f0f5fd264f7e5ac42cf5be4d4415d7d601d02c0f494927ff3222c806daf676c03dec60b9b1aeb24e6622efd91419e2974765b944c52893acc4de7f12fd8d65832886455dad40278530c22c2755dc521132cdb3c3c161d51201d3bff0a648ee5721bfffe44f8bff51864ada80a6a3b08e73d4c7b276b32100a78e37a09b0a3a725376d1fbbed95ccdfe614ccebaf5e88f2aa2d12e30a5ccfae3568a6a7e1df7ec472d5696aa7db6fc7d3eda6a62431288d97986e530e625bd4b8974dd72ca8260cf9e54ac41b7d43fda0f8b5bcf507deff5e40e53f675499b7d9130952f61159cfc1840e539e17732fb9710cfbc5de2c9ce0c0d169a3092b2f9af8e8b3794d5d2a6facc5cfbcdcfc961b086241d011648e91b7af43366728776f9d2642fa3eecbaab0450d36b7cb11f0936a0fbf39f3eb87dd2d0a6fe8679dfebbc6a80a0d18e002c42b6358e72d877529e7c77b80a4f29157942965d1d1549ad560ea6f6c719d0d5c42cc09ca20fff5f7348b4fdfc24a3c71b7176a50d22ef4de675836e2dbdff52c476cea7baf44f76f673c9fb9b65829ebb99e1ef1e5cb4a3b0bf6f8d7b2ae7bc80a3f89d8c1c5cb3f21e62cd0c4718dbf3550c363710490f01e76fd5ea60892851d2caafde7924b4d5987f4b655f4bbc6f6be91017e6ef987412cf635276e2f9a59b87c6f19e3ae5c0d0b237ecaae95509a1d877e2621ba91ca26727e79f1b3750c48edaf0f708ae00928b484126cd9755f9adb9f096f6b23ca4eb20b9e9ea6d94065cf04a35bf796641ecdea5ab7dd1505c487dc8a0f92328bb024e07be792b567cb79fd4e6559e53e25aa7c5e98d195d84807cce415ace7af09206aef8f6e08cc40f470a2135ef9cac8fdd7045c05d87e27382bacebbb9e87365c8aa4bb17e49ef8c3b868e103b4ce1236370f9cac5a8ee900f23b0e218abd7f6e347d88f55ede4ae489c626bc82a3d271c25257b53160596b1246c38f78eddd5351623f674abd62a1a046354eef9c4010dfb5401cb9a848626cbed00c11bc4ddd3cee9007b7cc939da5e6914c4e2bbfe88725582ed664647a4feb918c97aeb27887d0f751f69b327e4bf90ccddf97a27548d2dac6360e407d5be7b129cbef6df70aef3d56fede9a75847ada01bef5fe62ca5d682c46f203ec29d795e61b4f4ea0f6480ca8d0450e6f88fe514ddfc1e0d6e9970a7ce7e453f55b8e8e9c992a9296148dac19139212dc2a17893facb8e8f7b7222310a01301d4c427f257a19a086e71a763d70fb4b7eed500f13b435bc1b0c2b00e311b932e249efefa2eb43c3f251159d83605413272997d09e37653b2e366067d411a7443dc819fa6540e39e2b99cb1410bb46713e6f8cb82cdbae3a94fbc2d73b375b0756fa009f604569aa932222219e0451866ea1bc29f0adfb5151fa62c58a4e5f242fb458facf6f21376abea3509f80b40498c36285776bf679087ce80df3b71a127b69641f451832f9381ed7d54233c7a75f692aa7689eedb5afcdd456abdd7950821cd1c1d9d446b21f8b2076db9a911a21a74722de8a728abb47fb18799c4701f66bf403029cf2eb81960406940b9a5775635214339a280ed67057ffb991c07a3ad6ee0d796fb914c388ae184d855811b2b800bd4e8b8783afb9645733f9d3072d24e75318c3f1014261ae8a9587adc46402197e2a6438230c30b8eb1914915ced0b75fece8f1fab60376e25381848b3bff64c26310a48ae4e02610250db31a871a4d0df533c4c0aa354c00450937e8ece4bba6fe1099e0b6113376dbdb0dd0941ef5b816e3a408fb625a85db301c07fc954991192b8c0e7754b3498a12460d1010f8c78c5f5f88821a75362172fb240b6ed3acb744f08b023c15ef9a5987667088e990e0ed699050d76643bbf696fe415c5c109e7021a82b74cf6ecc4dc2ba00fe365efb9eab547e92050bf01e1e016cb1115f517657167bfd17474b545119b061c8ecb84ef7dc57ab15665becb0ed906c087a9ed8cfc291823f7df85d85daa2f2770ef65e31fbb67ffe2b732d5e5bf778b2704b5bd553b44bfb07bc1ec6ebff021149d60d6c47b3ee35d361d75ed55b6e2d8eae2f3a5ecf033d3f8a2f58559df7c19e2778a49edaedad9b559eb9ee71be9df6ce78d2c36687e018843492b7ff2060c12609629e60d677a4984f0f6378fb2ce96310e0909407e53aad86766072b0e3691eb2f2390e63f207f1e0b834dad75b1a2478766c0fd50192d3a1effbd00219db2fa1a284c07fb4c079f9a3e36f0f2c16a311d25aea345dfee78f3fdf5575decbdee512f118af7a570fa664b2003d5ae345d846a8ca726d9c37146ffbf01d5c7f816a4cc8980a58261c3023b72a4a5e09efbc3b4b8e3018ff2cc95f75e182412334cb6bf27b104fc9606fba265a3b152d473b476f593016fcea5f6324a5120b4aa4c416900588be655a8960f6ffaeb29f4692f6f4b3e628886dbd253a03d2516e975d875d5cd54c72e3db70548a2563166e91fc382a2f3facaebe291dbc19194251a3997f8d5fe9ee38732c6dc97b8dbebe15c2f211f8e6a9483ae154a60aa8490b0a7ecca8de47cf8c0d7b2becc57ca82bd4c7e90c4cfe607290b82b3cd421ff0264fe35964f930f31076956a666da680cd6a935af51e35ef7edb997b63644e2b902bcfa7fe6ddc0dd678c17d7d92e75dd1e554e81aebdd6c58aedf5b974988a87a82da022ce3f1afc71c0362ba232b7ddf188ccfa931db8eb751f20a77caa90758aae419438c816382e24ac66ed2c9d45a8bd21e08f53654020177122109e41ba901725c1b503a2ed9b124ad021fabf8cb176a81d5aacd32040db77711f388b19b184f05daabf47394f9d693958dd1ea5b3802068bf66c70043a9d48d3cc15140cd9357a29950efaead7e33053394360055cd592d4171b5bb68d328fcf6fc4d691021fea675e0c27c39c77d6dc11e5f0bd8a35be74d3cd674e1657d0a4f84670711e6e2348b607e12cd01e35efedea3f27a8476b732270643369b98de920ac5a23f6d8551cef557ba869e10c4ba5c512266e61c86c7a4cc959572b9fbc8fe18475b63cdb26a58520113e522c77e455ef8654ad2b35d334c8dc00e4ecd3abb4333c5a7971109eb65e96f4f3681b53c2936dca41724c215abeae497556571c948b4124bb1f828d140d32b25079abbb0b1ad166b585cba0d1523ec23ad3562181c6aecc63577956f7fe0b98646d7ecb67fb8e39513318d93e4025d6caf7fbe901125a480a7f821b8aa5207064b13e252f56d8b3b0b2ef93ec4055791fbebd027fc2db64907d7c9a772a37116236b6d7785f0f636e153edad3be28678aa0c0deb00dddf61757a1334fbb10421e738c9a0e7957c8f072e361b2e287b93cc40776e6e353bcb236102fc0b68dae785771362318c81f165967be05d92298655beba4e1b93f6523436c48797ea92c970507907e0d450cd41ce51f5e64445319c8d2ad70a55292e3cb9ff83c29350de45f94dab6a4863d3928ed484945f85c28faa1fb836db9a61ddcf2c3023b1a1aa945fb631be11e80aa37d3ddc399c622776baa5000848cb96313a50972ec5477f51cf934f4b8db9e633131f9e12ccb7c9be5ca05362afe0f3cdef3331358b971ad57f2e374e7d7ffca094812c05b5d895d22227915ceeb4cd8e44eb1194f174172228f53ab477027e5d5b310558c269f540d75e37d469b1213e4ccfb06d5d4ed386554cf55ae771c6961aa7ccbea305ec33519b8966c916aee45bd36b212445ca3a79cd14e2c80a3c8f168932f1bd27da79c6267ff6c3807bf020f3acf7d470ca866247ee6353722f66a1d3e9c6fbfd471211aa25a6f773391e9e57dfe55fe90a1bbb10314b4fbcc47fcf7481c6d4a7a35b6bfa9ba423298c1da14b2121582a2a9b5539941ed11c2938b941993ee7329156af8d6982463c52418626d4170f5cf0a3133bbe64f16a038f71cffcec37792577643a3555301f4275206b04ea3107ad4415a28d96c4ee97981b1b1a0289d4873aa0f9a5346ff2120cf2b295d57bf196fef8a876f1f3d0652bb8aab388b7823dae5dc004e406bec6f8e51d366f3650452ec7093d8ed397f618725cbbbaa6b211973d21e4640fc2d3eba29d0bdeac2a06d1ad40dcd5a8d78ae21081ac9ac4a25caecae8f3dd17755da268c504fac359522f229705fcac286dc531303c4ddb401c51ae94696473f94f627f5e88f99fff9b538cc6ec427e0ebfd1f834e86ca2c6a65cddd425b05d6dc93d39e7686327de611b2ac7bc02b0c03354411e14584e7136e606e27114c488f937b40b5fd4b61ee553c85bbadc1963747befc4f96ddd52373904d8733910b32bacd583d7c6ef9782130f18432d7eac0f65b04a6c93b9524d70ccdc3141ed9e9dcf9f2c76a279cd24bc3c33660ef00f96fed0b8a1c503a3336444f921354b7c92027d529aa2fc3852e6977e49246917e25dea77b631f51261819fe273a808901c8a515319cb0a30009a6640c9746a4230fce465f21d0f43922807c9ce636debd1b66600585572e1b7cecf476724ee81eda6d884e922c729f07e4674c6be67f0f2b1a990e75fa26ed62594b54fbfe89665dc4df499232cda97a31059d4e83bb63099f5634eaf971424792f70512876d8d825d0df35893d855dbc300384e7f6dd4febf1a124437f6975825f9fde32cb81d5167626b1f985ddcdfe6180cd6e618fb8e7c338fc8924ecc4b7da9f3819860d5c505a65e6af6a17e009c127b2246e5875da1e8dc03e3530325db75253c7739f491342b9df82d8c0ec8cd23fdec66b29c8ddbfb4dd98266d8487e855865cdf7166ebb9c0c288f51c551a868440e37bbf2dbbe8d5c9a4f922d80aa0769a25467870d5c0fee5ba66acf45a623c0cf7024a2d26c471db2183f7d003d5baf47c365a1524fb5cd1cd907fa6760811d9ad56b5fbe651691fd891e4109ae707b727940e70566136f8e8adb802ae8b33a88d3ec9ade3d8a590269cb1d731c08c2eacac047a69eae8fd55fc7b2231ceaa2d1746104382e4890bd4e539943b867ff43982cd2cfa87f089c6b6f30ccc70fa9486890d33a484862c50c79a8f2d9f797266d9dde0c8e5ddc4dbd5d8363c93d27f1eb730a5793bb0ac454cda1a6989536637d35c1e50204d5fbf15d0f322e08be39345accee34b61b3132ea29d706c3daebc82f9da8874f0cba7e3f0738c98d36faf6c90c129b03c11aaab863a5a93af91193a48583e309838df250a9d9db48272d096c7dab2ed20aba592f6e2efcedf6f5def1a384e708e1b7678a9e71ed16cf2d2f2c39f897a8ac9265167fc956331a82215c0754d1b0026859811060d9438509c5a9bc792e16d4f88a28b40ef81b505bd4724a983faddd34357833de20b92c15ef61470e5e7a60fae5a69d7d828295f547f7ae9378c7f2eb0bfa68655869af4ee9919e22b89cfc10dca1996cffd2d2dcfd1009d91d34cb65b44244fbf275e427f9e86a7c11df582736cfb0e8e15a1ffb21fb3a4391bfd781416a7cf9ee9621227d0f0e211ff269dee5b99994582b2dc4bf0e38e6e9eedc67f7bb87050465e144f73e6cede897df18bea1a9e8788f86b9d0d6e808542a26481178459a6b33492dac85ccfb4ae60d7f3c3917c39e8ad204b64255c944057bea81a2970c3b89a75eb7374261f183ed40f8a0ee79b18e9efebc9dc816fe309eaa2d2e112c690f7fc25629d0a6698a3fc3484fd8aa73313def4b9c4a9c359371f1dc086877ce6e33646f695d41a4902d4f77b9b880771547d6a50835f7708775a45313be6c151a2e649420781fedec414da8df6de106c9bbeb8fbc4bc02fd330e0f69ed25090f7ad5b4442f91893beb87530fb14abde221b9c6a3cd9eb2f7852388cb68e819435636d5a472d03d442066167f72abed2b9a735049942933e0b32272ec14ca1d28eb8fef603e0fa6a25ca2cdf3493f833f65bd39aa06341307232f0adc7967eef491f5070dd65e3d795c0f0eeb54ce5e3d69e9f7fa3733a75a18ac20729229f441b2e5db38fef3569218b4df985378005239e43e4af6f53320da3a7102bf833e288fb2ffd8ca4f42117f2fefff0646db148d141f5350f5772007698363b6252640d6e2ac9a878fc2b23ab59c7a51d8fb1ebb70d03ba625dead74ea681c51f64a402a2b02b22a88c3e66ad528a8963c80944361c7dfa41000e751b2aa9ddd5d3ea4aa83c2c05faec50941b00e48ea7a6e8b07f36abc71b4fd535eaec305444167dd61aed5e7c29b3daea014f8fc49b4f0a0c1174e6bba3bc971dd1156abcd3fc3683b418db1df22b4c463ec763c7849e4934c29ffedc7029f17829fe35c18fe910aac3479e00e60135a09e0629376d9b64f57b4b8fe3f05ef656592d3e668b1bf3b0a976bccb1c719e5a19042fa39387e0d56ac1c230d100838bff9d5d0c8b538f543a9b93613bbcb6234ece04f31044b08841a5d8fc4026833a1fe69ce7ef923bab89f96993574045ca772dfcbbae9e143a0cb6c3f0a2093d28bde8c243d54477a2753557c1751098570824caa298b3d812983b54a173ee954180ef52040cd51ef3a05d1287e6a0ac726d94c92bd9bff7d460c500a62d83037807be5fbe88c4f80b976aac595a64b140facfc9d8f7585e48d257ac61b7c6d5c1b58d471f22f131ad884b38af00e6b89284d45c0d5a35118e7c347543f9dba1fd52eeb0afcbcf1f083c4fca958cadc0007994b50e1466f5d0d6a825df77b5428d112d0dd776f6fcb109adc76f918afd5d3b91ba2533e18412bc7be9ed8d40dc19b74e104753628e59b789bead2bebddd9aa754fbc3ea07a6d22b14324c66c17b0f6092c08b4d31fb27f823ddbdb5ead375bf9aa6c11b615ea167dfcc94eeae93f89934e6407ffceacd7f029113b35ab0acdd25758971057375a275cae59c690ecc0b583150630a9e2ca35e25e9e035d8ab4041e3fca2c7bffd97adcd32e469740ef1803c2399c5e565ca5aa149333e6a537abc1d5f0440a5f5a100fa73d8a46a58da906150f869499ecdf1c2edd45e16b09be367d41638b4c3fdad12103426abfac3b6c7e07f426264536efcd31047a8f6d113e9cd528524118921133de4271dd0b64661092af49c54c7169fbab6f9f9d3c72f712234fa9fc4b0fc495fab50d4cd67c351532e06585f519eae9911787efa9be3e4a00c0b94cb6015a97ecf32ceada9bf0c334367895b6a10059e8998ea70ca9f513b8cf9ca4ee1dc10a8995af0a180c022b0b8841bed7f38d9b60235d5348300e49b1522f5f9fc57a94532da21d4870e516872538dc49603eb88ce54e4dc40352d4303495020476477117e4b43fd84d7adb9919a574c53f707aa5c159d7fbb1c2e03e194977428287ed6c895389f29d707300733656bd0e7017a5e181fa7197143d6f3f0e3d7191fd3aa9bae6afc76e5dd03faf7b0f9754bdc152e7a07b0f0320d0af6c16fa154986c1c58c0d2503a8a8d382991eb616b8ced2df1b55fe1292cecfe86a9a5d6704caa9d6ef9f3f7fb9071c807d49771b758d9cb602b38fdcea17ff8a93c34150e37c03b1fe13207d32a1af34c34732d68752718e53d20c46b79e2ef8901fcd7b1d3667a466060228d84402fa107c0253ee17feabf7ba6e441fcbf99b3ddd24ba6fb3ee13a59632acde4e2cc51ffc8c87adeba81710c1bc9bb78febbd846cad6a78cfc7b2b7a3662bdceb45de7288eaa53b82bd0d050e75dc522eabe99c437f487b9846dd5eca3b678db2c713597451d29f4dcb4e99f14743c185fd0b9703762f0504c9593744516bf0a0c4a6feec6420483b2ba6b0b7f4b644d1f718d8bc6015b06c7d23165ae0d7085aadc8b0817c089990e504afa12595c4ef11eaaf0a09d8da25dccb50c889f67b6af1137c78c99fee6c00963cff1796cac82fd0b944bd17f75ec2cdb678ac21cb3930ec22cc7f6aab6ac2cccd34219dc034d53d84e6a3cace5a216d2b91eaaa7b4dc53472d4a19bb6f3cd60bbdb89d4f72c6436c5a7002bb77544c9c8c704e78e463b6ae2f3c321931163b04e22c68e62dba35b7e6788c1220e8826cbf24df3e59eb1de67faae6eb3b0eae254b2f60cac420156a294324e6e102581a9732ae57acc3bf0f8d614d2ec2277d9ca178c063b561bb504813607a007472b7e7d4d7bc904e18f72e789961b76af4eae7d1bcd4bcf36c04b43a97d4a356ded7c3cc35ff3eb07e1dc64e4c378f30b095ced47f8b2d28efd103e80624c577bf7f26d3bd9a57045cafd7ffb8f0af2f11fd2cdf7b7cd450cfc8381c34e763410e84fe9f793bcff5da492a360de4f497f554127c7ba3f1a79c8d283d4b32f71ca1cc6559b513d368ac7640034eafd99610e4cf4333e91c308ace350ec57ebdea5f23ef38ad8e597736f83a935934ff04be05d4c5db07d666896e7c3e76c7c8627659458fb0c93293a7c1abeebc974054ad05d3a54d1a049fc39a0a67b3c36e8c5e02a69c600df8f2357e5d934691aab0ad6235d6aa98395a055a3336827b5e8559b41780e873fbe581cf29f6e04539b20ba3c2220bd88567e0b7481e95b7e37bcba0d685eae5f2e608da3deb712b2dc2dbdb4c09275711138822cb1d371530aaf608cbc09faa7afb1d3c7f9d4bf7963513f2c38060936a4e2e5e7171ba2d95f36e381f9e740e8aa609181454e7d9a94b8d3b0f82d0984f62283f996d10de4599712f233ab7de65c15271b2e28d97a7884cb95a373ddf36eaed9bf0029af42680f3c079d2b2707df738f416a7c0e47cf8b90e6b8fc7bdfcdb951067c5fdb5d3a865dfc3a69e1926f32bf5948888c5c001ca451f96b5b1028e8c06ec3f2fbad747901d4cc596fb7386ce5dc1236981e337cfe497467c9673181636322384c2a05216116a44f9e8f1efc55342851f7ddc9dd46c78c3a5aa084f5e687a912bea4615da3d27b693e58deee3b6d1209185ddbdcedf89262967633f35c1c4b7e62e17bfa06d43a0a9a5f78d984212545c6fe5b814c4446818ab0a855afcbed0a892db115d948c6bd6a6aa50c95d271b58b1008e276b99684f221942fc5349bfc495f79025dd5e057740b8c0d38a46d4a1013adce7b8aab596a8a04e4746d053fd0e33f47e7cde23d5bd0735c3e284e33676d32bf85c5497d0fb58b01187d3abfac28d67bac891b2753f71841963633fd6713bd502131fdf9adb7c034692bc6d51e3bca8e27d9b9439a9ca2e04a9658f19edc759894b4f72228897241b30915b4fc06bbeb57d666aa59b6d4061632cd46e6c5e9438ec69ea577d5649a08f8296655afb66d63aca2e6cd2ae8556a722206b7e2db0462f2013bd01eabe60eb5bcb30f57cd8cc58a89eb0cbd833277f8a60c599f55957ee73858ac9955730203aee55f21febcd16755794ddc6a9cac882030744f802643be35fb3df56a1af455d209e7575dc96ba947157f72d6561ce7ae31f9278b61405fa743429000fac36a28cbd12a9d05097af4543970df5f62f0488287e6c37f4be59ecf143fec77db014d49a20964bd2803695df70e78f134d67f8b452003362ace71221272174340e1e73b56e2520f08e417e77b11a30b46fe5c375b277f2760e0843e3c462c6035a6ec2bedc0a6403725c9469bb5425f13de395f81627bbf929a3e1b2e71b94fd554aaf959c5101178cf408c969162f9592968db7fcc2e86952132bf1a5e7ec21e80ada994f31f47461177c8cd717eea6e86f9befe92b4fa8ab0a7aeefe19280dc1e13bb5a90948ea6379b8f8b7cab67331aa602422ed862baf67e92d122827f788ea0377ed383ef81065d6d9b6718a24101400ba646f000da40560b85dfcc4506733c66e079d6a8188199d01ffb0289880c1c47cdbd113c16b5bbdc1927a4de8d87d272477ca333a26d0535bf1cf6f8b58283851189ab8495e782d8da147510b135a02c7347d8f6c4d0a302087a97ed7e76033ffe63d7b3d4bd5443f06b7bbab4abfac518a602858ca99f09f3c3219d755f2ff796601f7d5ad659fb05ac72bb4f73b0c62461d8654d42efe9ca2ec104e07af6c2a595d16f3e323bc6a2129b9e3ea92f33e2158cbe0ce4d4bead0c1120d66f9ec89faf004e3a9a6dbcaf6340adff98a10ad72349145ebe7ea85946bdc9afeba7051086c75426b1835f02e91f966aa74b65453bca1eaf4466acf12b4dad4884ea0d384ef540e703e1b6906e6b3252ec60c4faab34c14a296746ac9eeb9d8ed9dcd961e574a618129e127b4e231b138c7bad874ffc6238da704f18b047512f37bb1fe4d6fc79d990c41fb948ac4f04f113168e5aa7daa3b04d6c3d7b9d3ff27e0102136ac1aaa2cb5b97cef44a6e0ba596be60518b1f692a153a1f598b13b90c17e4e38b59899f7d54c2066f562746e532247d87e34cd0abd527d81813e919a62e595c008d0148832c57d8cd43409286a9bc25b30b56a9a072bc9788aac244cb3c097ce0b1ad3d67a99e1ce972b4a4467c0e602b4f4a0a5a85c3ed6c1f6018858ff109996e678082d83ef3b77a08f15daa01e6dc838cb356557899dbda8533f3a571760936f933e60cd4b9e5973714ede774f16f363512c212d9a7e110c1b49f622679f3b718e1404c7fdf9aaef8f2b3d7622c54dfc230ce27abb7ff4e64d8e094891e329ac6887dec6f2b22621d5388e97e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
