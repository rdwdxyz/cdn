<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"16058c75301f9e707886dd361dbdb1c55a9635cca4895197deaf73d62619a2c2bda54024efc0b23e3a5219daaff2019e256a6c8f672c1f2868a403272dab0cb85d5e1be5d35a59a96c1855c8bef1cb1b8fc807351c5195bc040617c513ac6ca533ebe8e255d4bb6b9de4a22d3c393b599cb9b76efcce54902ddb6b8431d7d3f823ac7be2e4ded37aec89cf757eb2e682adcd40da4ed8223a6960524f223db58674503bb091c0f7ccde9bd846f05f4f5a1bb3db5d153974e536148856b4267b4d83efe4ccb74de54fc504618a01b71519c0d11edebca4693c80b1c3816840c2723e4cfc2dc7d238bb274fa74a81700a5d43f2a6f0f895171d8f8e18d24a33ee5b4859ca32ad327547d26c017d7bcaeff8f0b5ca0e6742ec10f36e779aa23400e08a9c64dedc14a8b932c1b9cbce60d18e0497afc57f2f8bb27d979c8fedccd669beb639466d98379c71b30b1f98b3c210c9425e7260f8ebf68af4ca51a43880c006bd45ca34c8d763d5a7781017fbda34d18664f9b360e9d15b1b81ad78ae417c945454a0cc1f9c0661a144ad169591faeb55a74eb7023b811bbdcfca128ee7274282171005058cfa1436d51eb728aed5fc881d6fd3d53532a83835c76b02ce09a7b65cf9173bd99d849f9b9622df018ec2248625541b5730687dce1b789e7c680186be261062011baf4eb92440897b8c2dafb38c45071667995c165bb1d752c42fa472995b40466db9d8c49e680c3cc9857169aa0b14de0e3c60f005b298e26a1dfe069831bf2a9ba9b4ade0bd159aa39e31aafdcbf1f79b75b58fb5f3c0db0f04d2aa03cf77ee2011afaa704bb5750d51eae80150690cd5999402b7034a809528efaac990d0fe31e2581969c5292563ae0bef5875352e56e8011e256c5159dc645284815cbcdbddcb5942cb792911d02207f0a8f8232d317e862d6d4708c4d5ab1a97399abf819b15635d4f2a533853f13e73478b897322c356f76823e38b1a5ec81993c03c72f1c07cb0dfdbce8df0a41b2e50d3d932f0367d8605a0dad32b3892785486a1b7a6e6afbec24a208ebfbc6138a6864a1da5fcabc5b336429ec5407e6410791ed61acd2732ed50157674802ef5c0d9ba0d13dd5fbc42fb71a204a53133bfabc7b8f8a181494fa6d00a7fef8487cb0fb0ad84380766e49dd17ab79169dc2ef5b67eb3b9928ae183f429455dbae3cc9c5023c27bfccd6d8de6658303e74b4490f45943b58d333d68c90a185ec9725fafb63c630b2b6f3a4989ba78c325efd50d92cf4da8883a15ccd81dcf60dedb7c8c3501f4062f90df2313f75e9e1e402b4e76d5797b62dabd78de98b35c860ec2a7d5ab823d1e4ec244ba59519bcc431fdc2919390986c00e111c52cf4b730d8f258a97cef9f61a0b3441b13c2d7ac542e82b7353c698116508261dfe323d2d2249bf075cf27b64e053b59d476a56292bf0f47b2d5030a0163711f07c67101c77b40a44632e91605c45a995eebf88e8d8cc3c7b6f040bcf05bb4019e067ec5ea1add0f67ea6538df4909eae2a6139f3451d395337f65ca8743ebd83b16dca93119f4d2c832115e658b15b15cbffc60194e5b70d130261715f1156667d6f9025ede240cb0fa9dbbd8903d077e25c67db53feddfa9510b4e616a6360faa8be2552908f940ec9eeec4896c140ad2295d9ba4b89ab7d9b773fb09b44124f10d1943c522d32f8cb54954ebe6b4cc572e33fdc26587873db599213d325955fa719653805de5d5e2d35cd551f67f3508584f05a05a073f1036046737de8ae37b15630e2d6be99ae9fa8fb209db912c3cc1e53e49087c219dd70cac162fc85538f5acd6e21538aeccf7941f8f4c8dcee3a02d6501ab74bfca2ab27fe25124812d8358c1d17a047e1dcf6aacb046b50bdb955b5e78c875fbb147cd48b953ea97924e95847833860ee7199308b8ea533297ca99fdd00809b4727ce08d9d827bc6e4f0131465280f904661728afdbad8827a92f45b1e99c5353c1d6379c92956cca9e0bfb2bae51eb1c4a09775773d16afc2709979e9906e7020151f9a1a800bbb31c187eaecb6c08e86ecc74425e5e124dc77fcb1d3282e415cd01c103dc04cb2834629c6f5cc7b844194570f21dabe87aad064bea27d78f89c2d6120443489bd4475c7e7e22f0834b4b7d6de9fd5b3c96ff01e74ad66c476c65a5402a6c3559664d7234b01e59c16207374850bbe59076cba04fb6cbac47dbe4a736f3201b19e3791654dc7d646c4ac3401619ca315463fb710345ada7b5faa8bb15dcadf893d2822e3a7c2d0d7c378be76377a284ca87646c25d188680307915444ba0b206ffc9d3e03173543b2a11d871f53e61bc0025944159ad7506a1784ea86a3f5eca28af235271c8210c6ea99ff9da984c6aaaa93e7c5275f1bcd4cc591613b82caf38ffb00ce5713821f1c2b950402afcc711591e11abc315b6c4d0cec3ae5c8b3fdd591e7a0d485618502c228a82fad8cb02e86c7bdb89373ee14a8e66fb0cbab642175ca7d119765bd3ec40c14c0669bc96498741bed1ae0c8567107fb05d5d7a122d5cb9e7b7cad3b16e02f0509cabac7c64f755ae67208d5905117119be927854a779f1b0a81adbd33434749a14e483314a52b5883db7852fd38104c47b6166d6680c6adad18a3cc6ee5631ff099d0d9f480715f4907af16b200e983b776f40d2342a0bb5300a254268bdb48fd48cb849ebe2828e35503a85666302d512850020f6b00eeeafff19f34da9f6fdf672184bb8ce8f6dca540093713dbc88d51903adf2602e1a34a6880fdab414ab2d967194e8454bff2a800543b331558c8084edad86e243416b092bbbba9d12bc7bdb8ec3a7a4b63ac098b794b992eb0d00e3f34d248dcebccb35d5f12df0b4cb313937d0d74424fdec6ed4e45bb2587ca02b3e219c9de776398599235d0f828982f898b05537953e1a2fd38850b52dc47bca6c9bf16467d18ae215a1b3b1bc60546fd5ed8e8c8858d0d10df6b34b62b7fb34cd3f4a1e0c2eddc0facd8467306d0f4de6709d20af2418303b816966ed0f0fff2eedc09feb131db90a7fec013e9984755ea81c91723eb64486eb0d97a7d34547d3a734e71e83ac797fddccacc3bb6d466d9904ac7347c950fb532114a0653f6629e3b01424cf61784a98c63978eb48eab1db5dcf6d7b6a82884705217d62ec24a2752a79cc7904f541b0c6e0eab36594d57c47be74c60164f39c12e2786e720ffacc75b04803c454e15ad4c186a1787877c194cae0542be8f67c120b0bfba03e378277468ea09173bb9bc9a5cc2b8d52e3d7189dd63b216348bb4acc084eaf397203a791f11c9422d77462a22e8f875a0a9f0b188a439180f0bf54b9e47253848c54152ced59827e9f8503e86cdeefc95a56542ef2ab86306e1d709c012041a4bf2d5c8e27765c3e1c09c7e85fd4ad8a0bfa98b8386839801324fb5c8222396928c810daef2642d6f61d2c9803af0addc5096a41bbaa868e48c2e691e562de4b5060ba4885132fda609d6af7c7fefba0de4782b2905289cf68577a219f4db79dc45ad62960d14e7851fbb6100d0f3850f562bf5bd5c79e8fd3f935b55fe5d9a5046b186789b06a4701252117227a72e9ae9701ac3f99a7bc09e59b35092fa7d27a65bca492aca81725401948c513cfbc80d1677234ab8f404aee82d2a3798c50d7897e072627a168a39dd5d26fa4d646507227ccd8f6cc8e7f9eca51f0f75831b7ae53ef78ccfb678bc97a02982e35b37caa9dd7cac51bea98b6d53942ddb6979a125c7ef8b0df02a75c63bbec1aa8ab731933a14ed23cc05d1aa3329acc44028ea5fe31299269ba911d1498044ad260c43d3f8e2748428ebc440bf6d683bd0ac69d827c016d36b018fba3899b488908732d2ebff55180b3a8360cfdb0e4d185320e945eeafa338bb49a0bf14b1aec5975d523652c8b7230f3d0e13ca51b338cd8cbd3c9f9634965ffe8dd9cfe23586ff094813c38a9daae66b43c296b81161ab23b6bda19f1beb19219338bafacc922095a131174817fa2fcea44b3ad9cbbcb1103f3723e5d70c3919b2504aed7ffed57036e69e365bba66a6f208a33c17539ff00be5c3e5ca272b339fc230b966e10298e3ec9f7d1870d6376fd100a8b007ca40433671d08a5fa0ed25bfaad8db8382facce914736a37d7f0c9181ce5eadc6535ce1d0c363ad89aa851cb31f37c858c807e71c3296a528ed2dd8a974cec91d463e7a82da23bb3aeafb214033c35e0964efa34e2c834baa34f694571a81ab4eed27077be4a8935213203bc84eb49770d32fb88e4def314b07a291965f663963a8af2195fe8af3ee8ca0fed31555d82e41b752ca24f0acf9f21e1a5fa382ae359a8c83e48e842c95594180ba37cb7e92ec123f879150dd0f687c0f0da605f8ccf830836da9ba1c8be8ceff6ad9efb418c11c0968ea93816a29a5d6e1ff0b9a5e4e9b502aaf758892d957f47a94e84835d919790a0dd71b14825005a0ee1bafc1befae8f0412aa004a31fbc3edc430d6bcdeb67b764a9a72cb214cda7872774fc3e9f0fd416fbbe2681fe9f55efe6acecb5e6e286e6d148c401013b66103877a6b878694509e84eaf0a88b1d88462587246fabe5a3590c20dfa2fb7df1b9f28ce8844508ff5071aa356ab7e6c61642e2d2d64d8fe87537708da2cc964cc4a1b3579de36b0af81387b5537b709d28f796a4203f0542ffb1f3420ea21a0bd91f856a11e05400d09cb184031a312b76c3bf7bebc14c5e9dfef849375b5f666b22e5acf0945769b380f799929e94a9a097a730c3e1f590964b56f0e6783db0675e3b8566153a25e371040d9c15c6bb213ea59291207c23b9ab787890455455b4099cc666a933d66481de4fdc74e9c725f0671787425b413d0314f395639c53b1891d07e2cd2f1c69e4f297d6d85b3e908507a5853d5f8618eeccabd90f9edeb1e832d59fe10cd88a7d1bff7d693cd088a4ddc71638e57fd2136352d74f49293645ebc8448c2bcf723e5fc6e2ad976b0180a1e5a7da082727a281ebf1ed608ac98e5f742eee9f2a5646ee30bfdf6a6a870924c7b37b3f6c615b1df08ddefcd38abbe36ba8d9b8499340852b008acfec130e57a9969033c5a15ca0c9eb0ea7ed689648b7361ceb8a22f3f9f22f23c9f562415b0422a3c9945f5759e621110ab018459bf1f437c1d409bf6ce634179754fc8c86f491011c7f68c45bc84ad7798ea9734e3d166c50f5c7a8b7a4a9f662c0a5b5cc1bcab43fe5be3ade9271b20c29d3b84277d03105a18b5ab0fcbbc56d76591d4efaa01a00811d46d4bb1fa08c8058b1f189e162578cb4d1e1474d7546132f6b56f1f614ee1f6c05d0b73a2d235d9915c6ab119869c5091cbfe742b539ce1dad99d8b46834efb57905c21c9f78647b58dff60bd94ca3fac4a8a8336010f09b200c3cb380bb148116c8b703d7b0be1fafcd395bd29dc1d86598e5001d35ca47965200038c720b56a6841730a088ce1bed8950c5cf568e1d17b2a98e6a49c3518a6c54d557a6d88ca7c972f4b0191447e37fe89f5097c0ad0e028e9a3790f559a1dc60f6e094fc3187d32478f40eda064a32a301c9b87b6cd9c8e2d24972d6da445899ff892a950bea1d47d021833c19ec702fc3714efea829ff2406919665313cb60e7a863d28c8f27904280b4c9de026568a4ea9d3b1b5b756912e47815aa9d27f6e8d8174b77acb8bf900bef2a76dc889fbbdf5c641cb88e928d5367bb6a84a89b9177b17985260ab20a4fd9317baa36fd600d60228056f298a3ee2ad28363b6cf75ae2a758da98ca5d7cd57bc3a8d8a9e2c1d57a37e53b7d96027a00f2298ca089d9eda708b10e2fc11784819b1143368ed8482ff6d5a3aab8426f796180f5a131f8dc1d9439909572ccb30e757b61b9603f5d6e627582dfcdaca038614c5a676476373315615552b7d2ccb05bd94301b75682380699e93da5e4f26db2207f6f143b8e861f82cb08029ba96dc29959f6baed6ef261947f55ebb4ac3a9c54d282a4f7360da8106ad7a26c65797bc8e4892d622e7bd29f1f07fd2c5a9034d353b70ddb9121c3d9e0857c565615b7b04b42420bcae60cf892335575d68c724250e7e421f5e24d2498206cdba80c93e4735b0ed8feb6efbd3efe9a4eef1b6f38032d7a392a6e8eb143ef45f13a51c95efab7945b01a2eae4343473e8a287021cac87c5dbdb752ada80f96cd1da73fa28ba5e2a06a5957fce7644c5e79e90e7100c18a177b4b4bb9d8911ff7001362a4db014f53afb52b92177ab5758488309ca5e37fdcead69f8e5d58feb3fb1f82148f1b3880faecedbe23e596ab9264ca84b5694b6e9dba5c838fcd7b8a8f860dfc17f23beef58e12ea93cb2d3f4ab13a8e109347732476e68db23497c4261e9c132f6ac3f91857188acdd50261bc8e6e46d4e04e2c02d3765766a3307ccdb3914c3851afec8653695e84d96e7be755e2ba7f9a70381923f50a80b2f7b2c1588fb6394796d4f8ecb3b3af5156a2310bd27f767a9d0352c6c0b94812509075de2c0d0d799c0cccc59dc22ff969c4d3c2b6c5223af22dabaf5fab33109a8fd597abe7b9e3f8e0a194dbb5869035d073dd62e749873855e2590331c94cb81ef01e6f1e3795a33a2762f76326157a238c91b48bf08399754b77bc71f257b94955d0748ec9d6d6449593e9d822b8a805c66406f19cc0503ed0a8733c64535ef5b3c9899b47e0d358a17f36aae51dcf7257ef2a728e06db402242489a336630b06be34554c38ec2f7de614d9474f66e8707d95b6773c2f4003994d947c12c92712a0856f30080826df1174c73e8521e047980b3632d1009dab0a2edf0671424d6df3daf5dd09ae80c62580eb51b5f66764726ec986eaafd044b276a90d8aa6f3883da2956f1caabff0e2cee07b38ddd6fed9cbfa5522fef8249cf48d176f13c241a96184cbac6e20f727e60c33523943eefcc4a86c6d1f8a6511d7ed53fa563b20df506f0152b13d54800667606b71534def81b7d6c7b92e416769c6c46deace137bde5c766b17720704e932c10d03ec3fcc8a3d733ea443e9f0fe8e9bb06ed62b645b6b5c091ea7eec39cb35098797ad0f1787de1e6b739acb250ea8a39366d6dc88d485a6a6557b40f0049f823e80a6546161d1272a7912d6ddc39ac99404b4fd93b6f96c18701abbb8277063ac5b0e37935ec066d7a9e2fda2fd96637e9fe0731e8eea5bac0b54036dc641e32bdd8d30e535664fe40b4933fb2d193406e4bdbb5c5d8860526e27b17bfbc09033e1e18f232b1391f196de38e53cde4c1c4f3935a7a8c01dcc4fa838a94363591c50adb14a0e6ee45c13b12eb3b7f9963dbb02562790037dd0c9d0c57f2bcba028d2da01274e3a9a68b875e1283d2c49cb08c41233cf8ab56f1a4098d7ac2f67ebbaf6a62edbfb65bbff9d4c09ed8aad0c50adc5d0b7122cba0e6fe8bd9d9b6543dea023714d6b577e2ee634e5eec9ec21c610a4c48af5875bfaa8d6b57e293f89922d4674230e23aaa807c3bea24c24d52189e5c0cc7a9a2826b52a02956b46b3f0d34f19dd89c5272e62249aa40e64557161dba4304b620c8cf5ede951b47f512ddc3785300ae441dccde508b96dfd92348ba4ba913df72b278363525dedb95c156332a6a034d36a25b8f3ec7860f3e1ec9e63d816a306bf2c82e2f08307f8ec398631b923f4e67ee77b29d6b78899ae6841e03e89efbbbc0966b3518f2ef1f4f96ee4a8ae9bf8f4586577936368b18eecddce7866f3450d1454f8b56c8578a078cd53615c2cc8fc4b85c93d832ccc96bdc4958c4785770753f5b55239124df5aad52131c812212606ef1976a41ee2bce5c91a287d7066cfc247cb6b228cdac7a85896b41482c5c62fc710e567053cb0819c46cbe932887de7b51a25da721b7a6885a9d1fe7ff2467a35f1d7fdde503e0c6bed2c454a7d3d284cfa4cf24a5e37dacc2b3dc2a52958bf286f291e4e755ffdf04f3fa254007a955b09b1e00e5e7e3993c259559c73d1e64e8499a3acec52326afbf60f9e93ffbeceda9e2cd438764ffc8ac625f5af683aaf9deee15a1b058557725a0abbb55770976d5c47e75e23a8080ec392d8b0f723f6a3e958f7be6cf838e49c3c01c5df9e47c847f74dff13d5d77bdff41aa02e8261c3aeccdb54bfd07f3f72a0304b4cf94717b558065bf416f157a64695d4663b17a53f5360298e707ad3f2ad3e71337c00e1c16fc53e9bb021e363c509033828d761c8c6d12992623fa30ad7cf762781cfd14b2aa923d94308d5f997d188fc64539c4e1a22e293750282f1d3e768efe8ae379ba262c78e605056adf6a545edf56417567600533b89e3040d4f00e1998385994d3277e533193c5efe2d69f4c31c5b34893d2bc308481fe774b1c6a2a5ebecb9fcaaf3c3dab1a4394b6d9fa95a5880628b7307f8a546a71c044ae993b04e1ef8371de17045b31be0b021770560079d67f2f8a976bb5cae8dca4857006a3a3aad80bfb1657fbf9f71da0c92a004de54e43118cf3727075d11f6d05e6be7191be1fcc30b1ef0cd6233ff7327c58293b73786da4591b4faaab596228d8fb5ea1c162baa52f098c25bd4b017635af7b5eb6798e5ed5c4037e5ba36c5b03302fe1b68a725fa33b37744fb4dd92dbc71a67ee3610370cff139dc1ff76af00789e93c84e3e464c19d8e0379d5f72b8f98631e16a2f464191f7afff35e245ff7fcda722f4de9c00ced38fbaa55c2e9fdc9960b9fafda0fa2450960fa45cc9c147ca77def71a9a9779a73744484adb51fa5c0746f52f8f8568fa3f4d63c4820259c883fa0ac6cdf451562119b9e4dc89153e86ba1fa6615f68260d0a5a95526390b1f277ab7cc5ec183063a1e9f019c868c95316f8b76ecf777e14c4026fe83e9feccee995ad5d6fe3fdba81e051d552f136fc3dee75483468c51e4a445dd808fc631c86b56f459a25680cd166e793168b731210e98ef96105560b84d083bcdeab3244351be111faf9e9268f08f443c8b0c8dc76ca07e36fae5ddbacd62ee512a76df75948760a70ebc448cc96c87ba4a27b19c435c8480da4f5648999680a8f8a5ee2353078586d58aea3c1c7d41adb307f87282aa847990473394f53f2a6a4e220f6719b28dc572132a8698ad6e85a1c821b1322d7c4be1d1b422163e0cc3b175e6c99c5ddf7483b0457ce27dd384a13633346844d9a852ed5cf3a18e8116d0012ec34b5bc78ab50bbd93ca3a273ffdd837364a6db07b573ca27ee9fe550215423c37ea3b0ede498a6464491e72b2613e763587dc968ac75d3b129086faadbc1b06aa0eda0000779cf3778edd163734ea3ad877c646c7134762410bfa6c3c26f36d76f315d7448d8ad649d60c6d76679894ad4855e254bd1ecddc5466318c171c778737c2a22787a995e8b3c283746896a97f6f9f1dec23dbc1a4c48ff7eac90da944e56955f9c737bbbe561e7c45d5d4c7141aafd59bb19f59fb2879fc0b1afdd900e513fc655d9ad7be184dcb61457fea42822d7a8c571da73dbdc9f731b7d796207cfa82c8047240ac7215eeddd2ac9198148c5e24481f4db3292bc82a8251a7f5e548de477ebd85ff9da4c36f6d5aece4fce7959d39ed4c82874cbda08d30d863ef7ff2de59363f215967250b77944dba6d6113f070129c5223d1a8812b57b68338c185fbc455df56d070ec08524067c337d58a555b8fbe9e706e824ec48e38bf88eb2e7663c9594f4b6377dd0939e15f49866d159b4e937cd7f092b93373ea05b54a4750adacafe529f88f9014a7345e8e989154c22b20bf48b25f0ba2cd11b5f1052411cdef06421bc1fb89895f045507b311b74cb86da222c417a03a7389daabbb6844ea6cef171b2b03eb609cc0f533cdbeb1524fedc8bcfacc59c8bd7e5f6127e9a946ebe336de308224cc5dd9e78f6c7d0052c1068534da7c689c05fadaeabc1d43b0841e91584e43b74c7a0884d7a6ec9cf7308e6d2e47ffb7b4cccb1a54ed780cfe9663a2101995397dd29971ef446aa0b7efc2e429a4120b04a31dad709e36318934221166094caf2cc6c2366d8595acc3edad71aaf591c41e5f39faaac71a35e6a139811d9c472a0dde4bd329b5c4a5597b27ce39290ede5d63da005b3fc8bd1253ba518647aeb4566656e47c0f23a1ba1a0597b1a7d1c41acfa09d76d35e3a0701378a312ca431393a0d0a58e62e7b3f63c634d8031297aa73cef0ae4ffd40b76649c27a0508f186b0612e9abfd4cdfaa58120d111730ec9cebd0fd858a8af1f40e8e4ecf2e16060470acdba182fbd71a2db7fa68851b9171468db538719aff23482dcc098ce75fa58d56f3ae75a28655a730630f296ec9406c00d1664b29617486d4862d0c7a6e8060e931663e10d221cbc76caf17f8ca05cf7566143e9124cb2ddedc8e1db2efd68941fc5a5adbfe6c5f9a7023653844bae898a3c3bb45eea813177efbc0be7b47a33e58e909215372cac5a38ff1a5ce5703b82120c4937e6edbc99aa0a5d75a9daa54bf28d2a131a5699957638cc2e50a3d0e1ee68c1d9704c5580929530171a67a9cdf29731aad5a3375e35aaa3d914bb53cd1d71e6f001309681f8c765253faf540656af73d32ec57e975248494dc4485aa2eb414c1b1a7efa18491caba82560d7a04b26027a539a3d36b1cc998cb9c845e9b281398a318f4f6634383007984af0dbbb6d30013e1f6f9d7fb08ff1d6fed19cf52596a6a7b2609ed6f196c00cd21910dfbdab12276ad66e9839c6ef2576ce930cd8d546ea13259485123c641f094999d1ba56deb533cfddb48599641df31bfd858cc83bd97ba92f253eeaf688f6e366800c68d073ec5dc9992b53cb5ef74ad5021bc7d19e0538ce96f7e1d865e7a231892ac7cafa9365baa9ed5fa5c55ac8bf8163f4ef1fb5d5c5655e0ffd5a797e14a8d741beda2963c93b9ddfbe2ff1ec48d39ae7e6c3de441f5fe05c046f2ad736a1f1bcaefe734fc42a505b187d8993fe726e70258f202c2f6d893af75846b620de3b05ce41f33f8e8b4d4594a18d9f1823714a54140a95fb16d9fffd7945c516917c557e0a03c3f6410e90fbe5dbfb416fc6bb9500d851542b627b6155f9e00240f6d7a4ab7e05e84626b37e258398437245126c8a337b3b79de77a044a7756d02fc1936a44ac2a68af4ae073663b0617d85b4275c936199b251eebe78be0788b8bc204c45effb39da82eedc98a15a8a320b9d8af03dd710ecf83053ff33da58f98ecb364b64d7c54ae3b1bac5eb28d99a1d4600435c22f58b81acdd7fc2d2e6cb5ffe12097dc3d2c8ded04ab8be3043c946261e001d7df874ed6ddfca08b2aff391cba178b88bd7c26db375cb51e6e7348889f7e96de5a74bebdca453b7b8a87bc614593fafe17b217a3fcf90e68bca436ca253d7a29904d995d23fa31cdff7f73bf9dfd6ff43b42bc7dc0da2d844ae959aa104bd944aab473128acb84b842a0d4707af58c6037fe5718f9875e806fa86d8e5dd326609f88b45bc84f5806e7e2e993cdd936dd94bd8308413dcd7beee9835106f28bc0f69f1034e8b86c74659b64782192f2c927f5b07abe6e96f1063993c1a40453efff2def81ede05350a45dd5260d8fc8984c1be18520965307529a4868a2584af7194e14fb7206d721a56b3351f07e51613859cbdf91fee707b9fd999c01d02fe04c549a34622fc71d2347f4a05292a0e02fbd752d03026dcb5f4494778e5f78dd384be4fd1637c733713670eb5895445cd19acb20dc654b3cee5cec7ef6854d762ad486e14d2268bafdd1e3bdec0e5e6e76cb949da0fad5fa61ecce0520d80126f42315ecb70bd0130fca7825d61b9bc7632bc620ee9e417ebf183344bec980435c92a19f1b53ac1c52c2d7202e37d247319e19d6888536ae6794aff63f015dfafcdaadc7187f394a7fc2ca47f81f63522b62109807a56f9d99666d8b9056ae144f11885df9e0775cf855a77cc4a46ac299f2545327f4ee303b7c05c1ddc027a6190d12bbd34383a2eae0a4dd042ed6d1b73891032742d92cf29a410d2884a7b70027b44f7dc1edf530034a8137213a01f9dc6c918349fde6ecebc4ef111250c4c8966799f5b1b5b82f2e750153210807d2c7b767d0eabab46e5bc68681e024ece4fdd08962a04f595410662649082c4844e5379ea8df8a438dbb71d0f01181c4a597576cc6bddc9a64c1a5659a9d3ebd5b2d1c886a714cc667f4aaedacc40419b9aeeab2221c1f58e63873de9ef95dd97813dce8218de24dd256ef457a3fe31d5f273f13b5925cf74fe0b0af07f0a70e283262ffc70256e0cbad571018c231e96f5a132ad60a3bde00e9329e4c1cc78b1ac8c4f6b4483dea1fc5779b5cc680315e0fa62424a0dec39d3f00a33d0f08a2c98232fbd1f9d25d96a0e8a0d6a9e0250b5bed2b51dcbaee01001460ea66cedc0a7e3fd3b3fbfd8adbe02704fd41eba353b80d6ab7bf468de7076d15ecd62e49bf27e5368620048a1ac0edda779dedb7715e404217a2f48de8d1e6013a509626be5563ef3a2ad31f52365e07562f3dc65bef1e6662f5090e7252838caab28d76cc6a20a5b726e0abb9ca02cd5f80f99a835b1d02ec38876e75bb936f4ded5719045a3fd30a34acdbbb950747010e01fdf3b5d88ff98f1c29542a473ca23bccb359ef14fc413bfb92ff6a900fc12ddd3740ce2c4e4cd2f732d340cc4804f6385831e6562f3bbb6e85d70bd699eeff2a8a176124d5b70223db03a107b95f47cf1a377cc5207e7b31e7077da5de046aee56b5d7ec80dbb8449ee3efcb2f94bf97d5bea0b23eaf7985b9a1a71106f451444b4c5fa73ae6ea1b008ea0163aca39036844c96c773dd2acce006eefba50e7f98f5199fbb03961422724e65278adc9ae9e8eeae024e6580012f5e5d8547826345c67603db02188dc730b94e448d06cb7257be81a3802475036de26c88d6234b12bfb2737b2954f43afb1967d1e09caccff0331e14c31e426215db3d31ebdafcae3c6d7438ba85d3f44ce91828e0bc620ed161c8a4ff8fdc046ad9c7f4df491985d2ce49e6b44c6d6cfadebe9ecb2f8b3ae1d0ec132237382a26b1a6a2dd27ba8a1a2f1325b748fcef7777f876e4e1446a4991748b5fa8f77498417a2c01a2b08cf600c9044e4dda3e05f9ed7e3a7ba56236194826f8fde93b82f7021d26857be07f34c7422bec67faf00b50333ab3f74f9b9239ff1e5da009d9358d06ec4d72c653cd864c6fe6d16270f5c47766b867d529483fad3173c24221efc0427fbfb461aaffa5cc51df00f57309dc37693cb899f1c96b9524a6212de094c0b5ec898a03036f1ccc07e84baf85599fef3029fd97ff84bd0f6a21c8deb84189d4d52b40f9dabc8f452870f40d56f291200da541ed75431ff09cfa16ad8561b28b22e1b4652b2094f8ef10a71586da512a2122e030869bc842a176a75de9832a603c8bfb96f11eefd468f6a9f9b20917e6a80c5d550c2ec7aa14ff2591a8563b3ff3357ac35bc59bd3a766a61b7782bfec6da5bf6eaf0e389961f13b966da453cf3e95c7d84d649ddfbf8ef540fc74f8b372a33aed8c4395ed66e4aa70f59a9e3f413fe29f637e1f0c48f1519de1a22e6abdf86900c7340cdd42fa617143633f7545f7807c58749d59596e356f9d18b6c4ae8c0cd01331445a05d0c6d33a2fb640514f4305bb5c124e7468676321c34a9a5da420f90d13c3b3ab6a197543d15ee64c4bf5cb7bdb3784361d7860fab84ca72da9169c8764c7d62e650202d372fcb894e93bf6ca4ceefca274a305a400aa5a395c60e3d05dad649ec22c6e3c02444f228faed47cce503c068a293ee82f9f5665245350521bfedede5e128b48d553b695c88e7551c5a6fab082babdd1a0dc96b1e3c7cc423c14d046f7e2119d95e6514f7f1587cc9634fee3fbd77ff6953593a594d40be1d40b43979857292325a03e4db9a3f57a50509914a4989d0ee113b8180b9746cce81175dd4b3a438c598fb2b46e15b7ad0515e91f30da957f71c84dcf4372aabc63330d5a980d90ea652aed67dea0d2e8f9cefb3406e2894ad32e10390e6ecabb4b75ed41241c382e37bcbabc5f9716f50a4c599f87e732f24d01561fd7d580be04004f5d1c6b49c01e9186cb9f93d0e61a179d853357ea07322fa02233fba2f4772067230a0343bdcbecb399e75f4f90f3a3d66a1471c75af5fdb486c847f89adee69f54dafc537d59a6049857bd01edaab80e34eddec848089982138e89a4265fa275e0f755e86ff38c43a84c002977e4eefecd89231cd68018b35033c251e91be82e7a5bd68287abf18f4565a3e518ee8adb027048179721a2bfde63caa644edf8853a82615dc0babf9e30f3af007b8cc1f5093e58827e2db53e4815db9474f9b55034f0f87015c36db80c276881b893ed4ed19858a72a8ec29be87b44aa454a22784965530c548d7fd535c8bb450b8c14e5f68e7ad73730fe6d5e9d4ea5714aec904fe43a7fd68bee6de85c60bc093247ba50d4f2e510ed89a2de195b8030b6ccd9cea588fd914e00cfe13b73b6dc4044a8d95837a1a618c00958750fb51f062a8241a59eed5578a39dc6f9b80ec73adb5b0ea3801e83801c9ff7108e021375b7824405f4d1abf24ed774eb97eb759eb59425282b1c3a06ef0f3fe617b8ee5f252391d4618c82f424e3fd4e01f51d040f2d87ae4596e5e06c96694a2029eb59c7adf748daa60ba7ee994c2ca68a6118832dfeae17ead40322534f06f2c5f660aff59a3c0ffb28b8f2a3bdcb31ae7faba64710ccda8b0c4112bca45e95cd994fa05a6b1dbab00d2fe83641deab53b28c9ad9145be925b3790483a6bb03d6d10fc23f7212fa9c035189a7a8fdecca158c42d48b961fc163b1bd4ce454dd6ad419ee08c9da918a3279fddfb7de76d6a42cb0b553f705c8bab6f13e9ddc187e02b37a73ebddc37cde5ce9461f5c54c3086d6f4a97949f250b33adc878825dd045bab11d154b40fb7a19e7e8e8b6dba0e2eca751a3d53d76db9a19a761403ba94f83945d77d23f95eaa5eb8d7e0f3828d263eef14d895137a4d383ffecf16b7b2c0e28516e22e9c5b8e1f054a6ee6906ae13200809ea900a98bfb90defee24d4c80d959a08c65d5f122a1cf121cc691fcc6b3458ffb3085702c43ce58154e2f789d296d8c8d90bb76f57ab8e53a31be1b93e1c0feafd9d55668b56a2128758017eba2f135f34c339f03bbc298eb7af9ab3bd6b6b0fb830be48a3f1beba35932a421dacffca7d3a00e15a323017b4b5c1045097109a8c79f77b13607fd9e4f7d53b46c8baa2a8bacd5792b162fa45f60cb71336fd0ad37dca96ea36e652cad601acba6c46d0a0ce9e8596b8ea33624f797e82af054145069fbbdf43c7f714cd1db453a52be6101be83abd33e11f1086270c07247d74e927ed39311745cabc2d686cf7011581d3319f41a9a31df48ad46b8aa5c97aa214b8cfff3f045577a9e587248750a5bff87aefbe030a4d25c3c9fd41e1c187537db1b2430dbf561d3859ce0bb53a776ae6a4dc04f3aa6ed9bf13f9fded62e92d1915d6f6605a2edb61af9b7f7e05c82052e8032ca13b13c2aae8305d273891c3573b7b665394e0282cb94212e2dc77d0bcc3214c212b7d6ec53b04f04b483b7193a688826e5c5612b694c215d91b3ff7d651caea0cccb2b46319310b4a6269cb83757f4b3099e9d64225935de262222fee570b7390a793e025a3989be6bbf4a3c96adf80e9b2f04701b2e31db77f36dbab26bde1064b2f060e1a9f61c3b4aa3edfb66df068180604ca17b9cc85e1bb528cf62a32b571f60eb309938b1048766c786c2b0fdb312ec1b76911cfb686d7db858c270c6f624eb0f7debbd2f7f08a2b31b4f2e408d7567099ca3b3ede4a2e9769eaf72303a71e01ebccd1ce969975381bc5d8517dbdeb614320d2669e7e16da34cda473089c65f8c2534579c58940e0a736c064e9ae019f9bbf30d43180c0d05a05f1232cb5e2e598b7985622e9c90319686ab9331d415b9cc1b1e7fe6c2a39bd14986e477d8bf386d5ff5d265367f6756f84cca8e508731252bd4ba1550bed36a5836d0571c2fb2f69f092d0aada910776b00e4b3f7bce2a9c6d0ad45d8772786bae149147bece3ace5c8e6629a09111895fb18dd96b6bce219f2784238975f26b8e0b8da58829cd52a15c92e1ed69de2becb1de36325ce91d9b49de0670185b506bdd248dabb58cffa547355bd5b335f5f6bc576e98b9e96c48d7b7212882b217384e4fefbec0370272ee145be97d9ed6775aaeeef53f4d6586cb00c9a3ec14ed3cbf90cf033e8b9e775273c9a312da6b933fdc0079fdf8ca6f72dc6159ed046f5d3450b258cdc21d1dcdeb11d6efa50f6008453811b9c84def64c6ec15dfb7db7c5a01206a366a7a694c92c2513e2d82b5c0724a1b6b86de6e622f1e85f7bbfc4819d1e6c242f4085681b403e30d22fb2b8098dc5f60430354eac58f7f641f87bec4c56cf2e83a879bbbce7ec841b0c2c15e37056a18aced6fc1ac59e13a62c7e798e7ee520944323bc01b30942ceca143de311f8d95b1a41dc357652622039a3717a1e8a4010b41c3d49f9e4197c98e4155c9ebe795c477200250cf50ca1cb53e3856029e11b57036fa4d15762d19c6ac7b6ee05f43e141b83a9e892bb0f009efab664e5237635fb0593e4c07bfac6f3cb0723a634386b104e7d4b88641c910b6bc225a44d20a0e5afcf9d21ed71ee112bcdb420d54ef1e34399a29debb0f932343b0dcee7127b5ed7970867e5e7f72187167602158d15c7b36c26aa1b334c740bf29100da75796ccef2899c71052efab3ea2d3e350e11399bb58725fc7deb13404f24a55900ebbad936c898baa42f5c42f5979d75b1fda8ba52536abb7c2c400f160c2e929ae85b3d0d6a3b11166ce7f190ef4df0cba6813f21a011b3803fdddfc1a2ed2d66f74a0eef43b82b91dd49dca1a9e1a200ad4a36832251f06defdefd4cbdb272a53c2ee661dc0776d15fa137e34ef24eac2b755ee0f7d21e369a7afa6a6274945ce141a27b18f35b1a6a1ebaa82dea77377ec9918ff2b80fe5b7c1e8b883da59c8ede889a81696b16a1f8755832cd26d3f45831e3e1ec0266c2faeefd4b472ccc02c2b118d9aff0efd0374ecce3f02aae6ef719400b326d59bbedcfb21f7c2fad63191ee8f68fcb815354d72a4add0c04655a7d724d84ce897581bf084f2b2ddb9e7cadbf7d72b712f16dabb96a0c61f023f65b4b88290109d271548793959c0ad40132273baebffad77a143199f32170a698549b2ef543a36570248ff60fe8794daa6d4e53a848194d169ffa69157c13cf7de07dbc09b770faa1f31587048f983b9bac5999beb0200b565fa513b5893de28ed70f0945d83ae6f5cdfeeb7df6c39f8ca49323d2aba9183a7db2252b7c8913269cad13b63e8c1ac2d34264b8aca1c0e662b16f39c3190f4e163ae5fb8dcfbc796f4e6b8edab9a583bf9ddf26c4d285239666540cc0896966386efe7c6c6d95cce7a157fd9a48ce586daf74cfba4f52a4dce5a2a6d8343466895e90463d57c7d22b00eb430cb878715edec14f3eac251dc89a3607e560cbc14eee4336a12b814829fe883464751f07a79b67c91d27570a93dd20c13864e2d319e438174cd71ca3b3f7b63110f16ef2fe39d5441d3bacf4b76089554a53921e20a1d722d3ecaec76d3fcf00462ca65fd13e57da0cbb19fed3072e7da45f79c519137ab40030240bc52a0277501128a91792d4abd12ed333dd300a32feb2037aeeca67aabbca4983069674fea3008b8e8a4e4d2a32af9e69500d798f3c0b168cd34eac6ad17d699f600f790c4b846b9367b7118df09448d9f5b5051d7fb070dc3090db57087f7fa93de649c722351749673d87ec6a24b0c789ed6aa92863e9c8687e7ff621d81c1bbc640912942a2f071a79b2dcff466ac58ba02734bd30b4be96709f6e3c519424527c2c0c0540210ff1258ca9cb202706b34ee444e71c0c0da6c860b95da7c891c8dc2b871e5ef51fc1756656ee8fe6a58d7ba9c3d0b62a887b9848bff1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
