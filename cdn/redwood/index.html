<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cd9b30b968f6b30e540c931ff405a456c2f22183cee3ef1c9e7f93ec4941eac421e9724a94a6fe9d55c22e8c0587b83d094868099840a5d748a1405570549a12a42fd26f372d65a4371ce39f6b025f7febbcff5df8b40ec763d1dbce8735fe35368873a674539a9a776c125eb2e482b85232373ee96335dacf648d3c1ecccfd6e852aba17b0faf12ce337cd418e85c3c14a5f1cceb6ef0a6081123f01d137af9284a482b1d02064194337c838f9735bf441e007cddde5c4777d48c9beb056d28e7f13f55cf188781fc332718b7e3e75da71c8c0ecd97be4d84eceb06006d440caf165bec2b989257e80cee693496f445519feef26f777c45a48950336b7cef5516d8f9d75aec65f2d4eb2ee9ad741cd99c8f4c9325e1d6c02af8a83e48f600cf3c2944e231596d1d76dabdbd60008950bb7677fe3b862d7ad2e69af5545dd3cb87266151a26531296d8b0d051e82bdbacda2451e08702a85ddf93c49dd787f1f1c68aa5de40955b76e9f6c228da199aecc38bdc058b422d5e27d702fe2e431c3c411988ac39b0d1d2d5b7ba7836238995ee78dd9b32132a652500a893588afc836365f532a6fac559b9ce96b5d84c699ddba54de73af412c2eb1966de1433f79ce9fecad263733da3d9576afb505176f4ab098ec03e7711ee3621009a556965e529b765576a0bf3da514e2244d6062b41300d8afa928d39bfb4991d45e7308fc4b3f1e85defc5810900f7d6ea493a5cb24f9ba5dbe1a9ef18c9c608a60582adcb50e1eb99f63c39fee8161d0d5bfc1c54868d00ef54eb7d8c51a58e128dbf16f1a57c439244e5069bf070262d46ee71dbf7219305451c9e28dccde6b4f8831800f39af518c76a82f7bc30588e796fb1285a59d8632264678e434b438416fa062a738dd98793561706e1a65fb633ee95c36bbdfc4af25e002c612974b245057e852fa820b6b29dcfdcb3dfa7147611489d54ec5fdfdd303e2d5c83c5531a267f05f698db5024c27ff48a4e6b896748c2d0edf3858017ecd272d1ad84735aef63f03598056491afb1a2e4842bc80546c758529e4a0b35ee0de55a3e2781121ccb718328201e3f8085d00073610ca4388917c79fbb2e55eb257e6badd8b4a281590bc6625231ae436871ee394f555b6d7d95624ac415d4ee94ba38054851e97c1e1ce6d178f4ae75b7513293e6489873ba98be40a5d44ae5ab6a26c212b22070b2e9cb13241a9b03dcf127bf1e6f7502181b8c092d32fc523a9fdb7afb01a08039d400e7123ed2df958471fe4331c3c7e8d24b12e5fec533fbebd7f9d31c82a1e752bc391790b6363e846bcdfc1cc60bdc2c0736feb3537518a9f2d64401a565d2eb55ebf9f3a17cb789ccfa710a57125703c113fde4a8f82a8f6b279ce89a8b15a3cb9fa674f8ea07d02a23b6aa8514e39c04f6e99f8bc8c0b77754157f7b7f990b4cba18091611f20f7448e5b610f3cfd9a3f75f5f38c464907bceb47bf0857376424843e7087aa905b5abf84d747359dfc4174df226b0e7c1a40aa8bb6cecf226b0f92a2b4354825e3c2564baa921d232517098a6a28d00674441d816d2bb68e5abefa682fd3572a5a10b314f8c48c3221366923379912c2df37394f8a54864ad1bdd8703dc3ae0f2b62bdfebe859bbfbd3a108542ad50e0531faf1fb686d11996a20bb1af3bd518794302dbee95788717618d126539ce4911de528c36d1f73f72e312bdfb7f40f92613bd36c6df8edd6257f34bc3ab4846480fa70dae617cbdbf4bc39835f608b3fd3c764cbd1cfc1a2d5dcaa4a926cff94235a9890366974c6c5b20690416fa705f88ca04480921f5b8140a09a8ab745364f61d90e013dd2a6ba623459483a2e760a3d2ebd089391cec612c86018d34d7d946eb328a0599b7d54d37149be0cf6c2ca6185cd54da3a0c57ed3a4bb86cc89a815888ad533167318fe5c94e9e9c94ac2d3983c6d48ff90be0b767c535d59c39de8e74c88f5b8996006c67533d48500f0a7ae97ec4872d8a0d5dcc1346d4b0d1ebd5670e7c96be4da2eb53f52d2c984f21422ac68a9a77570bd1234f068843ab5e205cbc6cd7b5197516a794ad9c83f4467f844e8b601f4d06232b6d1d16304e615305259c8fecef7571238b61dc642a31c6618537082f1358a7d74c4df96d9f48adcba248edbd853be29780c412b744224f279543313b2f4aaded5f85f31aebf3fbf2580276694d7e00891e336020afbea3f09f0b9a1aa505899f7aecc1531fc371b2edcebebc2f196627cf27ee792b76f4f392817d437b1049ff0812cbe0eb25e0d7eeedf234621ef824e68de9d9250cc3598563caebe6722125df1353c646753c274a19b4c86f94b58b393ab35cfa97b5e7dc3d208785aebcf6b51565468039a495a93cdeab37fcc900c66be2168c1a36b95049518739536eff7a18eabf96b496ae9d570ef35c267957543b3695db425a68769858bea02ab1f81596fbcd8c7f677e33282181a1af9e09e507dc7003a5b9e7869d3aa35fe6c247a8a5aa1b949f29721ed0b06f4cfd7c2e6535f5bc401b5238cf6ab5314f1596367baa5a4f5eddc2b265459873116c2ec96d00725789158ae3b76d623b7bf1e80dddb7a0acef18ca5c8a81ca669361299d9b6ec258d86c9b2e0fc68d949cb56dc0be9ed94c4c051bcbf6a35ae64f0f7db1110aaa7947271d9a4b802413362cdebb071fad4440cc84d8c983995d60bf2d1b43b01ce1ec606320cad4366baccb18584fc49d3ac6184f614546c182bad904f327582dc333372968b9e5d45c901c9b5f2b96b54eaac77118cd284140db470e1249b21e926bcdb7c9a6887c7b30ed35f6da20edcd59d06a50ccaaa33252abd9d319cb26fff2f2e055075f19616ae93341659702ef6b40081c7ee56455a974bd7b15d3efe5e6118cced3a2646a58e317c1d9116d59a3cf3f370beaeaebd671edee1292c28501abbb4c9b15534e1e14b39c662b8617969e5ff6358721c24a3a923e75300bee82173e3153031401588a603a90e115d6be7f7156a8bb28b163eb27919ed5810f36dc1ddff35a3a7993d564c214fade24a4cb3fc9683dfd8aff909363506bf05c880525c5f0af421705abf89432061f53e2938cccec3749159a36537de71c83cad0424dbf716355b2e21f208932fc9d35b7952d15bb84420737d96b72a39e2b573e0cbd996713dafd9334f753f8a75ccb8bc9575e2eb052182a0ec4c4b001e1e41df80b18bf662eb8fc87984f41f1727ab72dfe12882164db21143feb22d07bee46045bcc1b5c640d2edb0ee0f1b2496ba58629c52cbed4f221800ec38c31d369edddb430ef3bb889f3b067eae332f27138a7015c285daefe3e4c0697c81d179539128d9824a8956a73fd139be0de6b888f67e29e79794f37b9913939f2037326d2d64afe23c92933e8fbd0226b06c4c7d2aecabcca754c6217e8a48b46fcff0c1a89a4804f53d72712411124e25be9abb834c2fcb9dd47374eefceb1d381a20569cacc506524f2f658e5b5bbd6096ecf8b2c88f9375fcf8421ae681c779d21ba5ad7eeb835d9c3edf6239feb3a5bc5d0ba18f537fde7df6f81c09790977cbe8d8c0aee2ef495f8c5c6b5b94793c821c8aeb75fc2dfef8dbc7175837935d5d438bfecb4e80aadeac7d5cb02e1fdbb3b901581b6939edcb8cb04860ddfdeb90a45cf9e2ef67de4719d28e3fc9d33e287daa8babdf9e82ec1d5366331364181497ef03f492cf01c9fe351737efaef0570ff36110be6a3fc5d52143d9f31433c5d1e6e9dd058df0ce9c3b262eb30948f1cca6633b61984697274601a92052b9762b8495c9138aa3a35731e360d2384a10d62a47b883a664d064e5da5d3cb733149cbb08f3a9e25ef820f56b5425f7ec59a758cee41a5445c750b5e9987433bd901e89a2d323b03152c39e1654922b4d39046c5169b7b3657110f11c542914872454c03312902bcbe94d1e967fb535b0621b9a57f00eec165b80a56247da26c77e852bb21f80dad55b3316d9ff35a81aa003034bbcec852ff7bf58ffb977e3fecdd4d95a5ac82d9b1bbc039e5a4f989e427d698b1a9d741ac48d3a174e22a0b3e7993805ed0da7cd4d36edbaa74adf5e2bff2281e11eb9d87e07c4ffe783cefc13e4fb56b0fe8b5ef2dd84596b037687d058831a89ffa12255ef5cf3f583b6de1a76faed853dadd8d5be58ad23a5badf4d687fffc2007e77502d447f0cd98fcc41e56d6c24c524ec0fad5686f7bb0ffe6d9a431c6828c18bb086046a01d279079e1cf6e3f1705e2ac56cd408107eebd3d80a9849f766afa1060bd98b27b3c033e71484c4d444b2ef3d910c083513cd60fa724858abe5f0e652f6b4901e1c04ca0db4022653c173e190c66af078dddadc27e80f40b8b79618248abc4c1121f70e3a42c3ea65d30983abe7d1dd27c39f1b9f8f0fd35c8811ad36cc16da874af9ca40c241857367af7a2600b5d24922c91d3434768450c9c585f5706e6a39dfacd1ad4acceba6af57eee44c4fc32b6949606d5c6dfccda7ca54d1940ac38e62d76f686350c401e4946546620efd4e23caa09093d8d15f8a6c11b510ffcf4590789a2fadc7bd4839f8156002b4242f558547ada6d707874672e1f62065920b95ecb4ae378ae2765d307475c8e0c3b680eff663e7b1e3483c796d0692f30affc76a71b45842ab112961089255a404ea2e08dad0a70d9e3d85bb243964638048d7191636666ea4f6f4c3d0e96067ea74b117b4421cef47988f43cc26a427a58b8d1266fd67ab337e5100bcd756e02b2822aae5fb2612d9395835edab61e149dc0604edd78469577a6371849e5f46a03228021ded9d16601788ee9112001b3babdefa1815f4fea87e97f3d117c56e13f81f8ac75a3bcdf037722eb7b40a9e015b79d9b7f360035949476bc8467810003139a0616ed73785242d0d73603c6eaaba2f0d78a0e3eb67d57c7c4ccd1aec90da7512cb1f2da221c60d42aaefb3ae7ec649122e864cd001839d81d9b0c1a65214af0f0b415874f6904b2a4720f2a6f8f1361ca416090003c6a45bb9cc496a91bf64c3168da8a20ddedf3319d20fce6fa1c3a25898d907e1f73e7eb01593a6c99ddbc498b70a214674623e6a5e4d728f8bc62c1e2c845f83f65a709ee7292e3662a48afd3882c5bfbd99a7d7bc4302822f0d7c279769a144c01aaf706d80541c0d677cf913f03d115aba11297f0cc13952e453291965537c908ae6897a0e2e63d6121428f00d25c346e525c18a449c07cf2df7469bfb2875e49559a5624fb3a2e89bd3d3956db4bdea26ee6a032f014853d9dd41f554460cc0fb71f88f01cdbf8990c4556b47834b784edac5d92fa52f58dca9662aa970879b79d8481d9282c689a6d46999ddf0943f1ad59b891236441165d46e939e38c53a7bc6aac9e20419ed3b772d8e9185e56fedf43f279f9fef5c39ad8a41263d87b68696cd3a75be5a1846ab1c744c3f94543c3b35b5a7570878867f3eba3137a16e78c005a4d7b014e002f17088da1c5f2e1ac3b5f9c6d99be774dfe420203a78eafb5aba32db4cdef7788cc074dfd35be1832fa9ab26e3b2ca57667d44866f5ad8988a524a44ae412a01efcf7201b32e99304cba76ed5095029f9f86454be6bc332780b64ed06ff9d0fe5a8245b8ce663524812462bbfd1d405c1f5c2661443620340d870d761f2b08fa57062b283bc15a12e45fe6129c1c4f0354fe0ad480e9f26f6055ffc5708c2513fdd43f044e5f5e663e24af5ba68d007bdefec26cf1325376b35a66cdc0a5326e27021eba41e1baf04815fd33f8c253a3b0c2e303deab75a6941d3f65582e5d3120edd04a3420cb6b6b3e57e11bc1249a5198ac4387e705741eb59671320abc86b54e352bc181b0f0ed23a28c7d2aa49cf8a0ab385b080fec867b59e2c6afc4cabda0cb4d42b7e2b31220414bb5ba0d890158a634a612c21c13b67690317d574b796973afc30691ce5813b0561bbacd2cfcb972160ae56c4012a7366b18b5bdfd7eefaea4875774889fcf6abd46b50bb5d89c586f05aaf6a711e565bb165199f5897b8cede98d3f14511a8597edf79ea910a97ad02b6f908f92370f2c4653ade3d76dc25f844c9231d8a5c140fefe8d7c1be6e0bf2d9751f0fd8ee8f86dc56144b02c4371c54fddb1ba856d90569d9ac2fcc2de41722cae8040d0466a638bc85c7a53344f4de4222defbb1792bab1f7ff1445bfba095db144c697847c7075da2a7ec68e5d1963fa63988f013818043c578bbe9383942d5cd657bc1111bb7c85381d8897fa551a72b3501161d5e109ae8cf886d34ed9d506506c0ab6b6ec493fd772b26302fd629a1026fce889838055122387ee36ec6f4b6fad6238b2d7c9d5e3441fd4b5ced968039d036e1a0f514c45b073981bcba94fddcfc305834a89419ad9211b3b0cf05a642382207a8e8ac3dabbba9561dba825a7e3d9f74f6d70cdb5761d24615093919d2039b83da273ae78f22fb4fd8e54efe3554e55542b20627b009f5eec69b8fd58966d9d81e90d4e040bdc7a8c55bb3a16e28ee89a438339a5610b1bc9306db92d07f205d44abcaf880f5a31a2551f3a200904c776fb02744265f20091b90f3c583a3f2998552980ce47c37e1560c851702d07db1ccaf50ee00927463deb3cb1ed4a393078ae57bd55aa1b72504ba5f91e9af8cca3631a2db761820493c9edc3ac7f7847661373d925a9d458acae266ad7a507a6c64dbb1a44c510c917d9cf1a8bde476b68b5c56708df7d9e6e7ae5ce4ffecb9520de5cecfa870bb998c5fbb608f267b4934a4519ec4dd9596fb4ca82a9dc12e70c06c6e0929e2fa2bdaa03c0dcb3b14ebacf84833b7a4a8b5572a97744dcbf3eb8f859a45d95fcf8dc548ba02835bc37090f20831687621451e5ea4f57c863403de995dcc1aef21adaf3e06fe066914eff012dbefba5953d48cab4bd51723200bbd3a6c00877b4cfd7a2b13eeeb62fd9c8939a131f01668bd11e3f98239a7d65e2ae82bf370822183a5b96b57084323196226976d6f6fff16fd0e3f67c09bfd4bbde360d5db8038e6e17eaa88911a42b931bd8e7b83a148f5a45465a731cb1209f9007910f91424a38f23c9980fff0a041f80905ef8f9bff15f39fd5b123914d8edb7c0ca7bc229f32c40bc58a2bf624e9f4363f7323294ccb4c8865f31e1da349321dc60955a666441e0b81eb94168b49fb48e79f611cc5df24f07bb31d82c635ee9a738715bcbc6c87a0e1cc52ca9deceaf5d06d30c7def671a62dee1157c6aa0f8904e08a929c1223b96a27d7f35ece23fc6e701b281351a7d96f4b6d3796e1605750c01d05d96223fbd31af941d8934a5099a9ee0907308d4428fd5f1b13c9ba3db2e97b59c66a4c13ecf4d0544a05a70ff9215872c4ee3af58a896368916d81be8af05c761f73d68fbe0e952f4c4ffe001658bd858f9458558c0831e3cf5da28de233a72f3e2b40cf8b2ed5f26e7607fede5b50588f58ea1d3bb0ffff4a88075fd9a7f4a66bbd5531ddb4adfa4300691002fa06968fcfb890033a1e78be57715fee0fb43bbee1fb69647e8d9a5838f675f0d6f591b7830ada638b530291d91dfab8f21325086687a77139eefe4a6496053ec02c3b0ded69cd0890e7dc65d300b85657322cdc62dfc8edac3d30c22e4a4e9b1fe10c4c92268577bc36190bf620b8f56251a414ffb671e1b4ca371aba89e935c2a3bb2b61dc8aa3b9d165f075e6a02f9e80717a8fbdd785feb34f05c0a0a5fde79655746a9bcd1ddb009b2c2db31d099db195125ad22a3fc5939f1d9a60e0339432e7b3e035f6d35f814df73489cb431ed94ce738099f6525d84efbdd1281a2385476f194f15f74a8ed77c2278caa45008d765c86c3152c99f5a231e90db89e0e4ac62f183810210a6feb5c314b9db4b2d18585f708e66bbd179221c2ee422f6ac07d114b8b47ab5e7e12e44030d08d66030a769f96a8c611abc1a225f89cad8e6d57172fb6f244e866d65f8e9e14a954dd23d5757da96448ea1d690258711f33ed97dca4be4492cc635eabb35f5caa6fd94e68d1f792879f18b121dffb0fedaca8bad3c873d1223ec4934c82bf520333611500a1611301870994b8ec64747b1fb3ea4dae50d23708d9fe229a644edac3bd244d18d65804581925a604fd7fa4260ffbce4bcfb1d0e9ce9c65da673730e64d9112e5ff7fdf1cba13f3c351febade5603a5358cb18dc15baff09d2d9e7f71b40b985475f32d1c0cd31e4ddd82dbb558af304dfe2c4774f61d2552678292d45d9f262e693057ce52f2ed7b8368904270f2d19caae96ed522a04d91246cac5dddbd96ddea7dce017a72514bfc7a42bd7906abb093469fd77297a8d39f3d4f20f2e2100e1270b39988ad9590c948a652bd7d8ae7e345b61d2ca6e1ff3d24464e10e90902c77b7151918948ad81e2eb60dab8bc9062426415b55d113c88041f896994d8d92ec121bfa3d97f8b746d3b9b6e65d1ebf0bd623497c80d3bf83e1bb150180a17245723e64f4df7fa101e1bba29fbfa41d6f7b3b38bd7ccba2b05cb1416f5efa410db06cac8188ae1f4e8937c45ab6095794c60b42f922dbe01a905d7f1eadb38d08c4cc660c2c761cd3a0c9a28239e16b72d26d78f3ac821fc4ba296cacf8bedf9d7d4014de494f678ea482decae118e2b9afc038e08ba0e66f44053db004b0566772be94aa8035794fd42335b9e552b2a1795bb8a3e8c99e0787c5abc9ac00685bbead096cfa10560d847c782574841afd439d2618a695e54a9e50b91b4f661d3166f21f835d9b8be3dc0e4ff5f64140f4ac4ef1809dee90c52a215230a425fb647a53f7d7e13902c6b3c871b90970b73098cb17cb90196744b5506569f2f250ff255ea6aaba8607e7f5036c2c223feea8666f5db8a39820651cbfcdbc1550250cf8237031941259b775b21eaa69084510b238b33c299b6cd3dec66e7f96c89e647ee5e0bbdffdd1f80933b84a3cf12b8ee4a226fe085a151a8f287a0e10deb93d3a3be668df88dd8e27b6ccde7ab899d34bf2b284317829d3b62fa8003318e8d253a22db8bd3b2635adfb149ce9cb3a41106c2567392d6a3d8bff4a66682dc7ab97f4e9b07212fdb281b930c6472e7151e47f09e3dc8c30cd097fa8bc49d057627b4eed50a780fa623db3876d3723aa9692da54640accfbad408e58c585b80b3c5bcae17e3f7084526682b7c34cfd7842ece057b50d76b00defe6d418bd987a0320b73e133756118e2e5b84b679d0e17ea26ec91c6f070e96d1afecaa36d6f28af6e4100c36d1643611c4234756c16eb66a7eaeb45608cb0d265e89fddc7fbdce65386009b11ea1548b9a816433e8705c0a18e326c56059cea1c2d4b8091a05bc10ef33e963d0deff7c345d5658abafe136b9b466e4a95355d784ae68b87d6c705f5beeac6e39e004b2314229b102e1093eac330c950f964f28d59e42f7465e2a1d014ee2ffe92ff9867ba9e12f1c86c0e86fea1473b2c9fbc6cb9b122292d63f6a69ae0ddb0052043440ba5b886d573c54f1af47c4db7b6815d582a229359244b7efa4dbf6173edf34ddcae57a5088483123cdf5975ba93573fd1f3dd00709d1f854a979def2228a7342ae69de22c9ac08e024524e96fdb84025c1ae2f0986e070f210aa11a77c67f591778a47b2567f2ed764f9b8ad8dad092982f4500c65a3329bccebf92e8039156c81aeeac205df1f85f29a7de10ce825b4e2533f63824023e62a0f13f334eb810e9d2a065823818f7e56efc527b5cf4a0cd5b274a5d7cb8d503db7cd3da563c138725f8803247372cb5ed82d3713c1495942aee01f67ac6636a82eb8ee463fbfb8376de0e531dad7839b0a7be0968ad7135e2d90e0c36cac733ad3b09e71a054dcb18f0fb67f7fd5899999fbb358d0d24dbc0884e8f491acae81c0f2552bb19055c53e56e2232884d3ff54b29f35551d12fb91a76a7a88001afe9aae5a5f128609e5bde4a2e86f1cf88f76715b4829a85fd7fe9e207424c9a5c527ed2dea8f5fafa5c22af14dfd10007adddbc1687aa42a121a3bb911e2f89e5fd7c4a544212c91f651073d4b267fcc3c75083d5460fb47409a1a7a37c81fbd9bb528e6230c591d1935da2515fbcb42d353b009adc8ee0cf936696b80554f6b7f55fd963cad4b0a54e7cb59e6cd5be215468e034eade0cf0059cc9c25d00da8eddfce5e2ace78a0046a9acdc56ab2a74d2451011f75c72523c963992c70fa2397e103de10b3a5e94c3718bcafe4ed28a409646d9aeb1926bfcbe8a270a8cc6e69cd9fb7096a4ea6e3c2661c4d32f8c913d3c24d0caed8de2567adb5d0cbc4753608ee28277e33061373cd0cc2cdd63b15cb30b2d01b6deccb716dadedcf25e6e6d4f187e38400bcac088964b081295b0b3135a712548c3d302d95189ad50a8498bbdeddb6f235f31c442121db44d994d59ecd706111a2ae27c3384c46fe660696bf6627dd8ce4f1c56c991d25863a1bcc36c88916db6acb16a4a984497f04cf5a573778cb0b6b1044eaecff2e783b2ce3e11549550dab3e5cf381f4e0481b826978fc87b80f7f54158dc0e90c9f169ffe388e5a0552cbc3b1e8ed88a061a2623961c97a11bc1c224943fdfd6c7d5d6696b3fbc961608d4f8100d3ff7b4573e16f69b05a8ecbf77e31355f2a2e49a97293e489bc7f405be62113246da94ff6b0a2a8c35bfc650451b57748a9aaa29883e1329a94a780a8fe31f5bf63ffd4e725ec936410bb04dad83b0bde26e644b0d2ed33bd26f9dbf4123fe88f414274645bbd8a077345e161a8b27a24607c29fb0724971555fe02a0b80f0151de64562717372bcab154163b74df5c484bd3d3a22b9649c5920ba0362354ba6ef331e3a52f9c0291ddcdd37e2abcd9f874bb26bf868968bf255afec07928c16d80f7e598dec44b9ba299adeba1aed8324f0b3ef22230a06743436e93432a5469574e8292f9806d38a48bef77a8d8c3210cbc22a156aa8e64e4ec136288d3002a72003350a4e5b088df5d20440c038720c29a0f7cb35d6c97c00c784d6263f45b2929bb568375c47a5039bc1d910780a36717b780f20910d1037f027f6bc94389412c19bbc7083303d4de74109ce257f7ebabf12a8dd09f94e147a54b1f5a6c4fd1b05520b26e7c061453f985602ec82d493490f657820910a39ad586d481420b23d2d8ec18c8341bf80cba10ff12f90fdbe5d1d286f319b0f62fb124f6595bb6d347ec80dcc87c940e6076f91e75f085a8c36f66360dc190cda4847ee1d03971c736a741531c9329fc8c3c878a5304765cf520b453c3f5c366154b68bee81c6d1ec3d7684096324b9dcf57ddef5653f143eee34b048c10c22542b83981b4cc95260b5f629e67d4e13738281137ca26403d34dd224996dff1763a06a9b8c7d4cf235e5530b024ff61f66c70cae1a99b23d3ac5889a736886c00baf47a4445cfafbd99d2231a6bd609e50b1ccc0c666c4a62f1a611433f5a615495a60da59a422dbbe316a0c73f5fd6145a5b08fbf4601ee7e8f3977754a472510cebf3467833f953c52c4de68ef10e6090302d407895f340079171e136a66f2fbfc99b1c081fb84821afebac1df268726f50744d49ea1d22a021b2230fcf7b9bfce5bde9339745c8f9e8f046c9d71bace365e63b8a27e367deecafe9336c69fbfb599484e6635683679b019e30fcfae3cd13f00eab18339bb21121f328edf7c65989c7279aef5f0d6371941f0cd41e6ef5057690ebf43607e19e91d96b86d8de057d76140ccbae952b2f94d23cf212cdd91bc78edcc1730f38c7ef5775beaee5238ed102be5725014d00c6ead42dec9ee18adf2cd44fcda5054266d52618cacc2d556225fa18c053ab3ffc1e6548a8a7fef585f475b5ef384e5afb037f93a5a337c47e910dad000ef0a89aa74b132cde788036bd889401a8b93b330fd171fd7852558f44769be0e7250fe4f82b9a0b56bec913e9980e33b0077232cc55f06149ba3da1bcbd87bb3a91c618afa3feb877bc616e413a862196a2be0928c906dfcd72255d8840f2eef4c7140f8741c5f71e9b63c42e962918ddcc6a710d63949a738da516abbd6bb863fd898c8c775bcffc7535eaa4875f5f79b19592945baf403e494d651b2b87083fa0466b235ec858ee04309f4648fd9fbd6af46f578028210a1d1a929a7b7e83c9caaa363d079f4f6f02f28431c41999705b99dcc93042a95333e77463ed364f5887f04830e181dff3c98c576d6500b2fbdc280cb547840e81e22abf76d3617c1f62bf46e97bd82bcaff43291558c4d2b168dc2b3476f6e5a52c1706b7aa1e854468c4c97c0ba375c53a29187340e9602e40a792859d22f4de5ce06ed1bd5d2f280a6b4a3b4a05c9a3372b1ba32e67252b7781c1e83f9322c403b05ef578e01074b8f7108b30c7540da64bbadcb2817f5dd0a8c4ef29298a5b046e95c39f3571551e625ab3182398acb12ee7133fe0855308f1a9d4c2ec7dd9a78de1e651a4b3371a1fc06f2d4004fa799e1343a2d2751d7c2386e5ec23a740a81bb7477bb2ebed9d82f3b37cfa7bcb75e2ab434b82b59f984c4f44814255c3f674d0eb50d188e4544a37f97de302840d519f24691d3221a1216a8f4faaa540a42c4f9c0560225764ce3b4447d3a3b1054fa756debd76393a6506892e2111889938e4e8ac9fcb8652f6cbb6c080ca5c2f49423509cec7c6d6f1fc7a6fc1de0a735082612b382478566f1b9fde245ecf855552eda47b9ec72442d8dd5ac63d690035a1ac737d2b06caaec0c556a03192a85748c702a83fc66d7f0130055291a78d30334392293f669312e4ac9e40a467109421509aeb2de1a5cb22f01b3c8729e50e44db8991f795928b24799213856a3ffe10d741443c302cc6a1df90bc3763a3068a69572585052578e87a288b312ed8f0ea9cf971f6b39cc0b8ce370b963dbae7169424b8b0696aa4675dae50523499d55f6b27c19e37666c63ce417a95fad07741c6ffc0dad3b64d38e99f477fdaad2f7c07200a76d37fd9f9a868772faf25b879dedafb9affe9375dd79cef5dafefd5c959aa15480b9257e84077f4c6c690b760e66048ef94ede4087eaa270e825e55f0961f8cfa588efa9c6c01682dc60894de53ea5a1a6aa29af31342376266d69fbbe6bc705ac1f2c6ab9878ad9610acbe23ecbd45ba2ecf730d103ce77efa9d40980a5fdf53b57e22e09534524a4b3e908a72c764c89b9c6ca4784efa34587757d6e847ced3b6664d3b7201f48df65d278049e8c472a77d3cb0ad073d6b50d78b12dc218708cbb954b3e7e9b663d1b50a8608ffc87dbd08d6a24c82227a15159850c6ac460dc1356434564cd1d43d5a25d92d17c929b2c7b7fa4e483234be9fab9c8aab9f8baa294b56161b3150f7cea2e600522f4d626c434dc3bf8dbf7c9d568018950b936a0c50e4913a5b92297a92c8553566938e9319a821904bf24d9b56fcc969ffb4022cda927687be3ad3d9b5c54169194c1d26d4be5a1a382e776451d7aa662e505f580e5de14fcc28c8f8e861a2c7afc2985edb6730c7a03ae145b962845875dfb2e234a82758a1eae6d86e3fb8135a764d2f8d3c8e1857ec7d1eba05c459f755f19599876927076032208da26aa9ac5d6050a29be3e79803e7b6b038238903bc9ce26165e5de2b0135a3f86fa9bee157fdcf992c6395c3c847cb96137f60d181d010820d12a60016917857d86ddf6cd0bbeb09090f70234e0b98f9ecadf73376d38a0af826ac3703cc59f0b0ee8b5f2f82ba9cbe261b733a49fef15618420023caa4940aeb23264afb4d4cb24bca4af07778bb4519f28c5e6879a6e39e2e87df540a63ab77b178c4fa0bb2bcbe86cd00d4d3b805c9d00178ee63310927bdc90939e4f565d2a4e9c394662181a5ed7ff8bff11235b9927ba53f9aebdb173c82019e4db20033ec0d5a5abfdb1ac2840b71b4574f12fa0bc8c5aa97a81b901c2e1b5f379db41d7fa4a57ad216c677f6e96603d2d0a37c2df80ac6b2d66b07669f83436d0cc5501853e62e1a2312885f68d593047f39990d0a990f171688e36d35bd74545c8733e02b1e457224092c1dae90e53e933e9e3bd8230bb5ebdfc3ea0244373c8c757a8aaa3e2d619d39774c8f3a4f858743e1e88c469bf3fc2369f57e694ba5fd324f2682fa5be49b8b011eb75ec0312b15e74290426ae02ea24b47ffa4a975985d686235c84780882285fdd1ff2887117739cdc1c45a96643df2a48a4b67f92f646f03d44d55f4fd6b45273dc6d8299efff49f6ee547a07594d04b960063f70904141d7ceb8f654153eb16500565419790574daddb63595f57e97208a55f4ccc497e7a7e7648da3c6957c1a3944548d867570fde39e853f4de2c3ce88b1a88a3dc400ff8601d1a78af6e106c6c8ccb682028af1146be5bc66d55146e1bcfd066be65fac880a2a5a149fe37e846077e984ad3745d343bc289a96159cce0b0ca753775a30516ec0ea2a3b38212c556b145938723da562da8a3744a8a2300056569279b3d7eb2577a2f864abc38ac4d5778ebe9d60161122fa14e79768c972a30f26ed269297c42e52f49e74c498d77aecd7f3959ee62b21401e70eec769d73ff765ca308324f65ab35f3216315add31a9e14b927734c7c440238656d1223a2a083bbab11fcb43817c1de9254705f8be3936435652b0b3edbc22b6e4a451d1aba041016040faed9a931ef2fb722b0c474eea98d47bcde887ee50f3b78af7c3724cfc8d1d8f1b06946fcbc6c6157d7e4242fe4f0fea76ecd6290c1d124d12e7c603f1796e445cad2f8c1008450ddf31c2ddf04deb4e453b5e20a1987321e474c97d51c204c2bb13bb9d8252c8db391db10fc828088efd9220451c31158fe3e27130b1b84f5beadb58876b71abcc7b316f696a40c566c7443d667600d0537222d2e51f09006c9fc2c0e95e643f7a9b2afb87714e9dd96731690d5c9bd03401f278116ff29c28217f0f6d07897411d79c4b59da63c265f9e9604314bdebeb6ae75c5338dbfb88dd7d8b53af6d2fac25a67daa80ed41b4daa242d59ed43fa6df197f778e0529f15adb933b0553f54bed7853d64fa80a1a70a0d36b7e6ddeb6b18ada0138876997cf8e82c439b61df5f1b9995981b278ad97fc2aab5094e5ae5fc7fba92d5db491efe662edaf88158ee6262c91a40f1bbabc0cd962b38129e0a2217eac1988e953d1e25d60c036625f472496a8d848ccef2a8be19ef472117b4a814c03fdf8ce3f633aa0e0a00384c03eea534098e0638bbe1f491ccc87f53de536d3f46c6e5324db423089d0cde1b76370d76c3c1bb68da73b8d04a224858ba2e0cf59a57f5e674c47588264c762248d46286c315460d296ff99d219bb5e5edc1e07cfe29b414da41e68081c568f661b689ef107e089a6055ba72cbc2daae635646bc2a54274e0539e82b6f4156b32e9eb68526d852ebd21606685af721bd13cf80970fb282ce2e8a9c96dab1a75e5663e922bb9da68e32545feb608756a79c6ae4251b9ebd4a441cced686d3689a778a294539764a9ea38fdc2109e1a5246d71d628e8440c68f94caa12a8e48e77e52c997a35e08a9e32fd3a8b5711663c4340db6e6af1c123300f43eaa5864c98893544a86a9f4fa0cc762170bd26205bd563481c6967b8caefcaa4e458611a2a7390fe80d19fd3bac2620e02ace05f37489bc774ea14bd145be254555ba1f1ab7882676f1407feb31d620a587cc77706496ced62e8481c14f3fb18b39a96652bca20a5dfdfae5dbd8fd1853a34b4c6c19e87ce77fe8e917cba8c9c7384e32d9582552e9794e5fdbf06368068a6b7d7d1f6eb6fb84c1030b847bfcc85bcd9e357433c1986c44b1500777505b951956b18391d0475f451ee3aa628ea5c69964a6ade2cdf7b9d41d7a5105738ade7e83ee8af0eb9a87996f68c30854e437b4bfbbcbd1258f2e6cb374bf08c01f12b8c113630d0d2bb8e05c2ac09b418e5c411c1d52f0fb454ce8b83e42f345e15798ba1d52015a599e55ba365f175ef45c9ab11a4b80ee62279b6aff58e79451feb113d412e1325f777b9ae9ee54e3a252645799509afecaf07ffbdd399ded778a13a66e1af14dfc4fab330b57d2bbaa5073a29d4b0387f739eaebe274e989e2eb55c839f7e4bdee2ce61b8d1e6f89fab1e7be8df29791e1f89b27957c4c11b3e15c1f7ad6e61151221f1562e0db3a98cfd0f3790e2a3cc1e84723b405d785298ab6ddda2232cb98c12cf646f55fc6f4dcfa792709b0cf3b1027c30358c38b4fffa46d82a3791bad59388a4bf287c45a816e0c2ea5eeb4cf2d8fddbfeaedac5b6e4c64662defb41b1b8c8a74ebf14a6f9b9d7cb89b5c78acf7102bc18e882a934bfb9905eacc96322c890f4c45d1f9a0702b3f0f28cf0d3da974885f8e88a7b435ed6169c492758a99890f2b887c0540a29e38437b94b33156592a9f102dd2c835bce1724a206e58285069ded8f77562652ca0f1d8eabc5e2e62db8ace68b8dcc65192c7e3745ca14f3b2c895c5873b85cb4b79f3fccd4f1dbf6a29111a1a113363740b5bb78cb4204a4adcc23c312e62259d0da5f9153b1bba7749bb5a152997223451c3570782cf55ddd736b04217fd7e09df7632179c4d8994833cc9f4e8243e8d5a5c266f246ff6a6c70d3f41f1c322c430c98fb876354699aedf3b76aef463e7bb0bf8dc9b0275f068c859064f0190e7b67f1d1cc1fff7eeb11167b8d0b35127a9d3b99f0954084ba9e8821f7d94f6f186d4ebe253359183954c7923066d14185114d79fdbcea53a46e200783de6ef81199ab1698b8ef637cf9e954ca6f66a9ac27c4665e33a88c7228303e2cfb6ae0af91a199ab6c43aa6aa7b4b42ff622746ba28134cc5735abbd72621231a0cd460997d3145b3aa2cc1972956b0e185f0fea72f8a018e432744ab757f69a1ab6082c5056a5c436ae97ca8225e73c81361f27aabc964b559a367a583eefd4f23611ae8f06c67530edb2a09afd391b0d38ba2437d22f750a8ee3f9721141e5689ae0a77f8dbddc520e14b3b82d583ab58be7c55671524ebeb36d49d70b8dfacc20ea551eac236bbffc469509cc2ac3acd599f3d6c5e31ea3b2f72d4eefee431fb081d023227dfa4a915aaa35305492369cb4d7d5b5e113934a858d7ac205575a18ac8cebea47088d967ff68ce0d6e3a6cb733d18e375cfea890cd1c244c301b8b50d2bb8ca96b1c4e619ac526dc3d5a96acefd0f2c94785c65f4c1bc3a541fa7d9336713c669fa16fe4059bb44503393c7f43dbe51ec1589a2191e096e5f1b03cc900c07599eef8d81f69753c5ee6023f0d71e0a8e77fc0dad6bf9754f228dcd0cf5f2c6ad641604c24bc23aa065f87ac307cb38d44014a8579c6a6b1d348baa964c66a578db30810e70a0a6fc7b7e15fd582f71a588d8afcfece1dbc20d14f232b73640e70c9bf6fe911feaf0f102957acb3eed9488db7eab8253ac085ad92d62ae8dfa48c3dc3387491534942422a938d18c2e91142cf447be34a049d95aa354af7d049cf35202044f0fdfc27f7571f70ade6f69389025fe3b88fa1780b63640ba9b87b408a0a2f221df1c6d070d31387e3ddf08477456f113681950c0396e326f7dd757e51d50279c403c047ff5b4508406ff78e10768d5d4f63043333e3fbc3230ac4b9119b9844cc102ec16c401513bee4fb8954329e15fe9a2d70e9b4d0cfe2f00ccd12dd05245ac241dd1b30ffef2c4d50be8e11dd8fb6566830045c59d69b643fa998b02f91ac46975337fcc139e7a64cd4cff596004a7f1bd380a22fa4484ef0b9438051789a4dda59434240adc646bbee49f2712dc8d8131c2967ed1d88bbaeb64a6dc51e867b5bb9cc20b6910340d6e9d4b47f465904024439b9d2dcbfa09f015c29215cee0999607529db3ab1a0c9c6eebcc930a56f7fb7a49d869211ef315a0d48c23d2a1c953898d946525a8708e9dc0ae9408c33f24fad62152c429de0f5eefe710d0aa80395f74d7b429479afc0bc55ca10d4202fbb7a589d3de0248534d35a23dc3e3f5096edd5e9c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
