<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d97e287c45cbeec7da23535960f179b861a77e3f80e488de5525a64105e0c9047dc682884a70fc45c35e9d6345d2ef113b4570eab251410a7deb39e0fed51dccb7e3aa011a19a9d4b092842ad376b901f5f7e0223f0bae0e554506e40d09aa7815af2ff4ee96134a03d20cae659154741ce4ac25fc4af0000e53946032751bd3207c599f2502b239813bd2cfa306af09609bf45296204dbfd4311571a1ccae37a43a8bb332c98536c4a4bf59de6a7985ce3f992e390464123d88090fc4f5792e47e355de16e376d8013f12dd713ca616117f3718ba230b7a758111dbb85536e07f938d3ecbaf9047368a82e87777bc3bb8ab2ad3eaa2f2b1a14c5c54ab32b9694258b4b76113f2a46817640cd39740d0d7941148b60b7f47df4d727e210cdab2b7aa1744d4207efccf9d9632a425fdc16c9c4c9b6d20e5cbf522f19d3a57413646dbb72cf7d9d1701c3fdb12b6d721b5f3511745633d786c17aad6c87bdcffcb9760b738af4c1c6c204128aec737095d9aea150cef2fe58203502a13b744fc1614c29562b202940afbaeb3be86ff1ce77888fe117d6eb6bff755140e4d454ff9f345ef42b944609efe2f08bfcd40b37c17010c661635b6d1aaf30a6e6b7a9142b4f08146ff8e5720cc7f118c6de71cb2bdebe62d367df5f0aa4b8b5116a9e81f5d863326b498be04c6bb46b3655356a12f4de90d86fc9c3c0c45547ab3f412870e9a85fe9dcdd8c8dcb941618e52611a35af58f845a96ad0a2d9c75fd8ec6890d49d23a4bdbc96e40c95e5872b0cc7f0778fcfe6c25bbcb2c926abd53023431e360fa21329cf334ef470f478a2d8b50fc854b519ff9b6ca4eae9aa8f58f04e648a8a42625c84ce12095b3c22794f653375a0550b3b19a3abaf9876320c2fa59b59ef0c2720395809a86140c24a8b478689c8edafddf89449045e5cdb9de60c5e53a931f6441b8958b8d678c1a507d3eedd51373aeaaae77ae351cff46d2c9c9a81a88c065245e9e5b82396156ff1eb408374eb28126ec0a2ccde8cbd969209e4fbae994b7cb995208ff3a33f50969d218a9c7b66e8b2e276903359dcf63ddde71e3dbc80b42b5877c15eeefb66e867370deaca1b573a4ab1d8dd11c5992a3f5e86230fb79891068bbfb7c418c3b4de10793415e1cbb75e3172c63453e73a7097be5272b2ac9bf01c7794813f3239a6b8def19f4c24e34b37e0a2af48708d76d83c0adf3e4c5d14204208b7e8d055aa82eb1385729063c18e8eb680b1780a525ca24f754d9207547709ffe4616ed7a9b3c5be9985a154975f23d752e2ce8b1dfa675e9c9a0418ababe166a073bdeae3a5f8bab7053f5c268fd9cc2842ad414cdf98c4f9b7587eafd322bb03510fd6bc76209ee6274c88b4d7b1f2b9bceb980f0a62368ac9a78c01e0e50bc447d7028f9716197b53bd5415fdf4166f071490afcb6e2a1755bd9228f2f1d7982a5eeacfbba839559793110406048d621a2ece2ce7ae8e262d6c34107750f9219699cacce025c438b3280ab8fe0ea3929bfe3d60d73d8948ede9f4448b18076f0ed1f1b40c9c8903a7c9c2f8f305c7150eb27df28b3c724233409b666043793a719fe53e43181d109318bc96a336ea9b147d4f18fb4353f953e1145d53f00142f6a04704c786938b6d0d02e5656106025dac3c61aa52b80a119ce8cd08174c6a4087ce8c633f07aa42c31f4bdb73b786a6959dfb6b62de869b6c596e489a16df9e817585de9abef77cbfbb70172b5e67da5ac5debd0f111db885cdb03f29aee802e1a6ff4bc1a609931f286940f84914365445edd8916a64b5b968d170cf777f23cd827ef3f1ea8bab994f0c39594ab96a3f5bdc9761cfe375018d00d02ffbc1720eea35a955d5f2ec9c77821fa9e8e97e39fbb1f4f06d3918e9a3b265ecf167ea66e0ee17943eb3e3d4932a7fbe434f4f7b0b78ad750935a5648b45ff0466622bfa89a763c1872ef85c46a2ddebd87935445f213811009410a678e78609f4128bf192f42ab0b6996d4cb0d3f10caba1c71b29e4a6110bae8d2faa3cfb2c7087a60d493790052c2ef07ec945b8b34d7c5d15c108f959aadfb9189e2598ffc3df785311a25745cbcb70b1841ec43a7d9029de91917ccf231ab2071462faef9680192e1a5859494dd55966efc453694a364f081bc03e6ca52c2c06ab81d464122b24e6a234e6da84f0fc4f18b5a653d54e4ce8ba8f8d535033e76dd12d450f7960c17bad15f9ef89a494e3f881674d64b6cac164094eab55d5bdd07326d54fe51a6d75884edd262d2946f637f68649e4a53807e90cf22114ab7e12c2c78d41de88b2062b43ea7b344da897197538df12e89ffc1c2b7feaedd7b4b2a9d9e5146516704558e317a7e363801bc05682bd187f15509f888764383f76ac512000a2714345d03cc30466875d03d58675d346125cc7fe5ca7e79c686c9e9255c90af3706369dddb3a6ac408116bbead72525868d5c567025f9977d0852be9a9bbeb97be0221638636e3160199bfae6bcccc4497cc7ae2056a444d1fa0f47d0749d39dc1c8866d5b305c67620afd9f0e0b516a917a1c7c3f29c571885dd48bfde8c5c58059dc13e69bca1d845f72896a733d49c6771b9c1bca277ce828e3fab132cd10505916dac05db2c5328b5869de48cc96e4250237392a06815976360fa4e67e09d438fb263ce21950a7c334381c78b35b6ca60629e2b7e8c350667c154bc9d23d51453d4520c18db8ee998e35d70d6acb8fbbf11539eb13bbed74f9f5cc76c994c320b57b89d2a6f30532aaa29cd694248c79161b660652a91a7e9f8d481f1e8a004b82aeb53c798d21a7c8cbcf2a4fe498712c05780a892f8c06cb9b1db421c646717cbe713b9561e2f5c8afd56dc3f00e1c3623d3a03cec4f830eab47f39bbab5d9da1d0a74086fe435623b800fc6504fc6deb325cf58ef0841dc021ac79192094211570c53b039b616b36dd7c71423ca0b7e8e02c4ad728213ddcfd837ca266301dde329cd48088cd8af1d74a0c8389c10e159324dc2bd16b5f66cfaafa925b56494cb1fd123872ec4aae1cc381e965562bf2fc94d823e953538bd25acbfd992aaba11e40d23abb2e97b21b0893c52f605c1e8365c39f87ef716e40568bdf72564c2c6647a6574448e1b8be00fcc5fe04678c12cd6a4e99c78bb9a23441d5984490e75e3f156868c27bb5d9fbba2ab109cc04b0810d50ded5e67c0e78c61cdced7cc8a3880e21541b77981c75714629672e8a812c7813e6efccb9c4eacc641407eb8ebef6efdc6dd951b079abb768d1e6861d16e552d02a5d3d058e4466e4a6db0c29e7ccc937e5cd4fda4adc51975c9435fcfbdee0331e5f85e34e71370008b673ba5a392e1c9b7b99b5884fd3bc4d746cd264226637cebea95210434c2a283ce8fb35f754a030542ffb45cd8a1fa3da3090a3f95b43d88a04d45e557e8e2307770ec12eda2861d76abeb7c0e6cfca5b3d3bbe735d70d454ec3a32e572d8884f36c697fa05113cae07e3917119dee244b0a1c1c22efca88bc03efce45f1c3cf3cf51d2159a43e1d29909df52662c9ea878ec7dd66e7b0e8f5d3c059537c05321ce0e4f2189d9ce31dcb0daeed026796aa92fce1a6375cddcffde2775d71411e24819ccb8f7bb87899abfd5b5e730cd10af18ae431f160f2482f1100ba8bb49d632bf020f0ca54c0dc629ff1074d40febde8af8d3891adb2685fdcbe3a6cec62d7e6edd903611ee5a5e69992c8688e1f30bd332ae309cdf4647d9305a6f861343339992b9c01b29d3ce0dcb30e66ff1773ff5b0cc39016bc208c4c0b63f3e6dff656d499425c3cdbe231839d38798b534713ca56a3604f5e832480d496b283ed3edab90a547c9070a1a15100a40f0fba4b19c199f71bbfb2ffd39da402a655a81bd433ce475de749fd4676a7f11d20ce384df0c3b7ddc11a9d5df6fdd42b1b5a1d6f6fc027cb0065b77c77fdd873178a07158e341349fc3c7cfdb9e1c02a08a0dfc112b499b10279b54a3cfa8a148fda1f1a49f40707f2ff08dbdb297f86b19f153191444a31eaf24887ce1c0b4c504f12633605b0b87821898a71313397b6c903ad1eca3435a499c1b330f8d057e07e18337773eeaa9f40786cb61b8bfc7ff83c67e4f828efb55644968c25bba97b5c5a723eaa7e9a103b7a036dad2b3abda4afd73085312fffee38bfa3479d42078812eb877934d9c510ff55caa2611f0f1487a8b895f7f31a87453953f78f8abf1776d0603bc2416ea181c055fd16be05e0f65af1a8c14725c0cb1781ae47e82b8c7781b95a952186a6885908a4aa32aa9aca07e805fa54816c977531098ab88082cfb0c5a836639618ff946bc5f1a33840a64a4b0ed43ed5729f6c791efa7f28038b5f9ebd64c24551d2ab51aa94472db058f4e785dc21117f57bdf3a210c020a150a3e3cbc37f2dceea68fe85548cc2a8a299f69522bac14201b6fffccc48213f7303186b8eaf638d6ae1160e2974627028f728ff88c3f26b99fd4ac21a20b837511d8951aaebdb70f570471c876537c1eaa7af594ef62165ef5abc3dc7795dd1e4e381f351c7e79a20f613a13445941ef4e534980c2cd811ce3e51949dd938b0d4a06655d17fc9c21bd790cfc80145fe0d12e2e668b46326d5b26990b05c3bdb4d248e455d2a2f59fde9e35490b3ece63c165b99d910dc6f9b72edf726d4aa2073b1c81b3b576e19d1beda5e22bb25352c8d8280cf0089fb794247df74fcc794c19396d5d9264a6e62083003002a905ebaca19594c08b0c59cadd4e9e6fe6c6545def15f30df3354e3fdbb6794d146f05a2850789e7de1cce7b5a47a834f727b8d21f9bca751357432fc07e3c15252c59160b0470b5a241df07d4e48abef14a1b588b7637c6abc938198e5d777ffe38937eb07c1b90156a51733d7b5a232379c6d2a440e51ade76878717646988697fe2cb866b2fd3d53082ca614233982e2c74e6bf7f02aecaccbc92bf0d62181562e43d4b53c36f9bd49acb43ce6f22bcd06f164dae20295062affe5dd797b9934c17062ae487cec5dbb1d5449abecddef05936ae418bc11082aa6549ebbd233958e4b2c3ada7065f22efff826eab0f7d4faa6485f9fd256516c31f68185ddd108eda26e47674bf9bbadd19e0e5c0c32b2f4a8d7771f07317c0247c5ca1eaeac01cc1def68563e72869510e9ba31df5d9a142fe312268481db7c65a5f7a66f7e3b19b7b1da5b13510fc23ebcab5007cbc3c2023b7eda06627ec53ddb820fb1f50622d71903a132d402e73d2bfc2d63d659a16562e785fdbb7ef921925fce72e6264e23fcbf912268dd262f780335a747bf02bbc126283edb3dd22708762be101183befc54a4b7eba81cfe024213da4ee9f7b7048d8a71f1e150b077c65e857762bb1f352c5790ab7ec4a491303ab46930c4dac04e95e0b647bd98283a9a9a3c469935b564fcf7f9d5d2839a14ccbd7515ae9dca0e7ae61b18e63c4ed441c4d10293a13ece9d27809c661748076e23d8bde9387362378b405ec4558ab13cf0b74f4f072182144f10cf0ee5340eb26e893a1b17876e12c1b283317ad4d66d5f7f54122deb7711981257ffe6f73c6a23ca644c7287bcc9ea25a0e5cabbe2a63311e39c5681ea7f3a5a7ce0373d5864595b5fbdac1f64dac48ff10fdbdbeecc721b0b5dbdd06e2d46c4416249327a2b883528bf76b50cfc62ceea2c202acea1f0281e6b39fd2518d5fbdcd37378ee9cf479dc8141f7d456981f6619eb20826dcfdd448b2cdecf83f811f8745d3e1ebf6624fd93117a7c8e783cc06f38ec9b1acb06d86a144aac9b654c4ab5828c106c389cd175e95dc8cdeb225ca2ac18033fe7216fe6028018fbd6d14aa317c9cf5c8d2b0c81d01acc3574c9224961b44c12473006efcd4c722625df52e8b1c2dcc90a34eba3c45206ae31944f02cae567bbc54cd0f06c61f50c754154540b6d19342fe72e58a8e837e87b6b2e33a5b3be99d23ae852aca9153974e06a85759b0304e223cfb34e7e4c9edf567f07bbe26490c1688fd8389afef4d0565ba5c9527e1d957eafebacf482d06274b5f739090d2a1ef956ddac6c18250030bf3a968db3967fb0d0b5617f0a5a98b06bdf62e367e1d72f8316cfd52387a97842256704a8c9ef5add635b4593a1b2391317d443802ce0816859ebc431a14e1d349f6ac33eabb6e70d4976b54d1adbcceb2398c3cef11ba069e1699ae55b976a2b8852b7f58dcd2f8d7a3f7788c4b3eb01dae440099d7d7011459ce450f588bc93e740df82ba496a9586d58f4310972359ab03d1ac94937a1efe50d6f54637efe9cba4f3e9920b3a02e5e1103febc5764bae8830848432b5be6e01b7650857ed6214415bdb26b8bcecec7dcf59aa0aa66ab1211c832c863a853f717d9380031a96c8f14d239714055887296ac8058d64ffaf190186d870d7538aceebd9b5855309931d002fff3a24f9210ea05882c52374e1407ea3a59801cff42e104ffb883260405760fd7cadd699f982c1c3c959049c86488a0b51fa7058a9bd293cab25bb787b3a72d823a316b11c7e082563668546188d374c45efbc6bc6f24cbee37d403829a517f3306f5db6e93d95f48f95b81ff9dae7c7f1bcb5397baa110c71aa5ef8b718154e7202fe6245645622a45cabe0ede51d86e92c3caef6b0ea7abb7834b301c6f004490e6c8b21042fd20504223b775327a15380cb5cb2bb7cfaebdc18951ad03ed56ccf1f7765990b1b593590ab72bc8671180ffc795f18516ef52082e84804a479766acc363031268b75413c9444019353cc21ede2a69ff3e86b362adaacaa29bfe9729600117f883337db658e5c7cfb93571edb49a7d631f49b423018458b40da826a39d88624fab2cfaaf366199d87db518cfca8bc92de0cf09001ec347381dd7fe569acd47ea0c212c6139e4c998299c1dc6d2b174ea992a9997a02a30fd4aa6310382752585d6c90ad2d39720ee2558666b3fa6274d340ef07b185fc4bad46a628d6e97c5a10d38813f728d97647a5b7b26ee7beea203152f68f7ee2ae79dea21ba633cfd45f673d17804e903698a91cde4fe77ff665b30b18237d8542f392f0678231e66f497704894081e27579f8e65050f2e7d9ab67d747fce77d807c23f13807dea8d07ea3618668c344fcb9fbbaefa69b84f5830624683a36b293546f1878fbc88cfbaea71e0abfb4880d47506c6858832fdfd40f30207996d4e2899175f86b7c3a9ed962a9df6038fb47360be936bf96b555c8714fc2debab94c2b9ff50a4ba1b0f30d97bfd309accd847f1932b05b6de54fe21aad384bd1c532ea67b7c7471516ca061dc7dbb785ac579133f0cb844bab6df83bbf7adfc2e62dbb632cdeaa3579f5f3f5392d74ee5136e4d02615d037f00ff685301f4b34c85f46215848bfc4ffcb4b7ac80c8677b2346bbd9e3b352fbdbd5e0aac1f1fc3e1a3ff01b3068280ed64b341c4eeb96097801f62915ad2fa481461c5d144cebae4a0028c44802d075d7c1075e67bb33a78541aea6f54f1ea898d90b768680c60854c922e9c4ed8a4bd76fa24fbf40a646b93f196168c8fb1319dc8eeb91203bae4287007f8c5a01b83a3ee856eb7a4e1d27ec18c91394c45cd1c6fe8692916ee73633452bf82a598dc0273775dbd083907a407e1ee8b69b1f4e93fcdb9befaa71331d6eeb35e3a89e5fd77aa255e0e2dd441eda2645ff9426168d3fe22dfbdbfc876f9a08984eb047b646d9a13edd8ef2611da77fe643470259bba4b212b5f0ce2b94d93569e5ad02e4dc19510fb5da9f50001cd7e8b82bb5b9ef4acf334bd9c66fd9786c0be41a617985a2d7f6489fdbe29e3150825c657ada6f84832067ff56edc3c6203477e0bb6dc5d6404768599e467c29d848aaeb2f69116adcab75bdaa363e80fdc4015a56c757bda2c0e78df76dd7311993483818687f338d6ed6908b9190845294d9eb01b5f32b6ce8821633e54373c07a7ada8f761b2029e7386d2488875da1b44917df08fd378c19a6cb4c84556c41b600e0201e6487b6a2d4993644123b2d510dbd26f9139a42d9f3d83c9c571173616d58b7501ff0b25f76bb7b8cecb423c3acf8b3bb5f2a7b2508a3617930ee00a29187aaf6685062654611d7dd250fe2605163d8c6ff4a972a1be927d4d821b41c12189cece88d2e84d95dc6ab49c8280c5a340df66d891d4c3a4370a9dedce7403541af165307b12158e5340f621cb05e89a5c963620fd37cd92ea946f65c81b85b753d43b2d4755d240e355f888df6a3dafa04fcefae00008ddc2ebc2e2b7e3f9ec4c0135c1853377ae8538e4883131c152fa7b7630731d31f47ffd328f9474d85b016904156674e4eee65b3ddf4f39f113af7df6e68851035351deb74f5ba308fa5bfc7f8fdedc834b24afb8c432d580bd34c171c2b01f8243fa92b26fee6b19a1b49f7110c1d9b3b6d322dd917b516c6890472ae0ea7efcfeb6c8b3a1306679f6addb4c5cd955fae3c10bbf2c6fcccbbc5176f4fbb7726adbe7fa306d560fdd89ddc87ff8406c3e772e6da3c08e92635c4272ab4d377f3e28793f53c63559ddd551a4af9464536c5fc05f7e3b21ce9d49902aefebb979c211431e1caa8d6539cb31ab5ad8905b8d12314ff8a456f50411bbe93563d5101d0656a0b955c663ae48e125f67e67c5e0e206602a02a5d988b28127e5ec99bc57594eef293fad36868af961a4fa582affb10bfed29ed9820ce8f873f869bbb3c0371c97283ba12f52298af9006a80d80af298264a18f2e5cd6f1e5319bf47f442174ea308a55a6a70e80ca6063b804694397bcb0fbc9388131eeb301b8facf0e173f32e68fc68a9f626bd87c4a9e100b7a71d5c724945efe0e0d8726e2c6adacdd20d879e3be3eb776b135f6abbf063a9815e7d05df4e1b281683baa775357aa016646c583910252daefce3a115206cef31aac17f648bf2e6d6504698bd03e1a959ebfff444bba48c7ce69d655acb58f6618ebeffd68de6b138a22b34ef3e577d22cabdd89c95ad680a8843cedb10dd2e75b30bb4b6d39ca462220685a20fbc17f1752321c0fb37c01edae53bdd9450a26c3003f34eef3afa3a2f09ac8d057f1d59ccdd730c9115638c4b93c5cbf48a5e5e8b2ed65d8a185b0da7439a30342e74b24ed291721e0cf14a83338f9f209754452d23f7f9d2f6327cc32a4cb63ba8cc8d942f1769bfcd5e9c95dfbece893554b372c01a1fcb67e985a9aceffc24af05dae345584b7b07ff1db60b51b5b3ee0e0c54bdeaec73532efce78d4fbdd77f1dcbdd8fe5d47b3d96f84beec1ac6756ff28372f6c10e4e641d38a5ae1c5ecab5ddd5dc3b0b122567bab6efef5f4c0070164a9852975e4a1f82139359a57fd8dc7c847e1c5799465326aa2927a035af52954c7022beea89f3cf0478c942a64f10758fc909012ccef1cadd3a797bbbb00783a32ef9f7e371112c14a1272968ad8b973689f185b409d49062c1b172d6cc0c9f617eff4e261af0a35f5380969c78e13a9ef69a7b41ed78f04bd2101d1abc617e595815a98a09bfadd1066bd439e67f30b70694bd0fffb6af712a66eccdbc8d74e9044bdec2da7b527c8f1e273a6d1dba3b624fc62a695b5f332fcd1747c336f0e0f73b6633c82bfce66a05c21f4034425650bad2dba44245beaf532118ffdc47cf68009529cf9605b88cfec99de81f6fc7b29b5a9de9feccbdf6ed19ad6ed52d2dfa9d13bcd5aa4044f4d5a5905869c85e224c37f656a0163b91817b6867222a2573609a5ef7311f0647e6fa49f61157be25373ac9fd8edd4638b4d6e8b74dee1f6c9d10c036232aace9b957159bb25ad33275c21c4427592b721734d0b61ea74276d37530c97a5da1fb0c256a10d9d91e6361b69d157a5e56037e687f5992147ae7b163026653888acf231ef93f6dc9ac439e302ad7d42ce0a62283a2d4a7bfd87422e8d6c55e2160223868c810f2ba6c245445c3c0130ef8d5eb0414d8bd2f10a2e8ed3e9a2e08f115081bede88a7e2d8cc81ea0d5ddd12cce7864cafe6b68dd3a7f14b03a119a4d187c40e5aebdfa3454d33f260397e76f81ca207f351690b6b2ae63f722c232987c3cfa07a78d98a84ef8a5d67aafc7cf34265a13508c64dfa6bba17a7a6af49fe32bf3792e88144c996542afdab4663dfcc38368c11837c00e1e8fcdc5807a91868e74cf613b27ed430b737f4b81a74e60b5cb61864237d21472b6b5beb2b97e8d6fe558541b7951b23dc06bff4af1d6ff2ec234592962ef4c34fd65960222e18d485c6f0a4f90b3b6a0158987087440cd75c25a4a9269efc6b4f80ff810a9cd31e55679c5f16e522f155a3b8619996e5640eb288bc4b39edb41a9de749f60fc6caf04851ad5ae90","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
