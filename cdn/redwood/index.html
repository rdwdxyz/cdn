<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6de138bfad2fb4289d214684eeaff59daf74d1eb6344bccdf83b0391988b58e191ba560dce38ef32e1afc20e5c3035e9ee8058d873e03e3631eb1874d39714b542c8ff7cada95089be2b26d8d5760dc7068af4b5a682c122a5607be1765e3097dece07ff0a59d702537bbd7e9a515d993482861bbd1d9b0286916f09b9299c519491f503158a1273ea5ec705ead913564f8ed6820649aca0e0a5a0c0b5f2404be15272a03a02cb0dc2e420fe0ec426c82a5dfee5704fc1d94287ead29e3f9a11daba106ae6d0fd0e8014191d9e544c7769693185b8a049d183729c2eb1fe984c6570edbda75cb2b8c61d07863c7484ed07a204872ecfba7d120e8bc48d454081a9622311f3558f2db7f9759d0d04fc3a076c53ef5ede56f64862da3eff5b93858c32681131935bf37dc0bc30586038cd2ffc26c47a319d7949ac52efb254de891979b81651d6a8a4e49986e887c29f485a20fb017ecf4f5ebf6cf96d53514910934c6a20a1ca7ec11bce3ded181e0a98d9c8cf20dd5502ffd919c8d3474c87dd6df467865a841ad4c5f53df1b1c269405be6420e2e9db8e2c686a04c186a492a435a605088ad9e3cbeb4e774def8a6b543fa803b8dbfb56e68cfcb402905ca257f45ca26e7d2456c8a1f199a50b8459f6374c0eaea2bc7ec36bd0c5abc52e89a5f42d30fc73a21030f7bb1d385371157b88ee77d18351420b841fa116c6323b5b9141ed4254a90c5860b412cf3ca6a2e5a559df4f9ef885cd21cbd185644c1d470c1c409997ffeb92435e1cd2c42abbb30d4a39ff543a104873f18f0fcf2abe384ef0353ed52e1fa5dcbdefc1756da0b8cc9a562628ddbf7c6d91f7816ad0a0512b73a979a55720869fdb2fe3b032c7a2a07503b9d6ce42a4604e675da40ba46865baf4e55313fe545c3c3f944a66f88600896a8f99036d260691a1a33967089cc3e885dfea25c2997eb4855809df17a27a11a8b2b8de308209547ab044ec7b05a367d2e2a2c65039b370712973d961a45076e981c8c663c1580e3a9f0dbb3730e4e019d7cab3e56a14a6d94201f2690a418a0da7d374af69d70e35f11959ef8d034a671c6bc71f9af6cc293b2fedbd65d5f7a142708084d2548cd60f92d88002c9613b98c567c7c32d3f67788b526f605c66391b3bb96a7f73193e2fcb6c7f297d4dec10f57117c47ee07ef4e0be507d321853036dfa7a4b5ad9d000032018f796becde31a8b9a2cb0beee54b372ff67a58c3315bc616c8bca5d59ff8d4d40344d5f9a0611d57130e8a0ddb18c0072be913be9f2a631b6e5c08cc8bde417729327f7f94c293e0751d0af128a3357b5c6e77b67fc598e351cb2e68b27f3a3bfe9a4aa5d87ffee95b51271e4e700a0cfee1b43f0dbcf0e935e3408e83967e20ea1ae778d1f8445c6de75e739548b1b5c7854bf173cb532420bb1d9484bbb9833f131149649c906de25ded410b1a5cd0852a5ff93496f9c8213f11cfb9d2c580c7aa90715af78175f9a889e5d771f904b83233397f00b4edcb39ed672c0e5d1f8f55e2c24f7f1ce4c79c0514d2cabd7f5710e89f4106811b0082915e1642a7897a36cf30a859177a36c6486084912dd207c4675d725a429163ac108cbefcbe9d108d4692c971eaf597e5f792902edff2bc1b698649da3b7e2fcd568138932c42155939b5592d80296b159e6f629e5aa64f5c22488c1fa193e633efda6cba8237ed32c63433cffc62f7c4b15459aacd582593a7a91e6201806f4e4cb54e5186d1b4a3080ff7ebd7bb3198d9dcc28df8b6dcbb2f9cddac2e1a1add7e37bb7b22f7fb0a80022c38029c9ae582f3d8382472029ceca17c05e9b7f88ddfd5014e7d1e4a43f6a67fc821728f11aad8d7c21b454eb6060fe519e48bf9530969ea46aa3c6cdf30eca0e40f518a4cc899a9fc4254da61b05899234ffe06bab3b98f3a34f7377b07163ddf794c0762ed33fbac7759f2e104d080d1d4070f1dc37afa6a43df0a6319a6f8309aa6e280ad4a75ffb7f0799e1b7e808afdb1c6cd3e8d3c9921c3bd1d4affc46690c2f562992a9a9ae647e04e9477ba6aa2f6ad8bbb7ab5ec0b7d1928b020b6a9071a28056782a74e591934f86a35871bc986556bfce5b04d775ee61b1f4a78b61c41f4237e9be581f84cad641c5c8398c59cd2cec81854f43b059774a7f5382bc3651a43549cd115f70aedc29677d63301a94adcdc2a02c619505cdd3678c89f48b4abf145dfed02dcce803df0ee9cd11ac4b31b09336e1b4edcb64beb6ea6d487f361337e5c74dcd0b6db37ce66089734d40b125237ff6fe5d45ec22b27b1b298595eb510552b506b39cc9cb6c86698b6e954b87fbd9fe96aeba218306570f6567fd5228184a05275ba475efe5ce4dffc7b65235aecaf8386e9b18fef9b155bf84f1a11fc30385765882fb9f57b12721ad43551c4975b75b51eac96c683f8dce64486f7951fa912692adfbf75420f9f3d8c3d353b06b14f147548def2c1a215c129442688aa832130a1e7adc21e5a94f37786c047f352df6086cc73d7cc016aed36099f812a6f713d44a70d7a2d24532e3777ab9423cdfd516e55a076735fab247f9c5cb44178a99fe03e3f4d0bf336d255b19d1c252fbc671aeb63a4ca7c09d7b6d74f57b342d0877d696261b66bf842bd2a607ab29912402e4f965879d1dbd3927afbf3eb4dd08bb8cf76c040ef92e3fcade1070b713878fbc74f38488ef8bba37ebcac4f72b3da0bb19665021301d1ede0beda6c34e019377cefba12985cbdb84c7416746117d0b70aa0f31d7b968084dea244c6abf127aa87397aec3bea198cd84b17c9bf98931fe6e2c40ee5a0b1348405a46ff75114dba1919345ae4315aa5b5c48b35d32366ce9ea4820e054ba4122b79a3a1de60319fbb283b092bedf9689e79424529e0e8f5ed9be103e384b9c99c22d0f2eef2e379d295064195c1013bb6c84197ece16eae5d55ea991def76169d2250cb4c350e4eb56c9caae3f0cfa825bec6c9d48d61e95be730327f4779ba9155915ffd27dd1806aa3584a1ac524371269e9cda32811943b7f8c7645d2b413e83de758f6de4218985ad8b21e3de10e8e62ac38b703208069cd9aa5c2a29d38cc056f2c21cf1936421f84b42cbe9e6cb9a27404a2a79717d5206f856cd6891feb663f57d3680bddb507d7cbec2ebe1f6c2e158f0a604c0513b51e08552de54040e770ea35185908b7f1b76204fa3bc5fa65ba69216201ea77f44cedade9ecaf1650e5064bb4a95706afdca6c6490597026e170d5a4c2e277eb102005985bd9c90559e5e56f35d20474c785a6df4979d5702b8334b3c6defb1dd5751c7c8a621c745e644c6cbefdf544cca4a01ac08de5204feb0d3368735b4f05ab0092a174745b56b39730c81dfa3f2952051f0ca01b6a350d3b10824fd27a364cea6c62da3c9d257443dd378f3f68db51bfe7e478d54abc378058ee48e09eb4a498f8825723ea625518ee711456c9dd7d954eb8a0c009cea54d16c2f33eed537d1890abeb9c4adc7978a5fb1053742bebb4e180a7f40982ccb57b45613953a5f7b07fc38fb14fd1b1a9daeb58a66c07585ddb61bd6a373264e76ecc2801667a6a5df5338382adc17286d4c758eadbc76f94add8f978e14bad0116cf48789dcc7ec8f04d2911ac8c21ef6dd7988b0ca0607414337d270270984f0b1b2251d1a4969453b28570b9793707aa61d2fa3c46f505b35b950e593be91f146965e4d26d2f82870bfb2e4b1b313a6c06026de81ef543e3378995afc7149a1d87bc68ac776ff07858d85186a5967ae72f08de5fca4635be3aba3b1a47b9ebadb0b2e4faea23f14e68d4c2ef39a5c628bc0562b75fad657052fe197d6deb7b39dba3c3999ed068937775cda525c28bd389e2e8d97fb3aabd280c21783054534aae5ba603379ecbe5f00073484d23cb755cdf4aa909540b2487dc36b1c98d0571fdc23a07ab3146ef2ef0c2ed80145a064a3887892a7d488fbc54b2a6bf44b3e5c06cf89b6bfeb8535d5ae3833b1fe3624d87932c11b4ea20544d65a9edf767cae24f2b2f78e614a1fc779f13012c69057cab76b3ed4a6e639e3a96f1122efbad75d3baff19080d7446ed975979a11b2e7420eb2c9f7d7b478988f253e3c7fbbb54a27582924b5fd83a6bf3b0dfde4eceee32a25619cef3f33da1ae1670a3d41eaa1ad8aa92d46607c3003a5aa5ff531e38d2e37253ff13896991abab30085691b0e7e2874804c31a9281da99b20a722c39837560382ec68a8a563bf53d672336b32206110aa92924f0cf5f1fedb36052f98d9c755e519c4e3832571cb38ea316e8c963836d93b260404bf0c2984c6e065cb246bc585f17e55a209ef5b5a5e0c480d5db50e88f13374b7d5d63df19b4f7e30f7e8cb4d7e99fa91566d891b7fe9c0f3a7a321eae7d98d9ddd27b71d17ff162d77c768c53f7b2d548739697b1853b80c448e4d9eff5f109b32934050e1da55287b266f24c1d389713277ae1a0b3855960cafeaf1e7f0a6a39050a4a5342289b25314c6b0312550b2de6ca2ffb373bedc20eebee5ec1d7b20af833c535b10004780e66e98e152065aedc175140b3a9a872a3110e11f6ab833ee484b29fe440e6c61ba736e54fc52ee986711979338f60740174e7b8c9a3579239c8480e0a10517d07b4532505231cb819500885bb10bf7e890bd0181482f5c6d1e80a757fffeaf081b10a4fb2687176e0c274dd09984cbe2595e3956a9df9acf64fe8eac457e42f29c4ac469c406b7067f7d4650a353c3c810c10ae36f8064aa584cfcdb8572860947203109dc83cf5e515df97f57886a660a041d15637a3fd5be79102bf29037c2db0ac0adc18306b07a31f0e85c270877478a0a5e89fdc1cfdd73aaba9f4a62851b5c91c22cfebb014e6910caa81c9545def16fe6f1aafbdd474594e7ad1ba3d1cec4d579b0288717ad481f78e3e779ca2a20fde736db07cf7378f48cc4ccd63e48c93b0a44d9cf90fbb4f572145a70eed3da4f61daea12c227e1877dd191d41799d7f01366f401bc5fa7050f09593a74fd130f68226108f86eb27a04bde3b4b74d6f9520028817b59e8e2ddcec047e3e22540e749dea48275a53f9c2b21b6e09f83d48117f3aed0fb1e81a8925c01c0a21742a21f1d1f71ce59bb27e9a233f7aa53502f850d77ebaaec88d5bb840aaeb777015a698d6a9ea54261f08c27a14c27bfce06208b6c5a3976010328eeb8d562d8d9de54199c6bfa80692403e08a476f018c0d4ed1fdc319f5cd74be099a1418681a0333f678675653ecfdfbc993d1070c4d4ea31e372f9f2f754dca32aea0f31b069b3c73e5c56470068da5d031c39d587ee0aa4402358653b4e297b39ba02eed6c1da518be660379d65a5536977632982cfbd3af889c52d639e27dca6618e4427ab626aadd3f4014fc14f247374937bdbac94269637e2a2865545d16834ba0b77716c382808a16941cb3d5509cc1edbc886a93524d0e7e4af83c56ad3f8c94a67adc23c18693e95dd0e2c51314b9b1f92b2a59f4af70946252da34e6749c65efd078ed4b1bb50d67d8a31ec80f3adb2755cad252cff210b1470ac92fef7bb1490e95105db01879bdf630ac5d42ea8009e32171ed707a1f331053325798bd0a0e5c6f7e4b7b0aa7871d450a01c2da9e1fca358d192958b8f1bcc84783c217b440f96a9188bfbac5507ea2320598d552a64987f876f01c4bd0f7804a066db554fea4c6062c04798fcfa9500ea3030e317ec71f75dd0c60246142c6514608421c4d280717dd126d2aca2477bbd089b045f70b699ccce82bae9912311fe3f85c48914f95ceea9010327d6bb155ee9a5aa4a4e20d3396544bb2b7de10bd1187aa0f2df7302ca1c03bf4c59d2ad7081deda8257e779709e7c518e71fcef0dea66b455ad853ab09ea485e44f5292c05d2afc77fef895858d90778bc961ec893e52060caa977d618bbc45459438b0958438db101e1a1b8bc0705a87f5ab78f671770539e039fd70e29d4807a27811ac8b4792374925e873101561436ecfc5b01185c89cc02091cf29c3634719217d835cfe6cabc1a8f7a98dd8def4aa4602b9e6cb9db6e0c6f0ed4f39e3ecf42851c6189ffbc071011e39f12a60afcc1c9a950d0c3b6522ac3f92feba9ad161cc4a850d854ee1c2cdaaafbb853e9296d875daf3024a8ce0a8d6e7e4419fb8a38e8035b4a4e8b3a27a1e2490471ee1c09c396eb55f5e56ba431e68a161aaefe7baeb7fe99bdfc27ac2f122efe81fe4351d720bc1f6ec06da9b3a89a47ad1cfb80cde93aebca9fed7ab6418470961678d9e7ab9c57fd47855ea60f0466c22a52718089d3689b1a1b1bee599fa1614f42525d84ce66697cae65eb05f745f7efc7dd1c3fb857f14375fd17120a7431028aecf7397c379445cb8af021541cd7dcd5e166a343af534a2b5e28e02f18aaa4d9700ebb68942989b9fadd7f5d4ff9c1f9f09c560a0d8fa0426a8f2291b81470adf1409adbb6d12c5440bd589bddafc71718a946c1a21f423133f561535cea692aa069c1eb596f8b2d3c9a20e13ff74e72b22d426f6e0f1c75f0ef576e443273462d326a7dc4aa344e4158e75142bf6e8dca25e95558ea5346407f2794eb2faceb01cb294c2bdf87a1b97b2b3338ec9ab3eb57b0d8d7f0bbd15f61c64a5ec045b7ef32f385cb1dbd29896595a68aebcc69999575f98422dfb629797cd7014f7a3e750da8c0aaf61e71a24b88ad0c4dcb0b67cb89806e0cfddc0e5f5052f6cfa60c385edc74c66d9535eb400314be353a0f18cdb54fc25deb1dc4c8f1d1408b01402884f4b9726acc31b72ca0129e759296a515be8026adcaf10f128d389b53a13144582c5355433626c5c0acecee5af32071e3efe19d6a624f4bd908e53fa97cedab4e8bd11afffa46bc34441c9e83a4ba80664ad35fa6decbddcd26e953e15f05022665d8e19e972663b8292fd446f4ccc8fa78ae4042e4771400f3ce36b220988f211c4acc0ac7bdd17d2f08ced60afc6ac22d006f0b18c1055e1510ba175f84b542eca24bc897932bb4d6b7681ac8ba569324d5c7939f57af98396ca07bb43ae4e8481b80f8607f39dafe4f347ef90c2a824e9ab557a6e8e1f8584127887c81c6c9da0e0b51e80770fb54a90857ae1505e99d588198956049838ac7ccb4514377142a9ec7d9c02d00d81776f9c408d751a2fb042c2a9e48c110103337cd68fcba1c361dc07e17c1ffd5e91986c0f10559070ccdd88b33c7aceee1d2a04b9b7da903a75e931c440294b215d8c1a1a2fc90183afb7f4e7d3f24f0c54a842add2be7e9d919989791f96fd59cc086fcaa3fd4017dcbb3955ccbaa791f34a8614b00c4a65cbd2323e605b50fc776bf1ff5b4f56110596a32014aa1e126e8930d20a9b54f75c80d4f632c3cca105c1b24f41f5f0b4c80b3d93554c16d9cdf288c9802ff317c510db8bae955589a7f35ea0942d147915c456ca1bf2504675e3feffe0df7c8e5b4dc6e98fddd04fabc8ff0a72c61f76595e2dc974952df70f71858ba714449d9fa43707e678695693a2467b2bffad4e46a1b473b7ddb6f9df7e24d2c2ff7cd16698eb553e90d9f885c7c505683505782e182502576c9924842823041e470d306645282123b3de1061c20c97f76eef89fe37d1915b2ea94f46c0256f522667a4730ea6f4dcbe8c2090a9b423a1c79b90e7b1b6a5284e30ffdcf9e4640a78ad1398812c62e6fabebb791725cd52e97f14d3c245b4b4a4e3b21c612d637b645a22b0b9359b8d4a875125b8d4c4c730589ba411864c93d70c065e09996e54734d8bcfb0224e27e845a92cc9a2316ebe9fbc61a5e39e7818a2c5050d2cd611a6beda56750ed12b5a8d7f7ab179f51c779b01c52d10dc721fdf6fcd4c71da91577469e00438d6789d5cb872b97363770595f203067d9b630e7451edf1deacdbb113a030091ee5653a5b24ed41f0425905ee3b9376f742af241af70a1caa19f0a8aca7982cfbd5a01367a0d66b30cd47beefca997cbf99ce533ff3f5cd6a66633738ee44dae8d4e1d938e8452f59dd4b08c72835c585bd9072e3234ff3e2ae2eef8762e1b5fbd61d5e6090d78234e769ec43e2602fd8266e828b460113c47ef83e447ea828ccd9d659ad97ac985e4ed2d3fd2f9a8109c518f9fde72085438507d354079c3741329e028717a7d1c8b177532b2c82d88b0968ccfbf0df3498a91cd702dc5cc99a0bf7cf698f37cfaa6d2c83cfe429ee92651653b66beac2e999d85fdf76cb466fd8d607bf58b702a8bd3661c7023f37e4011eb94b4a16dfccf7436edcab6f35c327594f821cc4b174eaaa87c84856443726cc9097ae6c553190dac19c09c709ae842241d9442baab431b19dd37ccd2600d6505306c14bf0f507de1d902b01ea19d45952a345b282840b07b077c542665d8aaa3292266aa051c180cd9961d267b13573ac09a6840cffd394e8d40ca6de9178be487c9a65e2e55191504c0cfc482dcd6127705d5ec6ce0ca442100ea2b8347ef98e20f5e871c4d2d802c9c475fdee631221d7d612b94f50bf30685793cd5bd07b4a11dd317ace233ad3a43c3840e1a5a548d86bc30c29417e840a7fd1e06faeaa00097d2944a95ec42f92cecd3e8852949ade142ae28e1aed20c1501e218d87a654697871447fd131660357bab27cebb7ad902c8a4b0e0e69f174802cda51b3e13766d52f683987904d1fe63d57a28985a31bb4572885cbf12edcbb3a23f1c52a9b50e60318f326c753274bd9dd47f831b244c0cee2dd730272eebddab55106e6df8e1f63ed2cabaa1ac2be0f8b18c42104b553912e398335c30640f6a988bb048c17e147fe9352ff723bf45e2e753125933e1ae2f04bb07eddd14e37b18ba19ec658ecb442fb4aeb837810497243f6780de095168c0e7277cc3e72b24ab4fcb3b547266fd170341d547ca50e394b6a094565ad444dfcefecf3a5b528b204d4609f6f6c29da0f177699338cf0b68cfb72c512d80e1d0968974f8ad1104a407bec86f5eb042a3be8f2536098a46800f279941c16af3d5228af21e32ef44842642c3527a7e0273a5ecc83ac2b0de7548469fa954fe75c824c101f7d4492c9188cd953fd2fe18a15ddd4e797d7ba8bf12c2289de97ad3bb4f61183c103cd38ed3d58467a515fd43d0652a111e8a4700f6bc18ade13c1171ad1f7d77ffdbe3c5f527dfa1d7a75bae95979ca4ceb30ef3ab3326f7aa5ff82c29ed63ba6f5cfc9e47d516f582724a32770e26ed016996303411415c539f031cd922bca1de2161543b3ca07def7b48534e79aab66c09ccec4f1ae072f95ce39cfb6f52472688a9821d959e180c990d00aff68a847a229f1f90c7dac8dae7ad405a1df05fe4e4f321751984b1a2207d68603b42f2d58f643dd1bf3c6013777fb7995a458910126c40741285783ace03d2b8869449f43cd7766bc980685242bc399045c8cc701d40fbb10cef617bf275398bdd41758f4e8f84836eca23793898c54579282e8bef54be3dd098d80a6c0011f8a776fc5dacd879b82df094653091030be4642d577c694765ca24edb08a2024e921b8384dd9a04bf8d657986e17a7402b4558e3be25c424ddf49b12e52789fca2311caef0a80488aa55e6d049dc0342841a780dc9594580b5cb3aac62b787917150b92f4204ad029aa33a1f83541ebb3d53b5754bef6077472a7f2399981d90f73f2ea18997c8aae576384b529c6425cdad4dad0dc85921500919fd7fcda1b5b7cb6d5ba286dc54157e5b6f6ae05accb310236202ea3555033e17d61503a9b833d562a25f20f65b76274c7ad3c92b5194e4eb3b83639dfa2f90d264bbb280fc861a817fd67a953c56f2bf92733ba564d3f98a44c7c57c4494d56a836be25113f0fb1a9152f50d49e7d1bdd6cc5e2d45ab057694b236ab88cac6346f71530ad42202a49323c249e285f58a493e7661ea043e661b7b42ac1b00820bafeaf38fc3a0df952e442e0e727dca7bb4ed225deb283e2b2cacefc05647b86977dbd9ec47c83c3acce3ada9a2e5d0047aeaeaa0143e2f2238ff62391b6655738c540f51fad221a38b52dc65aaecb07aa65bc8e7f82f676ba5fe210d20390063eee6a505520542f127d1f37ed6618f66c3757d443c560e5e61d772eb62bdb28398c2e16bebddb11051a6b565e603169f3e142ce3fa8ed571809f3a67e8ea88523bf8bbeaf987815b2ae363be97ed38257d1d0960369d2fff43f3eaf56b1d6d9e414c9a439a3015ffca661a33b1f3ab62c6225cb5a14f01a255547d0235d75f33b5b0d179f3a89916e0f3d6af6683ef5aaa1844daa457ab448d2bbd1f5822a9c7b3a4a0451181399ba28ab63a918f8a5615050572d2017bd95f34c22c5d9f507cf5f4a5ca505519ee2edd07dfdfe600ed96e1695f5a8a6ead1579af776925be2caf4cd508012b764d24ff84775988ad1c01022aa00d1d7847dd6265c675b06635c973b4fe8c4fd5675888bb7b3e41e28bc7140ef6aad8159eb422c46650d3c2a59677670be1fca046b1d9d8db772b156722b1ccae2fcc2c7f90c2b80a198a14ff43abaf3c87e1ea25f12a34c3fbd585ebdbdf29b3522d1dd4c63fdd539cc226a16795f8a5f103ca1a0e477cdedce4fcc01827bf708988f40e897e539a042c73744cd9691051df395c2d3aa7f31a556a6b4f0ecc510ed2a6e7d09020a4f3e076432c8108f4f1401b427d3de1970cf718b88f93a384d972095fdd8f6d5490a48f05281295e62db966b28089488942bfac2de6b2c0d322007d657544a0e652ecb592dd2fd8becf8ee56cd40b4cc4e0ca889734370948b403ad644eeb1720e1216ffe01721c25cc31e1017f9a064e45a3e56a1e32470bcee4fbbf78c0c6b099da1d93f8f5d725a66270b8747ca6443c8e683b564321798284caa390140b4ecb270ccef898cc07619de32d6c8c4a0fdb4828206398bf1ecf3b7c978810851cdff9cd0407f9b8b3c9ca38991c5f6b938afd83f37a79abb2f2e54780629d5308bfd610a4cf302f858ad9c1a4ac66e666dd6129a2d52896458f87f958e6d2b2291f157fcf973f89c6883d659fcd48193f0cb10e1cc409cc9f7d6167a119c1b2a10fd0d6c4bd81a817b6236d15d414397ea43df310856bd66daefa6823a7bc171727cc82cef1388d0b3e1f9d66fb8d65d05e919200e1a3512b2bc3ba199b1dc957df4f9bda0848c012bfd3509f6011545f6c7874d3e5cd5e3766ad1dc2816cafd7490f0134bbaae505f11235a42344a8135a3295be5a62ce72d189592ae3bcb91a76dadfb5850bfeb90f45afce1fbf8a28ac28b623139b1c5756564cc3320920110c8a1fbf2eeebb639e2dc0f79edce3a46c1cb3b219b14b96c2bdcbc86ed3e9ff8461b7860e1921da1f5389c4602cc22f9896a329e1cb43df7674fc026ac15c435134519fe315a202b41ed19d2521f6e587fd56f1a21a5bd30ae775701fe4e6e51f45925ce58d69680694e7000275b32fd2f235a1a11f5caee0b664dd1887e6fdc30f54294f23578d2740c206203c70684f30987299d05c443753e760787f0c59fe484172be0a14cf739743d879a6738392f55ad574de4d78b3bf004ddf4611f45f6cf98d691470aca02e9bf6a37bf8783edb34f7bd7100593f48d010635df3084a45db2d5c4773ff19a5e3965199c306f7ce69bbcbf2b969650a50f35ec28e326439b9a6fc810ce6bd2ff35610bc880a020941e248ba61141ca34da58e8b93d21b7e12657cc9ae632f39bafeca0e4a7d73c47bbdf9c87d88382ca5c2b5b7b270d7300c77cbc84d7b37e09b930a7b7014af42d4e57231ba656f7aa23bb741eb5840c12f6677416c689189402a297365632722047e6fd302065091c9107b4e37669b19a3eb2d95431e92dc9fd47ff54fd6d608ae59e8bf72893931d55d5b136e45d055b89ec7d2e42a245c36a3ceb0138d522319c6322c8044d3e5c4fdc243d0534e28be22932019279d39f549b6b58a6cf62b31513a1fcc49e356bf3d59fb558325e216b707ab07d87f316b1524130026d24820243f9b66107093a98c8266fe2ba094de7614c02e9212503cc631f35f06be24fdbfca3a528a39c1303c37e260b1ce855d55c1e10f8f03f97aab68a209faa7fe3c1ab5af2f507fa594ec6069eb5dae57b09d2ba9cf9cf1fb2fafa41dc2083520c492e0372f1cfdce5a4fbd2777de5ff77e5a6ec8187b659b76a989ba4f3e9cb2b4a7075a3492c7b1e6f768be699418c31a54d23b4efdd91f892bade360033a433466a6636d5ad6d0ed649620f3ab497da2b14b9581241c9c71972048c75d612ad36a18d70cc73e22501b2bb59ee7c7ee8fd4a0d0a5f750691d9d6eec278ec89f8a054fd449c0c7faa4b84775add67cd3cd584d1e6f71cf3e0d48895cbe67b9793fc3aa3cc3f715e9acc296eca42aa53cd08bec058e6ed51ad8bbac7e39e072d78412411b92a2b528b19568c9acff70b7664e967227801cdbf4a4535989e347f5e35356f01caf2638d9c92c94cb9d42cde01e784a33ff7e1fe4e6b502ca23989f8df27a96f07cf5ae48dc2afeb0689434af2e539a14f324534cafed226f774741f2cb98f1c5517682b55fd96eced6d6d241ccc634b2b74ad7b26add06d2552c4786facae1e4f31d92dd99b313e82828cec30b41b7718626bf83448e3244c26cfe6d68c40b1c2416d92b336e592a07e8a08482e454280a0104f900812e7a49fecb5ca1ed4bcbb1d2ea8f398c2c940f18a417e5b71f4f3652b4c44bb3345bc6158acf8d2ca9ed515d3e7e8b6a8d1dcc489a4b9bdc6f3835c435e7028797a2b42874a58befc34870a35b0a96af0f391851c9e7044df7311e1e9707cbd88ce5b509a341bbdbf2edf66e70e49ca7ff3b5f072aa43670d7b61aa16e8f68da3af6c2b47d78ff7333cdffee0ec2cc5e3708f956faa850fbd656090fc4f702e7b316bd91579717442475ea078dfda1e57c64e8a996bc4be8bd30e67401631ffefdf6d927fed7012dba7f143b0884349776c8b0ccff7c34fe76e3f833060012efc15bf8bc2c71e176c6fe5dd562a41723eb56cbb17948f45b36aa96c393804fecccf889456a8e1edbeb6bc6900acf4c36ddd47563f2061fceda30b33504c8c8df9786b26fb1ec143ec39296e8d6c3fcd8fe720e13ffba95b608f285fd973eda8172c18ee29a2e199d258f818c977c481b77d9d557b96e4939d30e1cf2ee62e87e9e690f672201c886bfebdb1ff72b17eb46110f499030850fef921f244b6c0d9836d3b66da3d3f7b0f06a7ecf5d7e6651389a0db3a180cce00b0591b46e3ae382e606473c7451942fdb351e29477a5edfc8561264499f6e0c1256d65d217063c7947a61ba486dad503231c748931555353430599b4051f083b16c77b2fbf72a1bcccce28909c8ec955cccca2be261f32df0007efd89c9d615351e762a6cdc4faf87558ce50172c5b5e736a1dc7ddd17baa4e3bed2fd39007fb2fc8da8ca44136128697cd46f015ea327aa3037df46dde9a7a7237147d2e4b6100b60d3b1cd6bdff8be45acaecb3e6aac97f6281d2c306007f455c4e156fa970c54282229cbd54806e7ec1a42b00c8c8b474aa14f2d5416f0a53c6fc98e1e52d4e9b70dab2cac8ccfed7b597ac8dbbf09831e6abcfff5858be4bd7657335e6c58597d998ca573c7d2ab4b5a448a5ef714073247cf75ac8a3af914d732133006c78c058cfa798b09d5c51416c1bfbfb978d4c076e6cc8e90485f622012abab65c2e0403ff8ae8c552bcdc1707097eff2734505c5b69afc53173eff2e85e89f2e99abf6d4115745e53cd433a3e09e37303c764d8030cc75166dfff7cd5082c81a5946cb76e807e3f4ef5cbcfe92ffee41f404fce5f2b9f192bb8c9f34845105b7591428b4a9e168fae2bf086cebb4b42266188273e08ce1de61d29d9d2267e4c282f818cedcb3480d175ff0582dcc72701fba3e43059ddbc8db3b73e53793da8853a539a9393ab60ec3003f93f8bd6769ab66b09eeeddf734200445033ae72a0c1cb0d561aff6f54fc94cd857c25ba5264cfeab15e7e34c90edf0354f116a60bc27b8f542f7feedbd8b214315798661076d6221dc2bcca2645014849fd3e3c65d000c9eda3d81d07fdff1e8c8ca936573b7524e33c5b90e169ce92ccaaeb93156ce26d085ed7d073c9873c929f9cc5b149d001c3a3b3539468f90773db620c5f7286505e47ea6a424f1082f3466c074b6a3691e3761d5923b9f5e9270fd47498c0ee406e2f27f6f5091e7366109fe5889f03541ea42f747eb2d68ab4ddae8753b8253f846952e3aa139e9a6c12571b6709f446e2566fae7b23db3298486520ccec3e82ec967c4d8f9e9d769e71f31d0e65c8e07ea9547716771a97c368f8c7abf78b99ce0003c7cdbb7059b2418a87e2ae552ac94aee6d0851295c82237016cbd3c4800f199575fcfcc5ec736fab2965690174fb35142a8c78c3c26e4fe006802a03d2b44d4b224ffb4f67a24f8b6cf271e931d207f09e0d4a31240a722bd1cfbb6dd2b3fad5086f5a2dd4085dc020c40f8fc60e8934260f04ac90a52e41ce0e133e8b274de8dda18561e574256b49fa81dd8788bbb26f33401c135d33690625363420fc8cffb8c55a721884675d6080b046d8c46d597139211b138ee1effe2d7b66db4bc0d8904e611ae519cb29e9e7c3d02e6ed8e14052e7bf7429441a182bbce1eb31e4e67e43cb6ae0b90a9119ae4d769f54a689d4efd668849a5d11428b1342e50a4054965ee45fadea7fa8c504d8d98557f5bbe5c4832375f7749034d2ebf6146a77a16cb54354ba0f349a1b48d4e2d28806f75f00c6f2fd2e5b7f97db64f784179de9939c0eddbc73d6a469e6e630676a6b6c3764a685a27eaa47116875b44150979445326e015259a5b7709f7d1548f7cdd67cc43f626b5cca943a28d1f10f543117b7236b7af862ab9708abc955edda453f2e31b8aeb6d1b5671bc7a25bf9cbec3460da8f8c1a6da4cac432d5a9c77f849c09a81e7b9fc3d974d9a3f434800b41075a6c7ff25a3ec6c71156ebab5cb50e493c77a46271ecb861775fabc0eec9cea35185f60225295bf739fd8a20c0dfb2fade3aa70bb5b581ea7a1fe69ab6269f17b1e674c241f14387aa503c1f2627bac75a686b27f81b15310149306147ce4be4c2aa70ecbd4cd23e22dff29ff195b85bf855615eb860297551b60c7b5d8ad5407b457a6b5292738ba7a576a9d03e4288eb4360a40ebeb9e56d00230955c4402b2fe7e5282eecce99e0d0ca2c2ee500a3cd763bb00c818f7c2c677c80bc5cec2044009d3b9a9d3ec1f7f85f92034b44af7d9b4cce23c7ed8f39efad0a2a9ef32fc68164e47e6a7fa38780d32aa4fe701a549a24eee81aab4770fc5af262cc96cd11994517d87408fa1246449bcac4c23b034be4cffb24beaba9b088448f684ecfd0de94d6241f30e569cfa4fcd1766b5e48e3c54480818ee2cf1523ad08a872a1d96348f58971a649463fb953129f2468dbf18c4181bf6e2bdd58d1b6debf8972186a6d2077efd8ceda811dfc057b5c0251620d8293dcd6ee1053edeba0c73db9a1f5aaa57107434cb60230293c367a998bef5e2caca57ce82a23b20437ee297869ec5271fd55d3111b179377e961917e472563cb1c2e89406b623558349affbbde5ddd143ff81601c288fecb3f2e7eea9811df1c72c11b1bab4e253f5afabcd0e6868be77f2e5aa7d1058844b22006e098a57492e0cef85e2c2b39d4e86cacecccd72eefb3417d3736fad17b261e0b2f5f95ed10f6a3e9471d8903ff4e28b21c8e787a9d5082eb8641916acab9f9bd7dadae9a52adf831e7205052dbec70138b41dc5b01ae298ed091f1794352a6611ed7c9309366e046003e520f30455eeb24271c49da932755fd63c22611c2ceee6b964238fa3cb052b23a8a187662c1c6b2b118baaca17e020b177ac410563a7e91e2b0a76990e2689be67e6b8ac8faf175f6448b5c2f2b049156f37c1cad95094cc66e70a01b67b0d9885505b00968b3020cc299fc965fee2346b5d6723205942ed5e9e93535363e876e4729abc30e0c266356bcc9f5f2a37ab539bdb43f7ecab0613f1c284f45ad349622674a7ec74fb211d275ace2bf59d3f0cf2172f21927275e5e54891c12205c5f2c13f092e44327d1986915567272555de07045dcfc8f04d3f0d79ea6a1ffb51da3df946c0c27b85d424819a255e1e18bf7ddd4ffd2ecf140dca3bd384163387f05481cfd3f73f19f6b60fd50bc25da872352657e766b4311abaa625537efaee986314ec0a04db75584de3ba57bbd0bbb75e2d7d30641fea797d6476da43a23bc7c58939d24f145d4aab1b42a47c575baa53988a605c0cc4f797e447415598c75d203b42afe0870409d1b87ca68fe4205bb6cb1ce0e9f38415653db393fe4f0ca90b520d1e2e08260cd61b1ca2be99c6775d8ad8b2bc4887ac28e83c2a87b7a0e4f3494ef23f35a1941a33f80985cd12eea004177afe197fcd72222db905bbb99f202017f6e85a20436e2b1ae246d95635d4d9d61970821c1284a374822f16b19ec0cc387f9283982a4be0421c7b780a5529cd82dcc0aef2c0a881ab3249f220232d28a77385038e16495274a927f4412a87a686d9a212327d0fcff7be4cf60ce02096a127b02bd579a09ba8812406e9eb7ea989cf75de3ff2cb80ce1105cff3bc17be141de386aec87aaadb82fb8ff285eab01939e77fc365362e4ebd736c2b160f519432c997e4cc781eeca25239e913669c9a017a903d19bfa5e46f86f4c68c8cd8c90ba886a16e8a5dab06a16938ebce9d50d48ec834c4e637ffafcce38ab823407907cd2ff8caadb231ffca4e0046f62cc1743afa2b2f80d413b75a05a3ab7657331e170e9f80255d73614e86114214f02f5b3b4b3242cacbbf7f5cca5e79bbf60c1829be48e918be7845e20dc3dcb370957c5a03795c06d869aa9a97825820f68f45a6b93dd494adbd362aa7bea04d2f1a481883ba44ad699ca934f260f7480d4522f4744c681319ee123b196c409bc44190342a6b34ba1baca6d9cdeafb603cba8478f120eb17d87bda5975c2e40b6bddf676dc9b8c9682aa1dbb03941bd8d1d87156e2a2c788fcfffb213a7ca615f75fe5e12ce25e6ca946bcb032eaccbc0653b8602e190c40e3080d73b9c63145dbb5d089389122956ede96b6d432954a5a77fd4ceb183579b74b2549c30fa66ba478256011b6fe69dde7cc8d6eda131a0d7d229f388b9848301bd019eda677cba31c0356f75f44a88081cb9f96e5b08cf8e9e80593da70dee7d84081d95b61d128934257e225f21c423205624e254416afb0446a69679fa793291c1415aa0f64cc977a993e3a515ddef4226c3ee6eeeb889601b2fd09e559b5805036c64ed11a68f1d66ce2e3d32e69ce834780d6629ba98892c3878c74951eb2c37a2eddd8b7c843ad16597ec9bfa70e173b2fce4468b0a2be7dde706e3b00dfe76bc1393cdd45482d9e0ecac97e87135b143d48348f2703e07e67c38dedb49ee6831b58f4d5a383ddbc018052839a69434f7bba32c73b7132652986ac95454ad6f86fb754016b911fb7cc1b9ada09c92605314e8c301715b17b404b7bf0a7864f2d90d4b16f6572bac62a0532a68164b4649484e9e99ceca709f95ebfb4cf4d11c58c968282ddd554fb705372596cfa94d894e28214543c0f5c8fc863d96645eea4f15b4ff97801d4577739ab399ec2c0242f15cf3625d2c052304e6cbe761b2dd338db76c57153eaa506719ca6831650e0522b71a1b2cfbf0f61badb4efafb97a59bcf9b2f89b96f3866187fdf1d361edd7d896c83d3c8edfbcab276e176f0875613d8e89bbb2baf7de7453785288f5965a6e70ddc962a8ba7a1256a0e8714610e024716206ea3b0300923721bbdd9bad8244a33db6e7c00fc8b971b25b7a468350be202d722cc9005d202ba1b37494f206beca64ef6644b1ba95419ac6417ca417ea6f39feead0b935e91b922855a009290d318220a0fa8142be7080603653cc3f429e4447ad9a329e93eb04b0cb3b79b387","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
