<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d4015d6ab4b9db0f81c53e7035cda777cecf980a87cb4d8794c1645f82bb7df9e9ccace746834773428caa07604b5d14141b74f9935bc7c4306e23983f8d82cae9d2746245fef7beb4fc4d5654885759f7388072f324b06764ca12cd61c233d4982356f5cd54e52655f6219e95bfa9b13322616c283ea5db52c21cbf3de1a69dcd00f69f42dc60b9f52adcfb5b25d7d1f71072ff4f7ab575ba6bb6acb65ab6b91371c6815eb710a837acdd1dfa78b33d27f90c53b7988c7ca31135f613b5f854f8a88658156f9ffe995b83b249eefb78abe97990f84c1b8a8872ab9efaec6a842bf6cb4f2e2f0969dd9ce03404a16ede9728f5d4746eb65bca3aaac6cebc3e0c11cd82bad25ce976ac5143adaa296c0d608ea91a0435376517c9df3e8fe0245ff136598d48571549553ec01f7f76a8e3c1e84eac592c777972cf4533a2edf053ad4b3c5e40339822f506a689bc52bf248f13439a9fde876eae8c1ae1a64279b68fe8b73eb64e33b0aa5cecdfde640cb65e3fbece5c3e931f9639a62227ab263b06920d024fd72a0e43567777f055aa07c742450787c311d09274d0c5e31073dd0a98a58c9898f960dd7c532ff0e4a047b55d338f41344196f315a3d17c7810df90947620b75db6f4abc6577192c68488e5cdc72b2331451bec5b6064d884ec79cec68a91b12004f06a444483f04537e1fbda894f29f3e3a9c7c90784281aa9f309d67d4f3905f7097a1dcf8101ab0f8c89a150ed57d3f7551772b86d6b994c66d6143a70dfbc03331442667286b182c75e5b95f8535f5b2200fdff825cd2b8dafda6ab6ae1982614c9e162e6ad8950684cda7c4a83819b5d7219ff75b0d7e71f6c6558b1f49b1073b490e00ab87070ebf8bb280ff26e7bb6d7e4167986545ff5fe1b38eb20ed47d5eb384b323fdc017dc7bd970106a6a66bc063bdb59102e9214fe44d58ba10661053087f5822cc0c69b70b14a89d9e348965611db4e5557eb0a245db17edfb1c149b8f7ec4ddd85ca5ff13917544968e65116ccae91ce96c3a705c0d22cc7e484ab187e34a815593dbe78f0658c06f350eeca626125f29938d9694521104a033447812f8159671ff7203b38d8a889b320dcb4a3b70455fe01bf585abfddeac09f07059e963be2db2bd7fa8721ab54757854195c895661c266be2227f7ea77e3fcfe4d4dad8d79065a484abc536510208c5b1d9d7b29bbbf8bbdb30162a29e0b2ea3315f9297d8b84eb5904bf0ef3a012708da12833b201c24eb45d8f85c0ef74d218b358fd27c336ef64449441f8b1d1441a2147c9bbceb88c286fe803e5640d8ba60d0484c742fb0c53210bedec140c9af1d527cdb17d7f09a1064b4e194f8a2a1420c26210f19024e23f7cf4c28b6993c4024f272843468870f71b0b1d62a1836f991e4b2e15652e38f7835d7569c40b850081f1920f727999b2cb74eaede0e5dbbf4c766533606c33530d4a0807e477aaac5de25423b2160bdfd9332028681495285316bce9cd229ed03035fc79c51fd01c61aa93eaf7a127d5cd411dba9d93fa0a2154dfc8f7f8e9309b37c7333c3ab8d7fde3f1d35e406aa913bf8431e7a7b174f86c5995aafdc20b1f1814e1ba5d99ad6d558aa6a60eb61a761238297aa5d9cbe7106ee60aa59a5027cbbdec735b6de77820e5d38ec4fc0745d5a767603678c6306076c4503c94a52bb9283eb2ff2be226f69fbb5c6aea16991544bdeef6d8cf39624180296e09fc8b9a09711454f0a95a8ef411518129048e006ce16d8ccada2771d1297850c6c9b98737f1dd110708008fabba6dc693601eb38bb8e06471363c45b04832ab0acca20fa632e2cf41537c5d243afabf81d1abf895f36be4b260dfd81cd99447f209cbd8b63ddcb881b0490ed11b10cdd4a6e76a923053e20c011ffcf028569581e6bcf74f12abbbe2a95dd9a10f883e3f3a739b5a0bf3861d62e86dea5491c617bbbb24361998a1e8b15708b4d3fea95e50e7d2307566abad6b499e2be124280eb5355a6f9a7efba1c0084ff64b7042233cb9b79c444f49e9e84350c5918605292697d4125c394f0b6a6bd1d0bbb1df7a684eb51c439a287ae2eba0779c9f85f1e1ae53db0ce53c21d716d7729010789a09400aa9590f3f121f39d4e204728628a4068e93c2cf85aa9c4a7d31de0bcae783282aa625a72ac6bc923e71f4c10c8b40e564c8aea02b62b377ac619c0b27b960b9e63af1a9892dcc873c2b77f18b6f71c3cb62010210ac94ce3af9c5f0688c415fc1c2aed9e1bcaf3f6180e0c22b123722bc6517e3c89c3bb21aed782cc8ee87e5c68cc7216624fd3685dbf92cec159d49d8021d0c6500921146eac72c73b8efe7a3b3cad2fc4b6e0319a34824c6a92d2820e89f577259555ec38fd87cc654671a48b7494221e6a6ffee1865fcf7f8efef18f811d4bc538fccbc354832ed790b585cd38fe645fc97894081d70025be4661e06718b4c7201925af9d6c08f9ef6693376369c017dadad8d4eab84cc56e28e0ee942496ae8268fd61e4be85680cae5455d05248098e365604eb3573481891563754e4ec8ca8626e51b95e9c67314791bce3b9206989f993292eb98ea9df29f8533ab29b70e1b1badd27d697947f0c9a5806eefadbf33740da51c0c560628b966a091e63baceb3f3e16cf24187832d4d9ec4a185c6b863c467b34e41c2e89b6c29d555dd340abed6112d3b864c89cd11beab7f597f5ceb14df5b12fdd4c51ec47600cf1b00c7376978fbaf7e3230ead3469f7ea564929487ecd86889eae228df487b6d5a3e89a2d9246b147ad5ee2fbe3f8f29f3717bb68a8228ebfb3ab70da83df2dbf28614881a3273cd14fa5a94a60ccba721d4934b8ca708b143dbfa856587516dd1725b657896083a63a96b24433afc3a6363105565643ecac6786e3c597ffa73ddb917c68fce0eb9f9a6c9f3602dc813e0dc79f15d9e8da7aadadea08090b96f579918bad3c189868835dc10f92f9899bac92ef9c80234b7703949db6c51fd2de4cbfdc97ab1783d1589269696798297d4ee0f7fb2e7cc8f4d1e0c65e7ae82d44e112c94ef132682fcdd82354721ecb4c8d6864729d932141dcc533d10f07502ca872798e41b10d13c11ad0234466157f2e481ea4935b6870c1f4fae65978e1153d772e2e2c37299604a9e9d7ca8d2f9427f8653c947e5d6433c774f34971e213e8c044d661a0f49b1aff7f158f27caa312fe3cfe104b1872a24f58fc2cc5492d2a3731029432757c4d6bda965072431b860f8af51dd152b875871e85ef6ccc13ec8290127d222308be508f1b7a75abcfaeb441c080a9d36e4b01bb104ecd7b134abb78e29528f834887e11b0846728260a566325ec7b4497d2e93ca7ebac63f5f4de238627c73800be36d3ea7e3f8ac111f1c52bc567aebf27f4eecb6c5ba006a828a2c841ebe454c2857da2bd86f64e626332f337f2e75b9c491ab70aa9bb2b77216b9de08943cf889cc506304d76e123fcb34cc26e9fae0009b6063b9fa19dfaec923b9b8d6b69e8f97e93a2a3f95e7be0dcd5dcfb2fddc1e7d09bf15adc0f3eac41d785a0b44916362392500f15acb58a6d43d3b0d2502f76709d35a0de42945e489fe31246ce9c02daea90baa79ecf1910415c522b3d6611add1266d82bb7dcec33b7dd9115dcd1918edeaefedf74b947005a8575b85701012b7a45be1c1dd7284066ec289e6b7658e70b887facb7498346988276532a5c39203cf7c373643672c46d669f996b9a0b75a6fd96520a58e8a9ad4d062f90d7d106f8387df530bff02126127af50609a55b043a4e9efdf0b195d0b98c7afa04fe1a6188dc9346c9e98efb9a0482ddb9cbca1c81897fca92901e14079a1f96d4a1867ef52245fb8376eebc25d7d9372a870c374cd2129c4a98af91044d97d126ee22c40c079bb7eab2b1f8fba9affcf05590112aa302c34b2497130629a8deb2096ab1e948c837d4b766991c5b4af719610762335c1b7f4909aebeabab884e12394d9c6cb730102a582b9919751ddd0283bc21f9838ac24e6630bba3a6e5887da9e833b8dca80bf8149b29b3ca78c3ac2e84551aff861de512712e8168b22e78fcc0f0a76be70ed8668422706b32cf839155faa47b0bd4bd09852f88ed6b40ca508736ba2c3b6d485047ed36e88489a450d7aa45423560c38c13f971de509ec5530b6091b8154ea011d284ee3db92a4e79aa4ac58a2232b8b17c7a04f297a6be49b2522219fcbaf677ef6f95aebaf528a5448668dc684d113c85bb636aebb30020c5c29a2ef4b93152e80df64fde2878f1f3c4422601c9a101c6e84deb0349ae84ec47811c05f91fb19c5d123a1a091b196c953f27e795a8dd7f731649ee5c796f0d1561701e111f983db2593587fcf80a13790273ae8b943be5548ec543981dd7fea4863a2d1639b0bb868657b578c72813b7082e7229f1000a58d426cdbe6188b1ffe17c2c65537f89fabb314df5f7dd4124b0d3f089cf1cfe5bcdd57f8f9c66ff4503d9d01f1fbfb7529e5cae26368bc34cc13e971447a2d70613271873bf293c12865827f2ab91cc2cd83786c50bac7afddb44cc3d918281b546bce9c626a81199630ef5df9728dddae0aae4c0ab2fe4e03f512843b3a20a5b8b9409c5230c550b676304b2f329136f3c0d67264c1da7483baae520948fa9bc6792b0a533e61a88de5ebc1f0b6dd53f94361f9e58087340f549c5da4f36b2bbeebe65fa88d7776d1613bc8f06545d9489376b45cb32fef4a878609f92ef2fd40237f7cb4531c2a20d9d518bcd990f127fc0f1e3b5f474102d78a892f9fbfb1655de30b0bd2a18d254270777c343c0c4db315bdc651ddadd1fba40d67c1ca7d5db70d338ec26e793cb2d7d633bf397bc78c127a378ba7bd18728bc9fd76173a3cbc362efedac9dceb31f0b179921e273ec112a3a56aca2dbb49a181709290c0f55bfe17a0b8a76ace924d62ecc24b55c7a97b78d8bb181ae2b5746064ca59c6daa962b3a10399ece23c3fbbb5d03fffeb7723689296f3038ee528866ff9870c7e6a1b51fe58173faabe9adebfea0c07ad4d76c0c13dc125254382ede871987c20bf983bafa4099315a9221e2b5a7269006283700692c9e517b3e3b908363942f2443b8f25d80834ca4b9e685d446f2a4a72f8ade21414759e90636b0d1abf339c2798fc30a608d79b11fd36751d11b669e34d708585a07e1e92d49925384d0fce3fc948dead0e31c680400bc132bd302880aec43c81f96993becefd74fcf0b817b7b1a85ad10aa9d981c86ac3a15410a2c96e4be4ce1a5fc4fcfaad29b422361e5764df843bb17ed49df3f6839097a12c1feb4d6f56c39aab93481ad9cb1fb901de069cba9a6faeefeabe20c3ec085fe2f5bfe5f3078f9cd6fd2f769094f174bb4de7059c69a5864596c96014b1fb1b4c38f0747074238fe6c75d80dc162f548e92eeff2dce0f21ea26b70c7eff64bfd86e9ce2d44d52218705068fe10d9bb79211733c436c464aefac08ad60e429cf7193e91d5c3b2e94b7fe67b2a98176f82f041e0c86cfef2b886fb27ce43086f6543b708b8340e0af8f9876d0f49aeb87852b36a7206c332f9037ffabade58863242c91d83339bf2ca959cf51deb52f3829726ebd92434f6d403fca3a5989c3cc0edaf4dbf1238fe7cbf09d973d8873041872a665e77d79234a8d5203a48a1453fe8ddd900c02d8165171e65bcf5c00452bab2d8ed2498ddf3184752016ae925e6853bfb0d39ddf8e87f6f890d6a51be852d8848d5b2e09b2f7827ed1a54584f1832c3dd0f142c81399250ad39d33c151ff40b296f1cc7fc5896c345f8b4b77b9b673b0824bffebbb6f48a0a0594d4efc9421df8c37fc1f8ca296e48779efa42e3f73b644a7062fbf14dac5f6db704334720461aa8e0b2c6e35f2e9710a92dd5403a9108bc957d9aca042cef4ce6a6109e5784bf41743365d7356dcd34a2ca0f1d19ede3be9cbbda4cdbef68914b17ea6545931b0064453d8be1a272cc7f9ef58f98cbc9f1bc4bc318e62e18f3033ad32346b493ae710d0a0114cb3bd6866138d98989b0d867a0d2db307c58122d96d35ab4227449af65c826cbedc109d0cb7f762cd707fb2ad4b97517f71974dd26e8493e01ec8d6b477e428e24306767e3d235c69d6d1e514afc3441c11275edf9ec052838b23889a96dc29fa23a8d814915e104929565f8b5c01d965030753fc8c6a2ea71bdbbbb9797a2969a090001811061c862eef5bc09b41aa08079e3ae3e5522046d1a6e98717ba1cc8c21cc9b4a1dca3c05adaeff235adc5bf493e8fafa81c543c3305bf03f468e80c8a62e11ea8e53a9c2965955a5758c861bf7376a90f894840459d22cc2402e6ce0b8e15fd560faf653ee42cfe14e5d2c738695db20714a572c71a193f74079d5ac329df1a76ebb999a099f9cf74ea3bb533860f37348fb17587c1b7d03d260ee176b8392d13c7761d6b2120a7a7b7b90e949c24f33dcacee858b992c4415c5c9742ff662a308951514a9ee3629866660fd41a7bab4feecd48c619a3ac39431a76fb8d2e1957dc96f52ced5f6098f08411560affc38aa1a41f793a54582073b0ddc2a84d05fa1f4743897ed38e5aae980d6232706eb7cce2952121c066cf13509756934319a592445e212767ee9639e6f837ee2ef74d141e8d34529eb7cd00e268b64ad5b97d6d89bd91c78789dc5139220b81418629e95e6cda40a4053f1f5275670a0649ae08294f4b79e37cc131aa7e6a03e340cd532b3f8d738f5e7f237320adbcf00c0f4a3ac0b5c6dd62b6e02625706f3cf7a6a0f4252bc4ee19015ad2d5bc42ae49026730fa0d90e11e8a4d67e9d1ea0aeb9f54bf922cef82478f2816515afc8bfd2cf8034d3e3236d23f01af38c32bbf7906294b4b5bcf5b6956fa2519e16583c2ba364f6c155ac09942666691a056c42ae9381ccb33eaa1f747dff57d8407a996fda74b654aa12a0f2ef0069deeabeaec5550a9419c0f9ef6dc7a7fc50ec4e6248149b76abb10e7014d7965484b17ec487176a3dfecb7d761850002fbeb34b9e423e25166e479b3fab5f824e3ac0c4fada8d28a7bce16b71aaeb6607a6124b5bb47baaf2cf84c7694f7b6882a625cb7b26bef1b1c12b02971cc204f6156975d9b75d4b1175d1f2528635ebcea9f27aa948d37d0da898ac69c9e2e787600199aca44889af9e648a5a43e64d204f8965bd9d3ab314614f0d5de1550a2c82d3c6c8dcd5975acde6f30dcd5d984ee0c2bcb067d2686f4e1bba0e43ce72cb9b770b1d22ec0e0aa5b7347a378275b770f89f5d33edc94ddf4be943b5e59499993994f5f2d1d1c1cfcb9da9a5528cebc039c75da5c3d2e37967ed2efe6e24d9303c0cedd7b3dc28dcca63829b502acf96021f5140af723a8e34cd1f541d87b0f04c3357646fc29b8e37b80edc53a9c938d9b52a4949b8bdd951525dbb787fa5e3809fe961d42df9d7f026aec4c821d9877482813dc1fe9addc70fa86ec98ce63418a8f4b6f19c9a128ce403ecafb5aba30efe613fee8b1ed25603edb1706e99b40cd9100ede959e50a71d084bcb6c65ad1c6d05f6e32eff013991b70fde95f05ad9d34aa2a5fa15eb15b2a35cdfa1ce67a843966f728bd6ec8c7a6c2672206216cfd1623505dc27ac10df3c8bd985821030435e7320efa08824094f2f0ed9485ffa834cef06772a5118a64de857435119f21116b78de91da79c9d875a8c4db4be6fe2bf3d7740dbbc7821f802a7a82f24d237eb444a9daf07b8ffd8870eb0c6a08a7426f863b3fd0921406a9ea3890598dac3f34b671c87626ed52a795f1a0b2bdc1fe51d4e8b60a7dae93d8d031baeec3ee972a0aa6c0cfb741a33580372cd81f65bf69da4d372d9da0fba2a01561232b08be67c67f4051eeeac1d16db6de28264fe80dbc48fafabad4f3fa05ef44cadfa04c91d49d3d2b419e30695d7fd6c16f9d31fc7a9443dff276bf2b69936e4efd9eca1d7a18973062d548f171835e0267c0c7679131c543ed4d9c24b52e46ad1df57068d90090ecfdc6dd9757feed9546fc5956ed1aa5a6c685946138e957c45595164d2b16cd06f618e3d7addb35c6566114cf72617fd2cc49678e9668ffd42ef818e18a5c116936d1f54c11b7ecddc0f23f9729542d4ce28c4e518411b19936a47d08559e6b3168d02d50a948c6b9f8d6b0f8725228f0ef527c7d4d436497e0386cb765ccf3a1eb561178e274f041205bf7329d15381e018d3882f2a45d41d5826d2992487479c7e151257042622b2df3144d3704be1d0dcc26a36591522d72478a80ad708644c4679412c47938667a9525a6d54c0157a1fe9867379083c98f7bf837428a32da67b69c16f9120788fd91f2acef9ffc9f36ae40c189d357b53cfc0ae6fc66321ffd4ee44c3ba736c0f725be296c69649a80220fce51b88a38dd73f601f4cd620bdb2f8494725f016e9320e0acc0fbc45e6e1808610dad1fb407a8e23cb35e1eface09c1452a59f746aa84b80e1f458dbf863c7c8705b2d960944066323729faed2c71d61211d71a7f7f429e24d2896b4cf728c73f52f91a4aeedbc61c757f03cadfb881dea5611ded3d129990ea42b027e84e330795a40ef777d6b93d615801aa0510c1d7951940262db7d17ec166f813e8ba6a77a90e33d14ed06a7af15170ab755a4efcf81f4f17e758ed0ef024616e7daee456c8b33b72b7d4095c6cf5cf515c78ad3650ac5a13c56411f633d02f0862215d93793d1e5a648da29771079ea141dd786d4f972769bf7be929193a2c304306dcf58aa5ca9a7c6ab72872c85081722db90e617f023a67b48aa7e813c3b319adaa87f0aa1e85d17f963441551450295fc9dd62cf48f8e336f9999972137ee0458ed3e4ec4c9ec000a3161ae2e1970d3f1ae9afbb52b6ddddd4fc364c80e60c4ed0fb0919b3036bc64409a7ff4343a3f9693146b6c3db9d22e2c8ab0c03a5e1c4f4d3deca1e278c2b1c9f0c36f11b4fec158f793bbbeaeac5d04b8be02c3fd313c867d91ffadf94bd4a49d2f27accbac108fb57b1d63951cbc4408202c7c73fe514be4efd4eae09aa27099306927975f3b00e8217d3be81aeab91d1734a8b5a04de7ed44dab943c8d16ea775700210ed1aaaab97eb6db0b705cbe841dd78a58f85fd5d00bcec5f050c8a277da90c9d99cc091803266edffbefd25e58a69f2ec2ac75e622a25cd071e973b02e8d4d459f66fd884f7c4a04a3ab3c820c8595facc59934eaa36781fdb3442b9e0899fa951b23937ab6f652cd20d2c3c9f15939f48e503cca6a5761ab4b4b4a6c78131204bf80c8f3d9dbea0c3871aaad28b3b8045266e9de38262a7ad2d904d345f4614e6bb4d12a8d133a2f8f014c1c710553e90f2ff3d3f5ca3d86619b1f459fbdf997ca56f9b9a2ced944005173577a675e959156885b6478b6ec3962a60f256b93c1ab1f26941b96f4609898e60cff7a2e76fec2d23431ee838aebc2186e85e6c643dd417af28217074b1b8cfe2af569d47eedfd559775cd920a3597a7529cfb7e0b701bab3db2351edb739b923e60c0f8f4b988d6264f05a176eb10c5254898728feef36a52929a3872c3d8eb5b4a12ef7fee7a20f2e7ab7eaf504ca34e8aac333884c4a3fbd59cc2db1d47004fa47af0f340fcfd9e564bea6ad830d8c86fc783110ac4ae31b4fd3e5974542bbb5eb387bbc5415ce7d21901e5cc72d4ed37382f866e99731107f6a2f7e0c557527ee0ffb017d28cecbeabc1b721e53fa7f1cddc4f92ee7ce30099934cbb8d190f6eda1bee41972e7396c39bd3eccd4d025f1b0477a9ead58585619cb28baa1499937ac47bdf7e77dd48c4cdbf086b701dbf653b2297a1d7e2f2a7a8f407999ce61b8d30529c7c3df0eceaebf7d6b505170604e937a04511597719bbea1d0c1b3ea8182fb4ae4778542dfe7f33d24942fd9f8a7c96ed460ca011a9ded8bb41b163aabe78ba10484575b2922e52f041193f3535891bef8f1dd50becdf13c97f1c7e7dd0828f471261359ea0843e7f7f731f2d84bb98b9a7e4522a67632c9013ab28b0fef227451db14163d5d330deb2c9d0ac36df071ed4e0d62ec03c05b95d5dd1456ed06d6ce9a8914e1a9f2af05b993634e5df8faf6b7afe2550f76bf17dcb85f24a8b5133ab06bed89db89262d7ded90f85f1c053d5342157ab032afaa68cef7a960bdfc33676974670fd3c6f1477e9d2855df557181b631e158bfc0ab23fc903736635a8b4d51d5ceef189b2c5b456dbcd18e67fdcccac65ac93b32e8b09a9865e68e67cc8ec64fcec9f562c25e2bcde3a95eeb34ef623edc9a6a360c2fd61ed53f0ca537d28512169bf8faadc29784ba894878a305d438273eb8a4ddb2c6c010062cec16219dda146e1fabfa458fefd80a28670ce91ba62ffccb84c312e9e6e77b2145f147fc23b2545d5a311a1374e394605f1e1d5477be49c812d4d4017d8de83f520081d62da8619a9900cf6f43e28b2643ae9f9233ad5d2586eabbe17507c1f9d2d0afc0182ff79d19939a030e57e1b5a9084a516254a09a2e7ab0ae4477d0a39d7a23c3d20659be384344c3dec499173fe287802a91860f6622ce122b526a53050c313040ece2980a0d792c123a35363c0c4bb9b79fc6c5b6d3968b75ad50f2e500376810e07386ef9a86ef09e47d4054c138fc1a659e65ef034287247ec5457fcda97dc7461208ad942d092a386fe95a467b79794e8d16d973e9e006e41c5354a2afd810832fbd363ee97ff2c99bab22834b38cf7df497967f291498a393cb6807d973a7b37eaa4ca2dec2cc50596c10f419389f63111055d449ad377f996a8db1a22237860898f6e5d5f3954c13f0167a1f3c2b3102c86dac9dce636fbc4bca767ed794e7717be7afbc63d711e989b118fb4a163a747f33ed885b7333c4d72fbf558770d6f4998c13b4f79d922183a8b3e3b40241d0c89186781c36246fd588b694a300044909fb7a7ac1caf056da4e323f1b91c4698b670532232aad8d17b518c75a9cd10b1e99f2208965ae92ad71ffcd3bbb77632bd64f0955a0d0bb664fe4fce1ef1720340662a2708b24146d3f975ba9c503cbc73258646d8968bf4c374803f7f530e17e3b4052ff3cac771110ec9f34f806b09ad16bc5210ce739e8c7dbacaf7a1819bf731d3dd009419bfc51f774bd93f57be3bb038c0d7866777f1657bf61f8635c823bcb9800eabda49ed2791438658ccc721992b16b16a30fd378489f9a76bf5bd6d5c6c0daef0d9bc62564e59c0ed894340f4c8a8c255e24c146f01998f62c6f02f141cb8b01dfb6432abdc73e554950e9731daa3c2da03f6235675d65c03fd119e53ace312b9c25d98b466352f4364c2fff769744a23abb504fcf38e207114c3a238cc5e81009ad8da49f7e56faf1daa8c2b59cf213f932dd6bf5c7be64c9f65da4309f3609ed6194c7b6e663037d0abf3745bf824792201fea501f272166b08defc5be4e24cafb38e36121aaa42ce1be151ebce2064a958dcd844915bf93fc59a368921e9f42a4d5301fa5d6850149afa6a1c709e62eb3d3b80f6108ad478aad0c4767556c6f4f17cbbd558b2f5f69de26c2b7c1e4fd3212e9514b37f194519030667bc25ec4ea5acd13a93f44290f0ad9f44ff0a14b0512018fc351d86e20855472ff20d278c189e03c5949c1e84fe8e2711425a33a25abf843ad3e8f97f24d1daaf7f35e811280a52437994a0fba0fb0047b777970b75043e135cf6b1d80d575613853dd1e2949dd05b35a4eb811a1c0963d95b77d11b5116f491b993ea08102af5d28d500042362cb95986607eaee5dbd33ee7d520751497f1f0e2f9584a408840e69b55aaf66b70488092f2e3c137066593d41a3bf996ce7b54925e28d08d642bde582a0ec9b5f16bb087a843281ae49fb5f9e0f93bd6a3efad3f98030653b7fd2015a211ede0d547dc958808bd9b28cd76c6ee088005d14fc1388041a6eb7b8bb60f156103328926db738cb8244b28a6e804cf7f247bbee2bc4aee46658d6ded4bbd0e2178db06b7dffd44cf030e45055e081b9c705b4f3b18f988e837b6531806a315cf4384c36daaf6fb0bb8e32bcfe69c5e35049d0ec9cba084158fc7dd460be4ed7c1a565ad2169d110547dae8c74e6552260fa47ccc70b406223b821a83d52d6d0e180bb24dabf8b0acacd0a2e8116301d4badf293e5d621a12b9035612c089640fac5e1f8beb5a96d39519a89f56aa2429d785cd6d10808cea3c5d9d1cdea19a00031ea4b948138ba087e3269d85453af40cf76756a58af0fba014364df9165ae4151f86a41c16187f2c36c78ec0ae414dfc39c7a1c406867fcef059cacdb40468989f661d0c14199d2cc7be282c775980837fd4342b4348ddabef6b8794c7130304752574610793099ba304c73194ac603999eab9b5b068d02d43bd7368e80c57373e983f9e24bf32a7c0e06fe7ed1cdc9a2d3edaff1c8fa38af2cd97af3413044325008baa46ec1c3d31e0a666d2806f0029838b81dd9a2822fc6a3e69e7037193abc45483d2f5fba5c94af2fe4afc7aa9663cf9a8c810a6794ad289422ee07bc264caa75ce0d002abb98681a4e7239859d667ca8ccbf343fd756c67c18572ee0ef2777a6d76042c1f0f03cd1a72718238aa4cbef73a4397b5497d8153a4192aec82dfa2288ed087a0f005e1e51b67f45ab8a07df7b9a1348967036312dc5dbd93fadeb4c4be9ddb1c01023b82fdeb4efa791a2cc7dc1ab5e024fa23946aa4196f3dabce1db124f98d16bd145ddb50a80998b003837e2e9fd364ec8d6b0cd163253617368a2824cbfe873b0bd89bac3c5545eb008f94d208e8df2c4bee9d1e917b9fd9cc795ddd8813e3f023f4d888fefd1c8d7025142a3557d20e8ee6ddcff61b1b16505d39ff47337af5c42038c92a919031aa1207df504ce8aec5a578279fba8a5cf3ef1a620ade1b6401213eebd2e99e1e3cf6ddd306f24205c97668a21d53f7919793c5027df4fe82e4dedefb564ea6eea8b9ab032173177f97c070a458a7b6aab6d9c39573a8d78a30ed9cf9595436c6dfdcffefae55ba89696ca666bc68c23f9e7346f57cfb5bd59d76ecd86e4585a2e22bf5fb3fab4f72f1e2d78ac5fa9aed3d1e3a9aa5b7283838e4114e7aa7805b244f3eba678796a84bbee9bcdf39042afb051875f77e1e27d8945503fd8db3c94c864df7d08e399c4e0c4ee73b1b9f8590aaed81cd4389221e69409c71a537fc671a8d527dcaa49dd25813b1d526aaf5067c9f9bd7ffdc622efb77cd5649fc292fce52a8fb58d361b140a646413e7c3850d4ffcb95c490dc27e77d1569c06761a95f1010374fb2699d3415bfc59018eb1b5115032203fca8639d3ade8c9c28db719c30a9da4947e47bfed866684bbf58ed3bdbc9508bf2e9027afded90fb5993d0b5728c321b4f575b85f125b737871bfac8edd5a41b0a1a0addf84655042fdaf4028994f60b4557084b6341f3871ee610e60c880e971adba5c87d3e326a09050491dfed26edf080243ee2fabf3f33c5bcde5c64dacb7d6f3abc2cc567612c7ce7df21081a1535d3775bd74e7a22e3d7ada177b9b0765c9eb2351bec5dab720ca9a9bd7f9785d1fdd191df8729e638ce230911cbac5ce4b3fafed32629d482b0a8167978808e562aa461f442122d85704b049ef38464969f0b0f799cff86257b19f325247303c4106f44052c7f36df470a9f6a0d31a235686d9af5a8502b3848da1dcc4a853d1780188b87ebfb9ac309b3ab0b2a9dd1111cce2738e053d87393c8e173187c0db0f7ded764bbc145e0cdc0b52018f55cb87232a46336f6c60652025e641920f9fb70dcd293911fc04641b6eecd037807d965430e1015f6148845554794b8627cc728a9c52536277b1a8bef0559bda3b987c637471ceadf2a5350d8091e593f8689a82200ea6ebfd7bc06e253e564367b2dc134010a2287a2deddc779e35378545babe55fc8ffe1e7b61819c2bdd8f0ade085cd0f3715e6335ffd180da14851b66ced04906b714e7ff1d00da0fb12f162793e9ab1c3f45698ca68a7511a03a31d39640191ae732fe523f0bce0c1a4d5dc8749813c2e249437f2523b7a45f374be7f059b8722a3e8f0a47c54dadebe21e9d613291c27c5fd7820a25d44c6575bcaade17c86ed3937af1102791db140d5d041eb009c1513ac8153077256b7489269908a1e4335664fbdffd3f2dae6935acaffd3addad6bd0075544aad21da2f3223a117280840aa256d84dbd4978257349e3fc3855e221ee28469501e17b2a729c3df42a044ef30a228eee5b0b7f8329e864c527e062ac304c5358e03b0028c13aa95fbcbabde5817c56c4634b031111931f45600bb1a148daa6dc22868dbfe1fa038ef51eaab5978c991e15b3829d71f3a519ff0c3096635b01b2414b4785ce0ff48d49f8e03402701409d28e1031552310dddc0efe992cbd4030b689ac7c04a889d3e84046e4451fd2fb9f45664527309648f8a22cdf9dcf9ef0d3e8bfc74060e08280537e8af684bcce39eb6b31b74980a44b3668f9612d06922d5ef0dae7aef4518583537b823dcf63a833917174c7a392d498f0ae8a9add240e67ea212de99caa55f5204f7d068a9e8dbb13df307b14ebb464134db9090b495011f2fd7cb2583ec642cd28704a7770f9ebadf90f919a8595f62a4be520550c5cfa264ade70bd7486df4c78ab484ec4f62e1e5513da46992244344e30fc51372d95b27664bea30143de86323229909dface35efb9b162889f375d3bd349171f8eedbc8b4e63379c7eb4b20e66a5213ccdef9ae8a82ad91b8f034d4026cf408e2180555433d438bf759cf44b40ead55e714b0da00c0ba67e3a4bafe74ea2992fd55651084698a6e148b9d897274e83e26ef4ef9c4dd425cd8c6a1dc384ec3c2c06ddd2cd59a8a188466decab33e3b0abf0ecede218035a1889f0425ae4134c6db4820c44cbdfb8dd61e2e35bbdfcac62e164cb0ab8566470b60a32f2b1fcbbfbb7724fa57fa3d74701c3d78472cd7dfcf62a3cc0538fc583e7548881b02349d4dce854a8174bcf74565b71211c39b205620387e617c615cf772481714a9b56965a081fdca64de3ef7a466cf92bf85c70e5ac86b5bb482a3b10b2de3c62f4e193e048bd1469c6c821c174a530834bf13912d2c8ce3283ff654ebb7d73d9850a7b660bb1356935bbf52e5a8a459e494491a3ffd679a525fd2f7a81ba9b4b468c95d2998d1628fe0d08dd5600af945c41a56d823edc2995c9a4d3c8f964f972e6f15771450c13cbbc391eb1b5eb52a25afb7746bf3c842d7e839ef9f1391e18d605fb2380dd808abdf1ac914ba6b5d4c4740b898343036eb8ac09cd159da21e30342d6528d40fba237ff65161de834f82050860083ae9338b09a3745bb79703a7f530f2da99bdf797f5d59192513bb7393c6a7f967c5c7814f8c516b2ab9c30a2f1e034dfc014fc0bc4566bb631f161fe27ab0dbf40a1b09f3647beb837095ebc5fff64a378d91924bca63b23722203651b7887e8235fa45a2b398c5430cdc30db0d21693395a1fb152fba5dbbb32c98020a6f32dada2ba3da9ac8e024c2a75c70ef196b434afee188cdf51526e2fb2cde7bed9adb9349489262e6d9feec5ef6ac80ea2e5cfd16e96324625c6c2a4a181b52071422f401720f5551eaf15aef9902e2f866540951bc76e62eecb49a0a9be1586a7ce855a309a60fa172f84ca2f846f8e42d4d614a63d959b63504e14af38ba2682a86f2f45659cc0f2f725fdb8f9c9255b37e0a1304ab5e78c537df69688ea474790aec8711180138657b2eb6362d25d82d1f192c483cdfd78cf658b3f41bd91ab0d584c5dcf839f2841de1f7db7634d3deedd55bb73c6682eff385cfedab3b438500020d0d0f6a03a23ec0dbc1726a26c583adf9be5c0606be721a0fbaf3c302851c4b4f6531f15bdf615cc1fc0f782c6b6467eb9411597306190999d61bdbdd7c28ff2994263f68d8fdcd73c3eab9334179a9c93f5fda7d5072b2923d5ad350138ebd9cb1d8bbb7e5ae983932e0ba421d99d8d37e1fd0304f3d281bf8836d46ac8cbc2309690db28f2d771f6a41f31720ecc336ec1f495020424fd3d00930d06396eaa092ef0324e5cbac744326f9dbadcf9f1fe7423c1cd4a6d23a1ec6a11ef7e66e1e0422257964e29d7aa332d53221829a9aeebf3c69ea02ea7b74a8bf27918033715d9c21ec6cc326019cacc9d4e1aa13a624f227b18b0725b21314d507e6ce9128a8970c848a0641a7129d9603b21ce10c0e89dfaf68e061901f6ce64fc4905e6dc1722345d777f9d76bfaf72d8d203f230a87d6a12dc499f55cdb8fac1de029dc7aa21ff6781d8f1771bd42fd7ff0e515c6ff2e010da92068afec0cd5b8e06e4a67660871c1e8fa172bcdd5ca35ca111596c14a08e9f8ab044bb71e145b0ed434fb37ab50710cf5551caedad15670f73baa7eb6b93488d434cdd05b31feab61772a1867d73e5f30400b39626b3103617fd4db21d7477788d21d9c67119579e4334982c8105de1fb01d301fee70727cdbc07dc3443b71b418536df5f741e68628382ff43e82fd46754f9b3bf9c5f869f6782c676cb6f9be15f3a7d4552307f10e18b3343d6b8108212296ae10f9ed591562ec81c409cbb2e96865fa69c1894a2a995b95fd5be3de67715171a2396d42cac9669176fb154b4cc3191cdaf78f3fe087a752ee5cedcdf7b202232872dc4860fc6a279bd65870d554d98115747e74dc8c2bf86403c0ed405e2ef88787535e3bd480284bd17355ba9f8c053baede4ac3ec05ac89366af68102068ac190d2f15b884ec054c7cdf0d7f4f474449f56378575ac6185775e17031dba4a42dca084f65b3b201e18ff93ed70b96d442a8c94826e279be70b042285fd7dad735f01a68063ee7dbb82c9380f03d58429612ac267e242f6ab86791b5e2c2cd921adc016322e04db741416fa9cfca388e5dbe7fada423096f00e43f9040bc9d08337e6a5164805e44f9d30e653a64c353d165ff56a8262287d20e410acd8aa7240b16aaf929ab4fec6581e28b9ca843b9ed86d5d9c79c2759774b6084c4ba9d7c11d8ac372ef4d66572f8325b1f62e61499907679bff9f5473bb6b10b9d0050208b619a586586f6bc763c6802e975c9ddd0082a95c1ec1dd4a3c5f3ea7c89849b2e50f8cd473a7afd3936f241d4cae05985a3a195528f7ef76a44ee0c3fa0d5f000ac9669c691d5f11794c210c82f2fd399a066edbdf9d0e5ceb981082538c36c5a70072ce66604c8514ab99a24f9afa9ae52155286ff5a0b011e53d31ac063b27e4f89cf0a3e8259fb78b18e2486ba5fd1aa6dd1dd59ffa9e416f2c3252e31352d4966bcd2788c19a0824e462bccb4cc9b45fd0c810fa2c4ad0e8ff547ee2e30d712761ac029d5ea8a3269e9715f8fb31b9c7d5882102ed6242e16c5bb80e211f94b4879c29ee7a96c5dfb175f67173e668315a51d5130ee5d0e8094e074e36a129ec959454025f62fe2338241b742c661cec16b53caddb9316cdbe6aefd849c64bc1584ad7a143c048a0875f50f5e08e9d826fc77e36327871fa96a2d2d26e19b67d624d2765be19aad62260dcdf3a0671c38e56d604906b2a57e2964aaa7fb6d447bcba0f716b4ec2047ba04f7eb00f24fe45d38fd774c3341fa062a66632a4e3eecfc6b38b096b4ffcacc5067499f048ba0f948e2870c6bd9651d2e4a8b5920b3b8fc255fec476fe9eba2a7077f7807229f513f4a73800efd5667028054ab359017c8fc31aa5c11a590909165ae6824c8653916babf320e86493cbfc6da1dca56435d631d400b97b2f6a60d8c3f24f73b741f87c46aff981b09fa03c0a3346e5d7cf72d8acd3d8a245231a941c1132742bea2c4f0fb9aa97d0bbd5dd0e4ea847279b704533f571577878751edfb8071ef5a078e189ba6fc3d9fbb39af94f50cd3668f45e27f48431a2885aa22ae64cab939a0fe5e599a0f385e8379963d23b03d40a3b2e3f0708264488df52306bb3fe6457ad4d4e6a2ce58d08002ba005d9ff","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
