<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8e43ba2bfe6c4f5f9d0e074a9fa8730c3f7d54a3cff75d2bce57fed4768a8ca59529d863d25805cdcb959c5d2ad3680c9bdc1d9f774f9fdc4c74672c564dfa6b7533c6318fca8f6e51f4e0e9b1546b17aeb96da7f77865a984db6032e22e66c9d6488927f673b8937226eb02860c9bdedefad4875c1474c494b2676bc7e862a7fa0e3c0168ae34ce1b5b911dc3238a8af66a450b2082e06d79f0b0a3080b9939e62a1c111e61e2fd9d500983d322bf95d0679b8306b38779181f58dd100cfda5ee0342ae7cf42ab71efa02b706303b2412915be576f7239b282583904aca400b79df43f3fd32b542770530f0925d04cfa817f117dbc132787336465f0a4079ca0513280517d3bc8fc7e2bedabdbc1ddb21bdd58a556c2b06abed2c5126460ce4354e33f513e069c130b4d33c6f79db7df35cd75a8e7d4fdeffdcaca30162a490db617f777a67cfbf58829266d1fc00c0091c313d77fd3602037e05ac71d6ff3ad5f7eb0806adba6b664ed755d2bc36a076d9976dd2f65787669345a9bbfdf17ee115c891f1915426cbc68f58966ef7e1216d448c6d29ecc522823261cdc86cbffb5e97b69f5786992925dc48f717dac5cb4ea854f8d4a57ccbbb6ac26578a87346a1511fa64b76389c728d93bd4fb90e1d82fcec326e47fd1a8fc9af635d5826053165d885d7525ef2f2f2fd36fbe38368d6424750b80867b8c3e06185a541a0747bfb8b15a7db0d1b6f7bb817808d0893d08b95cbb5cc74656c45218cab7edfacff15a2e6c98d2a3c905ce12254a15304df985e30f84aad4a812d1baa4e3e795c294909b7b27997952e67c8d46e5620b48ab41e38caa0f9e0a7f07f8b4cf76a66cb5679374aab1aea043d0d5530e66ecd4ef3937cd3ac1908b71562ef1010a9eb921169ccde7316deb7194bfbc0ee8ca7044a185385756b4a21bad7add04d14d0c42c6772604cd7d9d8551ca957b17bc12685086245dffc120364f962f3d0ded23d08c36fe70023c83f818a192112e9d4ad560d47a9f41b406196939bd377ce7321d542ec9d9a9e113fd13cd3338cab2e075b806c2c8138b625830b12ece1646bb290e245c386019dc21896fc266210dc85315cab40f0b63b331f423368cc9aeae60928e4e45e54a35258377eb71978741a6b6a8316306a48ab8a38c14125c53e519232ccf67c03b537f807cbd3b020f4dc64c48672d03f5e0aba391c329d1894ca329605fe88df6f02ac29232accf6e5706da9f9c687b704822110ea4e5afcf58149278c550972468e5193fd0e11df4c77afd43395b8b17847df295cd3d763932b65bdd6708c3334a1e4eab309a588fb8bd2d3452dae8087a3ed8584132eb4119d32c3a893eafb579ae9699f26f5d2bd4dd22ceb9b3dbfd96d7702c58899e6542873609695322d9f723ac43b690e4e6f9e0acddff3269674151188332bd626626f30049db5498a795d4ec9346b91cf3cdaa5965f71ab712b589e0d3d0695d8d1edf5f654b7f3b8993d874249066bd944bd1970925c897503e71555e7a5fc57e7dd379843f14d1b19ac6e54bd277063143411a5e279b4ad10c8689496a7af6107f96b0e313f67eaea6dc4175b65e600754eae55aebe4210b1f5daf271a0ca9f86d302db3524654f150ace41e97c23264af10c6e5a19954b8cbeed3f26f92736df9c2f49ca06ff875115c8bcc6f73b5cca3db1b044802cfcfcdf71beb9f653c53fa945770cc00c9db5d81ede31fdfed522e8b11ecb5f61bbeed6f6b910436f2ab7942f873042f71181ba48c1a4b6f15c96811fb9e33c02438ebaf684102bf51f1b1294635a060c5b0de1337f8790206b6ceea977716758f05ef8c5055254671f6ef4637d31680f55d79e045071cf0bf14687fec5510e792d9e6661878c3fa708c3948b4b35dace559e7391ff0d6e6f93dfbd639cd5c347d6c592647c15584bef593d07a2a94c1fa402a29814ebec7e5adb6071cd57164c972e6f88c2d2d27838407fdcb1c6e4b871f911430acd6aac048e89757d3e93333e4d4028c295b06c170cb8b102817b28dce301b682d663274deb062c5584a118c3b74978068d9b60176504ab3ad54ed6c5e561e420f26d479f023e1b587d8bd00b1bc130d177ebb8308857cfae9396ac6d6c176e12ccaa1d1a72e35d739ad1f946dee6d374cd38541a83ebf2e947a7bf5350680eaa15ab6f1b9ba66822f99d56bd13e2a40f84ad9efff10f28f41b21e908444886433ccc8e378cc7b1f4acc9dae89e080211996ab3d88766c2bab3524412c6fde6c4140e7d36102e28d911dffd12c7de40c916cefae03b37f876257c432b28861c81859ed976ea9feffe0a2c9af9a7afc7c2ecb7f0cf5d58757198faf2152635e21b7a14ae16a6c38fa9cc4929b17db49c6c4f16c78dc2f6c954de73c55e04014e6f139b4d7cfbe5a6e90eb401c22f51e0c26663031561d77be9bbaee36fa0fb70b5960f1d9b373893377fd7d0c7b64e7276125f921fd6d1a4cdcbb2e4436dc1ac70e32c5cde92922d3fdcfa2195a5719f4a69a821ad81a299d7e3fba81ecd5ce76f7bdeeb177120dba68fd32a47b91fa1519767b016e59e5aadf559fdefe40faee0ce4f875ba36f82951417bb4b9af28edea33a1c1f700b061ad8af5f0844927d0bc38dfb7fc2b15f0896ab1a0e00248c4ef8266d27c2d416c748276f3c6cfc8bbfe61d2dbb3fe06287f27f3609b51ef06899c04dd415bdb92a95fda0d0c225ff8fb429b7c6b20b3add4628ee617c22ffb67a4a2403056319493231a219cae632164328cb4388218d4a33654aa0949e38ec7f75a84af482d3032de6ccb456a48f685cff4a5d3d60e934b8a51c6d816d7d46cc8fa585352b7a952c83fc3894599d74491487badb6fe6cdc865d5da9f71683c992a1022d756004fa1bc09ea010839e54000b1cc9f1944301e30016e61780ba3aeb136c47e79503cb62bd7e1b250f7696ec5634553349a47c81a90a1ff652b3f0c391d060d27697e20f341fe30047754271915778097d26e694e29862b3399a432afdcf462b8b305484a311d214e4b6d1b2397eadc8a5a5672f63eb647cdc835feab352432e19cce2aeec92c4361e91993b2ad95ad054235ac9c07c8204c675cb5edc1cb07784e70d1ab55e8d57ade3e4c0f4040bf850bb96b985e536161f4a174122a436919dcab88e55326ef3a7808ca67c752b44681122d4c6e21c5b260c8e9a119bc219d48033880f857308c2d65946078e01e0972e240961a038f055298da637b362853eb2780d38f370953ab9251d00abfdec88c83e9772094f6417ff0d2fb9ff29b6ffbdf3335684ddbff137351bf39be2508bfc55d94c87fd3619244510ddf4c5ffb86da78f609a0271318b5770e0afbfcdbf49e15a910cec7358b657cd4621e96c4cfeefea38313be27652746b3b46588aac62e9e2a20d3a5b605d8f26f6be3abe52ea2ced5632049c79e3e3a80824b4f51763fa3a2a2b20908b7bc1358fae3145c2b5da638fa12a83962f3c22fba956fcb38cd135b842fd1eefecd9518c61c80c8289d6b349773c007fa618c29c550901ec92adb703958f3d912bb06bd1baf2017838d37c84d9a19be1ae38bedc25a3e8efcf5176c517ec60c5a69d9d8286fade71ead51d1ea58e9184f7954a8420de799ca0dbf7e6134bf110f8019878db43c667336f623c39f71c24cc87f4f36d244e3ca7d0642e044a6654c3eed44ad5f54e456cea261a11e5051c7c5df9725516f4e62027c49dee930bda49f4de043da2f0bde3a8103e41178155b5a780d97ed4715199abf3aac13174aaa238f1e1960d3785c7d7c615ca4b88d380a9eaa371afee0e24124d40b69413be05e11f471965b77b6dd682d1fc5a5c98cdb65f2f5f79f8c51da1dcebfb55ea9497a8777355b94fa91e73db35f26cd042e873fb4be0a902c6549e6bf859d7ff3115dd87986d0940674e6eb01ca029bf883f7d882758935be7322cc56b13281e87c10191e9577bd816b7616d1cb6c8fff6c768510034b15ff50ba5c259859fd2368ea4ae4482363e0e6077177a974f13708538b3147b2f64b19c4daf254dc2507eff8950596be83609ab1d79e087c2ff8597c83ef566381dc10c963301460e3f8bbfc3c513020a5abb6831099eb7187bf086661bf592ff413af1d58916755bc55fe56deab5acd5b453f06c64e02646aa4ebfac48c21f3293ab5596b4b9028f5036d27ab6fb4afcbe11c8db90a0c8000aa8df448de2e993f30af0447ad75b5f5062e4f615080053f0d03e9e0a651ee14a90be81d816a962c4f8ff63c58d199f6ee60ae110530f39589169fda7532f8cdd83e4fc96ce077faad4c8e05b0af58af2e8cf0c8acd7400df6695719f3688636d0c9b11cf1c56a1a82c72c968dc040fdc1e70e0d3e661201a8f2aa9328e72fa7f7ea83337ceb9dfdc3e7a3645b9446cf23b7931d454061af0d8a5459d26ebd03fd797685b0e17462eccf099d8da8fbe4e5dabbb78bd15aa7ed631f04b4a15f18c6a98fa20d990f1e9bb855e26ac3971112749f843ac05c411c10062f24cb0099b8ae3333281f795bce5454e3ff62b23abf30d34ee65216b477e8572838f1cdc929759498fcddea8c96ea63adf8158760b6a00fa515a2e269954ecb1615bed5c8d7f78d0fd702fd2ec4728ca3836664a246af8ea860bc9b0b30009b303db5b9f3e693c0952775a4a55cb24f4a33bec3f25ebeabf4f1b78aeba23b48439f187291ee72a1567b21b588349624ec22ccebf6c70c5a826c7a7b9a3a6f874edfd9482c2b35b3c7ef13ad2e4ef4b84ba40a21fd1fbaf67696954500357b85c360885a41eb19a204b466ce729fc9e52ebbfb1748d58f546ec4b327636c6f6caac8ba1589e7ab88f016b8a3234a2b34b2f18b8d39a436c12dcfea808ebcb5891fefefdeb76105265a75e4e0ee9878bedde2878664a3abc4c437c9752e01e14dbfa0f9b7e4458b8cd87dacfd70afd62d5f32824da33cf883dc544bea3b2052a4e353833bde90c7821c9e87cc20005f23d98019a416773a9c2b0754c3c8b5ae8a09a7101bff07a2a77466c9e42b77259984fd5b17ab30c49ac2b08487410558fbaa6262e4d456422f0de22d0fd30a98016afbf22b671330c84c1c5f9f11472cb55ff88c2f5a08eea3e3368f7184741c308d4f3e55983e5a9bb0857d0497249c10955eac0901f11b2322082dea6307631b05279c5e7bb4a3f602c00b811f12b784c7116c2a0185ebfc3d8ee5e31ff02cee18b3d3d70f499a2de2a81e2e359e628c1929841c67864d3c95a17fd9f78d38cce3784eb3106dbb6373ed837d14f670249e4c6b1ddad3d9d1597feec8d78f1f6591b0a5e6cfe8042ee395be0bbe084deff71e8efbefe8edfae450e5eab76ddb97ad9f9f4656698f9076d63c428207e185e898b2079fd12a063ac4f01abca9d74e0f4c054b0a2408ac8e574b269a8bc0650bf8abe1439a5cbbb63dc1cc258e4f2b97f2b095027f2884a5bb701f63a735d395f39ed4cbd64964086986ead0299f30b5f905117e91a1f970be810ccb80e540d7545fa460890db313a584fb317723b3c56b3ca9b9b25263ed00315f4e4403024c487d469aef2ee00db7d106d83d2778d36a40f7a626f6dccfb5d93974d991e0fdcf1a071fba3dfbc84f0ce7e936365dfd5bb48b2ffd8dfee8c41a586a38d22e84e56d852b47e625dc398376f3e338d77d622c0bccf79305d541e4118f6594d89aa34c17172158d51634ff283a3a66591a9b99a73741252339a74315f29e85de4eaa04f8936500ab2d3f9f0c1fc1338a2eda1b557f3a6dd93e1b503d83a17034c4d8567d6c9f8f4bfa29477fea6ceae66cc62592df33e1cac4ef8387e1cba06048dfcdc0cb5345d45862e05d07b141527697f42ca79af859806205713aba30f76d479b7a41348c72c043dc42aca197924e1b9b970227c94dcf60afc969a5a598f6736b558edf72ddba51db09fa879d22add39b15a3fdb4efc70dee2d2976f72a0a18f9e030161aefdeb4d5d58bafedc20c0b1c8b8156eac2ed29df404d7d487b09e8dfa2b89f2e21780b4778a7cbd94ed1ce39be39e934cd8d728dc6cbfbaa1a62f6855ac0ae0505015eb2fc5f4569757c2c176b6b59c6dcf42d9e8473af0ab430940f6c9ae4121f1b3bf88a190f898fb589ac7fbe8b9124ae04ddf2608b0431bd695bcadf86970baade69d5af2eda0cec2ce13752f97d1a87039573dcd5559da36a8709bd695b4e70e5c98917b72156074186828e32ddca88475acfc9b3e86b86e780c1973d338f73e4882d0aeb4700172b07f852fb89b523204fa262e53b236e4201aae159abe3cec7ea18d0c72053ac899b50d3745032c0de533554dd166ed66ddde6387db09441b8f2168fffc374823bc3dd9a5d79c431fd2b598d72f85b35ea7ca1e6bdfb316246f7c1782c810b5e83a6aaed894077d5fb9be5a8b6b1f2ea9e25168a507c3a9655b5b5a26e7a292c5e038e7ed1d65435cd94696f571f807c0bf0590857652d1b68fd335d62edd9cfa02f8fb3c8995eb708eae47ecd089c886806305853facf0a5604733a170c89f23a82cb63bf2bba3ffab53a82bd300271aaecbc031ff4e589ec40fed34b8fb9f8f0b710edb0a13b2771c885767281b25477f6624c96c9453a0ad59fc44a30d7d0b71449aefd1a6d2f8ebfd16ad10fe947d3828fd42dc9f59a7cc7342265a9cf1ea65f26a9cb1f441a3ec7c1be85ab23e9f73261e9ae2cc30de98a72202241cd74a8fb67e6e3da82615b32f73f1a9cb38fcebb35de0b615432a80240a5f82c398048aecb19d52b721ada7b447d89ab0b9e6cfe344d3fbed11195578de264114b1b831e1b4d23d47246fb225bf92c9c8a255c0a8887224293469aea7a5f69f9f73104d9f68e0217ea6a1e7cdb93fb84de1f821a52ea2635ac540c5a31a0ad3f3a0f59e88f48a2611ffabd39159a6ccc0a56da53c4c5518cc74ad8326a938e6c110d91a10fa83c7b64a53534813caa043c823cbc06ddf42fcd4776b0844dbfbf8fb604c1d4641682ab39e564cf04f91ca9b40b0eec3ddc8327f128f1d5dd852149db8e878a58f1afd25e6ca72628693ad2c1be0038c1865dc5d06f5ce8bfde6b64c867586e883726c5701c4ca49641856abc1214bb075ff702118229602614fef40925451f2f0d6947c10e19864960392d109d7b76893123bcac041c9679cd5c20eb4496a8607e1af8ecca37680d190ec197ed8d4570f5bfad740b5e40bed8e9762936b7bcf1e877a35ccc3966f227fcdd5497d3503c9f804afc76ec213d207db3a6a34ba200651347440e00aef66be0d5b5166278597eec718ab70366553e77790f9f2170f5cb0f049afba831dacc23a1bc88f9778a55f8794a2c6a0355c1c0c44eca61ee3984beba69f5a6cd18376994cd12e4b462d93146c1dc00fceb89214412154408bd220e1a40dcd4b520be143fb04fac7c2dc98e897a3846c179eb2ba123b1c94e04691a5e0786534d2352e4e672e1380323dce513f4b357a65d34fc07b0cb63d1e408207ee243799159bafcb706416830d25ed015c809dee524432920045945daf486fca06521a6bb5e2d442fb904b2fc2d6014b26828ab481324b8c7100d766ec1067119492c80d8ea3157f41bccc929db94b82ef8e91717dcfadae30c1406b306eb2c7137d2c15bc54871f9882a92477f5a3045c8d00ad9611d2ae1209eeaf053860edf5f6929550520d4f0fbc21fa65e97f23f42c07dcaa52bf377da3f0d9c1947cf5a778e0578d3345e8995951d5bb2029fd3b81cc41d6b585fb1cf8bf698de42a1e05f084c2fad12d78710dd00295ffc982b35f56be475200bdaaa83cb2b7ec902eab5c6ea3c8b7b519d53addacc39a552897475456ffad4fe1b00847018b3cf1e431c87e63f189276c361257fcd3d04ae48ce7feea55844933987064300dfff7f4910f81299a57d7bedba34a27dc3b0f37d369740cae28926bc2be1eee15d023a215e3dfd291c09c277577afeec60086ca23aa923e3559e27118031cf04d6fe6d655f0b1bb33f85134e71662a1854d23865d371c2fe1f907a7ad19407dde6c81567039dd553c58bf3c9033d04f8662271bed80c6702a543e702963db26b938d4e10bd50df131489789a594ce0d7e589c2eef74a8dd7b79a9d585ce2cd7db757fad04c499d1b70ae8f9dd96d54ee2139b4ec8b8edf3eea78cffb45fc2ddf2162f41a9d8614ef12c151c5aa030d18f1582b7f8308b683242326aa34ec5ea3b3cc54e7d45ed2568f634406c445938e2223f840f97493a7fbce1d382b4b262c29745680cb8ad8c6512904a22c3e5544adf80bd77aa1d0127ba30a5e0d58fe37f7b23d01aa0174f7b0b286048bff2f25606ad072cc737d610e47ff85ab076a9010442e7c3c8d6b89f4810970356fe9d7bcbc5d7df948328214d992cd5b2cd033464eccf7afb86300205d3bb713899ef73c2d759e093b243e8643ab53aab5fa49fc105216f4cceb51012dbafe733b9a883075db4673aef01b99e5119cf6cb3a6327641e179664455f2500e9e7892323a7d116a32823b707be7cf0f630c11c420ebfab7742f4ad4fc9c358208c888d92b86c775d2a800e1c52e90237bbd5b7883289bbb71e00d8536443697c783dd29e3629c7722ae5f2a2717b0e1d2d2da9d230f86f6334d103034cce8f7c5f2722977aff97e97bbb11484a792069e6773a6c423bbb1c8041ebe8282bc8a92a307306348a55546a9d68b1e8718f54c1fe2dea022c8fb511f6d421571baf1267cdec1693b88c735b17bb64b6a342b991b8effbb15cd0abd1f7845a4aedac00352126d68cd5d496f0aa9a0c4b26cc7c8d853dc550ea8bed56818c241da9b0e60390fa8657af23b712d561c9b5ce17b27e112eac70c2d7579407d8e7c581e5cc40b37884700072d0da99bbeb17bae7f331c408768950f816bb836c9ea5dc97fa3a53185ace8e1f9173cefba1647732d0d13729876d93954d5020d74eb8fa0550efa01089b29bdf8a198dbd829b242e04f4b18d0f3533b203087fa63901c64fe00f465769975c490b7f9a63cae9c84ac0b290831c9456a04710a75d14a237a980a18aae522e831938521710ee7a47d68e1c9fc2c76214c9e555f3ffcf8c05763ba72fb2d19fab314b5d1a1dbead42563e1e51cdf3f712c2ffa7b86421a1e03cae81114df05b54c4ec5655111815f06ec4c086a589f5c606342600a1f2b70c46f0d04577d3818aa8d8c116683d36e496e5c7f558b9a486e6723fe282fc10685ecca14548fd0decc7db5f1b9df80060bfe00fbe68e037f3003c8e6712113b7cba7798706b75040793ff23380417e3c88e62d0023a1a2944fb2f16c791509fd504669c4433e42bf1cbb1e253c593cad2db1ba165e8ba22f3026fb3b9e55506431e62191e009f375942813ab118d093cfade0be7e27ddc29dfe652cffbea44720d97694204c2f361dfb6d7a422ac258efd381fca28506f1c515d5251db435d076eeaab148a7035a370e69a0deacc2649465d087e42f4244bca0f39fcfc4dde5e6f171c0f620ff7431d38c2028f425524d03476406d4b9f717b2fdec020afff767dcf5e4002b2f976effdac43a58f4543bbe0f3160b87a36cb721e8501428de1e8a10364558881e324afab28696aa84964e5b8db84a8f501536a0a12f38a145623d81839fbdbab104817282600c304ede71b8ac09f6e8ba9595767c7b3150c311f9d32bf29aa3daae60ff97fc07d13925b7870425eb8f7f4b8254eecf131289a5a6e968d975e73da84ca473692c6f5943666c57ba46a480dfaca9a1a81abd8826527c874fdb7f46fade7fe30d3dac0b6b1caeb9b9c3747ef9403d6d30bc4946e518148def67cc2932751b6e3513fcdf4410becf877761eca63bc3f3acaed26734a04f9a71004a6814e1ee1ddbf769b02df6f5a1ec4f415c5cb6920e3d4df650367b593a78caa93dbd8a2ddc34cf1f1a7f645b862e7469af3184267ab6faa0cf192a8eab0d33dca994c0262f0cc04a8e4f77affeb08bc0a541f36365c55ee62c307345e7466e2adc030b0a479bb57ac73f28d7b193cf133a4dfce1d16b5b8e544c0bf138d3abe8435ede467ac095a4e791fd9cfc7e5d0fc85aec43f6e924a11de81ee0707ee6b2343501a287a160c33db569d36dd9b6e984ca4df3a919785829115bae8d14fe51972f5ade5d294ec0cb71452376c4d8c183de4e55876c8a894508ca51aac4ebf836c2c1540fda47e170692e991e502d727e49bf6b410f0a5e79117a0e70339a84bd61bad4dd2325c0498e94f2679f952d7340a3cd343c991da8bfebc5acb55656492aa9883b1d7178de26b8b4f36e4b401d1a854cb38e6193c7d1cd7374724597f1b5a16daacbfa8354549b80bf46756c08e5a6e8b4d748b2a4b2e9c8698040718a7b8522b9a99f73328b3fb9d5a633404d0f460eaf47c65798d04a2593833db7d2a89a011c0293a284d706a808a1fd05fbd4306082ae621b18642c0b775e8bb7739cd42d607b7d18c5f91d558ccc6d48de19fa885501d384c4b4770c38099caf04b51ab5c24afa159df460a29533cc47fe6a26d818857a1cadcc3b54acdad37287579c336d846871f3582a15a67d6886961d1b74b878e1e3b297119a368da57a5406db4d8a3719d4ca525574071dda7d6573d2504f3f76480dab40416ad0f1fd088c33a8cbba95ac7eb246a79d6995760a1a9c486a207b68a8ae6efd25a16d123e5c82d7092c183bd90c6545a4a7647a8aab820d087232ac0a13af8ffd45e2b8facde8d7300cde5ddd3b4cce4e1d9377b7f0557c962998f305b3513197db714c1234efa8745a26722d9917618228d36415375a9cf9fab32b90b7af88d644cd25c0e7cb0e0c724318ecdd70fc3f8f845e6f2ee1973f5fbcb2ddf0af532b83ebfe8e28ebf7b2e0e14b01a471b91e684707d97520037fabd84c46e7a06739dba5b002207c0dc7ae0840e24ce172475ae87adddda920c72ec89e6f599e651a645a3dc9f358d2251a33542d23fd6c38f7c46f023661cd8c4531285b4ac36fdf219f70dcab985de4853115dbf54f519b8bb65dc1a2ba8a146e030e39865e75c540f8eda2f9308807868e7818ce544531c90c7675dece387bfcc7d2734485df3ae2d4560d9a741d671547d26d2e54300536e34bea520fe0b77476d6c38b7d58eece15dbd4b57d1653b9fe06d3e00e7afe231c94ce962d523e94eb63d3f67c14c0cfba76db2f7d501d00af8b802c048c45320a9b76e090ae64c640f8c51a6dcc571102c2fb6c98b38d1538060137eafc21d00ca6ff470549f0f405bf02ab663490f757cad4aeaff0df18bd810591389946743081a20d122fc3c6e8906a164313bed3830dfb84dbb3896844af3d25ac1b28ab5296d42031e54675848487ff1ccb90b49c67a7afac652978ccd89be60df898e283734ce6eabbe943e478f2e183f1db29caa2f67eb395b3c8e505d38616280a6b8139c59186829bee494c25710bc3bf036de4cb8beba0d67fa8eb10b3593ec1b3921927f6e588522f08eb189e747100eda4a20f07c68dab15b771ada1eff602ac7a5e65568293a4afa9c95412a97f95abb1fd173edaa4e9f11d52d00302d57e622b15639f67bc3adf56277201d76df200c3aa38c297356f9ee3dc3408345d31aafa60a886771c22fdce9d3fadd682ff97a97cbb4d18dafa97a8672d2973f455469ef1e04b88610761f769fe6d428ffb050d1f8f54917d433d6c45f093c4fe6a74ca60c2c7ecfb9124e4f8bc7169ad6f53e9bbef22802daca6a9b770409436083682eaa9682ee794f93be5346a74613bfb2ae145cd123f3f50294b9d1d99268b7234c6eb0ed10a0a5ac91c5b5166a43d540089a14ca2a16369b0512d17e8587ba9ba979d845d727d8a55273a6ab22d2b701b43c7dbebff9934612cccd6c22c4a5e34de0ed197f48ba040e09cebb5d977d8eeabd76de257e65b3ab0904f7c2c9470b0bdf37fbb44cbd18d7857b447e4c58f9aecf3d0b5ee48d025b714f2d640fd31260ad09120c54d39d2bb923412a9369d50678effa63c107ff423f07f47b7ae9278c119a4db7d9e2db76c59efab8361135abad4648b6c2fb46dd7e88a80d739852b900cb51deb73b39c9d659a6fbe834f2ef6054967ca80158e6f66e7fd18d13080b07a9d4a30cfccf14e540c0dc26c39db2cf0a949e22a7b0dce3065b467d18843133f06d66a8348b954668c7ee4c3bc7a2ba077a55cc20c558e7609487b57d8c1aec014b1450f64099fed7bf03e48376aed740ffb478a0f9e716dbac56bf4dd3468b4aa2fa543e3325019298f929e98b9ab81dc2474975b54aa07357c71110e1316be57ad8591b38d6aa9892ab41a146944de8937954256591e4334b8cab994e7c06d29b57b732de1ea8a9d24520e82586285805d83d74633b94c8da97a64b9dbcfe69d2860bda946d0333f7cd25e762d2e1306a5f6a22b411dc4bd3869069d8aa582179dd24beba5471bdba8be6ee98a94082ca84044051a4b61dfff77d3c130e4c12f7dad97e6aa397ff3d3d34a1bd142805e154aa15a2c6d9ae570790af5d64116c2d7035aa375e2df8cf791e5f623583a521732abd97a80aef54a0e3011e8ad2d7875660e7d945bac13bb7f311cd9f07387d75cca5e26cb999ff3e2d3b8fec7998213825b6d8fb3037da77cfcb65d953cf20702cb3d83cba8886b8b9d7dae84cc4fc9d23db4a23fbbd025fbd3910a0e1700f312142fd0e10a9f3f9511b4df01e53a7c61bbcd9371838b159f0b09b87c0954ae6d5071c43ceac35e2b8b95d3f51f995141e86b4c2619863e468c9d73f9a6cf9661e14c65b98433c751e742c44ae1540fa6ff922358032095b719139be4479577403cded571be19c282b013782500110621848bf0bcb18296ab8a83ea1d74031e7290e91f0eef169d47f6862f46ada1b4b127c369d31a65865ae038327580627a6be0ccdeadaf93f2410046022b9e07b367f778a6c07ae79743da7c11bc6d6802fda681b3b534c954abc47030e66fa87acaa18f49fe32d652a00dddad22b5605879d6cfe01ecc1b09fbb639ff5106eeefb72d8d69205b8cf57845526cf7cd11d16d866ba7b3ef2c21af6b4b0063f1581c8dad73a36e472e4acbe4fb0ffd0f0e88792b2bfa2875b8a56725b1095f07df0b41c0da43e8c83218c4a997d3a2b67574171b9c3adbe326ef52aade5906d23baabce158d718d241dd0f65130623be5d11c06f8c592ca37d2400e7bf4724b57421e02283eead108e3a792e1ecbfce6d5b62194f21b59351d1cd8d334d129363f21ec38b44662582b4a573224bb7ae01f6b9cfadb90741bc92f4c1ba1f9536d1ef6cf30b4895269e61c97367d0d56bb36abef24b1aa11fde8576067518f74e263724f95c695cab6250e63a91603ca23cefe2a80ec84efa885cb906c37f0c1f4f1d09e42fa40b780a0213cb0a45d4a52433db606804f7ce067b5d58a99f6123dbf48f6c5b9e494466995a0f93600b7d23e0bd88645ff07115e0d2b85bf7cd9d9d8cf0cfa7623b1d61fb8027930d0cb3a37aeb6c2f3a4f0a8af8396be97f06f065d1f5401105f54d7bc2303029bebb7030c2f81993252f27b191fdb745af95ae77419dcc7f816dad1b09c2e76c2c27c2a0f2742f0ff8b27006b81c4f4baf4f752bc78410a647bcb415c118ff7d08c7813295ec292ca24cb4ad3b7a4783c2a050ed71e93171ae8c1aa8e1b4b95f3e36c2b32a315fac82253083a7d0361861886f3ac6cf2b2564c82368999c57c5a83ccbb920adbd9720ab7dcf615a4743136140d2fbdbf8175834c931eecb03091e11313ef0611958bcc0de5d3cfba03a0ceadae10b50964dcb63c1ce56fad1a74f0c2a9a65831860e205db75c1c16c6e2b07b35baf3609a8e714a78c7e0efc07257734667f694a741138f15c9bbfe1589b7d1251b2360ef58bc80d2270438e33916d639dff38895d8bb76d0f38647020a51c72f89094c1a55cc7876226203cd53ce3076bb4b12f5422a7144798b099c8bad3320b6cba9398c4a57aafdf0aec605d57c385f611624d4695bfb707bf8250a4387ec6e80d45695d2a1ee9ff45f2e5029720428fe01fc5518f1b21e3330f56a6246afcbea273302ccc949ccfd4cc33d4e7cc39a6b0e7e458d7d83c9e1bcb31fb18845c6932b32e34633e9df2bcae66bdd1cc005147f158e780f80da6935cde1fbdae2467465f33aca41786dbbf82be07195a2209f77cc0609e4ce8bdabf4c0829d9c813d544f19e1a14966f8ef2355c3b76a7155378a4d2d1e58311ce2225e0710f8b689e81d6eec8b35a2b7cabe64de1d143a2b296f0d637c8acbcd6dfc14f3cb6ad0cbe10ba75340aa201cb2dca6dfa01a2650cf31888e57c783d56e8c0e2be008ce764108d6c3f8938374d6a6594373b5b3063a7ba12a75cd531915d43801ace04eb9a4dac877fa489232f58aaf22e231545cb3995b0a6729e8bc0723d580cc6f9afbbd40e5af568b22e1bc4aa18cff536c9a0628815bc60b253ba0f47eb84992e28b77d59a11f7b046359f7b6e6f696890e771def4ec402d097f4091a2e7424d851836b86b1135df1320e27d5ae46f6ed178881d1bf134a886d17f234b42916ee172d4152f1eadcf6a116a5361fed0edb055678f43d35e4572f257b775c235e5f06424df2e71754802e41399a6dff2a3790b4cb59ea9afd82d2681ca5a67940cffa4e4910ba45c6c7944d30e59976b631ac0a25018abee1e69735412e93b7cacddbc8e9400e2be22a9dd4a2c1f16b04628df771f6bce69ec8c512974f537908be587b288d48940694fa986dc4593a901c1b1af1d0e1faf1558268e1e724385c802840ccdbebe9efc7aac76f86e1c0283f92f92b0d5aab8333a1d828366606f7875bfd7afa95b3840bd77c1de5d51146c189e093e4a394cc790af98fc4f272ed9767a7119cfd9c7561817a5ac00be21635a09a6d764a1a97195a369565c79ecc72ce496ae8a21e1348a56d02be70e5b16f320b5ab4c4293f58fa991c5c95aafa542b881aee63752ee2b23d0872c2e8e8e5cbe75a8e5c4d08e016e22259803fc87d7dbf97eb9de8b6e38bef251528fdbda8242c1a15bd908812f334f087d5faf099b0c7866423b0fd3e45a0c02717a53246a0fafa7c60f1211a1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
