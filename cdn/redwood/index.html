<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eeec004b4b5513bbeec8c64355e61a60f176cb21d4e07a9ad61f06336785105793d373fbdbbe583be64d7372353a633599079814d312d886366b1dba9cf944268a6ac693a646ede9ababc2e90a6b22e9977340e115af3a7d7f1b06e0809cc084110f90d88b0d6b187198e9e28a548510263381c28de41537c9f97c0482228da883fbacd7e93763b31e907e31662d8535d46e98b534bafc57dbf88bc7905f50442e306c42eaef503cce9110a7b32fceb332c7dc4cc5bf331d1bb8dd70ef405019510c04f713b466b62d26a2076ef7926ce61e0576369b66087ddff7c790a69f5ad8c7238017179e293c1e81947864349959bd5fd1aa03ca8c3bfa5ea792dee4066c007912d754d13da9036f9040109e6dbb4b59c48c51e2eeff40beed4f28b35e1fabb5b9d22e704b9152788d5c1969e49b1b081e8ccd8916d97710cf0b3619274f6675b91692c2c67efc0ddad428bdedf0788329a6f24a9d009eabbbfedc29b72b7bbfa205db7aeda7b6812c9946a6d8c37ec6113f117f45c7a838accb9414ea37066287e5ffcd45e12a22b61d588cda8b40adacd124562fcc3fc56d4c1fb030c3b70b21fdb0a038edfb2424a2aa7c2bdbdf9b00ec21d0251653424518f2688e69192b7500f992b7db3fcbdb9caec96df2bb79847b6bf8ebd2536ea51e409d07fd5135aae7128ec2588b3abe0eddfe6a646671805ed6ed07431aa78a6afe02aee8e9441eb5c0b1ed3c409d1faf22955bfd4d6abf2da247e9d228a29e0770ac995c014670e411f0a1b051da62882cdab9aaf95192b1eb28e690b61ee3612b98b89fd50e9dc59a214b4747f55bac90d6b8744e4ef3e5765ac6ee8f19e07e32e57ac79e6bf6099025b99126c386daea0a3e1493f10f7f39fab34aa5a8a29174677e30a31447915968169a5e97203ad025db47d032d05afda71634d820eb0765df9c4cf7799aa4dd3b0ad70adccae4f67cb6478d7662525d0f140a35459ba5b14b6a386cb1d4de4b8bd2cdc09d5790ea4254ed15859ef1166fee42b5406e7802e7ff5ed7bc4ffad3d5e7da7a24f0f13a00a50e3af85a6bf3cecd99c440467907bb42783a3fec5bfee4fb7cb63dec3fa556057b659cd711ec25d834516287870a3b0047bddd88472dc3783516f4368da069c94fafb6c85829a1a64f75b41a0d47b0a3ea332a966f11411d7e83a75539b5993950f6aa7c3eef933016c7f2013ce5363a13a1b6a4d4dc0f1699438895973f414ad81cd00d86e081213e8be27c413cc5756f1390095cfc39e5a2b92506a236299348f06aac427f89a50759b31daecef505370d26f3a67b2b3aa76b0b835a4fe06d9eae8644109e717fccf9b8015a05164b63034874b4b0c5dbd1cc392a91938e9547be629f28e07efc8d2e368caba5e2f168b998c615175b4d49ff3c030de34b6d09149bfd612664032755b385a025a7288d18b03bdc3b929ed3d2f6f3fecf0cfc2248a277db6b752a1b23fe994a7f087f1997e94537cfe49784f9cdbe82d3d55b810ba00810db978d0a8ec99187a7552372386ac7a92cb6ac7063a4c70802a70eea06ab7a9cf9b2c63a6e9cc388c284fbe6dbc3f6115c059e0c85f914182551a76bfc2761f5e6791b310b209fa0d510c3b17a646c686fe120d077adb2ca77a85c53d112eaeb456fd946693762baf5e7b04a8d088a566456ffd567b2d8ba917871434bb4ddf91c51604dd2e9cdcd6c31217a1b9f010cc0190e663cb0a6809f0a3664aa15435d3f5e4f3e448747b4468aed884647c1faa90ff6c9a1d5db8346bce2fc094e057c2a782ec7f76869b56597612e64892d540275d023615ec9ea0ba0a651dd08172e92d07d494fe81457b17dfaa89754ce4bb604453320c0200bb8fb1edd6621fe28ce7694bc46e9f618675d8c67c6e5a63677de0e6d1e62f1b9ecbb55968e4caed23bedf68a2de0367d3a5e434e19c324df6f7ef79a46efa1f7b711297a230dc84b343bf9df85e7e1095334cf829aee7c6cb03ce04d37c5b3d57b3b381f5595bc956d3846f052d3fe3895cf5c00745ec4a4a783929a918f06879bba878fae47b1a1e46c0e3b4ad551cad7a49185cafa259ba40139f81c4a336c06230d8bf19e5034164fb946b6969107ad2b9cc9cf74c886e41a36d09d9b5d6562d7f742ffc331e03dcf01b03facbcb783f44ae83f3ee02ed6736dc758ce64f06b41fa40af53e995d577d0dc436be0e8c84e514f3332fe196814b1af1a7c659d4f00f748ef56c3ea5c1786f2231d7b0dd83fa044af4fd7de08be35100a60a8ccf3001a0c67262b911e5691e015816e0536f2c0cd3e8a7b46946030b18c999ee7f8d99cd2eaa47b9a3f91942aa6aa093b66cbf248a875640bcfebf91451d1ef7cc377c7dad9197102e53f2c85d9cf09bc2520a2ebf5d2351cdf55d24ee815385d5797de42c5809b5838f8c918952080aa6867942370877bcf8f43d5f4639bd1fd1f5a09cf5205e9ce16d2f6bd6b0307b9e19a0c8d60f49d9284304fcf618a50c1877da651b164153c6087f1bff384214d91fe882e4cc30b9444962894e0bb541a06b9be234917e726d11f1a513740b04436b71b2d53a41a6bfbd93bd34dd9551034838665cbd72914bb0a6b819d5b924bfd8dac7bab15e7236fa333d95782a01ccb8fa63682436c9103da768649bf90b7bbae39174ce80d5e53e9c90633a6b6965353c45c08914175b2eddd47d1743c1468f3df8f3463c118cf22bc50815d2f84585c20e5e7272e867ac8d349285f09eb11b82465f586d1756b009e6930d788ea270f09f0a3d380abdaf5aa79dc0653c4517f50ed60497b5c47fa7f8131bf46af54ce00a3f648b931b14ed91e2efef8a1b60fccfa783c4e634d3f4224581fc53bcdfb1e70c54fee2ae5c1d7aef97bb54363ad1b8299ee8b9a65c4f3f48dfa62c89b34c498e6a212cd26fcd662678c9281535aa46bf647c443cf84ca3465a0be519f2b876d9cbd19348888774f8632bef0a27fa16286ee630b21ee0fc9594be5710f05e229947680504695d4b93993ba8e9e5ffebb91ac23a7e104e973331d0738bccf78ad28dc3696490c6282ea4877e1a31152713167135c57125637f5e38d898e4988d8e17895fade9d8ed63d757318b90644644fb6ad2f8062043367eb53d4caa1c880f965bc6c87aa3400e60d6be3fce1cf6575609efb976ae877011fd0ec35da5b85cf816e8a4f9cd790c802db475f78e67066df8e4474e0b83e346a233272c47e4e1569132e72adb64b4cecf6ea92640136b5d91524a9c011c4cecb7a447337ca5563e30dc4df0b48fb5969981630626e885c93728843757c40565e3e742d7dfacf52c3e4702c59856ce2e230b4c311606297eb25a784774e008afa30700c40fedbd92371fb62e3a5c0e337ca82b39048eb7b85f86b754834839ac5d0a672a3c8ec4c6e7ae9e634366995a68e5c8671938c50b18520ccc21590c08cd73c813311aafb32a7286cc8c3bc8683597a61b716b49dbcb603546dc2af6d90dd52e12ad787b86225f4c1633dc9d3ff5d30a323469852eb236edd17b9b972b95ebd5e491fc51150597b4a91143d3d868e72d3305b4857ea7d97eecac637ffc242aca008b03b2690d7e49094a915971fe7c4630aa05fc4de1119d17f96cfcadc83b4725f5d61962ab89cecfadf80824f34f993716063f58f9805c2793b06f5cb614b658fe7ae9248a74d0fea13c0edf2fd504d7c05e929c77521c106725df95e09eaa6ceccb75d5fd88c6045bfac987a2f389a45d25b9a5bd07578300371f01f451b4a6d59597256aa522360063fabf1d58b8ae563afebc53cbdcd4d70e79fef012950cb6b6845a795aa18ce1e6a4c56dda3d3d4b81a13e6bb4eb7f1ec6d0cc1fe95fb8deb40bc2da396500035fe4a068abdb241aeec44ef2b9940eee6986b94fb376d44d77aa1c9bc3ce42961c0b3661b8c8140d46b3885e7cd3c3f821520f37b1d9462a9a80fbd869db4512b1bcbc60081baef88210834fc5259aca638d6b006511a3b2fc2da2e91ab0c61bfd52e3367b8b43ea5e57a4525a229f748322723799518e9829528e768ce06d050c75618fd3f175fc131fb064a48d690f372466a2ad6997f300c02ef09ce5022ca7cd8185f10362c8c79696ea87cbc09eb0b9b6516da595a08f455445ba20efc591f484129f796eac1edf94bf228bd37ac233176a8dbb9e806d960cddb22557bfc740d80dba8da66b9e9a56255bfbda6f0cab9e1ab4ef3ab0629e284ff6885a1c12349dae491bf51cb1b13361161729296d21dc83d7285acc0da3ae665b1cd3b75440f301176a2ac33b629d53402a3ed778386d470403703b9e516b30b19ab91536f570268f97cc8f41dbae4e9e0b280af3fe345a2c7eb0d12c7752ba71f931a457e6e6f7e492471bcc1c67d02ea1ac35c456a267f64dd4e2230057c136042f37f3df41c71e7fb3234c6f8b894a89884f9dd162ca52226f1684e888dbddfb9a7156ad635f951992acbdf6cd54095fde78a6cf3d7a2070d7f62b8a976c40648d2a76c1afac35f9d96eed5d4c663c07791375a89ff1c65d6fa61ac2834474691f0f82a225aec9de9a22f6191de0a545fad5eebf875fbe92fc602afd7585a2d126c6502ee3fd5417e181a25161c09fceba3e8683621252e97ee5e067dcc94eb36270934bba06e3cf0fc2ebfb0f7526c66fb0491d921704bb12a68b39b6f7280d26627896b74ded60ed1680c925a883b7855faacf749ebf1d88c305a957e696d264f5c6ce5982b879aa7fa7ce27a9c021b19b55fb1bbf5ca7502dfad2a08e5cbba4eda414eaa33142feccf53c8f93fd7d86f0e182db67c9e9fda40ded18165ec9fb446260630874b056013bf39a3f81b6eec64bf41ff32ca87c3922713954b124900d21f6c5eedb636041650df0c895b3f76e5bbb5e3ca1d62f6ce7923e95efee9ae67afee51bf10146227525289b6d05145dcacb0721a427ab60516753fb5953c9011ad9d74e3267a561e50bea678933b673a5abe120e3434c2fb4228933ba46fea9429f3f6fa664d1271990ced5c16950faa4e7452bdda4bef293ebf68e4f36f3c0ab8a05c931277869071c5501fda45056fd835b031847dd6800c422f2d743580ba9fab8075c6053434e6b1a565bbf5d4bead6dc16465e278ea0276b666550c028d35213190dc0f09eec5de73375593e187d9098e257e3628f88a925bb5853e0f425e786901d3dfe8d7d8191326b20469bc2701d24227993331b371b1d4c7b94793d00c767104af6a591a4a3174e7b5bd9c053e742a33ba243ca6a901ffe0433335b062f4dd7f1d8bdd87ae3ebf43181cba852ea58eb07a5f6c3063e2aa8a8079bf0261819ed2a23e3e848af4676ce9f5821e3f395e371533def40f6fbfe2014b08ab916b32cc1b76273b38a8744a2673523061804c6b14461f4e6ee57814ce10ea2e10e00426343fc2393f919e5e9bf84c7ab53e73012095d7f7f0847ed1a61ffc1a493494b524305eaa4abf2b80690ae66364b38ba5d21c02ffeb2c58b0d563ac34c2b0bd7f0028da932fa489f617dcbb8a9eed1584611ed580b33e2750adb80799c89b367c1019095cd418a6d3057d9b5b67c4c0b2e1ef2aab9de1bf9604b90bf7d1c373bb37c5b3a59e0a3cee4194b792294b4a63989091ddc528dc33487aa4f30fb47c490920529e0dd69c0d04776251bc3d1eeb0a4d342dae1e007cf62339465457936ad8bfbdf1aedd12d65f1b3c85c20c0461c306b336737b0fd754d6a8ed0df0c9ceb66300231562eeda8c3bf5b80c644563f4c1d5edbfeba4a64f833a7b99aa6fafd0a8b6d66cf6810dc65d6ac09344770848f3c0af9e96609899609c035f72c559d823ddd2c779ebd10298f1ad961d593f7231eef82a56b295010f9618448936882dc5500011f16b8932f9cdb616045eb1fea14539c3611322e184dd140abe91fc9d2eda47101f6d70f3fb89b2832eb4bfc4a7b1b4ea15b385e033fd33023a6ed9b764b5cd49a2df0eeff34e064dc882c57dcc36d643687dce149dddf184edb238d3995412afab008c9c2b8531d74a7410b85c45474532ff200fbf633195071735a15de88344e25d54b26ffee65a5d17c9a93a8342ad38e247e4f99eb89fb1d1a0550470308b940dadbb26b63cd8a0c123507772f255800af06ade151b187fee171637713314d24f4ea8a152dd1335dbff2d272c367794b7bdd245fb2ac9d5d55289f8a4bf250c442dc030230be853622a8d2d81819abfb74705b78213f9d94c5b1593f1c22df5a5cd6ff4be01ef6c9a7e98c03e99ef387641b00dbded510c32708da5352f8243863371083389c96d488d781b252ff943eca5ff9261fe1538c24bec8c8ad254db50c1a48ffd152fe0c7c54986143f6c07df1b8478db956d7201ce27449bddeebf11dd71c8f011385b65a4fd185cd6d1d652114fd6150faae9b321a0c1618fb524cdc503fcef25660435252a417620ce2f7cedb4e2ba250ac7d7ce22bc26c3523ebcfcc2c2c335fb97f559ccfd609ff3214f9a5b64c8f9dfc44525e990903abbb64248a7d96e20c2d1921762ede1ea995236513eb8b03b6253dc001358d7952099e95490672262ef239a56599b5250c240028c95604ae71bf54f3979bc0d3ba8c1f8608ba0aebbda57284ffff63c53fffcd3f5b4da1f13b9fe55e955833d3d4d329934c6c968fcfb1f30714d8999ccfcfc2a7b13fe3a8a337d2e9b82bd35281ce1c73a4aa6dcd746b8b7d6729fbb8142d299daaf0cf66c88f3ba309188d3d7a4fb555d463f8ba61f7d4770e88dfe0922d6da347902a0b7e76712748ade8ce70a8d4c5e84a1c2a09eb4250711fadaa2c0709e49a00024689cd05be14f20beef741d2658d770404d7f6dc5acf2188ca3194cd89f348e4aa51b21f69c6dafceb6415729fb1653a4b274f906bfeda294be73b477ff1e6a6214c6e5ec05c758eb1aa4650eb90a24781b87b05d8de0cb7af54441168f24f59bdc33a829968fdb7938606e468a30dd80ee462cccbbb4bda62edf1d61eacddf101958014f4eda8de9b993aae4ea19b7d0991e1eb19fc6eefea59e4e65881c0a6dfc00a533d1b82b2821937c0c075e55f637144d5219798d7267fc601bd62c5b27a7c99022c489559dd7b79c39cd0ed7453e446d70aa91cc0b8a6d5481e6c05d1e298c7e2bd54a679ac75d623df307646c7c6d2a07140dc072ab24c1f4ad52c463ec6e7bb2983bad116c2b306bd48b076a4e5ab6538e480a0b30ac52942359da75d1ad2bdcadc501eef00a36c9e2b2abe0816f6a04f4d63e869dc98078e0dd56f1b29093f3d6214da447c14c8ac1688477a27a9bece93dcd11aff63a3f4da09a8b1a975a70138cf5252d7094e9de02843a19ebb11c9745aee3f84403001a13dd4c92778effaaa9d6cffe1d504e3698a83c1ac2d4e6f28ba69dce4ffe59a8418464823dc9b092a1ce89da1ac2d3512488a3eaaa3e89679e911708dd3553c002d0bed15fa640aabc2eee13565abfcad5034caa0db026b6be8046324712a6b939ac605c62432c01640b37dcaf59671a744569788226d680ee8621d04d1e0a5d6aeac8471f06d94199b1032cc31309cda80809a3b9d7fd931aff224b45a9bde70514da002bee3833c41574e6f0e2be38bd75b04bd0b17dacf46c62bede6cf4513435740f3fa7bbc546cc29ccc93efe9a5dab830af24f78fad2c366124703b230737a2eba04f71f5bf546d1a6b65c9082aafb9b6c7c5208e06e7227a7f04e3511ce9cddb1972b1af8c53e0c55ac17ffd76012e65a2aac5e5d9ee8d8d34f6b1ce4907dd4156b022e4ebd6ef3e53a40e03dfa8d6bf264560554c589c6a245d5e79c1cbe175b5ed812ca1ee027fe132240c802583b8c464ee0ede87ecbd9982b82867ad0c6741d44f3f3df10e7a83a3f7e9b90b532d9eb037496cb22b98b71a60ebc9559c3fac6ae66a6437a549ffe38cfa7251b10cc9420ce36f9c422b15c52bf4853875a1d430c81589463b9c6f21db68dd70d38f767a80aef5b30c864abd3f2d0a659f389e69c7b2d62a0c2ababf95f7627b703621cdb0d62bf002d0398cbe412edc61ebd72ed6b2c0f90db57102ade80708edf0a903cfcf0cf371e8b8120598f9a5835d8925d4119423f8090cbee6ea50f89aa35a8d47c1b3f4880db2788b9b87095c06433ebb8ad26b446f0df03810e4eb9582884f5a21bf87291bee8489ee8dac416a23fd623c5dde58cbba8cf6817286f41a7532a3d6caec4cfbf0b48e28775cb4fef3e5b73647b51978aaad0585b10c0e3f70611cb27aa71042752c102a4cda613012995ac53f0d18a4e13d94d35cbcfa4c5db0f200a3e1b1a4989f2e9c099be935ea90ab17805245ea3265e45ac6ceb3e84c5ebc766acc61b448d69f049ba1ba6bedee55086c34cb7849176ac049c26e44b2f8bdd0607b41a98afbfa190d2186464dad57444da21bc77dbe8a9c49b388a00f3489031b3794f48822b89ca70cdd7cce510be249c3134e1fc62739d7e647a056f276e5203de11c6412ac14084e9ce555f467b2f729ea058774207c6f5c76752606b117e46eaf95998df6357fa1f183aa0e5b3884e3946a57d8142223e0989cebece13c5fd49351e2709c263ae567c4e135c021d01df840e05ff4df9a282a11859967aaf1cceb4f48418e74e33ec6bb1092176fe3de05b1b40656bac954eaac0dcd9f72f07efef9c60301d582569662caa5f69838817cf51752052336593345f9a53d2ffe2f30a1540c49b676c89a11deda4ec65c6a59aaba47f1484c5a45b37bf218eb54e3a20e7d41cdb45779eddbd0df7bfe730d35b70909694b1591ea6628575bb6d59b76b55b7210d6c2ffd33a0476e23cc30e2bf478aca45d224ed3ff7812a84f1dd32aa8654b73eab55e332e906b204ec2d76b578a16042f0f076cc0dfee621296be28db9044064b4fd6e4259c4d053208fca5d07b2ad0b268ed74372009d94c2132cf0ebca5ea694a667a6be51ac40c4f23bdbe391f74ecd7ba40115a76598c7311f72dbd14823905b6c31fa46bbeee9d7d7d4fef768fb80ae8cdf2b957c6db283e42003bed499abad1e9ccf595a20d7262e44bd2354a75ab35c479760a05e57adf117255b89718be7937816105061e7e771421cfad7462f379dfd2fd85439247916577a5be02e5ab93999c5b4caae86c79810f0f6caaffc80b8893f209b883fd55723d0b28084790b20945831c5f69d9fda14310843f9a6073ec4b45768f23e0d591eee4092b2a3916ce2654828084170f0c6a4caff467c1514870ef07f6b7e7830df5a4e30c5ab4e104e9fcfda8af028dd4b6e9eddd6f99646e8f5cfb31853d80ae46101789f780252f85a5ed595609d6322b991ae05658f1985f7222534627eccba9b773945dfafa4f3f07835d81bb246dab0f4bd8914e92e8528d6791473a223d116940cb38bd3d4b8d7347adbd4aef64d871309a56673908e8b827cf3df9eca4730dc8e33c954240f054b79b565749b2036b1494fa50cd9c0e23ff7ef2eae7ac5c4e0da7ff8c38d6caa06bfd05f9f2d52b814b1e840d1cf866763fb08c4512782c0473a09be83855c12422d5054a6f9544008d8aa64dc280133ac5077cf39b5d6eef2349f7987c7a7ba7e5588a3bf2a529271ea14848e43844b8fae517a039628cf86db7a474132bb66fb7da23dd64361c83c8f9ff895f75bea27e94e5e7d172e9c4775e185b1c137d762c2e1a377b559dbe79634ddc5c51686319530ed03793ec708dd821191eff50d737e90f64e1f26a88cbcc68af8c43f08a74152ed4694273adef8c1c2353667a06df25820899092338acb77bbe3339553bf352d53ea4d4dc40cb18b996889e5afbaee193c041d52df442d7319976f2dc255a1952e9a9c491a8f6d89fc7ab799ee8daca909d1fb062a9514cd05b79476f5e0ce07013f497a3d0e9c8672b273447431b4d5d84d96660f7810a2687f865f1002f6c7bb28711da57db4759992f720a333e6a6c8b64612ed02090c50d48911f5bfd77dde65dd3fb996f843a1cd906c5bfb597c0616f138b58a8e6ccd52c9138b1171bb46819c500b0d1603b8e5137cfefb0b9352539319833c445378a4b62d0cf31c0ccb7f482d5977dccd85644f27402cb035e47c52792101e2c7ef04bee45f6f8d3f8706c4d18d6165780864fc8a736b68ec75bb1ae5f04201502628634aa157986a92d2765038ee2b722173fcddccb694abd8a6653c9ccc863b0cadc41519a9abb95d3c1ffcf35780b2cfaec0a6b339d2d5cf43bd41aa051f4ecc6ec959a6e4aac4819529782bd051bb0bc07cccaf5c48021da2ea49093e99584bb56d91c267c835c6c28ca2601f7002cdb3b5a2b10088bf151c80c058d9743c75455b44a084b67f9f8cf7e1b106c85fcedd2f36bea7a68973dec133dbe7b58c4a10754886adf8617582a62aac9c0fa4d5eb151e2431ddcf7579fb50c8a60c6cb5154744de40e378cb6a718387941f3586c0fa0dfaaa93d291fd2c088b72f528c99c9dd3f6aa45f34bc9d14f76a812056a457f361a4c89b0b382f44dfbc1ce50674e38cec8dea52c84d2cb1427cc2510e09b5ae5b020371293f4453230959f413efbc23413fdcc375c3e5d0d5b7b50a329d62e849747d1783d3840585e0ab0212c13e642edfdeab3a0dcaf23b92118d5ee027a88547215aadcdbcdb61b29c70b1427ab551500769233381f89ceffb89d30b8b33b7bb9592e86ccfec84ad6a2a5e7f04e43cc82ca221866bab523f863b70f7873fd045707e6c60f08b4dfb8fefa1b060f14de42ec3ea69e2d499a8dd06efd4367afcecb8a4515ebff46fe9f89f300c6165248731c87c8c1ab1cf76bbcbe385c061fc8f065e3b139bdfeb2e8d81606d4020f451821ab048079e85021878f2970f9261ac41de7469ba08d4fedf9b4528c623f9ac370b9c420faac815dd2ad89b46d897dd35939637e1a03e26d91eae4e260ccaf30e4c95047564c0c57fd163d983d6e1b9ec883d04bed9f5030e68059f187da481faea4fb76558076cdfe00f057eb8a7c439b7dd9b2733cd0d9f9f32eda724d4afbff9a66edfb8b5a9fe8f9815a815b94a0985b3169972704008b106a4e18dff93bfa3fe6785ba4e24f3178303f94862c19dedfe294e9b42a19875b519d3703be775b9cfd15f6ccb2f52e21319d4e81ea942e274fdbe4b1ba67da348fba6d65fa3047f77465f3075ae34e48d09459f5de472e8d2a4367fbe6e230f54f89149a79f588c1b66867474c6452db51d164dc4b7f094b324129aa9caa939b71c2be1f0f453563c887bc8516d1b9aed14bb93da6584d9988c81e80f4eecd6ff422b371b12326e25e0c39d3cdd676b05c7a8fe84fc518dc22cebd96cc394f6dcfb3422f5b42848af985e9c799106a432192e4c9482c336296d1be3fcbc76767d76bdb1aebe50c017b010e1321f99d97007a3beb68ee35a0ff08e6912ece4470e89185afb0b8c7071ee9986c87977088cfca2640ac6c708aeee8daf238adac3fbc723c35df8469311c586252038d82f38ab7f81ad96121246d1f1532ff6b02401f8d13ff403c8b16211da01a435e0a68c85d76021c5d622606b36e2d87719659ebba2e7754d029f43f5aaced87a758a15c4bb454d8114b2196bde09c53c9b7b046cf2d4cb2bb6b126c32ca0ac91fb63168edbd94c28875471679c54d2a170f3e89b1567723c9b19f04505dbbcdf11955235c9f3e8793180ea46dd7b501ef8acf490358f686adc648c03d96a7f62a9a99d3ce701d905b36945d652375b1177e25fee531a88f11aae51ac9b19c2e6f2513aca3a4add4c391b159fd85025c012f230561846c2c47ac90a89069edd699bb3c64421cabe42583e39d3ce78322c80af4d77543f6980d0ce6674884418f8094097b75e778610ea5f51237f6dc956b1ee4f00216cf820db46ffa3ebe777de8f3340864e88e63d88346113c3de2d3728bd3487e21c4f906cb3fb73f422373de0bb79311c4c5e04d8ea1e6702077df486b017d538f1fbcf7914d8f145ae74d471289983ac1cafa4670977368918087162c21b07d2d79dc05de241a6bcff9836a81784c431252ad439570def835364828a0960fbf76757fc29c89cd3439fec865547a6c97383667ef33c91d2844c801787b00d260a7c3cf846e03c226be5a225898dbe5fdc95f28e8db4b9952b4e28b56b4d8b55708851a08f807a7633c5ab032e89af3c2e8397aadc1914e2a49fbab9b9e12d36f540f692e3f9a1a1952c92e7d32e2239170e0ce830953b246ac754c2ca91c7c32c5dbc37917b15acd1b1e88e04a44a3303e87f03486b73378519073ca549b3d10d68d9ccdf4d21b6ab5879dbc1eacd26f7650b94e6c9515d3ac7fed1250ec5faccea5eecde67324cee505f6a1d26c65e57ffed48b5a2485df6e6dd6a3068d07f0caa7d8eed6f562d23a678c68f85868cc2a3fb1015e4c8646935429e97c6dbccf6cf5640ffc57ca23afa2bec42a8081e8848c7c44641bcfec75e775ab23c6d9de7a327e4ebc422b4854abcd2a42c7d7ada39e55b186853702f702af7ab5b1043ca25f6d4eb4ca2ffbf8ec29adea507c87cae3401197c90b33d915ada007a5730fa50eac48da88da18f1180f94e21d73bcf42ebc897e677f3af31a109b4376c277f961e3446dd3489bd930cce74f69e9e4153917713ff98d3c237c630a3d736cfed4f4d7d5a0be64164a8928dd09d8a80003306c6bd65fac0e2be60322b46d4472034bfeaaaea2c26fe474dae54a0ec87f58608e450755d8a62c883b94ea7f27b86c5931b0ab5da4a50b215e5ea2d44ebaf15d3a0755aa659c3c016d9da0a04f051135466541ad1f06910e37615c6a942313ed200fa35f00325acb79f94eec3ebe52a283b8f3b814c8551d7f0dbf34f9a791aeccf560b6f9c6d5f89e8e430e95d19de0572397847d96e9c8bff1afbfeb191edef587692bb2c680778df248e24cb64cd10934b8bd20b95fd95c2ea8a695ca4f57014a29af44e3892be256fd7fd841e45fb895c873b51fca6c9e59dca8571d7d45df9867474691cfcd7cdee3f7b2de6f227b883eea3576439614025a4f5d9ccc5f810e4dcafb970272a0252cb04885b40d04d76eda8b058ee6974697e7050cd887b85eb8ee32e3b068ea8f2961fbc54a0e72056fca94f866b563b331ac8ca9bcf8316d85c6fe82089a98612166beef1a289d4a09c0eca0f5ce9c10b6d1243f2ef08612e484255fb80aa7b781bbe3306f1b0012aa192586989099f172a883f9396052006e6e7121440cb442dc51cf5027d443ff43ca5a3404ae65e429dddadd2e24a309822835799c2bf401456ffd50d131087ae0ceca967674495432c157d23519570206f3a3c00f1e431a7ac93a48ab490c6c4d81228ab2524f968a81106711e1d143e1b89c6948c140923a92ec35b6a1bc8470b995250d9ec777a34a9d6dc1fc9ac6d01194a7e419fdf7cd30fcd4552e05929a9c37b628377069a95f8c4776b2af2050cc0445a6163daa46eba620c1b543b4f8cb254fa4e6042bb3db51c500e0596e060ce44e3eb930a795131e1b4d72f30194a8af0e84bc41bafc2c61788f3d6fd81ac2a4e06da479fce1a29979a2332cbb5a605687066aafa17746af9b58f4fcf2be49f71fc1252a11bde219d8e1c4aa63d3fb41ce0a311a8b5d618fa80a2c8608656ff8cdb789eb04fa3ad86569769df40d254d40d4f840bbf0b1f850ec471fa423a28b30102a08b269828aade49b01af2a58f020048e889d20dc66465eba825e2a25266e775ff6630dfc2ede44cb094b8e0d133d886436ce98e7795a4dd92fdb1d0a15a89fd8cf7c3849d2a4cb7cbe0a16600e7a5ece83642b7d518774cce187372a40c1e766099211416a122b5f4c59f2decd9343caf1130e5c3cac2c09d45d4f29db4d4993fbdf0d990169dfe3785ee1e4612ab94ea34d7634edb0dc46a2a71850e36bd8ec070fbb1f7484cf41e72e0b45b4213cb7d7364867b03aecd9e9be9a473eed9ab1aabe72805e1e84d3468581934e729e5aa941834d654da812671bcb911457cd41a35bc549fc17e13d2669ae2dede550566aa25ee9a3b001f622d1487f17e5a0a59c8a126e121254828c8702995867b46ed2d81cea894c70208b51b2a84e5e58350fa030ed112002e989e50a5bd5f4d07c1245ed4e32b32300cee6546b3b40325260864407a32a3c63e6ad0c47a083f76eaf66a705607b54963686be1a9f3467fb3c86721a93208f0a93c4dfbcb33786886b58b9ea7077656c318fa973529db98a33ce46936d2f9376561db68f6970308ba6ca714401a4efaef7b3b216f701110854b1b5f56364adbbdee43835624197064b20d1911e84a7584d3b894556606012e60a78c38ac738c0d0859cccc3b739aa22c855b95bcd5582ae024e7e0d16c1f2e893f50b576045b7da89d6d8c43b7208a49c75d381ae9cf8a43a9f9c2567fd3592de887f0d5262b3fa89f0dc3708f80ac2fd4fdc6c1e1217c327c37ee6162c3317bf255fd86858a7561d544cd70b60eb9b0a807f4d3ad8b70897c1cceb7a96dc68aa426e68eac925995f2c896071af815dc3f83e51bedbee64d2db0b51d994cece4660f749ca05236bdb1291c700c24f05343829efa3cfd830cfcd47ac82966b7fc104768ce30e6875dd1bbb93ede4420a4a8e46ff61181f1153064868c71785bf700d2cec086b7c52b270d1db296b644caf1f6ba05b1fc81d5c9906ac1e9f6e33502d509fbeef35d5e789c92cb897c5ebc3da09fe770509fd3e219f9c83ccdc13cf7f21271f21eeaf8a1696b47ab9bfbb882a2cbc19394021feab0a70888dbb052810e5e99d4b126802ad13223205846a1fef406dadbc7ec462e95325cb9e3ac39c8daa08971f4f3180244cf034724c2ae630167b61cb6849b57d15d004f4f76ca1c2a14313a6211a6ba0a096d9485ddef7babcab2ce86d23122b5d35f8f735a2ff88b1c20c31b9265031c2b7728a8593342fe3d6de92d51f4c3de4f98e2812097fbeb719eee3981315901c8b5df87349af17c34e78a5d773a22745b23172a8d608a808ad1ba82046e4c96e0a39630bcb065270dcfa06c304c52297751cbf214130d071fad6ad0d1fced09d0855ee43fb119c0241df7eb0158137aace6dc8e31d119cde5c13b4b8346bc3ec264416e05ea0ce0c2204b3bcad0d9c02e03d8ca02daad98ab6ba3cc1ef4d78542ac754c887453baf179a840ad635a60eacbbb333bf6f73d697de7e0d22621be680fc3e884858b4b58422e27f488227d1f8b8b149a541d4d850b03a0b57f48ab4aff049e9618ec95955b2af2cda889265c973dcbe82322c5a19a282bedccc1c719d0e27b827444c33d3830511402db248f683e730692b00c29a0962fbb3a5c23e141aa79d1df5e77b4f85aa80c56ba3a7c0c15f0bd8f8f9efb22d7a9ba9c340f146f26dafa6bed3ba3787d4e0d6668ab77681ced48981e555807d45ce4e182237028eb3a47d3065b09ad5b103c265cb7583929ed90df6db303f9a9191c90627503864e0c0ebfce86c8af7689c4d7546970aae4cd52a6525544db4ea3abf0614e71ddf4db8f5062bb8f5939227708530db674bab54714710f0a4abd730712f6e779fcc5c23a0533aa8c8212c97d8839405d805b9dd8b5c9b065be5aefaaee6cb09553251e324e096eb9abdd7bf489e8079601af35229639ef7f3582efd0357577395890dc5af59cbe555af3424a2b2c2066bd2da53fa6a9b7ed2cfe29c02d9052e504a49f85b06ebf0c0817283e393b13333e974353978b6200c6a9b1529d2688a1237e32d76b3cd07dbaf5419cb6401ce5c95cf7a2d36bf718909867da0f2076c95ad8b97ee9a6116d34e2da9cffb4ffc461c71686f05909ce93c51c225f85f106bf29c79a5f033d204b598728e751fded69157199aff6320aabd39f3eab4f69a7c1f937c60497e941b7d4e68f77e5598655463cff432c7cec4b10ecbebf74cbddac347a8ccb69373de39c2ae2bc8900f41dc79793c84ac0e4023271dcb0b51c1cb7d569ed2c69f9b2bcf96f34897e0f8f68750b7dbcae0c06bd69e11eef75b7a76ecc8978527437855d9a2b15fc38182f4a985f86e301c1a8480f8aaff8df30789df6a04353a5350a9f11e3ba5a2a6c4763994e0ac4fc69ff1d4177458d5724e3fa489ca7af8f1671a4c5be5e80bceeae1b9d5817c0b12bcf8d619680feedf6ccc20326690c0ce4e9368de2f4a8e9c7fb2568fc48efb2437d372281f4bd3eaa4411e7f169113a43d155d0ba10d3321dbcb8e59753b69b6a7d4998868ffa2f8391f14c1a4a79cc6ff344a8aa5eb6f85c2703c38066bf72e4c98f25c56f4effa944750a757afbe4e4b21a98bff9d37d89e4111df858688481dca2f002169d098ff30b52e53934e56f099372f89b055bdd39babac140aaf4342b4c196cd8967fb88554eea04f083bf824c0970e0783d6343d13d7b004c2c226d9f90cf8a555fc9bddd3e56e9ce49b1779a82535ec30d8cab2ac211e2324dad17976cdfa6586801e006205939116aba5e7e181948542d80ec0966808fa52da2c46e866610951600758df3febb1997c3b7a2056a536b664f56443db0fc846668419c1c17f0003682a72107415e933b77caa034958b2eae137d41ffd4f2b422a873ac130bec16a999babc433d404d08daef57ce351a448e8fbade92686f7763b3acf593219d3ddf5e87bde497edcca03bdeae1004a6f3edd9e93854546574c903362fb5a1e7f63e43eb210577476420fa8d134f981db62ace1d9c18172305bd96d1f0519f400fa773126456a53e1f7abaefca3fd2f5d33b2a1b8b7ab1215a13968e7df59ca0371fb6e77eff40f30b7cc5f4aa4183f7aceb2cfe8f79dbccd0f94eef32f1de5462094ae1b1cfe10dd24af1bc042199fd0a28e06bb85cfea2379ef114a621eb7ee5061e348b7f69609c2a468ba592fd2f82c8ff7a27985072a49b1fa8fd21013d9e3090332ea280c886a431bc2eac3d4229f796c451face92869ee5a7c4887b488d27897a0bcbd43ee1e53210f08b7a772dc5a94ff605e5aa1f5d23836e91d6494dbe9d671ad5465f53bc6f5528c360e8e0190b9a7eb6538d9682d8474e0145bda7ee7d051fe7f9ad97cb5a420018ca15c94f93e66f1bf0d3f5bc0ac5c0f8767f5ccf94681e9a37f0d3b4fb68e074854af887d81f3817d5698cdbd6fcb11e0d487e08b6c82f738f761d27a5baf26772a29f992323b02575f1b2650464654c69e8e6c7ed1f76fe6111ad72f6f811e9ced5f471e60d97dccf052b411ef4ac7c18dfb555776d7028a1f3a1ca7835d45b4eb84525682af97f41863ca2ec628e5f2a1befaececddc939db12995ea33d81132801f77e58c4df539242182357c8f38191211dc74a48a4f324698d674e7ba1d5ff666a2ef25da6728dd692186cc08f8fe5b6eb79219e087c619194705205aee7b0e300b3de9cdbd3fbed301b567082cb74054b3b6702704dd422b4c9d3aa44bb10e182ba38ad8ee3663dfafa3ca6cb4c432a870dc5a17796abebc4f594ac13d67280a4fb0aacb6cb855555c89ef0ecf8958221511026ad9a47901e8eacc3c0ebff1d365cdc65fb02d4e666a76d8a6d2b0d5e3ad7c5a750647c81ff0dae9b640c484e269194e993b28b3b8c74435035733a16ce62590ddc40d5a7aa314487d5a421de39d518bbbd0b8bbe559284d916a9216a317cc91c6f0af0679808e28d8915c3e8dc15158187b7436ba5acd3ac5469e622eecd2bd46360a594a1627f2f003c85a58e6d60c29fce26a01980d333412ad3c6b2d1d32a49226b27b56ef5add1cdb4304da2e85216266a063cda05eb60e60e8cb276ad781e32fa36588898298a994c7b3034794d464a113bf3758224fdcdf62371f43163db1bdd866874808b170737a7269a3578c0c7874af62c25e5dc90611f283a7e5465ee0b649f225c17f7e2b949a2edcd32890dc35bb122ad7e790b5480efc33655582a99be93b0fd22812c4b378b3a5f6414b5869aafc842cb83656a42422c33a75992e86aa0d8c1f8ac673b9c12e1faf0675972d1ad6c6437fdc8d245e18a7fac54025cdb6e6afc06e9676528dbbec2c49205211","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
