<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7c9ce614e5f85dc9405e28216d0533495f14a757e0f7a38e5cc67e8acf354e67d331080ea74035a5fbe28f9d0cc3b95fced1a71f93b40e776ed63807bcfd73f8a7c184dd711cc57f79eded31191dc58dbfc1003d45fcf224eafe22c882cf74f6da215c90ad1acbd7ebc6f6c3b7a43c23e0c6f5d91743561adf71f1a016adf0e1a3b7330cf419f9f3279a1c64e2942312487639ea74327ceb8636e5b4249d5941de05768e77a1b9f95f0d64f427478bbbf708138954d564ca0d0c8baed18c8d0deb744088a679f2674602f27ff9061ec097a63ccc41ef97ddb95da0214c1d945a87465cc24dff8f9e21eb6b087346221d67c208b40134298330f8d4547daaf380bec5beacf47467b1ed65b5f47dca9b5616bc0ed6195dcdcd70b989b07797db69efc2a51032e97187e341fa599ea0e992d38c6c6772988cd0fe6e4857599e52b3a54fb97ff8939d91abbe5858ba834010715ca735e088b9a03f2b52d6c442a3da147af4695f70e2bf8a1ad52dce31607aab882af9d7cc3c8701194da3ecc57d8e20769944e506a7de052106850f3b4cc3b24a7cce13a096041664ee5f4928593d2cdc4636012f4b4bb261f8a0b6a09fab6c7e963d6237c5415cee9608a7c649da41dcdd83f96ac8a0e27fe97d6a74c7be98e31e96b625167b3fcde2cf428b10d73f9265a8b1942743747c29875d2f7b1803bc26b617941e20ff193b0c5b6a3f87e49b21e25a2381ec73beb6f02327a6e242da78797b07fdf5d3d31ec7ec0ae2bf2d547acac23aa69283aa3f3fb7b04f00a4200dfad22494d227b14117863c3a6de61ff35196729d7e44e5f8d27516a421d206c4b51ba28c0f300858bc52f4d8c6890306f05de17f1b90dfefd220742aaf8a76e04f1c9919ab5f21090e1daf1f190eb3381e5092a4394d92aae94c562c562b9e3c21f0db3afcf8c845bfea48b9021eb9f09c87dba49c92ea8ed3c61cf0877e96065569a7c9b1bbdc0856e31c4612a207b7ce854414302ea3178162562c498dcae4bbb8440376816785bd120b3451bc82f9b1f5fb888142a558ef6e6fbe61bb70a1b54d4343e5e3db0bc69edcd8d74a225076cde1ef4f5cccf3c4e0cc36c9db43845a4e56b3312b8a21335b9e278fd2a5befa66a2f79205277eb6d5fa060ec4edd3885d378a55040d8b36939f577917d423e031eb1a6b1585bfc7bdc5ac4ce9b2d51187e389a6241dc59ea0ca49a3a7c9663eec70c7cafe04a9e44ac1fd1703bb26c783a519c22dcf74c3ffac0b78ea5bb95b7f578056d32ce802ccbc3146649708dce196e8fe5312992002ae998d7fc2d556b3ad04a8ccdfabe738cacfc6f84840330e892f6171bb6ba5aee1dc87ae6adc10be14e35bf790d439596224fcf13f882ba60e4bf41ce989afae034973062cc3a3913e34057117db2efc1dc8de09542d4d1c62df68fefaeb3010fc917a0f4c90dcce355c3026986507275001bdbcbb636cec71ee84f96fdc3212cf3ca154d82a153b383c0a2494755edf7cac80a1a215cfa4d87de70d87f10e4654ddc93b34c34fe1ea95e15ffbe8de6aa1846cbe39407876108ad11b58d887ee2a7f5a3ef4102cca4fa8103ee14c13f8381e7df2a838851722042d681e5f9a29fa8eca30d002aeaefbb6c0824cf0daaf83ac8a0a83e71fff34737ba3d92c9efc6c6fd902e5f8e9a61f339422f822fc745e74f567c018b4843d6855d83d25570bcb17c097a7f1c0199698e09e5801c78906af6e5f5b7f90d42953eec84fbc79ba919a190743f6d822c6c25d00ec5b8eb4cfdda6345ca66f91b6c25d8da6e1919665c6ec4936dcd31140a6e12d72f898f650c0228c2dfb4b0b2c8f6eb29b58007f649b50fff852c32fd28054ad699143deac525875a71ffac960014334a00b72244bcd734d6af879fdb082fa2139db8207ca98e4b636b51e851dad6412be3da5b19c37a2eb64c5a3bd9abb59de67c62f02d741370cbdcf3806d9acabae2f69da4ee226883d844bcd64b70e3b079617a80e3483eb0f239f1f2f540b6a21d0743af115d6da19434a3181f5d97e7d00980d0ecb64dff5de6fd10ae7afc5bca45e076bc5cb57724c8b882b1269a15264aa480adbab90aa2a14618e3a9bdebd3d3f8c1e60baf786785468d5edaa61309fd064dd0077057fb1bfc5df35fec14061a900653217d9b483e2c89a75cfbda8910c222541e298e1b113eb15bb79bc304430623c7e93153cb2aced32a494f9da9d5087eab02d899cee13ab000271314d660ff422e04380ed203f8d73c059d86437f6172dfcf0c5e6eccce79925c74b807ebd4f97841bd9b9faf9f06fafacb32893375127d66a1b50043e662341b254bbe1d94d6b6feffc012a79d3b0779d9926de2aa408756b5f8db309b7608c738631b7beeecacbaaed0179bc7b0333ca75a6a8e5711f8ec667be43d1d2219914c6a8e51e324b53357c9232340bd33122fdc83d680550dc9c8f44af36d23efeffcbdb99dacbc336bfd9e7b59d6b18bbdcf14bfaec6dc01b2bef99c078159e67c75b55f07931dabb696727e71533fb875c27dd1f1915c6b157a5d17dc957a73853226f62be893a64b9e9c0447fec689cbb8a438df85acebc15ab2be6eea68d795148f6c6f2c019ab2634f9c9a83c189b15432503d38a320d456272117ef7d263aa949707849f7b9e148695ef56b0c7052cbcabf24175f32f6146d00ffb1f32cb5f177120b4ea33a5b291c2a0f15757c232c3aebd8e62662635a8c6aecf144ec61459619c48b42941845b26192b2fe51c0bd48a9749a3fa5faa84095af8b77716140a76312f26e42074e699f79fc653fdb1d2512825ba472fd2d262d5f6cfb722c5266381caf4041c1f60d5886dc12cd408d3bc336d28400fb61b5549ebb4977c16fcc5fc1bef63159a4109b83d2ad09659a5e35eba04afc46e7da596300b7a4b2e08328e9ef8e6273c8dedf662c66103b92d98a3f507be8836be52278de8b8e7dbd0ad9b2b5090e2910fb474ffae51d82ccc646c01363f35144e34aea7f83e8a6ac02883d2f2767c09f06e12218b8feadb653c353ba481e3901d3b743a402293a4cff614784f3380ad91cc09642a6d5336714409454407febaaed9d5a71c753f55f7725fe7dafb3d4711b9a71c8cbed0cc093d68a129426d705611c25fcea77fcab3ea5c6787112613c614005dac84a5dfd2e71658403bf8cb8f9144cf423af97af94f83c257cb2a03c719c054ac39cef737eb2567ea8644e4a20a12ca1b2f8409003f4a4538be4b12c3732e6a34e1c37366d24881c5f6d80c916b5306e5b60d4e2bb036b595cd19e67e5ddd19391f39a4c1e80f9b25081914f6be2a977a94876a9925bcd4a6537674ff58f6eadb464b51d61714ff9003da4a3367dde512e3fc91c00ea7b271ad41cddfd0658474b1736d941e74d44bda608889b309f08310af7fa3437f001dde205145c877390e525214ccda9107daacb68addaa95367744731c818e8e2100fe6aefaa19d03c339af2e026e17e6380d5a22c26aebc14574beff6c970e4a8fcdd898a515793a8c723b4e031a4ce32ee063997bcb5cba7b2d91326b1e7000f390552d42336ad880885320f6c8ccdf70f36bd17a3fec6590a24b6479ec489fb956b565e1e1f932eeb621d9fb0bf39e480da59c5eb681f1be30cf3d640f53106a3651aa388bf5ab500cb60519a3d6c61f703169693ea6b9dc830a728fd6eb6a98277cac2138a9caabb0b1c09627fbd3cb4004ffd4764e470bbfc420d9c12848de4c3f224678197f9e1cf1260f1eef84dc916608681bde93ac807ff7f9281b3ee414e7d3580470cd0011639ba5cd302280912abb6407910169cd3fff1dc4732f1ca909aeb59acd9290ba7164fc663760b33cae2c978632cf9b9919a50967c9cd716bccec85494e206772255077fef1963b1ff0958384c1f462f3a65707cdefb340513897f670242414bfeeae36bbfda99cae80713204e82d6fe54424b66b86431a743cae75d8f78c9f9ce7f448f4041be13b583211030c392118bf3282b113ed0b16f7da8d345a9f8cec4494852357e57a0aa8ed1283131bcc9c954399b46096e724668c4f3f2b18d0ee4b735d7f7c3cbc96bcc6cf428f4987da103450f055d0fc2d694d92a8e309bcd97a91f9b21fe1808f703518059d60ac5c30edd11ab11b8de5a18d53ceb14c2f661936b94ff7d4b85bff3e382d317d26f788f8fb6df9d968e0046818bf68a6dc11af6d4de62ed24b05560d8b5901206c0ab8083ae64658ebd9b0c699e37d8e1f033d9c538cbbf5348c94712e8ca10fcb9f4d4132de0b0b908db7068a8c84ddbaa9da38ba4c2768c79324dd2e4aabda47686bace003d0b772eb5759ae2b240b105a6d4682d7f97f573623619104352b60ae5ed58ad89d78982e72994a76df3625264d0daaa5a32a94e7cae5ad09c43b6a0c24e713c17f61b7ab064fe12266b6f4d3ab8b36e44bb5a9e51c53a1b1faba33d366c5626886eaa9546ff861e59132ca5bf9a4796db78f04181ed99971b66f53ea7e66cfe1e854471152bba8a72d64a5f7c67d35f9b27136fa3891f62b127e2f758fa3b81a0fc7a463a98f98ab39108a4ebf13babd3c7a5f046904be1acc7be86a5e1b3cd6b21d2e0ef7bb9b4d57b94b4f89a0a8245d88a85a9273fff54ae840c35213b8deb71259618fc5f7bd904c6613745437224e4ce4363e2e8cf556569b661df0586cf99b075ab814ef0d65b3c8660afa2c0c1507398b3fb4b54ea255e90983e1c4f08ff0d1e5323eddffb4f4488f678dd136c484ce152142de59d6eb2ce56ab1547f69c17a11f9106d979fc71b2cc845caf2f28c1e379498b09cbd81e88138b7465c8121cf28be7c31d19fb58f658065e13ae33fd0b27251fa75a2a90c4882b2e1fa137a8bace67cd6f7a4a24ccc55436e5fd99517da96b3815dba0dd6c090d15679cbda3705942bf8f477a1f15edb143ccbc2a1a5bf8154cf9b5dc591c4984aa9babfdabd42123a000b77345bc733b7427b12e08efe73095329afab652a1b60b100ade74cd4cbe5c27808132c5d40434137287a6dd7a4f43f6eb9d55dea824b5149d5ecb15958da807cd73094ebac5359350850c42a9c198edd6f66aa10005e4d0551e77eaee403ee65fb09e6e628fc8c85c7922740145ebd08b2d1faefcb28b8b083243f7fc6e7b1c17ed06600cb8ab2e01b4e530d9f45b8410fdac19165a81bd657b1cd10e8433679581f586b40c9ade754f38c7d1d5e1dc421335c795bd104a842c4e7f059d10fc6654638a8881eb1b24ad46aaceec4a1ad2b86377b68b71c9c3667dfa9e628a8f1bee97ecdba66ee7ee3055f592ec144ae768baf95e0680bc4ea0e0ba6b81c6f91087d10d0ee5020722aaca7ccb3befff06e769216b73ff3bd9f13f353ad4268dd66c1aa01702e2f114adf0df131efad98c4ead8e84c6b55e25f1aa5893a73bb33cce911e26a8430b67567b2fd9036c5bbde6251ab80368de63752cfc59209aa26f54cf7ee44ca2d0a96116166b606b5b8add724166073b6ea269bf2f300b3f47342654ed9e1e0741624ca6ce2dd6c24aafa0348abb8cc7c43880acad24023bc87ddfaedf13851f816c6fefebae8232a6094e5035aeead31457a13a8aa4fa37d8d7ea119555c90591ef28524d73f8b1aaccf511ff2414ee2652f6cccac880dcf2b96194db3686110bb9faacb80ed7bfd85fb45ea7e1c6d396c8ef74364f1a844f90658ae47aead96700bb9cf705e206f314acced5733533f41a7afbea0061900b6828baf4b4b5616beb3803755780ff14bbf1a3d214b795f28f7f46ea8681814842c8ecc64f578478851eeaa31099923df70a89cae349c129199a4c1984cfa3da19c0bc668085e5da1a1bd44d93bc46089fa1583ea0cace79ec595f237e4fd9d827f7badfc1f877215382cb79adcb49a350a9591c3b61586e0336358ea6342076e11f5620ac6dff29062e876ea00c215739435d3dabee7f6fd5f8d75cf3ffb0a244f329282e747a435a0d04b84571adc4334751e886cb3834c03527fecd6030bc3229a8dfd1ccfeb07744937415d18d3361ea92493d3d91f13f6527edbde9c7ced0b9e017a63f695ef35376cd48df420349afeca4581ef84b3820470e7301432f99a8f4f32bf4d311bb17b094c7d09414361ecb9472b493b6c2030cb1baffd5cf2d793fcd7a16ac95e0aadb080e4c2b195ed311fd9d5b9221391131541bb6b643e8d48d2806f6ab40e70f6efe3a7ab3e4987b038e30792c1f034594c1cd62e19e0bc4f4e020887295d8f7578b4c4588aa5889afd48b2c954e18775d8875a8ef679f282b60b82d46307432161dfc5a983e42f5f98f2431756a2a2dc6cafe458c1bc1de855d6b53565b5b6f52534d1d55bfb0216ebca5f2fc69ce7eef6acb1c99bfcc7604115d388ef708aa3b7d5dc6b41adb5792f47520dd235ae53b56de04862973808711d45f73e8002859ae312c0cb4c42eddf6fde8ee7b88ff6caa08082b24681f2b886c484bd7ae6c164cd1c1bdb8e8e10834c2e056443964f941c017f2c87ee7f83c3bc856345588b0c815e0877b23c58f085830f45d4199b5ddb3235e1947bfea0e64bd2b97ffa598388b43988d821d925748534a41c14d56716d12009aad1aec9c294af8cd44e56503f96fe82c067a30a9492f0e987b47e05a246eccf4c64a126c9e6a859f46502df2637f7addde2fac9f5ee064d51bf0664d02b4d5c0808f06e5e8353a0b077d18f1a8b4d214a098eb22f73f428a63b9af41a47369bb90160161ade54aac2e05191960d0843d263143e1dcfcd676bc7fefd3a122f60571cad1882dd0f341470ba5dd95a3577f6e988ce29f6e7c3d6a9c008bbca9f355f46758dd7b5819684fb5c7d3e9492dd537addb284ea9a6c884e02e2cab9912046e05f5d15cabe21d8346f6b22a9cc20078e26d0dfb8e6814d321fdb95be82c247a972941c390920d68e4343b282ac71e3170a2546f6f31c23bc7d6aab43bea6db251920a65c8e1d82a1391b2c691a72a9e4ce4e37218b3aa2c9f2418d5dfe31a252c2341238ea93f12bf526b712a19b7db1493cb4f7d8961edcff2ea43ffe3633a012d718d7c9b89ddeaa2f94a9b1d87b913b725352a37c0788097ce5933ea13c676036eb57b2df263583761341c5003605a896caa29a749a887132e69fd8d9912cf5dae748343b66434b50cf0ce53047f3280228caca9c2a873c751fb583babb816e29337f25f43163605062a70f66c6f68b0cdcee58bd5e86c98b9885faa6aa7bd1e0d5e0cfd10fb57d66dfffc78cf11bd940d686fc05fc8e4ff33d9cd00b0d5a85206dcf8672b6abeb2d778077e207cb5b6b048b9f6e19babf377da090237903d245f3b91b441bb0362223d6aafd578df395a39c830a00475991dfa355562a1e685ae3a85fee2028bb7f7245434d41993245d82ab185730a603db60443cb047a24c2975c0a9f935bff9f60231cfc753a08c0d905610bb5268190f1f73cf5323a349a8bb4b9a1de451f3981b4e119051ed71e145769f3f0830a4b083b79a7ad24182773e240edce091ea53665ea9994e888f9ed24011974265cf4290d04240d09b1d9c80c3a464ab6a50728f600cbee6a82fc116ab59eba1ed2333c74456c59a321b9ed2082c9d5a124f4f5460cdaabb2c656846fe07195502be1718f4729e2a43488b5fad30b87bc4715d9629c0febd2fbbdbfaf1a07b9a071a8b0f6c2725f85b8e9d63773749634696736f56f575a785fa0e5c547a2bd904495583b2d7e9f9427e24132e73c4c773d913461b94dbaa93cbca3d67bf8a166ca25732ce6b591512fb93ad74e869d27b8c584309386fc7ad14c0b3335c2f684fac128fa977b2b254171f33a3e90b0fdae995adb1a1094b297f68fb66804ade414d18cfb303ef349792ec5cbdd05e56b39bfe917c986a27cc1512838ca6bc9d377c7baedc6dfdaee7188b2574b205b8958b7b09fc422100da0f55278bafde233088d61c54b2b08d6affa4aa679b00653d581a639bea8560140d2b0f880c7327ddce5f7da92b1e8b0a957719d2da53837277abb6187913deb6a31d1f9154fb2867a19153eaa191efc44f368e8e102cf2f62d912ee43cec61f3ad52da714593a3be8738274fd184a49f8925db453cc5c3df05337465f973f1211357325ba50728e4559a4b3e29f16614fab9e43d2d9bd4c7e263489ef24de805cc3fc22a768326a202a8526fbfa86c8b140980f90c373494b1580eb4797304ac9a5e534278517a0d41cfca4ce45b96d42563954870a188edde537a94ef339c7e9646363a5d98b14afd420d05f40983df4870f8ef372ceafb165d5efe900823bf3c34cdd72c3c1f0f484ce0cb4d518875a64cb259b5aa520478a382aa13e956aac973cda700269318da9824b5667e0f169ea759ea66a48c303f0d0666f5cc8459290d275ff7a211ef7de25ee0b3bfdb0f6d94d14c85f95a1a48333efab86aafb0f81a8a1ac398d67dcac13fffb1daeec19c7c74c41598fa8b8441f9c8a4fb5464f54bbcec3d04be849d2122ba8776b45478ac347d722044ef07bcf52103c4c3b1f9d5e623091d9e355645a6d69a05cc429231b07d9c8dd46ac632bc7233712a2d0564f95dca466aa2fe45228bab1d2528b432f925e6bbcdc9911d2e8003cb436703dbada7807b0d3da9d0f678f3138e3879f13fc17467ba829e419f04527e5b6866a28d93273b58b86085e766dff7d8ab797fb84f643c8e96786348f1af472de2f5865528cee33e7988a194489f6618d0f9a039535758471d06339bab0542fb98de0cf930f1a31489acd1bc9a6f6e8380da68cd4bbf0c548da4b5ffe453e826ff60c9c490aca3f55194ba404c4284319bc887ce54e7f30e42f103c8f68a88d9061a37658ad8a1fa5a5b49f048eafad81493ab80e9427682a530f5203d984b2c5fff63da072a45e10fb9d8127857c6ed8b4c68936cdcac71d2068d3691729460c60123eb37f98e473a4fd69757961ca2ddd3af51498910427c296cf80db828f30f2aecb9ef2773a27ab84b21160b069be574d3a5aecc3e39f009eb5c502668d3495d20f41b6bd43a001efe36e5dd5557b431ef91ba87c8139ee6bda9e8961c785d14f2a2fad39014f6c82df90fbc78765f02d49695634f114e288361507ef3dcbe85ebbda37c31738f3c3f3fa24a08194c123a59ef13720c201f0210c9419aa50d87733ac2744540c1d15b788bba044f5e1c9d1988a5542e376c60dfe7d3a7e568c4b5022fd78cb80d79b88e8c4668b2e02df9eb2534612654b96a40b28ec3c71b2a4c14aec0b73ef509262d276fb38dfdc4acf76b3dc00ef8a4d18c4d6668c807dca31cea05d7370b6fecf72f3b3670306e5837907cb9def330892429d5da5fb5c00d13efa0d0680bb73a74d67baab50769fe1300e37976717a03e34d99d5a26dbef38e82473c2108dbe9e6c928b54e9d129a8c2607140513a655acb29772bada3aef64b6308c111914578eab031f71d6d0ca6f1de423445167109e2eff1f5ce9f31491a5d1196eb3661ccea441ecafe0d0d0c518d855fbea5c66f8ce76851a929cc298ac756a150c35282502e3e9a5df4cc75f810f1a9c6d1db9a03279cb0394885fe5cfaaf342b8190b8113ef5e003e35443e391c001d050952620fbbdb7370ce9911026727122281cf1ab51d057459f8f45bc7e5cfcb086b79d0ebd6f70b96de337715f4ed01ecd8227dde7ffb907df2b61c4956b3f962caec8d65797aa9994c120ef8615ad675eef46e8789ebfc7b8e30ede908f8a290f54a9afd5d528ab17052de611d1d854c360ba3d7268e54cb0ecce3f751dbc10b04230eed3affe9a91bb49d8156f18e316f7fd4a0514f24d5bf8f40f1ae3779403104d753431101500f2d40c3fdc47e10d116ed9900e40e35f9934cd38ce70b6f9c1b055ea167b9c4cae0bad53a06aa7af8dfd7aa7f54936bfa967b98333c66e3b0c8c4fa88a8b6fee9a72acf44b6887108a9971c2ddd4c0c39c10d4762294919ab58401ded821c1e28c0e35a3fb38d200745e1694b7c5cc7d5213ac7992b69575704ef93ed51d5e5b34f82f028c7efd10a42377d646066441a5a9d2a166a4b911409144818c260a54414ff4aad60456443c8e72b30bfa16db6625ccc19ecb451812fb1a7d059d31508980736a18c3f2f2aa8a7e1e11c4354e89c8106b9c4c72c974433972eace2aa25d02e00b287613c2a83390bffdc88e9377d50318e666fb43ce67b8b9a38cde8fbf3b9e8316dd53ba9cf060e7f9a91160fe5d0bf42ac50e95e0678c1982b1ca7b4dea6d259565e7b056646e0b720315c3254a745107025502f7b67a43254659ce08bfb36752ce6e4091d9954b0b51dc18379eb485f56d7c8067a7f732e0328092ba539b50c8c5cf4364eefd671efea45ed65c146a1f0ff8fd5e4bb4e43711aaba64700b1cdba183aec38464c8ee2396db512148f20c9b0bca7eb9e108b1e029e855d26c8d7a149792abcbbfb2a000143a46696799706b9cad7fa92e2bfb4f6aaa397522a094cec82a9a48053c591d3757bbe8a9991a276309edc8803946fcb2341341e27f4f15f5148ec59db9a23301d0ea4c731be7c0d2f6b7d103a23faf4a42b47af4b9020f3fcfad476f9c9c8be9f5cd53bad9243e2159fc795048bc1a72cfd109ab8118cc3b03f797d3c96d39ccdcaf65b74f7d4b7fd8388acb307af1b321a9ebf5a022aba045cdd518626e78e5ec6cd4f1b4a6e1c61ea18a331472050fe9b323c6a6b4a664e5f99410482094f343b0b05100c8a18935eac997381379667bbabb1b1ade465c22812ff49a075acae083b985cfbc16f42a22006ff1fb9cbb5c7a71733768c2da244ca478ade96e86eabe6d0032b1db62c0eb69d6ff964e6846a0330bb0f68dace73e628e2bad128fa2a62708706c824c384203435dd3609a7b4df3533b88a0191a195455283125b32b4134d46d2190a229dd42e6f57004a6a6fa8407cae90c925eb6470617a4019b82cd6a46233855d7b654aaa9114956930d6fb7ca688f012c59a0a1723df05ae4447c405ab0deb01de65c9da5054cf617a51e3219a489191b419fcb59997dd41706bcad659cd2c644fdbeaf3c7144e977e69099ce7c3d55a9fca362b607a709042fedff9c29b2860c54ca335452ff5f3a0d8001f6e213cb3941ed8512869bd92a29622c29b316a6744e4de4887ca7ab28df218c114a2c012680a047aaecf8ad2714ddc4cf102e568e51ca91d782ff6bc870d5d5e9b5916507d40968bef516cb178b2fd33b24d9cbe07660102694623b12cd7ff926018fcb14eb1a864812da83a1f51daa3d3b92b2317e0b214da18e3a9423bd99a3b87ede77c7a37f679dba8d4a15c8853be9e41735f785f0a6e833a0bc3de79f3086076cb4338974f4df5d93179ae224b864b9177f6bd87841cec7bfd1d272ec31fa30127e2010cf1ca1dd4d2eb181d9c338a77e1f141aaed7f92a742f46ba7db477688a6d3476806907e00062568433b30690fb2f1659fe6f10755870cc38b88ad4a07a2a8b91eb612e7567b70aad361931ef548918340a0ee90f50245b58567c2ee6326cf845db136c6b24bcc76bd41863ff984799061aedf7b306543a88ca47e5720dde62608d7bb1e6082fcef925bdc6005641f079fed69ec65c6d283d71d6ec4c59f3b08c4017e984561a9abe459aff6bc00072032ffbeb8d6b59c13b5b941aa98fe7ba13c9254d7903b2d6003c81494bffe2c061b4470e5500e381f388a14bf1268127b3716b05a578690b911442f1b91140f8db0678fe645eb9e716636136f236f36e669f386cf7e3ec98e05359916ef10481dc12549f352a9c565587b999d83ca487a7388784e290fd3e2ff01848b45a8d5e5a523dd1d8a877231445bb7c1dd68ddaebd845bb0bf4b56a4152a8ad15145ac68f0fe5e466c910ed96901eb858e29819c723e1e7b05af10f807f40ed2cc44d5e6a833a58fa3628d5c7a4803250a39ec1a1767a7caa5326f31958446d0bf0e54a55abddbd1ee1cee7f73b1c1db7aaf32b08c42aa6fd64ed0dec9032469f134572aff93a49198c4f12c70fc953bb8b9185f704f9c2c305044d08f9a009761dd16f9c3a77b8574fb5fd837aeb7c1e9dc63436b5c71e51dd67243931f4aae81cf245a70eb527094e8bfd95a0fe35ce0a678f14ab0cda2e9ea563d36451e1888ec3be6375c133aa076922c4673bf7d97a69849c00828f2cdd929ed552cd318f2378a9454e4d1987153d33348838cae9e82631d4c146d8626b349ceb7d32eeb5de4f650ee3ce71073dfc74a013faa90aa04a1683ecb5a99fbc9320d9068cd332ca263c42cdaadbdcf312b8ac7bd0f8791f285ddcff118873dc519125fa42899cc6c5165e5fde4bc7877a087b87f0c0f10313196115db7fc3fa83934ddf30b36b759b7755c7aaecd46489f0fc4753c27c5cc887d0017c279a6a18a59d650c9c7f86482734698aee7ba4211e451a4a280769de6e532ef103adf8893d5c72f6717eace136c980cf02f520caa14a635b398d8c0282cc8a7f11c556aa3832c00e24710ccad6eb60627b799edec9933c047eaa7664a6b370e3d2585285ddaa6706814c6986f4d2c0f02609193319fb236fae326d0a3521941d1620457efce95849a3faa90f98ac23e00178e2e4f6e62c926d724ed76d28138cb59fc9f5913fc6e561f9691487ad1e581730e8c66ca5776824e2d8ad25f923b47d03ffb47284c7ca2bff0ec21c4ab62792c47f3498e38e8c48e062d07f13ea418838cf9e832eacf855ac8406355e00a6ae100fa06fa686a9e325960ea1291ce2173406a23b169f390f81c5ac6309ffa3d4740d6a463c8133a440c13b21a4e50eb0932931975e2a6364131552c25ccc7cfdacf1472ca7c141fe6d451c66591ffdc9daba27e07fa43fa8741c6fe0099630eb4e9aaf757094057b5e1e0f1d1af1af8354bdf740ad1c85a1b37180baa6f8e7b3ef67da30c5fe0c71fe82b79f424bdfe274f1164675bf947aecd4982bfb9d52c590090f594a8ca07e825d9a21186d4ad958ada45edffc134c1dd20fc7c0e1d0a32b5c623bf82228c19b80f1003660a1db26515088d627ad3ec0c0c1c4b810dd02d593cc1503cac93b361e70305ffcc57bb30c14c3a7b4792df2c39e62c2d0911e33632c17d7d47037a1ee1c421562c9fe6b44be6ab570c9116a5db3ea41249ea001185e40381fafa16ee3d3b8307d34feaf14b34ba0dda863f365050b93a069aa918e65f53ec54cd0d8950c0149fa56d29df06e3d6879dbd33b9cb7ee929a661482723416f84fcc7b4abec4b431c453403350911efecfa71b45613e64706240a7006891f80370a354a24aefe5d5c28447921c25e567f77f129047e2d6c5b2a8c2d719fb18da00fc7a16afc868757e81af5ab271781a1ff1fb4bb9d432df52e286248cee4656fdefcee22bb54288104916fafb7a1f0b982ce9bd0815ecf1e90b21acde2a712598503720c8e929b599adc2d6158790c361fd77d3c6697760090f1f2e9362ba6838275de25a4c5b422f170a544fc0a0ab8403a86ac0843618e82fad21dd26f157a6b502794062170f584a46ed97d05846c4a95d8c624798c4b9b01286d67943ae6fae88751bf106b07963e4bc0d213dba3a21e30fafda509d4981cde93010fa9fd4da85cbb947bd9b76ac842767d7d41f11fb254a9de4088fa5dd063e202a2b875378f2c762dfc4abd8e6abc9b12f593bec317f28eea0c26494098309843f4c6f760a3974b32a8eaa027e8fd6aa8c3a4205a97a0ecef7dba9ddf064748c414a758362d8b656c688db75ec720b8053110c10b6748c9533ece11269a937e3ec7d6a30204ac6b04702b379abd2c3df5247b72bb392e88fdc66f7693ec07aaab5a8d6b5e56d9e93f95a0736525bc7f85d9d132364c09f3092b0c1e0b19a12ccea85b3e1db56d60677c99d69e22fca44ab549f14438f0046f99952250b3178acb698d758aa1ca80ca8340c1dd6f29712cad4f5fc3f9d681ae25bd271dc1861d720a7c685de6284facea1945aa50c975b99a51b9fb01e51b7ef18daa2df75cada7895fc8ad9d6a745e30be84ebcaaa46a57924987d2a4cc3f74f4a05b19c979336b0277ea2194db35c65e0d14119d4f0aa6174dfa0a37c64d4459e8eca3d57b6b29030a318a6fbf7db2011f384d46059c9318b71f1df103f6551223e51565e0ae3fd8f60ed6fd2f86381894a7c061b6c9417f0c96a8eb6b3fe8f54d2b466d414c4b818ed8bd01e633a788bd9b24cc1ce3686db61ab03f4e2508f2c4e4f094d2f81ef34d0a1f97607c14a9b6a9c9d29693ff03d34c17823fb119cfc0950c353d1c8c80f84acc30284f07f747ad464ab62c219011734e5dbb7c4eaa1eca548d866da392f99a65ae3e8073f8c3228d19da0a57f3680b81870af69d401cb3cf0f0145bbc0abb98ecda2a68291decc24984b7c3cf87eceab995e93522b04da128d61c40a9d85c338126dfe2891bbfb0b69bc5da0d0b381e224d879728115ae62fea9db8bbd6ffe0cc2a3dced1af8b5e831b54a720fe47f6e136f5a01885d59d69380d7532bdc0453cd5c71240d50593924e10487c561458353336f2092b3cf73302d15e20db1a9a1008233bb95fe4f62490902f9215fed4f383a0fe29efdbbbbbfa5a303aad3fdfacf2012e9ce605309f02d58d77a507d623542aeaec5b4b1df02d6a5443d0dc4504d0400c8c2dce3554e634562a1c593dfe2e5081cfc5c55d27cecf635455181d41ddca60b4db91b00565d15963d805582ea31d11b7b197f7d135776e2904a6625f21466c934754f30d3e2ff844ded5a26e0bd652a5595687bca7fc93d0e4e3d92c5eb2c85e29f9fb5b900f528904c98961e217db546b96b6db2b5568c993323587c8904478deaf314c490adc544e78ed61f1f71816591c32574622fc2a2e93b1140cfadba7c402b7c964f4ccc32e3310143e749e5d8ca77d0312906e9ff29fd28e4f98863bf813a30b0259c68ba39482af02f34bb429f3a60db9f7c6a1e15b7d478eaa71016a22fb0e729d9b8337b7e0149f6c05cce105fe07d1c5c0642d5fc0d1ad78ebc5800c1e8169c167cd9f9f8b820a01e9ff554652be1f42f660d963a57fae8ab24733114270e159a22da70b6432a0e7007168f985a33ce3ba32a0148f1bdb1f2fd1bbaf2a96fa43","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
