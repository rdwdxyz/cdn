<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bc6918003f808933b1f4d647b43b611c4f69202788024cd655f70a439d610e0b011bf1bc0d92b74e5725b895af603fea3a38b173fe180d62c47a221ac8bb3284252b0c969907005385346a4be043de091c1c0d2473081687b7c49dab8d354aabcf70996ee1dd765fbfe13850d9f179ffaed9eed3897b9af3ae6fc20b7dc85be7fc64a6b2fae4025e173d495ba837b24aa3470cfd7b7990939581d3d36893a54b4165e34048e878817e6fe9c007e70ec58ed9a5cb954e6ed37600a67c3ebbc00756166399cf03e02e9b985d2d6f52a3fe49ce7dc973b9e3215cec9ebd3cbca2c2561502c9fceb5cc610fdd3e8f5ab9c42756e8fe34ab5b75725547c398f6a246d1151ba2be15b7c621159d05a873cc8abeb4e4cccdb6eec84ab8c761930b8777118548c8f0b81311661d0b153dc655f6cb97711b73f317c3d759a601c2c7eaf4208b9c827d1b82ccc90ca5556f8c6720d9e658abdd190b2904adbaa5cb1ad2d260a48968494791c4811b950b0bed6961a3c02c1b7e1a43ca7515dd7436c5cd6fadcb1c9edc7239de0e5c3d80bfccbc0ea5fe2474fe5065dadc6df3a521722de803298df0be5c4f95d6f72b41e193b4f6c90950d9b06e495a4ba6dae79b0f9bcf25fe3b63fe0c86aa32842c51f9abf6656f494937c6f6030e9d16cedf1c130785d6ae3853ddee7d22e0fb50f75ec520bb367ee2892dd505b13d8e8a763922aeed5a099a06a8a8f49327791498ffb13963a5818da01a1fc4920cefe1e12ab2b6f2398e5e04b9ab3862738803b904f7adf329a62e370106e7acd2a009997eb286c8e58a7218a49c28c1a48c1068342df44f8f24bbc7f4d1ddc77de844f6604d51706d4e47a5156c17a219f1dd1f14b55170374d801bb049e5321aaa6067cbbda7566063e893d16f8d6774be7d4dcfd93fd1a9a4657c15c970d6d755390e404a9bf1d41fa6728228683fc36244f11f6c0b36de4fa92cb87c1e77a7e918fb19bdbca3d7bd0f89e7e87a689364c4584a7b770e110b13890cec95292e296e87c8693c63649a799e23f0fe6f4c67d27ae16656e78b1f2b9af20e1a5d3cdbe2254c2238a32b7d747ad35eac5fd409bd59e5f0d449a47430ae59990997df3eca6bd72d54d6068b413aa5019ce6bbf163866afe04ff54539aa624ab0ed259635c6acd4615091905f1fef8fe47d3bb0b652acbdb344e6c7a3c6bddddc18cf67e7264db771ae4f53c661c065553771a4bdbedc59094f95b22c8c067367df1df8db2d402c7beb8bbfde49e839044fdafaf9d51f0e68dbfbabe0de7a53747aac42fcc110db9692f793504fc0d4ee8ab22bf05e6eec6491630dcbf8f8df5f301d49f95d0adab22099c38ef8c0df8b14d0088ea5df29f6cf772cdaef1ccf9501b8bfdd1bf735857de6ba452ac12120da0f184e8a8267cc71a0bd9e2b961e887c9b00edde7b863260af38aa8fb227cd891fd0cd0e26a97cee1abbbfeae3d6993a7bc6a56858cc0d62656d43c9dca5e8b4bdccc6324305c32c058de60142b98183bca9e147c84bb8baa3fc964026ba53e716cb1e7451b6956a5b20bf1a56c014286908b9e3d4a4b47e028d7ad25bf329ba39d6e483b841b354f6a00c68b7ea5523bbb4afd4555dab9933ba3b400643219d810e473f137a9f33e645ae231d37b4683d43bdcb20248dd4986a3694b15a5c8062b5b8505a53555c083611f5dc0cd7fdfc042e1a2978d54ffbc49f7b5e2175a49127815461d441a4a62a90d29936a7bdea2cb9df84b2a336295aed4e01566e32778e7039a9d7e61161f77359a60af57c7e453731811556162cd6f62f991cceb53ff0107c68b383569063b4e9c365dd45506a18c041ace1b2076e32fede035bf0ff495444ae91cbd783d8ffd8711909f2491cf319d300fe0fa310e4b07c19c906c7df9718b28717dbbd05653b5952c4a5b3718c0d6fcd4d97348d2ab5199eef678d31a19fa9694bb724d4005961e8b6bd2340fc529bbebb324b05874c314ec6b5291f79b0daa6ce4c767f4d1c7b7af680105a274d9b86c34d3da016945ec611383a3b99a39b59213a1f457f53af8d3c093fe9c8a33b491a85cd024ad0cf7a0c7ff4c0fee09b10126a1947bf27fc827a11512026334898595ec41e228e824ed06992b7125332bd07ab1d68a733c1c9b5c320ce348d464c3daa8acb9be969a143e5acbf34081a78020de620caa407a3ba1d317524b3eaa6c711463881dbc3e7b9d3a67b376b255fb4faee4da96ffb60d59e831e9413b1c4c929fcb1e559575f78e42c1a1676811bf11a6a96910320f3faa43f03041a80d3f47e6a94defa01e56f73357e3e24d16774b9205b49a58231a25021c0cc724558d8ee70482a494fcbf3daf0db3878faeaadd9c0d19936b9b87027dfc1011155dae6bbf5fa7e1d46bea8ca9b5c999875d968e35b2b67a744edea67f58f0b5e0969ec7066120764509db1855c2ad114cd042a202576a249411dd54206f5d5cc490baf5d14b906c14540458ad010da237e92e558d4c9199dcff501a31f3b39a3feca8876aa166855439d97f161714204eb07edb1bd50227b5ed049267945aa66abdd14da9896439b8d1b674f840918b36da4ff3fb301b1bd2317cdcf6a5d0e26f7e7ec1e15da82cb831275d4a04d95472e15628288863a7c00c8fe4b07e33a194094e30ed4b946b1db977b40fbe2664d1670bb1f7028762c64a172b5c1d65e0130da394464a27856b32eaa6afb04bb15bb0cb48532da858ece673b4b366b12a6fa033cd15932026fd7517a0e6fcc6855d3a8c4bd51084dc2f6c684dc4569fa3374e9155966257ac864b415735a84b0a5b8469c897f913e9aa67ff1656374b536a70d815242cef34fcb668bc199206b3b8a995b11aefafef961b054413d2d00d9eb3af4d942f0282930c1760d4c59ebd7e4b78965d414d3f5d6e0112e06095ecac4ad376a7e5e40bd000ca0350c09cf02f1f02f255357f3c54472c65ef6650d300cadb60850c3d3d5a7885aa0d291f18e0bc2b40f7595d27ecce89bb2f89a7e0a0905cc3ed4c5ad8e75c85a130be041f3f49950d095c8317531ccfb7d77c68c2a7813efe5fb712696f266d582531bd0d502d14ce68f78828891a9e0bb924de93c255d3810eeff14a72b5b95038ea0f2a3614a31458747ceb86c31b2fdcc96a176b4f5af2700b2b365b1c04662db6e5d4a562406d5489d5bfc52905f4582bd9e4c1715d16b57bdf8b41948229432481cb9d034e17d4a326e8563d33730b4bb445918bebee96fde9c206348d3dab348b251f13e7aadc803cb43a936b48c491a6fa194d2d23a38f66d779374f31a4d9cc4406e17efd7b73756182e5bc1842bcd16ca935d989f2c1405b98edfd17f5bdc41f916fb7657c8790a19646404378378577fff0647bb71955f77421fac2801fa7fea22985aa00d8a39643f8248af6ad65831091f1892356e8033272ce0482e0e7d9d14b5ffa0b4a013bd4e7eeedbc2c018126f2950cb9e1906a68c1363f200fb669d8c209305faba01e7be012c77e6a295a5b6b8b89ce253d2bea8ba93e981c7c2c5045468e37da5c968e10d12291722bf86015e5cef01039664cf18faa985d8da8d37875cb647e61cad215f9c8ee8ad4c608ed810efd910bb1cf2f07dd6fba3de99c39cd7549201eb654df2e7072261a4ed1680c73337fe274c5c0df6b0747e6ae9fd699efd44dde92c7c25167cd3601f7dd19f1cb103fe3323d6a49631381c5622bc34d33c29f28325c43b814e3a04959ae04bb2c9f8115a672f70c8a0594c061cff80b69b38e19fac918dc97dd6ca4dfe48b2746be44dadc129e156cb9e09498572148008666f834f04bf176677fa1218bc0b6c405809ade2c6a08f3fc47c7e55b418504f19827718583b481259a77956e7da9b52770c946bc5b97e58847bb9747f595d373f2e52033135c8b288ffd1b87c805f218170d7233c9aae8d31a858b8d3633b51d099281461c13fce93ea62ed2e30d5f31db2d5b2728aca9edca1d87b0ea067beb2cd9924daa0df1b85e841bbfb0de76f9e71643fa63639044cf6244c5d4c5a2fddb2008875839dff617941b5ed5af3cecc64cbe2bfa33e2bbaabd55d483ee7e06e024907966842b3d01230348cab1b604361b2f809de6daa2073471ca73c6dfa981eb250a6cff6d9d6cdb53aaef1b79a66f55b0ba952d78000cdb48c23ff8f25b766ef10a8b54ea6e26667b496163a65d883cae175b6d2b10d3a2629775632fedd0995d2fac70c65ce4464ed88d5eb9dea71acdf3d6517dc801f969cce25e53774eec73b60d593fcc5f9ab7e0fb847ded310eb5ee1993c234ad4fe32f7cfff87b2f29b70bcafc2cf10d7711f886e3fdb71b2a33ff2de454b5a4a2efae623e306cdd6d025c91763005c8e49f3845d5618be10ffa3e14df2fa32ffb57bd93be2436473adb860c3fec5ad58b45e43f9505c45bbecf2be4c862c9c8dd1a5f474481b4def4ca29ad30594a388bd108d33f930cb38003ed350fc29cfb88071993fc6cf36f961bf2f439d816a9a0b31d41c11ca72c1ab268377a7ec7895fc890408423b20edf316def81fe94e5b0d9245d772dff9c233f6f01aaa0aaaa857b8f49313f1369d7e7f22dc8524e185032213b8b3a0d77f6a4fd1811466190ce23a0d374e747d70b9dc04802a6f452ce177bdf102591cb9c8a413e6639d228885ac797a07b531864afb2426aeb293a5503d62b7b137e3a5be521849096b17391edf7de955a56631a6bc366dcb3db2ffd36d49ff2277d6ca5c55d7a25d2bd9c61d014b2af3d7c8f78e97d535e8e981158ec33dea18b39f027febb860520b3dbccf4cf442515a0a09c46ccedcea39fbdca18edd8e380191b12540ba182b6aa8562fb8e7b88b5f0855fb2fa8b78b4f57e79a6a4c408589f3bc1f1ef76127d07cc6e23c5d00b5f49ac69b1e9399dd05caef9d1ed70725523977a022b980e198851d40c4ce2e0fbd924b2c71d6746e25c54ed9e84c251dd740400cda051912a48638743e96c656f0ee6d5a1be0289afa1fdfcaab874254242bc68c4993d3430989d2f354c00b9b63192886c350b2b0b3eeb336ef226ce166ee7c801ce057bd3640cb33ce5ffd2e9a9e3aac5382b072c7d507cb6669400cd1e29a5626196c2e9209d42fa2fc023fb1e33320691b42b7395486c58bee68e5dd3eb3c95cf0d1e83b6b2eb09b76740c4069229c46aff91050dfca1906fb50f14a8689414cef4f93ce94b5c551a0978d24a51886bd8c980519eece88ed637df072e7e1742bb74375b110d284fc591ddbf6ec476aa100609edd8d4c70949119e11e97376742c99dd0aca8e9a551c051139cb42f4274cd4b8bfdbbfa0c82a6af9974b4973c97fec04758c503094f27dfc75c3270618397a25a540028a579a7ac9077dc2a5603af4c1b62fee24a7cbf47d9ca6952dffdbec7cfefb043d2daefeb3bcafa6109466029f4bf88f66a4cc1e7629d5c6e96d5d2654bb5d24f06efe1b32823a5f3915a3edd5f1615f40c83d691562407fd6effb0719f017bc609fa44879547b53e6fff8f7290c14d392c27dcf83c74e4affda74c449f77b06a2ae9f66c0ba3358c55eaea615296fdb99633beee1937a35f6dc267cc3172c97be3db7d58e7aaa31aafc8c97efb48d00d0afb533c9bacef0bd68c50cb078e1e6bc2b976dae3fdfc98d1dc5d27fba6e26c263e3a0f3854135298030ee4d7ad100d96db87e4947cda359b7496f664a8f704bc1e96a426149cbbc2d4a275d179f4d4b27df6481a0f075ddb6cd38a7007af69796b6c26813180b70ebfedb8227af2a49dc74ed9cb39929afa4a5cb25533fc6f5d265aece9fadb1261b5c2775228805fd5cc8211f8f5f6cee7ef63f9c83ea6b0099f4405a43ee432b9f27406512894306b066ddad97078efb6505242f897e4932477aeb8a2099b42c78b76b4de7b9dcf45a34705dc4b3e32d86347f30ea884d10294ca2d2ad97d93dff2099a5ea59ca35c103a963b88f633cec2cdc6c7a9898d66499c6de94faeb13fa05e87dc1bf68708de2c158f91d76fcd89a7604253d63e74581b5e130f2a190a6ae475410e995b22d4274a297bb3bfc776498836cf7473a16a4f645a4a641bf6897eff1ec0e89c878a353c78b24ae94fe49c9f3949a82e00c9830705599b9f951fe15a36b4957fa620062d1d45a66e32eee6edcf08f2166c965cc4110e495c96af00049e3421c24a5e3c0d5673a4aafa6b6bad5e54d1418b63b6e816886300d54ff61be8582ada8195b8008e549febc08720d1fd29735c5ddb1e4dd758a03ff50eae350c2c64f07e378ca675818641e9138627be1d216e968dad1d5105bf82d7037623806f231023e55ccfa46577277ac6b3e41b36236456b42a2514d19253fca7a2e9fdd3032f73e192a5727e9e459d7a62cb9c1ed82844e3fbfbaf1900803b547dfc1821bb8a858530dc1ea66196ce24078bc7a2e7bacc7f99345aeef28af6d6b72793193c6eb71d718c6f92a952bf5845d0dd201be41dc0e2973d7147c0f73335aacbe28df862e3c5ef84553c58960502c2dc80330508c53bde593063b348776cd7d69c5ff9008b57c2870065eee5e3dee5ee6a5a5182f6233ec2f1487487bf8359dcf3767e570d68de6345bfeea2fff89c8d0228cc5a38f6f764c6cd5ce9c97a1dbdc9e547bb80837e9385760a216007ead9307d385099a03ff37232a7378c92b31b08d6940badbdf58f4ea1ecd925a10c7f13d207343beabbcd6bfcdd52bbac8828f3425d6454745399959daec97a2030c1bd450594c9fa1f8b42906c91f1a6c6261e4c5df38e4fd214b300ea4152596ad450b57d4e5c14218727abf22473d2550bc37be58d4d25f5a9c212807917b7501bfd8f4b11f5309d9a1132eb6e45a5cc8110375af9c3bfd853233933a1130a9831cb9913321e9c4c86b54d2dfbb3e2b10e3f32dc059760cf61fb8d04ef1892452ee0b5e72fa546a445692cb9dbfb0803e0906f3b7b992bb6e600c632019ef1037b556813f354325f0ab2c0724e905a9e6be7150e65d9d6952cb5d0432ad9f9b61ad0932969c195bd03f41c80eee030e87c90bfce105898df81723e4afd676f1a48b7763b397166474f3f755d06193b6c4c33e14fe3dd8b2d84bdce6e411c4c2dfa8c91e5ed342f3fedd4e01273ebb75141c084f2c5f3f4736ac48e35527f77b1bc9ac31f4bd2e1a3c2191a577d91270c3798bc38c2474d373368746e7ba0224cb540487ec07eaf1ae27e75bcc8bbf48e48d938365df87e2ca024e72a5ffe90afb007772a35a635f591a78ab9fd065463052add0bbf02e721363fd4ad963ba7f703c4ec3f5e3320057d4f3d9e7e549e860e2c744a3c77d45a20a2168add2218c066b6564b29d8536051c6226784bdd09ffe5fcc3cd910797d749d1075b308e94afbd3b7a625146ad603dd7f06293da739949125b22268266d3a640dc1b747bb18b1e8a9ecfbdb21b414af12bd2f6e3c177d5ceb029fdb98bd4e09b9e70834cd56ae1359ff82593904e13ee3cb47e513d9673122517938b1a72ec10eb73dead25f3ea2d1b228a22022c9ee3f835fa9a94aa2246a99e2bda082deec12baf670e7dd7a029d4fbd629a41c98786425000bff8819fbbf54cfcff360e619ce5fad1e81a203efcefe224012a1ebebe30744c0ccf96c1ec962d1af15a4d05b3c22015c4cb49922359f976c41b5760dc05bde914fbf28a1f389a36b787976d18e839ed541417eb5d1bff3ad5634c5cc8b0aff16118d390b1788ece6b2b1801d17eccf14777355818314dd82b4ce6ee1adb644eedd3dba62834f2facfae7359a8788f2341651c0849c32ae7a80ef361fc794add4c9ef16642c3135a741b73ccb0c7f35508a10d141032d5f12cf3ae2df5911d0b43396ece73774ef1f2c3b651eae251d733c119e97f644740ca03ceadf6a2f419ddaa9b28895051219599fd0f60ff0fc78f780fec87ba145604bbaf688f72907392401c6eb7829fa7ea8567f07b82fdedf151dce9a53e84473c40517cfe1dde231c3b0e0bf07daf08975a6bc7beb9cc9abdb02dec9af15e9c6d7111b0c795b1bc073af47559612c157347fc147db7cbc6b2ee4c0651b749dafc065d901e2b797ea82b6ee490fbc9b717655e7435b7c948299fd472425ca11dd5dbc541f979dcf275990c51e2b7b6d63acc407861b7927dc4ff9ccda49e9f2b5633db6051c1f835ac970615f4949c63cdeedc9d436531d75eccb236e415486239a194e62376be420945808531cbf5e31d6fbfc5f586e04b38eccf066d677a5566b7d0bd299a6353ee8c6f6fdfcc01356b1cd305f2c6862327b13fb3c26c7a946373db7a89efcbeaef8513e94cf08c73a57a8eb84646128ffe086262f5a6cf6e01435f9dd62357140fe1c4363f3ea3d750fa38ba18a14657c7cb5b351e6cade6e606124bf60873ab4af4f3b3dbe7d8b5b19085ee356ae15da2e8f8561716eca9a97bd31cfddc61017fe53703c81dcabf585bfedc45af1a774fc0367bab945c208e971f244b2258d5b2c3e619e65db634afc04b52dd9569e6137ce095613d317918098a3bae872b0b638bef9be8e2cb523e2f6f16dc5e99fb95465a7e71b28c6e9396e8d95395bcde246f6db028587480227136426cf92be183fb0a06ad10af069b573a59c62127cd1e6ae6eab3a25828dcc185af5b618871f521236ad6173506a89990f6a588007be838cc4cd9fc92243d507084e6a851bb1ba26cad3a11ba8b5963fe1319b87c21a0993c26fbe33ce5884b4df982f4f04ab110ac7d5d23a13b539fba261667a520e6c6f19348a57d34a1a26955073a297defd0dbbf2917d72b7a6e4aaa89fa56440fce606364029ca5e25070471bd173a4e1c2fb15e804fbf81990e3baeb34a277c11b07e590bf9a42f02620c73bfbd528b63622b1f7f7425e0ba1391814fee07ee368eab23d3a703bd5a3087f20397f34acd2199f413fef6474c723e377efd7c0061201aea456848a3d0841dd892e15d96c6dbb49aa3c99107993cddced848ef62fa5abf02f776476fae7026d3eb09882c04bc7921a476f2be3850d521c7d55768ea3602834bfde7459f6f1029d3715d65db58d0573012d6c9ade534bdeebe595703f73d0038203ea396f1e0f2377623c143ff868f1b6c818564ece87b9a0b6124e410b8a6daf8fe4712b14f50bb69a9685e2af62d4f074dc180a97fbf00a539a1bc7a20d94a24acc18e9bf9f3b77dbfed51e2e3b4ef855f9a26d06cdf89a911cabe10e2ea248e5b1767e6b4f4340dc019eef23d2320e359fd3dad99f9b7df18c7e4b579b1f297db54e27055b3e3581bd8d9b13f259dedfe5f019788e2277e6c0ee7103290aeba9583349f724eb64ba3e7b1ecd4c55f399b6d488bd5c1be2ed440080d476c28431239fafa30cf27b7cd748e9d67b66210e4d05cc3783242caae6d0a127a51193f51905123bf40bb943753abc441c4a233070ce9254c2fc358c7c41168203fef2288b04c9ea322257fa3896e62c4fa11a66a08b3cdf1a25244e7c0e9c1a4099fc1ad79abb9b3408a1fd4399fa50ba4fa7f55c8ae5dba73b75230262cda76a63393c34fb174767115ab68b0269b3487633ad424b789f7a9ff3d17cd0ff227e5f72768451d4db3126f27687fcece1ebc330d407e697c56f251a83d4335c841b74cc031d1184ba122853058688d153625916a8ab15bf3a7f036543ac071dd247d29d25ba52a82c578cddf343a4d18aadc3a30a021c2231f2adab33d624b44872b51f8edb0f35c81e668c45f80139a52c0709feea2bdf93d1f74107c8e7f5c874f43b6086bb931d3f78afee92e976a8a71ee23a6d2374f2ccec6156f88c76d6a5ef5921bca775a061136675cf4aaffe4f04d0f08d121a58410a543eb82ce69717d147a63b32f10b284bec20bb59c094d3c654f4fdc26f6823bcb08fdb74e34bdbdece95a168154bebc198c61c1693efce0ba0e5e450639a1f7669d5ef2ccd8b30b27b263dc7705b527d18dfd51f19a20b27c84007825e2c338c8b206e14bf1687b6ecfb7d3b8aeb4606c30a6e833394e21150109638a4ed089b15dade4a5a4146d2e8f972da976ea38362b58f338b383489f1b3fb275d7277553a769a2967b7fbf9653723f8728f0b82da74780118ae325f0011e3ebae22e893b05fca53e34d4721613dffcd09c935ad4e0c7c3d8479003244489be8ad7670953ce897d1793bbfc9132900d7374b93d7edc21727140f2d0664bc3aa5f16d4919187e3b6a28a333b8c1f9d0a3aebfe92df6f9216c121e2f092fd5cc328b24f44981e6ff751db5b94c8ce082a0b0c374bac65cee3025a5cb12aea2bf45eb93b9c8d275db5231ee5938bcfda233d06e0490c4584c5923feddad599c60029b0773ec27e1164eb64906e813ed9dad9b1e052427cb9622e05cd87853ad602706dfa3ac7b808249a213fae4148157c038123a7f70e463c3599ccd857b552290ff712b6b7456c55ff7e7f80a15edace9938f237ded5974f45235df9a5304572435395fe027a89f178564692e65f2e5062fac41cb9b2f84d53d06ba40e5193ef4e4cf91b81ef7d34d14fdf2eca85dfb7f592bdc7c0dc597948cdc12c2502374828ec545f44888f58621d3d41a203e7e9d5e7576f9ae3116758f8df4cd69c9d9c1e6f0abfa907921d20a48a58523945f3730623098b0ade01264fcb7d41f739240a22777fd2bdcbe82837f463ce5c43cb984193aa0391daa7082318b80db52d350b353753fd7c63c9dcc8fb9fed56bc7969f55c6829b853b7edfbc167aed85c9198f95e2f4c16dcf4c93c84da641ce0ef6e29a5cd0e91f4a857a027cf38c42d211e032b97e9284d8a2091a81424e3fdfcaff763b6f3f7f27e82aba9a98884ee01409d5d244b55c5c6a8fccca8b8264e6873b60c3390083ec80444eec488abef6cf4185f09420a7860a9e174058227967d754e4d2bcf2cf3133fe99eb07d1788a8bc0af58e69f28390862ed66c781874b476d014c6d67c6aaf21db07fd8ea4de7b51c0469a97ac66b1a12c688d1d32d4280ae7a4c8b41a547882326be9d0924ce28ed31c5877465da7ce96556936a4c77771fa34761f770e79118ab1f5b586efbc6b1d44f860b211ce48ed1a6330e6d0a2635285f69a149bfe369f73f4f9023ff7f24ac8eff813c0ec9cd54836a1023eb98faa59955b78da08b01bdf16fb9ad4f70df921e2c045b0320726e1f34ead408bd5cff35f4a3785f9269ef60d38e13259cbd3216b0080755282a3f373caa1eabb44030f682b2cd2a4d149d76ae690d28b9d7e2849e4ecb0c92bfc93f42019b56185192bde1ba2586201ead75be9c42648d91db856193bce689ef42137c773985e3e61f95fe5d0d79f89644f0dfe1296f00c1dd77a03f5bfec44080939814ce0204bdcd6e42bd5899202ae1884d9d2958f34076981029a09a964784104a5e6aead9c8c0f462f5992b837cf86d2e58ecb095a6c1fea941a8aeea86173d8559391adcabddc4d1f8afa3beeb687d8113d26eb8a2c0d30470e14790fc656f2560dffa32487007444e2a73a720072ce17285d5d2e582e699b4038778e0405cfd31e417e995aa483e719c9bba292778f4e8b231c92a83a14324925e75a856016ed8941a1ab9679706ef1c2e09abad861afe2fe26d88157fc24ecb48acc9bae3dea22af145403f693a0aa1e7c58c1a37130681ceb65b8d0f4233b461cbead999ea83bd04e56da982fe74e28c727ade07175cfd88238eea666e8d3a3677fbde07d4db910d8fff86808f6943a3dd4dbdd4d4f8ad36aa29caa7e4451f452c4085ce0be2e98d46d2e05f6ffeee091474c24629d6d13f5fb73867513a84803bee0214a5f3efe328146c2a16191b92f1933a910efde5840d3d004e9c24d97356a696f12b545810307d4f87edaf0c0759edb02100c80a1e858ced2cb45502675a577817fcbca140979a97bc6b431ced664fbbd307702628878a28fbd70493310d2ba32561bd916ff67d5e2cf31cdebe8198af721f1f896755449476c6530d6cf009bd56b99531edebd93c3fb4e3d1e297896c051a3598270212ecb69c00a2e4af425426c1560316e9099fa4b7ccb94aaace90358730929f98f8e07e1c69e65efe68ccd45fad030d3ad1dee2bcf02290ef77b1420902420a2430e8aef23344bc27fdb54f020b762bd656b034cc5252370269d191c01d8262fdd660994d67e8e542822d056ce9ee17476bcf7a2a05778c37f7165a83ef0387810c94824706598f9b5f2b6d1fda0d8c9f805a08c388c17ebe22ce3949196de1ca5c2712d1e924ef6f847b170dc7d4737cc312cc1f07db38bf3061648bcb3d758dbd7f96a34fb67cdb8a7e3c877c17f124d3009f1d193c7efac1cef297cb3daabe4cf8fe723f31f61c76a2c3fb0543c14f0dc6268eaeb03ba1cd6a0822d054315a9a4d5fb73504851da0c8c5827e5427292d479814c006fb77bcc253d3b5bfcde373761550a58113bf73380eb9baf2b91bc2d179791f2239edf02acb4d001ab4056bc64fb6b767b4ebf2e813ba6a9b34e57b0eb8e34662d8993f90edf308911f0819984ffdc29db20328804f29bfbbae68f4b8eb0621004e56080cc84994c0b0d6d36ee1ef4f0966d3df50180b14a3c0fd940d688450b16d7020cd513e6000669337ae48c16734463b351d6993133ecb2dac71608b29518cb800a30c454c974bbff365d8716b7fefe6fbfd810698212f2d27ad13fc48edbb5606631db01061fc4dca35bafd60083f55e55675f2f5f9a04507142322b927d849632c4a7683fa6f2e4f276387f68f65c8e43cf01dcae9a5fd8b856f933e4b0f7269d5e9be685096109849d4080809d0bb50ab9c5f4de233c247c07749e773debc7e62575bd47fd1ac6c8412bba24f2c8e7d1c0f6c9b37ab1e78728bd7bb4c079879f4e14c0dc4b655badfa32ffcd1f3f22d3a10b64879c55bbc8b7b685d06402f18c49cabb13d78beff196f4d0969f166deb250b171351affc2e47f60da9935818c4016d08ad392e6d6cd51fa7b0dbe6e49e728c7a4a8d3d1922e9848bb76d8898e53e105863ef9d1ea8fee95c874e23465bf160bc97bcc3d37262278d06b466e7de87d0e46f01308883e6c5114ad330dbefe0d31e2712e6e746dcefcc7179905de927ebbdf758baea1400513099773c10c34b978050e1a67842fd9e1424fd9f5f8fcd9feef96b8dc6d23b28075d9cb71103d1fb8af926a665edd9ad481c97c860b1dcab79c23d33d01f2e2da3a01af00dfe97871606aa006e32aecada6d12789d78536343608e207d991a7c8c540b2a7decefcdb8e4ad1fa6f71aa0d42dc6d3e947784e951fae26b8c2c7a9c209f1ca9fb020e211d5b4b54441a5e45a3f1c113dd1d01f8f3301bbd129558b42de70baa194dc82cd0049361268ea8283fe9723d3a95b1f473f55325da2f2f81adf3cccee22d5a7abfb0e01d564999fbbed36a7cb8832a43fd3138eb11d0a5416bcf3154daeae4313b745a1eadc1fdfdd91724811a525c0f2c93a503a09deb4d87d6649a1e50a4ae87c388d1e6200289f913f9f4ecbe35053d236afd787730b4e1b7c16f2d5b99e76ce4f6d91d1a90a10290a60d7c35e61441648fc8cb707b1feef6d2b47755545e3ecfa3c375b8976157ad4a3c24b7bd0025061d440d1ce83e9999e645cd150224f3c96789385fb4eec1ccc06a109e19b064992b887415ac482d28cf4c9ca61d23b40d0b0d343c9e8d38fcdd6d0d8c87178647b909268d53f6392119aa55f1ac36aa097178b027a9023cbf45dc6b0c59d63902be047c2bd4b45b99257e0fa003a745554f8c2d2cd4efc6c6d1ccfe7f798a28bdfd2b4018011882add9936bad0fd896b3266cfe91bef93e788df939c955bf1096eebb136caef8ec09e8725f595458dbba8a827d46a4666ac313b929daee092f850cb555b61de3bc4ed99f2e26be011adb909e0412bc4284b71fe05759e24c2187055b22caf83db3b7d83d96334fe76e6101359abb89ccf1560246b0e074a192693ffa2587a58311c79662867582c117aab6a73b9724d60b0879c41802e07c0ce6c4d9dbc7209e89afbefe9ef53b75f6d77327ea00cb7134942d09c81b809c6d5a25248b460cb42666439401ae85c9a5fc954faf6406661bbe018475cfa6b9ac1bea95f20bea8f431a599f0b304bef3b753463da1b8d196b5ce60fdf4d1d3016363127097786837274f89de15380f0cf1d5c7d2006b6f1ce10e2a58c9b9488c28b6bbaf7f3230122406d0b03bf1f539e63fa6be95cf36babe4a0ce0fe36d081b65b64e4ed771ed5fdf9ed7a67c3fd02df70935ad515b3acbc2ddcc312c01b9a07130bb8b897deca2676fe953c3a6f0767cbfa7e31c719c7745b45d4c12fdb24bd0fc1d61b03f8a9acdbb5a60d700d89d92968b169220f085319251d0aea0d1384d68d1209c446a5050052086c5f6a8d59211b11c7b6a707947a847117afeec6141a73f8271815f458f8e21c005e2376263475fe3d70bbee162acf59a98afa0526e0cff1e8797241fdcfb537bf229f0b8109ce817fd12865317f2242fe06d371f93daaa9e5ad343ef70d59d3a98ba8eb24483e6d98deb015803fe83bde7c2750bdb2baf30a5234b7b6d3bf51a40009bdb98c1dcfd29f52ecf8e0d7058a7bb3a5ee20d379f08ab6f312df87c990bed6567056870b2c6f2044046afbcc69f07939a74a33cb3147554afd47a74225399d7d1ed1f98cca26201d9ce72b82f7cf940a150b287e3fb5b398e52a66e59ed640089dfd2d764cf79b0b5bb142de950d1ca213c5d0ac23f1eae8f5b4615452d6a7de038d12a48e1d13f1e33f86a4a0a4c9d381ae05dae1f8d171f9fd038b778a22cfb4ada10845d537806395a27c763ad95ca25303fcb1a1feebcec373086b4705c61695b4502c9ab87cf63326af969cbb8f13ad1301099ed7153a00f7315bb747a09275529191fce540272ed98b47c01a5aa558cd4660ad1637029ec19aa20016b08da964785b8d527be8a2b566cf4068bdc8367971dc858afdc14dc9904e93e9c938c988a87d90dca1f3f74ee9d90a5667e543de01dfe1d70372e6b5986849bc4c437eff60eb8bd136e9c39cc715e569b69f25e97b818e74334dcee26cbd41947df58e7c77b296f4e429f8a7b1295bea9deded40412f4da36","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
