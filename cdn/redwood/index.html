<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"28c7fae22a702418d54c9713bfd2544d0592b7f8dbb1e478ddea323b9d5752d75cd1fc01a033af9ff93b91844df192c4df6ec84e006b9185e120b6e7f8b1914bdd77d62fcac31488c56c4ecc378953758ac45b6593e9e01b8c686f5bf88e1cfa8b697e8865d8ff38a67f7c490813f4995379e2563a8ba7a724651b3db64bf44c4f91e3f27de0ccccd83d3bfe2f08229ccfaab1e583af19712c48074c96f35336048018cdf381aa49b2082a6f40d2dab716b3dd5410989b7d1990ae38ff20f8e6d632bc1c0c9df97e6c0d1419be98b469f7d8a7bac7a4fa42db375d1d6d9a091848d831a842ed16c9d2cbb0cc3794ca524754cf7970d422490be2c10b0dd17b47ae1cb4d6fc4eeb9a6827110ca50090775b95a5e41fdb163b66a8b35e153b8eb9fa92bf732102992c8451865bd67c0d82029d8d50d464baf6042bbabf81b96ac82650e190252e3f974895588b179d07e880440584ef592c3a8afc6a3a586597c37d5746c9fb49943a1ce5d3d4e2fa85754dabfe5bfae2acdff16180c71a9ae1d5c429bb5f4dcbb758d957c212b227ca2e354c6c71be419aa4ff52ee77c6d05f38fd5acc1197932a4f04fd4f74ff32bdaa160a59635a95d0e053266794189fe7cf0a534a89c5ba91004ee8cce26456a57bbcd6d749ca228e879dc95ca165ce15452bab9f5b139e6e4828b2547e017db6bb337cbaf1a66efc95635ccc53158c52e79305e3afccfe284d0cb3624d378ef591a8f1e0876ca09b6e7780596cd0f5fde16ffadfed3962f104469940844e6ea0d6a996ef5caab1f0e57957472379526e4ba13624e097e8a87e07c28ecdcfc25c514320bc894532e39c73674084901ce7e3ecff5cb1c4043d1070f10796a01489d967e453780999a149541d970a6f1c94c2a30e44389b3a39afb4c7b0fdbc44ab481b7c1bac9e503edfdc73c003cad6a8b7a445d55b227461ef9baa84570f590e846d80d5fea4128e8dcaf0b654b483dfacb51f74c04312605c398ef7f302dcd91555b2dfbde7770d2901f3961ce78a26a8a506944cb19fa0c266384de990bb845fd13b986ab546b880151af533720f2225078979dd0da993ac822c449b4b71bc4d92cc7c23e3f82b20bf3b629f02898e2998a8102be4e68b132539bce1c65e551307eac4859b2bee17278a8d668c3b757de906eadcc70cca630512b64128608dbf6c12b33ac5a1471d2e67cad7ffc08f216a20bbd4ce69a405bdf97dd1dae87bed8364c2cc0c42cbcf4b89aa17abaa4bb40deed805ed92c8cd46c8b881da548b6dd3e9a2b719bc765d58c0661caa8b718d7048595d4269f09d27fe8d7694ae691b72785d799089ebd35c2075723987eb66bc6942bc1b52238d2f657141f743bb0f78e08fcc5660db447f473f462a970002bfee6bcc3861c372e224b608dae3da9259e52c45002b9c8dc2c25fb79c2bda2278d1edb43d4435be8d2f5c473337849a25894aeb42c7a6cb85216490b0e6c4bf24fdd9f1b017b1db293e08a47ab4da6731714a2802b66a7fb63367da886de114f23efcd23df0b3ce0654f6fb56127d8462dcd29d8cd3fdfbdca0e21c724d7d08154bd083ce8f62655ab19463ca5aaa6693beea49f644236a726c14002df1465bb95a49ea0a956a19ad340c675a5ed81cb1e7a2d95d08b06cea36d7fe0a52312fb5a612e8822bb99f02d46f1154e6efb161328bba90ac778774ac5a44aab18c33dc34c2ea3d1aedeed3193d57d188c88c5993d2d27b1c7dcb52ac495e9d9bee5287bd155b0ab5201f3d9def70ab7edd54de460d52c940d386b23d0611c78c121772f886fcedb48ea3f3dec41d8b63ca98c1e4fa98aad5fecc8c82da5afc433c3ead35bb9c5ed0b9946d198043a58ef62da6893f8b49b0dbf9a79664c1aa95a080092172862e9da991c1c3e98c9054140e00fe8d2f1f0412eae33d82818e7865e59d7ad3a6db7e9d9b6e71cc914c3ce9ef9667e5271ae80030d803226db85f156f0404434286d96a815a25e88208a412830c32bf4a4594bb0014b93182763f2bb275a26b66f63d635e7d2b739daf2846a92ad66ff38f43ddef34881894055d9c15f55b7e8fc90c75d2799d15af4b2169a6ffdf49fc90c7d18c3ac771a1d5d3a1d688a73a2b14d4cfdb07dc657dc2d82e50d23ed82f38d2e0770e5adbbf859df09024089e9250332f18be8af96d7a798e08a764f6394782abae1d54783ed933836c912a6c4a9270f3b7d241e4b86fd018dc313928660634146885bd062700660f6cec342e27877ad1d9c2f4e7bf024e57c3c9295430cc92a04eae6b310947aa97b562de8ff2742441281ddaa6349d54bdee0c9bb48bcd7d6d7aa68b19a8e74a23345037eb7326574cf0b812ea06af2a0c0c67e4f029c1cc3762d04946ee23574cdffc674f791e9dfeae05979df7d6d99ef1b1730d7cfb89cd5e73f517972072ed4afa0a01abb9200b979a399a4759fb93ca3678cbe88cafe94559335c9727cd01b6597659a28cae5ecb0d94e75092c02ea948db621efab16c027c73c001f791249a6e5a7f920978749ef0326790b6303afcd868992ebc03056c2bdc80f0222200f469068c49125844e2ffeb3edbd0eeed9a1e761f22ee585c6633cf39f4c7baba47c8fe51099a0e8674cb0e97d4e581746186583670caad7271dc3338e4165abf9535e6ccdab5d8b09801dcd99a540f2f8e445f74fa3963ba1f6e98578c1506f4755c54c2a802892cbc35e091c2ddd0ecf7cbaed080c05c96c8515596b5d27db09a0fc5043877544e40407fdadcccf2858261d5363af863147188f431bc1934e0237c9cf0ee1d5375f717808e2f124cfe36a67a518449ab6946501398f0e8013e1a2bc69fdf45339064b04d897eedff3318deb199d3df78d7bb2db4ca6f9b55bc642b3e2368ac52581f960e8742bce9dac509c5dab0eae2242d025f20597047fcc6a3f886ea39cba18ec495cb8d3fbdfb7af3a4062eb5f891c50ff9a8784f9b41db8bc3b3d739049a3f999d492b877b21fc80486cfdf86f5e873fe30b7d0dba8fd31a5889f7b1782618de55eb3a0dda1357c1f65ebe91f9b926ee56d87fa04b45a6cbd656e8eab3860609f70e7c45ddd7c768e802903a0158bec01671a34ab1bcff0e27ed891fa3769eb8a7b9f0485082c0455fc67d39e28aeb75e2059613d4f246228773104c8c6c6802542ef02b4c398f53126832fe6670d4ff88742f2ac02a8f441dabc9699176d458e76932c23757c232c62dfdfc114888a25cd7b11a35969c900bea9d728098f4d07560a305a68ffe8030297b3694e504ad5e922dd37019aa2f3137dfae1ed2e6cd9c23ea5d5f98e2d9d8b55102280d767554c0b8e84cef891a14d2d41ee940ba2ebf244308a7628cc3734bb9534ad3e15ba4483278a76a4cdea8ebd16ce6b4e3f41c203e4749c90ef7b5d7f5f16a7d3608173352ca5f6debc84dcf0df23899ada0c1d5b88d8c52e3dba0a6898ae39efdf979c3a7973416d3b96e483c8175927fca3b272bc63a1cc430b3914ac44cd30346ec0e2e1b0902d8b3894ad52d450a1d89cbd271e9819f316f98e455e763290c6442d72fdd95db5b5402da74245203c5cea84e61ba1dedc69bdcda2d672aec1fb98de6b8c33416acfc078591455625287c515e19c6882f2cac801baf9853b666d97fe8fc2b6b5fb568cec7239086e0a31c1108bdb7c73682f095373449c3ef2d140994bd0dc60e69b28888055810b1506bb0144af07ac2a1bee9f8046037a579da899859cbb125d13cb49491520dade78a721f8953ee55ad4ff8bc7c48859682e2ed7d1721bec0fff54c61d34f250f0e08511037fe72933c40c3a9f39bd5ec35049fa5c9f5f5f2d93f9276af91b5a05d84ad97282577abba5567f070f834f4d1099ebf3970903cdb605a5bb9dfbef0e3173a0c37dd02026a9ccf0dc104bdbb95950dc02fefed7a25388ef4565fd854c9354056cf94b0979d87f9f40fdc6575159ce9290e72196b5b094bcde2f252c8360f4343aeb195abf272ecc1df30d205b2777e283a8496a8987f8c05fe1aea99cfd58ba147cab4ab236d20199515869913f56bc48003f28ade094646c9da241e586248f99da8d2e0ad8440a831a1c614b96af920f2f2ec8ae5ddcc892a971d71ea65e91aa27d6fc03a7d9af19e2298a4e737da636d5c48771865fe42007fd883d8fc06f2c543e0e65457dcb7aa9bc7423f26963453f0138203fc2f2ae92d8c41a40002e62d7e7d0ef803e7ae094ca86050add4c8f409a88496d7e85acd80ab23646274a3f9183186901749116c7792a3a3b83c8af757048e644377c786af094ad24a871e9226c6a1dee3ebeb0175e5dab4a92ae2b1d35c8ca7993e4c7bf92e04e7af9b26cd90fd173155b6d4afb40ee57ae47a229e18e3c8f0d2006c599abf709b603d899752a7c6d7b50db5545325f60b30f174c411129feebe75f6994fe1754d8ebc9fe3fefcef237ec35c9da2c9751ecf54f62847dcfbd6882d2d9f5bfa321ddef6be36cb972f01b7af7521c71daff5dfdab772cbedb0bdfb58a1487addf706c9998b7ab3fc79d6c1db84a4e98a9440262a1375307bdcb4dcb414af4243dbb866c3354c5886690d27007c89f3b4a0d659a7355859d3361a028d70689081ddbedc34812682fb121f111ee6a8dcfd8d4adb6d98a4e0ec0fd5a24b9d4590375a0a59627e2afed5b0493747d795ea98eb2c53b00f9bd88621f383702387cd01b9db6028caa6d2b1a12aab272b91784f8ae0d72a4df5da716128437d7b4026fe5d3571c6b220710e27ab5becbb424288eee46cdb584c6bac37b5530aedf475da5d662f306c4b32d2f6f955d79ace3cfaae5eb77a6c2aefd43543ccc043d262e7b3e108144d9c8810efac3bc75ad8b31560c02018f7256fb83ad4ad422da2da92867d22f21c741426fc4c2cfb0aebdb381abb8a49036b91efbb147c5b9c285d87bda5cf109c5d9787dbeba5527a0a60309234083eadb54753a4052e280811808d3ca8fcac27b56108abdeb6cddf64445252064e6032cb5fb139c9b1dc50fe220b542cfc2a20316c610ef43cf003a7ccd8120b0b37f1fd47207bc6ff0721bddeab78b15557a0727e44ec13c9f173c5b3718dca9183536b40b520acc7f79e24c779a93a86a32682e9e6894dd040b4c7cdd9e3eeefd33829d5270350ea626d57a115c8d0c444dc31030ad8b04279faee518e472289d39f5c02d14accb2d404122f1fbf223251931c9c8184b00b04b7bffa28ef19974cdaefc85e598e554c3e511c0f5e9a9276fe343739b99c19a0c54f297ac3dc8bbd56421d0f2e06b28ec85fa455cb6fe3e72d5c93855b3c2865c6e9ec81c81688702a71888343c33f1bf992d653dbe6ae6bda5c14b0cc816f86470188b91c76cd782aef3a8d74b49c5afb9c385d6a092a025b4246ff624361891a70f025a33a24f815ece45db9f91e3b14bc3ec378313a1d66574a6f930325ab8bbc9693d25498db271f6e88d4ad3093007bc96f55fd8bca5cea259433d7c3809034a2ab5eb2ccccefaf294503d43e4520821a153fd5f184de19cecb6a0b4b9094389931c0b900bb301eb514d543f0cd58c89b6e67f5ee155cf77705f961a0164011cd3137dd3288ea0e42419fb889ef7157cf6bb5b5e1426d59a018a7d5dafb889045649e67b2d6f6d3991ecfaa9912e48c50b3952d4054e3cd56311203dba16b48c65eddbb921f067a4f56226e0eb432ca89a3ffa07d2a4106928c8d7abf53e5946a44e43ede9b660c91bf0418b2a3316fdddea2bd0354a62776717e87e4535dd4189572b9a9fd35bea5f0bef7420508986dca210df61e26b2b75339f388076d52e94c106bd6fdb04f70bfb4a512e2672c14c2d07c0c04b70bd83ddd4a4f09355240423be0dcb301f3f20e5a9ebd34ce9b48fef204020d11c0ec4674b9353ae9845a6bfebdb9c0511bb42a2b53ec336217c3019b0667e160a25ca83acd10cfc128a155676b40f97445c43e1e3cdd2210fedb25e9d408ec45639afc4e622617ccdcc69277fdb28472a7e921584605baf59c7d91256ceaa0a01e5835e3611c3df07b8902e0ba88f1681ee10c25cfa02b23283dde37bf2bda1510c3a96547a6651cc18ee56e4323e85c480efe5ae045793c04b7c88e1a616f2420dd2b346dbdc27d169ae1f880593f44f225e365eefc6f1e2b3d351aec9b639582f78fb3f79517cfd22c273203099ace4150109ac0350290189f3ac3972b5e272ae8f14def5dbdb43713beb4ac1d383b43a30c6fd25430fb26f322e917510e89fa5e34b9722eb7c8a2e77cfd496da773a645b11bf36c00e9f44232257e007f67bb68ea2dc56f30c02bed8287be15dba33fab66dffba47548c326fa2b15296e462303a6783f4f93eee020d980f171dd35a6d4ad724272413617f2b95cee71397d09dfdf3ad8897d3f8f0742ff1e8121f31ad114475e9ed74ddf48b35b1db18917c337cd2c9235fdb49dc8baf0a5662566743e2f9297e5cea5085ccc34a79de9cff426c90f3e5ba317763ec18668071286147a21b17a4d4281c37bba309ca1ec210632dc2557dcc8426369cddddf0359164e57b0a63fe2e22fbf937325eb63fb6ca9d7b57f9cebbbcf42fae1c02466b2aa5fd86d7309da3b59acb8f4c87cb5c0cecbcc754288519ae96031dbbca81503c03786b75dee1b57adb4435a72cc26cda558344b21f21ac68932e7e1973e29d436d18794604f7cfb9420f7e6fecde4c8fd2c1ed6a2453a70717f702bf3a9ad2e336ccbf07d9161e767f7dc18845d2e9b7965317fdd14631d0d6e502b4ab00a136261f779c1f958106a667f0443d06856747f45bda6c0e79656b84844b27ef261b7191c93339828a0571fa43416a3386e9c621675cabb2f9465ffaa311c55e0e25f21d7b742bbb8a1df0b7ddf3351b7195c913abe56d1eebdbfbb87e2a0bb34db610c53f50e4353187ad9a17d88a6afdd579b57becc8864d7faa1963a53c8387520e79a565ad878c1669fc21284e3b25b8243a7d067bd4084e50c2f11de74cfe9251fcaf2ea46845123374c9a7a4014b72272c3f868bf7bb838e9ee879ab99b715c0072cb2298f8e9667cdc5b192532a4d7eeabf17fbc9c9968302c82c8d53ef6cab79b3576ef0203beb88961498f76b546b0abb18c14aa555efeaa2439a4ed22ff5b1ec8058bfc28e228a977403c1fdf8b3e37ce464578aa0ea2197a94fabc5be6b2f4c8e69a307727558570ecb99cc713213bcdd9fbb6a7d08ca9194c564b25e66d6fca5f3c13bfebd14aa62192c0e2b279d2bb2fe855d1319e8f08bdc45cd0d9d966740535b00fccc6cb8cfab8491ba1bdcb0334832ee40f2df6c0482dd3795ca17ec736be061d30dbc88ef58129a6921b93e5318a1d8f193630f0670d46799a3f37d5c417fbc2ff274d4351cf357a68dfe57dd2c3d9df75001fa4aa92425995b12cd1fbc2c253f55a5b069acfda69ac2c629ea890cfbf869a1961bcf555b24e91ab58c01e86ee4a73f883bb89c6094fe6484107959aa37364a14c619fb0e7507ef3864e3ca9c71b2a7828f7083664ec77f67f6b3c160019e047b3263a86b72c99b969bf81798525373a7b5948c4c3bd3e138141bccb840a8428fbbe1582f74457b3a156dac45c8f2fa787cec5ddfb1f66056d6e05ac27b67cd90177eaeb58d4aa9ca18dddf162a2d320753f8c372e4df26db302ffe11278f03f0b956b182bbe40c89522a83d43ae393cda51bd04bcf52beaab944bfc351b58181b274621173cb62bac8b21804475175725bf064fb3a00164b41bddb6533f321e4038220590491ea089568df428d7242b0f0fe477840336b018c3e2ad0efc916f4ceec871c9e2621bd12feffedd3dd13d4faf57e882bc4864a0625865757e0f535357bf4d7331a1ad7c96ed215496add43cb617a5c5a401bfd82d4205fd36821123ebcdae2742ff7e337736793528384d92d05205b423f0cd1fc10c916d1ad4cabe85164f0d93acffb2505108932cc0839e6db130b6435ab6f5909dd1517e7de3ee93dac66c8a155f79c81104765f460fc419903fef13cabbbb83f1228a8ab7eb0a6ab53fb25e7cfbcf2d2e4acddaf77203c66f1dc39cf20beda33a10b5a997606a5c154f30e8e7477dae805ec45b2559eeb51f1ba18f47465f3b78e2698656c220c575903a0df0efab2890dba452a2aa53a54f035a77e5cb83f4f09244a12b49bc95ba285c426810df236f7daf8292a9967ee4e44b6897a8ee22506e36701d553998e262de8843a9599dca647759a7702b747f21575542f6fa9ffcf4e74ef39e771f0b68f1f11a308772fbb74eac8b40662b643556518f713674bc5ece7b4ef7f9b0e0d88fe1508605d506a0421023caf30ede6689f37143dabfa539f9e902a5cf9eb0c17af284a4494ad15cd1ef1ed5d21e42362f28c193dd676e9aa369a4f4e10766ca0642bb2a79d3b539610bf753978b97db42ff8f64b0715a4c8ac902b71f6a887e8c327d8ae8f69e7f34f73b9213bcd482a7488a5efee0153ac76f9486f251f876f05af818da0e995afe7fd36499432472d5aae0340ff70e7d2afdccdc715e4cd5cddabf463ea8463f803c8d246bf9a3fe61d683566e318af3ba4b32fc35370c2fe093f9add71d632fa2e92f59e96d4e9a0ab0ec8cadaac7686b4c89e3c0b2627490bc41817c8815c853a5f4b52d69134b69ae1e7512c1751cac770e618b42322bb74e10421a85c9fbde8cde031ff1e8c9f47d56790c5b40a5a17921807ea8c00074258e6e0a540f7a8f9abaf98823048ae008d1c81e9a9b229ef7143d610ced4168a01ac42b84331693a81e070607a5ac57a410426006aa29f0bf73b3659766105c778314434747d9fd767595ad519eb50bc69177cb3c6b7a1e691b1484fa43e5f03bddab389c7ff913eb5350198762cd21c6d72a1851f5ab912fe7d61d450a72e44c84b34576ccd66e1e8da5ddf4bd8edd9dce0011ff517b95129b3e6fcbb9afa1ef66fa716db3683d49b0e7d529fdb8363c89828aad01a3888f88580fa8f2c5b1e61e43472f5b1492977ea0d1c0ff68f79d0ffe79c5e493f9b6fb19cd8f3d41ec89727dac66904e8a7f7217c47d5a597106149dc6021b3e9024762f93fb95b7d1abde564b7a05affb848117a631494ab6f1be7a93116a22351697196e82891d1538c4b7d8a80a34d060d334ef451c030b801253cfc5caa7422390728b149ff5d3f98aa0da8fc1d4183bebe473b764308119a65ced701e88e16153451c560730d564bb1a71d74def9616443b40d4560aba4fe9d5236c9d5b00d891ce7f4337d7c43f2f292e73367b2de6230ab185a0b6050115b5631836bd4ca1fc4a4b65d65a0b43c1f7347d06846251fdcf229ea98c0320e8b9124b5cc4b2221fee2b566f786bf0967e176cf9db4a7d6d72fa09af8fa63c34087db9d94e31b60ed5f6c2eaab62c934a81bce878bdd7da3700fcd5f9eafd237302ae1e0f280bd86aea079f115af1d5261fc8e52b84a2119831151d6be98be4e646e7f999c45f61b2292e7409ffc47eae1d5242f812a9f449bf2ef060c05e11e6246a16b8e8aa1ceda7c38dc4d66403fe0d9d477248f81b99fb35b4c862402f17c4b7f963c600cf197b44f7f61bee203df99b94a76934e5c6d7870d566c81c15bba8746e68ec7020ba29c84d378cc89d6fc01243ddc70e31fe5ae1d0594eafa3347644cd6b4908b54ee512adf5a109d2a429acc2cea19a08ee89b1ecc3e68972e3655f9753db2fdfc0ad6fd2f5e4d8857b93e3abf085e64e971d568a59aacee4816d972a1a94e94dcb9f43adeaa60f74e17912be0ea323150ed77bbe5be61f09f3d20618b2abcee4a6218bc08967fa2a52aee0feae6cc21aeaa6dde6ded4e810e30653aab72c76e9eefec54020cb52385a12c8e4459baee6cbf81cc9b216a7a7a42631cceba8639978f580a6abceb09c280a8cceff3a6096f998f7ae7fd3b2b13bcd50eb64559787718b0bb10dd7b2c30979653dedb2ef5b343d73e12b2cf5cb22d3cdeac1402a53fec8652d50fcbdc65b43107dec8ac67bd3def47a26eb8bc7e057d67be0e61f6fba5a29086b8612e2a023bd7443540d8f11ecd05db35578b9a18ea9c9e70d8d3330560ca0a2898255dad195f5cc787be96b9b855f9ad2e73846458cd52c1fb9c3c0061c0b2355d0192e39f460798b77b3b9260fda8c1e80ee4f6135eac6da4a100e43613397dec6895f757976a6c8eec4683036b5b5dab367681df41b4bed248a7dab4082675223d458dde0650de627c92cce793978dd606b4cbfd503f387bd0ab93a5dfcec455f2b300292166e898295dab57a77d0ad85ebfe8d4cb4df6ec19277a43eac00996c767d10b5c37cb2e60ac5ce7d3405f75a32a1a71fc92548f649d095f13b9379359ff3f5a3242b5ca05223732b855865ffdc67c198b849a147a556959f5dbe54f4978faaa033967da77e0aa602e599c6f262be69b020ad2fed2e00400e9c2e8f261e62b4f31cb11c371e8a0ba6d4886b3d2e829fad7fcf037ce984a42849ac2e64b4f66b35215a3d73575cbc22b5eeae25c8adfa885040214a1a4f279392f89dda46a0126bad58af0fe5015e150f61ee8635e3bac94078514d14ffbaa045e1641088dc08bf72ac26c3334942b7ffbdc5edca0bd34eca2d70f647477de1ef5b27298b3fa57082020348ac653ec85b1db12045816d7975f19339957ce3b58d8260b0281caedc94fde09d11d17cdc69b23e30d4aec805ceecd3c78900fe648d13056d45d190f8880a9da12aa39026163030d44d7b33f65a368c4b349c2baa4cec4ca8f6d9b3e3e4de7bf142c03c305b02987220147d04c499429fbeb837efb98bd98c4d0c9f04e6c5f77aa018c25190f135c15a75987b211ef6b533752383143baf8050cc500c2696c84af0f1c9f0a76766f8ef68b64376faca64561d4e3764397b4d35c7387bb52e3ccfe2c3d0f4d5df09aea0638c8e06d0c7a0db7d839fe82e9408b70f8546d16f5b838c1ce75ac4299e306c4ea9d122181c34eb9947c64fd76c1047928b73a260b40122c9900f3ce75d394ddc5c8204eec0a66b6929bfa8aa4c0a80c3fd0ef8bc5f582af5d2f9e12d20ad279cf819e1b0a5933c8a0a507071f1a7c975c7861e5f4c4235b49054b62931d8f53b636ac58f5d85140a91eed268aa824ce68cc605ab311d3839b54ae3a8bca1e5bfa4b78502989326949a41b6075e8c5b7e0a0d70d2423bcaf37dab8d88dc1f736d97aa372f26b409bae81acd2772c5d1549259ebda01f70afcd2c0a07ce4ab6f71a36f74fe16d324ac8ebca52277ab23e2ccac79def59a63eeafa14824db612c6c2b9cc02c940cb63c939df3d87a624797bc46a620fd79d5bbbaaefbed1dc1439b9476c3692d137df227bcac434db7db6a8f787ded9ed3fe14c7d21d672eb754dac83a749253a8e5c939cde2a928840e136e7b01c5866dd8a2e3f677cf4d51ec7e7db879cdd937f99ba15bfc25782c1650042373719c14ee862643be4e80ce3840a9251e483b2b5f1715c680b18dacb532e732a58841f471b517fa14941deb05fc20dbe704a7956ff5edf8347a8b067cb7401da269e1c4d37f21e5724b86c33b9b2ad9bf3d4ac1dcdd64477e0009878f5e90f74de0fc8f2f168c8b6afd37180ef2092a67d317621c90a2328c3cb695c089ac9390bcba405a0bd03b6835ec90251e07b792f00177b83fe8ef2e8f24ceb5a475100bdabc2e2211f10dd80bc74f1afef2a178eb6dcdd6a9fe6e806f440ea3c5981ea6a14433303ad101667899586143b2e72257eef5c5caa7333cfbf330071d71214a1cbe20895141b2659f6ba009b141dbe852d18c91015a9c6685a0e83f5fd2b4cbd358fd83a2bfe3325905f882f5b0cbe0f445979d2400808ef24f39235e9b795c8cc1b57da03c7de4248d00d599cae819353fde61a978b61f89c5d699eb09c814f15419bc33ff2a765b00bc24cb05b0dacef28759386627f30e291fe26ecde5e79d215868dbc0b8c072034d5499fab5f9e1d4b93672e56bf9d786244cf9a8c70c09b7a4dfda5cb5e25435b217b7184995dce5c7ecec57c6fe3a8a631a956eae1d877ea8ae2741068c904700a563e1846229d91f49b2d04b9b91389c722827fc958e156656671998aa768bbf32c95ffc32ff838deee3b1cb33388053740164ccce5bcf39082158c81802bd1a7860a4df3d1e89748a90a5ed898057c058c2f1cb6e57387a0464152000ca0b3f2fc6d43e64c846a49a965d152bc552b3668dbbd34ca11ee101d3677fbdb7f9aca19bea6ce235b41b863abe81bf2c1437ac6f42ce283fb1f6ad4b9fd096c690e4fefc88389b02d1e744abfeae529cbd2f78d4245bf15515c54e31d4c9279a28a1ea7d6992717b326ab064d7cbedb529b4cb7ad8875116bd157f3156873f5cf6956630ec9d836254baba328465cbeaa2f0aef027352b626169d059f2c49ebab9767d809e3868945fd523efeb2773d9eeb65e41e841d696d0311a93c37219f5c026d0705957fca2c596897163e2223d0232fe0432132910d5494d78bc6ab4cb891aba9361fe0126c5243204bc117af3abcd381d9e29ba9360a882034321ac70b2b1caa82213dc9e8fd5414491f81d6a09f8981c42617ce07237c67dd05b84bc4fd828b1b657372e2597eb5286ee4a1fe9f89385a649f92426580288383a453632677e9c8fc77819cd31b46f8ce05fe704cbb3c9fa243097d131fc34aa823bbb6471c91a8f6c0dcb5ef451fbb24af5df0e8514347a9112d2476f20e3cf50d477e6199768ef1f310c7d15b7412ce2a79146efc0390a7aefffadc3fee740df404fe3cd91e3cbf2df8de888fda153f92d55cfd06d2cc9abe6521c016240b0b024f9cba0a34dfb439f87fcc6a91c1600d2d9e681ecf078b5cc23e004269868894a76b641585e42027e9aed8e9f32ed3bacf9c2846ca6fa7d4d3654999a7e8e5d0d7d627fe2fc75cd16469da17b017b35bda42f29f94ac065638f01fafacf2c74d48b0f95d04e458b5f50fadaf5bd70a2fc8270da5ff62628ca7a60a2f87d03459353e4454d1372e05650e3050162d5a289b46ca6c88b0af9bedb20acf648047ce1cc15c041bcf26706e9143c760f180c3c7324ec0188b1a8f8eeaaa92c9e660d71c0d67df5c96ee402f6c976ad416a63de25a8be37b7b0788452242d92977228727ef86c0ac1a8bd94093982660104e9f3f82b03977215065acff3e25f21ad0da4b592d095205290ba6a137a5c24f1918c2b44690fc1577eeb3e689806315cbbb5521407578b8ad9333d86bc6ac8aeb18580f5bacf083f401c01c88ae9e12f613eb32214bd3dd8f5e5ba2757e54c795f10a72e73fb9154ffc8d84c44ec3a1e3be77dd875b1625717221e5ab5b885856b7c729e3e545c1d3380da2e52b21ad48b1ba67f121399cabd9c32a2e2d1d1d85e1ed8af9256c40db432385a8912fc79ffa5c20337e7063993acc8a594df246a3a4ae8b6381dddf112823a887dbc80b10fe7ced298b8cf588a66737a7cc0189c1eeb2ff082ea75cdf6d0d53b53d34e9b0ee51a83f16b25e9ee848c788943773fa78e5ba7c04bcaef9ccd6e259402142581813ef64ae40c3ee627b73b97f8a84fdfc64dbce552d9864ea8fac35603db9980ca9ab2c01edda1cc5568efbf4a933892889215ca568ce59dd6aba5dbd7847fc6dd98ffa495c88b0126d9d58b5bcdf8f6a7b06c1b231f2c5dfa72a45c28353ea2cc37766d9ad5a7a7461ee18f2e1baf64d31bd4548c3d2e41e99184e3ad99e64da42477f1809b3d3deb3f67158e61fbd7c152a1d1a82b49d38bbea190b556766ccf4d44c97deb89bc525ad7204131fd767b32028b63a256ab6f417a4ae82ae2105785c6caff2f458859de852ca1f0a38387b1b3c06ec8f0fe1283fe4f0651a3bfd2f4bdbe11c4fb4ba5a164f87397adf24a3ad2458fe8f3a87afea486909a19309cef2de2628444c96c8e3ccefbcd022886c27cd39fde545a466c668795dda2c1aa030b00121f0540864778c8155e1a1eda1335375920bc02c75c15819dbe5c815edc1853eb59160077117e37fa49968beaad94415004dffdc680f16aa5b63c7c4d96e0ee10a15da33232e923013f72957597d3152c62e3d5fd2286b0958daa59784316a664ad1fdbb29cea80d9819bcc2c4310cb30402b04cbe83317ae2a87b60e03a928524933dce184b6d9b39ee1c5105e5d51d0cc85e729cf6723b70af53f40873ddaca7bbabb1858d7053f2a18d58191d0772bfb002b4af01d554b213ca38bc183e01f215cc6f0d6ee631e0f3955065cba716388b4f5972cf817da3d5335f27b27ccab9b58dbc35fa8691dbaca0fcc1643543a96d05223ae16b5dfa26738e749df3fbe17aa8aa3780b73bdf309d46a7082c4f514019adc788cb6cfae4f2fde609c8a2e15a6ff02e82ff15ee09c743902e44ea431de015e8ba7cfa597027e1655eca2ee7e6ea00be9334eb12fd28ee41bc7440e5bde8b1428fad928a59724e19365687d82ebd1dacc507a63ff26613312718720e3dafee9d1939321941224a06922a84fff498615752ad3537c6d34eabd72daf29322a6ab7fc4001b05955ff8c5ab0cb984efd6b5882b93e22840ec9a325937ffb6c7ad7c2b86ebd11a470369be8d9a1cc0b24e8b9b7633765e0ac081b80b5ce8e2f5b36caf2514e66cbf52bc72cb176309d8d71483b027f8d415d09da7dceadfb7655ecb8df0f6b3c9cde7f48171d1a41a0328b44ffc0a238e027c176fb4621ae335f106e9456be575b2d69ef683c789da5e0796fb81d90ca9753683fcdfa4c6a4676fa5a1c7413ec685f8df2035d684afd99c5c3393595495c6b245b95bc735ac558fbf0dc633a403f46570aa536c9632ef5048f7208307caf4159906b9990fd6bd349a8e99e40fdc64ad05946d92062c94eb0822c7cea3b4eafec5dec1eaa6ade59cefb1900fd3179d256c201d5cc785d47c77da398c2bf355e4cdb61eed247edd5a1e9da19936e57bf210468931472e762509679b229dbec6609fb5a26e8479d3e3624e7f9c7c4f95878ffe13106f994640442d5d91ab68355ffd26237970a8bf4c01013581f1b272987851540c56b371342e435a0ed3ea25b0ecf953f770b5aecbe7457c06f85413144882c02d54675c6bfa807a10a4b1882d04c3082f4b9ca3f4bcced0912ff6114991b8a1957af97fd75345235f0f220baf737f58c7ad6f1313234d24afeef79673f749226cb43f6f05d4fb9e6516622a5ac0bd50f5712067d4d2bedce030aa32e7c21d639416c0d9f1f3df64e6d8aeeee2ec5d76d18fa4c0615ba794cfe9be26839004887ca0c5b75c21f21ec4b0263dc5f454d2c4dd84be98aa9e4dcd2b922a1c5b617ec63231a2a9bd651fdc22df27d37c97f89bb0cfa614ffb6eb24dd192cf9d530ed408c8f13f9a7dad63c55e2bc8bfc8dc0a27300676a6195d8e4788cf786edabf82f0414942d4dfdbb3789c3ac0edfb4b800d922af9d05ab9450e79d75da0689a4147e039bf927a7a8e9a5608ba185e8a1de69fafd4221e37ef8e7654bdbda7e631b1b6941d9ded27de6351709c72da033b39453c1ac9917e084776e48825455af499e63b89ad3e4f2813130199301c8425ee67541ce2177897e3e5b50e883c1269124002ab32ec11d77f33526675b8e9d9ed503c1cf50a450e71ba7861878627f45332614cca29fb66dfdeeaa05e8809dfd7071c0963f9cf955791c36c2ab7ea3ea832603c1570dc468db05a34bc880d0cdc3b6002427e6efd4ac5e05435c02e1c65cae8c201c5f3dae8243b6cb4171de0fc04450c9d2fa2cec6b3f0893851dbb10152487b1b98228e1d8fb1904f404651520cdf14bf083a8663a3de01aa24e67dda8f71ea675aff92e61e7161851071c3a542b2cc36609b1fb31f2318151aa6e1688b7076b46cf925872483a2981edade9cf7669d53e9ac6e19ca7cce1cc57fe30a6419c8d4192600657a63c7272810e9d6a016ffec86c37ed1c011b81c3f5c41f9a95ed84701ff0cd77dfdf2348598c8395d3f6caa389f12c260ce665b0be8accc256a4a68c58dff33c95f6c66364b0baa76013dbb3fc5dd6f2bf984cf5547de0b4ff49d400ee1a917a809b4363eb1df1ab37232e7e6ae4cfa60bd27686049e8cff31871401e79c41a73307249fe859e1e5f8b3a5905b73a6ff36c47d4fefcf2758b045eb67ddd9551a7baece90706a93dcd1f9e0e370edc3b163fba1d977d8351c39ac49e0fdfaa7541696dac5df109f107da8d05753dce6008d785a1234f20e6c788dc040cb5f91ee4099e25c04c737b46d6b39eec6bdc8c354df63e19a60eb1689ec4ac51fddd4d663906a786f1fe377a31e110d061aa6235aa1a0f4b7c24daa91f1d712ade4ef9b6ad7a7ef0804485b87a573c62070ee88320e4ba1df38bd74d15184f1469f6a3c850bb30b3ab111e64c55d560318079fa623a784b9203534b3a8485fa9814c54953c0640e86a678b07d71fe22d9b3bb10d884893df84f09d8d9f9c0ce469e3708c5220171d8dd8b84e2b35520d727361ef5fd9bd7214845d57fcadab5a8a4f48bbe74e6a29447ea434fafd772b9ff70c1c6b1784da9dd4c6a67a5cbb2f8431bfe4c8f84cfbc7b1542fb243d2b0bf21eed3c39c717622369cda9be0f0980dec908f1efdd4b28131a17bfb2aecc5587f729059c3781f718d420801262efee500751642ee69a531a31d2e98467d2fa6b935eada2e7b9824dfe3c847149ac58346fcb7e20a673578fe7beec068b7bd796a80704b33d6502b3d7ab8ec6d319d87e7d04f4298df2135629fc477d1e00c495d9553436fafbf0035352fec47372f6927734505880a5618218db0aabea8f6f128c57748ffb52f8a6d04b602baaa673d6dbc834710e9534aed8176ae0659089ec1ad313785746f4c5c18f8aaa5ca32311250d89072d1a5576bf7ecaa9c80a28a4a70030dd731c3ee6edcf2d55c1ebdb47116933428551c84d062080d8e2d1fa83ad32329796f15e10d26c2e729cd07e02a114a929a9219db485fa9af1108efe6e1b590f760ff00a4c7f7cfc7d4fab95c032b8f8b98751221abf905075c720a4638ebdc827b8bc81280573ef97cf0260505e9ca4f758ae4af7489ae93c7732ea5448f8d610e5b394c66c6b1349d2b3a9dc67c2d806521ea6a8fb256c0669fe00cd2623f1edc77274de2cd0bf053dcde5fdb42702950284f29e650cc4878f069cb696b4c26ba196a300d5deaf3090baa5bd56c428c9bf0169fa6b0b33e16445d859d7d4d61e2d556b85ebf896fb068ad77bd6d2a01fdec7e46eca2669b72be7c247076d56e59ac07ecfa0d36ac37ac752fb4000e50ea73e421fc784cf4d837bdfdd4082b2e2119ad70c7d1fec3c2a815d99d781eedf07b759f5517283a47f00bdf26bf75d25a134bc534f75ab3ab076a7bcb53fb6db707ac83c91feb0b30567377be4f16dc5ec12a314b8a997f3604962766ac00b95d8c7d6b45605c6a4cffe57215cc4d20b8a7754d8b49bcf394bf3524b0838fd52386b7de15b567af40667806d9a75b56257169aa68041eab0a78efaf4e6f0428ef5fbb4e18e05134e0ccc7afa64d4a861b227f48a38ef2cf74c1bc02ee97d39dbbbd5443f7672f4b5964686305a844531494cef44aed8ea8ea58f06ffd962d5d4a072bd044dc2d4e3d62e1bf74c88748c6f8d0f29812dd021a243515174853ca26bee87dbbccfb36b1c02eab9f19a68ea14faa9a2c88efd96f47bf640d298a340d702a34a015a743ada654e326a955dbfbde428a9242ce6da64a2b55d388488ec987ac14bd9c48bdd73b328754d31974ea15b1abbd7ced17f492939dda0184083f7835551fb9e5921f38774303d688237ce7eda026a88bc8c9f22af3a17d5410beaa0c19920f0fba3a95daf1a002bac9658f5336ce6d2011adc77578d89b6988aafd9dc0525cdd505c8890e50022a1e3d0756793c1f10f9058f84886bef5d54033cd49a7525d6327c28486b58ea7f4aedcb28ac6a41604cb77ca49dea7cd30a5010c93ab996dea4c3d0f4a7c1aab49108d13b95ded3da631f625bc1a7a74a9f886c8c3a30dc7998b4bdc7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
