<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aa9b4b04d22649294e5d6ddd13cf7c67ed39787f0e9b83a024f97a2f16a04c4b98d784414e26bdca164d2b351e12a1403901ff4c544c4544253826f7f66fe206f745d03e4740212f1d0dd503141dca4895fb39ed3ec1f49cc9542ee24293b5f8173c1ab70fde2c12b3f25ac533b33e0a833683827f41914b5b8a8b19771f779f2e082bac62057640cd42079ed17fe2f4d34f2d5fe3882b2e5d63eae5ed92f43ed4420022cf64fd97514949f56ce31fe9931e4398cea32d493096c1c72113e1450f0f1944229a5bd5a927d34ca13b5a9ed4ef19f98b62382fac7b9ff7239d5c968ee5546e4b31fc179442846e68f3684f1bc0cf83b0b24654d8b32660e5ec3691be63da6c3f701eac8f07b53983bdfd289cba8e6095e7d5bc7d7a0d4b1841dd7772f921636d51e7ecad964955e753f19a01bb0a3711f3c1ec95192fa22f7054d1d9f70132f91d308b3bb193b1716802456cce2de2bddab300ed2b27135944c829413eb78a9280c7ca3c3c0409e4b102d313332bc34c3cac100a055beb6eb4a926860b8b3afa20d87550c423cc4e332785a05f0514c8883f09dcc01b17fca37ce5f3b4a36009e1507d807df06d23423ca8544d69f66b86248e883c6941ccc8448f970dd33cc96705d1fcf4d34f508f74a9610fd56c609e0a794a93a05b7e448edc98ae00b547b4fbf5c4638e9adaae4966dac9c7771d9f9f673a16f94dc356bed59f0fc77a0a5d84bb77797e9e38ca65632be05cc6ee69153af75bdf65f30833e8743b3e8cd736c2d345f1b79579adb881ee89418b8264b2281c2188c3ec0ba8f9a2d943acec7550fa892fc7e73ff7c50d62fd17fadd9aaf392a44435a4b4cbd391fbabbad5e1a6e145ea06bed6556f1822eada97d96f02fe1f6c3766d2c82532b5502ccc9e78342e6b9dae86316aaaa9b10084313661e742e96efe0dd007e050798cbcc56890741569d9dfe78e834071d4531f156270016c3e982e4d6fbb575cdcc4eb9b8ee6727bf268778d08f9438d7cf0199b44e88e58951d5dc0276559404d79eb4984b04f23278b5b9c17fa5e258cbe6323f51a2104b5d17a4ad7ddd75567881ca06285af50f92b7f2b192117bb9511adf30c6d0527563ff1e230aade99942b73a149f7825fa9292cce2bf6cc3124a7c4b237fd6ced63c46cd5b5a0a0488b9333e6cecb2a98bf044489770202666a36e87b27ab7f88653079cce3a5d8f7f94c9ffea56871f380cb0d4db7b8581952d2167a7b09f83ac92d5c26b4efbbc5d82209a9888bc04fd7b90cfd59ef44b3c2a841b1583ecba41d50fde3f7c8d0797b6ebfce3202ea7b697e665990c31f9b4e01a1612dceef2fe14b8338a33d7632f685c5131c17ff41b9b069d5cb3309f8c58d97bcc98efbfea2b4c1acc414b6b9bb19308153356d6ad9b19eaaaec33c35607c75c5059e5af443c2706c4698ac74087b63da171ddba019513c3ac2a371b4c6a219aa7211ce5dec46ef62b71fe5d1b27e984cdbcb761859b155021fb3f02fc477df1e399d8a6d9291bb66751a9250decf36ea6fd8bec63783a93a35452e80746e9584a1590d60a46c80309913e1fd009f966b8c709916148531f563ccac68a7c3b92dbf874ff27df6a0a1a763263c8904cdbffe8f5aef51d0802a664e650d4bc6950d3246910afeed7c662330c50a3273c3d7bf4b305f2835a1d9fdce525376e165a3d78213e558c4c501ef3d6874bb76e3049d4279ecda2d1f9c3de78fb0f59573f2d3e24786cebd63831867b4b8f63fbbbdc5bd3c0c62ad760e1afbd1d1cd321a5bb1309be26c41149ff08d6e8b32d1194ae6c74fdedc63317820a426549481a309434acc4827ff2b43e0917494eae21c6896c858c394c16cf73bd35bfd267b77b0f0bbfe235054deea3c4b1507203cee1b695ad30b24fd215ad0122cc3d67bcdecc6a6eb7d681d3866993e1eb627f2399d7875bead05344af0f181c4539409337ed4b92be185d1d292aa410ea0e02fc1407dd6e2ff6e2a66b520222e3b9fd52b898c171471f79dd95f16e8202cb7435314ab1dfde2ae6f6b59470567fe86c898826f2fcf31aa031865e46f158716d54fc3bff1528985deec19454dfe3c7f41864274905e150738a6d4ae7d7ef7d4a2404296d3cf4c29f5445fa6f393a8499f5778e36d416a9545f0f473534414b5b417eb4589786b59f3485d928a38852f1af362be20210622266be87270da8623c2577d8f12c6dd4a79627df74116a5582b1d8deaeb3e9f8cd271cbd2415c6933ece953dc24abe3ed519e230408df2f5618d347d7d4f008a1d85d2894de9ff6aa56ff84ab468c67db38c1b04fd4cc69fae2995209b430cbd9b5262f1c345dceec97fb3e2730a485b544aec1a9d6217b9421a72f77f1335f337235bcb7d6bd916aaf9e295531776f79afd50abb2a082235c8ef1e4eea71d589c216c1878e2ce414e3975c216dfb9a3a8ee589e4509026673e34181facc148b41a2b6a7425891747e3e876bae91575bee7e6ffa19229473e88cc78b7e5d4eef1ee6450d07acaa987d1b28f47662537a27b2b226be8608824fb8485c1a891bcef77bfd536a719e46d8be822b733d5ed5217f8e8ae0076a1359352f5fbd4c8b8da4ee7d76ac67e42915f155d806af45d80bf4bd9107ea0f5d0e8726993eef8682e25ea67e30d8718b3f678e657eb655640fdd54044b89b96cb10ca24a102e22ec18ec4f57c6b082c081627c7354f345b06bdc0d3b3b35a3418459b326b889b07448c865c92ae76a845bee9f3dfd53d430eea0244f07803b8a48abc7d824d188c803ed0b9a97733419e5e37785280f93582472339ccf6c019f61bae6da183cd4d8af393484ef5327d4f8bce1f66c718875c48a131249baafd501873543aaabb44910ae82bc30a1e27ec6213f69dabb3f9446f0941da87e5a46befade50b8092bd342267845a2fcd6e0682577ac206bd8ad7f0debd410d69f63cec6722ba34575908dab91957237968cc6f04d393a5500a78ac434d2b8fdd9b20c4a4f57b03d7b7573c74247ee2bc2ed099a3a1ad1376a0958f8e759522ca2dc438e2ade4ab94c90912c00626c019c7adfccdbd48d06457fdfca33d0851d40921ea1bad2d74e295800f3c997c3781efea47b7d835da2d73138e28a6646c97719609a693ccc4fae9e71ac4aa79722bf3890add9fc8874305626217658e148192643c7820e9ad941b7d6f6f505b052aa880d905b1487f7dc787d6b325c5249c30c07da59999bce390b99cbf46bfa49eae8186e03087b643341794844f14e4cd7bf3d7aa014648595d837dd6ff64d8bc578845dd64014fbf899e30cb6bbc9efe3ed64ace74a95dadefe70a0dcbad715b2c67bb7bb46cf412927422a85845c33fc35e96e92c7e2051308ac1b45e040594c7cc7ceac2809587473e1b3212fc1e3e011333c4a4b05efecc64c00f4b18180a7baa87d7ac982a1f1ec3382c8f72875b69b5638aa8b95f1e84ff6f7620c70a106b6640ccb9572d9c235cb75b2f1b1e7c3a7a07cb505fa7c2844135af94f98207675738cf3086b7bf695b49fe47bf7a9e6083165559c79c07903ee2ab94ca5421c60ad529c25fe848e45bc47615650bae96f7246ae8d7cd198e71fd53bc9737e4b54ffe9ce33bb092f5e19756db73bdd45044abd23768e23f425068d27ea8cc9b8eb94113e9f7a3162283ae481c2e13921065e55c550e1869a3d18ab7bbd5b2f0f84ed2b5122f9067ee52a1d88998541b7138ebbb7659511a6e6e34748fdf6fddf5e9438e25c4bbe0994b8901ac7dc0a41e62502d61fc0c6980f5cf49f1d6ed0336f2b11c6c2f746b2c067478b67ab0153ec02fb13502a92ec38be73329cd301fbb74c6dc16042b1efb5d0bc37d01e89b7998976180acf85059b65a6e5835fed65298d54d9ef5f211a016f7b9877db5a9cbc6db1c0e50fe072e6d54b79546f4f354185def37e20f629686ce9ba73585176426c2adafa611847043ff731f64b5f71acefea3c3bdb3a167485ae11a7dedc3615bb5beb6909aadf795dd006cd6357af4703ed2016d1d6bf4324c981f1eff272f80fa0ce5eb5df699d68bd804d9e71b6495eeb2acc965503126aa32851b7e929765f9a2f127b21cab9d2ed24326d56bd6ddbe229373e94e7bbf7fdc61f2c2f0e6dc7e46d6abd908b975fdc3954899d169b560843eb1620634bb456fc61fce2e86e02b3018c382839426fac87ece694fde861ca3fbe7940a876d205ed8636ee56dbb12438b4cfa39f74a8e6b9da77977221aca943c5bf42468f802d577218363962a8f50d1f52062527e0038780a14692b03982ff0dce3f76aa027e1be6de8036eded9469efb2704563ad073c91192682639c7bcf316c1041c0d6491db44743b4ab75c2f2caf09d5223db51115edf445cadd135b8c5ba92d0cab96064c75b38d654fbcf7593ad6cbd227ab562457ad25985e2899458109f2aa966f093cef235ab2eef96d24046b1d27e6034756c81b11450dabfe435e7351853139a9d34f9d9876f5413a3a56d7354ad7a532a87372e60951a4ff044f96bc4b2635c36a9c7738d8306dc354eb4c82f4a0ba6b60e3ad6f28d2186b2047e952ccb94378e483c455d0d8cd64268a0be01e1f51e0841b77e6f712cbf4ded69cf4941c3a8154d0b61b4d0862728ec7e834582b51111ce8fe865fe5f3ae18905e724b98686aeb648cce79fe53c7610f412b40104baf03b97eb084083e84034b649c0e1aa1cdc0ad95188fece284950467dcdf3db9627548bfcbe3438ec84d8a33a88e41156a8e681054443b0f1f3d647eea2df4c7442b2e3cca03af64a6ecd9f1f412ab4b6f8dc4346bbd9c4e64f8f684201c99659b678df711f23b17a33efce31e46d5da18553c2ed4e62598aec632cc18bff981b90f551a38cc4866a7b456189cfb3d0dc8091e38fa531ca8b282e700252777a9d3b50d7a5aadbff385391cf4fd13b9f273994ec3f6d4c156df6e76505cbcd30247476a946f162619f79e465d98968051c8dc3a8a402aeefead53a5c22b1800619a01930f3859f4c101ca8a4f8f7e8b06180fd70324d54b8bdef0e0ddeffc7b2172131458a943170548dd5464b420c72f8ff134e05b30c821822ea695a406a265da046c7927835ae3ffee3414455c4fb4de07f3f4c015ee59ee961d9991b9aa2ca2482fd2d07562eda357c30e7f4d6c14d5aa47ad1ea19828667928e15c4a70f5d448988d8f66bb6978a2716269740ce37f65720aaf703d122d34ef0fa5e3102c8be4710ec60de5f0c048f7ae8f0d5098cc1ada7e1417aa1e75eeeedf832d1f985b2400e98853c06e9dd62f66a5d049183565db549217d2978097750d10aeb7440ff041c2c9dba7c75b63a41917fdb216082615b6c3c97e9c08771895cd9e7e4939351a97c3d77a9f45cf12f4066d0184ba135db33a0b9f5ce177a3a9f4ad24e23f5b8cae4c3eaef424ab81e3483ce34d771aa19cff9cb5f9ca667e1bb5944103449b2f8d70de355a28fd6b22aa224f41f5f11cb7b43e73cc41402fcd3782e7e1f61717498178040919edc3a366082cf879903c1b2e170bca657fbc1ea7bf47009fe4774271d78023834c18e3eb8e84d591feaa16585df79de00dd32374adc0d305a79d569683a636585a17408cfd836d357dc601a33b21d14cb1d10f795839b82a765939c8cea8c82e9fa167bd12e6aaa8d41b35b51960f349dab6759eae83a3e66677a4bd7f65880a961b7894338d88087ca370ee3d559d904551961d4a164032ab592b7cdb722f0387c2eba7e1cde1ab9a3d95bd2080790d35799237fca4ef083e8c9c56eae23596143419391174c4b6099eed528af818ce698b88195cae298dcb272ef733c83a48de788758dbf0bc5ee1a838f5b575bb2123be21c7bc2d7046ed842a5bb2f2f1a859c521416ab763e766711c1004f2b0b794cd8caa5e9e439b5585f1ce6841d7069414bbe2a89d5f503d4932adc28e3eef05e9858410b36f1facc9e826d92577720e6cb26fdce2dc0bd4a74b5c343ddb4d53f2382bcbbd963ee7521c71fa5de7620606c93048068d8040d1831a2ac8b2d293af503581efff8b54ee54a0a73ef74afe08749ceedda8519a0b303e0dcbbf1a0ffd6a481225efa9a5a62e2d7e988f3b402734410248ffe173be7dab9d2a1ef422dcb67cb54b27e44703919900b627a7639a91795c10ab24555c64cb94662382e13cd4ea48964564f65628ec61879d5854e09855fbb8f8ef73ecd1485bd3ddcb3872758ad4f1a16efbe24baa0cf7e51b713a7fdcbcdf84ee3fd1fdcde2ccad9f3a40a55ba2bcac448b5bec67a0c86da2efc46295a181d14fc310bdd4a3c244956ae9983980192937d1f94914eaa65a8df2870bf7d43ef6f528cf36e10a1e1f2a98cd17b45fd8cca4f71d8effc39331d487d769287cdce99c26a99e2fa6976f3b95e05d0e5b164461d5139b753ffe3f4b5d78169070a015c3aafbf40c3dc800d40d17e7eb7a758462f2b616fde8b70f258ae8e5c9b4c98373ca6b0687c98d269fa06d1108ed4e18e56ca0674c6e47072a0e064b3212156c5c588a2afc583d0e83711eeb84da6e9656ed59a13a037eead6d62188baed8e9cc412749595a970c75ec2919b7a9ab0264b5aa2b559eeaa7e0f3570b41ed73e01c159520198cb86020e13423c4b0f208f0914ee63a61ab25c573744344cb774805656dd4c970b15736f1b63b81dbe91f6406353c715f171fcb8ebc550a95298b53a9b209e164a927251c5fc0ea4275c11f60182249a21ed5d2022159d0714e25f49a1b0e084f2684b2fef4559b9c8078a596bf093167f129f7b4b7f09b3855caa96957f381e989f13f194f653adc22cb1335ac517bb27204107ba484505eeff6e10d678412270e22b9f553e8efa5883a65aaee1f2232add8bc61e9dbc2a918a27f0cbb03a8628df9d6f14671be6ca254741cb4d7fb3d9cfb73d511a07e5ded31adf229cb77ee0ac753be038fc33c784de86d989b77df7740547b22976183c908ff1039f3e13cc41514f7dde50b1d84f4c6a4197f0bb2b0509339808df5f29a229bec9349ff255897b6c724076d07512d7c3ec72fa581b66a38926a7429b6af2c8cfcb1fe2454d20c0bf882c70bad6f4b90b8f5fbd78fe917b432ce9c71614f64958d82428d8308c250b5a1169225bc2c7511793895a52d7ae408dc9e03149e62d32dbad14e032b5f5456fc11d8082c4c37436b9f25b0503b712b5b8135f96a95222e34fcb1a2a14d16cbd277eb822c836fa28fcbdbfc57dac07d5d3df973b656cb32323cd2e07e0d3c15c48c71c45fecb1f81b1905126ebc78546c71bfc1e3dd4cb9567bf60e5bd789c812a55478080bd3bfa4565c00593c96f2f2f76c59bb445ef5446c30a32256b3fceb6110d18fd78643850b27eac3aef0ae0a71488773920a501195536dc1ccd60d8da12490dd37bb273d7b526fee2e8349abc7686edfc07aeae53cec1d7f1abd50116a0db9a97c40fe4fefb53a6212709788b2897f0665854440e42008a2c455e6859ff03001d78e60c7d14e408d63af87f1a4aa64c02c75a2f4148747c0214d47e468859ca81f25e91264597ff380c4473c7cca371236bfef9279eeb32edc2c3dd065a81f28fc9768682291cf9bcc8805efa4868e45a2cc5f020e7653a4477c0ad72edc62ecf0e36b347fab7fcccf246b1a5390e9d488beeead7e129ddcf1de02c44562fae9d3f867cb8f57e79647dc5b99ab49d02a6c4ed7c3dacdae0ba1b7972cf521290954b5cfea49122a2f2e44d92190e300193ad8138fc66792428935c252ef091dcb179c77568a557d53ca77fb74e5a1ebe04d02cf7e6d7f2a80d1f1ce6dc5bde0f72a2b5c3988d83ca4683c6d54e9829439934344a51d7f165b4d3c1f1b4850d60211b567f9c99230286c669801015691d36817ff82e3f29b3e7455362122d7879cbb3d1f4379dfaf3c4479b2a6cdacaa965140f77c09833ee020989dc28d426336c00610e5f34398c4baffcbb21c651f396d83c487ed7bd3410be17df161e8d2a87f5b9363e95370d52ece74ef412f562440f78c686ed0702431e13416586704bc295ad35eba2d2ddb6a2d05519302e49152d4dfacbcde8f071de83d6243b13a438a4ddb95168194cbfedd408b88deaad4ce8bda1d87f34ebfbe7e4017f1bf029b59b998ee4df45d7d990d47065b543e6d227fdeb994f2124a75a67dad65ac87613a090c9b69a8cf60f9d98af49497361f1ea7eb5c50a36b972847c5e531a8cbf403a659add46a9ec883176a4f46fbaa95473259182c1d3eedb02f483d66d94371c8169bc8cf4137e8fd4a19d5666340c87ab968f80353a476226fc43335b29a924cb3fbadbb995cb365c6b21411bc08ac62387175a675f6c88711b1baeaebc76981b705e038959e545c382dd7986042c995906ed6c46e62a0c450f4c15a0404441e08be8be2d44975ba3b06bb5f59e88afde0f30fa716c6e3fb46033a7ffb7b0348b0c58264ba66b736c3af4e9b3aac2b09ee266b52eeb3262816720943e8f2cdcb625e43ade723fe923703823680c9f15f7eb36c05125519b2abcfd6adbf83cc87cf60cf31958fbb890d24735c468b33274776accaa3aa8e309c431c22a8b032846dc9104264d4596f64e7c5a2c6b9c29330244a8f9ae3741c1ab3df8cfdaf78fbcf5a0bdf77216cb7753856bb3a3ee524deea3a998cf4e1dda32c20053d98fd027848bcefd16514986fc2a988d8a11be4846a27ecbe710059b5d64805ffa21ddd7a2febea7550f32453ab4b2f9e852bed932eb438f70ddfa234126c08eefb3966da82e3a15ae63f18d896b895583e56e3c97721736d7b15ffdf59a771b7f2581df07d3b10ce80b0453599ac6b1018ecdcfb7cd8573a71912733b8d088e2fc9a7cc6744dc3c13f41b15a4646db32a956b9d91c104a0c3d99b928d9968591ace1d3eec6ff36bc7c027bbafadfc2c64f1905811997d514106b2342bb67fcc905b59101dc2e5c201df35f1c53b9cf599487abe1b017bb35075a974af671dcd18a7eecba451f0629e6f28dda5aa1b0245f1a246dc52260b9823d8bf4b4b15e0ad7314dd15cf5d724da8cdf3d71a22fad3480d32f1a6d0876b32279fe614c5b8172e740e9295bfce4fc754173621e10b39520dc9fd97038d9d3c75fdfde95149913485f2f4fe2ce0bb6495b9292c71c0b5ab07bc6e4b1b7dcf72794289802284f928048e854cc5faf12847561d6854943fcd5dfa21534485603f078ed8d234f0097b5d3dde361a757ac7105430556a349af1b0c8821c8e8f8db93116ae45e1f87f4d8d8d87139ab2e1932cc6d866c3b477de714018aa3a1e4e5642cacc35e400e6605effd02d44f1c3312e2b03aa62e0695d1501ca0819c7ef90119e076e42c07ed6eeb4dd3bf60785b915fc180c897ad26e2c77629ea9fb93ce1ae7c97ab9cd031165580ed5facce578c233350f65c0ae1d2658a4c81700c49b3abc5f89350a88d0ebd09c4d0d7611d20356d22476ae35b1b0be8aa3a44931837a9884cde0acd18929d345c1b19624dd53183cd3201dcd33eccced83a19fac66fcf3aa96a182e380f8bf6be46f12dd0ee75d4cc402cee886803c73c34153f25cd8d46a2d8e28e1346a323cb950792ac815f14ed74f6742e844818f67bbc8b073ad78ab278a9d3e4688f3e753f6a3ac10e368c8bb822f0586c2513fd46c7cf9cd77d8f9ae89efdbe5606c8a57f8107dc3c5d45e26a7224d709a14563ef4f9240e072aabd093985585aed9567099e45b158bb1370396cd4e2bb599053d5bc512416c84a6b08f05ad495d4724b0f917411c352091cc84a92c148fd4d285b78ab82c65e61bf977478db14a7724d2f157d1a696a0f59f21e01e9306a053b4e362c20e176972bf5b0ccaee8c41c0e1eec95c566f64b37e9e8c02c398cd6a45fdba6aceddb48ce8d9df6f25d3928cb84f4b98cecec3b038a91a1949505479c3e816cb62713b7dd3b8c252ff4b817b96958055916bec633538d99e40ed2a4d8ae1e310e34070d6e9b66321414ac93112b0ab22417d5ed2fcf8ad229c50332872ecffc99d02ba42d30209744dd963e2984fb412897705347b2803ddef89fc478cf156767611c959e2d8079e06cf5fca985325ed54e88e7b3dea0e3884c56a2c97a6256d03a62bd397845fc40cfc41ef9755fa760798dbc2f681855f9066e142a5af9e7ebf6271ddd1168d02fe7dc491441ba366f8e04a6187eddd51cf9905e3104ff4258ffe85ea9511c80eca2ad10e9d05f4cc9486b42ef377f6d86373e3ec3e908b460fcf1ec55867976849e341d4f521fdfaf3b49fba7bbc9b8209eba120ea7b52ede110b769819aaa4faf1b04ecb9cfc5b44b72dc357f45a55fb5f482878e40bf3d0575e68eed51fdb6384888f3dd11a2e9d709a6dac4da4be6147e6def5974b9920d98db389e782c8b792fc864ec9a30344b0b2d8db78900ce3c28fc0d1758d057ca29f390d52d634dabe99afca37aa88b8a51ffbb26d62b1b76230c1e02d47f78eca174f87e43f30f8f185570881c623308e26369b86f315c940db3995768502ed65c03d339f2ef284e182099e15133357b5bcb69346ac5672bcb5a766b9608b9d908dd1443a1419e9d53fa131ac24f5604a83475190944c476d622da9342bcf4b6d26965b4f48a0bcc68284d809ed324cfaca7bc2a8ace2640519e9c289f5ee1a15a2998e5a9c7ea644a56cce2b34126df9bfe25c5685cdaed83f7c16ab9fcb9e53bcf59af7f86f74a3500e249435181c5bc93d60fe55bba2dcd9bd48a77de392884c4283a2be11a6b0b2cea9bd06ec7e5e12b1b8ede81dd3a6e5add1a2d31d945c8ba19f1632ebddafc8b4e01cfdf389195798a1e17dbe9aea5867eaa091f5ffb7138fc1d5f6b841119f7158c24017a6f7ebd769cc4fa8ef88b8528f02004225e26beb34c7a27906e3e95de7bcacb87b1659ea0e591d256a506db2cb4e25c83a46998ae1618f156bba26d601d29ae506e9df70babe8bea7da01a68cf613e4d407282e4c1268a00da36d1190f4ce4924d13b960d9e94ac86469f1883beab19445ce9f39f6449ee31c29d8660d727cef4ed4e3520324af9351867fe86afdb73ffc9320b1c81c32685b8a22ab3ab44353a86f05ab5ef1822d029071812793ee27c87b9383e0993c1948d0d432de792920c7ec9471c88f1eea97758346f7ce9618e36bbba5faeaa309e29913ab281421f0d3aa21f0a7d4e27487913891608b3888b65d9c915bbfd8b1ca48d3042f311aa760e1028f5c3c28b419b4479755ce2ed8dcf6f12745d27763cc3fd1ed652de8a1c2f729f3c0562120b8c1928b9dd7f50249e0db4ddb710e6d78e059dcc4cb27e2c6a3fa313347de6731668eafc7dc52d09195f5aaac61aed406f6096b9157cbf609631f15ccfb78c38edf87f201e49bba4e5eb644b567dc80a4d9158347131a4394250d97c2b42d5a20b016a424fbcb02021ae21383afe4f801833c752cd6aa5c0986ee0449f4b17ca4f84e04a23069347653e23adcaea19a4b743c415720d86318187ae155a79fef7c971b18d26d501974d4ed51576911fabdccd5602fc484bf7e3a199e85904c6fd1abbbbf740761f9e48f45d1a727468b3f8d93e44dc95285fc71e53f06394e74bf790eef1224e58cd797e1545c707b4b0f827a1023e908ae659b8408d9ea6867734c30a30dc380129523388cec0359243ed384ca6fd335ddcb341abdce144e21f7bc79f3b5fd5f1154a4e779bcfdaf728608d7cffa9871194796533d335e2d7db3ee2b52667e41e8f43244c493a46862c7ebfb444d10a809a9e6a09641e0460dfcbdccb5a619b1911777da02a422a96cef25bc16d677d4dcd3bdab4144c72a2ce52ed29ec3fd349bcf6ddcf652ed53327f0b8df147ee102e2c7094b8b30e5ac2dde609b7c8e60745d193b661975d5a14093cd335238c9f54fa7e6853e7911d87d09fee9aec059c3124e64a021cc41ce1567b6b2d339a4793a40b6b3d7ee5cbc3c55b3c06e11510f2dad09e5ff61a06f1a7d1967805c9d91b44fa2111863cadccfdf68e370717d43a4e0578cb90eb1c9c65d08072da425db6a0d949e697fbcd19b6ae0f8b092709a7ed0b1c9c1e89b46db269946327a46fcabd2f11225b5f36150530fdb2cfdbecbbf9af01d5c5b543e55029ee77a46d6c4d8c12c5f6bc97d34c19ac76e68f49685a8923e2deb37f26a7d1f81433a76937f4847cc515f9e6215876d5c62579807bff0b6bdb6c4a81148fc7e423aac370af173c14b7c8a5a421e861fa2e87950264fe439b186b2963347f2e94238371783fe9f26727c759f27904d2f5d09aa35f97adc9840728ca3235d10c07f7cd46ef2a8239e103c22bb7e89f79ea36ebd735e36ac1200f57133bc95655e904dacc2b6cedf8ba1a354d1eabfc69e98a0ee8b9cc8e0634fc23fb269e1224d5b201e0d086bea1b40a914f8fb965e8359948b85959bac6fb502a4c2c764a3e89bf9306af80449a65d5ef08dd13f2ab2e46d0533085f732bda8f4250a01e4ed6e044574185d2001f3cf1c58513afb6030be6a80a81e322b770663d7b4299aa167e8e7b24496bd535dacf1b6133276e1d9daa65b3fa251a2773bc7e2efddd6578d73740dfaacfa83af3a479980d9f5f2620a57657d00a8b068de2ac7d725b409778080168ddb8919988675ff87bcd57be69c13fb0ed293bedc2553ed2c2ea5c0c0161c5527868be87ee5fa66407779378a21ac23cbb511fed807fcf0255e48203c9d05f4e7d5905d5243fb63ee70d8bef0f549c8c168f545582762bbf7aac2163eb74e0d06e3a196fa751f9ac9401f8098eab5df13b3b69537b544791a58d3595aab1ca197c1023ccffdc086a1176574b86021362e07924397768081bbf2728eb558dfcc1eca646acd7a3cbbf9b6a8501553db8c600f5e4dd31233319d39990279c717f23fb14fc02a84ce6d1825391051c1839a0ea4630f42bf95dc68cbcbc0afc55e191c638b4a237b5f7a43f48c12c04c6c3bd1704b32a06e09ffbd9e3dd8c9fdc3f4670ad182cb3461f58ecabd8373d78e5b7fa94662b417ea9c245077beb195132371ef658e0c3e2f9ff9dfff03f0acfd5953086ea0f2945da23e1af3097870488903066f79b9872d0e150a19b39febe3413f7294b45d421f46eda8aafc4e6684a7fc1ce1acd5684e3ddd376d17b1ca46e7ba489d55e583d04506d87025993ae8c9feeae8c618ca3e76238bc00d04037438e8a50b97a9bf54371f6f2846bbe71f3139066340e90ea7751bb754f977a53071a36d66e577e7df8a3d684fbf582de56271412888c4404ace22729a0d6121a00231545b5ce56814a87f343f74807ed4af17e42638d0177271d8c9e6ddb1c86c9e5b5fcb23dbab1766f3b7c82089b27b433815592e4b81166290e0243230af330228fb7b2eedf4b6f4b568f41f3ffe40f0e68f77d24fc3c73e557d9bbb72556d647c1f963b8f04a172e35a1ce54d43e0c82eadb1ac3e07955bdd8afee9b2e54a622cf08845f371b2dbd8bc62f2155dabbe3dc82a987193d5883d8a0e2b6d1e09561bdf544ce6cc39cc63791dda25208ebd6ead6fe2cc77744880b959b553c92e991c2b63ea8616706634d06fd4763bfccc7628d45f2f820b0d6dbec57655ca09cc5dcfadce4d3dbf1b0c1c7bdde0b7614dbe55b5ce8bfd11e3e7c54673eb3840307bea7c0969245dd675b84bfb7d833716e1e93f79dbff9fa61635ded8f1c32b601453066cf2e5b1b69d9681405a2f48ad4137fac4474dd1d03566ae07d0d1312668f7251d5d94d9a1cd6f47509e5bb9332a6591df371890d4b96722899177f7c85e4fba6a768deb8f6cd6bb09fc3d52422c9658f294bfd1ce3c84da35f5622184e0fa41c661052844acef3d6ef588919182c77d7004f70d9a7028d2c81c31265c11b61f03ca550afef8d3507ec9084d1f1380a39ee4944dfb287e23e5e4220e31e22f58d7526f4af8154ba79f2c7e1929152e9415d1a33466e3d914eb4a1a5d3ac836daf93d52e0b2d07d4f984b8e081d0678e5fbacb05c4da92a5e1ed5ec73fa90402ade42142d706d40f51f31b4d9ac96d6f059147919b8e8477a8f1ca5d6ee83956694b1d7fcf1e6d1699b23a7050e0dbd3a5770873c16e17b72ac624c98c4604af05b6bb98240a1db9178b4e4bc90de7f7fba3da59c62c3866ad5b63cad4f373a5a2badefc6be78529a5e9543c815b694007fd893d2b088f30788965e8d8eee0f6763b0a1dd238f9315166b5fde970931c3de4822f9f32cff34d9fddd71abd9a78548bd308efcfb2605f85e4fa4bca1825f183bbb2a0b07cec5bda17e3b961c621a207c29d15340e0e7397f1af34c5e31b0b0269d857ad1b0b935f795e19f12c86755c7a3eba2fbd2e3927c1ab17b3d432ac3c17765347b7b2179761027dd636b65aa123412668c92375035fc9494544324cfeea38413bda582c8e39fce2d61c9012158b31dbc8a42b644893e13dd67c1dfa6d56113ad7fac0d003a3615253098418ff691fcf7ce0c296a1f157d59e1063c8d53925d2c1c60b6ea53d1808047c2dbe126b5f17f2d2d0464cffb63d98177a2e2b560ee6be0e6ca0589f54b622760a4b3f131dc58cfd6bfd21b7106ce0316d7cf912d4c0f50e2c1b655fca06d3727b549b2842a6d76785c6a66f53879aba85827c6242491df451e2c5b4313504aea60fa42f8c03041e7b6d714e18c6d91381c3723bb9c7e160db9ca00d84370ce5f3b454245376371226da3ebbfdaebdee09c025ddd8316cb93b7842439a708ad22b2968bc1119b2f44c247679343708ef3e0b2f7b121bb1b8ecc4f6acb9cad8bd9f209527f9e2c9baa317ba7e41559126ab2207b8bef7b50f52368859ef394f9b600160fc6224094c5775d3d0f31a6b8e7c1182017c0b97fdfffbc63178283956e10a71cfbe5fc98a92cae5e21ce3ab20c4c877939dfa42c0d64303b2669a6a877d681e05660f5a587ebe35ef69f4a835c4c50dff61669acd8d6cc0085350befb5182c2d9fbb92d1019fb246a65d5f8abc4bdfe1ed8be6daa53979d245f01f0715a2166429ef1b4cfa58aff542eb9df355ab89778b611fa3abd0241f90921cb205a8cb03be783f488633ead5a2644c3aa5bf70812d24de9e4b2c0e2fa410d013d96f83a47fea134edc02bfd51eaf45b0af36d2aafd4aba9ae111a5edd4a573e61970d73badd3d1f83033aedade1f6580d9793e584e4e6d71c56fc39197861b56f3d6774f8bcc980f328c950d99a56cbf8285f43022ee1a80c7f07ead7f820f95f7355740acd7fca45e15bf7d5802dafae07735b0b09bf44a7319ac9bee4b3785db69038957bef841e13615b3317eac392cb723e6e358562940833747901ce426167f0426c32e8ad39b90d1a946e595be1cc449d6216c2796f6f3d6201f2176c96efea0e7db373fadb4a63ea5eee17bbbc2686c28d6c552f7bb9f46311cdf44308e813a5169402883883c522534318806765fcf8efbd5460514c67108c675df526db26e17744070aed7755246f01cf37eaba557f687ea4bf9cbb196d0d7ed555c92b67f908d54ec8feee9d654f752ab1480d04389a4825ffa4f396fbd2139c48186fe7710888c007f8cf96b8ebcfc3df70267fb23c3bde80c2a345fdd3ba7ed348e0616ccbe25f7d39217d3fa497ec0cec10acdbf266c162cb6509c310907ba31ea20d70da398c84ef453c957d75097ed718f139236a1c9624699dd895d06b5ccd2abbb6fbbf2da78116a3f6eb79dab8fa23cef9fcca63b090d9878fb6b16c7cb885a34ad33c7bb28ec7c22accab978389fe7ccf705f1c16d51d9064ea1e9f870aa6c13966e3704ad061e0dfc547cabb277fd8705968d00eeed04dcd18c068e6746daccc283761d1c4e5925c8fb4df4076f4121cb29c2fcb63ec0929900aa63ebe6835cb0b56b57c38692a50a2da6547e3302d0e282ebb5d884494820ff0849de87de08d4ece70bf5406e695f2bb068ef8bfa6706a723f4de119344ea7bcd957c2750da3aa9906cfb4966314010d18f11635f9b9e6c32d00e152290f27d82d88559c88bd5354b822e1f1a4696c1d1312b2a11b6acd8c7ec5be731618cc838de22767f23eb7af0591046691b502e8020d36ae73fb98c64392fa1a270fb2ba4ba9f469ad7a703930d15f66eb1d4239638563ae9a3925c7c7d3e7b020fae0e697a66e4d9fa59f1d9423f249e0c6c3c757cdf8bffd50e4854b73b34ecad7fbe2436ace9b08eee3a75b505317348b180827f6ffa6046ec2ab15dfa7eb0dfe07340849d7328bf3fd5d2020dabab686ce2e505500e0edda4a343e6b672c79a124b8f0bd06b63464c7b9d75806c44b96a7ae9a0bda773fd15145771b962744b0b693c1351c111fb952c49eed1b6318482459c62ccaac5d852bf2a2899f1a19fb5fee866fd30c7f6b4f003d49429ef78f05cf5970e3a1603cbbb45875a4289c25f8011bf553965e24974656dbee284c61a326c0a8e082a71f3b8caae5cb286db2b72cf7fa5f041e0e41935133e78bbfdfd6ecf610d1ff52ecc7e950dbcd1767b3d8ada3bdaca690ea4b4b1e7abcec39da2673a10ec1cfdaa016e7330debeb92201e286f89f84f43de3cc05574d28c9302f97c2bc7338bd5abb4d60eb4f19d42e2c4899d2a9abfbfa1a1ba9eb55a42d8b7776c3df96e7c27b12b1fec04e710b0ecd9839a4d444f284aec2348f99af3ed33e21fdd0e5343123596b9a2b727851f55a48adcf6681c23e05c450f23c231b7be19929881b3fd0e6547e43f8d49efacb1a4286133e562784b55ace4a69dfcef862eb2ccdb49c22899fec3b16a84f122be590287623b150b9de295388ff680da386819e490068b02180a255381e567e34a62b03407986d7f3face1e13b912d4795b2337b55920fb510a6cd9ca4654784dabc871a206f891048e3dfbd9a054a0e4a88e99f15f873e0edfbd50d2200e4748d928e0fe613cdae1499502164c044522e53cc02f54f0bcb404043f811636fb111c9c466d42864d1b8cd7136e00c98ee1ef3f626eab172848adfc7c2e42c7e20ba0fc27cb7045d2c469f044659bc184c582e80f39a570c564cda75b03ee310bf53d41c6fbdb9c9c6a4a63fd0986e5fd14f19873673370064d97b739054387607507985d11f7c12b3b093ecdcb2ef9a6875918b5c56aebdf535d418eaf1abf36401cd9338b9b951bec4dc74a88eb5cab42dfd5faba0d554f42cd44efa4a8c01b5167d888208442aee01903592803aaeb658df26a265430482ef3643f88a53b0a6f11fe9889e5f0879d2a674635dff8b404282fa804a056682f6f820b32593843d3477df2ec95f3aaaa3ee38e313a5c4800f356da6282cae3333e744941a6e74709a8d533e34a160fba49a7fef56c9f70d0e9d9a745c4fa0ab8ed934e22a0f6bff91690fd2e8f529dd8afa7053f6cd257f3aad08296784595e1c73dff0ff0436e16fc56358208a12af514504515e7007f503014e0771c65928754d74e44b6692a0fe08f252dbd98067d2ee2bef9820305fbb227e0a61a4a540b9d1c96b1c40344aa217e774b24d0e457de557c85b86da5f850e2940e0432137e356a80bbac0ecfe566db69c000807db0f34bc35d2919db332710edea43d097a978e0f54780de039a3dbe8db566bb258734f9a4b3737f110a8984bf99d144b78e6c1c6485d5c549f36b48fd3df6488a096bb4bf6e6afe43327416a5f4a8f9005364256d0ee84e6c26a57b27019eea5c98bf984252c53b6dd365eb1db2558a01305dce5e216cba68c2d6519ae7fabf9b35fe28f6f82b5eba5e26223a7212f3255fb027d44a33aee0361276c1c7a027f8443873d9fb8099e62b1bd35667c898c80597c4c9d0c3f746444717b17e1513af5fc21f892cd888b78c9d294a095a9f20f51c1d4a48f825b10fdfd81d4041b3cd92edeb8f613f4aeef413386b25c8270b9ea930e1b2e5945d7333e1b536f6e92e47f5999133cce429d077546967144dccb8dc6084fcb5ff857c8a98b2130d99a57590f557778b2272e111144f454e17931cb4c4b6d18c2974f2864b3c55f889b9ca193ca87dc26a99a958d9188d2647bac843","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
