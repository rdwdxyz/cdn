<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d1c17d2fe01b88cd7cf14a972b11889e5678d4b98d7ab49293fa18096039fea34fdb8ebeed4de48ca6c1440e2afa124ecfdb162a9475d621cbd2dffd4a9b6a3c80210a5f21d0ea62fedcb8934b5f0ebdcd881b4b206bfd36defa64aa533a0d90d192af114d97557861a0c3051080bd866792d27c5830f0432f414520bba3f9af0d879b6e00fd2b3a51a5fccbc1861b8d365cb57053295bf3394d96e42d7e6d969d8758d55884db050dad7ef2e67f284fa7a84c4d8db6038a7fed43bb438f7f2b56ecd7f74241b44fcc93301cdddb025a8eb4aa0373ab0d35cd3b5319546effb2e0a2ddb8d71e935351934348da3a084ee083857aef527ff70883a017ed0b04d4a78acc04c50d5334d2d78cabf0739dfba8eaabeb689bc44a1f0b98477a59eaff3a42f5f0a4105f3de030be722310c4bbdefdb76112c9eaaf6b8d8939fb29e6a9b29c6315473622fe779494f6e6c76766c8a3e1f517de9a7d946395c1efe541886badd3aab8b72cf55399e906c0cbd0fb5208800fb1685a8c0c4f12c32974d35c45ea17f2e97d36c7f4b4caa0cd3732f09e6460c24d90987f6d5790e0813d777fb9afa177711aed92d350e6680c3f366f9f61345d803e335453db8603a3a237f8f8f79fb53fcb0b63d3cf26ef22fe2bdfcb39cf52610c80994799bb44c6ba9ced373abbbffeecd941dcaab5fbe2d17d0ad579f6bb3c37870cc53b3262908d664df36c7eb23e53e4f8fc03dbbd81c6799680580ad7045748b8a74c0ed484c811d5c2265af78e670505b25dcd6a3560eae0861cec8ba434fd8adc3849b6eafd752b62308d5b0de1173343fd5dc64e9fcfc9e8cdc661e036e00c4f12c8bbec22fe9aae745e3adf47a7e95a1526a9a0f3146939477dc2ae526f5cb77cf1fa5937b38f8df764c33be31a58085b209bffbb04c064e3cccd33ec8fdbfde406eb0d5015ef24defb698048b3a2862b13281be65549394c1f2ac2647266708fac48d799a1cc164bbc3c327b55dcfb51793f28329190bed6181168d00947b29dd71cf48f0de7b6e9f68af9ddc51029f65f48a8930bc836013085e2e14dc92048db0ace11111713cc9c8d14e67a72b36da17d55df83616bc509b166c82f9214a6517f8e407549dc64e3b71e5825e4a68aab5bd60e6bf6a7382a9e942756d0b9d35fddcaef40c520a57724be0da0833268131744cdc37513a8085cc2f2ee6250ba39a1103f55e7f5e1edeba97c59a90efb888bbdd3ac32d4d283160c17d71c7ffdef189a26ea7cf91f59c54f24248e7762a27c830afc4c3d3311290d8b3746045c11e5409c2bac5ed402a511ac0ba1a68eaad769936484736a1cadbf3efe2b0239e4ba71fa27e498b4b891ddb047f9987a287a3565c5fc44d36c5eec92db11b0a7d04b6dba31ed58b0c794e58d7eb7823bf4c086a36eeb690368b3940eece03bd38478d48a7d765cae7fdb2854636b10ac6b5f7162e67620b9b85d169e087733629ced924c3d55072eb7eb9b6931ea68b62f2d8dc4a16f8d33b4677337752ba1b056bfb422a7fb04a2b9fa7a9c7037135c5dbbc6f6b97ea056731af1fa70edb4581e3455ef4e1bf7462d305fb14719cefeeb5ccbc5a78f80a29d7479d92561b211dca28c6042aef59fb414203408eb788167f1a660bf2050f70fa22cfce736099a06520bbdf221b015c889af091780ca739ebb86fe868fa9e5a481a110963f09a2ec95a50316f19913680b2fbbd92dda125d7cd94ed077de107e2c7b0bdcdaf4fbaa3622aa9d00dd46de14efabe2e056c03bb540dc29cddb84a937b540b3cea666077fd0e1d1642cd16d6705332ed5118119dfdd2448cbe77e3e7a4f1afe08f626673807f7c5ff3dcd6e5a7c5dd91c74551bebe95c1539d834ca5c0bfc78ba3a51d674d63296315f94f167e1cd5cc77f7e2d29966f2290e71ea06af281438b1c12c04af2d960c72c7b6b64ff17d0cc35074c218ddd4ab3ed5a3683479c78d0d275de25cb21876a57e51f592e525e8714007cada94be9a076e365bfcd7e5da288f9d41a6733857e064ff6313da56902c6c06095da9ca17f3fac9e8d74bc3545339d0c20449dab19fc25dd98010ff511298c569ebb77f6bd66ee6ea5e2032254b6ad80fe5eb49a45c87d2a9a3b8fbb8df832eabae3ccf31e9f8e17ec9f4a2dfdc87997a6600116e53120a64c4d5c4e2fb2c8d2546f0f2c49778356250bb776791680db4a624478adb8928f748ed427a658fe5210e7fdb2ad5e00178b4fea8e2551eb731df6b04256846bbaad6ae0fcd60a4f3b61653dde7bb111c30ed634548d91612b9235fd678d8d888a97436910ece68c2bc28fcd426f03aeb278e9926cadc4bf8bd00b0b349f8c8a6c75e2d7826c878a253e1f2deaa64228578aec0ff111a52bd620d984112e3b5137588b80183784c239d735485398ab082b6274eda311881e74da6f6545d4556eca8b28dde0a25707dd9783d440009947aa076c99b2e28d7ccadf2cd2dbe74b7b63ac1408f36604b761f0b345ada6fb9fffb7cf7eabad01b2b2c44508198507a57373d26f45dcc0f0e824564f67143755dcb8fdfe849e851e1218cc7d6e6c2f2f3d77a0b5eccd1734e9616bd1e0d6a685938a50de565a301c0d66600388a0cec204e2eec5404a945f47de9b671edc7f6fbfccd4202c2a63b0bfe52dc73c8b70d39a9aee471ac6926259a4ec36d0796b654a7f372c41ba2c7568d15b0cc734cd95d9d468034c9c3d181ef77f9e4a89db7252e146a21723740f35febc413a9cd148ae53a78853f2cfdfe8661e56596c94e352cc83ef1bb0c4f6b9b3ff1d1be507c20737ea46a71b5ed8eda09df7b5a9cd44ea911a5bd5ec1919c5bbd02975cd00a8eb0acbcd0708e93866da585838adce3167b5ad3335e8edd37d55a33def3cdcbfa746b1aa714c91e5e3ec9f5f28c7cdf3572bc98ea8bb8a819a64e3e79bc564c65ef871175fc97d46ff7d9b596a02b9306b9e924bfff9dcfea00ec6a1e85091015049633de4f8bc3c846253e2975a60094f1549e948d293ee2d6575cf55b6c176228fe6d0dc5cb84ad5bb3897de6d9e9cd07a83f443c92dc01f0656b038783edeb3a1904823e2d1ecba9f246d35ad762af8cd7a5b52e0a0d2ccf72f700e938e1e2bbfc99fdbbbe4ad94d58eabc0a2cb7bd262c8f617d0d098fc8e3fbfefb585f587ac3da3363f0603826e60d01c537004bdf16421bf7fbcc7c1c83b1432370c5fc2f0b63db7be476e3431bd3798512bceb692000eabd5d1304c67c9f062250f07d623abb6b8bae85bb93eff51da39b05d9fe6da2b79aef507f2f02228837e209aa7dcfd017ffdc10a5ab1f77370c67aaf91ba5fa7bb5d65634b5591d4e0fc6e002c232bb44350de3d869e8a07d44674c355d263b8bec0628b332dba542e614245ce5fddace36f9cc2176e709ed942a3321e8171b5e0bfc689b0c20e2412ec0c60617dc65d0ba9e51613a27cc9a550a0220b298f7f07c0350c5943ab97921d00235a102fd573c091edee551f057d868579c3a93a2daa2883358968feefd44ec004b3fd19596d6161dd1171a0591cdea6140e9562a30ddab0b428b46d7a9bd74f3faab87f0f675c3dd0ca377da30132244a69457d6488c88ecf3801d2a898a2994ffc0dd6873f28cadd5ec1fbea1065aa0813e77e46553adc9616b09298e48ecde5e31a987274f17518f1494600deb951c2e3c3183d5503e00c3fff0c031fce1590eb522c357fdd9105d47005b1f59a754680900ce24c0a9169270344dd34f13189fdf9a2e111e29268c042b72074b1363fa27edd470aaa2eca8f29f7fd8793baaf27561564cb72af373ff85516dd41371331cbfb91af7ac9853d53fa3f14bbb274458859f2311785fff3b64fdae3cf69ed54a5de1407c66ccf55958d70a14928b002e60027bc354a54cef87212b2f764a70d7f309fc11560b698c95f68f44357d2e9831b6c966acb5b9659d5a5f1cc0c425fbaa6e5b8bbf829526aa6c06df1678169398edcc49ce03cb873e543d1e5d822796eab4798767c8a7b4d87fb1cd4148cda3e9ae3d6b1c93cec414eae1b258d6b2c4b3e4f6921772ca513f3532abad5678361a83010c0992ee61a6a7ced2b15a4a6d6b2e4bc03e07984182d9f7c1c8e147aceb8cb5c3b8eae6a7eff0ab8df34f423af0add7f97f0c3e4e063ae9852a584f85cdec43e0e20e60d66d6a1e5fca461e9e98eda80a14284d7519fdb3fb44face5ea5284c49443cbfc8bad21fefbead6489329da0751a800b71fdf7e585401fbaad17660ae8ce8d2c5840f6f349aafb295cbc2fb15d5e53cf855d3d885cf7d4b197988ac3c72aa35c1f81d593518fed7667e8aa2b1f2f73aee5d8196b05b8664b042c799a461cf8f39084a5fa14ac23787127d566eb27da65c766cc2bb3b7a0dfa894e1a9abf0b4d7414b5ae989c9cfb9e474be73f43b6235b6af29372c345ffd41461fd701621aadb1ae8e07d5e6f82e1781c941195afb59779f6697649e03bd28c27c10412cf410877a7a60e26f47f979ccb07e2d168a639f79f6fc7c74f12da3dbb984cdf0cc400f3f33c7da1868b29f521f316836b4f2550e8c5f9ec16ad776c1ad2e209f88ef976e8eef51614713c050fb9aa8a6c81ffd896326a06dc82bf0a4bd72a8cbfd1f5d83e197d1f6d965c6439e48b4ccaf5165af060469543ff419190ac79b8aabe470d870c5eeaa3af458f99fe1e96e884a8f535d791e2e69692925682df52f59b3889516b600e463494585f662ec93955aa5a1a0fbb5d07695616daad8f793415ba7d8f2ff3de747a146a798e77fc1742c00469c0961776e2abd05749dd5a3fa8f0a93c423307537f2ad62ebb0cd77a44c4072fe3dc0669417e0bf93b641287cfec6d71041b128019dbc44a283b83325fb98f1f29edfcfa566d4dbfa2f3971861e4a15b527b9312232b34bb3962166e08bb51327e06828653a4b6d8b568326d9803e18e6e53adc30b786d574dedc134c42ad02c8034187a1ba8822fc6135ca0e495eebc007db2488f9cbb74516a019e2b3f33dbb98c1591436c4b3777b4776ef00c574380fee6b79460bb53677aadc2d4c56648fda28851970cd67ca1ccfcdb2eb4bf871e0ac5c76769d4ea702331a523a52c44e2a2b6081563f1b6a120727bc8de19325b9b7261c97d674b8936161c7decc6f3e18f566959ad1882d9fe7bab5f94b783931a80cc970ec46d288c9ca0a862ddafb6b9f10cf83791f204e934b6792c31f57284fd100be6cf2676a53711244f4955909a77cbc4fbeffebce153e0ee2b9126db4fcb196ccfe2ee8c185ef24bb21984d7c16f361dc5802e5d7a807e911ee04e5d08cdbbcbde12c8c880dd45596a88f85d311392305ed981c5c273b26ce4c7effa5f88d063a695ad9bee55ef02d5017e08a30a156f84dcb384b21110a7c0f98fe61cf7d9aca0ee5952d7fdcb01d854a7141add867ddc964ca572f2c2ed603853e3f3bea43753ce89c2042dbace5aa3891572137c67b745da3902b0a3f44850e12c61848b3cd8f974aab89f4107fe08404cc8a5c3d114c5d02fd458605f55d1a4076986b1dd91ebb7a129cf843602e8b857835e7c04aee893bac7f84a72659117cc44fbd8786bb6a082598d3e3b1cfa281e3929549b8b758f84300eec98dde9c7341c90db2ab637ad37f8dd0bf6c068f3cc100fc2f6aefb2710f1b7ae68d6d1326eaf1925ccebbdc9d344d2e9e868f2dc2804fa1d4d71777a995e05b1950b6efecd5e757a40c5cf08a92909f6e72e0c4230668836630331b29608d40ba37d6b967913f0027f4071419f5008ef428708b0421a338943741109b5c9d25655906dcdcc74a3be88ef25df785aca6523a2394ec2317f6a96530752d64255f5d6f76a75925b41bc6bb30aabcf0d7ca91dd98207a350d1f7aaf70bf5e598d680359145464cacf6df7a22c484fbe43caf182de4e78803aa2a3dd391c5b645bfa699c81f6c547da83e650edb4ab94e7a33cd9b30fefa8024cd2936541fc533d1101b37479efc82669d6b21f547abfec6fa9077a790d2dc6947bc3e855bdcdda36e7827711d4cc5ddaf2ca4756f2d2ec1fb29bd266cf2f2471f6b1de0621ef921145c469334afcfb6723b676662a5f7675d003673782f009bd5816d58096edb628fc9687bb5f8a1e38271cde1f77cc5e8136ec591b578e215242928d0da73aba830aefc206635255486ae044dcf776c223157bb3387c4a7322a5125c14994f612bed83f87b67ca6068e437285ca8a3051dfa6fc1c7f184514e02c22b5ee78e05cd5f07bb9e446edb72c2726c188051047746b74c844ea1b91cb2a6326b8455012cea028b9eced837184f7f959941da3464b87a0113f095a82e565ba08225289dee1ba8cc468bb7e43c6c025172a53603c1387f3909a1c7c2d0ec2fd4b6bb6b5201953470ab5451dc5e9bbd320b430d691d1fc75fee827737958ce3d29518416f3022489546bb924015fffd6b232ebdd46362a44d92e30a75eaa05861adf6099b50bf2c3572b051229e195e0063bfa0327af547d883926354a748f06e6eb4c25ed8f27dede6f1087166e8dc19ac0eedb5fd7d51bfe119404932b061acb714f85c6e6414d475fd1eecc67fc54148ee68f6c333150c5fe103d78f972823e02a73e8d565e818ac40ef525ebc383d6dfc92a40fc3d692abc26e18bab6e41cbe2b318c6a937df5707802043fb370293e7e2d5ccd2b7e6a86821d0dd56f03b2245f2df0aa0f236514e3c7ff4fe733e94e1f7397e558deb0f5237b12511e74295d1ed1f585334ab6689c6cc4947189003e0ae111a0f9fd9260a661e6f6b7e8643e30690bdfbd7d62e8a427838f1a4db4900bd07ef865e18de541389fcbc6acb67ca85111e6042793b3047198161eab76ac5f7845a0634f44b2f145c159a589cfa2167e4ce50f17308e63a6b5b5eef1056f836e838b64975384174fd6936386da1c43efb6bebee4f92e3d1e32f64102cd7aaaa51c4a7488d1b55a7d6a27eb32aec8733a7d5e5121f48d9484cbb8739ea1da8012c37d0cd6df93395276d4cc066668863f879cb7bcd3996ed2b2e7f86ffb8d9f9ca7ad5ef37babd31ff96faf86aee3b6b5a26b33ebce3d6a32348b32f67fd1770e5279e5d42425d659b25871dc1f8b7b6147c8bbc86ffeca4cb46291539f7d7b12340c08b857adaaaefa3efef728eed8c6e1d8e8d3178d84584d1f896c5f22a63d2b3383d5b0afc42c7a1897120c0ae3679794b0259cd9ffc2c428e82b5dfbe0b92dc33029e3ae34273bf7bb31490247cdae14b09c148ef0e7634aaf62db5563ece40d9116f2a8488dab4194c43bf2e3f6339d8a6adcf19dd8404bbc2494363022b74264f65536aaf2a4fa0161b32b280de0c597ff7144bd8b875c4bdfe70765f436f14147428fe111077f6f348a5de727195b15ee978bb58cd62e2bd4b24ccd104137323c1b3ecbf128f47c673e65c045965f66bec7f2c62dfcaaa61dd1b1c6c006aa36c1d47db89d6b785fd19423880fe31bdf8f29a488751b906bbca1413caae2ac4b5b0b4dcedeebd0cfd48a8ac1849260c1ca5305128de9198dcff69b3d92e6643943e43649d28634c814b71ab64c49a81e973fd5aee9aaab43c4adb8f9555b25ed784a0d2e5497955b58a94a1c53f14f202f858987f783830946403bb65a90a1121f17c9874e5488f266e5c36e93d1982f4dbdcc8ebeb891d2aa523c211810584394a704c1d6a9e63b9aad9bbcf821b3ff3e6c3981236c695d9707633350526632f8b979d08cd56a26e51681c813eb45db6b1c52950e9e1bd41f3aa9c913c644f9ea1ef2c166f9d5edf37bb844528096a3dae51465763fa4d10da40e5d6a95779f4410e1303a2da1d2e809a510bbd2f5710063658ad5e094940a7fc3976f06862b8c62185a492228b6aabad136d72d852a913b869867431e6d6a904842cd1fc0101bc585b80524f4713242f5d8e109dca7d0ff70a522313bbe8e11ee3f9c26c07827cb17906cbadc6633154cecb8268b6f1c82e393a2da07feb5e499e822ba958a12167fe6fe4fc0c345212a118f8165ddf83835d754c33ff2030440e26f18cdb3454ffc5047a0bf7d01d286284c3f0f2d19812b35b14490e923efe7359b4831ec4235ab20f79a499cb4f4961693349b5cbc7159789f9b97e5e83c950915912e9443f0fd168a7d86388aeb1dae67df7e02b1a77a047fd330391b5d7af0b74d8b61d6fc9204dad5e0c181636b6653c352ff427f5162079b471a59f9e947b389f87a753765cd4bb378d4221c7c495812aee889ba41d4a0ab94dad230f5efa7324f5d095b85050ced287a0232e7a9604b3b6e36aae82018844b0eed8bfcd0f8971b30e0e8f1f3f767ae9a40529fbd7acb923e2c60e04c4cc5b3db310ff17e3af410d33b30b2f4e8094cc4180f74be2dec30a258add394a433a67376ddf0cef7b09d5f4ab35f6d56a03a3b0ae3ae7cb2714b83f89b540fee221a384820cc53886f235ac1c0e6b85a8bbc29b54439d85c0b33dd23fdd5887aecbcc91106f5b8598a6b425899b12a46ba7504fe75d83c8bb82f592b2ed88b13848985f5b118fa62fff74cc6d09c2989d088d81f6a342b2ad8d472b573819497f5dd53a55d447c761d78063e8030633026137dca3687fb0ecb5aaca12a15b53901803f8fd6a1414f335d303f05222d31f5d9ee898e216f05b1220fdd97cc7126d1b87061e8af46077a1a14fe87b4742448f7d98b25c834f459e76a9519e87cf2be17f85bb047a0d3349c9dab7b44880991c2541d6a0277c3a40810415a496aeb7b1501da07579824f13415626c6599e12dc93e8fc3baaebbddba46ded425c655506de21c0f72bd3c39c3bb85d0a2a46b61205068fc496ecaaf51cdc09181af0165958a356af4792310dd339fae8c044f68517d51c13d8fb5690d303cec4e6594fe2db31d4adadabf29d1797f8a8f8c0bec53e02de27660981b172118b67907431ab22a47e30271c3b71b21515a0a62d4f2301fffa298ef3819c4a81706b35b26f809e737f5dfaa66f0e34f774c0430ce34b52f23ebee7cf0b7f3f6fa1eab05f43859977cfbd23db35b90dd0d349868dad5f65906a8017cc1da66bf9e560f136206a65322da006bdbf66523ffbcb5602133d0a9fd4ed396a5e19859a91a9115e545471673d09f6b9d12af1945e10dcba9738319a9701e1729ef99067a7a04a42f2fe8bdc24439a7fcb892688fa9a1e0395ddc8fea94de091c44ed5ef70fc805593cbd8bd95c7dad3a31fc4caf0b30c7e27af480120668afe3468920d2df0dc48fd35934304a1669843b33e7dcc58d3aa0ed1bb677b4eba4534e6e7e947fa5b8cf9fefca192d4efc8d511160c1774576eb0f17f810070d02c2e9f5e18b70ae73841f91cbaef172a783739b39d0dfcca61894a7dd3eb205ae9c47687d821f669b672715f45689de97c339d3ef5bb8f0800c350431e368cc3af22331606fe3ee4f1ec9d89be8f94df7aec9537703ac19cb37c0eab286e64f7e6ebcb46caf16d3b301151d35560ec4201bf989f27a4b8d6956a0996750a8a5bf3f999e2c6af55cc58923810369215965997fda0a08e7c9c75b17a0f955bbb8cdc8dc6366f3ff10f53955561141c8978d0eb69e50cac98abf8be27a134e73dcda41747da8daf433d46cecad522a35538006a107f8a77654816f4a09b16c29130fad5cbb06f4cbc2157e6caffe46c69a79d2a7d363c7165386a009bc299b2a84516df04c8e2e66c48ea51f423551ff26b2daaccf9313bf7d44cfdfba849cedb9c42bd19f5abe6ba6a9af9f9023c87b5411e18a17a496c02f0b113f9188ca36d0582db562248a218e03459b05f6e643b0356f34d22ded2f4e869890c07185d971f8d4b87c8118739087447b66d94c8658f58ce83732f31aa78bdf8c795d293af1e715f6898170cd5654c2b37644bb5e8abe764fbfdd84dba22ff631b90f03eed6be45e6900a405147813af09d47024facd88f51b8d4a4e2752ea3801d5fdbd1bb9a41ec365f99eff5a147617abc90e94ccda9f0c8079fe157706456add1868281762a23c85c412e0aeade9edc219588f0f7153163e0c6d1ea00afc56f51e4edf66af8390fcd49c32f3f181081a023722f90497ad6d708fe9d2aae562fa867e434840005c3cd7598b6bf7658c755a752bed58a2afcb4ff247908d40f4ca88b8dfdacd900276ac862d4cf61109af55c6fc81e19e9a9e326d3d58cab3433faf36c235177beb9c4b657c68f71e42fc8b4ec4a259f492063bad2726c32f63fad174a1b46b1a79827265024573e03975c44bf94935fd61071c862f2c2164e86fe9933de91dbc5ce947431a85046563ce18c05ce949a9b331f03cbb26c16d3c210ba9d6ce0bcb7f77c53675b5395288579f7cbb6dd7dc15987317c06c816cf40eef4a19bb5f910a4973fb88ad86c100bc551e95210e75d9e149efbd8e32cc52657ec7369c6ce46a59c83362bfb26540c2e2e7edb4b98352217f6e7ad24a12cbb3f7ed903b36a60b66172775c9c2629cefe40d8e3915fb364ca3d84550e7c78feb315dc0208e0cd9950c01f77a3cd69dd329dd06ec4e0ac30de76dc9943c499755b73834fff9bf9d25c81d7352c744a1af6eb497353bae295ae1f3284a5cdeffc39e1923e224731157c968b002226d65bd0eb607e376ad1c2a82f1e5a1b33acf935566525304f174bcbbe187a36a697e988008ef14a0f8e4b033402202d7ce4003ba906c5f05725b03eff7817654ba09c3000d6831338bd4925141dc5614c6120b3a399cd4ce23ab7d6b79785b458fa5680ecf19ae24602624a783300b3e82a28a09348e6e64ca0a6c04ef58d2fd8a86f2893fc79e64272c9db29ce6dc80f66320b9be75ea7bfe88bde3beece96543754e336a7a8a1eafbcbd8ccf0df654dfd2180515b1f52e1a96da20776449ecb5f2def56ca619149eeb98a4497f3bc3ec7555a167f4d2cb3665dcc82b7b0a3e94012ce1d5de3e4d30ebaec7d3b9ce7ee55d2430283553ea904588f07a7912fcf5a06729026d42b9f81fcf2f97fc6f642d7e9b609ac5425b6c7bf168cb71c766ddfc029b0e954a679f0897962b7dfc68f564e2c6c0509f11864d885eb74fb59b7fbd82df21527cd08c7e77387a7e5c60a5d03fbf15da7b59f1fa9488bd76f23d4e1c8f1daa9696f346a8e115bafddd6de9a5fa18e9a4c9ba50d6a76d184f773ba5eba517c44da96b6e677c2aae8bfbe8065ab9ebfcf6993c31cf27bbe9ce8814eb4345839696a15a4b257da2580059534e54bb2cdc6a53dda8c8f18550d7b391b1f4a006e1212fd38559afec943427c6485cb6ddfcb46b66976ccbedf2dc02dd341cbef04622c040eae3236634d97eb2df578e447e011770406ad99fd9574c43140479815b44eb18330eddc486ae2ff2ab312e6b6f24b6ebcffd18f95249eabd1aee8e864306e5f06f420d11a9d6ebe79ec4e67f7b5ae9948b13ffb2dbc93522c0ff82114d3bf27beab9092746f4bda14b8401c04d87fd4cbd1ae7a5322d5efaf10cb96fb336d0b77d578f442583e082f3edf33075b133af9c75bf834a43389e9fa8c8c3d673acd88d816c683e1af78da6a77f5fd505e223bda916cc09c4eacc76dc5ef9214c6013ea8779eb48d9a14e968a4e953371ef333e4281d32bc82cfb12b2aca3c94971377459c69c95a2710f416e0940dde59a0482844b8d52a78f9694c2946c7e767fd731bf5540693592be45918efe4682df486595bf861ae0c54e975ec41dbd2fa85f779f0fe0fd537de4a33acb86c871e401416531f2ca987ce410adb463aab1b3d3843542bda79d88d82fc880b245b8b0500bc499033b48d5be512fb5ea1b61e68705a07c65c169dbf716ca4671c247a3556e82c56901474b26ba921099bf72952f20a7c777c43ae2ae7e60768360ca2b66f03c74d382e305e9dbc53959d467aca4f6719f5f5862e0bc77cecb813a60e24d154f79eb4394c4f75fb61e8b8e21c691487b7fa0ac84876c52ba97d7662377441c6a5e0e0e3f23a322c180b6c195e6f4ef4aa7f0ade2ea0a584d262e08ee31b16c0e7f149a4f5ff20f50985b111722c09959f6d7de5976151c8f5c4bff66129d381a368990cdf462bdbbb91223cd04b6b5a7da8424532c2cb3fd0df341afa21c86d2302c7272bc87f3a8feb25def6fd6581eda64cbad4d0e353fe6c91d9679b478e3005eded9e28aa264ca12995d445b06c1b9ff1619324ea467dde2efa88f0b55913025797f62f501a841f4dca5342a492e1037cf59b886239aa4e70d4db1824423cec792c1efd76b62d492318cd8006531eae7783bf2fe840e9dec0aba873492289e759238a1473aa5bb1d11ef97f2762145a144393b1c8e1e518ec00d616ecd4ac9a288731b13dc3b62818441eab1ff6324700523cbd3231f135a36fca2599efa192f3c79dada23a723a8b6b536c5b4df83312bcad259bfec51958c301d46923765a173e00f8e0cf1ca2ad4918c20abadb7cff6b6c88cba31f73bce466d730ea3c3668e6bf774522f84ba6b311fa96a676f4ab3f360007289780eb79a425675fb703fd1a43626e785adf12643ccc7b1dbfcfd88020244120016f246b90ee5fd74e1f0a033a9dcf40bdbb0c38ba0afe4cc3611997ef60d225f27a4c30debf31924130f8e998b5cb7e1a791a035acf523d8842f29c9d7c361f477018f233eff6c018a58d8b28f92f700e75dc2cd660f7e9ce448ecbfad1282b3bf65bc4475d7fe9bb5eb8dfeb8a0066b66adb3c5ab20e0db80f9b1b0d1cf7b674fc6347f6f8c72c30572286d6bbac7e08e06533132dea2ba05c93392edde3125f640646b7f67dd3e3e850219e189449132a99aab157dd529c27f7a05b3f42645f4f774f5bfc44333781222f4380ae7e5681551f9693b6f316e887f5beb7f56f02471367c80e62f8ccdcaa606c930513b1a0e9c986ed8facc498119b92472ab62f44031ea27f1f1d9f8f6e46489f6e222a11a6251a61ea0a5c7a92e5707e09793ec126ef8e4547c722851d6c11253dbcc90cbfa53f1ca8b185b180ea18ab39972f2a284c90cb552e7c7d2fc34a222b6ea6712f18299f95f65dfc3fdd7c2a5352ce91b0ef3c5b6edd8b74d560122652cedab6c662c7a9a601c91689b8cc412c562142bd0d6c2497ef88328f8ba3a6b0a18481e06c438f97dec4e6d0857ad54891279bdf623ab23a895160b5d98ba8cebe8bac82e408552cdf44511cb9f649b1cbc066bf774a06aa4f54b5e028d67e57fbbd4a2d9a75a015fe786fc01b7a411f884b704a406aa674a049078ddc6d1b7bc3b9ddf9bc1f26abc0c0fd5a2d62b3338a5c3e1c9cb0ccbfefcec778b287235d75e37de14474fbda83873afd6d615873f14f08a751a670693bd0d5f8f2166ae501c5e4b37b30c65d3d487916a1f18c87544f6b7f957b78c341836ab300351f2ac7ddcb8037c03749de7998e30e18f92a036c16d9216ffba66e05f3b4b57e49a08885f7067f3fae859cea333df392783f8f4f8d9d5b158ce55538682ad9b187829c56e9fc71e2452fd89bd58480072ae56ad70d756404f1f5eaf23b2e866e522d6783c273b65990b34ae32025f74aa3e0cba2f7a01d259f1a4ced8929cbae16159f8b07c2e029f59f4eef423e81a3f4b2e91520cd9eb9e2558e7fc45696460473d35bc2742f3e759561c0600aee5a4b07f94bd5f5c306c1f5f560e1797de5186c7f0684cf6b6c65dc644991bad8da85e330a4b8efb3a2680410e8e52c790c7022e3f9bc060fb8418e2bf61049ed8261daf47f0b2fd8e3d5a1b5a5f356359df7f112cddc4ee9b6792a61b68bd56d26364c0ba2e0d59ffcb469c133766f2297f0d59f93324d6560b4d5a7e283862131d9a40b49d1fdca9b59bb435ab23d9743b5d493c3dd8211a3abb642c40a50d61e9d458a2b13d723572008e601118ca49dea58d11e85d6355999fdbe909611bf6a0109bad100edf072a7f27ca83aba1734cad722a265391e1dce097ef3b92101d2b3c595bf254fa0a9717b9e3753722087dca661f57ad8237db2a1582d4e785f1f14dc92c71dcbb4714e8e8a0744fa0367ac4ab9d737871f6875df6eaa13d10eebfe0e9db26a1132639f5f54ef5581c1f634592d3a88650303578d8722c38229c83e14231bb7b6d5a213af4246d6f85a9b2dfd4f7168e16644a0a425e9de09cdc0dba2be6bbe6aada10342c7bc67989a7731f13eab56cd1a355c8de6b9289e84c58a2558eb54105f97ea112ca3e6de390eb4fa04370994bc5cbf87997d81da8f41e24457d4805a414fd36e6f5c28ac72f88e0b4932f5d47ab6e75a2d60441ac7df69c399efb913f7a541f9b3e10abbb3024c76474515e3829383525c129f8031d613360f3a3963058914906b5e08d31250fbcd4e47ad1de941cf2af221e1dc54fe259fb3f6c28bb0fae6cf3d6b9c0823744d9c24e26782a2edd2689700c39e5b905456d652748d229680eaf7d81f005e2eff4d5958fd925005e2a3911d2215fc5be7880c0f75d501a35809386ea5f4c38e9376c646113f2814227d2563a3f21964c94a3befbba944c74e32c752a826272bb33bb150d70f993121b7eda4ced959e47d6a8691dc240d9cfdb5af3d48d6bb9edcce9ea76207cad4c735d9f39a4033b83c318d8e77538522823480a7e7a1857ad98f7ed8e5c83818b2400ed91f07c45b44ea5283fd09e2d08e0efb674d42857009d9ee56f7993fc8732df5a803496c025758f84214c32a5c1a1321a0a41a063b0383d9677e9f810784c6383c68d57b057db17015030d35fd0e1d0b600407af4d00b1ca4c66ca6de5c43f84b13fe003d40786df32ba33657b067f927d71e7bd119ed065fdb243dd56cd09ae434affce408a101730e4a514bdcf9c8895ad05529e93c5bc82ef73a9d85b2316a925aa2b82313835d797ae1b2eec8a645e02db7a02b3c5057a752bd21b8bdcdc97986280dd87ba7451832b2dc36e32b946806f2bd908d228a7c148eb0f1fd780a8efbcc77b3928d31fbd4603204124424f02aa332a371e692132e3266d9eed70389b265b86cead59df6d2f3d8db1f3fd403fb257c30aa838623e231b2314ca4387360475ebae926ef431df025613e13194938cac937944eb72c60a4cbe00b1b91a8e9fc000f4d0f0dee9c3924629155f3a8296d39ab7a1bb8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
