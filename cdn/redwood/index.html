<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8adb11d135738c24a03556ed3e6c45778589a70eea7e5c40991b1002462fe064a7282cc7a9a21f3ad936ad012779d47fea52496a3eaaa510205f65e62fc97c028e28aea69111cf91d1e325805d5d4e1607cf59223c45348d5913786bfbdc770dae4588ef7a90ce1252f7131a8842ca8c2387112cbde024f4e0ce15555296261c3389f06cdd4dc89aa8027a7aeb960f070c64b4c7ab53e0b2e8a6bd120950bfc9542a38dd70b2cc8d291b693103cbf5d3a915a11c23201f392389f9b1f4ed92eb9341cf2c0e23b34502baf66c5c5604e1aee8d6eda4e6f4c3a4677fa45993d0a0aceb49fd10752c8769f52f71a68c0b4bfc63f60123584b4d17bf47d10bb10645db752470fa2587aa7d058f6289f47a3cdec2281b0d381b37699dea473a4d93b5064b5f539d29e3a78e5c7df9b30917817d73c3e505fa69741522e2708f0efb701d2d7f5898864f2a6fa77bc3ea7f807c381f7733e58624310c3710a463108f2d285548a3fb7f54e70977ec26c2579774a498c15eb14682cb1482f93fc7660fe63ea08edcdcdc192270c1fa76c97c040a9b1cfca7a2b4efb08f51e9475f9c039504f445dffa61dfa06f62a3aa854952a56ad7e74e3cd36abf805c538f1f0a45a4b33a80828b1fba45443aa61062bc0b0daa3898efb39b530e47d57e65fdd2f2360feed72c64cca699589c70e662ad9a937a9c8025b0fcb71ff98cb0a9dc05a4e0513b775d6d27d468008c6ca85f91096013e5800148735e94cee5e5b79fa07b574ea8da30cf1a1ea7c0d4f9bce45d65bb63ebe81d276c100f53948075deb19bedc2e304db91951011ce981593be0df3aa01cf72b708302b01bd82b97a30efd5262e13a2acd4b3389c7f8eacb46700c4de8f29ff522602f4e7c226099353359887f9aabf1c12f1e1b5c643d78f221f5ed99aa1990a71bf917a92d6f5f0af05bafd68584d63ebf1d10bb8a88f4647e253813879eb1993571ade2a0c4644116b7985ab940697b57e621a64ee696501cd1649afd2ff70b60dfeba6c7634245e7d70ac399ce1613ca640e1b7ca72c2af79d6406359b96b2d18ee6f1310711a98d9c843228c18f124dbfdd4263658636f6e33449cccc767355bff9aac0e8b1b494e1c94cade740d912782e6ae997ff75afcc26a59fc050ac57812f4d4a3c16ce7ae23990346bee7959d933812402bb776e8f8db1707ed69d7e3592ee9106d139f4bbc9a973a7fe99fa30b7618bac84535476b3751219b1dab98795686f855e3008776de56892e41ec0013dff589549cb7bd1372f78291318fd6fb4af438b38ffc028f1c80e7d523c244ab7987338038683cd0601b65ca14741833377f3fe6656a2174ba7ebdbbc1ce344a671a167b09364dcb2b03cccf26d3a74faa64e73a7eed55bea1efccab8b92f4b3997c7594a1c4e07f9d5b36526373a63e81f57811bfaf9239c52b7e21092aeba28ea435773986778cfd38c2109ff22bd389ae2461507ddf9b568554d3fd2be811eae3b9faac8bf5a5730a4dad03a8c3218c61b63afecbf865c01deeece519924e6781992cfc5522981c998404aa4608997966309ca359969edf70f37f3c2f3fc1a9e201cc9ed1d9e41791c00fac9f2e4d892f126cfc0f1e46bf98dd5c67972e1c776cd123afdbabfd419e49c87534f0395b1d351d025116a4eee4c977870674cfc883b486c31ffc35a29bf72caa120cf00e61bde19fadcf98c55b1757baa8f17025ebd77ad399ff73a57aec3525e5e778fd0d8bf3e7f8da1045c70644584906f788672d285e14f2fc7046e72aeb9a236af2f22c7c41d16a2400e8287afa719b664695b658323a566dc7589ea66a6d327090ee42b0c3e66d586a13a77623e6fdff127d394e768f51d4d912e6bf9b8adb738ad4fefa11bb91474638857ac52faf2c80b296ca7ecadcb3cd712f479ddfa87921b267a27bffe557021c42b6164d06fc4accdcaf603039cec3f3e8b7ea3ab59896bd660e3d6f202a5738dc666f2200bab6b7f4d448a5407b6100f523cad5352ce61e6c7503fbb99bb99f264eb4d8d0eea2c593490c1c15001b31974c8c228701db1793156c68db9a2862ddb22b2adc3866b509975c6a3dd73ca9e6752fb1538fb105891adf18b2a06506f9daf70f092072397047f39fc2ab74c6eda258e8bb9c1a55401563985dba5ab84503121ba0b7563afed601f0eb3f25e63165eb950694a53883f36f23c99ac954b27ce4962d1a4d464f0b4c180fcdaf746011037e3362b4c486c32bd2a09ef0c233787e342c644749fbea1a39a4563af0b3abd2b2b88a993858226bf6d9e16faf47c37a50ca1ef3747fda7644c70fc978712360113ce54a08f2478001083db96f5e2873c17d4ac7c8216904d99c6bce3ecc5ae0b744810c63b5e433cc505d8ed01278b39071afca5446514f9052669b62d834318347ab61a873eaa16400f25fb11f0a8c5aaaf7e4d473829fe7ee318255c5a61199f983ebb236d215579013d1c9b8273835e3e8dbde975abba01356f142c9b4c1459f8b44203d3a2ba7ae2f05a58b73456990064a5a3e6e7474a6d7168b51a48d0f0e26ea5ee29b5dc70d0dd07880dfa7c6c54ccbe13b3371319b7796d158dcdd0ae2155d9280d066315b39ca48ac905eca15f4d5bff124b6e2c4b368a05ce2f4d0ea18a5847693d750d87a57ceda5be5c1e02427092e56b9510d5700af230340e711b1180f96ad5ea727c4824d8ff9563049a6a141d21cf992c88dbcb1a66ba612f82dbf59a9513196ad7b64a9db108c6474e2441795bed42e2d46e90c451c426787704859cd1c772b2fbb5033f5b9ed117ea04ceafcfc40bbf60077fe8c9275f70d7a97aab0a4417a9c0b9f920c844c7cb97b6a03f2610af6e407e1a868f291e778b3a007eb4c23e276e905ac99395ab8bb0ac4547fbfc05170b3cf6e6b6b8a65e3161af713718369f4f5503280a0a0a2d75bfc14107c8881531edae6c1b8a00e294d78b25e487cfd949b184d1d98d1466348b339db61c7329b05692989ee0be387721cc28dd64314826b6887a3d596c85b6038e7c04149e884b5f82409492382393f8212b74af78bf60d382cd39df12e9ebe46ff8e835ffb97775556bcc848495d4e108cf889c795ebb3fe4d89543cf0f2c00284248559f9bbe888b7ceecfc77d383f948f98ffc26258417646d29073dc252cbb6cc29f351ee0b0206e9b6ef139b1c2bddc84f8160ed5090fe30211259874ccbce433d0511b6e012ffd586dc0f02cb63657964a69cb15fc65bda6610e89896218c20dc7173d62ca8d87f3f727ed6f0ed57c2e52dc23bf6cb1505f02fef608bd7c531c82ed32c04a2c461292fe41f268241130bf7eb8d893d77d575aa4416bc2e2d3288671d30fcd3df357f992b66efe8d2a18258cabda67a992d5c82769cbef99d508562288cf0710ea898c1ccf054db44de9642a8c6583f2a28f8bfa7d17c387e1212808f14f59f7179104ab4fdebdb789817d4e2800f24c1f0adf5db9a66e50cabb0765e1b62503cd79edcc5c372404dbf905b43578d4e92faee071da11dabd7606bd492996e2f64358f0d1c2cf71f033ef0419d1f5df7ce1f438639900760d70b45a8c6dbf88a6d3e295b5c459baa5b05a7e0280378ec453713817b23047cb852653f2004f08fde230784e39c58d6c3fd2d5ceba45761e5963c289ca23030a275d8fc15aeb3b9ee792ab86d9c8f2e3b19a6c9a7626a79f6ad4d29b3124c7ce2d8d66ac0a1f2fb4d3fa1eb9bd00414366aa08b938bfe63a6a69057d32f2b6a2c29007119dcbd75e3699253dbd15abc3b46bcc900d3d3cba33e0b0320ae6c6992ce6cb2b98b6c50c7e084f90d0fd65df8180627658c6e8e432e3cf0fec37097764aa91e15c2d4783f672690aee956003de965a9028b83dcd6ed48b6fb070904f2f34a3eea15dc73b453c7fb800188287c2a478d78ecbede24970ce951090ffa4d4eb0025a98f7df33aadf8fd6c0dcc3fbc3043c7e23a6a7ca8db779ddcfa1c3ab301ed21944aa7dc2b69b9de2d1b832f4ff41faf0ce7dbc9208880174017a280a3152522ecced99afff1fb4ae972b1ed5c8d55f72be7599fd9705569bb7d77362f742b78c66747598385b3d78144878f039375a7a454912b236942b0de8aa4b288e5c1b7105520fef23fc232702dbba51847a6aa6cd7d97223af9813b76e6fc5af7ca7ea5d2fe56701e62443aa55a3563d1c143202797c0a15b5bb7f4f350df686b78ffa762473d3406638056c2957c5e27f6abf0cd4d0f30159f2dd6503d23d3f90291e20b618acfed40ff4a8cbe5c0ff4c1422a8a638f6a72051650cdbda21792648f203ebbb5032fbe2a2a9cbc0fd7d2ec37c2bf515835f02581e05812b533983ca320cd4c259e686e38cb7cbc3192eed73a14aeff2680085988b506d435469ced486e81d0f694078e0f577a433638cf16201a4e1feaa4bec0dbec11170a4299d97ab2090f991893f6ff5130081686331623e29ff7856e0a12318a52141bf0edad0b81b36bbbd51084746a3e313a5bd14b8c3751d3cab3adbc375962eb999c047035bb2e3496ba479c4773d6563ca7f3753e7237a39c4efc6d7e428d9a5f0b5445a96b12ef1169dca8e1104eb4c3e2ae1e84c8e7ed9501cb85a9025a8f53d80d447cc511303b2035f1e73ceb45219df70f89fdf45cb56019e993fa732d12dc4baa9745f26508de8f7a1aa708198b35a97472883d4efcf56e47e48cd0cde88f9206bae2c586b6270708bd2bc83e545e67a08a0ddb03aa954e7e68c53533bda35c047eee03570208cb5b536a04e3b778a46167a3f48eee26cc5136177eb7220d4c4d0fb65cb460790c5a3b1d05bc9168283ed38b41b33c303c3f8240b6e1a091b2b23dd31fb8aa86fd2628970f02efc111dfa1d2ae77352e7d3549e35f132cc733be2a2e5d7e0dd169b51bd22a7a3a738be78ff2fd8ab58be66a6b855774602a1a7d02f1411138f1d11fa1377b8737537ed2364c1779293b3d92e86678e6d130367f7cd2b5f16f22650ae1b81abb051ea991ab8a248ae22fa5ff61a8ea3c215cc75944cdd5fca676952ce162961a42287b2b2ef3991f86059fd137fa8759150acd6cdf0cd2227e5519baf9f3dede4e3851ccc92717eee07850b793d9ff8f49f3de5f331791ade3caa24b2ccde5fe59ba75b3deb77b77786e87005f3568017e0d03b5ce526eb5e93af103088e830a81e0918bdc980eb1c17261f21b7ea3892aaeba669e9b807d74b74cc8371a989ca0960ea0c2fadd3d12e7a8d5921923b363da035f0409d1781084b1b58a9c15b780e2b86b96a012c9ab3540804869da2eb9c7872b824428cbf2a1139bff3ff279ea4ac7665013376290f049b253d9d423e81e42e4bd886a3263c909082a64e97d56801287f1859cf9bf76c6ab7ce9a0b270d0952ee873e14010979479e32e1557f4c294e036cf8a553620d54d0c71f612aed47d86c775e21c96092d6930b7f3fc33140832b016f69ca507d9919dbea5dbeaa72a72a6370db63a797440913fe0706b21600450ebc3585c2dec82b2e2d4a837e31f713680de3a6b14277dcd85cae6f10c63f60b9f8237f7fbb3f1b6d2dd37d1ba5f56b84ca7e0e0bee1a743ab8ac705653941ad6506894cbab1811a2d216f6bf670f48cad7d9c2dbe6890828ab05d7071a1a91accf3467dd43029f52e1803e0decf96f9ea22396af5aec40b7af5170147c4be673c0b3ae41c865f13bdf63e078d3bdbb695643a5062605048353563d9f4411420a3465a6a4c28fca69ec67c1d562dde92861b58b22eeaca057077070b8bdf48f142dc0aa24a52f58f47f3b207883067f82e6e33fe5bbb62d01d077dc67261dbcf7dd7113c2f7e992bc51e187e5326c7cdb991dc3700c813ad131ac9316d9300edfea5df0084d94f6365252a6593992669ef637de13566579cfaf1b12a6762f9765d43b9200f2cd81944f6cf5828f32e7342843411eb00ee60b17d686420366d10ee54158ae2cfe7e2868fe360d51dda51c0f3e8a25c20038f1b3ea752a576faa6acb4c9100d2e3f23597361acfb20e081aee4903f574605f78dd29530794ef8c0039dc53b1f025f13243c52dda26bcd706126b7bb62db13bccef7cac60e6f1fc64cf2c75d7c3ac17821c3e29365dee2c9385987433945fc331f84f4d1d483d8e097e3b296afbe7553def3aaa7312ce833f7f84b43596fc6e72b4a6e2924f0885f208d4bc4f24ae595e07b60b035b0a4b2f791f5de7eebb8100a519b822289cb42f104f1b15bd6e6d93c4f12a988fc20efe2d73b20b4db7257864a5f0b76fdd511915a912740c6727c8cea970fff5e4baeb1d59618f3b35ff0c62e24ed751bd534263dde81dc6941c577f8762d46b312582aff3ba3abc03bb0ebc9b660aaba2650a1b681113df23f90538d6ef9721263b64775e1349b25ed66a71c3f8d34911c230d24359bb1a088106462e814462d1652917d16e2f1d7e8423021d87fa564335255633e69b441dcb3ca2b37ab8625f904c25588751c0d47f02f4bbd53d19f0d022c88a69611b6c3f7485be1d79a1a338dfb4e9c2f24f962ef1d10f9fa1ac6906d4db2c24cc5d640e88e2a15651ffe8ad93363af786f717612a87bae5039193cbb55967fd3273333c3d0e162aa34a00aa89ef95d0f15a7398789a0eca89d09eeae16c9925219bfa194ff47f077aa6cf062a6c4356c8a9ba5772092c602a6b79bcd36ab349a27769c49b66e62230299d6d983428c2229d76a65810a0ab5740dd7e2c8ba545542b76fac64968ce46dedc1483111f35cad1c605752fa1096a42a92f2d664a9777a768e09fa2aee9354997fbe43d1b3f80b4eb3a25d6c84169e0b5ca5c8e27e90826e120307dba5d631da895f45d6a2202e04ac8a49084fe3bd087625a6bb985e7d383fc79e1a011df239f1e5137e3a753de3a86811a288cbaf0b1c56b0bb1d133766f129a87ba63e16b59aaf2683bb2e5aee45d39664a3170c6602c60d25dd62b9a8db702f13c7047819d6ab4c44dc9b9242b32f19b07fa506e0956a82f499135b56be6ceb01e59a5f7787a632fec544d9d9a5f193372be1f139319bc9e331fae5a85621d4cd00a5e6b62fad423fd4bbbee3a0dbc16fdd5a8ad700c49737d57882c8218d3a530d7068878d94810668e79031f7da5cfb7acc967fc41afd11e0210312285ac20995029c7cdbe604901f88041f28daa0be43b7e497e1eecbc5fa597572c96d73e380ac79848fbda4db9fedddaf1be8fb954f017852c6c9617034940e688df2dc0dd1cd5924797ff1252ec198c5facc7ffebfee7b5f4d6c8b7102b9e729bdbfd36942df02afc5a3ad85b152ca7ec6e4526f803a3e547757404e54bbebeb9bc93aefbd48d01ca2b109ae279ace138bcf9c4c46998eb00e80bfa196ee6b0da83274bf10d9c785d5276d042e43da9e5f42952170aa39a0ed8bb03c8ddf54c686c41c817a7f18c708a6846dda82d74a1d1069ba3db62b152300b20e6b42d19721df72fc56d1a6c8eb8bad73363f0446613889f54b3249276bf5f851346854a6bf8c884f03d680013138910072074d4198a59e27e43a019a553b88d7af0037def0f64be60644249cd355deb6d5ed74623adce568423b39d81c3c349894982a8928bd442b54fe70ce865f18bad4eaeef3d4a9c98da9c228091a5674374201245753584d94206c312b69d91bf69e8e5f97db1c40108f5f6688f7f95ecd991872e095c149da994d678463817d17d568251a0b2f4db159e05891f02065bf1495990162d8d3f96ec41d5f5289caa62b2faad64c77085970cc301f0611e87e48b192ff159f24304d1e71098a6443e5fa2f4ff2d344690ba2edb0e2eb63fc7da99839152a14a5721f9d8e6b1541d56894cc5658d5bbfaac43fcfa83a7dd6f87727a439ab1a665788dbaafe3b39ada62647229ebc2e09609f3182543925f006a3b2eac4c1c5d87b1797f6e06f29909b43c1efb91a5c20368136fdb8d3ee6fc519496d03f07a531fb7697dc78869bce067c3507c2679d73242e83fe04cc1afec4dd2bc1c39acac6640102e58b92412b48d36129e153513b8c1ce446861764a04063ce8021aec6b7d7d777abd152172230d9c1dc2d20069f32df19670d8afb4986585044c3c063eaab6ddf9f1f0843b96cc8f908028bee7291102e2b9f8f3cfe46bbbc80890828cd7ae98cf353ce2d5b01601539e63e7b3a4de58ab83086afdefc539625ae7f18ec9f2eb71ae56325a409de39382c161d5a4bcaf808a4f205d7faa8d304fe2062b32192d493f02d97ce8fd3a6d65f154aa643089e12c06cd53fa10eda6ffc0135f6931208262184f56c9c2e85163b483368f2ce136709f0a01c1d18cc9c207841022d4b812fbed85834841733adc0b677f14ffe0014008f761221aa66ce8dca9a0821d3984e3f9b052ef2e19b8a1c365e85642ff28c1e8378eefa099e5cd21ea5dbb4edc57669e6735f6c7ae87c8f95ed5074a00a022a56c33b1b410c7922c1b1a6be42f777fb840e124433ec21dc396240ecc435054be05f42d69aa4509a5eb84a61508977f3383d5ec69d7c4952f2e1e01cf16f75b2b4d1b814b8b7adb331e13bc1255cb4f0cf130ad5fe035fca3bbd2640856a105e6d8f487113722299cede18a68f95c8bea09092449d286fe629bdd86d9855eda268ce8105c8b945c198c5343d8ae2e2d18b819577ad82ce278efd269127db79238b3da4b629817444b64fb7a182c95813b96fade3961eaa57df4a1c136f2ea667cf3134e2199afea3026e0a264261a3399fcee043fd80474c36081bfb0ac9a4e924e182c1ab78c4cacbdd737545b58a752004464fc8c61ed05f4a34d5be1e216ed1af54a682e27473c70d86e2277e98313052554c6101ae99070886f5ea88dc275c65b7ebf83053cb1e0b2f299ea13accd6c3bc8667aba2f26ab708f25dc09bb13f6c1a60f380458c9f657ed7f0ebae9f7bc081c1ba20f338ba2ffb9e65dbe79676bbc79f0cc6d8c5fc15fe58203b065038c0d703df51de3e8cc199f0824228a68f5bfd3f42aa7f5649b8d7dab901af4ecad7f0460db2c930ace3e990ab4c8a9a849f1ac473b4484bf869057fb5baa48d035eba3ebc0b29904b9acd627309067b1abfd2fc37c557e66f77884cb501bad6f73b503f6b0a73bae253ea0ead7156053f08bfba91f4a8b2967a066e66272ca0d653d371b1cd62874a35ebcbe0633b5238cdc2fc15e43984d8ef051544b85fd5289fa9f665a723faa3094c3d6709a1de1fdb9b26490bd86552757052dfa44182f2123f4b50c3c194819af8aad8fda45b4d9a4af1840bb4c8a41c3aa129aff9c3c1ce02ff1ed431f8e85e558d3d419d862d4b9e6100fdd1423714763b7ba2e7fdbd80b56bc2c5537c1d8bb4da6a91a696ca088b2a97390e9603d20c276dbb9506f5a689189498d88753ca6cf07541c3ee56ce8fcea9db18f7a2b09312a4b42e7d4b745a6e3b8a388a2506dd8886f202f9fa035583e439bca9213362d7fb52ff1c27f78cd7b62ec9afec86688130a29c94d655bf6c4bb8744451d64d4c13119e21b62e6ceca91300f6573385da2a4da59d000a4137aa6d84ab121679815e62b6876e45eaf1c3a7e6979bf3c9f42026c1c245312a4bd00d032d72be9f830eb9d17bd6d6d1b8897f8d6cd433df3c4dd0e667909df97011f52e2943d144f7b49d3d5f1b7c7442eae2be192aa851da4716a0388acb4735af0cb1d2a9fc1719c349634e4b795de471004892dc2769213919880155a2b68d3aebb657be3111a5509c5c78b6ba8ba59a4fc3de6cf50872e74adf95ebb8b8d9aaf28d5d1eb26ff867b0ae58bd9d053959225d1ddf6c161c0854c53c9b57243498f2c998b92c9fbfa1c5f4640f5535b73ba4d74372b3e3a02f6ccaf3cf7d0aad6c78fcec0c98f197fbe8ef70459fc21a7166ed9cb1d1d5e25ebd40d953524f52e50d961444ed5ba267301c8991d3c93b160185e8d79958a0380e9b3dccd6578145638648a64691d1f31f84f664e201ad678e0ae4ccf0b053cc8e41b8a046a003f4c04b196b105982aef7d8a6a759fc05a7e3bf1d745bf95985ea4eac1f417893fb8972452ba57d96fc3cbcd732c7da6969eb2b1ba4c9a936c57c8601af20acfac09e1fcace57cb326fd64583f2d306975a34d200e691deb7d3ed6f21a0c4b3b58e5c1e9b90c455e414a206461b80593f548f18384a35b214455cc2a863218dfbfe4268e46aa22cef0647f55a686a0597cec6f26d21f8d4438922abf13605edb31b1ac58d474e70a9ac28c9b72c58ae885f410b7bc489ca513b8e213e7b742896e5c3e5d16b62d0466f773f41a417342db9975ebbb9bea3315a7c92764dbb91bae65847aa745a309e7f6bfe6435e3204b06526c9b5696ba23de0366e5799b73441bdf89f4ee0a3a780e9b97453bc1cac49d99457c44bdc868318dd3f1eaceb73502c7519f832267f5b4ef694acf4282e54a09490d8e103b348c65f16a0fb44a9ef236779ad0ea7860519062a6c695bb4bbdad85cd8bd076ac26064779369cee9009c01b2dd05235491506a0cd9cd65234067cb298e9978fb258aa50538cea4cf1ab250ffde913049aefdb681d325b7cbdd21af08a6db446eed12b54148dfaa0c06555a4dbac529572606191918f2c085cce8970c951c14a8a66de2a9b5d4103f13d531f59bd54731851bce56f426bae95d97f581345a48685a7cb5f6aa8736a876f95d48c4833f05d5f80361cbb96c24271b188cf0ed9f447292d3b084f5a8c874c00d4601221aa78cb5703bd22c2e6e44e47edd332de26170ab4b4fe6c2739910dbcd1d8e24968be30108eb09ce2ff1803361bdc03c2d21f701931a07b70ecab053b7dc6e5a09a34b81d170894bee124cc424dd80fc4641d8c0044b26caa1c906a6a13d67a27087e68401454f3e65fcc40b3add3fb904cf3cf80b3e4eba43bc2f457b04213c0c1da250a019a948df4c097c42b2eedc24933aebfddb19f523062f00086a989224777d8e7b4df1b815b25e5b848769c29a0c207d39630406b743b507440425fffa64369077b32915b2027f6e8dce540bc2f75a5a428c3063f8b750bfae90a059306a9fd92d85bc58dafab9f13d265722b460d8697e6bc90bb05a14de4c952e5421b9321ed332d46c451182343a78b5a9d7c20ce0673984aede4c6a0cd308f523ea72341ba76ffa530327e46c7d64ba3ac97d005ac21a2c5a4d68a652cd6abb6d1cbd7a24eb1c363cab2dfad865d5ff1d2e261b7af68fe41b28b9e57609d535f1cec0478a45127a42b1ce337650c73ae8bc3288e627c762c893cb194c04225a7af55ae3f1ec6d8e8ca91bfa5ad47be4ee18e8a00f4deedd8cec69487c6523ecd3cc7b086ab003f698cca1493b4eed377404fb844be421468ef92d6d36aa337791769a8e39a67056fbabc36c76b4f8bdf67a34bd1b185ffff79e94d82d2e350a8dd6214a7047c4a7f16a934bb1f44fbc32f3d35fbcf995940c8984e085da163d1bd8888cfb1b8bb14097865a995cde20d15d0b7161804b50fb98dd20524dca5edc2b99b45ed4d6f601b3cef988505c099ca873e4d74fc8f92601221d96ee5bd8058d374dc237bcfd2a13c6bf68493e841cfae9e1dabdf324d8ced32f596dfc5be8fd9fb7f177d7f36f05fbf3bc90044ac9b1ad30c8830d204e2d2345a6476cc6c8c588baa0ff6721f5dc74ea35212125562cea31617e8a86dc8fe3fdb8e8831d80f016ab0d0d5d781415502e4d989fc8b46e58bc964e1231dc69420da92549177008513b08dd94211dfba7d899b66bafd0e97e0aec9c57c934c186c4bea02444980dbf7cf8596a4addeca357894f73931aebd10b33e462a5d51cbd8b80b6a8ee34f8120882a557bf780a0052e44ffdde752190fc2c0a1a7a694b5b7d892f1d004a7e8ebc1be7ea6056f2a50106bc24ef3f951a27a04569f7400341bbd78f29005ffbfbcf4bf6dbab3a4a5d2ea19b0de1d229c209b874a7f042aa77528b477fd2144ca77362976e5ec954e5ce6b0cbaac715641f874b2a22209b335f74576d71d5c96c184c50dbc00d7df7d762cb62e599ae174b096ce9ba17b4d79f3930240780cdd572a381dfc3a172f3fa74d9b210c8734be2bd4f85a61d2d7bfe1321412e79308c70a2eeac705792219f242d447b602d38936235decbf1e0e692529d9f180f8ac174011219989139ab91855e986b44b923c212212d4a404a9110e3aa4af5d00fde82ff82edfa9e09d1ca792b117b9c147f9f4818f80e2cc1cf361a9a19c8da68fb189ad1fe187b177c4267a7b3e5bea3525f8b749f0a7b45359ae94613d810bc526e4b1a2e5c51f62edce0d118aada127b661e7d88d5ee282ebc1e51abfbcb2379a76dad2a2321f5108fcada816e4a9726e3382a67be2acde2e3f39ef0c56ea63d5cf588fb3c20fbb49df33531a9b155c5509eabf4010ccb5bf54862c2d989ccece1a81a5299035f132f5ab5c5e673e91d9ff8643497e1bc373e79e53be01336d8e52cec42264e306b099303102313899029da740d823e87083d84424a42f3670cecd347b13078b37ac9bebdc376bc99aacc5f0b9a184a4d0c2b46afc7e0926c7ea497f8b7819937756fdeba27f618dcd956e14af28d9b237fb9cc44985b5819c2b76ae0271cc8415da6031e7dea7699171c3fd6be93f5c41078ee804358cb6f9b457fb0762e982a5df1a74206761c04a42e452bf9532e98f79cfd255e74d6bcaca8a9125a4e5c9e1a059616ddf3e3ca8d78490a30711d8dde5b4786fdc0ed91f8304bfbf09f88d2b3b90c659945e1cefc447f26dd4d7974489affad243cbef1d7518aa606b31c0be499e62f5348eac64d48815a1fb45e3d6ab1fd84b3de97c688758af511ed91d41bcb4d7a58ad32beb5319b548d65bb6a005f22c74cccd40993d41de8be1a37bc21a491d956852c92364877616555c61b4d804ff45b646dbe4ff8e48b3258c6eecf61fdb8d0291b3971e78830489640a4c96b308aa2645923f42fb28a04ba6699a6bbc6976267e14a0c971e3de0ea60c24e0c57942997d7353a154ebe658726051a54bdbc7a6cbbf9cb98b6c550deaf3db3510e414771b4380ae6772b563693c754356fa75c78603dcb0624f6560644602c1a781a644b6b27a9d9182be074e827130cbb8af09a601cd67a3794596858c4f282b948eb9a9b30ee2b5c1fabbe7f83bac37247c4fc6b8fde7627abea6e1923d7bf94afecf74d8dbe0a354c42b70ae6b4b30fab24bcee9b6dcb68ab24c1b510e581648c338a35f5315e4426e4765d70462c7f3769f8a8afa358ec2787ccfff51a088c3f34b9b0ef0b20326fbf8deac9e67da83448f362276caf58e721173678371e715cc18455f0786cf9a869b8346f9005b4a3685fbd1a6af7c518cee89a393cca3a15c042ae24cf3d3fb019ad45e7124a44192a93aedfbd1f5caaef132c2960407c73a9847fb5f2573c1f3210bec23d7ff00607454a90eda0803c519431e1b2bc2149d723437dde717e0afd8eb5f068668bacdfb33d29b628d29e16052430c353514d3ef6e199255b8363f08c5733f6ff768485e695214c50c677e8cb9c71cae90b5d0c78d2b938bc74c55a3475c7583a93254638989d617ce171d3740eb814fecd1d0ce88b49e0229b13c2204cf2d6c609bf467ea502a293f3c2907dfb516acc46afa44c52be790f98c4b2e8063a4622f0609e9ecb545e48757867ec6209b18573db5fbb3e309cbafa65b15e8f6f9668fde26965884442518079ee906d04bc57c1047fa1442e24b6c924b6ded4e473f7f7eb6e7f8b8bf18300a7cb20845fbefa1f9aff08723222150e499adf6de16664012c1c78f7c9c9f9880e65b1b0370868ed4b1e4aad050a569b99eaeaf4af41640e0148f6001a102d3983c8e1ac1250dc3ae9a2a20e18c8b1f305225c55fddb6ffe9910d501b9c5404f85b6217fca7b98fed2b14435f35189bc8233b94fa2a2db9ff32f2981fcf03c4e2745f84f3c7eee301bec0a9376e5ae00b4b2aec27ed4d7d22e86e6fb459b94d766221d1a316f6510ab74a0bbea0ec2c4abd9d447611d6cbf99bf7a288e39fcd41acb92210e7457dd4104c1b760d1d1bdbb383f75a27c69b87662ccda09026551203c879145505cdea55b57fa5f2c5de0c6732841e563c3d699ba1dce1b3e99e02aafe23b95bf08ac150269eec63998c4df2c0d82a6061ae5bf23933c2ebe22b43250cad393df48e930618491d69a6eca4484cdcf213ca163a45001730160a756de744a56dd661667fff3209c7f6cb67a185da943eeed3233dca2f87c9b294df37ff14e8b4df96323c8a42d5b7950e7a99ea1090ab0f77283754dd64d6a35c4c83e127d53eba1b029c25b78b62905aa2d5c04062eb0bdb38b1bd7e4d22d3a2f4c5a5cae6cc2f329ac625c7c009eaee32b9519a12d870ceb0bdb691c111d1598f544c82f298df788dd8acced071651d7e2c65481a41c605210f095a938226166ebb21f79591c2eb1407b1abd4233f98af710fd4ef8378f75fe162c3cd93f69131867ea41d21b35bf1b6660d0ce58246c54d43e97dff59ef2b8d14285677f098b453b6628f6ff6cdd844e12587976b53bbff4209bf4316d57c300a59ffbf6269b68e5804ba5ff3678af28851d2da32b08e8c9cbb94b4c8d7fc498763149bb43ea6a196072a18f3a10a14405f3ab6f1a7859a5c28c3ebfef67a54e6fef8d3e7329cac413eb2d39167fe67a5500ef3c10e62d3337deeadb238cceead2fcd6cb54a925ad8f473f0b899332c293809152334f360d1e3ff9813262293466dae327246678ff3805967268313274cb28f3ce33bdcf444a18d0d1bcb2ee080854922449a69131141a6a0ee4d2588444c1e8d021e60d83e327f873ecdfad89329aeeae99477a9bb1f3f38e6381241a10c7a8babc826fad426219c62cc8b3db48ec38de4bf6ddced11760bd93472e1419d51a14dd68b52f6836cd530a12c28c6c35d5d9137a8d92ee652b0de20cd0ab53b7bdab9b2be8c6ca9b936301b9d2dfb729fd9c0b9b93a8c2abf4d33234bf6a34cea045823b60012bf35e20a45bf3ba56cb60badef0d90ce4c18cd43c70070ce239f3769f7856ae0f51d0beeac95b985ba9863a8393f1b30bb8a467c70a90f44627d1ee452b9129cb2ddf4ce241f046ebc3fdb39aedb38560f37cdf06dccff125ae0ca723e8b107127cd7f44191734a74feee27c3d460d354d06a27eff2c915d114e6cc476fc52c55de79bb3931f83150158eb15ed670bc556e0fe438e83bcaefeaaf09cdd81f15595c1ef7d015763e7f7e3606b9250df4da82495e7dc4241fba8c1ea7e41f48c95c3f0bb815a7a0c4c32e043b7970bbc0288811b342047cbfab1f849689da4404703ba7169bcd4ffbff606a148dcbe374617c140e3a9cf61a92413e0ab100d52a40e3d8f1880c6d5d33bc53e45f0735d32cae1a019df13396578d5e28361b0981c7d1ecde3e81ad68a16f3b343399edf46cfd2e74f41034d138aa76da31115e72d81d207873d41fe79cc9994a25d73c79f81d5d0b38cbe0fd5fa39d4f3bb6e7d0be7f838e76a4861f16846621de86eb49c3d7dced3395a084d3559fea1ebd941a847437ac4a40c114e0f04b110461460c2adcb6046a404958bf51966dcbae06dbd644177933543b8f778c14c71f1cf7124d1a9e55aa379550d44461b432585d3e8ce16de7587a4604e86671e5a22b639e5348c368e4d4884d411bfe94ca28abef80d44d3162f3caeeb17a9a8c575f5af88865ceb31f9c2a5bba2d405b71acf44f3f1f8f55d29a4f95357d535bbe26c68ae3601978d85808281d9458ee1c951d7005040bb154b43f458eabb07b9b701b3c6deb0ce1cbb23f29c5aad92c09024b38a9d4f7abb1e95156c5643dfda237ea64945cc957c21fdea1951b159c7a1648f80cc8804c034b694e970eab7224927fc75b0de36b3a33e5a8f80ebd3b50e6b2190b0e8bda2deb1b9a70d0d99f12a9d6b3427188eaf766cb93b79b411b224cf3a24fc8af02f33d2ffe9bdbfefa6be05dba74174c04c644504493b71f63e2495de1acd82a0f52e0106b44f17c64caa7665854e458fdf1c1a5b5b7a4d3dad03d3d051dd2050a18f08f4e5ca6777b24e147443ed30e5bc7516041f6a64176e05a1f4544efa2ac790ce027d5ec41bed1e8c28fd15d127214e9e16e7937bc5fb28c3f59a13072eb93eb8a8e53c870fa48f375f741e9624e6b01e8c36d9eba330a63614f1d1a8d05188de2c3a65c041ff432598c6f32abf641d65f209f9c19127e9d3d538478902a7283e8d6208487567c0a2b0ece862d823e9864c31723da8e0db314d1138d86ce91e17430a89bd74377027260b2ae3ca973ecd82d19504b1a993ecb24d437d8ee50e105323a6434633e2a3a9ab4d198d34ae05dc9f0e5f6e8333d1125dc169fb5c01d547d131dd8dfc809e41083a66e724dac1d7e00b6830e95c127e23926c76ef646f9ddd2ef5d0c4d60036591596182bc19863c95663aaa6f345ab425363fbb855416f8ce42233e08dba29621da60d1d9cb5e3d5205c019b145c573ac4b8614a96888752663d29c54d795ee69333b669cefdbcacd7256ae22c23b97e832cb23bb8cfe052a79f087d3c9a1d3df0a3b15cc456c678624f10c4fe7ca534c6dff3cfec57dfbf784f490fd45eeb9bb224d93fe8d3ef8cc1b41c44735db90f1652e4c418523f3018355bd410b85768859dc94db82c53c7480fe854ccf3f5218ee1dfada610a914cbba6bfa27e2e4a491b3f4a1cd23f0e6b0e4cee142f12121e96e7d5e5414393b9f63d22b90d379f349e394eef7ac1a5357ce770e844e14a575facf4724e840e8f26267e434dd2fd9cf9ea51bd23da0866650fb8ddcaac7f766cd49a9851ee1a47fa7ff10db36bacba7062ede93e1cae5a885c85554dfe446cae2c0c9f0bfc2cab9fb8d3a30938a8c46bb3f1f7b620432bbd4a67a169f3dd10f095457974b9b1cf49a8302b6bbdc0a484a6bda3573313b1e20de8016015e8fbdf7bc168e67bf926d3492785a9a42cc38d49e5e74894d02e5d3a4a13592ae8a5fd26d2823bf95fc8971e887d74580a26c6f819df58793a18a85b856cfa1870006f27eb7d40b2a6aae38fe31d73f526154c35e1f05c8ab6c26bc1b77f844e767343b26fef31df33e3d4ee29d7b994194fd46f082813066e187d7c3d114877cfce48d8ff09138df1ec2af1fff9f8a9520d96fa65741030b2354683bea4d45eec462c600d7e06717949e2a1444ba3df0b0ea7e56f3f0c9d03ede9031d2b12335147451c53fb62c78187eeb95ce03bb9ab5df4658674cd90ff0a4507563f21055d97882ccc69a378651bb7d8430e7808091ae9082217e3c8798dbd944b54fb0f26f4c1f0f3d290369886ce71e4d9b38f3799f9f7297120529aad47ba55cd9dd255862ba426dc2b4f256f69b4b4935c684d68d62bd13302765b1b2e9185e06c611c4c4172f53a555beff7a4aa40694101b57c24542667900b96f5feb11f9cba00a5cfd67b144c4e5cdf0435033c43f782508a43705e973660937079e3f768935c83a914a071474d2c5c600387f8eea1fdee4011e5ca92f790c1a78e8bc04f961b8aa124e0eda020973c63200c42bcbd5679d12d8b74ee79d932f9a637d5fc5f1e80a5518941a7aeab0e917c1dd1003a78b3db6af918a4914f30cdb0f186a9f4d682358356197dd58876b4706f48f8815930d97b8f47bb927341c933b6d1ffa2e7a1f38620cff6fe41d9913c8d0ce3c5bf138ed3f06a207e474a8d37ab9a92319b33d023c0337b7b36f1be02bdda89958b6802cfd97a768297448f179621060ef478288ad0b2e7de53a93cc4f8325ae1ea780923368ffadd74bdfb87512ff65a31a42145e5ae96dbb2a86ffd466b4ae4e85edc714f5cf65e9091c31cf4686474abb965cdec27aae191dffffb3af871ef7293f54e61c699234ce39389f8803c1e617ceb2efd1a2893c1055836edbe80fa6ee91fa92974e475947d848123cfef1c5c872f73e35d4be673dc64f25bc5b78403c3a409cbc356a8fee023bcb81fa7bfdc8f515890ac8e9d68fee454a0a45f81ad4d665ec3b5c0227f60","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
