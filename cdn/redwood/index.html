<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"15fc1f3f95d7e6759b3b62f6dee216e74103e2b2dfd746bed69406508ba5a2d06e6ba4b95cc902914c079b1617e6f5683a2d077e3880f705027674c78ab0d0d5fd52705e1c3b6ed359de699578ddd526fc122c50d7bfe02b859ec4c201fd0c5ad0a5098066b93201306c3e73c958d7a247486ce18639a9cf402c9f4541314b28563927a7f1a297ce2a07d23c3f42846299969519338bc6243728ab3c2646438b2bba3882a5319c1cbb9d0ba4b1cf9558bb4d779c4c03301e5fb5ea53335f57b7818fecf1c194d8535e1d4653eaa37e52e2e07491238deb53432712ce435daf83b1af9b7265889ee8458f5f526a19d42a5883f196f6892fe1ac816cd95065c5104fd0b8d67e07848391e3446b1170226410628d504a53515f9a75379fca05af84c5f3ee2824f8b804020f0b0e216b80ddd9b21f6472de33f5e4baaa3c61668ab02ad3007d57df0997b21b917bc7c56ce591289012a5c6cbba9f0ef3319a57e4ad0b39d00350c8060d9938e101fabe8c143f1ecdd8342ebaaee475be791c21818fb33489c8f5a076886c77b4b699314db85b06c265b71f71c448d7f270b1a3e29ef13af6583f5c489536f92c29839120e1bc1615811126d64a045d9581957f8aebaa024c8db579f170eb7fb870df4b66ddf6b995567471e11c7357d77c93814b19315df8b35438a5669c0cf502e93c6722331cba7e8005aba0a296945b2861e53a08094b86c3e1496359858e63decccf05377ab175d7780ce4d9273b2f1cd284ed795a205bb6369f339c90cec862757733f02fe7ac82d196a554de57e5d80fc95b7b974c48f1387e75592999e581a3a9b844335ebaa277f3f74740ba3194eaf63d0b176b27ae6e87039c15893f00fb727d5594e4e1e97548bf4bf91df3f494fafe09a5241c66faae779da269c37285e91c3aba5a5e875c5b78902ca058c99ccb3cc60e8da1854b9d52f72081fba5a722a5eff3cec0e813174b3cd9681c0ab37b2bb12fb8ab7a6d9e376351ed72f07081fd59c0f79b69779bec1018648ff07d8f65b98f96299050642b90fd33b6b1f1e425a18856a508dbbf0c63d08fdbd1d4d1b631ae7636e97f26c22ec646f071887fd8c0b9955564652855117f1651a6f1849dbfb8f7325f69c38151a630db3dd2e49d953fb606dd90a070dd69b7f4769e79f40196fcf4e810a743644fd683b4bd2f73d0d1a47d5ef5870bf01e7f395a87d98d1977a15927d754ada0d43ac2cb08836d1a0956bd51a06eb9038ae3c94219f16433853aa3d23cc3d106eeac26d1f0285b464b7f30e215b6c03ea50ce16bedaf0a947f058de4598bd8bb5c9ccdf67fa94665a05ccd0e0c517547f99aed548f6d1b5f20feec2776a873ad11f4d1c439ac18648b20042185ca4292034d8bcc66c2f607cb00e43472ce0139d88c9def53326526c3bbb2db7076738c13363c5a2c88479c1d7ce8edf958416a812e9238ee77ef5d24f37f0b086b7a829409b73e889fceeaae0dcca8939c269851746f71b089ece77793d2ff09968b8e4390b78cc596c2784351878dd7d1180e002efbd977b107f8d6130e08ef7f40b7bfec3f8e6bf06b3e1f3590061b292c31a1e42ddac0d66b6e0f80fbf59674ef1306315c30a697336bdc508b3920fd5945aa86ecdbe407d7050938f7d1c7d4e31fbbd1e7ad2b4c017c2a07a01ab3f32a5d185b79fc083bbd340e538da94d6aee716f1147621b4a39a38856a8d774e5e672041dd28e9a64f703ee405171d51ae810a3ef4078cc48d5430d709d7a4d4ae073485a46f7023fde1dfad8e14dc7582643eb1bf8adb37184e7a60d1d99ea9abbc1d2adabdb8d3690e6a72d926dea7532949e2c6456083b5145fd8512e586acd37b8f5848d388e3862354c8bcc4bb6b51780c0f5cc120b40f4e00963fc51f708cd340efa029a00689d303b8dfcbfcc651a89340fe2f40edad3dd489908859fb157c783f2250758adb290ed205696b7a542cf4b6ffc2f9dced52516e5db1119aaccdd62eeaa5e5962256bcd1cdb29a4216609688b0e894137fe3a3b88b3a2e62dd5b2cbaf8cbcb284302a63e92b3396420ccc218d0b6e67048d1331873595d7c15ae3ade7b87be73b6ff76d38d028d237ff40d7afc4e43fe5c10045f9985c88c815338fa8defec455e8ea6c473c62a5f99048a604ebbec6a2e64b8e50af52f2e9046a60099eceff7879ec840bdeecb151e2feb1ff5df6272d5e578ad8b52117f6eaef550eaca83b8801d00be64446699d12e6d390b809a453c9aa4e1e2b268f79b2f6cdf406e65ebba36b42a965def969968cc417f66dec547ebe1af9c85ef9dfa50bcbde6394829bef7fe6b604b9e54e77893e4a65142fe502df1c76972d5ebe071e6ed83c584601f89057dd8bbed76d06b3fc54433f029d56f25304c83bdbfde64042d226677e6c5531fcf66c95546ab23a561d53e20ba91e058be4c21c0fb9281af68462dadd4c45b9512510b6cbd1d68a829c9545520b9282ba60af37c75e5ed077fcbeae68b8f2e5d2eb546343d501e618cf57d85c2ca04a424e969798d2688d80499e8e9fd324e563591848c4e064714f09ddc5db2b99ff1967ee62c669d0a41f69f3daaccf2361801903fc19bcfdb632010e98f4431b61575aceaa26436e80ba020284d5f7e73e9c387c14bdeac423303248d26b7cb229555dcfb41260f276f19c4c29520cd9d5cf0f20887ab22f0d1767b7f1e43b40a4bcbea37eae16f897c63d9365d71e57b27372cac223fc3b811abb5f2551ad1b49cdaa10337dfd18239393e2f2d82643dfc3502767b0a8deb31258fa5198d22c5d97798166c57ce9317483d901127f0f68156706b94a233dd69e3d37fdd2cb103608d6c62106f8a71aeff2a0491678b1ba6d139bcd963135a3d6f063c59ed3b272af11cdae99f5cd9d1fe46bc8d2102e69a4868df3422f111c3e681d5cebc77fdbec2de28ef995cbc1046ddc5578704b7cb87e91348c138a413670b17061aad89d00ea043865f9af468bc27577c9d361671dc8d7080cfd61cbd014060ee5a1c206dabba4534dfac3e7f3406fac8d3b9b15940e8a3cc3ce19ceb2e2de91b6516e61dc38e1a9ee89e95c48f5f342a5f5161618c8c4dc1ac1e4b19b28f7a5635777f8ba52aa40bcbb5c7cf68885bc799a9aa52558ae4830cfe0750b24eb57da704cbd0ff804b2b9149ea492d4d8d52de181001d7d24455bd8235c668da6d31cb0f8b4e67e57bc90448b01751252d2f944a674b178da10b9bddaf5826fae2cb3cbe2ffc62f9d5b625e2a9561f09e80823a97a7c40c47eb69433d02a50a2d07fb0f36fc744680879cf57f929b2f2e742328e64c21b1650066dbe47c38af0dfca861ff1c9f53fc57c558a5ad8fb97fc19937bc565b3f46fca0e56d0713ef4ff7e8e07cbb8979bcd0c8a2a1042fa67627f1875cf288afc258a7bd0a07f4381368fb8d78491ddc0913f3a6edbe84ad00752647c84bff98f68cd9a9f030a991e4d44b371974a3767caef48421ee8c5b6bf923567f4b635d90c63d8fd09665e3d574ef260203b487938b9c71744768604795ccc1c5f01325c4d11a9513a693eb70d76361a5c72ee2146b5ce6b22a40981b7a05317d7fd2db914f908af285367dec42f80383389850a27bc34f5adffca6bb53f3f62fe02f2f4e059bd09bf5909362b5883bf36e902f4cbf502d6b2c45170c225eedb6c6bd5e0a21e051aa4dfd668cb55a2a2c4a452793dd480db54a0844cc2f766969418069eff914c38049b500e280b08c7b3be9aea6591777cfec38ea76884dc2797d8e3f23efff36b8da8fdf078b1aa0460f3173ab592fd5e16a6b185e0e113ceb0daa8bd7cf8c24b9bd6f1f4085a016c3fc5e655c9acdd29f65722c0cce57ed7c18739f62230030613e53d06b2d060227ec6322ba6dd4dc7fa9856013da879220c2ea4572a2e4eee4c6d987ee99e39c0e6531779fd6cc36931f81cdc18036cf91133aca04ec06390600cd9e0f03a43cd40185800551b00faf39b002c8ef4ea0a7d13fd708e79d027bc06a2904525581aba32467c9102091ec410db0be371555b0d2a33c72296c039834594c8780a05e6aa3d27590919779275658917c389a6f08c199c6ddf416f431f8e8e8b2a9ca48fc8ab29c99c4d7ad0151ef6c1f9fd9a01aff54f553a3cdd2225d44d58f4d031ee75abf1417cfdb2ec7bf2baeadfd71e557adac3a303bebb896ea283249069df5bb1ce0c05102eb3be845fb0e42f12396355f030fe8791227c44cf6b3eeb312cf421cf9f0936ee8a190346142bd07306b7f5ef30ed308685891c361e4b15420172d49bbc7f3cf4e7e86afbacb93be80e9d05adb3091e5ab06b96b7dfd41e7a639b472e8c1ba2a29f4604ffde3aa5f805c7a5123bd179c5ddd647b871201653c904780fa9f1addb91c53261d6db85b23cd8c5d9853cdd13c772d9f48891afed0f79af36ead292d816aeb63ac79b9a37b2f9cecde94d6fc18c3925f5f0ddc2977bcc6320598a3f99a6d9955806c95700ce2bd6195f0dcd62e0e0214806286d1e63be15167ff4b5c66c04658b26711189ae30e8e6305c90b72bb72b4abf2f2fbfa90f730e332c2660193a8f1354e23fe60edae0ada6e7cdf07fbe492872f725367a2d045f4049965738ff9937a0a395699bbed23f75812f8e15c07dfb1c350cc40d2b5821a4a82881a0d6a91a1e89f9cf4b2d07b26aa75435ba671cba35d9d1aa5514f12c0f18598b2638990ddb3e7310462e6d495a970dc266260e2fba334028557a8672bda16b1be7b5894a0690ed4be6fd6d6b3d259a88eb709c305a47c5f2b3fd8af543276e0a28b6f0cd9e290d3c0802f09c424cdb417ec12ddae7e3c6399d34e36ab653cad843de42c7d9891bb265aa5eb7d29277cfbf95d1b0866dd498f6a5e65c26e97244fb29c6a524863563ae8e21e7f25d8fabb5bf1faddbe88fac3e87c131a566ffb382de89d5cc3046c5273e0e4f4673464389095e49e87d64b7492f5ffc10fc0735ac982b9a1fd818a92de1d28fc084e2c45691b7377c3db453e8102a8dd170a8c32b0f532069ee75be76919e1a2824097d65f47e4ce2dd79fb2d469b6010133a39c4c7a382fdf71950eba12c1284ed4ce0c953e8e111220ecf0dc0479d865f98b513959746399dc9fc494a4e7b5c61b49372274a7aab8e9910e1a9fafcc66696a7d0faa39c552450565bc21b1102f00801c63e294e31622ac42929ae34e772163bdeb8cd780fdffcd54c1304cc4794e81bdf1bf90a7cb34f0f2fdd8a3a1761e80b85371e019d971cc9e5ec38b36dab22252c95828f189abff6f024f3e7a2b604b4e9cf697fb72886f26a85433c4004cc0a44149313b648f009d4601ce8472c80d2d006e2cd53ef56ec106be0b54f0564afa0fc06219ca027665aefef034c5c703ac1384f04cc45f9a29e5809363bfad6b16c3754bce5766372c0327bc009dfe6a7b527eb90e2ecd4aabb22c22c80b344a1004c574047de94e167a18840e86d2475a23b79060ff8b95a756a776d91488a7a49ef2522983a2607f4f3d21227952399c7130c946c739f45dbfb74edd6a13339c33fe965997815f61aff7e02f28402a11432215880c79627b293562ca0dfdcdd584bffc26fd3ed4d30a6a9036d898f9972528b2a6c09fe8c551daae61d48b49f6b772bd18963ab7debad0d839d403c9fb24f7d2f8d86d8dd9300b4b2f798ae55dd89b6c8808cf47557df5b70c02d384398916c45c9998c7a127e51d8a3ef3ae5f6d7fa6fe9c198778fe58cd60e30b327ba93c79ab80f05f403deba5fa48ce9d7692a6559761bd617a6cb9cc5fc7ae84c84f6821965ac66efa19c712f501f8c7335c3631ceba9939a6cafb0769cb5a375f8d005c71542e080af7766289adae3e7051d5d714ae4822273e2c6b0ee2c368ba661615c386c4e00728648cab654bce29c54a2f1baafed2de4baf56b0d5809bf69c3810a9e65d34bead2aa636dbc5d2da1812e200eb11d09602bb2068d62fa3118507dcd17f47b56ea852044e1b5353d9e20c96a8f28a35429a87e74c996db3892ab994cb5cfc34381f5ae5f6e10898d69771f7aca118be340dc3213fda7fc33c2b04e10510519e8c2ae22178c995c31a107f4e1068f9a182c8de220abf5780ddb2bb4f5032cff1137ae6b6b5247ddf5607e1adf8f7f1f4ab144140b5a7031a0a8a59eb967218940e8484cee3a512ea3077a958060c30a39427095d5bf85e79da18d3a867cdb2101b41c5577b931545917198a510da97e3e89c4e9e81968cd72dacd6ff564c3144c4c8fe16d92c84ad91a8e0a8c45bd26f107e7e687d7fa6c90c74179ca224aed81c292f3ff0cb708262c76b9cca881ab319e1bb1524eedd9105feb759d1bb2b30635c380906b6cad0a6d67f9609055165ea37240043e0b6cca65bdcbeef9c5c6ed9ab1ac82755215bd46df0f8e851f967d17f1e6110c65ef84b65d6999b4eff98ef05a5fb7a739c636941350c0502f232032d21aa44c1fe12302e9044f6c92fbf5f10f7932201beda36f07afe981ffcc1b467952d9d4d1b6225204da6092338c214d6fb5d55e0a6e61b5f59e6da45007d2d4ed4ac7da84682a5c19c81c11f6abdd4948b617763dd7da2ab619b116dfb53a1d71dd776b73ee0c89e4296bc550f83742018743eafc10488ef410f9e6337b120946e5038dd3fb8c832c675f9cfd0309619c09c11b85ccd002ada4a520ae0c28f3eeec211278851b32845d605541190853a61a0e25a96f5896e16e2bfdb34df53746ac292ccde86cdf86550eae525c45e3205f28d4d20327ae62c53a7f03c879734e151fd1cb259dc37d3b8920173584aed8ba32ef6e1ebce86635f695c4d1e24680f24d1e970166ec62bed0fde03287ddc8a659c1086d4e3c8ac6a13c432af515bd42e72d3cb0fd6d891ebb958c1e1ed8335b4362779cb675d5aabb08105c6531bd55fcaac5f3154f7bf5259075f53bdb7c04a789c06656f12cff99cdb45173922e7e2337818921eed431323502e22f643c7a056e8bfc8c1b128033ef29662e5c789f8d6eceea244fb002825ac58daddd1960c0372e70d21298c139064e7b872ade7db54025ebccb9752948987d1423824b091e287ed028e56385a953277b0fbe799626588c5668b838a89509284af4c0905115b1a00b8333942df425280672b3c2aabe5d20d78ce66ca014d2cac892422fd651990618a661b9cd4bbd648b43fa39ca133ded35c7d2e1df623af45c949270ca7bbdaf8881771a719d3dbb4051d5fa4c770e114aac6574f6373a489f87b6bf010535679a4a4a7cba5b78c0e13db5ccac03d98648f1e709ef824a0170e348744b1fd95dbb07b677dafe01929b9b64f8a70df0758a9eaacd84e053aa7327c79230dad78ca82a5338032dd8b71b9bf0a2e32b9901ad8e900a6f1ae8c0a5151211950cba84f9778b96f8431b5037a2b056d534662aa33575ee3e3a10e8a2e75751ac0f0fb775d5fca146329e7b88d0c2b660bd552352d4b6d94c90b843bfc9d34f318e2e9728bf3b958b8346aaf7ac17c9ddfad9838ccac1922a810a802ac862ca9b7e204cfce8cf8c91cdc9c38e047bf2619227f13f850465d27d4dbe8d40d38bfc4839335a4d4be3eb3cdec0ee1644c2051a29aa7fe362c2cd112f2b27b5866b8218a2a956428f8a93796330a0e103fdd149f16a4166e70af007648b7e223c4d112413b82c4bdf21160c65279279f6f73b4010a16705a71f1c53fabffb0e2be68dc8daf0d6e92dadd2786e588895770f33294e8980fcadcb02ac26235e2268c53b8ce3fbdc7408dc679ea85263af7b2d1fe8c8485f1d4072dae4036250ae087e3209c8b0abce83254b0d1da5b16e99f3461f9669dbf5432a86e03319984ba696974c37f6702479b8491c8a8b53c27ccfc52b4d8fcf28dbac196d12370c553408eb450a241a53fd32a12a30e1a0050d781f675ec4f4283781c56d8f103d3ab27b467754a57a06617140152f83333619fe6910c561b9efa9d7bc7fd1cf820d283f606c9c4d5bc04293502a8a972aaf03fa98915c63ccbac1a1bb8bbf256eca62a6cb38184c8b46329e142a302c9556796afbf8dc6aebc82ff14e2565c582f023798fba13b391e1347606edf59200b4097ae01a7a711efc68d6c913d503fd624d6361c8f876eb4a65550b07c7252767f569d568acdd2e2c60e1f8c6478c30ddb7aecb1aef7c322ab5f61de96d36f19d38193bd71e016f2b501678ebad6b5b75ceffdd64c95015cafd4ae1b93543c5d636aaa3adb088d8f3745a5efacb4b78eaf24506253a5a3c6bc16980b97f084148dfd85962cd6b0fd95e4c96cc7caa3d82b778499a0506c641cf358c146ae2351b83472e9fe04f58211acf5908941c88223c6d0946f7119f8a8ba0c2d66b0983d3c392266ff7e8bb4196b1454aa27c216945d57b71911ad8f43bb36771a6614483e3c5cef4618b4ccdb6656d0caba66eab007226d7bb8119ca149692dd960915ad7b185721b03fbb378fbec7357e8d1de373524980e6a75246f2836fa7be73a3062dfb58755de027ef9bda65062c9526522449c8234e6db5b00ccb54bb67fde19400beed441758582f264e05b9d351b2718c95a8d0e181e19e75e60449abaa7830fef33fe5febf7810c447a9bd423073a2254dd71b75228186b1a04ebf0199932de11cda2b12ede35d261ea460160cf90d1ba154b692c85b86cefbe513058eccaf204f317a42b96184d589c1c8bc187ba166afc4ff1e7e3113eb7f428b9f35f2cc81b34af914e08f3794591b0f4b553dabfb7832992a0523c0cad108643d97f7c2eb3b4518eaa46b3a3dab9ba18207667b627a086a20524e579a737a0d022e1ca51a80656510fbe286e5e9d7f63a9af320699e34409dc84ef5695be4f446b6e8ab87f896b55f7d520448ad9b319c37cfe3d8575c41fdc7d6f76bf876aa9b97f63c4d994065be0d04913bbdabfe61ba6148f3c0d75c3d1612f5bb1d349f2096c364cb209c6adab3cf5f7c563f78552dd7f747d43956a7c037cce63ca41b4c9dd077fc8f2a2e6282293ef6410a4fc767b5f96d23c433aa470f98d1196aa5b2f5113db88c4337789422be1c5ceb972b7f17a6e7fd55159429776cb8e38f4eb915c9a5b61f1c1a2533556fe3185524a937c3fabc55285a6047dd673e6c14149c019b2964d4629285534bb95f87fc156d8b5a0cf6b296bb3606717e5bf138795395186f1b211d660957931418c5734e88c02a47aac5ccea6853a8b9f6d6621726597777ef26106f6b91928169eea310963bdf6c0c0e4f0ce993a4d79023e77996964fd01dad88931ef2790e839a23a77fe098263027aeb540782d058ed88e79a90828815165ffd1dfc3661d3a17ad5e20d9882b60cca0d0ea7128e989d3c4b39ce0f85b76885647de0e0aa58f6a393ed16c110e20c1aaba073101801831912afa91499119c2396a6852b59349ad3ada3fb2236da94c254e9b0f9d40743d93ec1eea64ad0b0bad5d3d05c1ebd73dae035a1cda98cabcedc7fccf3a9707628c05109683168655ba73cfd16f1f253201e21d61afe65871a43c4cf2de324dae52572236ea91228224cb7241cda91773e2307b34e82903e20d6c418851e6b0ef4607cfdfb2b9ad747ac19f803f2d38e40eb5a91fc58723f77ad14e1bda699f86bd0e45eef8d20b9785ba20381727d42ae883cf2e0067cf9a641c58ecbc9cd6b8faacea5add25b65f0468003f645e179e48eac212c013d0df65c90da7f1206250ae65b97d2288a21895e696e35bd002cbd46f06cf870cc6817bcf2e17d7e0eac6330491f6e931e4d2fce90d67a01047a25f6edae808baa2cda29391d65bde99127d8e93dc5cb25a748dbff049e2e438b41909a509fb7e4fd684d819bf0f69f0d18695c1db0d82e5a5d59fa6f452afe5b4654180053148d25cdde0bdae5bebdac9b06e12fe79e10a1f3b157812657196726fd255e9f26cfc5f475cfa86bbcd657dafdd6f372f7cb97c024d9dc9afc9b93233e8072f9b7f556aa043f5b07cc280f55e1b757c1a179ec808b56a050ea91ad6eb53b33eedac62ad307f18fb207f2110b5282d08bb3bfc81eeb46b1beac4d676a8732873cb3a8b9b113c74b55c10a7edab84f3c2b74e3671204fa90aec4c30298488a8e1a4ed3f1cfa2f539e701a586da92f54488c5cf776fa3ebee0a42c83decfd51fde9e538c6ce10fcf3e1dbbb045f2a1a924dfde8ecd5ef521615f52b890f1c042cc679175d55d7b3f1b1d4848356384284658767db6a4a3c0f3a296d8b45135300a296d5f2d47efce6fc2faddca4292da39d5e81d162324add3c42053a612d9589f1a6ce1a6a56762d47239908530d2c1e7a3d285735af49bcbcc801d2ca0a5f0d473aa654ccc180233cc8dff2a4400862f6a351c82520840bf0cbe5cba70dd03f1b19e64f9d9155e7ac51bcb75d8246fea906c66b437610038c5c44f6a270c883c0c440c94ad0308e51ab546e5f807052b67c1822c0fb60f5f72b3899f5ea41db989c7affe0dd002836c0c953472d99f1d2be260723a5b75fcdec649bacbbb7427d13412a4604b1b2dc70449f83c36c9a60999b38b5dd1ee1f70c301d3c07c253c175b808d1816fab451c6b3ae9606b9dbcbbfa60fe863b79601b16d717727407edb741ba525d29a529b2438e3253c8b6fadabc1aedea176e2290150d5ed5bf82ed1948b0b382519f40788ad4125d23c916b3bd63c6651560a7a19b8dfb5e52f156fe552baadc89a3a9b50d69d19a438be827dc7229022e3f518ad77f4927551bcdad6d2c48307e16a4d6d03f201fd3edc69084bc4cae7c8e5e06b7e39a592bae3320007ad249f168a7980d9b9271e90c7d0e1437f66d9e641a738272038120090b5f246f71accbdc241aae3037714369eea5a6a95ed3c174204a858a730046a6c922caacb8b710b39c9d26a6cf3aa662538cc9cf0cda62408da2261260e1ec8c92efe2074fd67cec6046eca98c103b9589626f590047fc057f0d04dfc9054aab89a3f81db433ad2b54d7276dcf11570adfd6d8f9127770396d05cf750289e806a076ee495ad94718ec7906b8520cf54bb02ee30e46ebc3e24fc53a3c3f4a7476ad3f99d12241ff4d31fb0fe790485885b926a6e066b0436bfd8e67303cf7241d27106cd2a6584ea43eeffa23cd6417a04a86c8b6e42c279f3a1c3d29079fa4a5c6b9e0a624e2ee6bb4ca6a6d309af2ddb817eb5d00d546cb1f962ad1d1fae29df35111f24723371aa8a04a4b8885146b048386281b6ca9077b9d3be1a2a85cb3f9459fb1d491a200aa293f65f13422d653381a4cc1b82e0b83d7e08f92c19e5fa83ffd0b970a96f0f4901a9458494bd5e4cd63a5c2da306798a0e9ca0b12744ad5fee219e607689e19e54dd812c69bd023eb78c34acad4c7bd28d8e9083b6a3dff8f35a56a515123a28d1d17f7af01cb29594d5824859fe0fb7e0417ed2963d2274426a1a443bcd2032268ff7e8b5f6d2747b9bb3f3f55a534c4345bb98c2dd16144de0a41c7aa3c5efd87bfac3cf86ebbf518b24bdec3631d6864041f8c6c9b1943dc6dc42dc87e780e60f1e77a353241ff4f483e44430f520704156c1fc96d29528dd7e4bd3209515b65d474f70deb0ae9d4d96e17336d0ca24ef3febd2d4202bec8bb873f85d6167655f7b1ea2a318f3e3b917fa4477b88798e8ba3400b849ea152245179df33afe1e960fa709754831e1bc23ddf145d0cd28a5ebe12404b6419ec26ffd2705a45b34a61af503d1070be59ffb18854a3a3bc6baeee117749957b6e4b6c15ce685565b833b668c3595f32569d069f2282ea84e2170f706f0a95a1d2cf22c08765b6c432e902613e2eb3e29bc89545b9cfbb113256d7382dfd1e8aba8ed802efca4b39ef68f22ec02dff6a30d5f442a619a82e0492f982c6d4baeaa48f2632a7cb83ab66cc6711af1c7651912c4d77d1ad691a74eb07617bdb5990447524147dbb96c0e0db2e4c4c1c7ecabbe7688cd9bf68ffda13f46f7be810444d8fe0f10c8b9866651eb9f32a2af313b77ba904d688b54e4f81309b9c882833211e1ff6d5d58fd5c368bc47a8c1f65d4cdb9fd6b8d465d650bb34d61bfef0dd2091db3647c0d160641fa19034346dee925771305a7dc7f523b17ed35dbc42133aad89bcb2c61fff25a272763d01d096c659c12ca5892021eadbf45a0ad9c1b49f23632a7f1e5bea39444895b7d01a36dbc6e406ff1b9bfdf9aeb3dec8151589010897294ed9b9f2abdce00d8d2e669c105e515910171615db437bd55fe5d0a2a3ed01c10d9e697b599581f97e8b453984f7f7ffbe1fc93166fbf58c95464d3e5a9a3ac90aab894ebac9cc62366306630fee9579ccaa23cbaabecbf23730b86ab28f48e324d92c4ddcc7fece435c66e9cc9790dfe8e99063e9d674cd18ea57fdb6e8f28a93a8e3259b735df2ce5cdf5a715d63c5d6a0d945bf0b71ded9b9064caa2c54d4be8b309ceeeae5d4fd3ada1ccfe3eb4ac3bdd90d8df98b7e875f3a5ac4ecb9868c774c9f7b62151c116e589ad5b51044a719839b5035c037b7c1d4edfc5e61b725b07e3500c8ec414d1286581dcd69f45a9ad1cc3017bc23438eb99c5ed5cc30462396725a65c0b233ad7a174e2d2aa48faa8c6978b679c24cf954e7982273126e2be0583e998221a54d6fa9e3d72fe942268ed7bd362d55de587847a349bb506d4d2a142ae2a1468e531ecc76d39054615e4c2d8449e96c76979dad1fff49f978541d3d9f9bd2ff1fac094c1f4e3986ec75ad1605450214b3c9b892641763d11aa09efdd3c8a925111e09be7043f439844d57f522120927d1d6ac6c926d9f47824abce4677c7a69155b03902cbf7bdd00391800b77ab31f32d6cd44ba26adbbd3854356fd40afdd99d3147a8964397dba0864fb7505e79fd039a6fdf4a0100535c5f05a31d2f6ba9b6d3189a914867ce7eb43f45d28c7004e540f3467a1a0f9b06be96b31bc1f8231cc39ff14c3d0b6c0aff6eb7e8293bc06087e8b9187e79a2f1dbebc25074d2ecb1767c709198284c6915d21bb6f368596925af0ccc3061e047b674d1c9500651adbc67dfc7d7b7c11c8ecff2ab00f0c6e70d2946d89922d3b978c7c5f2f342864a929d76213a5556146824bf72ecb37dd175377b4950a3681677dc3c0b93f18696d53acdbb3a3b14a91f71ed964e8b65f005632f8f090f43d7ef2ae39f26793843a423f77bbd0195de9464e1de3747524779e985d20d7a08f069ba171c0280192c257f3534a9ae73b586691a76dc8bc1586f09a26363cc2f0b80ce1dff6a6d05c44662b68576416d28a7e2df28f38f57fb4efac0d08fdad21e1a3be7ddde8999638fd8e091db090c5992c76fe46b426b0b3c1b25d5299f906a1ddb7c591385f440b25ab09e697bac0d25ac553dd6d54703c9d11d8b1f333f2ab0d3da701ffd39b940935bef43cc9e92674339b5ca0f45030485667996c655f38b3698d885df92a9c692bd2ed4732f4be655b4e58c85e90caabfa66d87b62d880568a26d9c0ddaf6cced22da4c474d10d0c97a2928e9ac45fcc230c6b5daf38ca0cfb6d8050bee304aea5d9cdf73f7f6a84d598a79b338d3c9112b501e2433fc24f6d175054b53fbb2ffaae45705d642a5abd38441413c22c8aa2ba78a7f593cb4d7221889f725805f9cc6a30024e7f0d4b9552bdd7412b9772bfcb4b8a445a737574c94099ddb2d0ebd7d3746e099a3a5d3df6aa86b6ee79d81c0c48e12774e559623413a3d07bdfc398f0e0f75ed28cfca7c32f6fdd749ceb6fb42ec912b66cdf71cc8a2f38dd24c7079295cbcb973e9632ced312a72e3c4a2899f0a345f6bea5817bd9a5e8dbf1e80110eed67cf14432aef6b3225c13789f16d34b853d3daa9193a641d044100adc41a874b3ada4aff97bb48e82eb43cde4bdef472576c007b1400c55778e7af6f9e721ecfc10d6d5fd984ccbaacb5ef4cfb0cb853c12ecfb6b029ce6ed3da923c50fe0515a85ae693f6abac93c2daafafc21a398e6a8677b178144002afbc329b1a340b50f46a57e6c3975e8a0335e12e07d74893f321fdba3127687faa99bc95363f65d0df093d0ead4f0b0be2844a7aa9837f5b5221746bec8864099a5b89f1475a908ba74ca588b219ddc119d8a4cc84a90525fd02abe649711ecba7682ba201fc7b1fc2daa140909163d80663738a0f2907d2f42ca0a146e646f12cb04da7bd0227d150ec3fa3dc1d090a0cd96e14aee16f6ee99e8d3e1660dbbf76d1dae44eb8f07ab888abb0d9ca940afdd97fd68fab12e303349645918f4406707dd08346c0b128711f955912ba8baba97bb0470eec6d43a6f876c04c37f9dd11e12b2ce4b6fde6e8173e74ef8d1038548fe239d4ac99e4252c3413cb16c5648a5eaddc80102b350ffca6b491a84ec4a4d0ccea6643766059e33a982e8eca4f4be8687cdc6569c20275158d4f3677d2e53a006e41dcb35d429e5b307ac78ae03e77e4168b8cee5c4be7fa3a5eaed2f6422053b1da16604235fb266776aa388fcda733dcaa14882bce302bab0f04e7bc9b1a0431876d3114f1f4d4b1aac7db75691a8f003ad4d61065ed63757ae2104f68d9a00ae29767d6b19beb4995964bc55164b82ce035c5ffc2dd0b5ed4bc7d94b6b1d9335982b5bf62b65cdeac9a68c349c1558abec546cc65f800508efdd6264f2857e20a4061c898a8e271914af4a86765b9fdd0e0e16db9f1458399f12b794872f220bf43cc1c70f88ce67e25a8c53615b78761047affaf516a97c143fe5ce7a4f9270725b3c3f8fce79d78fe792473545e94b9779250fadf036fe5331c6c0dda8ebcfce9abef419b4be42c4686a1fccc47171150e8173dad5deee6ce05dc5d7495a8c8f36344d110750271e1d2bc7b3905d5f716cd86ce42b3fc98687b3795e8bab766c9f9e45de938b96d0b3dae8efc6068e9e5398ffe3bb872ce4eee476f5a886776c34be1e17f4a6014c6a0b1df05834a69f702aaa556ec774fd9b5acf2497c8da64b6945456b14929cd4394cd38abdc417fce535504560679b73ca8c0e53cb598b1f11e12ec314b142edc98c230225a6aa5418ea0cd4f0dd9aae6a7d7c571a4391a6cfaaaff9a9b71fc8794fdb8a408c5aaf53d483a5fee174b33351a03bf0b16ab4e2917ae06d31292997666f3311e2f520d29ae9f508bb348b73d7837298b0ea07b26efb00d37d2e4edaeb6292ed0285baa0fbf9f01815eccb48bf823906bb44b09f4752d3577619f786deb713f58ff0784925cf364f17e67ae02159cc0d775e01d4989d06a2119d76d9881b4a94e3d2d90fcb529364b210ddf3f9c38592d6ae496a58321026896d8c904ea4e03b1d9dcc2d5f31d6d3064f592e4cf0dba0b05ffcc9a8a3728ff8c8c2816df2d1b7ca9835f575c0ad14db1a5f80ebfb4a717efd7a3a53106952a61fd73f66ad27110bd22e98c621b23fc1906dacaa146b0a134eb0015b0236880ff7ed5956e4f8970463862f048b29936dafd7ad0fea50b6d6c4dc7cc2f398c83416667537c306010b97896a9ad15d90cf5e606e7f9a2ce775024c42606dd97500c6f64107ec3c0aa58a90c071a957443c58c4f11903e35c297c7b593808852091f2f3ff151e44e8340fe2e678f73c05dddb94f9ca83f577d273a3d5d44f0fe882d9020d09f0fbc24fc3336def123ebc1343f66ef826b3341d8449a53058c4c2d4f3517af1e5d7ced7cf85067ed3ea71938fbf29d279cc213801d80e81da17520c0bd98716f34c93c0ddaed0b65005fefed3ac15684b383aaf9b9ef82db9a3c3899328452faa87658adc40f5d4f91547eaf3607d1b6f4d977f3bb127955f1845351beeddee8c42f15329d39f572db9632613609b41574b60a475da79044c586ff015a173ed690888fbb8207f1efc1d426cff0da2d5cd8eeed5683bbff4473c4b723dd7f4370ef9681ca381aa1c6b8bdd8f3c07b8be072e01ac37d48d812446f0300e829daa9d3512310ef62c48d29abb5407b81a86eac2ef32234b04f3ca46b5d3e04ef3e5509e46908847dc66bcb6c7a3b4eb0c3c27130a09ad8fa719e0654b3ee503cfeb7d0fd93ee44275ee0c5c0f0ac66e09eb9e4d87663fc7b69cb13122afc465d49e96725bcf3eb2f402413a2b3a75ae860f43d074c9094f6ebc9e432f6a2e3f077ff9eb0d94cd80fa839796af73f0510d55f36c8d9126d9e51eabbd844ad21b34f48570e3e0c437bfe195a44bd9d66d97c0c1a6a9f9685688a8254bf640f14f534956ba5c2b85a6a1ab48b5f9f37c42b8e19946b53a7edf9dea5d01dc2102277aea8c9ff0a49ca565e3df43aaeee98494a773bfcc4aef4b697ad768806e5c39d9146d3fbaf07906f264adfab25c24b13503f8357c1610194274f82ad304a6e23fd4d992ecdf4cfbe59f62d7c972d80c157694c5e653038bbbcd5995ef4549adb6bd242a97d4b9bd6e7b8cfb7679edbae1e21e27d4c34f4d6806c63abc60099ad5ef1f1080ffdb3f041d7e08e72109d22db403d793e6de55529c219c29c6d609fffbe94a7f83b01ad49f4789c7edea4667dae03c996be81f5356fe0f37170c17ebc5caa9e850da7730fdc546e2dd5abd533c947fe24d53612979e465f29476787a391f7c906a4d9490e4db566eb7b97aa4bb534fef64bc834bb84b6c190148b182b4dca12f4167bb1ce391753e0a3ecb6e95a693aa71c834b8364217ebcc3b41785b4988f1d534c0457f6673f5f313818006f2fb8264f500f9e995fb6ee666d0e4f2ae137484a999fcda506f3d2d9b9d631f9bb22a577f1cb4483414df6ef6394f2f1345e771b11cfec941dbbee2195eb3e41915e130a4aa37527b81d4eb1ae3cc22e19b7acd7928d72819f719cf3aa8a8bff8e392bf447b51edd85bfcff677f71be133c3975018954d058d1dc273c3627465b898558a7215bc92601c44273a5d10cb083cd598c09c12bdffdade8c3a5212ca530e33b2d610d703112da56ea683ef15ddea1f9da66c0f71c0c3b6d295e487eab1f95f21806c6a5d763220e7a77b23a5eb285dca47817f3ad3d1bbd9e5c3426d9936e1515931ec4c4b0f86dd4a0bc007afd630f6866682ec965ac15c73d5915ce75c216d368d1464594ee1172f657f319d512fe571544307957812ce231de7c1817e7cdacda5cb5efa068a15843a078e4e174c1cb4cf6c06410d491ddd05f8d02a587074e81b0cbc71e25ab12014302397d30afcbc801f650c47a90d28683fb349b81fed6d81d7b1737dd925fda630d75fc0aa3d2ef8fad5c0cef380fdbeb70e86e75807a791ac0785f73127d431727364cf4ed4d9d7d72db8e79707cf36731a916ac095ed9434fa84df9e42d5ba2dddba7e77c92f553e9e9b53cef670adc685e7a30b56ad6cec14283b998324f2a5bd56dc18972ddb93c62238a8667c9f5399546e6345bffb1e0553548cfaea90b8295f973b08a48c6b75675bd3e9e0fc57b86f92c0ec5cfd858d770d11d3a07435e12817c5a24159f05bb3c91deef6a71bfc29af9f7d243c47ec63692d06a5911ef1ed469dc61c63ebd069e6b1481ea9d5efeee991f7d5d4891a7531b88563dc598734b20be446678b6256de09f7222f46720128291ceda3435d54f9251bc55e4101a168a7337e42e389279bee67771495281f5fdc93ffc4e71a187cc844a74a468586abbd887fab4d70961a492093c115e96f6387895b200ef9e06d649de7666ebc291ce22f09f8a323e98611511327163e7ce3cca9b5489a02fcc420bd2c35bf94fbb1e24e160ba475fdaffaf04cfea452d8c1cd79328aabcce53260ee68124748b0d5c680ce49a1863e296eef9ed66f9e701ae38ce87809e7a1c505731974ef56f134b2599f4e532dd19f4b97fb082706cc403dc866fe7d2de27ceee914c51e5d3e277b25b5db4c623426823504458a9431b8a5638727856dab55d42e7b83abeea8820b6a5bc33f6346f902405b4d14da116154acfc791461ba546506326ec8682e1182a1cebe34179d1ef02a9c5dd58c96e67a5674fce2be2ac65f47483dfec99869d93b840c4409394e3b13e14bb5c3030095668682275cb9fa25aea39b9772d2bf66d6793776d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
