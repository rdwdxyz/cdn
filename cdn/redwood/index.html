<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cc5b949a217a6290ba21b6c014a949076533376e9df38beae62903a4e74d6a80e27bda6b7d528e42f728550f9dbde5769871ae7489ecdb9455ac58e5848adec6f6493fa6ef9c9edd68d5e6a89a30ed70aa412e768bedd33e7c8f623bced53d5b6df8a7947a240f4fff085abb7c1335c2e0daadb4cd659bf1fa343819d800e2540d9783936c5ba99093304a2f63994a936dcde1572f4bc2331699f0c2f5238359236c84dcc6b645028932ebcfe2af4b29d99f617c67317bdcaf9bc2e30a4e49de847dae4ad55c863177653d4f4d3435fcf20584e3a8d772e9a3749598d398e6a45cc45b6338e4de1bb1e2e7e01be60001f9edd5f2ba53cd050854fdbadcb2f38026d2e6f22acb37a8ef3f25d635873b50fa0ec973e0cec9b25e571a408a6386eb07c5a37c1a1e5dbff17d4ec50a8a0d1003c0430860e6fd5a2f069f729e7b4b39b515f0a9f7ae00563797a5784a3e2c379bece8cc9e7edf0a5130dc5481c318e24d3880a9dfc149193058fcd33a1e1629f08bc09f1403c1e3d42a86915030a4e2c68c5c406ba6c6d8e0ca3658b2bacdd9b17310ad7fbadeb4b821dec7cb6ec493440627f80823dac7ef0862387aa06e840ba30223275d249bc89d83af73e0ed22320579aaf28f6eb549ecf1e35330516ca823e068b0ed6dd2abadb92324a567d6bef7a4b5ac4371b55d1bdb3189fcee5cb6316c14c0de12b9817f5b6d70a7a9784437e8a78f77768cd219c9b9aefb886be0f1b522fc735f71616a2ec9aa7c8be90c179eb3745f31682cc2421a796d2c827f8488800d188a7c1235f33e977aab11622fed796c5f2adeaa15d60160e1fe1a8dbf0a369c2645abbd6f1c83369c8144f353086c05c0fca86be8b90261ae091a2d5ac4042b9a6a5e8f41d81988417e972909083ceccb4c10d504cc30a940743c919d48e865c10ca59cdb9f5190ae1f571f875092ded916558fe605caa3fbe910aadb3bb9f38a69c4c5bd7e8fc8aa61e765190e7779422e8d4a1e4898be4574c460c3a96d3eecf33005e6ec330d00759e24ad0e2b6c0e6c81d3197df8ed76e8b8803b5bdf82b63be31e328bd0ab7f5608354e30ba2462d86da83785dfebbd71583ac78f949c223cb4ef429c5c3471b8b926e435c6c3dc20d0f4fb6cbe19cbbb12b318fa41f5a1f3f8c1808ccc7ee2f421d873076cc4a6833e1165b3b6d874b5e576d7f30cf704f8f4aa106c5f166316aeff25b737ba0284d09a3bea34eb75437ff132d9e7aaf74b8086112e962244b2071fdf90d8d98061ae664c464a4d5cee191dbeb0600f799cd332892778496164efbabb66b284b83251793e751a49b382c27328b4a86902f9463619193cb705689346536066fc8a47b024dbd84397865c65530e950444fb226603e1de504a6a0e7d956bfec76e3fdbe582990ec3f5688e8a3e3f163623ee1f27d36325912f12356a80a3ad39e25548dde089489749a133b7859011eaee7cb184e10ef2a7f69c7913662dae3c45d3fb52db2b2f0a844cfc2750f21b395c0106206468e69408451126d450f237751c0751332a53d6f38a3258f3818a1295cb841906e7f6bfaac2738fad031b840040f1cb1fbe86029f088ffecf5dfab745659a848ddb5d71e3fec3736dabf7b47a109f1ee35dc489a26b138abe358e1050f4ac48473da8badd4d93cc37330d6d11d8b4a512758aaf67ce64edfba6af143881bb5c55eb7bae31df5da9be4bbaa795fe7660120e091c444af223b3dd3578fcadaa6df2bc17ca493a25d4770c7bfc8c461d8f7201643fa00cf8aaa94592ed949d8cf6bdc6f1acfc3fe58e1fe6b725c07645978c9d93647fc4c0e634b78eec47577874ae32fc56fca0c49b4bf65355f472bd094fcfd6a580998f3bf84cbd853ee29c163c732e65715f3717d2203d04f365aca8e1e027e3afb00f7177fd4207929e53cf09eca2814e58673153bb68ab19a0778a6504713e5772ee6274b7f562aef8deabbec456e43b397fd5d6179f6054e52bfd80f9e7ee9b45c2a7556411a06c3811627b3603947813557df9de3546690c598c722cc8c7f71f64285f9c7ccc4046f64419a40ed07867992cf45a0cfb177a12822d45dd4990f5041b898fffbe84987fbf191dec64c2eccc00134cda7319240645039537fa42d9d21b4a9eae697839f6f89362cfc607574603f7f652e282b60bc5517955937b8a9dffcac01732d5c261f92151356a7600d71c506514deb36834a9243d6043d8fb0c25a67a64e7c04271f0cc168a27e37ddc6a359105ff9f52317c69aba8abb560bc671a9744d131c4e75002bd85f7c5bce0706a56d7e62d978ce1b0627db48be678092adea15571674226d89786735fb0ffc2241e02f274cd5273cd8eaec6b07ad7f352ca6894ba730b5b056e1cc4a3a2c4d01f639a7c9b68e02990745d20116d496e3a82733567890acbb2c6d35ed58599bba6b6991ed1162beab3012cb898bebd6c2431333eb79495e746a663515df159bbc04d4e8ba3e5df4d091dd05229eac280aaccb141f93e1b8fed28762ba4eea3eb700b04eb7e408c5d384e30719cd719795d524471313fb5a42ffcef59a3d1f516199aaf38bd8427564b898caae72b3c52b7789c3bf5b5d588ddad8ad9e02c1d9e3c933cf64bc757bf6093624325558d65cc7ba26577905bd6e15cd3af3e09268ccd41e676ad4da31b1b1d310cf42221416c3ab1ff905da686ae53630f9d570f81704fc8a3ac350ed16c2be31fcfd48b0017fed100705475f30e130b97e4438e8ecd749c8809b9ba9e6c0835175c5654b009dcd98ed1aab067730e76ad3e02e4760866c70c9538cce8dcff2e0cd0d31bc00a23f4423df238bb430abd3b62eb0b20303b5c098854b46db4e2b74bff410f0d1243961a2bb6bb7190384ebc71335a5685dd4419863ef78d10d7eba5b614b2b588af4178155332a5f119084c517953aa055a2d251e8b598fee45de0d7580d30ad75c75c4637f1e646def5dbbae7e57ac5b2ebc659b4e957ec79ad695b9eb388805a060a7fda3f956250a1d46a98c7da1d44b86267574afcfa77420c4418a2620e2b8082fec209f124e4e592cff6d9481f60507b9bd488df5317e497dfaf41bcb9c7505c7271b906bf81c0b38e31b26ee7d41dcf47dc542f5b1d00b1188f52a6a2c3df46c99c0728b6b23cbda773d631f21f2d3b155d9259f5211759e42cc1f3b3c4ab65c23354e9cc241c3811554a1178dab966f5f44ac953f81a1911611a644ac573412587838944af52745da0acba69f7722a44b56331c3cc050f67ed5cf2402dc5ac844dd07b76dd4545e56a72af017f7c38e1949faf8247aaa6a44c3edf7de1ee0555d2d11d7c9e38409a47aee9f01dcd05fc2ad455343ce1ed090c57b9e60876f989febdbd752dc388cbbe7968a83329e88888798a781049b9685242a7dfcc58f01a67ff85572ee7cb30e96d976ae07d002f48ee8096d3d9df2c4e151c936df3da53f8d6c577826812be31baccc92886ae07f3d226c207fedbc57bb70e6e4b4d9a3a78ca4b07a59b8870077145ed88cbae3f705bc8ac7fa8e1275135ea6445688027876c721c00e7fc8f87231ec933c214089b31f7085d9c1d014b3300ec4c2effe840a03bbd0e9e7ecc03cb1dd24ce0715515ecbb36c5fa0664727a3ab93fbd2771f43e55420213f50da9cade08e6c32c9440276fadfb7a42af837f04bcfc31721d8ce486ca9f62604eaeef9448af79384696b29ce5e6f65a20fc183a8bd2eb2c88cf599ad1de9c8e69fdbe2ab3a7edd57273b03e8b73bb82c77adc8cadcee14aefba7e198746bbed53ec1af2e5390f306a2f2366992b05d8469f6ab275dc9aba76635bd0f43aa5a1df71d098fab5e4bb4f815464d02f7ba0384dacecd0e3e43490f285f56e870e83abf27b8541a9cd7ad3e19119358f38905e6088c38f214e683f3e05a3669077ea577fefb1276152fa34a9f8421b776b636227be53258ae3571cb308d61c2e89cb2fb51634d4782d0374e8358ee20b4fb4101336a6e17e5607a4f9486462c2420564be15edede6fec5e3e317a9f89db59f92d0a124e019991bbe9386f126da6cca08560eacc281ecdead32e8c3d104bc7b67bd4d3917ccc8bef8ab24fee93c04cc49754b29a96d718942b383ad7ed36de781f701b259ef3235a1e0530a62c86139c477d258cd7383c2100ca0941030a616764c75a0a7f34bf22dc5a4a07eb1ebe82506d056d3371b08152d9362b4deb46a5ea3820b950cd2206ad61b9fae748537e92bc555b71d92f05e04a3c2aa494cb133fc619212e57c40db09e5ca0e71ee9e5ecb9686a862e229f48d81aef61c29e5954cd503bdf596c4f66db984f77aa934a264baa8190fda3843ab1af7078703b2474dde50a77d5a4b7f370afdebbfbd2f96c7ebd00b30c410a131aabbe79818ce4de3b969f0c02ee725eeffd67f283ef421716259320872299f2e13031fd21b755b2546b2419da29afd97480df5a6ba0006eb00f3144e8e7ff3e3acba60e027ddb3a24f7dde369cc19c21724c35f367b7eae94648bd946fb58f68e83a011c6f26a1ba4cc40af3f0e0d1f12d869c9dca2593c48c2e09c42f28e485761ac802cef62ee1bbeeb886b7f9a6b6693123b698082be7915dba01854fa2fe436057893bd6c9edd85c817582b7db51855a84b15b0085c697653e5bc72380cbafe446eed5b8c2e509a7acead9267982267403b081021858c82a0b126db810074f75d41294720a27d9caa5c2ffea67007faf3673e363d24bde89b89efb45b6f54c4ba97d040945e7a821c6175ed21d8e7ea6350638468f33f31e2868b428390dbad95cd477d3b31fa3d2a0414ab3c9ff5781c892cfd253759ca0fdf1b6540461046152c45374d4e1b9ba195939cafe58a93e094d2eeb03e646a27714080982edba0efbc3b57bfaa49aa74ec656710ff407f48a4ffab62800fca07515e468674dc1e0a269a5f0b85c8e0919b25a736ef0371eb9ed267c6a3c98310892456f666e7576c88b196eb4acdce273131adde1c9751c02fee5e1a3f0a229bb0a78dbd0c473744f98be822db90fd6395d4f1c7df42132f0bb42a205c0b87f2a566863b6ca2aa75069012aee1300f7a45226644d686a7496d3383d78289eacb93ce51af12331b3a5a8986be809ebe6373a9c0a6963ac0d7ec9d577fcb3f2a1acf1ac5e6f93300e1305abf246b9ef15af4d9f5d37c783a5f9d99b849874c611348f37bc3a9169799ba5ccec1e312f88dbc5c012f1d8552cb10f0e90995939ebe34365c8accb432fb64d302ebcc57524ce36807232dbe53ba4f54b944f599b9dac96871eb08918789c636bb16aaff1e6f53646d8427a0fd1edd28a3f1eb0a80e3cd114941a82f75cfa6ee2afd312186043899f269dd81bc85642e32f9c5fabcde690559b60314b969e216883481e82e5ad7ed8c91e9cdc82325cc6de28278e5dc83ac9a6e9a265664f69211e06451213d9850fcda5214ae50196bc21e8b52a57299d5049416d930427fae1ffd0845df12842b34f8002997ea889a76bb9b575019f2c8aa913a5fbf9a2132b5d1dd083dce79ad2ee980162d129e720eeceda46870d0159be5dc9b4253ff15424ab333c6e5c555aa1df0bd6be6f0e605284c9ba3df9f552338a517b9cc1a21860423156de03c72027678cbe499628adfa55947d51340eec78629edd0bb2bb5c55f1f5a865f28a1f1aa66d0748e652a3edbfa137c8180fc37926ccc01239360a3209ba902e5a250a689f6dc28e8b29039893226301d6fa37afb316d769c67cc90a8291b455d47e958d078f963d1569f090e800b5525c14ede57c978c3309c8490850b5882bb15101b46814b49b1089336fd7c097a4404ed69e2b8aa4247c6465a4e0d2886a12d98ce2643bd840be25c0639da3b533698a70c1359e3d1fc0b28e11d833ef1a27d940f881b7ee4da4a7bd47f58b5fcde7b2b8bc13daaf1b61673f647c0aa8f834336eb13f52e45838d0b4bcf931810e4f94e132d2a7c5cff80e6b1c59c611cb83b3fe9b35f196d9a8cb536ccc48eb50fd72bca0421971f5136e74c872b7088bf0ef1096118828ced9ebb6c4923f457c0ee85aada4b2ad4100cc8462adc9acc18cee08c0452dcb5d6b59f006344ef76434428ad024e1f3637474fdd6cddab19467b1021ab5d3c71b22a2c34818bd6e52825105115fb95f0977ded4781a2120b3748c2ca0d7ca817bdaef627d668ecc3a52dff33a411a8a69daa5b53e0425f468b49ea8e491794bd17a03e41d2099060aa78b6f0d98b3afdb59a50278ad771fdd5084957464ee4be6fd12afe7f2f959ee0e1d04f9b1140956e50e70e4d476390b2902cb159a825b0b65922118bbc4309dd4c8010b0e619a0b53006b69e63fd0325fe0c7e675628803f3a2e86d3734e9282efc9ae2db65d4067ff8b8072c5bcdc0f3c23f7d236f037f397593bb7203ea6b7053b548564921556413df5a7d7751ace186c8252665e5fd61507ba5dab07b1eb1feb28d85618d52879761a19c7775308973e519252ea25627ceb0ae3575b36457d47620ac010a98b2556c3064d3ab7bf3c479feaac1033bcb3905cc516d58b6f651583f01e6005d00f9aa44cb20c51a289388339f4caf6c679c8416d6f3bcae4571a2a6169d29f5071932d1428959896d1c05229bd2b0a2191751b52522354a9d77e4687160a72e3262f850f66d55cc718aa5dc925f34e2d0a2749a37c47563d508b8e2e545c316d407ee0adabff09d83be6f660dca505d554c899ad6fba06685c37b2bbef43badc905449406b629a902e02bfc41b90c0bcdc4dbb05ed03617af65847195ad9d4e7aafa90fb4f2c36fb654112dbc941aa7c1e975c6731bebe1e2da6d063996cdee5484c7cc1492a3f9f9234c28268f510367ead98eedb83b0406d70fc3ef67c6afa0986a4b157495169bc7be5126dc980f34b0cd86a6d0ff9ac939872f7533164ab9bc14572bbdfc19f4c30a59a663ff4a644de0c9d12d6784fb16493c36211f64814ba1215972f484aa0bdd9e47318c8b1b760410e96c86580ec06c5f6d39643ddde76396ace679048779f7f9f2d220d5d9ed6a42e9db0de10fd4e3a4dd06817425e20458ebe7f8de6091c34177990f4d6fb4420ab64a80927cb88a5b173fee012328b3b9e8e32b41a85c5b51ae1be7c9c6a73706b4ebcaa937f1382a7d811c11ef90fc406886206320fc4598c5cccd1d4d1ce90db25936b079b07b1f2aa6ccdb8e8b17a84a9a993e607aaafe98733bc1d00d248ec54ce6abcda533172320c581d8da8ea62b81d0a41450fe7b1745bf5854acf754f687f8c13b0932b4cad329c0b1920c9ee181a132be0ef09d79fb1f9c49035cb72d7ead060c9ad430d197fb5c9c3ab0a175a7e9cf2f3da4cd7fb04cedd148f79e82c17624bb29ef85c7ae01654a24c98c27e9d010e02aa5678abde9f215105353b6f2ed41fb7eaebf1af9d2f221898fb50ffd7b12f8e78d282d03ad7c4f5c5191e27eb0bfaec7ff7c902c0fb8abbcc5f144f1bd634ac46fe689d6478a41198599ba0d9bafe28ff3b8b6ee439deeb36e3006af95066631b1839dd5f33088736d301f5775f04ac4abaf31d58ca12fe7f050ebcd4f01786a4b9beb0f503db1d5c5ceee8eba67c54cdfeb73195f1bf0eaf95163deddb36510474adccf5a405aadba520ca2e537b96c28c2c85b855a9ff6e60aafd9abce0093fe79f7b69735262ab469590d770f283088012918a1028bf57fad933f1d594f5ec9cd7ed3a1903e85786517454a44d434374081bcfca7eb908e017a2d34b9791b239e09972ba31d94153a07b852e055bd3d87a6e7daf8f24f1a1ac6a2a588c5b7226864d5a830c73375aec77a272df7dd734462551da66a5a962f8bdb16c10d09e1c70c9f9d4107f12cff19533429d80060e8e0d709c70629631887be92ac0241339a8d026bb87532b85d359b767e577c57d37ad35aff847fb78cb3e4a014f31f249ec7f96878dc850ad886c0a7528e3e1ac2f3f54ee8ea6dd7059a2afcccc663918cfb398d0d3080e5b1f09550bdf41cebbf1aba6e6cd0e11db45332dd3a401af02cf1eb40f413c0b104270dd5cbc50d72dc3c3d6938aa21225da3dd68cd9130927af302456c8b6493e3ba44675d996e5b023a233617ceb71e03f71d1ef5d87ca88f5eac50f40b076c526624f6ddca336ca5fe10a37ad6535e73d0159bea5c33f598a52de221d5f3b8fc517e60c104276d3a18400e9cf4a0a1e9679bef62fabac83d6f05921e5626a7f0c3c48f9e9358fedb8a2a31c82eb38bdc2feb25e2299029d832d7a87a62e5b8a950058f4aec9ed1922ff4e9f3efb170d5934e8bc76c8c931b97ccb0336e08658f1da9cac6443635808e889fd9bf4edfcf0dd16293de912f7f3460c0b2952c14c4d9861e45cbdc892dd351b9e2a15d32e66349f2532c7efae7d406fdb70775589e3f669aef96222d7106adf16b5ac37c380aafd4d3886ba4e0b87d75b2bdcabe78395fe4ed3a97a031f9ac4647822268ec7f8bf01b7dda78f0de47583dd40b06dc4c1e552d72e9bb14e8cfe6a9da9aad43aecc6463f02d74d23c2c937899082d64f778dd8378f882f30af04fb16cdcf5216af7f20db3187035caa3f4d58a96c08c002ff952c6a0fb604baf8900542e004c178c233d5b69ea720c5f4a9a1fc512e8f8fa336a8746244d4606f9b4f9c2bc7b6a75d1d59bec4fb54850a930229303280140468c2298dc35de263803fba138f4e29d46df1e2f5e4785fad6361b397fe6fc722bf9b2b36342cea8f964a9d4b51b02f54df656deeb7014df016327224358dd19fab6102a1e549816fc98cecf81b875fab0c61a3328fb561fbc7cbbbd6d8182d5673c366bedc0108ca42f20845368bbc6c091d95e443c16401f0bb74b06f3e594d3fe305af0ca7294e4a3717f8b7d813f567dc5e7f2962a37c6a5c90d2e2540b124bbfa4a57b30d60fc7539042bbdd704c28d784858b5b6bc28f27156a79a46abffa4192e11021893512f50d4f27df6e87cc63e4fbbc0d5736cfc1015a296eec47fde2314a606e30e0fc49abfeb3a61f922d745a80b15788cf5ac7adc0a8d50aeea75e08e2615d19b229a3dc496ecb3905e17b2ebb836112a0545e652affbcc4ec008805665f2c63b60ea524eb4586a2dc2bad1b9103e15b1b02302b997963e55acd811e165e6500a284d9881d5aa0f421e596a635fd78defb954ce010f17c2557e5faea35d10c356c9215cc8730ba45021139cc9bc36e43753f51d3c0dce6713f8fc169a096df12bcba2ec0fa5aa44f30d3cbe5dc752a33892367d81aca7ae6c2eb333a0aac5f6bc51faf8715b4cff00354e5b6bd70594c9c327eaadcb32f55b54986ecd7b4095b5d9c2dec7bdba66a300235fd24078a6325e9ead04de1068d3787f917f1543590f5144dda57f75b25c0ef00c17dc558055fd24c8f2b5fcda11707aa0da0d34c0b96078104e6b71cfe601aadbc03f9806f16836a68ed43e29af405e7e39326c828bea22c339b09707cfbf2bf22b8f76667e8bb0aada6185d5146c90e3642c0167e0ea3a90a0ae86338317924a18c2feeb59f5404bec414e4d8a2a14abae32f425e18c14d83cf41e077c19e12562720e0593b8e09d7b22bc73384405aa213f4039497ef0300cd36d7197bde9495f6fd5d6a70f7296e6c2d3a6d9f584f32e7912fc1dfca400de32fd8d76a44a74abf7f4ec26b1b0a64b4dfe67bfd62e2d88b344b90a0297d4973b7a77e166d47b2887d43d42855875c79f55cdcee6ccb5e98763b05d703c574abe387062289f4ff01ebfdf46a5b06e851671ae8da6a14a83377d0b1b14e6e3e59881618d76c8567bae95f95bdc2034ecaf22db6760fba8f5589e15407928f41e90f4e106d98ded8c98a1244c0a4e20a9302b8a212fceeecb2232b83bfbdce302e0bcec33fefbe9deea3fb1f36aee5c3ff5b6fa480ac76ae6df539d1b9c4a090f557e283d8bc4c178f37582cfc80ea4f2518981feeac645582291ca06232220b94c27fe7e901431f36aad505a489b358bd86c868400181eb518cafe43aa0e2936af5b34c167d66ab0418e420779c62beffb5f03b230dfba7bc47ed250c1378429034f122262ce872920b865d265f7a79c73decf251be0288e89945e6cf87f424e643e9f6731232e2133f3f271e57670c25664c63c0314250820b7e29004091984149b99f152c26fb02600e2697032583214fb1330be44a2499600f3e9fb39561171ee140d9c8d3ef956351be98e5b11c8a448fc7e867925d0d782a7a31e83cd63b683ed34b470c50e9ecc3e453af3111d61b22f25daa02ef6f8597ca18f62a33ab3fbdf41bf85067da6bb80191f795cffeb572c6503c1858edc3873bf30c3323521714d0956e64245f60ab54b1b9ae2a5e8689924b41a68c2b6a019826f5ff519f5652c7c19edf45b4d7b2f32fcf25e64d82dd401a38881def76562afc4be16e2a398958c7f1a319902f77916b3564e7ec1648ed72109ef4765973b23fb14b75e2e844b7e713a3720917743176cfc8b6a49288cfb82e5aa6b6c9abdec8b731e8e1f4092834f7fdf56b07059f5fad555c83180764cdafa9a887ae7916d860fb8f17f01470af6fb189c1aee741d83d091deb41aa53ccceef45e2ae8c924b9b0c6757161946d3f44a6b4a0b638b5185776f2fda7f12f166b3c16d1f89c4fc8dd0d78dc816c516e1d0c3448a426cc6a0ca5dcf3fdeb6824f92d7b2ead8f63925aab68e40cb45899693062b1871b7193274ec8a147eca1cf0f84f9978c6bce61a2496070f2d93c1195d61e459784d9235d0928946eccf756c37329b9acd39d94e7f40c8a718080c80e6f066816a7e5bac08a55149b9c42e99a38ef27738571de2021e9e6a3958629bd764601611f92c50f375f9b538b7ec6904c14c1b840e149cffbc26e91892eab4cb81690bf1172168f61b5928c974d094a7ef7fbf467d91dd8b4061f31c17781aa7933796a9a55fd435d098b8b684aae1bdec4eb464de0caf869db1782d7b8999517477363e93b71320912ab66c6e3e950bf0866e4c5aaa005a380d423d79ad6a3d366830cb8ccfa33a7432f07921613cf8d218aea5569b59be56feb508e1023e50840735af525a6c0533c8f85f2d411dafcece335029b032ee3e1fa786cde219b62eac98ac6751bff2b2cab492497593c62c765462f7f73dccfd5343fc3cf3028fd36e668380bc93c8ccc6a028f01c30a89f457ab4568799764898127c71ebe3ab1d003aa0abd31f99160d36f4abf66b564a35d26bffbb43bb8ea76d662d837cc3109a7c1f8b06a6813400dd2669f439bb543ecb8092cde584cc77430ab81951db0578009b7f76305fefc85189c283a8a5e088202050ad7db5fa7af2e25f35c1695d65a797d942479cc6704b2f3e2d73502fafbecfd0897858e6a8b30f2ec8e9ff324ac415bec70654bb311c5686bc736e9949f292470c728efc6acd2ca59f6c95c6914f4ae1406d4e68bfc1d1c6c87846ecab88048518f26bd75c6de24294ebf3dbcb10403dbe1dcfda005c9e8901978ec2dbd507458402f6f50bf796a4d1c029008ea39dc6056366ca0b4464416b383c5f3cda3fd58cdd5c32ec18a566281dd351f422b08829a4f45f7f7c7c69e627a9c09d273fff722f731f0988afe4b001b3d39134be742a316fade0217a1d27e8c8cd01dbfe242ec9ba2306d2ed744d397e95297dacc9064326f9e68edf56a8ab02b50481f468ac4d958da21e6eb79c9a32200ca6f0cd066b8d408e1831cdfdc5f9e4ca07b6650ec8d918a4499b72b82b70507abf4b0dc09072d829e4a34a9f2a8ad29d8ef219e30f9a5f4e33386488c37b5d6600d2a5c0ed313547b0346bf28a31625406dba909cbd5cdca052ce9ef5064a6eeff40f633eb76f63b8dce53a488fe35e41c51e469f15bfb75dc3c903cfc472fc8bcae4a92f9914c260679f45309f643976cda9bec07c3b8534cb07d70739a1cf04e9bd594f9cb5d4f83b63db8588fc7f07fab94a1b234d1ff0373aab46f8c708be8630e03f15556121d95e2a2870a63e8a7d0c356b79149603a36136eeadc5d60ebcf696c2b776065c88d88aa913919d269bdc5065a5381e4f8cd7fee04315b0dc689807b59a3b34d5853262911c90350c94f559a4de5c0ec7fecb129a8d610873c330c410b777afe523269a2e9407a22bf9786b01b0022680a3eee4a5f41b4d1dead664e2f27056a809d2da0786e4c22264a040df543e515b699f979f9efcd18b1fec2de3dc1bcb2b5dcd2e7fe0c31798237557aaa45984c6caa97bf958cae0ff8e20e6d5cc0c6a0f8ab4c6b46164b4ce5b7e6e2f439756144b8e2703e7fff4a781ff84e43af48f05f928d05bed9b2ea487bda9369600147b75b3b88d5198219209de93415555666b69af8b9b2a5c264f4894495774320530a5484b5a05f8ab976c3ad000692b11fdbb5a64384c1d052d222894423e32345b9b4ba8f39e8eecf279ad021900ea0fbba07d09c65966837561b2816cbee82bf37cc256dc814f852fabf069797529390a5d794a6f42a31a327bb6c27b6bb4d7f90824726fd7203ef17a87626e1ef3eaba014bf208f47ede637e314d880bf32165a7ac70ce5c5b534bd82ca942d65d042d4fe35b3590a22e6d0b7bc3be62e16a7076e2355d08bfaac03b657ba607e36f2a50ad60bd3b477afdb1451b62f6bf3a9d283f1bee66a356dcb35aa3ac8249789a36c81d8fa580dad6b82376f08e86f8da0fa2457af081c25ca2df277a81f8716a7f04782bd72727c6bf17dd205a64aa374680b537f709c4a2e5f9d56a2a8d9488fdcc2ba75486adbf4a2c238de24614aab4570629138ccb3093d1b69b3ddbb7295df316fa48e32476eda14f16071093391a912a11418bcd22bdf5b7045e902f6935e41c495662b594c4d7571e9f623bd8dfa473fd889234cbc4de1b836b71d8ac284cfc16f099dda0c6e73d085a9b430be4def69d4f2171b3193f483623a322c962d94612787811c1197fb838d36711773d1c4cfbcd91b3a3fb7fbb19225ebe5abb7855b0685a07f675adec175e382585660b2272f11623ee48b15555a63fef6678297b8b4fca053853decaa6f3e663b2ec6708cae202b9e6352227eca28ed5e02bc23e305f3b5f29685d95dbe4a540cdfdac9439545a3699b8bde5058edcccabf17ae079e59e14cdf99ba6e9a5c7b245ad4ec681cf993b84e66696aa938d1fa4117a8b717a53ff91188002ef4798acb58504c22dba0b0797d99700ab9bdb359a8fb74a10aae12062ef3fe870b9043065da1624eb0b926fb63763264a1b97dffe4ec94e38c664e1f41447f6d8b1a181d75fd9657cd12bccee7132b2b010a484125e7c9324d87ccdad0b45585abc72459d867a840796063796805932c0ff3273df3a37466b4855b2d4a7e46c0260a290b5fc9ec2e1e9d82c164bb7f8d3419a18cd0c8d729719b1f983278e6262a0c2c2cf16e1a24cce0ed5ca4c1c0179949a19d78c0afbfcb1530d405b1229de923a5a13e3c8d4470f9b79a30a95da26ebdd0656856a692d1d73aa1da3429a96d3c642ba20cf5aa9af721d2124cd29f431722027773cfb7a3e7b907f85faa11ac154074a730bba21b1e14fbdb6f08f240b18d5b2000ed13be751891f7d9d88e03149f8ef670d087d622cd18011eb9959e5660d491722f5934135ec6d6b2bdf4faddaa01ab1ecb10ee8e2af5b57488409005322f4198c69f570e6fcc28991cc53c35a1f089433bcc87aaa721d9abc62713fa8a421b0ced95d588d951368b2296cb7b7c61608d8553751d001536200e97c16d9ebd1fa53c649f4c5370a94203e09f3e51b94c14e5aaaf86d04c9ffec2128b97e9422d48e3b39fd5d0853e7af87dbf897c0f7cc81c6a7a56242cfc16e3c8c2b43af86ef7a0060624cf078d157589d38304bbd46b6f18e1003a2f3019401cad5f2594482147e314ab3545f254d3103b03617f9c68ab55fe8538e9558e44cb24e020ee5251dfa60a54a7f0ed419fb8656be6f1cdff9f0d21f7971dbb73bee49dff13c529b79aca80c903281e7a99a1831df2d082db7328015f3c68cb8f2e759b06a5dd50b7ccbb344ec54ccfb9260885d26ed0f4327f6fc9795c828c3110feeff1bbb8c899621817a0fdbf8b43288ff6628e0d3c19401c7974458c61d5cb37dfa003d9cb4bac8845ba63a8d9e02032fe5b0743ca1d722d3d979f0b1595306fdcd99fe03ddefdb00f0a1b4e1214ce4149ea99d19f5744d4c0026bece6d3447a7465741b1ffdac061041c5969acd77d0cac2835686a750c3e5a53103db0e62203b5138928fe6a01d7b1bd0b0ff3f0d43c4cc96680fc7e7126df156d3df27e614495835b7dd0f288f7a3dc388b5b9b3c5b60373bab03fcdb5845678c9d18058d4f947555b5db7bb645ef48cd7b7ac7b6470c00e90c79a06a6b251b5ee8c1203b0dae91e74270d6ffd6b51371dcc39444196222c1ddc6089ceda59cf08f1c098ab8627db9ae3382068442b5c66953bfaaaba554e30a7b023dac63644a551934d219c85c3a0942dbdec20c7e3b30ead8845e593de21f46ce89367134011e7c984aa00d47e80a2ca6143d9fa3aad85b7deeeab5138a333ff1dad10c71c366ebaa7bc6be9e612de6aaa9db33f24b60e3a8642c80c435308d561202e3486cacab6972ef19e47ae39714fb19b349b4d09eb6b7bd025732dc91b367faef328e2d4ebfdca9af622a0bfc0dfe9728cb5a9bfa060c7444d8bb4f3664ee515a192065738127dfb8091ddaae7ec7ee933991f8575287fc22e6fbf40e6644512f4da83bbd7128bba5d36e6ab7d5f61c8703c02dd6e1c0928a90a09ae1f013c30686e85a873762b380c20d3776676b373eaa28fed25ff0d315b6b69d24d0a3f0a7a360a87677fe6d18321b51026836d58879df553e099af45255392398516d170cf14a7e2cc457d8b8c025f67f9113eeba990ebb4f9af184864d3c3ce7e4f62d9e0077e962f7ae42dc86510a8b3a8295b56b7fcea41c0df7a97f91afb00c04f66f1f6ff45ebe7b9f5cfcd197c4f3b43d9d22d77d9c31d0b3ecaa056272ce3d99dc3d65f5462df5810c5aa59c30eb323a8e510b5e483553ff37651c34ff32c63c3aa04a9743f4b0c7c62b1b8d269b8ae103a1efb8bccf74ace60174bf274b2238c3b97c78fed85a69e036bae32232e23340ec9d31bb0656b7f669680b9325990bcdbc2bcab43bca656877970ce4c52cef9d299c414af8d8a6a6443eb452186bc7289a966c9c05ac309948eae1cf69586c2ff1b1477e332a45427dd3af457e5271ea7f717e2cdc2b2b2c36d600ae4e4f9359738cb532a7c417dbba7b3988c19fc5735d835bf463ddbbbfd121b37dfdaaa5198e2bae90c95160084aa1459e04989c5ffd77a01f473a4dd7d4412aa1658af7b6e58aec66a1dc4c3512586b36fb980365f26361f5bc937da4894daef356df30e051c4208f29e69b15912f59db9cd5f1568ab85bcabc8cf514ece52afdd28c58fbdfafdb87ce7aa512ce746cb7737a9587ddec92cfccdfea4c747ae9419ae96bb1a29e0c62ea9fd23c38b021636f1c01c3b48d57dd11a44317263a0e2553abc98ac4eb3a921ed89e4748d4070cbbf5baee16a52308a08570d5725b595194bdf5a0d947c0d6f73fc56027fe1b3f29e3a9ae3cad323b25f16f4293781cf64ae0f56f3f5a0db109a92fbcca16820e29bbd095a1bfa516285334e434c58e9e345c1b7e61e789c1075a950c4d68ebf8ad86d2ba469d05f4a79f97769fc42f65d2f506dde3e67e1f78e45d085f852c2a65a29a6db0529cf7d81810b164460c49fe9704fdb678d8029ca1be6e0245c108ed10ff7d7412cf695884b8928ffa23c9f467beab34ffbfe7f5ed64fb85b060ecc91431332ea7ea861f282920678505700e33408198a4f53e2cecc097b4da283585908a491db40525af8f0c11b9d361071f33c88de56377286fa7c979dde2f0ea4ca66730ee841a34836e91ad72e22c85f268c3e77f372560edaaadf7eebac3acc47cfc14b76771d9eec70109ece1460e3e3258dd0bf39b392e5c9281eb2d2abcac024f00126ae679d9340fd3131cec3d18c3d1485965a36158d4746da0795765d761e493ecbecfe996556fac2e9ce3873ba711058e76c83a772444c4c92b963e41726dfe58dd98964bc55f0c8021cb86e9a17163f57376ce15e970a63fa42b0fbb37c4e43395039678071c9750ab5f250b5821b09fcfcf4df2fca8e1a73baf4b555f755df1005f3fede61a6ac9e425530348c01386f3d61d731898e2f2b277e7ca4273acecf42a8e6217e0fbf676aff11abcb6bf26cb994c53e5e8f268f9f71bc1c1ed3b18304a536559104936976cb5d2e1a9dcc777e27ad1ef1fd231f7f93da6297bfa699c06b15d04abb48f798ff97dbdea78ea5a14fc7d8d050d21d55315cfeb09f6e004ad22b026f5cf96b274166b73e8aae7f7c2668522bca2c933892884da32acac693bf192108b817a4842c857b757878716105c46b97781480c6e93788c8a5a7af35e90bca9938ddb43ea03cf39226ab6322905ff3fd510a918d6ac969ea79b7558b68c8d8aef35427cb1f1a458faf16a4934aefd0e4e61800116346014c68151cb3df6c286a4c75bf2ef0a14441af42b34dbe1070584675bda66a02189e6cce693364be98fd759a89cb4c1307df23c44d8d9318e435a07d18109ae9b6af6c439682c34a9af1f98ced20260203c90f5c69ac7d3c7b4f0c006ab2b363563339e8b54fbb71d993cd9564ea93951ec9cb3b67fd5c383c6805e703ce4a735b8b457404a00e64df73d1527134078b6bed28423b66bc07bfd7a5c56fa7f19b16d48cadc3e7beede461011737c119c73e5f6ecaf5829334dfeb0cde48e534bf342057d033669a7ecf4abbd3e8d410bcb1ee1379e8ea74fd1192eb68c2100fdabba02fc567e13ab3659dd43ea19c8c16f4c87e5b4448b27c4e687ece76e20a0b75949812d653288c92ea72b27194f91d24a2f7bd51838f09a0e47e40b1cee3a95a4a93027199c594a1f05081541ab6fdccb3b3d8e67fb7fe2c1baf8afc5660a01979d480e578817db5cd7eed1b115c61ed9188e2539fa4c1221ce7f3445e2fe44338f578dea57c0209728c9b0a09a948cab3e7633127fb61ecad5582bb84cf6dfa93114ac87542c1d20a262d04744d57b8dd0329edb72a50d55514454f4c8921b346bda57cd59e2ea1ae0fc505043a8be3eff511dc869a7a6d45cf019f8975732297d9129fb0c8980b6631729dad0e50d9c17e27e03bc989dfd4da7811dc30e8b7207b5b7848a21c288c92118694743a0b3d8bf44289f3c509e6c4cb4a390c4f1c45f5ed741e9939c42d1055eb92180f72157dafe172352074c2f3dff3877fc47d73780e2569652900bd42acffa07d618a4c6eecc6a8a8b8bd94f37bf3754ba8a33b43ff2ac4a416510f6db0c307ab3a60b3bb73eca7b94c900449c545d27fc9e10df465409afd2b1960eabe6d4604df0d225d53b147d96f3a537a19edc354b28580e60bedaf4a3d01379eaa10a68a428fb06bac5698547e2c6c1c93fcc930fe9a8b723561e43d95f230cdd26aa4b44132f32a3ad465a71698e2790d0168713591ab565128d8266c49c57fcc0a2c7db8216fd324ec8bd2e661cba2450f3f458630d3808d53f9ffbd691b4a8c294132ba53257e9dafcbb1b245598a47ad69d9eef4395ceeaddb30c897534ef3ededc8eaaf05b9322b3b66f74e82bba951f55a50119f947e72b659e4a0a1829471e45e3f215f89f3bd0bc0d9830f0fa7b0e5c1c20252e6f96ebbfa469862572e4c7924d405c84022ca8bff5a39dadc714ef8808a297427745f94905a0f0fc8552a98440fd08ad726c6def002f0224b481e2290c06b06f22b9ba278515a0da014e87eb0080a0109f0e9ff441ab17859bb2919d4981c0c9ce8c7a798762d1c39c1586be12fe2fded688e8acc6eeb5097a17a5241e058ef7a5624bdc04c39ef869fc7e531c577fba2a6948b302c349b0dd6451e913f73b3a953540bf402c52c44bcf74b0351d23ef4d598d78124246fa9b436a0fffecbfd83e77eccdce56f7b1279c999c392479511f0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
