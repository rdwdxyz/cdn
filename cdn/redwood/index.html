<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"293b0178ac309bdc4953c2d4146fdae1d5dfed864fae8c19c282ae0df12bc7c74163a17f08dd81363395b5a935bfba522e70400652d9225d391ebe0ecbf0a7fb5d4e5282068de92d15aa6f38d8b23692339feb6405636cebb5b9be735ec7776729f729b719fa0ff115dd2c1231af96aeb175d56e409523ea1d8d6918514fa59c4f87dddf6d7e93f2c959aeac8541909a00f2f4c32a08614d55a974f2ce00a4a5f0c68563ff57eaafdc992e459faa8bc10894c529a38eea03f4ffede97d5991184a00144d4b3797df99fbd18dfc03519807e00e8b3e2f3648ca91984e5371ff727f4e976bdd5f604cb8fd0f20bd9f18abddae97caf43644a5dccad937858dfadbb4dcbf8f55ebd5c7380822ad9643f6b08742d94468a53f93357bf4698510801e001473275327ab0535cd6abda89d4bf14cfc7767374e7e4ac92b051c610ddde3db9fd540248f56b06a7fbfc75d88801205dd0c737b37ffa2067a0df417b80bda5f6c14fa27b9a51967c4dc43fe52e6bbe312d3306f02d691325379dd880e677c81a2d1a1e101b9e882fa0395d3f46532d2db31963741f6c20cbd9542cdb92546b968185cd77c8365dca913dd6c5beaa8749cbcb62500eb78cdcd8d23f491806b4f1081bf2de38d61e4c0402f70054417713967e937fe6a2a7c88c14a564642ec01ddf622dc5a421d3643541fdd9faedb3a161be88d6f46f924085434948e84e6c00a94bcec93bb80f340b1e1494a5f406c342926b7eeb98823a73669946cdd017840cac0894287373459ba8d7f731a741ecaab03cab578bd9a278a6dc0271e043557d52270231471e579d5b62c1a90aa6f3bfa7e985cd31886eb651a549af7e479b7206c495c65e6fcaff434bd63828951c9c5a721b780506dc750953fd14fb5595f4a517c581f75866d98d9a9b42705a6fcfc36bcbd895d76867cad46087e659f28ab21cfcad9ca1ac3905d1b1a8d854499ef8e394da968ab97793e4cb8447b4b4fae135527ea6161a752d036ebb9412223bc0e8d3da3454bef00169a20a25d0b6c3527b163b15eebf6bf15b9696a13821163af58a46343278ce17fca7f7045f963b5bd6514fa83ba4bacee5252f3e18b60284f20437f06fe277a65daf5a3b05c081c07bf539a948b60f35fdb6735540814d043f9fc6924f48ddd5b942cc66020102e39cab084dc5c73edee062fc3dd534214b3452b230cae45afd56f94907045a1de480500d3842b496fca5564f75e743a64701eeb096df39c7824b9e0af03afae7b4a457cca8740d87f205b695b53dbcc6ddb59e731439ffd53e5d8739cee359544b73b20e3dba3769e4734bcfad5c44edfeafe82bdc35263c19ff93dc7bb2f9b951883a72b4a6e6279bc0a449f84a9076ec509094fd4a13e9d1baccba78f16ba8639969de43675b4118271253a84b65ec7a9b325c4493c82e613f986d534f931b9d3f4738ffe6b3fa32272bdae5815783775a2b59628071d64608e1a9698bace5d3f2bd31c4327df0e01a6a61f46010254a34d861defac5188e2d641f14e91803728371498dab22953e4ba1ed334d0a73af49bd555876c97ebcba653e3ebe4cfc18695ee87d5b0f3b7d6226764a64562e953a2e0af653eeb0f48a02db5737fa642c630bdea70ac26aa0b793c171aa37ab99dcd7f071e06f99931cf60287afaca5eb7a0a4c2bb73075b61d25becde890e5223f8f05c967e99c4c22d3c9826c3c2b2c92b572526d1b35cd4766bd7d4aa7f4111a7b0b6b8dfd5dbd2a10c68cde1b4d6b20b27833b8122dbffa441aad933b658033d1161eb3699e5031023cdf763356bb4ca037e59d00149306bdda2d3d5b0b9fce6518ad33e8ff023b99fb4c4f6ce616510fc691b6266eabf65aa75387306253a388ad3685480bb6234b00644969f49250b205baa013c50e3ab714b5bed4f049ffb2706d75d810fa9c395ecfbe123d9feb501d9cca022c07f42c1dc7ff73de808f36c89ff283fb99fd276d3cac3bd7c9b7a17662380933a6c47bbfa76ffd7ef69b58f89486d964f0a5d662de98f35ed1c8427e82907b078d9deaaf48b2ae3cff0f7c4c6fcb375831a496a606084d24694e91066cf1ce6d6811cd4ff49017dcd386b1f006378fa4803e5283d058963cedfaa971c74e839ade7b2bdb33c0f9cf78f195c45e40a403df736158900de39d173f2605f527ba62d448639c4f423d9f1a95e94a74c859ec160efb09ba36d3533d748cdfdbc83ca8fe9672387b1ba01eabaae47f22cae79d51fe9693296cb8010345c8deda0858cf6504b31870ce178dd817ed3792a5bc4c61918ad35046aebe0332ac04f5ef097deacecddf22767042536d27aa254c66482a960ab232e44822b980360eb73baa3dfc96fefb6289641829bb187d9aa834b0ca5f04780ae7ea1b18a012e2b1d767977a6d51d5509a8be0da48e2853c8fb1751bff3e0a4288e44cf445f6f6e6f178c0cfbb4c267f60794d9cc07ced9bff085bd76579ed522c2a2641c9092d630e4c70e51527dd77bf25a0c9397318e8fa800c4990e163c7bf512ffdf33961be3b173ec75eda9f59a6383c5be0519d5e4099df6078dfe4720c26a575aa42c15d5ed8e85fb6cab298deee0f85bd7d93914eac5d0e45a509e9e14054c0b7468d2432d914a5563919b393c9f702979262354029d3e91a9a09b330a59b1e6145d5698ef6a29a1939d8f71b8ea6f5cff5a9f048af2d7bbfae25b8fec63778ada8fbbecc0fa820fbf86afd02f55d9597f841b559d3d593f888146b85b7b106e7cfb37bcb9c3a7eb75a93c31fbc540063b83cd7af753742bd23fd0fcf7186584b66175b55808fa68a5357807622e6bda781ca8599de47e67f22467e57a5a738430a4e546ebf96e2527185745fc94c6abcdc0fb6a5583df3b0d291cd952cad3852fc700a4d847891bc86638cb7e4e962ee457c110bfbbc2e9a9bfb04925be9f0a136d8fe5f2f584137bace62f72a1401898ab4071ce97aec419e760436d596f1f4af54ff8889e49689b3b1747c636be28cfcfc6257540f0ae62b9e0f7200280acb52108406840a12f5da8004e38f4b6ff200160bc482b99e2b54153d4089d68bbb5a82b084380e4c436fb56b43f33934428e8424ecda88c89b2c6bb48ee921324ccf15cbff2489b2e7dafd668a6f00a9b44ccee1b842ea41dffa3041c2175d32224e02cadd93df3f88f057290be721c50e127be9f8f570259374f9cbc07daa61d0c95343f785a334876b741cd4f2c8bd7d9f2c7c499bd1fd1950293f97d354596c35b8f364b411570039cdde50be5d9637ae13229ac96dea190ea07b361becb45fba579cdb8cfd2b19f4319029668c5e46ca589d855adf7441e9a939a8c6d47300b594111e678a6cd7a063f19eba3554205208c50ae469177dc4a54237ea6e62e873e0e9a220475462b270f2ec7792c3416aab034ffea93819634d0b4153315d78d678c0990297f8e28d4bec6c806e648228a10a12ed14f975470f27ffb70d319bf543dc18e3c997743e441fc5b72b60f1465370b70f1f95e35b8d4a5304892aa1f12a735f832b06ff2bf1232d25aeb725a93aca941953eec2e3670b4f576de3af0c4404fc33d79cf7a8f5472dcd2e59cdd4349d596341d3743092c07e9ac30eeb5efca2747f274a7582483480b6c9f266e86a4e145ce3ab5e57f062ba0e7bb61b1138a7609056440375d8b0025b75fa6ca661f5ef669d8f5472f1f96b795aea81d8a4d54e2214786d74f8ad54b446c695d7b507bbfe9bcfd9413e707741027bfdb732dc5b9a16c2fc4bcd18e7e8aaef4f57bdc8efc65532763aac579d3be6bc33d06143dc9ea407d0a239988b082040ec90f7047b322ac9d4a8f51b65fb3a4063d8c7712f7446bfb2c1a9993f55acc3532c6715ac6fa0f5ac366ec4510a947009a3f4eb2b5f3b1989f3dfc0ecc3fcd0f67790b7f53624d51741099b746be94fd584cc8060aef05791bf3a44d5b36fbc0df234556da3c38bec20d7c1b545106a8fca79f22b16dcb314f79b2a360ad25ff2dca10f8b8d68de1ccbba9beb32c5b72b1f0f51121c5f8abe5ddfdcb857ab94a2300a3313d64952940eedc0bf21e7d1efac0038a02ce1481bdac3faf4f25a72f243fefdbac57e71eae117c8fe23d106ee2bcbe775f09bc7efbfb417add8a4f07584a33dabcb0f3ef381a01bb01ee44847f8c6e0eb5c37e751888de5452142ba04502e2eafe2c3cfe894def6fee22bdc32c5f24e2c2caeeffee8d99af049beeea5cb5e98f8f3e7003061406d30590b0b4b1394214ae96b27b4120bb364cbaf6051fd69215b2960196cc108c9f05d8f0fe283623919aa2a0a55bcb2de09a496650f7298c59b10fe824919f07c3ac79bb861d67f57c5ed0d5e55b987f37f94a516369e6ca1f8c07ebb0d70079ded822f2d0f0c16b2a695fea7d6632bbd0c5833f71b158493f86c1f9a1382e7c562e603da1d792d9cb75c3af37f91c1cc83c986839cf8312971f1dfbb498d32b81acf9c0165c642e9ffaf70545f332b59e6ea580f3f4fec486e57831582da9bff2857c737819d8e2dd6b50a3b5dd763c602515e1bade19597767f6052224c9246b04b934af058ffaf7ef15a33f97ceff0bdcd9d6fdc11406525fc8aa7b2ad39c7787ac1331354897e8b858dbcba85b0ae36d5cf0332160273526f6fd005bc969efcbfc5cd7242cc7069b811e42b173b92658fcf369cd2298b250e7c0e9a3e4754daca9075310c5f6492a0ed240baaee7bb0a43f3ea708fd44b2e9dc48fc937abb919e45813046407bf6cc7c834717dd9b190e363edcd7faac1b7e65f9b27f03bbc915ac75b56ac8f12efefce03630aac6b121266d7a9f605f0f3cde4f714393fca5faae68449b618e3b46954d09c93ff4ad0f5f4712affcbc37e8bb4d9a88e6c9214f9039c33c9a421964dffc1e9ae595425f804d28eec3121c193208006f06b233fc93992c104afd0b9344e3f2e16828a32be73fe4ec9f76eacc33a170013a3b63f208eaca2c883ae6005aea86c5075a5de73dc1f7b24b2b0e519e8f3c168f457a07696f8e66b3e09b95809e9472fe1cc14545e84f0774a4c0dc9911f573074569aa596e70aa27811e5d14f80197c0c6fbb3a3c75a3e938c9354c517652e25935e5a4ec3e734a146ca0475a420215c1050b56aea21deedb0cf79a8625b7e22d2598390eeabb966c075cabef36067a7f986cd4443ac70be75c36f3996102debae5ff81995fa2c4d64627673fd8b2e05896a17342fdbed07952d9bf5d62b091d62a94eca219e5b3aff23148e791c4086a9e33803720d2d4593e43591a1e121d6a755f425bd731423725a1f5d39ae5c0f7b527f3f0942ecbf6c663f5ce1d0ae6213d7f2a2f5b9a77cc830381b4c6704b6f250aba54fa093a589b05f8a3e72c4ca5b746dbc5e454746ab0fbd31b883fb8e55b0f7e1b1e7a56e0e3b963fa4fad3b0f812204df9e79ac3d8ae3d0f8be456fc7c2bfcac2c8fad320220aa0fb4aea9ca521f33c996800c4325c2409bc1a08cc57b8478309bec5f2ef226b0b657d2552d45f3d2262893fdc0b7ed950dd9d3bfcc12615e7bb2970b144baa738d139f92caa25276df25104c4a90812c0da65c1f00d89e9ebf802494e1cf15c50297c44c59a8d08f16959554f03ad398775b349490b8042b17d13642d48d7169fca2557b8d637e1825d2d2b65d63a0f7f8c37baf7bc18504e1f9af833331ed5e7064eb39a530c0db3aaf85246663b1406de8e77b4f0ffd8766a999996a2be17ddef8710cea01826a5d82bf25bcd4b7ec3b2e7f2a7bcdf0168cda0a641d295092c631480ea98f7bc63ecb68c5580f47207ec70886377b79a8755a153c8e70b2ca7ddb875ec99254c990b5cb6947ef25cbde54d53843c06f4bf46cb285db28a69597e14adee7b270386198264face222ba3e46da5c48a544474a9248ea2c3988d4f3c64eb726db1d84d68492bb8129bcf220e246a0de6179fc97ce898bb7a39e12702a3745293621d689d0777e22dacbb6c57fa39b621546ba1f398baae5ac6414220f72807fb289cb9f2f677830f3efc1fdb3d26de79fe6b67c9c3c8d443ef13696b3ba15255a6981e1200ad8ecb92d74e7d1f5a6e8badc276cd30cc698db58066ab330d214f33292093294f4fe0c3cc66e24a25422ed00f268ad5b1d59f240325ad68389c52b82c6ced8de2fb2b96a077b295ea41976a3a4d3322f9a200125a33ecb35022506b8e20fd943e59cb9c228d39a0c302927336930a0f3543dccc430a2c22510a681b72bd92b315c80d117e936b60d22fa7c60d81446e3df7a84047e149071d7b092bcdb33345a1cb6816955bcea05631542eee70a4f11f4f6b85e084204cc6ae115385749d1a0a908f94cb22da208dc74dad8204bdf2804dd32569b9236a1830546740de15ddefad0b09140f137136f5691037054abc6cbf86ff87fe89cd2bba937ea7d76f803043ab66236867f1b1acb1ad97b5b501c544ee6b36ac1a540478eeb9a98ecfdf9e805ace2c4007b98380f1b7d0f31958d359220dd2c927ba4f11fee8599cb00daace9df031e912972c6622a3e606ca8400f6af8ea13e22edcdbd63d630eb5742a17aebfdce4855ffde33803d2ffaaff6096e15d0e312b4d70bf224d28ced39b69c58472d62ab78f46078ed9cf2364492405d2ea81772a7fd8f49372f4e03650d8344e0c1cc0c3692ec3865012916b200ba8193f72c5bba5a72d781e255ec4bff3a8695f93a3afd33d44b1013e87ecc697307694477f6726a47b6efebd01e10a16e7cec6c24024466001e93132b54482a3b649d3d56591f2e92f078379380a55f13177123d44894b7ec9ae2ad6ea0e8940b54b486ee583fb3c86c1b7c725a70f69fbfc9121054f3894f4032438cbdbf343479c836794b8b16d0b60c3588fe896e7ea4cf4e7c6dce338f30d816851c4868fd37e3d376c7a468b609be7ddc34d7d0559587789f8ff04f64ca77fceaf3a518cc23f66830edd2169e6c708fe29aa520f2d0159d2968ed9c6c73229d23de3aee707cf1dc88c293b426d7bbe2bfaf84666d5e421774709fbda4a7179e19132ed56d098053dfb346b6d44a60edbe5762d37f8d35f03a50e9bdbbe2251d0ec0eeef35c0a11528b7bca4139c7cd6a9a502dff2a7e94fe65a641a02b12e05af87cb787ddde521745d1d9ea75eb2be277333efe62fd64496f371501a6589bc29ee9fd79a59a27f20833c275efae045c040d132c8c4b39e4b991f54dc7d480693d6e87cb34923467c914bf5d7a936e180103b55a899142790e5addc9c0b449272184545cbff1428409111dfb35eb57ba582bea0afdf41eaeeb5f86331b2ff348069bec68adce3519808f6f19b6f4cb341c1172c5981f2099e8486393d7366e0edfa21c8def6af0652ea8c42be9eb3d6b8d8089757559e4268a05d5d9a86fc96075b6dbd77a734d2022e998728fbfe0bd34e56babe7613f131980b6341a75bb9bfb901290ba9127c462546114b4e1de4019b5635486558cfaebe5ef4de0ac84093e2c2be820fbfc444687581d95d3ebe6847ee482c68d8d5e2b2f9c374657591550f83e04966060a9f54a44938edb354049e6dd888af330a5f03d01624f4253b81255949a4edf577d0ff3f9e2c4b5cb01750257781558dcf95a4c0f264a197b9cb1d6837cb2bb8c2399edf4460f83dda43684d214f033ba7b04b1247070832b14248bf8a8a47de0b58813d8848ba52c621d4b790280379cc3223eca4bd093510e44d0ae0d37f1488ebf561dbcbc770f2321553efbc7cbd56c5ecd6f2db635d5171fd3e20e2de75bf5bb1cfa5c6691b3d5ea0eba1528eacc56d17643b1cf934b5df81b75affae3ba5f65fcc246ab81695f189e49553e2138af489fb6324514781e9b28b0dd14638d33b2e774c8c3722904e8ce7131d123594f1497d150779d4bf879218e615a8c8d192a50b376f58371c33ddba2599c6e31f8612e345218a6ee281bdc8ca41586dad0de1fc878596da163e313759cd786e0e9e14c4c161709f92509266679e24a208232c60aeee7f2d5d383fd34642c8fa33f7ed9d9f0778071bfcbb93e79771b524a1528fdf25d80ce59066d5e266e51327b953ffe7887858c7a983b157428cc5820418b6557685cc0bee5dbf8ab3f153c162861344a71334b934138a7c41d930b7b0c3901b10148dacb7604d6f993ab5a835f221fac32a02c088dda764fe70f2fb4152cd830d31807bbd0545f9727d651d71be1d5d4234e8faf5861e473c1f64edcfce63b3521e4ea1dc42d0baa2cd3f119cb851224900c0a7940988c013cbbaabeb13bcbd4a9156d397f872183e9113d4e1077f1f7e7ca5b65a23c0a0e63683c495ffb4dec7183e9c2d7618d17cdce70e27a8974eba807dd7e9bba21398e8eab37962419bde936ceea385d72f9662c672386ca25d9dd720f85c36f5b28710c74ab8cd599710cd38e490f3db18bfd9f05422f54c74741b979ca2d50e27afa9d07786138ae18ed2a2e812ea11780995cef1967dc32479f624a855e2ec6962945994aeaa15ad01788eca6f3abd5de4aae91bcdaa014ac3ad8e2e8c18d0ec028cc073363ca783cae6537a8f3ec4d4dc418579c8e0029e52a84eb8339baf723a0af33f40fb1840eb9356a8698689b2733d401dc534fde2e9fccf76359a1dd670badf23743fea44f24a70238caf6c479087bb192346eff6ed8a91e6cac5ddd44601a8121ba33efc627e18f77022c22cf06a273f8b3a0761a3d0c4f1ff1fdc31bc959dc148a700c843355dc7ba08003c8efe50791543d00defdfe8c8a3603d7f2ae1da57e73d28402f1e3492f0d7c13da0f293c1c5bc6fbafea35b18c4f710ef7d8f2b9d6c9fccc476dc5e697271fdefc07defc293cc2ef4511098f08595a063df451c6d55391922979103ea9cd75486c14e5fcde7da61aa25c0e001322c46764462011d0dcd1672409b46914aad08b8ae86d6e62747a95eecacf552eb88498ed5f42f0f75a1ac89b2b12cc399fdde679e222bf7059d016ee0e6f5d232a53a1643daf6d7d14b214658438a6829fadbb589cae3e3c32030752456ff64c12faa74cbd625cac2d80c9f9981e79d0a2bdb3d71cc25ba5d97353275ae76edd89655feb589bfff42116f411349e640fe53996dbc976886b31166e9bbee5cbaef0389af8f2b01ecd484498f3d8fe780ed120ee54c69f508449951352ad453e74e8c7fd2f2759982c4dfaaba562b3a5cae8d5d7d3f324907836cf1a4c35be2fec6c83064aa64946485d2b8694ef7c9b8be95ad599695fc6b287839bfdd33a8786b887918ffe4ee29cf34d12f4d0da27457fe5a9525e40e435ce7168ff04e1ec8077f18b2bc36602548b545ad75cb2cf7c1161acfeb188bb17e6a016cd2de85e09b8644f451f660f380bbd40e3c807d24a58fcbead95acfae0c07c524c1aff6f5a91cdba726864e316150e66b6d0ecf6021fe63b824db84f12450ae5bf700278d6dd73d2204e1b79c591cd2fcc2ff8cde98c24ba7059ebb66732467da4fee0e477b39aa6d97843835e08f268b05dcc9b675da9573470ab9bee72e6466b3f0932b1d450876ee0cb791d22a6404552534b7fc443ddac42756b2f15e664f1bfb7ca7f36824012593da65d6ec452643778ad4fa8cc4ba3fb61894affde486c6feb3c4b8d113f0be869e3db17e34335e63d6fd5661e77ec163b01bceb522e67efc13a579aeb92983fdff50383429808bc8b68f51536708de9e81fc38f2a7358771112ab2af6b768bee58c22d824494324b8e967f670eb77d93ff3a44953a1642826824ca43a1e435b70ac79f978538d4e1fdfe5d9b9315df06faa023f1a22387ea5977e3aeb2f1e27a5621f8d5c2c01315aa8b76aec5c79e70ece6213bd96184d7764ae21540ea4f2b4aebb9ddcb1ddf5f2a34345bba7e83dabdfd7af7ba336737e72d8ce1af821ff077c4a575b25b7c56b8914ca5abb2d5f6c3bd6db8bab5189974a7541e30a3f08afe90b6cdbe1c2de2e9c162a44929c150b6eca20d9158cb9511c802dc621b8fc9ac303fa58df6300755845c7c178af8d5cb87fae111b0e3b65a607a089a57b7a7663d7aedf24478f9e8505e0a11083c1f982200e30c97c7a278d176e43f7fe7932906b87b5b0d681925528f4104dda3f3a6b65328f22df1a44ab1d9e3982d60253a9aa11cbc62cf7c2def28ccc3a306101011f1c611c919defa5ace64641c6b2a2d156e6d97af7b204974956546495bd29c0d572af0fbcf6781f732f495263225286af2e4e8f4de122da6fe98237f1f067fcb0e62d90ae5f142621d1fdc8054e09ebb5199badbae9ba863c44007982e5745ce26f12f28ff4a90d20a0007420c27e51ac2aa1629cc3c9c5ac29c6f35bf34518f6d4d911a5c71782fe38fb09c904994cba322fa5a9bfbcf33253853efe479c44496be6059e990a774c0c582aa77e0ec959a700d248826c7dfa2593e326fc3ad875cea35100bdabdd560d4d76df4294f8d6e69aa260307b68a969df2e8e96575f33458d19ec352b3539b9717809a329bd4cb493c56687ad1b33fd73b299b49e1c95cc9960e9618bf606e002d629acc2c0d6407f9ccc3294b40621d330b5436e63cbb9f65eeff2a2406050cf4304e1064be79fb0bb5b8ce9067444d93f391e22eba014bc8ae61589561d48f18f9088889a195b47c0c007fa1f6504ff721a1ab8611ef16f9a63a35fb92838d6ba941091ed429f1db0de8fa1a394031af42de13e656adc8f12a23466a7736f0c504289e8b333fb263c2aeeb82314b5b2dc333f0433ef286f04036a9634a35c0263b1242b7faf01ab16176ea982975f3f395d43b0cfaae3f3d93a34a7784a9cb760ba79b12fce29987a2bd32046349df9c5b2e09d616de143fc60fe76ea2b627777ea9c91fbd8b2479e2133bcfe07cc0d27429592e60c7d7fef5997f3457acd71447f782e003e28829e87af9ce0bee063c734190c51a9ba176265a4f1a9ef6246365e87daa312efcf3c5565934431d77d4e09934fef742506cae16470855d49949a621460713bb9dd83d5c1ad36c68d0761f070786d5c85f53848e773a23a7ace50de80edb84617c6ab258300b72c4406a20958cc97e6af7328b605e3700b3b87eb83d1497c947f2c0d784baa516a0875c2851178d3769191e89b1fde17ada96e2e81993c9d7280f4f3e73edb69756f6fe460dee9f04230f8f860116265ed568c7c33cd83f50ea60eb0e26cd1a1ac6293c2ff2586bf069be8a5e08ed9a8324635d4c7bf599e100ba74c97e4fd0fe2a0a359d120c9721504f86d56029602ab3e8b0c7745501bda311a02d1246b03af5b9fbc12f0486d9fecd9ace183997d69ce0e4123eaa27fe172a8bfd12c0dd9aacd581c7519bca3687224309009bec7a72ef81370f46c37ea1ff1446686583d8f54a9bb8e1bb3e891bc6f115a5345a3e6c0a80834eb90beb3b5a9413e464db652e4059ccb5668ec2b40744d1e749056dbc55bdb6558da7cb8a515b86f682751f5626f5fefeb639f64365d200a906ff6cad89a68977c06f7b08f64811880c0c955c73d19084b38fbdf95dea1b7193c6944a5a3594022c98d86fd619de967c5297212cb37598608af248ad0a32bb1dd541b29d51d7a26d305b0f46e3f4b1ccf8f0ab52ecb1948e513ee665823fffee7b18e92328050f4b4e2095538a6b1dc5264382ddcc043c95a05f32c2491a49e4dc3731937d0cbcc6dfdd212e247fa27ba4288ae123af0a935365f3a3ccff1d30df0daa6c4b1dcb52e8a1ba4688210481ee793ae5a7ecbb07690a1c349486b22621ca25163a5137c91d45e53167256ae6309965bcd686529497d0f3a48a9a1d064defc75cad671a798a44a10e9f71a5f6343dbd705d3cfa26efaf4ac74e12b0a72414d4061d49f057caa2e770ed03fba319442ae9db85d3cc065491fb8bfd72208e1fa5d0b241fca6af2e945b08c01778692d44b5df9c0560fee5e50549ec92ac1c69dd4db08e7c96dbd596ac95e268bc9e3c68302030a9103ea40160563507f735cf49353bf4f9d0ba98ba2e8d523331a0999ff0bcbf56376b38f594eea2d79c540fa0b7e99790f7ea8cba8229d1608199aceae6dc4536b4e7c63351603849d7611e97cd755903514310e1b09570fcba580ccd186b60aae3804bc3b49bc8f23029371e28ba13731637ebd5530a51e15589da03d4c54947d063768ea6606af5a0e4317c3514ce1e6900e782454f984c8937a1afc70c62d21486dbc54b0a631ca661afd932291f8244e10ecc729eac907a6e4dbaefa91653c6b709400fb10e5c4aa3001b4825caabe0580cd17d0c87f1f62fe2e06c1911ece9c0f51521f7c176a86b821ad1178a48e780c577b54813be526ca1247ba20d37ec6a1f9b9af3196cc512e2b62dc05d6810a934492fe6cb9b6bf2202ba2b7059b8f6287b544657620a1874e217e335a7670b5b9518408e9e7497e94daa94111d487af6209d27e2af478aa3ff4b0b49b6ed02e79cab8443a199f93e42af81b44f73a2b7dd71d502621024bc976c172b830df39be26cc667bd0f8591445a4d60c1c1b6b83394e2fdf388997020ab45fa840d5f1939296d2a476942e98471a4cc07793f5deb3433c6db795f26356d8ad223710bdfd6d73141897037989657ab862fda86ec245a079f1f8a68765f6fb81afa51f58a1072dea2dbd628aab7929556b2da4aa534b7681bf4839b53f2b71f354c0eb771061479c1357c864d0565ca3b0e9e3c7c55b9aea06db1c9462c54f346ed47311e5cb8bb7dd01f8801c0c3446dd11474a917ce30efbd203776943f0eb3b519f770f7cff4fdb3f537c313d42409a7e969f4d2f1a1d5728eb78d37624ea159a97af150caa4a6dae9500ca7c35db3ad9623135c3dde22d3e8c5e2803ea97a9de998be33bfb37d25cbfe7d5068447da16d8ed16e6ccdcff5bcbbbc913051a4429756fd3a43ad315d530b28af774566406f61e552d74d4a0c172e98fec8cc6d24a71a90c0ccba31b6783bf05de85767dffb5ddb55931f34b8cb3828bf15e4e5b79633c9f8f43b19b522dfaab5ad1356abfee521d026f22d8dde082b833244d9a2370e3dd77492f1ccfa93587deb8e0e02056e6de034e10b3249746171321834aa445f819398f87b38d9fd54004cba39803f6e4cdc4e8dae932e53e11456a101809b62a9d4913a37c7f906861e35d6e8faf238f6063b7827b7bcd3ced4c770587af2c2fd8cb62598efb77bf8314611589f20f29c48be8c15242be85aebf1f384126fc80fdc692349294af058fcf1d7c91884d89da5c73de8efca6648f1ceeb3d9e0dbd47cdc9003f676b9b21ee0677ca313cb55984d4c0096344adf74f5cb67e0add03543edf09e740ee5af9bb42bfb0a7df1a840cea6b7fb78d0a7cea866f874c03c635fec3f00c63119aa476d45eab174fa564f2e6151eef61990c4a1fbba05e7e4c4837cdafbf0197fb22982cfbf6f25ae64e23b529c78f31b8f7a34c6a4e0384d4f387777131918215c5c2b1b31152a891db1e3d260c88f0aaa4f8232817fcf6f107a62ba43bcea97f64887c0420d921f9d3b3035e76b5f0eef31aedfcac521833f8a5bd9b332444e82c6a6e6c1628f1f6f12f976eea4b60a862af823855e584fd025326cedf2a7c7847c95e3a880fcc981c36c61867110409eb59deb025c38039a995d849b1d614ef30c422b0f4cec124749dceb5799466e4494661477d827b5898bb7ba73ad28537a8147debd75e06b906b7f5f2a1a61d435dc32c74e1fb67a835e57b69a59f028ed8d7fef684bd5ec8b08271ca1197ee817b277aaabca32cde8cf9a6674261b8d318cca471eefd8eef0a8bf240270b226406a3348431956fc8ba51ec1472163e70e9b5150029b7b1bf12b8522ea288bccee634f63c959d1d4b350868fd186dfe5430656fd627cc1f692db93421345421af1247cb1238cfa022e13b9f9c2738ba3ee4eef008d2a6ba96467c970c6895e3eb3c4f842aa7bf65b9de09963dac366501a5298034444fb2e7ce430f4250a13343e94744ed144e7f05d6d18bbfa1c5c0156a95373068f8d7f29b318db38d40d40240b61d6e600ea1a8c4d9d2d85560ae5d1c2ccba2d9f8b7cbe59d6035c45bcbbdd1a829d4a457e286f0a312539e292902e3fc6db3ecdcafb3e8c09cfe754a76055b3318a8cd24d08068793b0dd21683ccdd7f027712b6fe2507aab11ad21aa03129bf554407eb7856f40a72122580147883152bea448679f6c2d9373d3216cc78d48c6a3867a2467579622a3592536df0ab8aa4c028ea6aae2076c12b9066b96e6e900bcd3a75ac7c8833c4a3372a1e43dfa7a6b24f8d0abeb0d67edc4e818dd8d2026ac8cbb31147ab22598f3ef1f9d87e5c5d8053c78f0607fe2a3ef331d9c43b3ea3a558831d5bdbea267526fd2949c5437051db1ab7643d4bc5d4e931344454d1638949c37c53d45428e668c931d5f1f980382951ab7f636c8d950bd0948537d20831cb18ecfaf93f3ed233eb61fb37b1a6fc9763e7813140bf271cea409432804aa565bc5cead3b1f61581d748b3ba008151f057829a2a2af4cb9b3c890a8e476a9a4838c237d91d4ce23d29dcf77e1153c314caf7bf6b722326aaa384b517789e0b0bad0ce0d0c21d530250c41d954335081a6e38cf67cea6b1d74ba210232dc543067a5c6dab2fdb5a14fb13c2ea0879c39c822f443df10e020d3e795b95e88ed1af4bcb1769dcf2f5f4bbc3a75e4e5c87010c6cbffa2c8759e5d75565f46ef5e0fea4f17cccb7019cdfc2eae68c665faa6d5f75ab4c0c88e2ffa3e03a73b6c2e00c2d57c46a96760916f776e2d482a366a173a5db6f5a49b63c596f8a917a885dd34a9d78d78592f3fa22a6086359a1661a15ac08267137e4d936bdcdafaaf2999189baddbfc667482f1077121ada2d1de7f8f8c1b168d1ae5849d03eb91949e153389eb1b5c01f2aac046d0452662e69a6a76833774f1c499aa7abb268094f41ece134568f27c421446f1e9f28eb8b549a6cfdfed88812699a5cf617b67bbce607d0c3f46e8998ae22c066c98d8309234bc9e479a6dbd6488d930fced58e18739445cc222139ceaba2ab3ab170b7c087337157019398f376dc9ac665ce79096ffcf96c045a1a5e3bd45d60325c1092c563c91ec4c977dc62638b6a02afa287b1bc21da6972d41a094591184f3a9c8ced482654609f0050ea515b05f538ff23cbcb2cb3addbd1128f10890b58e51f6dca4e88e922000721917ba1afb865f87ba78663ccfeeb26d70e787d0a4a046a7d60f5680707c9399d5035517fd8e5d32334ffbf4933c0d275f6835d18b680ef859a4950ed30e7e8d894f9b58a4e2ca7a9a43152277a7fb9cc798fd700c182ccf024fdff8d5e85af375464d8cb7caa3f87af58221675c9a2a8b8539602198ff6d3de4f2f4fdf76456fc60b77b537fffe2e1744e820a6e3464cff347f35512b23c38d5781272f8c45551014036342e38aaab2d93c37f34332f4e78d2f0d45bcf63f3bb3614afd8fcf011f319a5ae24a39d328baffeec2bb4530447b0f6cd4612f8333bcfff9181705a0c5e68e541eaaae8b1af2c05fd0b805631c5503d89ff3b1400de42c88e66bb7cae799816fdd93f22b9db5501a4f4bebe62b279c36e691d26e418fc55c3e359a9de835ebd718a1f2f9d3aa29e656f6e544987df4d0c85c8de05a2522632ab8b8fe16481304a0a4c02cf1729e305bd0fe77b4c8f47f74c1bf8be8ef6640fa20815f660424e620bbca19b3ee6b8460d81f94bd439de4f053a42b8717e3df87d68c6876eb5e4cdda6eee4f253c3cbd88e7c86b01f25fc7039beb4655c4df8fe625b9b13c326388bf473904eb9e5552021a74c8e41d8ff049c3cb5c7f563829b9fea10d1e67a502f30b658a1d22672b256451352bf8302db878d8de7204493eb7f5b6605fbdf3e4a121e47056ecf09f5cf24638f2b71180cc82246f631bcfc0051354eb59c0c1eb0a24d03f77e87aea7b8d4a96278a77b489a080a869ffc185042f0c8e3f7ae57038b246393870abcf363e61d755ac8234c43cf3d3a29d7c10b369131eda6d1da0782e98be733abcafd95caedb170871b6a6980182d03a01d32ec91e75dfd055f1ee6bd61558c5e130eeeb45796ff354b96c2fec5da4a9f8c59c012d8cb4dc9e28a06f414bdbc5eeed45e634b9a71ccd1bf4c4b0ca4c98eb8861a0c97d63a876769060c9dde1c0425f767df57be204cde86e5ccabeaa2949629aa5aca8b4cf83980e6de07a8991e6150ef276341423b75c089c2871ebd3756c0d4f8441daf8f1c41802f4ec3a65140cc7a5db53369c21a8ba2b725c9d8af6dec8716be16a57e44db6a120e67b507ebd04ca937f0955a02f9410aec5f3bb81d817b497ce68e2987492a6a23e8cbc23d7eedfe8a7c03165f31c1643686dd4be70d57b225aaaeb3a1b4486e6eaa88737e17ee0bef62d8455c2446125fca9d6bf59ad2b6ca651b7805e8c877582a4b464c14cef2972e4864a400fac1747f805ab6a67cb7b1b2f13fb9a2bc9c783c441cc8487e85aeeed17eacc0f94b75da87ea0a779cf1b3c08e72a684e95bb700e783a113baf2c59a5b5207741d466ba3f027276241461796871e12910ab18410e8e06a92cfe7fea3928a07893681dfbadfc67d8b95940781f4636b86458f02a0fdc284cd5a723cf48d82211d6946b60478eb0ad14c6e7aef98042300becbec898be5a8350b2b13532faf8ea979dbf8c50c18acdc4c5a19c524fc576fa24270c6073e209e1cbe4dd6a157bd6bc1484c56070ced1e12bdd1769fe7687efef08e70a830185fbda8a44c28503db23aa7a36955d3eb2d53a697daa1c80cb53e1e0412f84186be8d3a425a1b8b47486b9c044dc61a7f9f902dca6d0cf2ffafb34b55419d0b75867fdf62b53b60670949d3e21f58a6a0d9a2ef89e8913c38c58c95b78da1706324f6548a1c0cb9206d6b7259be48f0108d07a77406c9069485305201ca0746f358223f5380485209855d2a86779d098d9f174c8965cfbdbb625fcd20a21b4cf23916ebc2a0222df45c19177ff92a11f795ea9c99d76353279e4a665efa11906ae4275fe936262a2945ccbbfbc6d89f8b3449bb89fcd560982ff9562a61fe45451be49c4e519429ea6bde13d04ad1df00fbc92b19a5cb65e9c553c5c37c4587a71dbaf5b05800529218c9c2aeb523e5216404863bb3143f47837540741cca81b3b445dc80541a801ea45ff926b126e28771ae01506c978c5ef7e6b471b5018cd4d29da5a538807dacf55c18fa145e2959cc3bde330dd597efae403acfe9665163cdd75c67f8ae1f568d7a44efaee0867ad56ff776559597b8e570f90b30c2a5bb626be888dccb409c8f0c1a2ba225c7dde061f0e554ce92796dfafc743fdca2db03badc828e0427857e515e2ea48a2bead458f8ad49bc90683cdf022d818ddf58783a7a0412e9c5a35d520a900b262612d6c9f91d386c5624bd3cab08860e080283c2c8e8bdb5871b5e223e7f84b997be9b71024ef19716347e8090b35b8aed88bf480e7b0168d0e5dc12ab2a6df44ec14e15dc8e05e9553519d5740600e3fb25eee6ebbb9705c0b657d7da31be3e673fb51e6b388f7401754dd75c030773b67117db82860f5abeae8b822453dc169499f1b6c7e50a4bad5da3b83860565247da1f90dc04e4f909ebec345b817d06c6f14cd6548cf8c2314b105aad504fcc9651f2262feadaf4eb1df3a85f96381a17142652ebc22251dc09ccd43bfc65b66d394de459b0eff688263997099ba9ae987f53e593f214367fab7449c8868a8e525bb745d7d5294ef9a2e45e9ef29d49aa033828da06f955737d7de0f8c37dcca9ded99948732bac38c31fd4cd5f359757739c29c290b2054f27316d05825bccecb16877f4176e6f393a3b90907feecd3229095c2d77ced81f5499657a11492c4e25eb0619b15c02a027257f327308122805012042d37097f650c5b3ab15c60d430e916e9660117d86dcfbfe8a863e517fd63fb975fc617ed1d8ee2be18da16b01cf7fe5a2e46f9cdebf951908c8e37d0d5d574e1ee149c4c38acd8295e7d72804b49212426ba9c66d020e823","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
