<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"13d6169008525d913c0b0f2a7297d152bcecd7d1fbc73e46c3df34cd7f7c2558903abf45174ed453135eb4df043c2778fa1a511ce681fb5d4c9d393ccf5add096bc1cbd72991170e09059e2032a0eaec876a07d5962ee5baa09385b6fd5057f09b2860b992da639eaabbc555b93045877712d601f3f0b6bd9a364b81d29c8a0f948e04be747829cc4f47ea39be73df66e20c7c821fdb4e97f6cf8c67afa768b58dde96dac95a445c612bbcc3414ab1cbc3b3b9f4925310b270ff9678731c17433919881db2005c51231629cf4c048dda6076e9c55789d44b3fb08d9528b1f66b0eb3d228797c72b01c3b133a6d43270dc289e3a072701b9df5f76c881afa8bb396f91dbed20e398108c0427cc65879fa363dc65ef199e5ae61e3f885364ca4064c911db19b7a62229a330f209ace257ab8fdba382710a1b10919aab4095ba2bab7351e88be3732a0721951466dfa93837c8a9d07005b0a37f96de753dc836dbce32112b7ac3b00dd3bf7e5e22a18924762a39b781f3bb8283de03e346979012d0742160c6e162bacd06ddb0f8d6aa5b50ce19fb125bd11f73b65a242c817851e35451eb4d3b17a0d8d4226bbf887bc3a58a97d79c3cce3bbc20e8f72bd6eecbf84043ecaff84aedb150197942707c35962dc8082a828e29ebd7b323a269558ca173579de011bb2c38b87752312d2d9ac982a37ccf3f970250a36fc61fb0d369746def11352e7557bb412148037e8a145880a7dda23860fd44acca30ba4d6116b11a088b2b2c653125cd6b82c8e4fc4465016d9930e38606b9a55cf52473959eb1277865861b8ecab4b0efd49b113cdaff143acb71483f43d0f21dba2a4e2e207a1c5c7fd6c83a636b30545b99f0373598c187dc9eb8fe480f3fc24567dfd3c1c50fb00b26902ea79b203707a03bfdbec0012f6cc712958f2393a5fd767b17303e91f6f1d84324e08a50730c66ed9274820d50fd77daaf39e18b4c16d8fc9144248411b81912435a00aad881ed827147c2e15a06cdae541dc058dd19a69c4d4dd57c158d889b5a133bbb3aa8e9d3f03342dd81ab4abc70d47ff46e16578292abeb4c715ec3f619419fb9bdeb223adf8fe6f98c146d402ff096d3f8711d4de92bc405a2dc326111b3431319af28e8f8c2938190224ac75a78a95351e45a052854736501ed79fb15e5632a3980264fdc64e6b9a4e64de5fbf03b1aee43e5dabe712deba820ce7332e0bd1add0fef433ab5cedeb94b94aabd2d7cb2deda2ed3372fdb2ccd86f8c38072592697e5e369f18d1bfdff8e56c027bf644388273a7e920c9ab3159f08d681d26d3c68ae95492fbba342417cef18b6319d23c2b1cd801ecbcf4ec75bc80ca645b80f81e0f3ede3a38c82f20c30cabf888ee05478c90643a2d129acab9de1f0163fd3041a383ed9dc112ae0ef6cf48a201f79f618e84543c925a342761a37a57582cdb8d8325e99dd59365f2148ecca68c5fff8995e70bdef58032334b813b0164eb6e060912a66aaf7b76c635aa1eae1b2abe36e225535febe9947dc60adbbda25ffbe69faf10b68bbb8615d89b45528c980c621db03f8705d763379c8eb2981205b50352bb1f53ecb0dd4374e13020935dfcc5c7bfc1e467e262b4551e06db1b4b1a29d07e272a5f001e9f2cde1bf0f03239dff13420b01d6a5bc1bbba6dd0f9f9d0fd1c5575c5f424e66964b9f777b16446dfdb3d032fc8d83996f1ecf1bede87fdd23ef3e1d96cd9ba24bca082d77771a2fcb7b33ce76d6d176a31e8e6bd29b198f46550c5f4b4627f3b33c11e02aeb3712d4c9a47f2af7440ce3302a542482d51443e2c12955702c343262b181d1899b5c88b10ad69584510a73cffc9662907e3d05d50ccd3b17a744372ad94b11f76354f32f9cc774a2f0f7430a971bba765a10a7a9cc20e9ac56c5bdcdba8f653ee765d0f4baa7709e9828bac30baeac3427197f776de5949af55e9e856cbaadcf0cba7d9a3cd5ef6dabd1697b15a176b980ab919e529ec69ddce4670319720cbeebf9e787f170ea7404da0e91ab661f46bb727e122692e4651dc69ecb75ec161a32042f1476373cb15b77ea74a75dafc099f160f0e0bc0f26e0025fc4f5bfb4acdf78292b98af0f0bb955d3259558ea7ec69e7bb107cee611b55217c5b56682e554c69c1aff4ec9ea5adfa7e23ac5998042b4c4d0b9ff574e88a539495f423b3552d9799a427420af3fdabe4b0db129100130154d2c91e1295d44424fcf65ba95186e60166882b151c9271d1decad1163bc867b68ada0dbe7e9a4b727d1c9b711a82dfdfb8904bcd017e316f7d73b1f01ba24765c3e5d79bc23b0ecf133437fde96cb9363827824ce409aa7247c96d022d27a18a289b4feae45d1d1bf1a268d20b3c694caca88ae7636db6ad162deb1be88fb108987719be9b941800a0f4d6c048fa40132c990924fdf8ac175a508de844da8a22aff0ea75efd67997de366522e8d6e18130be02acbe2dd13c2772a3970e00cb123da1426cf477f64769538a5814c4a2b986b1e37fa3ca4b87c8ac8a6980dcf138f97725ea141e760a699c676978739dd6b35b155fac884583dc1391cd01fbcd62882cb9f4ba860cebfea00f7ca9d47a4f9f9b73975674d8aafc83aa985d09543d490580cd0bfa96c1e8ecc375be0303d76bf35f1ccf354a459abe97914f65b4bebdc5ba043d7753de0689b73e615dd7eb8cf639eb6c250d3cf1e8d565eb7729d8e26d8d5a01b1fabc2b867c0537e8712248ffa7ee81a1c0f0d874dfe280105f2ab19998437f2d7159fe163113651333fda622cf3cbf7e7942ea8134608d7892a0e226c635173e4caf33897c315cabdc55e6f22ce25b99516d736f489d2ac6f26d56bbd235ecec778cf288caeeb160bb2e20bc3eb9b7c96714c47b436f8ab635087b97e33ecb5388e48c417266427a3be9f03ad0ab522c1d30f14fb98dd6d307452ea0fe54518aa6b04c57b7a07aa9e7b0f7cf2989306858c07b196ff9dba21f54b6185cad0d70f34c431e78308fb6141012abd42c46498cfe8d260b35bdd31c07a30a3458e033b28e2e3b8415fa28fb3b5cd7b296cc2f349482e48f5145dc2a95a7dc2c5f2beed104d5306324dcffdf47613e00e363abf7fcb2af22abaf4bc72030af5d6ae9dd1bd2388350d41e0e08456f8f1d88a75377f9e1f2e459602f80ea31fad90a7194d9f1489cae3b6e180116ef461fd0c5d6486857ba63e283754fd1fa9ce5777bd76afaef44bca2309abbf125f1d26d24ed75a208ef1aa3251e583c97bafe0587564901f54b5aaa0f8b0f8b57108878cd41f59e3a90183dc70e3f0fcb2c42420587ecbfc8c333228fe0d2e56ce3a645a5cb9cc5ce9b2460a0ac5341c70f798aa5a6a6b07ff50c1112a41cb9b2953aa19cab4ff190e4f873fdec0b43fab8d3986c9474f071be5ab72538ff3f0bcd1364b0b85bc6ed97d1237b402f6dae24fb96056499859f3551d85ed6afe3e119f3c40885655e69f843235a12119631895cd937369946de0b20e92eea58d63a879635d54133c22b8db4326f02da36e6b1899ef468e59dbe7ee3385eda0069a820a0bb9ff940d7ce23b1181808ac1c00f9e44c310a5d4553d2c54debd914c492f2497d3a6ef9140af124300a648303cf8e7826b1d15ce756784a5d5fecf2e04798348cc0bf52bca184f4d6610782b7c70c02b58409b970170c73cec770f3192b6af4c49c10a201501a109f4234def1342c3865a3a401e6728af44434278e5afb0c7bf87ad4ff483860e6507944a7b2d7748c9f4e389644c99b8c0ad1a74d2e5e506cba273de6f1b2425589a34b1f840318a48109125d31419e98b17dfae3b76f3596f139e54df5e448dd1db2d5877b5872ff00a8d8eecb43d457c48b3f1c72ddd98a7e45992ce379054be84c9baa9543e9fc103fc9d39ea24de0d8a91de5cf1437c58e43136382b899c04822eccaec69ae3f0d3bcbb2e8f95288e166486cb1d7726614eec820d774e23bf3a1c2b4d1b690fb50acdae47963ebc275eaac7609bed0466b2b1dfc1651bcb54f3bb334f06c1228fcb429731a9bbec3356c903216142288ae0231159fed24ed26d663e016a1f971110cbcaf4112757d9d7adbba96cb19a00f717971f5f76bcf92c74db7bdf9bc5eb5fba7c984f017df1d1efe9f7fa36aa6843f79a400e3a9ff3ecba23e5fb84443e79ab4696949c4c6370bf01c34b7838d7e580c184c3099d7e29a974419736de6f268d93d9308739824e6d4a3b6da408b212bf93ec63b3eddbd7f1790b5284949d507929ccb9d1c3c23e780aa9eba1f2605aac9102fd9991cbd359c56f7b7100c65b945f6998d08b89992a916262c205cf2466f5543e68980bc1f4b57b104fcb42698f6c547fe2940d6d1fd1adcec33bd0bf7e1878adf4a640943c92080c07606d0bfc5d3559bd62657cb7f76c34cbd92a9250cc87af29cf2dbf52785a33e2a703a1b3b9438d19086cca69c0a1ea8ee4ea0de8086c35d744f6277305872a0032426be104bd92c9892342a7eb0ce2f0c6d89e641e2faf97b5291ec40cf2259a049a1c14c1186a60827af1c3849355877942034af08c50296816219a14cfc332021f634202a872de4fd379a89d4465895342d68873defade610e92b3033a3d22ea6145003863fbe56446b69acad6a72529083e4a77df083851d71d53e468377aaf7a30142cd904119e13cbd9c5ee2f4b4455fc79ff36584aa92878c69b6b4930119c04b63e02d0438be5d7e68fa4b1931585f586422084cfb944c1e37455b779be8a2623584e769a458786fef259cd57f641df299259a77dccad11a77a91681f0cc28dacc51b4e2535e4ddaff9e544d1406dcb42d8a344a0f00b5fe259a301cde72f1bc13f79afad2b9d2fb8f721d5c3914d797261a7a2b87ad3dd6922cc3d1dae055dab4957858c2f6b7cd9763967e54f07c00a013e1ecf60c366725caeaecddf58aa5e95bb93d043868c525f9bd28dcc367ad5e00f44d61f95b349323cbde5d4e9c8acc55e8fe5b329ff3b62c52f2d36cf4a8763c1937351ef6c6eac91d35dfe3ca5f479a5d2b06207b5a8a7d9c13e0b6e1cb919228341a9d7dde7b33e95a76f513a91833fa9b2994b76c3dc93ddb1cfabef8e21e607de5934ac170c0425cefbfeab8876278cb596fbef5e26fe95ae55b429c346112078c5a85b2733aab5f4a43bad327d62fc1616dc061aa0b0349b9c2879fe6ad540753b19b421d73cd91b988b0062e5960aed1f7f9c6baba75fd0386dff9cc30a8a3ea6ff8badd34629cebf9780a79df5bd1539147af968a08a9edca13f580c832e990354c836f5d305ef72cca583d495bf5ec270bda4571fccd79300f414ca77a62fb0b32e95b80bc881272314e73ff72cea59348ef757d592bc932baca0904b0964a87ad02e1ea2a5b989c629a6ea0f1e9805d40d14ba278afb66e4f82b3bd61dcaab8e48e11349c95b46f70c59c73572f3eccf12fcee400bc016f1e5f263861b7900cfc211d4ca1a2cf06a35396a00a97849c8a88788bff9ffcce32f39c3c517c257b94cd27bc3db5a61de7ca6c6b4d097a65d8693f7672dec2d5ff0ad1bce5a432be82bde485935b2cc57fa705fe5c6eee088ef5c4301c142d722b9f54590310a205f787f64c457d70399fd43d1ce943b306fdf69c8013e6935135af3888198e31ea54e4b9e16d46e056220686c70140aa46be1025ae2fde19c7639e2550963b664c99852ea490c8f9cc871c66a86246c23bf220fb741c6db6291586d6a6863c608065d38cd25ef4af27576b4d05c87aaa166896ddf6201dda8af463de52feac6f96482a7aa2840b94e152b65036664349c3ea7f8f7f8d5819f5814f3e5e455c273a304251b90e268a063a1a47f4d1a0229c49f8fbc8f3e76a3a4b93da0f2dcb2ce5ec799e50db8190da9d2fccc12c50c0af145e8db9e8fb441e824ed0250164947ab79a3c74aaee120ec2418641b56a63332d7ae079dcc5e965a71f7072282a9e2d65fc2b1ceb6f63de78e70242b62e73dc9ec0a4291e2cdbdde31c9e341ec9aef92826083f24506eb3f424fa91261cde586e9c537b4d6a272309af49187c492205ca222b56ca54a0896c7b8e4490987e05fb055a00a515eefe0297ade6b94a6402546bd24beeaec0e26d27b4b4dc5cd5f09623d349aedbea6c35d1e2c0e936c73977c5e9c541596456375f17fe1bac004c3d94e9baac60b3e281034a9e2739698705266fdb0915ca856a660400b4afbcd330082297b544b081c21f62d4f291110228773d70d692f864e2dbe1a6fef2b5816c0b9f4880642d178f5c0c1550a8066a8a7ebe9ab6dd7b53404d05f88cc633f2ffd91a78f5c3dd09ca7f647764e9a08f4485ef40e2803625ee9eb06702cc9b33d1072eef487697202ad78a5f45b6fc5086bf2e9125091e4840f5a0f38fd1e5138c48c824695f3fbac3ae68e65854b016f886a2370595d29779dae0b73c6f721bf5d6b1e2ec60a7c4182f85251e0a47eb5a2f7173391c3ee4136d4ff572a2a785e98e0eaea2d45e6cf1550d9b8a4001174f0c8d8606721bf8e6fbc0629fd8ab59967c11e4ce1fb18df0b01e3fef2010d2d4da3d6d951a66ac4758b42cd0932a821525f0ceaf139aa09bc3f17afbb20d3e39bc2d8ef9582dec16f3ce4093b9ebd76356170b46c19d2c2fbc3d31f6fe655e4fc73f2e7498cfefe961a7a057a8757c53f8d80d7a3edf5cde4b6a9ba72bb74f0fccffa71f1e0f8c40166cf979ce19b63988ba32317beedefcb81d73c64d0b76c67b44a95efd6e3ec88b6b6431fc3d68a8ddf828bf3b2a99622f1d273618144b6ad96f8948f8fba717f53c51a52c6a89562127188d7dc685290f53a72d4135465f0fae948d749ac6ac871f0027a81537544fd64d73f2cc4f97b8dc60a7ebf0e9c8fdb32c6c86653805c61e1535003a1df7b4ea543ec2d2e96714c1c64d6e88be7d80da86f4dbace78093a94642eff479ce295b131629678d8a0389380954ed65e3c68e40d0ab5d8f3208cda2d9160b49ee33afc5c26ca030873b56a8ad1f6623ccc8aa1a561950429c967f3805821f1ec4b6d7aa87e702ee3e91fd2372494f1c5dca786f9e719423fcdadc5eb3f7049d73a95fe3caf213fa5479300e4fdc2dbec31f0f761e1f9826f0cefef984c6c7552ef4a78d50fe9b693931220bab8da6dc8d79baf70bc4c1044d094b3092ed7e836ee2f557bbd2249b5cef845ef898705564dc5233d44e180480878b5bdcc845a9f7ad965ec2431dd90bddf1564f29b36863e22ff8f27640465d2971460be82dc89af5e14bc8c65ab85893f345a8ef65dfc327a9f50776519841cc7994e52d81ba7da319d14b648782f6d297b6e14080a79078be4d73cb906d6e7687e795564d6fb463fa379b1b0d8afa4029b1098eea8861b4c62871fce2c5804802d868807fedd54340cc3cc85cc4cf9ee816a76d2a1357bc76038f941aea30d79f6281a7c89f8963289a5c0c6cbeddb753b6a6728c1b8a12070bcba15472f10b714736b2c0cade0def5055ccb4c81580c33b4588092731e1f0be80b5a1d7be961fc850686d4e39313afd6797d4cafac69d47bfa74a8a91ba159bcba5d74b0a18e1f01c8cee7ac4c75ae9ed608ea1a67b6a58a0ca3cc43755857b01651a4c81725ef594e50160bcf85848d43663d9fdac0eac74775ef0b8461e14a4b44bb3f110debf836f033f13ed305683e0660260fb8fc3872a2eb273bb0ea98ffaa35578ae9c9364ce54a45f36a4b4399892c46f0c9667b90cf1babce931d6e804790541f8fde67e628b3000de82b2e0c9cee5b24d35233fa082d2135f4db929203905b32fab22b807cba37eddd096d6e32f8f6ff10d898f6a383c53f4460e1c17a529326a9385db7bb4e157d69ca1282a8322d24a9cc540939e3f0ef4ddb8367588a85fb786e66f427413ec6cc5e3fa89185eb3adbfeb638687571252e7ac1f8a7912a00f85e15730ecc9748cb7fc8c94b77282c8ad0b6a6e2fd3f909580ec31b02d77dd78381e4c7b65369b7fa105fca596117feab9f31edb6e49caf43963c074b99a6c16f88e76ae99fe56a0b96a9a8a338bd5a697d0d7c108cc968ee73c0598de1806fec0260143db5c6759561c3eaa45c08d92970c9df2c839b0526330cdfa2692aff19b38d76ac69ef1ef291e4f7d850d877eb9d22010ea122b4ba49ba171e6d97ca4ccbc73b942d9ff18bd3c73ac90d14b88f634d9effb4d308e07e689dff2b7f8002b42f89d786a2c10caffd1bd69dde804c0adb0950aef2bbb32c9a4e82f5db1ca77d2c3fa5ce80077b5100ae2cbaf0da0e859f8aa49c5ef26be75be6f7c68641e21a12740389772d5b194fbb6f51e6fa11777b09b07daf35d0845962830b7492407dd4715034af5d289106d93d9915474c6b6fc3d02408751e6e4bab2a1610f2f17d71e367c8bed2d2b665758da10e48a562355a078ec575c34a0dfea30840aff41c9a309470ef98a74f84a1839c4244a56875af1860cae700ea423ccb62ab2ab336d2046acb709a1f30ec29620f187c4f0ea573294b2f9492385e6ec4e32660d4765445b4adcaed3a5ef7e9325fd3478f85ab7f8c8fa9027505ac3b8420bc942d6be480848ad1a7a3c54a4ebcf565f962bce8377ddc1e02027c67204f6348db464796cabd8e1aba615fcca4a780b98c867bb3a4dd8ffb48857da9398f09dc2ee64da2d2de07ae5b9e78548b66e75a82cf9afd73547d1c45d03d9d21750c5e5e42fa5758f944a3f63b4d5a205fe342f0e115215a9980a86a5403a8267b1e8d9f85f114b0155e4f0f6c993a848c80571cfe5c60f7d061ec3d55d4ea25afb69dca383d6b486dcda9b56cf6b8fe6a45c85892ae0962cc8b2b1e1a370abdcac81c76ace4e428f27c86f46b903ecb0298a524e8b97eb2964affc8093c12198262b24a868b4fba76d1ff5eb2a94c071f1b058d7d95eec95ea5ba318cf2692cb7ba5cf5a2c1c388e7e77e683f0020dc7d59a7ec298eb3e3a609747e7df7641ea32ca95f9b9a1ff7279d7306874ca3082ef8fa093962188c583985271073f7ca4e869c45cb2787fb3f1639878fc179f2d33fc8f3e690ce534cf48770fa8880457fc1b8335f255f7375c548d815a49ca1189fbce10cef708c4b01ea1d6d415c18014279de3942c6b1cd7bb1e2ab8aa6f559170485a68eafbf754f77ba011179d4dfa82ffa3d29657ad0dbd40cdc3cdbc1a8097d71e8a7baef6b333f8993b775c9d866c07f60f35d628be3600bc450784aaa823c88c1210cf01554531cba6c708db2c29fbd5e4408fdbd4c52e82aa73edc40aa139eb3b3f58ea9eef1979801fd5cdea2cf1c60f3b5edb1d6b825b8a9a747afaf58895f71989e7667ea5b05798a8477930bf6769dfbc7c1d8a26fc10a78edad75ac0bcb8f0ef37e90b5692ecb29d076736bac490d45d0e162caf3f1977b4874bf3e9a289d4829efd236f662ba6186345e57e15033976a190396b0ccf79ad45f1d605089b014abbfafe54f55e4e7222c7572ca0a8a7e49a37d6aa50d0fe2ca4de48a13d94ff9e180c48c70ff561209aceb17c93b1207189c758d5586d0e460dae8bedc41ad70197879af3356fbdc5aa84e45788706b728f63ff73d1af43d81c1f97a6d52550c925fdcc43b9504bf2ebb9351ca4cbac38bdd83bc40608b68d2ff571ec8d2cf777117b8fd4381d93a0f66e7877cde181ae69c1069da0ad0839ad1d4b4cb2891021a5e5a8e1e87bb711f107cb219094a58789905eecaef158dbd17cc3d6e5c2666a1c81b92863ecfdbcc7f446318a964b32a813ac4c1f510e9d03197bb56ff4989d859c47148d1519f6786cbed6db05a7c03b74ccde916fe540ec60b2d9b24589cd35d3586ef29d9b0be138edde08a8574397694482bf2f245b2f3114ee7c0603afe45979c35a04a226d16944dab1efba2d2cddd6ea0b3466effbba259314efe7619882efaa23a92fb06b2af0d4e27a68a825b0b59f36b3d84c1d84fb7e420ab140dc7ac61a4445bc3cb7cf147c12a6614f4a4176908e9790da2b12da33cfd1513f54fda054c0e0566b0ddccf74aca898792086b2f90425e25269e714a3f0c86862ad76244d2b8de3fada02d84449f11f74ab7ddddd926f307eede8be304c6fb49c341e7a22b28d4647111c4285aea2325663ae47c60e5f4ded2efebb393d2c7df96fefc6589b0f37630b5a3909509a77336e5d2e9c3618889a2f1229e172f402ff206ca4d7607c83cce0548cbccd665ea8508078fac0bfec5c1ab68319a97b4c21d921081a92a6c93a2aa69a70ab2e28da7a8f39773c93d0c93a9dd51a34940c7830f78b8e6d8b83e083c3f26220866c55ae685cf90e7474d0dd00b4200b2c0144e809df38863aebba3fad44d2483aae7fac2b160aa371e8f5e58dabbc3202ab4a96fc4d837f2e3c82991d0c56ed29ca25516d9ba9d63d3b9baa7379309778266cbdf28c6daf09d9f3391757523af40dc82e0bac748688b8ef5cab2cf350334d6e7fb21e5970f304ff458d55b0cea09e61732c1cf61cb27c80e9cc27b6e18cd4dc8836c2bdd278e75c8ada62f5cb53749db9e73520060dab34dc2c72fd86dd67a00d68baa5766a40ab1e3b7461eb5de8ec0b412bb7c551de61539ad4b87655156a00c5895605b72615d3bb6401db06815f9d90f7d5417a40aa6f45f731607bffb755f13e6a1564481d998a4611cdf223f021191d6cc565da5a09ae45b4492bad56511a97f2c47b9ac5b9d9339721b71dc1bee6a4df7085dc000f41f68f0ad46d913834a17a7afa5ba75dac949be8840c8c17e63ce02837c1d5d0a3ef824063410afff09d7b46f72d8e86f17809559b07350944ae350f5e6733665d00bfacba66782a0326c12694bbcc992aca9c6f1223253170d9a6b834ed07a477e06efd570dd7b64e1195192e0a41213e3c8013c312768a24944f620c5255db0223b66479234d19b47af24f801304314cf56387afc0157db4e0db529c5e63a586858de1b8fa01aaa49a91524ca33897eedad2971c0ad07d2c55ed6bd8f1525d0817feb3f83087d6bf23449326a0a5a2bbe02a693fc62b67613ce0c4808c0c457a850aabed7ce23898b228cfb6f782dea764f6dcf9d90399215a3df37387b523441ad911e04df3ee82ab5e77d6f1eb1ceac485c818d9c5459a5ea294fc7c35026424fe87e6fcff91f10996f9d304232ff588e7fb88ed7b12a4835838bd3b856c888942c83940a49da2043a42a597eb48e780193fad48e361953710e8985203535cfde030cc26a5267538886952c56c332caa961ccb7d1ea5c46dc589e932f2736920fcfbd688415b8d59c2e776167b61debc806e950a0c44c4eef5c6b7f0e51f3006a4778a82900864a20f0a33f75dd46660dba9b9dc871a5a9b0b3fe31646053234c9b14bd39fde945ebbd9c4df92ec1c619977788434d354d77e31138175e1627331affe0fb0fcf15d5fffb7a875bb32abb8a1839dcc85cb7ab408eab9248d20d3d099971287fee15f07a050f522e730112a70bee6d8d6f2c6a7a80a873efb7f9da5d5fc8b25db0c28889838d917719a2e30d7648df6b7d024c0435757adfb9163e2f6d0259e8a94cf56c0daff08b447db4f7c561df305547843da1e59a2964b504713726374d0716b355f3ba50568c89771ad2a5ae6015f04ce7be44751a537218973e39de9a3a3f8be08b8b5ee116e3ec0859db5b16c4f538bcf86e148e6c9d3eb2ac0be38325248edf1e4886c562d6bc0762cb02eb4f375020c566a23c5d5163b85cb33b2c0b29798142445ab78954135cafb160066cb286399f71951a9d3ff5c9bc6b4a705a9e8ad5556c39b679016aa5276bb38de84fa840fe659a34639a4405b8fd4d6837a6f904f3b346af2ebb8795b4ce115b94fdc07fd0c6887a4b1e534140946fe76c30f319f480fb2c8957bdbfa03dc355df165c3ebb4beed1e6e20c2fc0052c819dade4524a8a40be0286f30d771f69059c4cc95fd1e87f33c17c6db56c772f44462725e7d44ddffa4c3cb66afcc51f8056e85f1ff9524d010086b00217927342fd053cb9c04f1a7f34f29cd224ff0545fcd968b12c8dfbbd9de5261d5eba4439ce79265ae32fae624dd4b9a21fa05a6ca3fe7e40d6ed1db5cf5a340397fa52d4762aa4a92972c823b515f13b8b758235ba6c46a2f79635d57d20e5083400dd35a8dc28e5d5644c6ae6b1f2b36edc1af35da5f049bcbcdd595b732612236c0c357cafd4f4fc90ce4fcfd18cff0a1be996d39f2c678e315c941e6eba7f59b369a4c8d1bc59744b3aa9414889373992444cd40b4c06b824128389c6ca958a0e0c52cccc20bd3a9ef2979fd90eb62dcb3339c7765f076003bfa565a536caf0b8aaad3bb5d1b4ab021816ea9372592daf87d1cee149962ec1ab5c0d0fd0dd15d031447e849bc599dbeb8ba6b07c203ebbe739e41e3ad5af1c1d71f5a6697c28f41a45726e6f3a52cb2d0169acc0127bfe1e33a38d0e7d21a1b27695378faa3dbe75697dcaac5f9204e9844c601b9d471f80190180485ff5346311dee7c932f9e7bdb717256846a81879e85ac9f2cc777c57e4c8b8cc760c94cf7c92ce46f075a18a805b47594c5553f77a900f33c2c637b1a430e724221d8a0c34b96a73f6b310870ec66e9f1f03472f022624a2199ff9bdde387f7cc05cff007b6f5add5a8e98aadca28782cdc3c687b560266b5385a1b3aa19036c7979e7edc20a0750113606261e457fbb04ff06e3bfaddc4325763f0ea09d726d27eef9bce4ada5462667115dd5cc7932e0487c32bd534160635c74d222a5f64c154649e8c38a23d40d085f6da8dec69016fc5db8c78383b023fa6fb69dc4449542f16999fa552af8357acf0a9e847264668a8ce38930c84943f99944f5f036a229ca617613eab79c0a3d6eb378382dfcd8aa423715c2aabea5c95fad907180229be43f0b2a1d2d393e891d3dd84635fad444952a4dac2eb6efba18ab6c09fbc7e87615d62442f6f2cf33303d9a9fd8a4b0286093e02f0ec10e07f44b99aa81bc18d7d4bad88ad5393c2961fefd508677d9120d6996dc15575f3f3df73541fa1ae6a081b7b67016521d311e291c909a6986e4f26e0828eb3ddccf41b1c2dca4bdc77372299a30df16516e750f51e471468c8409f56a8a1976170160a4b01caeedaf2ee199fe02e4aa6e2b5a803d8cd579ef04362723e02461c32dcde8883655299d3455bd20766ea4997830b8c5193c1066bc31cb362d50a024005965044fc47196479371a968d9d69b3aabceee4d8867032904a9da21d760cb0a33f258eede4a5b45cb6e9abd2ae7cfe0de88438f76c3809d69d700a109515877302e3272b59d18fd6a219939eca30f4bdf21703fe130cf2ccb0661d8a5682166bb4e2d8d95dcba424bf1f800aa4e2c11d7f44cef9542e766fc1ac19fab120f6a08e38f7269c0a95e0475699ecaee8226374385cd6b80c9906a0f285829e2504a8ac42f2dcea1bed944b25760f45d5a7d547fc3a431690ae7bd020d28eaed61057e8cc6697442645fd2d183d167055b146739327d023810c8e75f18187c7896d20ee6ab2a09e93602fc27c9a708be57185c3f259b1d636233cb02d8cf31bcba3457f47755d3c4711877d7f2fb310114615f2a4adc16f4cbdec73b1e4dc5aafc9085bc5b133f18e0d33ebac91b3fa904543a69df2f0f11b9a62e993431a2330932e3d7ee74f5040713bda1936d268605c46a5823e8be8a1d1bc7f0799602dc4ca037d65bb130409038ae8883c97bfc0428746a1f170b246127048bc4d8a0776d935ff57b158c1098cce53b3b77b0bd6597c3af376d3e86a18c2e33cab58325aabf1176469e80a7ee36758d50ad7f0ac042b7173b0a527d594122788acfa6bc817c5123f739a02b07b1fa84d11e5469e5f13727f409f7aa5dc81b14fdaebba972af2cec41614efb9bd0cd470f9c603b53f994637cc928e899c98ea1173cf2dfbbb7164e12ce6581288bdd537d65b9c164be65b5b112e93d690fc37c12e66c656f4f7b0f59d87a7acb62da123805d9acdd8d083ae93c5aaac61da7daf35505e79b9790717c44598c4f13563e88a860c5c0d798cd2bca4dae427772e5b0f0dca278d3ea9649677ce40e3fcfbef311014792c80455a077a3dce5d0a18d4664e9e3325e04cd24c10d90ead6cc12557a7e714915e6ab5337df7b570b193b5436e264e5eff689e317a3150b90fe971ba2eda92dffba58bd600c4cde13a9e7b9c0d20bd0cc36a0ed8316acfdf10c4abb63876188c4c15f9f580f47bd3ba8c0012e1ff8684d1b085f47046126968b9775b88d57c88433f700bdedaafdf2fa07f2b75107e7c2ea51d33a2a06611c34e07f65622209e5906eb99dea90c0e55337bf7ff60bb791a2cb1bc301754241bc85f17805a3761ee858356a5df9730176146743026136c688f7f8508624d3cb08575dd8384a6d26639f1e3f2523695b60142503097de37bf422e78e8024f95e42ebb18453f01fb7a38a290d4d8a5aebc267ec4165fee583e1eba7018f98c8180d9d893106bf922ea5795eacbd81d10263b5d5365dffa54707111d745d94fee497ad79692000bddd9002f6217f3d053f9ffb96eeb2a874473107853a16422e07c6c4b6e514803a9e9310f6f4fc55ee1c717cfa48c317bab31b42eb38960890809e81597b09a721ff9f430b0390ff7c474495cd97aaf8664c965c6a26e38e19f97c83266e0e52e7f1785b54b1c9c57b1b135a77cdf15c370a2efdba397f5e7914d157ef22c206f24fa8c5d4d4c4e877eb29971e17f57c6939a10b8f8a9f8e9e00e82e9f511b7769480c338dda38ae5d081d5eedb3c3a07d3e62534cf77f52664f206e178a492fea3e0aa4bbdf5794ef796c131e137164a07fe237c4fc954f3d34a5b372b6283969a10a58d6036e0c42c8129518946b48bc3902d072c6c1e2a0dc0cd94501c66746fc5380d0d887eeb14cf462e22368a9fe4dbc98d881986b85a29459d15d53f36520827b77bf7426655e3d655600b1243a6344eda2ad658ed7cf78b2574a0099dababe5c7ffe095bf2072a8e611d70a810c6ed0472436d140364e4be3f38a4bce340767a63267b03ee4243fb72afc38930b292b919d6e4870af4c78eabe6e29e3ca8476b14b6f5abec3eff4af357d45b89c59b6fff9f3b4b09ccd29b552c3fa690825568ca9c78e36c761b415497535325693de5250eee602abda31d358d01313707011d354ca5a1d86f95851f409c253951f5de75b1465a540c2b3b7fbceffbb2c16e23cc4edb446de2dbe42b5fcac4354951be1513c519517dd1108d9dae834cdc3c9bf2ef790da794d2e1c8f5317a9f3461f20b4ee54ba2b9421b151b08c74849f93ee891f9268b3ebb883c856d01bd743ccac1a54d686a40a928bd9f0484b69bd25a7f7cc55271d058abad030be3717d60bfb4cb7658ed000def955a58d01f55eb31cb533c30917c41450ebddcd01f4bb170b8cc182136b0381a3d3b32486fa03cf54e383775d93c440e98fe9c41b725728eee0da63437436759745c773fb603a41f0eb4b8e6e0a83758f2b0e478beaaf0a6b73e56bcbf03d54636cf638336384e9ed0a839ed1cd98c76b529b15bb0f31ddad1270ad4974727a753403c57915a070f5073c8690b9c84cf26ab5728ecb609111bdf3cf0148c0985c562f6c43729c59316e6234154217e225835942fe3f27a03a55930a83b7c20f219d66547a2bcbafb7432901800cfb8df5a243554ab622f1c84f1971f7c117163b2f0d265a82c8f2d939261ff2524d5455f45d0895b59cef51c68c6c4206c9f6861a582ea9003b07daf722b82ca67092e9a519ace79fc6ee1f8e2d45051837bd0ccde625a56bd0d0c8a457dc72467f773806d1cdccf737e8d9518e0d42408db4201bf6412bd007e14116d3fe5abe632c9f35ec30c612f1b400d84809589d2292cbca4177de5acb572511d3cf2291718536a9fdd0ac1ded77d6d34951d7bddabf490b26382658957061987b6d99d29b4e64b06d6f2676851148990c3bdcb3b64f358597aaf4bc9748e80428593608de0503c7c5d371d737dd08b6d7c3cabf918d0bf69bfb2fdc8be441e614b02b4e6d19d92c5f209fb79c683ab7dd48f1a54d56cd351874999df080edb23cdae7ad1183eebc81bee3c4c0e45216827a9868932f20bb3a674169c3b048effecf60e26551035123b58d3324a3263b39e624fe6b2aae6537618cb55ef021981e0a52de08d7d0267808d8a976c2d9e74dba42e2958a4ec65deb92670bf9504874614bb30eb57379c276b032a8d6ddf407946acde4827bab882d7e8e3c52e50edb13ffc538b3bfe13c15bfc4b527b7e07c9dad3790a4a7680b25d08b9109581540ce48134adf9018d16f8b761b86748fc4c70f0ca0bc5ffa95442abd6b25f4e5c36a11449f676457a715d8ec860f29cffa876f8371227dafd21c143fd8a0592ac8aba9374df0db5046beb48dae7c163b2ab61662c8acfc1c787c649384407a88fa7ab31ca2b97e09d6f2bd9df81336daa89bdf3dbfa2437e31f6d7064553407c389b4029d57ca6186e5361acd407cbbcb1b9934099b3fb2a7393f1c5937aac9186670c77588525354091656f7a5247a06deaeadd178ed1c63ebdd5ba0e775f60144d0ecaaffc269b02cb250d36aec251611cd0ae5b8069a6cea5a8aa8a478f5816ea7c54582ea40ba9af8769648c07c0155d0d4c8a42f32d78ec4110f146f99c9cb371a88093f2187f5b78e7e04d293c3699a161aacedd323103d05e2a82ae74815acc268d245e7615c3162c584b6c9ee17264f40656bfa34f61e0b218328dd85d2cef011af43f15893f671f765707bd599bf72afca6fb309038425f232a26f2d460660b4404357aee0cb71ab7139dceb0d4c13cb409cb2a63d96b035fa46d1f1d81e9c7e39831fad6c059a73f48514091cde348834e89218492f952520fc30beb1446f815cd5e126d74a3f8b54cba09a37a28a0196e09f1fe9020c13e9e926aec5d00ba7df5dfe584a70d2d61557004c43b295711e385a6b1f985f86e6e2cb4a963c7e191d5a72d3f48c7b237503c8858bcbc9db8c26652cf691a435c2963f57781a793facda8ced7f533252e5ca06805a1fb582833943704289eb555b7981714504afaedd5b0b261cd7d0fab48caaf3bb8282af0514471dd1e243254b20029c672dbc6e77ae8680a6224ad2f569bf98ed9195f714c84a95a3c4913978e0f32210fbd81d695f4b97f9cbbfcc0c4ece6b97921874865e8e577b7611e4d2acd377f4ba6e0ca4a71ba6cb81d7bb8e18cde6b5e1923630cc96303168481f7a1feb1f9717516a863803ad382b8b1b049c55923fc00bc5227a7d5c1a948f6127a1c52f10e2429070f069e741c326b38ffbf13191b02bd4bb154e22323ab0a97c8d9ccabcfc9c88e6000e8174150a56fbd115067e847386e9ac16287c7ff9892afe2c226cbcc4abc73b6f8e7d99f2e351132736b23aa6dec958745bd8ab5dff5848b47c9da79c41ed420799405ffb0d3530414ad232dc66385b810c42875b05bdabdbb217dd48a8ae996f79a710da50f07cb8f1de61fa0a2becc4134d250f031fe0a8a31137b51aabb82de5b816f08872be8c37c46fd3a8f541da30f7de7af773a2fafbce7ff2474b7f9e7fca12f3f4dd70a417b12cc1324e0b1f6ff8efa82904b52dd7fcfa5d17d0cc4f0c62e696c8a2c25e2cef8c40a5177c6faf0cd2bec9038c7d0491cbabc5913621745d2211a901280a8a537d5780f450feb80417174b4c4b72ace2e45eab76e3dfd423ef24f5915641a64ed5521183f3dc808d4a6c96c8998ab22e5994999489b7be0185222550ff4a53eb7d2f8262af1c27a0e2dd1e136903b295f6019f14456b9ff4e5eb58e7e7984ffe62a6e979a9f6f808d00a7580a8fc3420b4bf14dfea153a1c8e02205740cad359aa11ddde92207d45284f3576729f47f039614f04b753d79227df721184c889f5c11e0f4ee603ed1242400ee7e768ab42ca14cdfe63257c3d1c955ae2d220f9439b51a8983660ceb923ec94c8f14fcbd450712d6fcce0c3175f4166d1e4fa4ac95e664df8dc7d73c2a6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
