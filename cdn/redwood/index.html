<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c9fef05825f8bbd8ebd66e342652f1cfb44502556ffadd8706a01eb763ea989e97a19fd276d6ba9011b7ca78c73dcf34cbd7c5c9bdc6b76446223d665d65ee10786e496816ccea6088f8d5c9ff5f0d114a502b14b7dd4f203b176085709e2dca884e96ca34ccfe65ae79c80bd0023855426ecb1cd240b9b835ce7bf7e27f868a32474702d85469da5c1cbf837f738d15981e7d48d5ab61701e43e888a00f64de66cd4a26ce7cdb500e1ba84c8cbf5801335a2480afa19e38bc28b2cca7435e28a611a066799ac8f089ab91f0328e9561bdd69126e732abf47c4a8ab65107ee81b4cfa9f45f2d2e2391b28bc02e5531252679bbc550631a44a3c6c68807252af263da1301c7e458929c840f25642e6e88e797eb5eb4c75bc89e55c3b3004c06c929c8a56da30715ace340e560e0f5cb1cbfadb4036c62b9e3c0ea626246fcf76a2d03ad1213f8d08aea1217c02b568546415ce8fbd98fc202c627986e07f2d253504edbba01ed870331b6585f5317dae92b0334ef68e49fd4a6bbbb63bd69c92e21e57a897cab1aa170f604d34a680795fb524c0e3f2c5cccc79db4009c98a979bf47e1ef73222074bed5009cfb75943bc314d852df322c22bde1a118df806d4c743b390a3b1f9a63b282664f2d51aff9ae78781cbbf68eacae670bc374ddd0b6e51d3521a37cbc245436751232ce94029f10d4f4f6b296c5c6982340463ef3cba7716b27801f8726bd8d85d5f5ad6b39cf70c9c9bfbe2e54155dc37a368eadca2c07b2d0815751ad3146f54764370f21f5d5e0e54d5e6c839a528797b4afb52c31592ccb4ef6f3cbc3547992f75ad81ef6b70109b4add7d1f296b6446175693911a221a544107090aa7e9ca14a936e14e68068a08cb9a7a3c6f8d16870cdca08c5d858fd7be3ca9267e99517fa2faaf810694f8bb436919fd0bb62e8f6ae28a7408040e57dbf46616d06e848e1dba8348130ba27f14ab31395d77d852c6a4a10a5e7ef2bd7498e4b6e8c9112c43277f2691caad6ac2812045a25216e880204011920a629922632828018c80cd73566a466453e8fd81acec9b287584bfc91f3aed87c71bd703b7f978d1cfb369cebae067d68005021841be637d7ca4f6667dc1a1a70aa3af856a76595e5af51aabc9d06857c518e0736c11b3a8a51eb42ed3ed45dc406ea33ef058d46d921ee17fc73c828868aa1c524be8c5c0152de221602995a631377f35e498fb2eb1361ef5762bffbba4d06d01800396658d9ec4ebb5aa72a2d3b2a2468879a606ad7ccf1b25cad0f4cd187bfddbd6878fca8ebc1cb635069201d83f43ec691e61b610981d2bfb85aa8a720b663e621838d99bfd622a17d3ca029a2d77e34fd499b1b3dd3692c4e3c5ad4550946bb550afe6feb3b7bcba4e02d0f650736c612495e7a494ddab9c8949e439a57e52e8a8c5c6ee429b10a942e65be214d1e96bcee6a14d0a91815dc7115ad02a9b94befd4551309832b98ba7ed074b31171c60461c0d4c89076a151b10405e7db3d82f7761e66c4469b17025109f9aaf43303313e51e93435efbcb0f343ea63e0ce28d6249d10093299665b4530819393734380ead8b6de797d2620768a96b57d145262b5224af49f294bcfa6477c129c8d2bc2ff441e6327cccc5b9b900951e097b5be181e832751523cdcaf7115c022f981997f3f54876b5b82ea38b0ea68369ec97db9e348fcfee861cd07ca6d0ab7150aa02872637d857fe981ba52a255eaf41fea7ef0a1fa915c8f17e49e42f5d81a9fbc0e0eaede6b275648831d4d4717332a5007a51a693eb33f8c57fefe4644f30acc13d953276299dd46866a4bf56572ce186e95699dd4ab249ee52af566e5c7b90de68362a427771a520a2eb76b71b8abb7fbe9d01d16d4d1535c1bb3fddfaad60923d55d471641f2a2b8402b8bafc01e84edf029941440aee2fcd48b762105218c4df1ceecc6b96e94f1a7a97832f8c6ac7125805ccac96012f5358cf0a444f8e4e4e98e2276fddbe0fc9f5008d890d4f5cd6d30dfbc5a37cf307945b712e8ed4b6215c11e9622151d97e2ef80ed700964bd1d1a85b4a1a7d9a47e1ca80b402d210c7306ae8efe8a476dc64d147a371d506f3407074621d96ca882fb380dfce488a9b90e3a20bf6a4296191c2f7decdc3e710bf8765a9ac8851f0b7d5f6c4adec90111c48a2a211ea33186cba386da56c76fc6549087620188ed1d96b7aae4d078b95d1689aaa70f993534a99cce4ebd608884d7261df9ee14c44fe290b7681a71e5915e0069c49c85afb71217e6e7de2222521e9c3b4e4e1b100b07d2693e4eefb5f3bd7329f9a9d38fd33c2ed2241ebec53c4ffdac9c7bcecaeaa5206b17e9a7d6b4acabb0b99d7c9961603cdfd29eb71d0ac8cef26d7aed08ad2e09654f0860efcf61899ecd43c88b0a9d53371766617bfad2f8029911467aec27cd8b2780c0f7be476772bf2ecabd0716378a47b9b3155a1feccc9a04c991d96faf256b1edcafb9528e58b6db5dbbe28e7b7e46eb1d813f17bcb3811575a599207bd7e4bb7e63d51486d0a459b69cb7fef6bdaa75bc4851cda8bf93af257674c8485f05005376743ec552a5a17e22c860f4f55a94121ba807be07e568c730ebcaeb903dfb868085d3160944b9315f1c53df253e5bab7cfad130679c200e1dab71fee894b1980dec06ead0172a26215465b385d12574afc27a278fb0d5a77bdc6c8c146992588078c98d715606f8c54e46d04dfe843b07705356e6c87476ed9a8d2824a97af78427adc29becfac75899c535e75d08833493b81bca9b3a9040db94608303ea008abb796abdadedbacd360fd7c27114a9ef974a3eb9f9f1862c90fe2193b83ae2553ad6355e50aedeb754cba9338ede2793322d2bda134d26830993940c3c5ad1dc45b27d0458ecce8497a337ec0a3980aebc7d72e6ee7cf7aa12dfad0b9a2c0b9c58cba52b0087ce879eef4ac79bfb1c33e1eab1cb3b09884391aa101d0079f2a359b48301e97856ffd61a27767dfe49993238e138da0a61cf2a5f07e3f0987597d816a9831d10bdea7a4543e63fc3e92cdea2ba32ae7c782ddd5455c8a66873e406a3877550a5ea099835ccdc63125c832248c748cdef2f5b6da94433d53f0564f3cbfdeb8db977ce2721154aa3761494351860c8e2ab31bf2e66fc6d96bd492edb5127f9739993006c697c9a7e6cacbfba49e022581ef201d1c781e311afbb04a5fe3e5ec6c3f41e968926f5242813abeb55d702c61a998d434db1f4b0cb9f82f77aa5e3c6d0a014644c06339024983c2e99ff6af929f3b45255046d958f8283efcf1b9ed0de0d4651c7f01f66eb6c36cb06419267039dbdb825ca7779681037271a45bbf419a52235160aeac82ddab1ad7a695a696d1cd58d5ae64ef6dd4e0e207f280ca3dec98977dac169c31eea0d6ad1ca7181c4bb4b7549765626a3fee7ef8d2bf116e1f2f0d26d278e2b90b0d156bd3eab835804ab4fca37b164d3952a9a8dced72ca029402b66819019e57506329be2d22498c04b5c26f00d49ef54408b83cc6c211bbb182f14c2200f7703646eac30a6dd285abfd0a4939ede5658b1721543d68b52d6e7324d2602244d76d7f774e916168bfcca4de6c0059bbe9651bc67ee5b9a7107683c2dd89270e120dac8759ae35cd448d247f6094c2ec2221271cd8530a353c5b2ce0a2e5f4fea710adf2bc871122dd2c944696366b95b6aa0baa81bb798352c8e7085ed17c2c1d23af183ead5a26ec5e223c79ec1dde99fcaa074d56747371d3fde53bac07d58df08c16762968e1044d9a56561f7e63f41475ccdaa8762a3918b331c5037b7e07385f0a8164214a51ac0101c7edb942a92996f1f9c5042fdc1d8f157b0b31b7f056da5212aa95beb3590e3cd8daf3ee7c2b7de95575bd42bb9bb46a180984a97ac050f542ebf973eeeccbb9650459daae760e8fd53e15cb4d99fba495f3a12fa41f72a780463aec034dd4a4631314b2619e5fa661a40cfff1861ef39aec188158bcef592ca6e73cb33935abfe7c0338248551477a85d2026829dd2711428e125f21b988621bfc141f88583d514de54c5e4fdf871bebc100eb82e17160d5be3254a4d284723397aef4d8f17db35c8406aff3f3fdf38d0aa4508f3ba6d0ec4c9883859ffa9ef89f144ad6017f2af0a61fbf7bdda1f9330b92d388f6bea81260de19c930b9ba297d8e1e902937e5a7c3fa64133b1447beda177863c0c3bd9593d86cb9f045637e0d25eca45eb63508b95a483a137c7db8316fd67208a8b1355e2c6bbf3084bc9e5a7a2c9a1d592e1393e58717e4c16b123185bf9724360f89325e1caaac1502f4eb5c8f1689ee5fdc65d23ae7ad161e193f41f9a63d2750ea8bc81fb3ede329d98ca24b109234da50beb4de81ac362825767dedf8650eac367bad82def87d50e27cd0ee5f3b519b06cff910b8883cdbdd275acd2e360a2d8fbdbed8fd81a6b27bee3a290831a7366c6f6162b63b974a1aba303e399772395b7eaa4ba13135d9d35bacddf29d964b821198c44aa63d826ff9adeb49e6ca0946e20323fdceb90a52ef89ea3fb8b54b2a81be0fada4b4e26d6bd88e16fb86209d391d0d18aca9e5bb21dd2f507662452097ffe6edb6b7b59e95aaafddf11edc2e5edd3c05689dd0a1ef11264a321c19df68ed5c14d4dcfc864742696c98719592b386019d76abbf43a5ae66ce26ab3d1ff429644cec80f12fa2d1d769ec7a9003af0d6334a8c0c64dd505c9883c4f8606a40f88503d28f51fd3b9c37aa66063c434af0d3ae1345f50259b5c6c5ddf76f089ad7bf585c7949b0354d118465810aad82bb9efd32f15a61c6b0bf10a33485f265abea011c55f6037c2d2873acfe221fa06e9c56ab8c5ab1d5a152232ef13f6bdca809bd1ffa23a044371c83e3139bed53ef22b702b9c4ad58fd0cbe91b7a707c50b34fc262124e3553928db1c3a48409259cca443f83d3b7e0b3ff6ddb0af00fb28ae51d6a9810b34fa46a74baa65123ba8cd07dee842de5a52143625c6b5559a669820489fbf567eb910cc10d02297825cfa56f2d3217741be510badb0aa8c5a30ae8b8270930028f7d8893fc67b64416cf9ac3d8d452c515ef752ed8dce25ebd19f425d4f78c93a88372588168abb7c73fe12e7444de9f2b059f128acc2676d93ff30c6c79422bd2c7521aeacc98d9ec8858698d8182a4bf9b1a587d2c5641dde91289b064a914a3ac802b72d4399ae585fee27837d44c3c05119aa03f6a1bd3938ec8e55bff9a74a232916b84db9ddd42b13922622aebc5162a096e419c8d9c17e7d8875225456aacb5b003eab88384e2b679faad73043aab124dedb4875fca32d23695ec2524429401bc7f4332e050a1bfb89d0497339220852c2d93dfd2a72f1e587e2c336cae5a19c7a3f3f51ab8f401b86d6b3e60f6e825c31c0efb3c3bfbeccb1f90e018422e2b99be41dbbe17fb5a7eb37b84abab13211a5971bb3cf5959db7decf474794b9288d7f78cf5d570e1ef0f4865f401b70285407bfb3158a76da3e8be45621ca102dbea212c27c6d5f99816d938ddac9cb6b9963973f712ea7a33eef653060f836589b69c3ce99eef2843bdd4c884d920686f21df93e07d48df4a93bee87c2fbdf600dcb1fd14672fe36c63fc42ce194bb5dea85b55305c8b0e3d5bd107afd31a643be51aefefe779e64486b00c416256646057f88c2f34c1d530c5406c8e62654cbb5e6db8e1e59acb0c2ab719fb013fc2e5f5f8f79201b8336e10959d5ef136c4d52c804515ca14ee1c1c1bb051fa779edcee517928bef1f6bf07c48a978570f827732394a2b19ce26382eed53cb443efedf138f64b95b50611d83ef33789c68ec69963c265c4b84d5471a9f73753cc6cc806115ffec64f06f415c41b02e00ac75f0238b10060525a604f81da1587bd52d26fb31c8e5b61d0965f73554cfa0a2b8a886bae010753af4f3054b1c7a385b36d5af80bd28b1e7da5d67d57eca82dd8bcdc582b1ed10010b72b6d13e7559b840b5ef401a698d5291b953fde3ea3aa1eebf2da80fd145000c7b9eca121d68ba6544f357e9a66a4d3058df6af8813588f5ae0e31fd0e1165b49d2965cfabc3087b8bce3edcacb5264d03a0d8de747275eb9dac4746e8701917ec0ea08bc37cb722fa6953e202d8aa511e5cc4fdd0c9dc35c72d26503f2179f3d7cc9ec5d8912c0bccb6687610d5bffcf013026bb2045e44de35106efe3e070139c883f1f92f3efe019cd032845ae623580dcca70f9192ee19bf10cab9643c5f33be33399a5040ed7b8ec7b0a2c98383f0bdb6818f4adc830ecba0c0d2d9bfbe699285d85dbec2c3ba19f76815c0b019562e96bfbea6737a1694f8d97e0d0cae7e3339bb0791353895d6f85e9838952ad6f0a306c65370c09d08f5cafa56676f7391abf31f3d9674d7f8683b4d8797a52aebcdc9745d3c69e3944159e6b51ffc46f8b77aa9c02089c71e2c22f2044163bfe9996a766071d0accd675717b9a442b321b92fb27a6117749344723759d6dc0afada810843f98dfabd7d60c43b06cb67248d973e3b789a5b1e51c02a14ab995f6c499d6bd1f247092aa87082fffa025c2a342c5cbe7618142da177234520519436942a004d679fb622ab1e00e2a6463bfb7f20dc91058e278fac7e8dd4d9a995abc77d7045be517c0ed67a5c285afa0b7449c7d6124e17a2294c12cf24c23fa535a277e88e0244f6adaf38cdf867e292754fc9acf3d497eb56c7a3d692dffe76dc893819f686ba1e68614f0bd14e2ebbfcba4d3ebd7d668838dfc4f6af997fc910cb13dfc18c7d2990a21a42f95d92fed40679a1a5efdf613ce813dfe9746c19c3cbef87ab861b6a585f6a1912dba88c6d129692545317f1451dd3f8dd1c309acc709b73c87f60d06ff9e6285ead6cf3275914d22c5a42ddfb5f97a7e3340a7b6c5436a526eb00bf89a369289b41ae257280ed3a8ad314f6b692f8c6f3c7b16c18fe7c1c7770d1e85d4f09b76f1488e4698db7ce64a3680c69ec22e3d728303160af06341cbb2615d4a5aed1da62c0a84edbbe6330d64c0a1af9ff47d39ef64de6ba775fc3e30fca09954e0f23c612fa357e51b8a867d2d49e5cb096e718e9725af6e7811b4e05be8d1d597238cabdf90a5320685123da1c07fe8a6ac35b3a211b2b2305948df8bc1c25b2a96dc6a8ab83ae04b46eaa6d67b3114b925ed0dd5658497b2e133824f97368eb26ad8d0e38d06bce22f5c5a166bd949512e79c9433f2f8305edb89edcf1471629722640d787566dd6780b1a2260ff87d29cab67cf92f05c39053c2b082b3aab7c17c370519c98d65c0bec44cf23ccf1a98294be9275fa9157dd1d9a35f0f12560b63624c532cdf663c74c83faf4226a688aae9785860f75269a01d50edd4e397e732d34aff9b54a8c96e614d3e1f420e054bbd36039d967e712c8d52c6818b046aeb02403dcf343f4ab0c78ea91cbf9a550b0da4b3c3f38b71a9cf69b2292dbb979d235cd30e24f68027bbca6d99d1a6f1c3c7069374429cf2a6b2faeed3f969c736862ee5eb3955976862ceaed6d2d389c75b13a152f956c9c7ddc1efc43dda95736b3c1ebc348ecdcd515d5fd0b67d87ce1b7f515f8ffd7300ef39bf00e415c1b09fd0936befa1df776ee66ba417f204523d9a45320f1d14e1b76d605e1453c2f7a68a8c9cb7d967297f3d1b2da0bb923d2839141422e2a6d6791d8e7440fb23475aee40b6ded0de9c34b702ec9946ff68838da23a0c10878bd0078dd9d86c6ea1583b76e5bcd174b2150a470a953e03ca0b2bbacdab3d0a3e31581f6adbb022e7693bfd61fc7d628ce3e0e3472cc0002078062a5231e5db8fdd661219ebe28945b3f4e3a16a526d66b298080d4dd828479181d9b22d5471efa53a7246ec7b26c79ab672082c7c85e69eefdf753a88533b4301d28443f0bffc1ae8b21867698011e3a7eea610b80b33492920feba6b3afe889ce00e133b363633587db927e8c0bcd0331e6a840fb49803454b87800368e8fa11dc2ba3ff67beb698f8cc816db2e1fa945362eb0209664cebd906be530fd0903e22a2e943060fe8169ad4c271557642f529e7af86fcfa66ca0fd5c729eba281400f9ce861e4984a297a314ee4c2e0c9e9e649ef1b9a8a54d67b0ba805cf3a563b5d50f0eb846030858b4a3da78ef3f6afd4304c9f2347158ef98199d3dd664d1555469f69fef2b2c9578d153b103e5a45742ef698ecf5867d04674d744ad821b21a651eeb3d33cdffe88b839d515546ed571fa86f853bf5c01441f33197f65c12e247f01c2eff49d12c1f6ea5c39ab1979a503aa5854d3151bad089005111c36c7d35b79b2c13aa6f63d0b51afde058ff44889d01f9a6921be0c6416b84f983099323ab3eb3d03dafa99d926a928a0b876f7d64a5303f105fc6d97a8ca07bc1c2821951e69858d49d34e06b30e7c68ebba43891fd4873dce673f75e507e090f1570bf70fcd7a35c05a180111f4810b721256e359d00a50431b82a7e049e191b2d0b6444226e9dfd3b7d062fbd9ef70989b49a3025aefbf991067c2acd78d01119570208f0642e073669e787707d878b4d45ff50581e6815bae2772a654a55a2646dfd5c62f3fdb8771f701ad36d5402d886e093ad73099db0b414c60a0816b3ffdde29180fb7514b19acb5e5f4920afa94d087d59e90e4f99d5b9dd97791dd5a4772697dc495c845d288de26624cc5218a820c903c86d51f2558e3dbdac1a0f35490b86e479f75ce1bd7b54b266afbb99686be44181b5e92cce70e708dc21975ad7432b860ef627120bc2364810eee4f0ebe34d06de5c398fa0e3de859e03bb195a46808fb0d78870a039c56cd3b0a8bd4cd3fabc77f34a03de9d1ff21e74cd91e5e2df34bff3df7de8b9f07b1fe7d04c73874a58306075fede0434ef0d7414edc9056f28390abb415b44df1063b79aa2183d1115419a641a0aaf4ea9081664d9db7a2207d6c1469686252de5ec281cb5b230fc6dd83097906593a336abe64aee07eb5631273881d1f5becb1e65726ad4c9cd62e743882ca3e5e11186751eea235def0606f6759d2bed7f0d6e6502d13f8f2bc848c8fcb9d701ab2b607ce8b5245484517ccf88d98f52e689c98f8b5e838a04e1d7484de27e7b30518fc042d15079941b7bee8b76c24c8202ec06a3d0ce521abe7128231f1528312bfd5faefd7d8bf6baa59e2cd3c821955eb195c9b3691f134f9706e0ff42e88c5eea34bdd5be868cf311cd3f6502f5fe5ce80aa16319cdc10a5f814d6618dbafbe9e708dba33ccb2a0f4a82199b713129233a5e6bfde854c79949e4277d8f3294be57d69ba1b48617bacb47947817b7e200b12749db713b4aa9f4ba1dacb229efc4c8a87d7fbef33d31a18e18994139669407b34e2ff306e89f6ea22d20c75f1c0964ccacf15d7d68b6205838c76f544477b49c6ff376803bc958dc28ea25bf858a4e39fa41adcb6fab264c3beb4b0fba3464dbb377c90eca7c85c10d86b3361e066050da0f33b1db619c9e2d73e1906302a15ba1d54f11a5ac00229cc70fbadeeb7b68dfe8122ec32f507e1ee3dfb0ff0cea372e785d06aabc7ea027d0639bc61463d99a4f6b609dbde48a30e1b680cd5bd11e588ce47b2b2715eafd15da82b653a4b5be47731e211a1b0deb473d363c28777d975707494b5954996d8523b5b669bec7b39b0e051ec2ac5967ca9f7f105e9d1318da64ee6bc53c856e5b98b6540f7cab833194b96d5a3c062813833e01e3a497b12a705861dfd2030b71afd9e42406b6d413b7b5dc0e1807dc8a241542cf904162bd556831cbe0d35063c78b0250eb039bdbe9880b8b0ef44178d7b7e6504db0acb9c3ee8e38799f968b27a8b1da8360d7af2b744be01588d28971344046db220efdff44ecedc5f9f135aca33c1a24cc494994673c08de6dfd4dbf5ee650ffd3ee5f3681906b4406e09c72f4cb11c212fb375a3b0a2eae96e9ca74e632761ffd7c5ad356aa566c2d809889e8a958ed862c1e327ad0910544b83df88654d9a93b9b70d928e8521cde3584d6840a4c548b5fdb6d96f9785bea48c61dcc896bc70743c19ccb5d5463eb2d601a9e55d59e64f60b339b8a4cd10bcfc851eac96832f22a05acf63d79f2a0214810be6b870bac4b63884e69666f3ecf85b01e24fdab330dc766b507e0672fb2ce5e6f3e71d92815cc9d9ddcf963417d5e74e2a090853455a768f2c61de54682f270ebbdac090ac3f781d98f062c1972cbc804e548dc192de760b456b7be77f072db8d6ec2a6b12d699bf0d55cbb226e6bf2215f5bda5bc7c9481340acc626294b0c7686b834ab3c659369ae09b2227b16eab6846fbff39e0729f9d96449bd591a7c33aaf4f2cdb0bce896b68fe2b7ed12d40b023f40c45b46dc03d6f7aa30f76614a38abe1cc97a4bc6db58e97647204504710f6ee59ece4f5b4131be8a407c6e07420dd86aa4ab061740eb159b4e3c18f5642cbe41049431ae5bb8d1d57c5d23e9c75aa56276dee0b5a716e3690127dee90b0f0dd9338aeded68c2206d00f0932dab87d20c8019c3ee963fd805c4b8798e2651468bb5050356dc36264e53835006ee4fef63af3298348859667133b798a3f39a8f8638af83691faedeff84701c289a7165198b5ba71bbd49501e69b542b8c515d26665f34ebc1677e2d1c60a754ffcfd31fc3510112eeb54f160507d32605b79c7c6b3d762c594ad2a2737dd9b8e52152941d8ab33ffac59f7e600c708db41abd9c4124d3411962cd262523cfdd10b59d0522fe140fdb30b78f7cbdc2d25e596259cadc2914313cbf965d18e2f1cc5cd57a6e23c1b2c59447590e9d130cdaa4fde5634caf239e32b3e0e0ba255c22bd7df21bbbfdb9a2196b456ed9331e815e14b1d898e20e1b1b8ec3cf3f9eec5f3e4706c038270d20869a0425f447369209fb1c3ecd674c7ecc80f678878652edb2c4d73fbdcf301caa2f0c1cfa8e01c98952e59cd6a1ed3fa5b9ac420a08b36d01df4851661ec4b51169b04f5c653c484fe3849d2dcde36ad911c068338843b410b398ddf2817e2ab690b2e27ff1ae0b83682b28b8870da2ed5a6ab1a1ad8eebff50a8fe6d9842c76ee8b0af94aef173dd6887a68ef46e766c6c4807eb1a14610191afba6ff9661d37b501c24c7d47560f4b52fbabcedb365a41a89fb4b471b97ca2bed037aaccb3385063747e62af7d09c11bbb2dec007ab3ecbd618839910e09be444350bf850187449284d6e8c4ef8a9dfb6f0b033e90293453e4a87755f12a4b6fc2d0c1d421e4329252e568f40a4e910b7b449b61a3157b07ebfa70670e5a799a74eb8b1804455088c0f792f8222851cc9930e0a7e6569891c8c742ae2ab324b382691435360069047e200d400932d755243411ad6556f9cb9b767039513d6e111277122928226ef6f54e4a8ea068b037f04eec8031aef1536862f58db4ea323a5e44aa8aa6c19b5bfa8e2ac5ea82e924bbb8d5e95c811f973e4a50648711b0f3a7bab87814371bb6d175b64af5529e9d33e10ab835227ad38ae911b51b68bf82e3aec0c0e8ef16f5570616ee359ef7cf51e3477d002e82f5314fa4094efecc4a0ddd72e93768a9b8ba5f5d71cdb3ec6c7d51e1358838cf6038187a9af2c116b68cd5a1571647cec5c811d73aa7b7be11b34b5b74ef97a557f1ba349853f1f386118060d6dccd8d14fb9774120d1f34811a7a193cfd5a8a810ec86ae1019354b7e727e49dc5dc19db47dc3b53b5dadff49b264a8324c3f09b39536cff55efdc5884993ee4167f4d6d9708997f03b9e53e356b344d6d67691babf75a0c84022798b55b5a5f1c4dafaa4aef522278eae46f2988d78fe954c996a3eaa30bef7e4229b02afeec7294669e6ae27c6cbcb7a5df2069ba950e77da930f9ac83f8939e8b58654620ed59b7085ad8653d88df3f66c1353fadd2a088ca153843b7c0878736a846f8711e32a822b30abd2dce9ab377df28cc7cbe7150c1d42264b522c862d7fa5a1a8f570188e3e1dc2ab0043ef5f5fd9354b5ef7824f1c8baff83e667763505e739513d85a273a2442959a6fac4712160e68a55f56ee5486f0f7787f15c8efb294075a9e1f42d1a193dc78e200ceb6b6e62dc996efccca19c7f2681d02c64387faf6fe33e6515584d96e0552e25d60162229c8c037b196e761adc48bdbe8473a0936cdb664a272fd877d98c127b387c61760f244a79ce27e2c18d7271c0626f07746735d9833b138f657f5335cb0d345791c7381aa9e6468c1f6e8c6742ed813f94a9cae664fa5fc7096f21bfcb20d638c22454f7a6581a42b353408707f78fec213e38c2789446c4d8bb83b5c498b719b8d707261e22d27763f67a321c81df63e6ebe0640831a1dc8c45fb729f1e81a70be1e13c43b3e2efbcae7fd204daee17a542145e0a862eb042384985cac4e3cc3bc268662ebb683dd28021f430c08defcbfc3bcc06b3c8b3fa0bcd348a2c754f21121345ed3b96f8ace6576ba37626e3db2b5d4a32bbec2edfcf45c500569ee1247ec8211b667fe9d1d313f56dd94602d876f8c0d6c1ea3d1c9994ac80faa33476a4fc0a71bbfa1529899360513aa0252d1cfcecf3e1fafe36bb060192ef4451ffc1d3a2e25fb8c6c125f4f0ac4c1b2c80fafb2596293bbd07dadd9cbf2f7785114b3fa786880528edafe2b20b8fc8e8d70a0bc43d8487718ea7f561f65f7f8fdb3781ed74579cf58513319fdacfd63ce64eeb45e8ea7f2f955bb7285701d07c4d54cba0d97c6380cc602b2fe16c763cd15c8fad0e77501ea2beab6f9adf445ae7688418bd7304577cfd5b35079625c5ad8be18cef8f775a425a7ef1b697def363ad0197dd969ccdde54a2863a5e9c217c2111a07aeea2bbf94cc0a25b534d7e91b9c39466ece63d8ef38499ea1e61c433928049389a724fa93e67bd282325486d1c1eec87ea948a5f6631256bf38e938271f10dabd0613a22b6f3075b05b764238af2831707fa56656b7a2ae625a3e2ee16598644a4a2b7e18921d2c5a96e8dcba143071bf31406b5f0d8b41e094193fec920cf5b497b20edacb18c46719150d627ff640602b09127908a6c7458237ee3d503a7e6a93e9c41ab28ae85833af7d74d38d078bd1b9cfa8fcda072c18a6036286b1767b8078e947622e7aa087118046a7757a46452bf2ed50811d07a6c6985a75933dbcd97c675438daa3da1eca982366eac6c60509cdd0fdcc949b93f9e21b0885d496cde0e6fa7265f1a20c3b996fecd389be28f60ecf84db0d7e6860f1d326a0e8bcfcb461b36d9ad821bc5a54958bb258735b0ac9a9c7d4d8609b878c23580c90f81da56861860cda88ed06d4aaf8298fa6e17be41da69979f20f9c839f188656719a57d395b926c827cb02593c8a5d64bf9c18ec5749282259cf02595a6f76fdd331ffee025077323272cc1c37d7a320cfbe26259d5b2d85c0275e418e1c447bf32dc3fb58ff202e7ff62b391e0b1440558546db34e64242fd7397296315dbffc49abc1c1778157b6ba96d2d7d95077235beb4baa1536bacd9e80975f86778fca933c7f39a9b0fa088e985617edb97fa309acb75ba462002945663466ad8544852fb077eb2f6005fbb9a0c14abc8e9a46cf4965fa050b2392e3d81936e1c39cf4524e2439d89b77173c0cd35ccc7a388bee2e2c70996866ff9b23f288a60b9b6f08dcc4401a8d889dba5e33c6c1ac04c8a304b858e2168b5ac4c063cdc32c3e7d94575a6071006400961e5494d1408f94bef0d2f35b5187a2b117ab3386fe5751c4cae5927dcbcca920d6c01c47326e8bcd789cb430546996152c966068160148b0f4199c0a4a2b2e83a5be65cfafa72e17a4d55db2b38c1900ed12d220b0eef2f100c08caf90ba1d49032e7de429b7643c52b01a626823f11a914a17cf10166c05d6d75b6fd4fd8889354c21fdae43af63c39000850538c0d080fcc75f5112d9121ea4f97179fd69e085297b7c2f9569dbd79c2bf2509a49445a6f6dcb929f0cb0f021f9803af0c7cad314bc5b62c43df0f04dee70d57874dd512be2f54c134bfc12f7c53d7d9d2042ad0e1010dbcfc5795b2c74a02ec1f71b44d4c37fa23ae687d0b1ab890f627afd6194aabe1a2f2db529756f96a68f5caf48d0e4d0e4f815fd564eca9ca38b7e2f0135f574393671f368a74269e805bddeab76104550b7476703d25766adf4b837db11b531e976965df9fe4a6275646dfa4a7f8ad640f66f267826e75ff8285b218ce03d67057d32f4a506383f713bed276f09290c0404bc9c23f3f0edb59d3f64c2e60ceb2bd11e4c4a0a239e6f4f3f3de1027df209ae9a54706e549b039ebac836b415204f72f6933d511952fdb0ed99ecd00e188f7de38e3133a8f5dd17d38e40298f575641ed42e8371486d5e1b99b34bef2bb64326bd37cceb8b989871ce2b307d6d9c28bbffad2fd2a17c9f815b2cac409c24113777f6e278228c9a14a13c0a8684bd2332020053f3b79894db17493932aac9f1c86e63b571d02111a41c10b824c325abf448695d0be7b9544b3f78db90ed4dba3e3c05be2f00bd8b1f521570175878858178e5e36cd19cabdbd05be092dae036e325222afb86ba689295d64f57d7f1434e29bc944818b5364faa2b5fd16ab8126cf726bbdbc9b25ed404d9aea1b880ff1a7fef27c38e7e97eac5cf586b2506c5f443ad5beb47617e1b24089af7d79462547307bd7a8544a8f431f6a681ce0aac60db1fc37cfb7846e0daa84da5790eae37c60030e50037183507eb1183b818869afde61208a6b1e9baeb2eadd7544400ba88604d081fde5da3601d8042e88797476612b693bdbafc9bf65d0c63360dc98c2ff1f4b1046e9828feb5f3dd7a6906f2bf4cfdd02c68a0ddeb2cf4699985b5deab0a1c64bbcfde0b13f5ff7f67f73160ff80eebdc1451d96ea2a81bfcd64abaf296a7c20c3bccf2ca84431b782d4af5bf53b0b8449be2e8ac9b189d581dded08e9f8cf7caa83886e3c83e2a05492521ca2137752f69fcbef83e2f73be3196e7167c96fcef57d9cbe8eb860739dd8d2f84720e5448fea801d91879854c5af0dc4dc5dd5bbe81e5217c64d3cf8681e8157451e912214d809e07039312f904344f415c999374f729cbcccb96f8f399f598a7fd5ff3f3db9115aef4b3b9b2d8d2801a15741dc4760f14cf3e19b1c822ed6ffe45943da5871206556ec84882b56ff2f57da16769735b6ddd8fd810ec5eec8dfa0e87aec65c859f6aab02cbc1d30a63a0c450cf9bd80bb5943a885bcc22061c0e7d308574baa51aa46ef355d4c487151798653533851bb7c8066c87fefcf79c79b492e5593fe41b13ac4e5df8f5c3880ba0e0b800a44ef7b57daaa7118d37855cf76298f3f500ce3864df082d8628fcc5c0e8fc8af416a75ae57103de98bb04ee6c1481650b99c6872bf87690cbbe34006256011cfe0f188e5f105475494fec553404d850040d4f256a2d9305204f306e2709ea9b81d08528710b647cc15ad3a8c11efcfc35e81022c7ae7e4a205901009b3eb8b3b50a8f6411d5136fed40bdba0084fccef3ae413839f2318eb4f9e189ba9e9886dbd802140fe4922987e1a2c5e8c0615da97c2c5592f5f51dbbeaf792277a4ce216c9f3ae5ec101c22969b1c8e7d47798aa7f9504e51d93e0efbfcf396d4569e14c5162a331a23c90e1582458c915b8e64f2f555b24d608e19849db9d60a81eeb9aac93f9da91453ed47b3a956137db82c73abcb7723125a143b58e1ae075c10325033950fca1bb340dfd860a98ba54eb4cf3decce8a2bb647e42756db0ab73d327a8c4f870f3a91095368d822895970e8ed07e1ff83755c88faa145dfe5a19efa9f0fb831a155145da3f37bd2714d0ff471476855ad0c01404b091b095df00f224f7cde865c452ae1e60034eb5a0f5c94a2da054d43f6671910de87b817a02ea1b66082943cb3598d2654a5ead7455277bfbe8480b809a334a04153f9bf425f419420fb98ae752b486499ed4551dc8a9fd21ae6e7420fae68d25254b19917c1b0538f981c7e28eaea88747d6eb0149c72fc2dab2cd65e38dfd8a4d65c537ae3c5264a952494492c200b47fc67ce7f4563fe89fbd6966237a44853fec170889e0497ff1fee96619c5c86d4ad960d97ffcb283eddea38cfe2806e4405b59d6481d56a9125c59f8f5f346f423c02fc04dfd2c8549995424032f5c44c1b75a02536866065460db441113a9cfbb417aa37d13ce27bc0f17a4daee1c18decabd74066f8b0db7d1b76aac626f3437ee9caa904e51e5016d89377cd35387e1b9dd917af33f813018efbd4f40e2965a99653bb192960ac1b51e9751fe8301e615df66eea534a128073b8baeb47fd4269e85e18cb3eb14aecf608f8489d79a237cfe5b099ad2d92352f47e41fefab75bffa6c75c5836ba2eac6e1d74392757ba1131ea467189ea056b9290373f3aed789189ad06800792b0b5a3d002a2fbd6bbdb4d9adbbf22eea2102063cea24c54ecf7fbe100b10d932386d53cf848021312affeb8279534fbd57abfd677ee9eb373ee9bb1012843806e1917031a6c7084b95cc2904f1dc8612db57528e65da454a6a69743f4242c84bea3694a57c8554a2dc208a75472cc24961b6d9868c73e55cc10a39f807a0328321c193655bf0e14086a1af81d0670cde9471dda1a04d11334bc72d0b29fa27907aad122d841370bb70c9f000d130f0af22ceaab0b53e4e23cad8c8543894c337bc414639bfb880f904c81f9fc576f5279cc9fb5921b94b54777df688477310f6e23a363dafea5a8144e6cd54cc0a65aa360bac1fcc5522aaf07c34ab81558be4a25976d407d4ab1c2762fc5585ee7543a96b5ab019631a0ec7f80280894cac97eb73b51c3e4d5540815cbaad6386397712c97185e22057479b70969ac649d1ab2d7117caa44e287c4bd68a489489e40e547793c525ec2f9eeb011de7155fe7a298019fef61df0cdb673a534b0bd1a2ea11ba33b68ea2e6778dc97fe4a3cf468c8b2357f4800dad590391e4733a5365ff7e33df95c8974087e54ada17b123ea7c24705437ab490e9524f794b5eeefcddd8d95619fe164c6eebad37e06f9f9424c78c6dc380c5c585d23da308d0db92e266ccc4b99c17d951bb7523695ad6c1e26453a62546d493c871cdbb82c83bb238987727b4bb6e9331ee59692013deb4c68aef87cf4a8ee31092c1db00b11e6dbd16083e55b8100820c2744da4a210552a0d2360ccd0c048544c4f424fefa2c584d14eb880bb9ba7260fa71c480292544c300215ff7d2c0532177d8e7e4ec21d7b4e5f3747e281f1749f454bb54d53ad771178a05cee158b6992baea21683bbbb1de3f46e729d8836f522f184ddd34cf89117573a819ec1c7a3173a6ffdbbc54e31a61f028b84df5dc6e565162233de968d576c08a4beafb04540902bfb89f21425eee606db0a72326ef7a98615b0ee3b82d354b8bcbb7770429cb42946d24daae22afac65cca5dad2617ef4145b6ba6cd4c3a27d0cd4b9ab67536eb2e5f954eef2ab53526b1db5fe215b98af27bd5f7ebf7acfee8608f8c89dfc450bfe5c47313922b75c2e33f8e94600556be2b6389a5e28f2c23d6026fa878f8b5d75fce9d1782d8f7d2d165d8b2010e99d305d4d44cf140661e1209ce1977b6dbc0de240da896396bd79b07e6109c0a9bb2c01b16a5390c9eb96807584424b17a86be4f8183c053722ff7ff0be33e34c8733edb72f8af8e76ec55d1a8908560d6cb1649a2aa15f48b2cf34058eab35c0023f80e7dba1fba6f0a7208b061ec2d041692512e3c8bf0541ca6a35e2625bb5b6192e95f3cebeac3819d5a15376bca13f7a00fd10ca9ebc01b2a0184eac8314cb86704354ac686c3ccb60705cbb335740913dc774e4fcc40a17ab23e39b87363a001b128bf1cb99474535c6c0e8822d8fb4d423f4a2e00ad0e7176e2e6c39de8f36369a55f657c531c9ef0174cdabc112c374c1ad92d1df73d0ef04ffbaa953268fd89b03752d8f420830a1f1e188b5bf41fecfe","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
