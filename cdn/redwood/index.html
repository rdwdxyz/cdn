<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3580b3eff00c63ddff5f74f98c22e70665f1594d07b4c3473ca0b59c3a257ba0e4932b86b88d1895befec2dfe1dcaedd0d15e561d94709ef349c4efbb4a620b98bfc5c0e6f1ea4c90d13f93a35394cde6ae3ad2b35c35b9545d02df1607359290123061a3cbd7fa4318ad43fb55ecbb162f23643a2a10228e3bf79f9c9ffcf0abd97a13f18a03a08778053575a67befc8829c378f27b2288571f39df357d47e5ee0de09cc3711b8e8bc88df98563799d166b6ad4187175f14dd345b40cf6e7adc70b6efd170d9e6eba6ab7b9c2c42815e955fb8824f95305fd06381ab7d556c5f35bc3fca476960cedb3dfdc14648221ebd96d5ff839685fd1d9f4bae6695411a5ed00a7019072029dd2286d32221c399bb4fc3bba5904e04c0537c51d036a4d907ab46aae5928c67813e508f351b7838ab6aef7a0714049a9b5aedceb65d8c0603c9accbfcf9037f71638a7e6b897d5802c9cc25b13e9a7e1bd9945403dc0f79adf6f1452b1508b83f226e688d9a9a07b4cf1985e40a8ae04004e455b39192103a07c84e90e8ced8292af0fac19074a53fe9e39105fe26992770b833e711c071678b599dddcec5210bc693f4154af761ebe914570f30bd226351b9247dcb412d0bb6bc2dc67e29982d7096eaaf294609e1e10407fcd9662f3985dac0ca6f95c3466b4bedb03e515d212547a23d66a5dc78c135eddff60e2ca6f6636db2b2efa576912485c9b361fef11e921960b77b5faa056e5a45b974a41953269eb42f799d97da0220238dd5202ffbbe7784c18051d96bcfc59f9b5d1d9554cffcedf02e8512740c5a0a7ed2033c12926edc984b17b5226189aa0da75bf4a566278d36a37f1a02db3ad9720a6bf8e20e92c55e470e50657b01ceb1baf4c65279d217aa4c0d5683c0373e5ba03fa7c3846a11ee9a16479fa7010c8ab8e60515b7eccab38768abe080f3bd22c754f829916372aac28ea31b68e3d3d343b807115d6f0b27188d76445833ff7f68868f69125cdc3c0f004a8fd912d2fc20e731db256f7351979732a59d2f6d378285455640a74a8e27375b030730c151efd32e8eeb498569c18394bb0df0c701fa2eb8994f1d1198ca8d448293ed99ea33144253a9ee06c5a4e4469c11ff2e81b63d88e77b20509c5225511eae00d7ae02e7ff2559637f5c9940902cfa4e66eb45f1e3245e65580979cbcac0735249e93493c41a388e860d67fd7f0bb15f7301cfd717c69f128b4cc1c0e0861b056d2cbaf9371eef4a0cfc9b0d97ba94227ac6e6fdec6b8f082a2b8068d8e8f3d76a7b29c99c8fefc3d290d14ee4d480a7db72a4c01aa663e3ea885ad93b35e123baa8d88c11ba9bf9e0669693d9d924dfcab317c61025f04dcd4f6d3d603431c9acf4a669ca70ee9719861b43f77f2ba080cda4a2283858ae17dc22d65011879a133b72a20ec9b3e0b17c66b58a8074cbc274823c93165e97fbd5a0bf0a8eac7c310f21daebe083c811ddbec6266c7dc373c0ff08abcb8a320a78f522c88e0c135fd5efc01d870d43e3253ae42806ef074625577eee450ef59e01398a755e3e4fb0fcdd00e08591bc9d9af3e3a522f45b11dc5ffa09447074ce7b6c4570884211864cb98be86b00abe2c1a72712f8891a1fd9fb1e53c04a354efdbd0c025dc864be5717f32a6f6e64df912b87b79db6d536b4ccc226b2319e6def3643fec41994392b86d5780da29dfc6938e2e7fec4cf0f77ff1e29283a6ddb3cd61a86687b39163acbb4aa62f74339ab17259be69f2bc37074b9ada97017d15e01f0b3a6273e0f329a1a899efbdb45c821b8a882f60dbac9117547bf153afe01e51ab5f6c8e6a5a7d94e4a85afb4005eea00dad3f2a1540712762f973429bdc0aa5776632a8395529f756254ff8ad8a7fd54f1447d66ff5364ed7fa0fd16207132741dc9e7b8e59635f14cbc600bc29b121536c79ea300f4c1cf0a57a6677c2554c9b46b94f301aeee31838caced2466bfd8973633ef4dc490618564fb3ca3f127bb729896aafcc1526a480d8bd51d29c458ccc34be5c0a08f62f134402c076c1967d35d688d17ef3ac72bbcb14ec4e30c622adb7240232913ae0da0bf71a6de25417b41573e096373195ed4f1220c273680b3e5d3bc7dc8291666ab2ece9ff8fa75b7a5a1492752f852e2d67fe66ad448fddd715b71a6717ea128672f9f16db2b387252461b514ba870b034f5a502bf535879a614e653d474000c54b96188905478f4cbed149d5c5eb6a81844c6c78ccc47a7f6e27c5297a2e98c3db18c8f93eac69d41b5c2f1e7105a2805b9122e9d4a121251a512cb89fafd92e95200100df0923dc99db4476750ade7c609ebd262cbdf951d4661134572af111ab2754e8f4654428faf861dfe82250c884eb90b32995df0f72b44571176bfa28127fc0f5b943e44b5fa6fca6ccb28c23537dd767bcea5bbe33f89586ec523450ddd53496ec5ceb2ab530e70de49d0d492f00b8f11cc1432192f6f8ea92de22a67ebda8a6b5d88252124b6ed0eb973588827900983c4617a49980d662b974a1475a2046a960a7e6d3140818fba7cbc357e12a59748bdc22798ca8ae28889d50fb5e3164a74cf601486ec363341369bff689f7e7463c45119558fa3c18b026aea9b77b058be4bb8e6eb6ec3c97be138d42aa1561b0aaba21f07ed4eafbf85a76da9d22e7d5d088d29e826d8681114f6df522bbd398f4864542a584c1a0ec9cc9ca6656395cb330424f3ba5882c9e2c69bfcecca71e0bae5685a5e2ca7770d9b15210fa7f343e36d9609c559e9a8d2dab754c859cbd1557edb10c9c567d26813cadd549b2e8d982084aae3ad915198ccf118c2a779f247f5d3ce73b0fbcddde8ff1c606ccbc20c2e6ef64d8726c4cae813904c7f4a24b1094d99dc20c448f234c90a4454259bbc637e3877dbeb123856e703b9d490aa2e2473b4fb8e7fd2f4290e326d3b44d6ff9b0d61af3fc6d0c841c17224108f3f5d99ef9bf02fa8707ca1c47bf2b6fd74268fb7ecf515909b70604e4e3b56c617350e64c0d5065d433321dc3c7add315d1ddc40a2cf22f48ded4195b8c218bc38b5019417a290816fd1ed16b2931ea4ed8c0dfb2d00d5140da77b3fa6570df2b66b9d1ff5fc81c02ceaa4c67c22920fc949218469b7f80b008efc870c6b2d706ee37814c42f18f55f96f55330f62f4ef24844ac7c2d0581597e1e58a65bf1db095d211316c1456dea56d9ad75b78c3448b60585b2f33603e942e1b4fb465a1fd62c020479e59a2fe2d2482e719ef7270bf40c989603c11df00a15911be05bfee7ed4b84ca7b79504ab8680be48f2db348f40aaafe117260767da3caff1cad6914ef34d1ff3227549c4711cdbc373051c188b01831b78a512fb608755a1e48824bb6a4b8aa4c286cbd0625ad73ae0a93d2d267da02a591230037378d43c78ea48be00cb4c1ea3f86a96a1510dc40cd35b41c3427c5ca79c9eabee17bc1fafeb0160d2ad3bbf5a8e66461c6c2d789d30f291f28ff852b191c0945b3a34d9f6069d2ec7f976e13ae2382d3d788b919c447a107db08620894e8c8426f24539b7d429bcb7192e35929beacd8c863c43beaff6ecbf29c42b359e97b63ad0be9e653cb9dd4d4c541af67b4c8a094a7639ed4abddbbf3dd9b06430f633f9b101fe18e4b8438008f119437ee4c6c6d154d87ec0085e8122edd129e7b81ee1dcd9dfd7a48cb253492babed1df7371c62d1f8abfb03252a864a0b5972c8fadccc9f925c7afa00ace7f12ca8386dfb143d3042fb97e9b84473cfa66966bef333fd332bef550fb4151f8ea551efcd119dc26446906da0d8433ad4834938dc5be029a300b478979012a790503f049f0ba6f70d8c8af26c9e9867d397bb3df7d24c63b38301708970f4e49f68581d63e253c1cadfcf982805070f0cfffd01f1d8b9a6c3948a021eacecfd5eaabcde9485aef4026f23fc8e704a52ea3934eba08cdd94402e385f84f3c066c13468f480ed2240fbfb6800bf8ee313c3b8a06393e3a33b61391b3053c445f70d96709f48fe8f0656b5fffb0d77154c7cc61d29579fa4b6cc934bec07f1e07749b141ea9013d7d03eb1d1468bf7d8a21b15f3fa94a8ab4c3044e510a6749bfaf731834cd0ffc2f515dea16b7e7ae746c323664f16be24b7c0687a19556cd2223ff25f944f3453210cad082014ca9e5b667ee08f65defc4b244476c60dbedbb9e5852189d13fd8848e1db622cb5b276217502e7c801a1e1b24332517956b46268ff1095a67835b715ce239957e43c32b50a4a441d8d21692a035bb777a24eb595919c12dfd0660e21507444ef657d85b846f8cf0ac4a7bc6876ae688c175e9fddf3a992e84ed8cd5123eed6c1287703747780b8007fe688734bc516d1c5e8422040e97c7be50b0b7c84f190c5393c328a5d5d456b5a463609e5a2873196fdcb957642ae4c1ee5524c18a958d7958d5d4274229d1ebd24797efea40c58824ca1b0d5fd1cf2ae3ce8ba6197615393b0f94dcba12e9bc17a3d491c90af4a948278d57062c1e29a4239d0446b21b3cb2aad47305f0a779dad7937860678c95e8731adfbcacd2ee07d420029febf752627a49f2287f4e74a6cefff0293fc657b97f9b194ef634dd7311fb4eee7bb5150f172307787ee0eef5ba56dc2f80c7ce1cca6bcc8dd77f782bbf418346e148b067f21a9bd4c1178a1efb42810dbb8cea7f33be95045cbb28afb6f28848e17bacfd14f9c1a39dd47301a1c07a46a5c5d46820c8504e5a89172b9c2e1340e5f5122bd7c6221e44dc476197c7d709a43ab6913f693b5c01c9b0f036a5c4e1041464a3375251bfac44905385e198aae2d430936605c01f349e25e901bdc0c96b09b271378728987e308380299fdbc8bbfed43a5d5039580d176e912651f3d275ac50ea2f22d93c47eaacc36a4e6ee35f4d8a1deee6838baae566039f2083d6b421f51a15c01a29fa2bee61e0477f747f2f38214c919d7da72395095b97ed351329aca791db6e8e36acada5e7e85b084d2884a12f5c69ea5f972fbda14b0341cac2f8341818cbe727e8c43e2f59b4cdd1736c5662b7d72ed7ea09f1e28060df04b2020ed8d9839fb44d6bae974bee5735bdbf9e055c23e1aa304b02a803737d48258723eb5d2fc2b6ae18aa8bdfd01f29a856b0b6af661ef53b652d631a2f5893db98a6e9edf84b491dac44b4a4c8982d488bdbcababd471d9c0636b99bfdbfd9380373537751c59732bde76734e2791b33976a548cbaa30ca70b4c1dbd814955aff9e41723686ebdd213b33da06c6135204104f31f64b59fc0cccbe8f27f43f34b7c07c6d3726ac704171a4958b10a758a55c443136ebaa16f535184480705551700361e439566e87f0c3740f2eb2a373fa5428ed3b1f4f94974470f5d64ba51e2a628753e15eb65938ea81d0d67e702f1438d16afb35017ab2f31cddffadb035d6e27ba4281c9a28b5f417b0dd97339c7b1a2601e8f71fd91bcf61fa64b5a29db0312948fe3c8df535b2c8b811f328c71163ef6f6b86615efb4732619f94eda9c0a9a0e6d8e3d0fe8040921dcaafee6bbbf3c3f0428f510e8db00e5e39f3c65e2392b64f34e4942b2d9d9c5e7e4055f10d13a6c02ccf41bad839624c624740b0050cf9b42172a20a7eda38b63eedb4ed9b7a4a6f196fe877028b4349c03abc02f40c06e95dbd60b73a19ade17b7582c814e809bf3eab1aa34b640f964cc046bfa3be046f12dc30ba2d1c96c9051c061d5109be31d756f4f6ebc1a9bf2e831f356615dd94be1c4e8c639d104b5c544bc7bdcc0c6d0bc60cb281abf7e42571bfa50180b5073fd3e980fe2e61e109dc0d4ce9c819f8709b4416d20e151404396dfe973da18979d13b2cfbe6797decad0ad89f84802e5ad6d220d72bd70683dc63330cbe6e6d745bf3bee4b23fd87b54c58b98d23b14a38f688e75382519d1f0748654f36b1c12a988bda4579f70b72d462746bb6a23101e78b6ef1734952d1e2f513dc879e5e63887e2d7b196f3f00282b21aa506329c9abe98482b8a249498e9dd510755bb238be7cecd510b29c7743af09d73f1546da4a0e8df51b771e2e205277a95887b7604e7c94a0f01e6b46dafd3d63138d1588b463df522537a17a898f889804ec1607499f1f1cac3d927e6c3f02ea8abce9f15ba0a571051e05826eb08cb6b3bf5230da56e4b147a662e514ac67271a8ea582dc5deaebd6b5a188468e3476fcd628a2677b7b351e5bf463b36de185ceac3502268eae010a64f08ce70588646a1c829872eec8a71007ff1e90546518ecfa1e7428f233dde6c88714f055d34ea072fac77151b2c87eff3012cc23f7f88ec15f7dfed1f7991cd57e164d371512b75bfc5a4c4ea900104ff7096e4a80116724aa08012fa37baddec00d971397dae34e9a0c1a74e2c01d2dd19fd3e8410f0d9385489167c5b1f529be9b7722cbb35a9b9bb2e665943bd8f7b3379329df2cc4d311aaf84bb0c654089de635ebeec40ff50f906661546da0f94dc334d439deca9887c76a42a274c3eb0eb66c406b326d1e63a054e1a4146552857fc84789da68ee2572b6bdba43a05b6ef7ff7284c80dc41a72eec0cb16653e6fae99cb7d00189a337357824e8f33dd7dd50f87952b17971db811baa51c6ac6a1fe7aa1949095a6b3427d66039e80e8dfb26546601a14dc9e3fa083455c8570b802aa865b9ebf009caed4fee4de6ed1bc5425a4c404da93b9974833aca24fbac4b208910d62247ed94c854f4e03ad86c2bf788098fd82980e07dd33f16e1651019240f8dc3418e7870f90759db99c39d4a9d9c6868755a5a0697a4bff0eec2ddb1b46067b21abac3fba5665976f2c4eefd7a6750727e22e5dde15c8bf25439da8b022feb9035e89cc7b49d02b1beaedfec693ac14a4d6044ead57f6cec166e9eaefd561d209383e43ae5c1f07b049b46cbedaf009fd9417abb7401053785775df4c8300871cd8c77f42acbc7b5f14dcd982dd54c7f300bd9031b3ccc3d87952a263d9de625ea4304c31067933ccc91fd8b39f4ac341d7f613c331ced06fd86a294dbae332a7286afb107d9f7c2b13ceb1f017bb33cd2b49c045e11f9c132bee5c13192f924220a9f07075467a967b98c59a6c5eb0839b2c509962aaca1e58b8042a835be22c440d060be1c30807c97a6fdbf64abfdc782ddcae7faf25bbb252da4e3bace97aacc2711ae48fedb7d73c9dfa71eb560c5d37f85c4b7083ae3f8db5702be73dae03bbca8f7b30291296f043697050e292a281b2b97cddd9d77c98fcbcd4bc40a0092e188e051931eb11d207ca9851a32a027788fda169027d36a1b92c1b1d90ca04a19e9d7770ba841b131d73815c4df74c2814424195c5f5c20545abe6fab378c83ea7279cfe857a37cc6ce25d57b097be8554f572acdc405180d003a89fe82feb246706f0eaec8f72b4985ec6c2f5eb7b4ed5954d48276dbca4e75fc7422aa8b7438a0a3679014faa0238ebbfbc51c62e93ae01eeedc049caa07adcf8d95109d0b460a84ffa3e4e616db3fae8927140723cb1ea5131f79376cdbc56dcc8d544a8e35cab1c2c91794b61b54dbb73c4a0bb7393b38ba78b45f61ebedffa34b328e0446bab53efe387aa0080563ac48a73eecf5fe0accc72dee4a52ebb3a41d7886edd74fe4692c09255a5ebe6d473092704c0211d15f2ec791e22f8a9daf868269ce5533b7d3dac92e92be83a99f7cb0b990dc8448636411a8089bc53373afd72f5db97b0002cc94dc1efef987d72b9f65885aebb823cbc7dc54bf884252f95dc23bb3d1fc37219e214451af8a8892b34a791c739d7d2e703c508bc2e7d1e1336f5d284fbae070ceaed4fde84907e0aaf33764060ed073c48aad13a6b61d425367e5a872e6fccaa702411c5ecf96116f792edda90e5c393fd6ebc42aed10d65364ff698e10f32a50cb0151e0bce96af32eb5000cca563e4b40d391c54477a94464feebcadaf1c5084cf8e92bb7c8b199c053a257039bce7395ca91e13e83943c6c43aa635559ab5540bfef63b8fab3ed7d96d76334052b1e31fc1481e1e126cef972c0fa3b8cb2ec11b2d31518a9fcd68e9cee5c2a47897091d1be1e51bf5564894961ca935a3c76d6eeb7eb544a172d5edd8f8c1a2ff661718b51e56b2659724b82e23e5acfbf1771b868980c1f28e3ba1815110ccfc5c3808310f70690bfd96a5b44a413fd668726d6b33056f65f1f209b1a54e2edaa293251249b252f822634683683e7340661ca035899e2a4fb046cca32585c1e249d9ef8265175af363a27088c0a5c385f870903c97eb72af2a5515b24e72d14adad8e7268e667033a21803d5d6980288b17777a3f279e93e9d57c0027a12e7d0ae01c5dee998291c2a7329ee7acb182d9f0d4547cfbca134950f24ef38abf268a6282adc77b276b17952bc4d103e5a243c9ae9080760163361cd0b5ec32fee9f7eecbd2e107e65b47b1c9efd91713f4e7525d47bdcea6a620cdd43f791ef75f137c674c40f76e378eba305c0232fd22778672a3f4f8dd996326850471091fa599accd34d5abb7f3b00e45aacd080d74e41d78deed0e4cee3f566c5f5091ab9a9cc933c24621fe3e5f0a9f55deeee9f8996d3657be4cb4749f96a74ef62ebe4d14712d29634f67cd292406b13b8ac9fdfe22c06c741e34f5ba3d390ff42d45c6c51124a17239f243aee8f7329dfd999efa862df5ab6d8e21c1288db0c9903ac68442972948f1777fa909131a9c3b59b94dc3451dfabd96c25e39da6abf07ff121cff7f2cdf6dcf266220ab2334a797a89e7a3116be2aee50675085d41b1440f088ef4d435c67a54f7742ab8b1d9c203929204d2360b9796dcfdcaf94502ad4b5a42cebfb0cdee5329b7db73e49338a5a3d4ad126c9d1859cf38ec69f0adcf1ef24c01429e11dbcb971ab9edfbfec08f587596ae3a8660d29445b1e3979b4cc0610f56e10ed4aa8e1e26bbbaccff08f629c83f2c0afb8bd34b85947871518e5f60c77bdd58ccb66c2aec6007ea0df4c3493506b6bc039236b2a136063cc8fb3d58e99b53de18a7ac09a21d3c6c54de16d7a8767cd6a182e6cff012851ebf8760686e1b5e107b70ba4515298fbb2540f6bc9a14b935ef8497ec190be320685c9e5b7349c91dfc775a15628b2ef27e69a7549d22eeeab91a45116fc9298e9527e203a88c3bf34d24d3bc20b5f31e9cb5ab020e5294ba1461bce44d61e4b2991b632a4a7c0d8be9cbd4d514d40f9d4527f9006a88b3ad4a044055d6459d2d7905a860c5e02f250aa4a695465676cd1d3d6ef172ee4c7566406844720af7bbca0a0cef9dc663ab369e15a7090979274089250bb2fee7479ad97bda21570af5ca57f0323a29260b3813a71876252909aceaef0b8255b46df8636785f18657efa81dafc966e45c3987a8bf9810c642893a88b291ec80aad79b4e6857eadffd495a56ef0a1cb58bf3b30126628b6cdcfccf3380fd59537d17345c1e0b787f8645a70544874c2021a5d02030b2b4d026ace096fb5b72ca4512b1998a398b3e15201c6801dc53a1513ca0aa261483bc2649cf2a473524909761410f813fc1cc26530f631c82870765cc355cc645e6fac20d08949e38cc6614a4e7a555394e9b21d3da02c026b4fb215e615a65dab9fec8cbb4eaa60750311f08cda471318a4c65fd12d440532caf64ee671bf31f54102d13e91c45934a79327df4ddb5ae28dbdfa3cb86efe80615289e92ee76e682c53f8ef16039e9f48d7f7d60d3ffcec3ae8114e389ba6c0fad0ac78bf55c2e9e72a712cb2cddb4aec12690adfc4f361af32ce18b7058c874f910a5d028802566fc3ad48dfe5fa01db1186b92a8ba67e75dc5e41a62fc25827d3aa74f4670f9f47e93bdb0916c88284f2df5f375ff10784e2c5694f07ce38bb7d93f3d573042db51b8c83e18c287a7784eac32c2a9c276658173d61fe7606a9ff6693c48c3401a9f0c246e9627413b38387ff710c11f75e3fdd310d717eae6ff40913182ff14a85e7d916649dfad2e4df0ad40f1a4c735d1e356d5829f99ac93d954512d9f9ffe91928bc8c70837d9abea3814881c24bab3fbcee55c46aabc6c91075444e003773d99a02461f1205da784715fbe7047aee902364c1e84c14ac7cbc6f6d48f38107799eb8916bcf64f87d63624260d6d552a0b1eba31a0a581d344645c5d0db625de21e0d6fe05d784536e0cfa3222e47163d1367df08fdb37652ab5178992f3f959a11e17235a4c356dddc2f0b22eb8e9b89c5213f8234fc8d5b4bc01a907b9591177eacbe7a670ef9fda0b4cbc9a85dc203056f63aec4d18bab06a3c2855e7667453dd27a2ee3f44a440c496e1c2e6c28242860796208f35c07118f2013f12183fdb50bc50a82d1a1d1ab996e95eed97781aa821f3bee101b93ccd16c9bef590ccc7fb4cc6763cdf8393467bc9011bb49f3e6aeff26476df44321fb45144dd5bd2915609384e2b05f141c4809bdd271821c50c4edffa84033958226417d9bbfdcaef464460fa5e6f7f71231876c8b058c71c069b5524caf2a646def5a61fa67c0554a9d4a69e26ca8412d100fc7988b7197a39c33ca7b0deea57ddf1c2f6e0c869618e3a4de6bc285bdc61c4b9c4cb2f58a761a3083c3f573ac9620f62ca68946a7953cea79b1f74a526b69438e4e9c9e81af31df0a6b0e4b383c0351e613048088ee55b87ebc17ab59e337233f906d7c978e8834fc4b18efbafcc1c4342ee6b347939fe150460773bd2b9221839eace7ef38c8b1cb3075e9781ee9d60806c48e4fd72b163c0ca29326931a00ce18bf93079a904f772c40333598ed33d347a86e69383ecbf06446a1d788051b4137701be7b440a8a425c94761aa69bcc3572a20f43c47ab8b286dad36d42e9b46570201997de9df27293508752513153a78b8837c7b2044c6ccbbe51168af6a798e5234377a872e126ed19a188368d18cd61629884a1263ab90e80704ee72e1ba29413dab10a97544ccc89855e7ea84dcb541c32164791a2bf65adb5afd89d7dccd85b82bd0ee1281e9b52271c97a16691ad52a15ac12ebe2e6e2cf0264aa9391148da12657fefe75d88a11a10be4ac54352f94e1b544ec74a02bf14606fa00aed086fc551a2f4a7db72bd3e62eeee99bd89d903c9c6cf6cb39c6dcfcf81363dc273227f14002b3a6d8610c5f78e323e539ff83ca063837b7dd9057e7f82f41e1b1711d5ad46212eb4de31abedc70dec8e8e7d9b4756df3178adb75f64b083c7c9df85540ecfa53356625423629904c7d212eb835d9ea51adb174b58f775e0949a861165242e1aa2ac2a130a3001f58ae8cdf841455614e02e4eda4decaa2588a94845e873549e236335568a21fefe8e15f62dbf02e73355864c8dc9b1da9dda8f726fa2c1222d7dc963fd98122c49406f55f2ab76543d166545e81389a0169e521c760356a2eb6475edcdd089c4af22d53c595fa2c52bcb2d4352adf0433595cd3ea1402b99836db2480dc18af6920fe6ca289c403ba313902db52a98b2c99cd71e5bada2796bb1531bc9c5ba1b40230c9785b650f7f41c11b70a68f6da8ee0bfc66339421b7a00b2f280106d990b21a9291e0303316db82d43be4e2d007ed1677820494cfbb9fc7ad0cdd40255f60060b69a3f3aecd985ce98c94e521c2f24932545778417314930ac76f9e9966dcc1fa77dbe168ea08bb3f75337d79a1d92e4fb30eeac1eb48074daf846518adbee9421078fbff32c054ccc4010ca7eeb9b5aa8126c600411da9323fa58caf4e907481770b87beaaebc658c013618e842cff4fca969baed83e7355047cda2341b780c9efad10b69379e748e4ac9ef20f9e8a014fcd8d91f6aad6abe50e56e2a347d0f8ee69a0c288d773936922e9caaa73928a0010f7d6972b8b44a2e5fd9da08e7beac2d3c09c29412213cddb4f15994287a56689bd386bb5c88c96e7ad7cfed39723fbe2de7687e4daa5985f01e4b0b1bf7aa282fe68304c556a0e6c8953e0282a903ddc6c390f4e5a1ecc1fcfcc93c50660ff7e67c3c5db37b875867c47fff75175141c9c11305f41c9414cbc521abba3cb017f5a0e5c996ad9f05ef6be21351b321c2c5c001492b7ed5da3b3fe925615c5c36e55a899e2ed66f4cbf238644daa7d88fb0739506a9017381449a39511ad37df35d54b8cdf823c009595b4c8ab8a1653e7a0287d09825b0ef7b1b83a923aa4f0bb84f9a7aec5098cca8fdaa17c981b7ea89d1809242f4a72cb47455ef902c164cdc6617977ca4efe89b9aad1279bac0c942f2f8711e08b2141d4681edb26c0cb5d4691f851159240fe44cde9ff049eda383aab7cb90314b5b966816fd0475f93f7d69da3862c18ce35811c21f1ca527e4e12d9f3445d12a58b152e94c3bd0d8b281b91b22774c5e1bf97972260cb9e68f4d15685b1a9f723f4c3b877f09d8a481edfdda3e16265980113e705a61d0e9ff4f0a538097122b2231e5402a713c9c84198ac3f4d831d2a4b64c5fffa82b7ae2ab900bd987ba5540150082eb2e93496e48c0fef70b059276beda9b6e59ff648a860e09596b25eee6305ce7e83c3327be18fff8aa21272c2bd5174eb2f54f886722c6e56ba0e87a0be1ff6c852a9a8861a04d1343e02989fd40fd6c83816046c99cba9b117d7cd48357ab715aa2b7dcc3b0659da70956def69a04d3b2d506ba6d65d355f6e1344df6e4b36c74dd3dd7ce0950b2b2de0d272925f8f7f81c30fcfef61c3a8faa4f38188194e32e6b2158a77c01d7d5770d4ec42bbc93f90808245dec8f5e575ba28744692b0708d5b29e7ba81672eb75d722e81aa18e094f54141be89fada42d093a9fb922e5ef98d86267cdcd9c1e26bc2ff4ebb44f0c5c50432540dfd398b390dffb45acc5e04887666447638a40b8815120ae743b54706e92fb940b2baaf4a7fb78a24ba0b5fc1d69eeefdfbe1ca91035f30b3fec89e1453ed83a5c67e91bbd0a9e56c975584051066a106bb32c52979b2e964dd71d4aabf14887ad2aaf679d36648fdfb4791d6185b7f8429fc2f43058d95b4eb26af81ccda460eff118f0ffc95b01836606cd444f1f8f9a6411d078c4a62a4a8e26615ec9b8f1da0a27533c2a67dda319f268247dd3611aefb9059bb935513cf5dba682441ac604728ef07ca43bf461f4c56cb10dbd2422898d4f1f51a1707e217e8f5dd568f2d5deb831fdae4e0638bba73e372d2f450ba3404b096a9fe15d27ccadfa57741ae5e637621044da4c01c6eb398e7fd0c5c4bfd8af28211b0c8496ab84a422b7b2e360514a720c744055b2a8ec581a6f1ef2e1201f76692fb2145edd4f503cdfdebfe643196bb440677e6a7e54e27cd507a20be48f013e9f8d7c6afb7736ee968b696a7e1b2dd4d010f9793855604c946b8c6f846954548fc267b3feba8bb0d80b8d8579dd87292e61db78e2672491ebf71d29e85f50faec4cd8c1b539788c602a3549cd98aa495f71d9040ed3eca3185fd971ea88e5eef0ed82340a69d55733715c9151e0770935a17c3ce369b5aaaeae6337bddc5f04746b536bd2ca5e9605b608d240553842b82a3eab39a552a50a7b8fa75aba5a790f25c72a5ca96ab58637ad0d9eb5a5e4d03ba4ed0f404dea85404c5d06b8da55a2eb3e07a0f0750995657a0eb24c7e352940cb4cd1b7a9e0f3b7f7fd5329dba8802e608c9810c874f43930f8a5408de8ab75a30353c8d34b6ad83b687b17adf30e6dbd261feff95e53752b0caa909b427aa6197a8afe67521fef627338d738f72c4cec8f1ee495385bf1c6eadc2b58eb8a8656ddf7669cb604ac57db0c8931366e6d00e25542c40bd622708f42fc7d6e1e70c0c4fe76dcd757c9654d61c967c7d27517822512629099b377ada18210f9991d025247e540a76e1d2d7aa7a9e8ea40011473c0292a40281da464112100a6dbcc5db68c982504cd1a720b6d0c00ba061b8737269e454f9fb280cc440d68725f9d44bf677aab9ba62e561ee53e0e48cb63c221aee0ce80ae819df9f863d2ff6c5f0aced75e9a9b89b9d7e8d189c043cccb418bf6126d817378053ad4a145c4ddff56296f5d1499c1de038532501f3331f2eb486b0e7997845fcff9584767e418dba630a107cd9407aa90d8fc4b9dfa99f3de96309d98138482ddb65d492de89e7a4b6ff807614f7b4bc20c2070b610680d95363d678263d77571593a6c8048ad73f71ed4c41e201b21771994bbaf3efb7380ba994a3a78c62b4a1a74a19f2cbd7d6b427cb00f10caa46753bd8e908d13e2cff05545396f7a52aa35248d8796cb820a1330b84d16f8f79fab7d3326e9c3f91851f5865daf561457cbc11a7583dd17eb9784f63d3d875a63edc268995103dccc131faee88343046a95ac438ec0ddde6ad25467e3f95214cc02f863d68828e76e0866e71409241fd2722ea26df16d1cdd752139b4b8e9621df75aa2eab4ec7c579736e29ead2a99c7bf9420839b47c7100178bde8dfe9fc4e37f5682fd45dc3aa339010aaf19fd526c8530450317712291b9c4eea6c81c0847f5140ddfb48c1eb2fd9281e05fda4925a2c4bf33361db1a249e22c54011d1f172ee9b28c8d28f0bbd451323382bfd3fb49622ce0e1f5707174840c0ca635f9fcfcd456e0fe803e74b4a0f8deb32d949e6ad6a75a5a6fa1d155d6a0d962a4b1e1941b9972b713f6a70ec45a87e929fe796ba01f457a151b8558db30f1a0a29d3d8233c64ad2aa8c424204344777a3f4d635fd6c8526c8fcd3013431c04fd25ed8b24d119033da8816a2090a21109e6145cad2cc8e9e715a0a0090db15238397833ae115ea5965ff843aa3fa657ad7716cba5e402689a9fc873e2e4ce27683937678a645dd9142ce43c9b4164c34a8c6058d3fc7a4fc3e7ffffd694cbf70d1258229b86c345dc3211211cbf038ecff799a3b65e035884c006e4d3ca305321a5682d36250b4dffee6127f3aac3890162156ff65a6a4b5133ff9e61f2c291ae61b3c1dfaee40763184f4fcd6080cf31bc0cfcc60dfdd803853e28f8925665bb4fba18cf119ed38c1dbb1ab7d6f4cf6d0ebc9b05b8b6f2a526abe5be29b2423ceeecce8b33b03a22e5094f7493fef69ab50af224e16071a41f98b1c7204e91984d82aec693abd2499e2be72f5022cc22024148c47f526b0b524758ff9c05911693b654a297e87947a6e83863f1acdbea0880e60fb76feca8dd55f4a6b19105a8cb6675cc6b542ee337d24a5e74adaaf06f78d9d1ebd82d66fd11db48ba7d38d630c2d4cfef48e7ae3e954bada95c93092933a926b52568638b1e0ca9930d9c0a1fba11da64571ac8bc45ed62aae545c4ec3fb3a64330ebe1cd13258afdf219ba734abe7e22adde3ac203f9b0770b8eb8b5f0a89942572ce947328855057073288d5a928874f4ff23b4b7d0c545036a3b5420d7796317582c4c8a273a894732a662b920966a98d6efde801ac052297a7789f870af0e7258cb03526b5be5b8a09121f6b25214269f430007e8ff76e0f4ae1ded5bf44e1db69465f9f824b415749b9bca2c4120dfbdc48d5b2d9c7ae5e35d30de1a813e9d80d9cf76bd5047175a4a8fab384d81bfe54c6f1003c291ccd3a0153fea0f131311de96084e6da45d4af86a7f02f55fc5767f5f3186bec00aa24a520b4ab012b093754b7596429aaf75aea052dc69b02d4e5b60634936e972859574f6860707b3662eee15b364c2d011f292dcd527e825c0e8e75f9ccad7a560197cceda19e769850d2fd88b0caf17337e13a9177cc1e859df26500f2a2bb5af1f014535e5c8afa14a4002130b0a5b2c1c40c40d2b000db7d794942587a1d7e525d313563ed058796d751e1ae195aa874bdfb632299bb06e9404226bc49c2f885aa173397b68c72e0d3da832d5f7e775352d632939e687dce5205d85d57f880c8930411d8a4aeb5a18cb097c010c2741dce22e3238c38528cce481427bb00d9f07ad601d87b3ee5f5858dc63967d5f5567efe6e4c0bdbcb9187d5117285368b120d2089fac673b2f0eaf311982db86be324f0fba01012bff0cd3440ac75a63fd6705ca22e797069eb6d4cda811287c899a44bac11fa959a190a2cb46643dc2e2f89293eaeae616f5323b425fb0d7fa7b17f4a7ff87fa936a884c66fa3251166a9485c7d1692d68cf58a24c8bf5ffd957d4e47972b5727341c3ac570ea1e789baaf92d50ef4d13dc5690d0b2abde213d4f3213b227db0c1cde7cd82ee4ff6b0134f1787c21718148a32cfaf84aabebaf89726ee60fcb25b428d18cdcd8caa9480bf15933aaa98eaf84266855c6123b6d82dc49ce5b856907ab1dde9f03fc798a469acd6ca395f1da7209c45009b5086017f03e4eeb05a501634604b4bac6835186831e78a35115f122cbb0a3b56ee3307eded2ce1727a3ccc75e42c1572a89bf00b0b2b8d0fd729d5a300073e8aa6dafb8e05f194c5441e183d73413020685204be46457cf1b404ec4877500938c849dde3225a9147d3241fe69d5e218f78c8a47ea142c69a1ead6a2a8fb733094a05a03a6c273d8140de9f4d9c0805eea55713560b0108d70a4f3a9b1803efb0ca2df72ddd0348bb7c7b84bec5f879385fb86f1ad631dc1707061f648668a5b7e5092a9f8bca9b67964f1439f060cb12bfe53f17234824b865928e11f20ffe2feee9fd571266fbc04cfe2e78b9006fe4c908da0c9523c2eefa365a6ebdea6791ae6779118d1dcafbd1046969e1a7e43f7acd751dd997cd30bd75a2ce81449b573e654533cdf92045ff0bd0b531346983cf36c5ee03d20028c0820ed28527d9de6c20758d0984ccd6eda43dafe4e8dec4db06e9282e9e8916ea59453621d03a2236bb88c179a2edbca37073e1e91428ca3d41389def4359d2e72441f391ad864c2d475a33953d65f3b5380ee0491be2c8edd7a3aab0a4dff15cd163fba40a3250faf344c2277a4c182fe69d64c9fff99a6024a35f65a58e01f2355a64f8c8d435f97074d291fb247e11320568d225e4986bdd7cd652d7b137968d413ebd4aaab24f006ba9b0e73062c35cd338b7c865ea4be34e8de57882aa6822d7b57705f6a2736d8319900b7cbb6ca1824c62435737008f9261f57b2725dbf52ff11c84f62d4caef3499d46a839e3dd5dbc5585bc3a27028d2601603b7d2ea458f8fa6fc6812d2ff5f5567b84ffd699d035cb9b70c02e1d148299ced4145382a8adf25adc62840490374fc88a22c25f4d828be2735566b3c79180d9709a1c9304c6faf843995219b752e7918435d025e0710fcdf2a5ce3cf2fc1231175e672fc85fe5930f6482ea143d4e1c537c4dfe686280c7f44ce860e31df52eb910582366cd13e2da62b571757c1e658a459d3db75a21649e03e78e18f6dfaa3118727561f44460c3722294c6ee9d2d8ecc79de0f2faea5dd1f316c7e871cf4863cb6e64a65fbff3bb8b00a82864da8557fddeed359d1c730dde88bb3449127cc422acc783c644b49852da73e4151f3965d4821d8113d6162d4f548619e9828b7bd3c75e6b6f67cb95178c47bc4e38b6021152fca85810519cb38365aaedc30b3b1e194ae10d74b22527341bc75601722785fad24dba056ffa0cedd7c70b8180dc339161acd7b183dbed28cdf9585475b9671ddd6556555ee19b1753b8aba26ee7d4c39774834226ac6a2e9993f61319967baac853e8903eb2b8a046f7968d909ef351f1b3b0b6d842194f2c3f6ac206e4ab1583489d2a3859e9da10931ec883a079fc2bd4f5742bc28b7eb8089a29d8a638eb2e0e2db374a0c0e1eb01c4f1058524db41ed51eee767fca34a57e4ac1fd1d02b00959cde555e14c50b80eca83eb9cb81e45ef3007cfcead66518fe5aacd83d241f985e1db89b530e45194f9b1c21222b62310be4031b659c0115dce5ee27b249aab6f251befe6a2150787e990686818ceb110fa0662fcc90fe025c793c3c062302517a9209aee35c39e4a5bdd4b340d0a303edf1c9f142eb8a6019235bc47b9e968a2a2a2b3f9f6c64b43590a70088379b78fd497f1fcd3778a0967d2982eaf5e1636a7126280ba54650329bfe2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
