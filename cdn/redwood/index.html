<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1d59ae746d1c41c579afbe8da5b53c2b94711b9b7c02a2fc00231c9199b42b88171c276356dc3785db7294a1348b073c40a0320a8f03747aa21db546ccd28c55daf6d3e8cf0475159eb5e1bc6755286edfe3f3d099b8022d9bdd2dd402de1a77cc1747cdfa1025a19b022c742c07a66006032731f6c89000b806733b9c60657247f127be187473637a269d81465e11896f075e3d8575eef535fc9824eea2ca37f7782b6d9c310b447cf36621b422c914bb4c860539ed09aa78fe1fc471692a585546ffbb224f8579fc47b1dbc72ecc147235100826ba1d385d8dd6ed9a3d484dc3b631e1633f69a908f15c43b6b7dd5f158aaa226176b0ae0791804b8329ee5226ac778a5978446e0782056f5b60b7f42778e15c53e49b647f108d92466cc5e1c096f9faa8c9608d02f58e877a05169da00bd10ea6a60fbbf1431f9f87f5cf1b376f1cf3f1338b759b928e965695980cf88d70e9b718a197d0a4040bc854214d3726968e7f8c66e7080795fc1b03decea948cc6a045bb98094101e787aab80e831e9d62adc5a169921e4cc598f3d37edb983454a1fc86b4ec5a904803ef26b590e0da44e74574045dcd4b8da76c1b6d4b6a9d2344729377bf14759866eb9c9c39f400b0579a1269dca2f4fa88421bae41f62b27a75d71fdc6cdf50e0ac4940148aeeb09901d0f0a094e746bb5a92ee8ea8016f6ae6f62ac8c657c04929f2b56a51d3798d9668026eda0dd06e725b7a8c7858c36c5e08dee54e538c9ef299a7b6d8149dcf0726beed5ac65b482dce366d750ae51c0293ebdf70365ada30d83926a0d072794c277dcb64573d7210af61ed0a648cd72942b4de64f7cd0864c81e2530e40cca60904e2677d5b01edc3eef706757989ec8da6b9c1f27bc94a648e6a981196a678ee3475f4fcf5ff72170bc520bdb4bc6370bc5c4c1a9a1d93a4b001a631ec08ad50555f229391d556c77566ffd8c0b53c7b721edfc6f77efba2c21681ec21ddc599aa3db7230fa650775eee4681ace497dec370ec6860acb2396fb2f3caa5dd6fe700673dd115df922e666ade5460ee6d4e996cb4896299f9da3511d7da82c197e6bf0240ab23f6ab9916992ac4e8d85be513ecdbfc3d35111a77e305062ac6c2c1d9589aff8b2ba7a56d47edd2ad94158836da0e76f60f00675797d063dd50fc1c2b5acbeaa53ae7e9c37cce1688991ea6bd414d53f98f6fa7ab2de6787c1b56aa9964988c9180fef00fbc34b464c8615fc61d825b1ac9f36145df6cd9b684e20af80f9f49d3c05f11da99ed856e3b3c90a7b35dc1b7364f260a679718da4300063cdb4239bdbbccde205de22b5422b22684aeeeca185b69084d6c658217dc159af8e43a69bff394fcd5683ceede70b879b09b48389c29e136e8b33c73da774dc9f7c2e5587a57107acd00c4086372f855d990a13c308a1c37aaaed3ac69cadbec4f21bcabdfe3f86aacebcd35f0e64d3eebce3f06c271afcf857601af29f99b9fee940ea9cc60cae03a35598feeb632d6000aae209058da9c6a7b7278b6bc56cef3dc72a3531e5d06f0698618bca8a388821a9362f3f1c9e87eb3debc1ea5987f2d6e8ba239988f120cc8ff19cfdea2141adf54f6d00b738e59bace73b0773e07a3543ef7add7471b8a04dc3f42403b258aebaac466644d91085df2f8f3ff2b4681ac6ca538b70bdc4e7b513d38209535574fe911014a1eaecefbfbd52989ae9787ddac461904b829a9177a4e073bbfe86bb3f7a815ebf5317296b03c4ac434697487091688fdcef826ce303bab8e398c27dc4f84c4e280882f143ce4b218637cc84454f387dddd67f70bf604866f1cf15b00dd639edded7f5ee7a47416c5e3e9f8a4a6a60e8b87c6d1b950455fc21914cc47e4fa39dfbc9b5833d6d3717cf95414e6152b957495dac2543761b60bb563edfc2582a218c812e4309a60a211a8ac418316c26e1b356ec2f58b91696a75f138df5ca1925b83f5652a7143fde5ae3a9dfacab65e530db1a2d290142ca92bcad504de0513121dac47b3d3137448fc98f68a85a6e7ca6a0e9c177e0a92032effc57ad70b268da441bc9a6b49a3d8a839bd8b413fb17a60cebd45f5b075234b116d25aa652a087430886a944b14743d34674af6a72e5a76424144beb9bbaaca4dbbaa3393b859277343ea584ff43c5a7d66cfdefb9633385498b8486d45026aed9f6919d41256086533655dd477e5f89b872cdba3744fc77353b7745eac4b842fa9bccb979f2512d1dafb301076cc10c1cf379dbf8317e681d3e7bfe8db5ab57d88236719ed8c21d6e17e75e81151f7ad8a098dfeca7d8095042531b56e987bf1f6a74b9d7f277896fda533e00c8bf8decec9b0f51cfc5d4cc769f2d080f2ea8d930a252160f1af2d0c7750b77f0f4927ae61aaaa766723fd8777ddd45efabb86ad41794fb02e1f2e3beea8ba8403ab4e10d01a14021430a9632725c05f583b68e7b9570c5e2f16f65d95216ab8532687a7dee69455c95efea4113e163a519ec38229d4731996f7f2e1ed33866cd4681522e38e65480b6635409893e61c1cca4f0c20c32101613e16364094531da43c1ef8a1c5ecd0a55749bf857f3c55e78ed0fe76f2a3415987ad66f92dffa496865339e2fd94d4ce731c5f3c27979374dca3a4b38a22583f8e3063c792d2e3bdb75cbe113b82c5d950819a18a20d5ba03c0bdeb2b02b0e548b3b254b08814120c914db20fb0cc1d1177d63a5fd5308442ac7b8dae4f1eb095380df76d3cc968403ad72950f02bd324038b322d6d041c6499f3c78798d041d9ae9e308b3c35ee99ac9b7752041f69c73f67cd18fca3cfd5077e9f39036139ff9568b5912dcbe51bb086b5990d500379719ba8f09843f32fb6c47f2ff1c0a9e150ef76e446216de7753c5017735132c203bd754c915fcdb6b8ed3ff4f48b2a5b721a61fff4f8d168acfc57af71df6742b353d15e66877a45cfc6879c4a41db725a91e37a5b8a697dea5c1f7e5c005ff9f930955c58d9b48f927710fa9ed1c9775d50211fa297b7babde2bbbcd3e90f917dd81a20e4b5c587786798392fdb47485a50727d69231a4d554d5ef2d2142015a95091719c13cada7bf69c0681ae5b824963c5517e9f9f2bd606346bb984470d66a54e3cb67f9991ebc9c03b5e29c1132eaa8f09d1c94ea96ba2376957f0e5c0c07337f81271af75c3b3bcd08a4e3d494fa49393865a839d62d47c38502a1fc637879908c03b7e5311bbbbbaceaa896df140a5845e1aca02ef79162093a861dd25a0c9c9d59d72f6d684bc26be671227af563a4dd6ad11ea081f4d08bf4ebe4f08e5700baf7ca6a26f4df416bffe8d842c44de95d43bab353decbcc989c1a2f2d70575143a4b919e4b7494dffa637420c140f8e7367765d18a630e45163c99c2e85e200ddc273bbfb4875ac5f4fd32951a0a5d8d67879be821a53edf924893d85dbc4db8ddd96fc15ac9f6ea07fde8a1808b8d8fb932f8150a63815f6b72c981ba6b03050a5894c6a4d106c288d91d69b2ce275dc54806ad0a5128c21c6025f4fbd94354b426c6a91fcb47c88882d93438eaac56147774986f55cc7f8ce13512ffead77f6b482436dbf52592130943cc303a90b68a2d80be28eb5b1887f52e41d40ce99cb921745594fe5a1d0b283c127ce4a78993cd3752fab8e06854f87ecba9a94cad8b99b321d70e6ec6ef5bbca65804a8cc50231d6be1de749676fc89aff74bd01e7cabd0b163da281c5a224126225f4fd84fa505d21dd56f99c0c0a17e61c927abdc03ce0013d0d18af25ee0537e2b9d4a84263ee6ceb4218035c0e9ef01f75bdc72370f076a8200a2aec41f548875f96034e47805326ac296178228e43dcb44c889f4d4b9ded971e22fcce3621874cabfda1c5fefbeb063cfef18acb84f9b3daa38689a9a1188cd6b94f871f8919339ab953ae563513310b5aa0447a50ba6552022ebfa63abe6570cdecc3c0bbad42f3290456cb4d6176051a1b9855a5ebd660bcd9cb9ffb3deded3f88b4d7bafa40a894bc4b4754b6a22705b6a06c57ab1de3c925bb7d18e28872ab87dd50c0e47facb6cd48107515b6bbc9eea962e48bf1b390d3f96301bd58a7f6a0dd31e892e9a64eb3605d0fc3596e99d2bb8a849788219f5e6e4d4e2b7324c35c676b50b429781d28c0a24d11bd015c4f3df05677307513b606fa63f493a2c21ea9fe4b3c3f4c8d3f4d73ea7f6ca1136caf26382b179cf7e64818efe7a89040c156a5120718bc9216fe9b42a3d75ce79240d286af92ffd9a1343afd711d986855ecacac5b397d39518a04bbb8df8fd73614b4f1a1d70c0df4284490683bb870b9ff88bf2c970726d842b9849979eabcca78b58aa006a24def85b3f86e63265f7a8260e1415678cd234e33d2979ae3f5ec7281d262f75f2cc82cc9722d6e944e295ea2b6184c7dceb37858713387c5e37bd3db57e08b30e6ed8d249ed1a2f30cf2e95d72bb346266320e7086a2c202d4635efc510f81fef6f767c932ad6f7b6334eae7009a2c8194a94b24db69b9fe41d0bf1729ac338e1cdc0c306d0f5a1285b6a513ed37916f9af9cc1b6ed27ce499f54bb332faf39079a75c7ddbad648e2a7de3147ddcd75f1e419f61f9b30fdc2ccb55f68f72397385f2eee0402ee2e9a2b5f6bb9fdd2e683fb25a6cd8f4c0486214f6ce3832342de4ef33f5ac9faf484eaa0004c2319a16e836b731300c0c36f050dba9e2406ae5eae6a561aaca26680712af11c5d43998482488c28e7a94c3ce902efdadd4edd8194d2d68eab3e9a9c1f6de33868e8a5e7eb548e04e12a4b7a00ea3870b13e60cd9e289cf5eb928ca3c675473b88e90d8fd1ecd29242d5321c3b9ae5c0f78b419a13fcfaebb57928fa3d619cff63c39b3797fcd2dbafcf703b7236a97a9b5618a656387487b3b4fa60f592ab974b337e575cc77ff1ad52f13191253a82bb1373e40096e8a1fb2e4bb784d6ce232ca49d96670491107a34d841d0d34a4273a2e9d6c28868464b35d37e4720bab9b0085e1334badb017d6a24d37a82696db0fb16aa69778ce81db74dd9de15ee84b28e8830dd51944d42de71e618295306b0fc18f012972374563390d47093fb1d988b47f5fd8a9c388004eb6714c4492625865323ce64fe1ef4575efc9f0052ed38ce778cdd6c0cf600d22b6804ac0827f212e1c738c2a63265ad39e0c94e74fda13ff6d2ddee4992299d758593538ded01b003415a5552fdc52b42503058398b75942cbf559eb5bf8bcc5cbea6243ffbbdca85a9d77430ad12a99901945abb341e772173c9aa5780d19137f36417d9e997ae8e9aee93f1c96936760448465f82990bd9c7c0c6e6308f358c34e87320c4893d64c0164953ec34aab1c598779b12c1c47eea5ee05c841c2dcec6e684156dfa8bbe630e5302c1020644caceac4cbbeb51991b6909bd4a2ccd1bb19ccb54429a4d998a9caf5b55adec5c605e649e6da100bf008f313797eb02e8de283c0bcff67d7119c1e12e93f46616cc5efc80159316de928dedf601d14b07023f72d2672c3b001b3415b902bbe24446672a83864893befc2385bd01c2ae7d92aead14e61f9cf55387c89818f41c8e91ba9ddc30ccb81d80669c22fdd0d8dc015fed4c9d9ea06e20f34916dff4fdcb9c574fe989ebdf8b01b6ed5972639f47578dd0f0de64ad9e6759fce811aef10af56dfc11c1fcb98e6c0b73e4af6f421c3b794e1dc9aee6938bac66a5d437bb2d62c2056d1a9d6ca46990e85afbd941feaa8bb4011c3223476f8af65b6dce4b93ca38e5229197076925c510e6849474c3c5c945e3f3e2804ee1295aac71f2b42cd37bef1d96575f5a95fe29957da32766aab1dd16d11302e38edc9260c4386edf1f9b66073885e07bd163f4ce08131c31ad7f21463005d20abc5c190b0c5e3c4efee2bb751015d83687be6c69b8442bcef98ad8b734b9260ca688423ce9edd66d7ed80a15f920ac2fe20636b9f54f60ac272149b567199e7b853faf51b6f560969fdda7604fb462a0ccd6e970bf306f5a759ce29f7d3bf536f9260d556d35c2812488b0ec3ba11f16700b3458f2a9ccffb760f39d8fdad821c27b7d2b12480e63e894a7137a0ed14580c6548194ebd5432dc6c35aa20e3633678271cad9a97409127bc466a6d32a673d01e48e64e8f4d29ce8ac47ff5be3071e23cd1ee3fbcc618d749c0656d19c212d80180369f1fa6b2a1aad67abed2939425872d5a95092653a2e8f2bf246cc550c730a73efa5bf560fe993f55284db933ca4af55883fa34bbd482d05deff3cb4a6cbb9655e0c4ba402569bfbbf6af8c18ba506c6981a02133d168479bf5711a0d238b4eb534fa7d78bbf77e43d7e49dd1596a18c4bfd3782c7188e482d703215d31f568e1c8728002cf57f2221a8d6ed387cc3ca98f45c16d4dd5c9738799e784b7be4d330e6cd85ea8880539f0b6165ad5166670501dd1940234ea6e6e53627399ac4646568edc1f801b4e734a1f0b6a5947b748d6b78c301cc059f1fc73275f9929028e6cd4472e8fe343785fc1f38af3483221bcaa872bfdafa6121b7ed61bd91c33b1dd9e13e41596ae5f4359c9646424cbbd1c7b98c92995c106dca7709fd389a6e9a8fa15d133a75a4d9c1ab78b83722a2649e096de93b31ac638d3f60e374ec62906110fa05646b51dbd129b2a43a3fac5041a6c413a0d090d3494b8f1567aafd974ec638bfb470c1f31b0e65aacf73889718b3df953b01f225995ec20c199137d7d36bd59783144935f97f4ffad70c6cd07a3fc7f8ba9de51706d6dd1538b7fb4e55138d13ddff4e3d74ed0a25197aa5bdb3093d0542cd8be2d216163dbb72bb247f0ef2702b3ee0e3ba76012c51e0879539aa40b9139ba0c87c2a88553114d6ecf74185950879348652d2fa6d0fddb8d15de5485788f7e633bddf21a60c6a2b17b3c19a7290fba0af08daac7a8142d44b2ef37419669628bdae40db812922f868be60d30f3331692c99636b4968ec92bda6eb7a42161613fe276e6ed6749ef71b771ad2746b0b336ab22e6327d51c675709ffcda5e74522221efbe70d35b8f7bd3e1ebe147913a7788e218bf1073183a8324de7e3faad904a666e804e29bd4285ad730be9228f2003617dca6440e8f0f3cae798c973b81a405ef1afb8621aedcf89834a2bad2db18b637997a33bd769f9a350ce1b79db62a974317e1847a3178467b07524f43dd939e3ef40cba0741054f70be855a7f05216fdef523cffa80df8481513974dcbbd5e6354e394ab2855f32ffcaa5a569535857c42d65f1147a9d7333caaa0245b51b32284e45e9eb0c488ccc7c11ec3aa8730f73ff06326cccdec9916119695c64cbdc1c1215b0cf95543de7258ee11acbbb9560846a454a1c756c4b8a7bbb170dbae5541f827331a4b9f8bd10881e1bfe3a745d7df579c22d75d10d5f453d411389497b8c28fa338d57d85e9925fcf4650b4d1f54a6e3182ee323f91153413ee823dd4877218f0d8045a3f5cd2ca3b05119a688695936c581a82c9991a9b712d1db912e7e4609a68d5396a31253d94189be617a00b2ef7de085b158329fce3c661db141574f2a491e27a4ce913ac130cebd312ec3a80aaa1493558ebf99e8aaadf67aa3ebd929066d4c291c0987676b8911b232244ced9ee89b0e2598cbf12b16da86f4b2ce39643f467aaeda34381cb2a7f1ebe4a291224f7cc4bea6a44dd40f8fb49fb35a1aa61daff498c7c8b107f85a0e2489fe9ff21178aeb14f087867d7929aa7c1213c2f7d852c8de0fe90327079558a75627c23916a97f70b85a4a9f8873e5d1002c86593fe54841830af7197615d86ea390fe66601f8ce0bb2e7294da2585dd63e7601f12085364556b18918e0cc8f3739cbe2e8c124e893d34961300f5d7aaa2e5c9ab21180bddb665ccd4e8492bef304f059c19a671379b4fd083b0ecfba2d69431d242a33e507dc15cd2cbc2edbf7fb547e0d924f10b289e08ee5ef78f0fbbd9afb6954654e25267a4f9cfa2974920ddd95d55156d5121e53b7798ed22af98c81fdd2e1a38b31846a6b989727ef3051986b86e869bc436d79f47e8499d9285ee4c258336c3b4202fd3240804f351dc8e84d6dc2bb375ed4c64c3cbdaa60efd0fd9bf3cf418bf6bf30407d74cbbd33e5f828cd18bccb14b0591aae527eaafc141803dfc75c068e59310beb231c2baea1996c19eb7d9b44301c28341d165e972275615755ed5f3ee9653cfdb9732c5042031d520b0f5bba4c22e3178ac04733d76ec427e9b4abd4f389682552e95da854d27345aacc9bea8601e8d493b7f10d9557d8d9a13ab088e1aa286aa19a7fc25e96950acabe98f741ca9d3d138f0d3df39bd2ed53a7101af0239fa9c3cbc85caaaef782ebb31a9a83009683f71a8862b1964c919fafaa3c03dd031da4ac58fbc0ebe7d50700ddff50bdf0e6bfbc543071dc942f1f0dc5695e2967e7b421743c896b5b0aba12e60681554289a3d9dd8a1626b0b10929019b27e8931a370733c607f1031092c49bf85f8466390c89feffa06d0cd3d1559897de01707d1cd4d7b60dd82437dfe3eaa2801f36a7197bb2dffa3343e862a78e3788da9a006e42070b7e1523dce0ddde747e23962d3c8879d55ae577bfa20e17e89d22260a426a53efd96302a1ec88f34b50166faf46de554b136626606ccad74299b6c1e37f687fafaa1bb82c9e7135e31b6e544adac3e6790b55cafbf2d9b7b1de26a8d770f74ed72cca6d64acd4e0dc8baccf4256c10a78b76e86c76b38232dd0d7f96c2f844c2e36192a6fbdaa57259901c3466072c6ef759b3e10e330b85eee00e0b64390d88b1f36b2afd1ed0e757cbd6e1a9f61224a5fc57e86dc3b6b08554c2e3200a37929210384c014fc341b866cc57e65d5b3700bbb8e9cc1dc5f4157325c62ed311481b7bb67238e93c061a4adc780b830ca1954c21a33709e99ed222f55185e5ab2c196a5f20c2be024cd5fe7c786adb39d3072663684c1a227dc17e6a6f562605b7dc0a7abe2482f6d3283102a682ef13d854d1697a82b013716d69125a741e9feadb0145514efb938cc01569c59a56e04f0197eb36dc31f5c9559ad0050e3f55016f52adf3e881e74c0f7242190277aa7b687cd93bf7863dc896af4968d64e14f7eaea1bb1072cb82ac517518edb4b33e8f0f0d305cc569f6a7c22f0790a5c63bd48c5991a91b03e0826b800c9814fd52224f82529c511fcb8f331912f128045ee8b5a5b68c6b0d9b57543b30d1b36b8ccacd25fab8216628b10eaa0575c4ef56c57271207cf3b701bd433a39b6c4535f1cdebd617b9bdf7270d630b30b0182d31b36bb65ccbfa5c875bd51a3f8649e6ce04a2fdde7fb7793cdaf4ee407315e3b6f320261a63cb7e9658d9c0473f22a02907c8000c330017dce660da98dda00f2eb427d068293e50fb4cfd9dfb4572aff8609aaeb690f536378d30183d1c3cf9baecba25ab0f3beecff151d36c5ea32c32ea608f4bad1c0c3b299d9c561a95cf97bf075b805967122f9448bb5c7ca875fe2c192f3f362da3d990676e2f2ba4510b093d28621ef220f5c5bade29b5da280cd1e6b0685d159105a920c74238134dd788f51825ed394f3de66c5ee1aea9ed72dbdaf510b095cc1bb99370fa9a9b50dc370b2fe3fc18d275c8ba97c51a1f60b86137a373ff64a8ab82089ee4629f2563ce55918329fb2490d299f0b055db806de1435704f8fef4963e6f6357e5a72839b5a941ef1d24aaa911b73cfa7433b943301482482ae17c3af2f9d08a2081a74257e28256c3418d01c3bf416b8d9c35f335f4bebf2c7d472590534ee55acb92f251766d4717146a8c1de9da7631bb8dbc4614f8737dc6e43af8a5199fcf868b6ffa3cf1beb415fe15bc00754123304216e55001685341ec8f4980c5bb78ae1daa4e204958968be93ba4600c04e9df2080dd261e10e80e72cd3bf76abc7267dc95392088327b86c174e5f4d20cbeb535c92ac63e0656f4646f49a91aa390d24eaf06f665677f184403b4ed40ee24c258b7cb7a24860ca86dfdbaa0507e55b681b0c09a2563e7ccbb798443b49b34929955f4821f67ae84f686de1ebbf011215e561e130fc0ee8b86d31cf5cb096064acb195fa54055cd8aff01ed6068266324e76bfcb50006a40fe490c44393de11ffe2a921f657511a00414bd151e5dd7a0876ce9a34019772d843a4dacfdd041adce2a1366f5a1eb6f0f7312d61924bd61aa19cb41aa505ef0bd2e5b76d4141bb7c11d6b78e33162a8bbd8df4cadb6794e3ecd5e1b2a9e682c187475d962dcf98c46d501d22ee176d5c3045c048d233e56032c5ddeb5dd79ab55861805382a79fe431d6c6e26d8c0a0347a33ab0ceca738ef1d73f89a9e44cfedafc94fb1aa9c1c60a5ba3ab63d0a56881d242537052df58231bbfaadf5651e5502c3eb4f380f4c9708e1f5db66882eb0636cd42011b6c2026f354cef00edcf5347ddbc6a6657458ec2d794c91d453567a6992b008e7b0ad606930c6eee07259f495204e3379b725139a1a7b650cc6ae251f8c4b6bc9c3dd2c3b525b447292c2f34bebc6980b2236d55786b0fa5ab75533756e2d21f7068614a7b272157b0de85d88d186608d1adbb2984e38775285e17e917d170ea794520d927a39d97b89ccaa7115279712eae7ebb8dcc2052b270a3ddd7fecaeedc50753f75122f062ae1c48d7171b8c0ac96eef55544fae970d63cb8628853df54cab6c847fcf7562bff54a81e6d7edca640eeaa57fafa8632f77e46263a4396646c5ca2c166474d00ea380ff34cbcfb4739b82915f596c8f9048384d6e8db1b0f27d179bcbb97721f153d5ccde670d29792ca291a127f23ad1739291d24dc14d8507ed6c96ba0317019bebfe6730080e6454c8c77098506eef9bceb7af79ce791a26b85e4123daa625022dd50b990d2e13c17f32b6ae982b2948dab2ec9d9108cececf07525ee7bfa993f7b9049d4c17ab56737ca9c6870d68fd2e3cd0ee98f5fb2cef44c05995c7d6818242a2f79da68398e9beb86b8accba2f556ede842489a057145e39d86d121302deee3de5c4e88bf4f31ca9dc9e49d00c314f62dfcf55e628fa672986248815d7d3130bd63eff0064796cdbc4a6e2306c5cdc5522cab311cad491163e5b52e4cc917efb4b4b4e31b1857ef038d6c190d2e45a9a6d5d9d5027a755dca399e9c87c857e5344a57495d2813964941339d34b6944f64eabae13ce28e2582604b543a92b445b566c8bb0f6172134dff47c804a180f1cda804831c251f04395ecf99e70312381f592a9a5d45aa25d428ff1784e8a84693ea98f483beb8261393af8b0d866f9136b467fbd40315e02066e5b64c625ec56cd7a5dc756828290ce5a59c84f34008d9af243f3b7b871d9d11ebdd1caa2bc2b6f288fb5eb65495a48b09f65b42f97855ee040f4d257af67b5cf42f1603728b727722d8426c321c644262e3457caaaaf875a4237be73ecca5eadafa4edee6c35b43c851bd73df5ccb2b91afdf9748598f2cf47b66f51f1a8c779da95aebbd0f74f12483ff90d0cd37c3b23d53b30a1200eb321d2b79be1d5cc588060547f4cdb8b1e0ba4bdd8e4b36ebb651759ff79e5bfd2871c7de1ac7944b699bec2740a28ab77484f2dd7bcd17e8e9b9faff7ddf01fd1606b6457cf35e918069b5dee3ba3d8cbc39a0076de3c022289bd5ac83bd8122c2d7f142f94f08255f6e12c5f49b8a6b24607203e1aabcc8dabe37103687d727df425847be320240c839399e653fe036fdc1ebf1b46127c80fec2fd17bda81c48191eace1b2e000df5b9db5888ced0a5f1ca00bba69465cd0e57e345a571ac7999d5af15236baeefbf21db1e8cffb68b2dfc85b1c9c9d862cac904cf1e38962de5e19c1acc5b9a4947d9c60dc80141f883814e1fd594451d98e4c1db7c02e8975659738ba06f7b7d84a34d016d4d7acb91803e620104d3db68f503b59cafdf451a850a751572a411f44aed3d4c710558547d02992fac68d74b635b166c82ab8711f9a9fc4045f71cc80bec5ee6ab666d1b9dd51183427a9ca8044d8610a68ef50b0338154d0c62977a4ce5daa5fc31dcf7800bba2bfe278625f0fa8c0fc29e4841c01b46cbd5bd397ff7641139aced4ed5c65a225b9723d1495ccb42b36e0a5ede0eeb221f6142ba905e03f4ffd0811c891d3260951ba418a65f97a1d21b6b9a4b77d37bd5bdc20c0aac8a762dc68ea6cfcad49a1f58a50de23af86544956048d3b6f517f2bebab3eec2ee1ef3ae222cdee2b3dfc6b774dc690e464d1abef7d177739136136875ba7149a071323fe666048db7c781dfdc9a8da85a67c67e1cbdd14cbd2981dd8d35a8493f22d04b89a82c14950a32a1f150c8009df492e44e8ae9631df797151ef13f06128f0216c73f9c1d22d7fec2d60a5c631a261359b6e775dd15984b79c8a6ba468cbe24e251bc5c44631fb106a30f2077fe2db30f81615d87ff07435f7878eadc2ffb9e059f382903471442d49da6c1f4bc6f2f8f2e58f54cff36fb5db54deb023c305e11e366c7808c0796cd6c846483006f6f5014c2475afb0d823978a139ed6a364df6ff11cc356e3763b155034b36fa1c375bcdba673030999ad9acdaee572222ed3adb347b84154ecc4a82155daf5096fdde1d66ab97ec61857cbeec3e760b5597149b66456031772f243b1303320feace4869905f36dbfbf7f781cf49b8036499d42e8a56bcd5894fc7453f6f433b6b8528a97c9def43474fcd983c4f54f451034be1831caa403af649aa5f713602fdb3baffc041b54d6bdb5b4b88d56b0603f1e4ef8b79aeb5fbd191e463a134f91571759b3e369d433933863ee77acb3c65fe025e325403fe4be13b5bb9291f4174a5d4676dd0d36598c57bb14da67eee4a31a166130fc80409458cb989ec4754c504974130da489c65eecb4017951ef89925a695942153f66db3c59d3b28ff4f14875e1a3636a71375532f85e1cf999be96593a072d935afb46321e21d0651e962cd91ed27c607168b6928c8f41b23962cab65280453cd7c24064b3fc20d2fb99d8967d2db182172eaa932f14c41fc9656cfe5cc21b920bde1fa60a672fdac7df66402dd804aa4e3264d8f325d42ce73aeae43d21449aa4690caee92136633833a9c1a35d73ee0fbeaface8e764a03d5b181d9ea732ecd3eeb9e45460c8e1bb7922db301eb3ce655890ae32dd5c95ccb43a95a26c9e56babd426676878b0571da0ec75f4a0a0aa5d7bbade02d6eead3c760a9937de4dd5f8cad34c4694978942c82b10bf90b8e002804d8aa791ec052368a33a1b1b604d85e205bf556cfd2037d7463a8f3ae0d92ffb0f8b099778b2407fd660b5e4d6ea02ab876b911b7f84f7a7443b75cee72f171e396e4feb3ad0a5f19b30b318fac4169c8f8dbd53fa6ecdb378b0aecf2f0487d095385d91073ea4b00f30516b090e2c6c7c3e3e221a6d460b986fd82e0f130859b537f3baacc8825cfdc9c501160203b6bd91570df3cc5014fbd35a9b91de80114d9bc3c3dc5e75683c66715058fbd696b4d3d7c7205621b1869ea30f3933110e6929cf788c4d0b0a0978459f267ebe0389541e97aa9f70149f06b263c616acf3497d34fdc746c432663e5cc1e4598a009744773f30a39ee9f5cd5272ee4f0a6482a03fd51b7578fb77dc0ee672d7ed8b276348638199c2b29486bc11ea442502236e2572731c5e421509741953063130c737617ee15b34846b103ed44d2719e6bc5279c3045e12faec177ab0e1a9862e3f490854e0e4c9313a2aa8e02ccd8b95b92630dad2151e7c2c8b308afb3eddeb6c3f4d3446d2f96a2dc8c7f1b7ced35077827a0e8d4e7139e75ed0982e2367bce1c492ef12a9d30dbd060dbc177a061be6c68b090694937678efd61d6e387da9681e19f6d6259ff4bb905c261e7559bf98db5d243cf225943e6b390004929b88daa5e8a8052df2dcb81471cda83153b9a4b98ce4c421112df36a03f0f115d4425c0414f739691bab865f352b87b1b54c39860336a2c71cd945f0abd9bbfc0e9ffddab166b4ff508e092e51cae1382e2a0c69a2e6bab9b4e36b5f7d9ded4fd5917cfd3f1b35e30a010eff5015eee201f4147f6c4849a213a929045d51d9a38466211f25100879e2cc12bce0cfc3ddf96e194bee2e2b4074b0f0dc9dc72a6586f6379e20b9fb354a180a8d90a379b7bfa83c763086993c6f9a6e56f53dd19cccdaf776916906307ab41ac0947df274af5270267c3a420d84174366d57bafe072afb47b1c5481195948ec455f0cccff73a1135a55b927918e6fce5f83b6a5ce2db5269ef8415262363346a77a46f158dea2775b4ef535f80b1317a5d56f68e67a83b942a044023d96d34dace621a36f49b6a20d7e8ee53bcf3728ce9294b4105066c3408a7cc49afe499a712ad1533781cc5a1c0c262ac5f1d7870d65cc69f86302a8c8cdf972176e0718f6a3957dcaaf47f73dce624b6d4865ea321f002810f6f25731b53b23811b67ba0dcdfd680c727f23d2b51453c20a9a01914c2c2e4994b90c17789ce038c261e1683f7677a030937c12b0efc2004f41b88b0e379acbd225cdf293ad0735076bc532d6959a01d62ff0e9e069fa75dc17cfa2c0c59a812df787ccb478a4f6f8d6fe21afbeaf19dd1a47c21cb789b7085b750b79c31752de36e66273cf86a71e2e94fb035300fc0c5a6255a99140089d89153f8775af6f85fc909836d01aaeea9d12fd90d4472995b4b12b745444f4cbd5028f75b85455b4482f2c68f82964a3b05475838b9b1c0cb472af07461ad2f283586175457f49b35bc41243bb0c0cd5d6ca1c4cd9e7dd321bef99804c44cd6be9356d33f81f4810d91a76f2b32efd88f83c11ff5517909defd22908155a9068fa141ccc5011db34f64591b520a4fd564a49d2b7286a2644a006d57c2cb150e24df2448eda36aade48ce998c5c3d357e24b09c76b20c613d2f424407439e223256e05aa18282531242c063014de52c6d67b61c72333f56297dad5054502f9abd0cbbcab3dd76735555795c212f00ee3ca410855771249e4be296639a964638bd8536fcab54f7e18ebc7d9cb2b9a08521caac0f4f99114f427f3af8b53d9280b741cb3be86b079a6ab8b33e6f0f3cc2ba0edc2ca3bff3e61effcbc8ca8e6578bf86065c3de8a035b795cb75ea7cc6dc5e4b8ca0b8939601f9020c79641301b8f33e14f6e552783a2891b1a9c6c4c9faaefd6c4e13e6832337fa0de2e6685bbf0cd9b8b56b8dd44b8da252997fd5f93898c1a9e8a8e9aaad7e45e21160359d43d62bbaeee7a910a6e835761e12d4eb289682cf8ae0e1267c48051a0f421b9dfbd12161c7bce5447fd8ff22f4df79030f256e89d3343a8467fac25655377f10b461bc161b2d126ad3bc0c065fb6004897f1b680f079c618ccb6f86deb761b9c22b74dd75abd7ba35e5aab5fa5fdc94a9a7778accda861542cc0e14f97d09f0be3803724e5d28c43afa457acbfa3d14d3a5a9e47f753ce6ead9f7a291271eb3f3ef34ea9d736cf4f099283f1a864792520660133cba5f0e480fc8c7ebfc3f0a52c220f4aef5cbdf1b681028255bc7b0c2a5d2eb174d22b3c36b28b3d79a1baccb9b40749040f544a89054211ed5cadb8236704a74c1f404ae2e5cf420ae2cbb4f6c603e0e1d2d518deec1afc282e3629028491e732ca3c70cd711731400087a85592368c4f6ebc37bc56825264d204fd9a98c2d1770486c50fb678896fa8c188f0c518e2dc3a6fdb01dcd9131d23d6edaf5b5936a0ab3b25f83817266878882fa8f5b275c0762db558132f2b740e8f1815ebe08daeecb5059cc4cfcbc44300ad5c39c83d477fe044b3bb1914aea0a719e2de1f573a6410ba06070d9de53f3a994108c7f112d348abe3c50bfd14b59a02e2d666b9c1b2db087230c5e86b1a84542d2aac8af010654fb42bb4486624922905c8d1931d469eb74259e319bc6fb6194edb2270dd5a684707858f9e585856a9e4aeab851f95d576029b8b1c04e06545d774af450ff3ecf2537472235f7ae899b3421aa4a7e3310bcac266d8318d28968c3d6e244ed09837721483bcf173bb7dfd52ad580f7c20ce29c34e58910f754e54928fe70862b73362579efb18ca9f6b4b6169536d129dadbe4d3777bfa120d2d01d4d3a3bed849a3a556959d72979b7f8e2f5545723acfec83e4fc9315875cd1dcc352248bafcf548bdf7930a5994a797c2dedf26ac228dd446eabb4bab13d9e0620f873a5ea92498c7e0dd5c2c2efbb0b80111268d41036cb76191f6d94fee1f1e36b38bf758e7f03e3b7612590561424985df0c53545af6d09443f0cacc11c997d1356b96af6f7e89c1d7d4357cc6df6498e413622522854a462889ad12a67afe52d5352a6bfa1ac150bf4a8e4e28f09b8876c96577640a6b38242b344e34283672c1e7c82506725f30198a357e00dc3a48b5e1c81c47fc573c02f7655fa7a091c8af90129b660d0cc7414d32591dc6d323f01f0d367a27204533557abbb8d827854f595331517282fb305e4c0c6fb0d8b08c86633a4f2e7615e7ffce07127ae10b5b5a366a8c833f9789fab12995e6292a4e8ad1c42a6cd0af01e8674e5414a18b38064c3a0f198e1b81ae777984f2710bb60b81c2c1745a229574dc35159fda87827d3ab2e828cda56d6f5cb9429225b13454fe0e4ff7d664ebc89e5f8d8a64396d177d39b332e8c6d437c0861cecc75bc5d578abcf7d3f5f0aeabb9398ed5179c7cdc5b1e017d4a314ae7fbdfa1a89b0574c6dd8cc72832eaac6048395e9f0c93ad6a97c4c24dd3e08dc9deb6ed2637285981473803339aab0b2eb571a87697bae78a122319b03e823b50e1e0b584e9b760d13dad7aec55d000c1a4ea1c6d9fb389bd3b128a4a2c2c1a11bd2b4fd291fcf65184d902ba8784e76fbd25e529d7772d8110c336cfd37dcac424521625e7150d00247cb79b1bdd3196f8cd6b8aa33dacf4ee9d62f62e5b80e643677ff9f1cecfd3f67f93fab878c33b116d3b5186bfbf8dd42a69f2befcd53207084b2b5594085d8672d9a579a6091c2e442d0782d27b6dc9ae579701df8899966a2037241fd57b011dd1f45e2951f820be60054191d5d402c275fb3cdd1999e89ab35333f8a6a60d7f4c7fa6a5c34e634d8b220b68348a8d30173d8bfca759cae9482e24b7c5e61eceb43dbbf8bf87665614e1573db2ef4b5d50a6a3047d2412b76ff0db3ce35701975c0f182e49ea15637dd280a4dd244716149f7642a2521b3f4ff6feded30bb9bbb750083afb2e6f3df46d5e25632125142ae8ed0fd833c5897c4c6125f76c39a2f6500e303794fd6f89b79fdd269515f95f7e5332d8896c8b9794816652ebcb47b9e621e23cf08f4dbbbd75c1e2c1e3ccc5a85eefedec52892805349ca2d9d719fb71763202dd8b2a7cbee88e73f74b57e86bba41042c9423189d92dde0f70eca25f93b93427f03c342806a84d58ceec625f8ab68c9f7c711100aed7c7b3846e71668e6e1d589a8203abcc1ee6c04bfda74f4dc89007bd6eaa8d3832af644ea9be383ed548af3ad32aaf55c46e9fcbb4b7fabe0dd47b686589504923a38c99413c6e4f4168a9954667fa15320153a5af1c63f471c2c992b1bd8e8526a765ed5a5123da5bc584345930811a534d561e9b1d1d6d6237e5bc811bb1757486bdcfd08bdd2e1c2e54d9bf89d557c78108c72751f7e7ada5d90db32ffe790d1e6806283a85658fa57246904872815d459743b22666c18a5f955e26f8f57a31b2359f8a56b3bb9330b009c03259ade709587c0ee26db5ed2dd99211a404c48b1b0044d5ad7a18c57167461e6c7ad911f88b5d0e763081cc97e1f7a80e7fb6aed352f13367fe8c7219290edecedc7a5033d570e21d7760bcc3441d67b1aa4f55be078dbfcf7bb167259c38d524ada65ce7fbf90915d4cf476821a002de8a0a5b050fc57e18c22c5c4c5d59a25533fd46a1fb119dfbaae11fa0c6243244596529fafd016a6de93dc9da8b9d3d27e8f2c3c29b97add172fa7d490d97","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
