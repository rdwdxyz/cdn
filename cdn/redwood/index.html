<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"979723788fc2bf00cfb3520f2cb5a88f41880fb8908bbc53af7c196917c8c3c703cb152b900af0aeff3568d5219c762a92a44f95044dd5571bbc4aafd03abbbf4fe7610959f465f4b9268fce8c94c7177e875cd5113970acdceaa0fc3662d867d7340bc37eba84b2c03c468d6126c521516d619380d7ad11896c1d4ad6943a9dafeffcf80cee38ff381abe6f0b7df8691caba68afd196fdf2b61abd219934b9618e38cd7c75ce286606aaeecc69d083ae8e51b77b6c513207b8b9159a4f5a769ebc0558d928d5c856f1f10a8aaaf3cb428a6e74d8aa796e779db14c3f049d378555a2e1b9f17dc78eb8e4db5a5f22018d065f89c4ab4b06ceb9de2c5853024d38de6541058d9ae136b9ad5ed7f8037c9211646676c5c4215f4ff577052de91c426825bcbb808f34e34df82011952c3f6ce2d41a3b4afe25869be2ea42f12d16ade222727d2deaae42b263598b80af900461012bb1e1e5225c5ee269e6813ca8dc98e3c08d6355e9ddef8f63f6fbd08b3fb29ec6e2cbfd27c9a50e51f197e5e369a05d63cb4d44878abc5cff30a3fb683d2e35fd209a3d55758b8a636ebe6d48e6e5510797567ac08aafd79918b70722f1ea450aa410d70227ba63ffd744144cabeaf86e91937108e067fc7ffba1b4082a3d986cb5d627838369f35b7d8df1ae537935a635460a98b0c4189c1857baf49cd2667e385da6400f45fe9d43f59a0a7e5da543fb581c1b156d36b767bcce0a6e9ed5624152cf65ad726877f9c1ba261822c755722b8bfe805739606c419d4fe8620bc0bd69255d08ea4f92193b6cbe47fc65d40b9b87f9029c2f62ef34ed7eee0025335f7dd690af0aab0192dcdbd0c6ca9476180d4e6a15f1eaba950c8773da31169c66699f9aed49c12741b0185a47684715e97d13a5f058fca767f92ea6c429d6c22b0cc6a75e29ad8d8b0d4e6b3d7ed1205b601ea61fec1035770fba79db7f72228a33059713bb08d79e651160184f327c5cbd82a26053ef8bb4f1820e74299e0ca19642c33ddfc3dc956ff93df6a3bc7796a2cd928387d80d16a3e2c71ab1d1f642827d3aa672d6289408eafaf42fa3fc0da4b1c567f0e285587ffdf4c19f52a1ae401b0f126bbd75bf05f18e2509b683a98038795968b8d8fe40c0b680fbd0875204c554d288d01ed8e8b9b8a15ed935eaa1fc98db7b375db67d94c90983a4c4c5e6a4308614bb4b628174ef300ffc9ff6f4606676d999f4f6b94a532975e58e7b4aa11f000611225553f74f7cf8321e44d036ecda0e5273ba7ba139ba94b72cdf4c3f61dba9ca96544cec838444bc43a447e1fc76a7b2925ecc177b21f89bdf8b4e6ea8bb6c687c90f09064c39e12069a2c3c4c2c7de35207055143c362144bd0c9f51635d469b4b77c77df530563cdfe4fd1e8b8961e5b341345ff2deab39da19b5072d7dc15af4421313c73b56b36fa0450853c981390c527f89eef02d91cefaa7ed1dcd344cf187099483eb19f928457a0644050819fa0028109eb35857f8fa7e7f132e69a72a09b7a7dee4d2721300a0c7e1338f7d3f95c988e38f8e99be90ee16c931aae8aaa6cd434d99b876a5d85d431b31fc7d0c0111a42b5020bd182ed6b6696afa0dea30c773380b70d5ee6537e2f4632cbac939e763b1c3214c67c5036c03790131af785d64d5779631bdbb2ac3048e4588ba336f88e60e391b4eb8b40932eb27cc10b772bbf588f6818c2ef4b8e565d9070b9b1ee5d362c6ac8dbc7f2825fb8b71b2b73397319303e33b3aaa7a27988d4855edd7919a0ca803b742f935bc19df45a93887177ecd9d2cd98c171d2057144634b9f200bcf6ea043c905aeb2fa2a79a7bba49483ee99e760d80479cfaef64e6ea1d6ce537cbec891d741a8d9dbc110d9079e7f0e43fe3e1bff2731def8d4bee8a36a498d7a4f468883d8b35e15c49a59e47b4a80946d53fb5094750e80f7ec49789959ead15df98d86a93049977bce85affd80494430a0f41b621e4241a841cef27bcdb426d0e6ea4a07ee9adc036242a8bac6109d55764d0f7fa5139fd6dafbfe7340711e789768d63482b017974778ea3d9a0cbdb02404c7efbab04ac368bbc47ce0651d11c484ef7bded4b46c5e0dd9ae27899de42dbfc6158e65cdc6198a255de9f69332bbc8e793874d7424678b479e630dd930a3ab74da65bf96ebc18948b9b44c5718a1c67300c73db8b47f0165ba6f23cdc387cd9899eecd80fdfa4d5742fb6d26f16dfd8b65333906954e356203e9888baf6cd8f01c977fb5360929e317df7d84c8632650dfa08e9b54030dee3f5e8d8d7219ca70db5729693de1d209aa14a0a23b65feba40d2a7b397828bc06bf8d4a4ace8f79a852b8908e3b0137dc9b4d3d9bc515fbc209703146a653900f35782e8ba453e11c5bc1d0a91613442a31afbc3c2b4ed294fee279d362f10cbfce9ce14807b07b54daedccfcccfd93162ef29c09c3e66a2a23260e6f6437e578a2fe6c5afd859048543fbf35bd70625b60281b88e9f0695e0771d7658c2c6a4980b1a42c215982c260d6068007f50a3159450975abbae31cd01311cb2d6eef86aeb9a54d63d5c6e2f0d912ea3c999b3d46215959975e32a46464a93ad3870661e7eaf878bb67656cb0893dbe296754f2ab39cb1efc092d5e7b2736f77ccb3b07fa43495b4b32ef9e212f82e77f06cf5a206a2e42bcdd05e4c7ac576d276280371635f036b3f5037d6bdc6583387f17758ec0a9443f1710b7640f5fdfac648640310db365688887369cba0d0aa48726846a1684880c39fa2de41abd7114ffcec704e7de658b8b597d935c487cfaecc4ccb46b3af95d66993fd6de71c2652c11042776194cb7882608a1516788e88a91018fa486766dc92f87aa4cdedf8e1f376bc899c1c71e5fdb56b94cf3da4cd2c952556349848cb3133c89d6bf2a8c9db171974362abf6a3d9a50dba6cca5f1287311b9c3b49c9e2676477c5da24eba516d8a67d6a8e3362d8ed420944c807caf8906967cacf6df559cea5f524e371a32a469a85110c11ca24739c4d13364aa02942a2e1598d822c4c55e11a7de53c2a99a898fa4ebedf1fd518ff92919a6da0347e295e3bb9f93f516b03d570cd8cd2def689fdc07f9f884354fd9eacbb68888e59a310e991dd9bf1cb795ccd3712ddb591bb6eba3c847efcdf7c161451ccc0eb319798b3c064d81cd1f340a1f564b76f855ea38fbb79c00723f155a61d8b59a6ba1543aa4b914aba68d29382f4a0352cd9cb1c66f3cb85344392b0fa75b37083b95d5f7c8d690dee4c4655c7d140eb70ac731362e12e4a8663be655b9064a3c0572d083aa2e429dfa84c882567c96f4dfa3970e37bbbce934e6a02f92907cf4bedc69f82069473bf00fa1ca0ad74c1bbe5eb0f969cb22549fd2079b709c6775c5e4bc398d44ee0cd775787224f52502ce56bfe9a8f4f209254f8395bca6ebf931d200996b3fc7a97db921410b483c1f144e787fb95336bfa569eef8f20b470fa366c73df1236fc90d1ea16a32e667d8135f14e1d758a2a16d72d5129eef6fd03592901cb22630df189fe93f0c5e946be50a9a63448101405bfbb293f01b8887d1d03a76003fa065a693e5d52425101acea1f3eb68ed05b4888427098fee641d0e3f82be9cb103b296671cb2f5448865b04e2c335c1d3b9f80fe10087be61e5fd262f734c3f36aa4b3382ad1ae6ea220a2de358b6f9945ac3dea166b369e5f6d00ac22681b4f23d6a1a691a724571bf4e19d62624c9fc3fbdd0b3be9893b480b6fd71098cd946a45959a040ec736809e0f6ca645696660b2d7d41483abf2cf43ce9f0a450d62b369a62580c192d081af0b8d79db4cf7dfb983a37ae6791fe0f54fe20bb2b03e1f15f54ec5030a8d9673f248ccc0745643cd054cb94d4a26871849217d27899aa4c2bfcc0a32a96d32dba0be241797b13397f3d480ff951af98585ae5b74782946cea1d5585f1903ce168afdacebcb9ad6c3da137af0810039bf4b660aceddb4ce13f8e69b408b73caab894eb5d2087e0f0da4fe7f1dce3e42360d77b1303513132098c7119b4646536bd5708dc9081cb38776d3342b008c2fd8afcc53fd9036fa891ceafceccb75dbfbf2ca185f0762943ab0060e7e0beac8fdb839a9fd1146a31a2581d4903f71134191218067dd1e4f0e33d3d69032a60a9e33cbe688b0aaef2b72a6f84eb0f966611bb505ea518aee9f9efdf75a67b17cea2736974b18deba5ba44950bc491c64fdd2260bd49c17aae25cbc5593ee35a8da25641296d4a21986217c1b68df23de3fd74f9e43751bb223f16443e92dd81c3b06066828864fa5c234273c8fb66665284c98f3abd1e4fa4322e2f7230b23d0ca776d71a60a42a4e50fe7dadc71c9b628daf0e253817676a7138eb4ac6f07f7e20da26fad13dbba48e84348bae39ac40d02a1415fd198891b9b36d181ebbb71f097c6d4f2ce8cfeb07a0cb3b9997f51aa1d5439dcd1005633fb9d3a0100efcf326e7778ae2d4c6a6c720bbfeca96ba766ddf93060eb4a4267b3942a1742fd14fb868b850f15e66e53afe75eb2446f396f19f0ddb919d4b1c7e4c68f8aab81d90a39ee91b0979f91d7b186eced2d59885e05b39acf2ac69b3f792f3288b0c36ceed6b0e8d4ad890bbfbe7566b033bbfedbbcbeae63969325873db1eb41dbf9247ce434d37387232a5a79625fe2e8164ef7298a6255f8ab94c244724242b3b62c6cf63c2dea88b3a4d0fc6827b0497e802a0e3cdd848b44a5f2a7dd7866cc1a0b243ef60afd0fc7106a96288cfe51885ffcadd0afb43acf420bcad3309d0562910e2929efe11aece744c87b5ad720c4c7a9b4bc80c1d071a4d1779dd2f8912cc2a9b13d8daa5ea810d775b794233983584075fc38c71b554c02a8d3aa74c80c13d36c3ebaf45f0d78df9fff7858ac54b04b9bfa60ef4f3d7928899f9aecef28f5ed975372d103590caf3473a3a606821095dbcbb2c16114d187092da20e98abfe9d09d818ad2be8a694e4517a5b84a0e359b4e901b9f18045f9e13d446037ec0852c77a0f95700cda1e38ff596301e82e43291287cf82f04eabb43f168108e9081b8c0b7d19d12bd91b6e8cf81b91b13c58cdeb82ab503808aeab006785e7fd2fe41b6898307bd73966b83c3f77df59af8065d200efaadebf31cc1b6dc4e8a88af51ba8a06735add2d7db61a0a259281991c10bc82ca03b5e6a0f1e88d144d773dc1a024382151e52be548379f98176b339e42edc70c43a5bf0d298fcc41622540003f1e7bc9387d750b8ad7b289bb8db1d98da42f1cbc24d9f307648e8e8b6c4fa66dba0bd2d0fea44496b87ce0a0da995f488da2a78ac6ccd23256a49f8405dbc064a8547e7197ac83db3a1452f5b66984aedc90b08c44d76dbd91a4ab018e80c6a6e814146d2fd38e84e34eb83e026efabbdb202aa7f1f0ddb5af26a7a1c729c4cc4a44c9b3a393428cca9e6330e2df6c3048b46b4f8ff49562009bfb4bb794aae29ac59d73aea26fb5f08df6bc41757a28d3ee904d51690726e4c6eeb54c182a6dce81b1b3b3c372f3514239a5782a6d78895eb2fd778277060522969bd26dfc124c24bdfe1bf7eced206cecc69f602dc664ecfa3476d2a64d64579ee23dfc0ff921c3570e354211ed287f8254dbe2003c435de77dad9a13e7d341f2fdc77b8b0b12a7a88dce98373484cf3efbd1f268d7baf7f2111ea3d55456807369a4b9ba20291b65d0597bdc9174cc279f2cdac7848d7d95b1b3d954482001b75c7a6f2756e3af05d090cab9c708336a642c7e49b26fce15e57edf58a5742a095b0b41de6ed09eaf15062390ff685b6165d3ecf3410f75423adbc1ffa25fe7f7d1f77fc57a4938a1da6741018d2337407e0821e51bef5741e41fddc6f92dfb839cd75df894b00f55d88b1da8087f2cf8382be557b553a2dfde8b8b358d24c28dd3d88eec8b20b7c803c2b9b930e0f33bf6ad5baf88640f30fbb80e16bd14135fca203c410939f4e9d37749c26b6a4bb6a00e2cb6bb68152274b2aa401cc3444e22d7570c39511fbc9326b7ec6c5c86f57a9b72272c3c7bea6e200c749f70b0a43bf82d9f3c64dfa8f80a7cc95a955eeafa2b5f8c5cf7eff3f61d4e2371d848871985787facfaecbd66b0e843c9402f662d0d7b739db9a223abb8e568429ed3e7f36455faf4241b69450758781ad2d039b677df5af2070f708e9189705b8470f66e2efea471d31ae71708d8c1ecc9497f2a27def963eebcf9f09646328e594b753081604598ccee417214aab9ee9e7cd3d1435907798556c841cc1f068106c205db22fb989de2086993dd6f9eea70468146115f28a8d03f1ac1e65fea4586f93a5ea73f875ae9b8fd2a16374bf61af163f04e54a84a16e8c4f6851ac2099d37d811ac9ebde3a2e0e147bf515e71036e3d8d97fca602525fdf329c22da689f9e7690cc1bf99534039f4dc367499dabf42ff0c96c48e90228fe751674a4994591f2131818e710ca6f19f12fbaf85266f0290a4ef1a77f9c720306703eb50ed8e0dc6ad7158e8a6f8147df43c82d9337f06d10b1ae13ce241fe6dd5f942e7a68c9f6ca015a15fb404db15e4120d8aef939d1a3b5d3419268af9f35fad0df1568814912b6d982be800de49802ea114b5e6285114699820dc883c08ee72cbb2f7a72f642da70f8d54c19d976ff21b8e75c407de0b6bc7ca06551e6bb6975683036ba0a009c90422aaf7dab8cdc7f0d5bd83cb233bf0c008ba93742abb4e0a1e22191a52819c2de4d077eacccaed010d98431a56003647889399169cb277dab92ea07773c09e46a7ec47fbe8b2e68963e83df736f7771a384d3842b8b582a974576be0a04e8c785840a5638fa135b0d62b788c6f1574a20838a8284b09f605357b25312941c7d515bd4feadd48f88d6afb29fe3ebc3b46554be275a5154c7401c39243326fb86d8c11a2c46ebb4d634ecb394293e2e595369277c67655f60071363fc9f93623102ea72a99d571a0fb710d8b20b4462a7b6998d6a52014fecf36dfaa547ee3eb6d45740db3be2d1a38460b28b95daeb251646c8e8e362ed83843302fe355727ab44aad97fb0c20dabc5c2b683618f54fc6326ca23c7b4cbb762edd478c9707e93a1fac00bf499515a5d1bfa81a7d48474354401c572d42053275c634de0b640cfcf97c316f225436c56e9c6af4db8a96e69e99a9afff09b95a35365372db1402047371138f584ad1d0e558e246a7875031097d72030c4aac05bc58ac6bd73cadea20cef3b8692a958f72d5eb8545376855f7edfe67c2b94b585327c261943247165ce63bb17679cdf71194893019f9c2f07ded7b5d3ba8eed5b45af8af281b0aaf0fc8c98a8e35efb7c5c10904635d3887184397e51a9ba585e56dae1499ae00a668bf13c7040736e70fe078009c0b5f4d6c1fb9a9514b3d349e078ff811dc9aa5e4ed8f06d6ddf96f7f8e9efb8ea29d155a3fdfe72c9cb78b4c6b8572d1098b48a25e122214ea058fa9d3c9c1f080856285cc48e60aa6daad45ca6e7438044a947ebe6d2d57a950ccfff0a7239bc66cecab360eccfa14b3de7ca641fcbc6d2f6f88d28e6ec07d46f90cfee96a978d6f151068556908f2813c9de93a05842d39528391a09da725c85f946bccd1cbd1d0b68c35f79a23b0ef8cd225e48c51c6cb9dadc36d0013902efa3f65118f675b2bb1b0d7dc54434591cbcba337f90542722e29d4fadc1f170dc35ab67b20d75e6bfbe1a7a796b0c76c1b61aaec386126370d26f05fed49847523165ea8bcdc574dabea6ea1fd70f0bfb57331a2b4d011bea3dd7281974e40b9dcf688f1c59d5ec38bebcc45ff3e3901f5dd97bce9c365941c3525e18bce7c13519bfc1faafe887a80e8a025025de806084f3609a29b86d9aa96be8daed7797b4e4e05e606900529d0fccecba21fa599751fa894e1fef71f5295d1f7325393e5d5c782cd38b1e48a38edb490060e39890e00c5d1c6da6905d922ee8b2a249420c97e515fa17a54a275365033dca368f4f43dbad78cc4d0ac299bb7e73b45691dec9efa3a1fdbb90f980dc08d41e014687964ca91f9417d5941c7c4d3d82da6acee4d001c48f4624238f13ae6bee9313fd397194661ffb7fb73becb46c1f7734fb8222b90c678e8c168a15195aff67292d26ac3e3e08f42944d45edd0cd0f060d8d653cbd9daf2329d4f916f547176e3608bbbc9b466f55ea1f07094ff6af7989f1af8a59e339cd2bbda73ca3f9b799dc939f5643d100318af34fa826a6c937eb6c6d9db9a4b6d5dbaa8698dfe9da60ee7ddd231475600d1e17cd856fcb3f7ab19b3755d9b1b38eecd92e36dbdb25e6f120b1665885c9449c634dc2384a607714e6c79ec84fc22b67534668676e2e86819571d9e9b6da5786daa7696170cffbf61293d81a06ffb5feee5f245ccaba6ca6ab24fbe684e64c0537354fbcd2988b5deced82ec07d2519534427f0b0319e5be30d13ee6c912584f84d4e112d535096819ff77825897644ae71f16d83c8aa06bbc1cfbf18a5cd13556683d18c6a64b7df1b78de53485c8551f51f4b8307d1f52c26ce11491064659f737c935d696f1d3818f53f2da0db2151b53d8171dd3c2bc9203e4cbce8a8f8a8f606bbf3102e9c53f7ca48e5f9e2484e4004d568bf557a3d4bec11964650f228833610e1ebb15a621ca1024bbad095381d32f371dd9e5901b24854efedb86bb168fc80e9a3aec842467e3ce75a0f887af8add97d0251e14878f4d02a728ecdfcf5047dfff60db1217cbb43248b092513a7f83ca2d8f696b423dab559690a6b0837b0118a86ff11d215061ead9052f9e52d33f8d2c17a4b7a952fb54a2aecea639e8357b72ef5e3b0feb5c44f3fb76aaf6c34ec57e3a331de6644176e8f0764733ad049066caa4decc1bf60194efc032edf1f2db72c4d6d1468d3b589a17375492229308355a65684e104c460a847d805802100bc6b55d9e17a97ceb39cfd02d4bedb4021e5bd1a4c20b025ed4a7eaf682eb97a6a9e9002f01c4073ae4658369f139586fbcd640bd1622c4947333d814cbd59a6a52eb8783fa2668a1473b372f9e330a6c05fa31ba36fc42045c07716b2c51b4e5db1d598a741c5e8035cfe0d86768c6153dd86a74e13ca4bf950389733d6e8e15ce8aad776e81e566f36e8735fd8ca828b6c72a36dafde10e2136d0f0e6ea89445293e61859a891ab0fff2a05ee0a85ed4abcd0b1eb685c84a41fd0dcfd0694d85d82a6bcba109345331eb4899ea0e640c9b3eec78bf82817e9408ecfb0d18d627e8ad794a7608f88e8e01c1f0f9e0a9e98e2e3c51e4810a0822174e8d66834d7652084db087b559307236aeee241bdf7bdb16f8344f8c98dfbd4ae71a53fa10215dff0d0b656197f60bd482e7c5643114220719cd4f4d8ba3e4812507af9a2422902ae79f87bd5b50831790740329795ee67911715205a73c747e6f420e446f0f7fbb0704cd388fed9ae0a932334b305cd0fec8cd75df99f0f9d41d0e9e83ef026fd1f95ffd82fc0017f377247b73baf179ea6b1252c754d9ed8cd057600f2f7044e1e1648b7c5ca0ff2f7d45a4257e7d5592c70aa3c94bd6589b7cea67e37de31e627ab1423b22450445a61884cb0ab02c9cbafa0a8028588c861cca1918e3135f5fba8f477aaf4182af28c48c5dd687fd6ea387206172ed667bf7db2d096880513aece01c232698284e9623bb21661c12469049edf56157a31709dbf1d8257bcf1e2aa98f498676d06bd83a5cf687e5670c6a8aaffd58e11de2ac687b2e2b9c654058bda9b2c951447cce6664faafb987dbded9737133ffac309990f4074099fb47ad4ed79554b0f9adf5b1c3168bc2ebb0a6b233a172bfdea3a078e6c33c65bdcaf68df9c45d74ed1d2d526a5a4b8e053334cd8b45f8b38aa6b88990b008d5511cc2e92df9a71ab6b656fe469e987b12ee6d7533efb18c0d6febf93121dec4ad045b3acf66f06f9ab3b58f2e23bb5c2fabc6080332f803300dd3cb0b4ca0d745ca00aa371230e762e0fb540cd8a73832bf9703936f95e70caa403b9b0f30397147f3151178ffa72bfce7b77af25733262b10f21c89134968e7c0d7756e1cbcc0145bbd8734411c80f3083f5027b21a08b71b7e622863fcff38b242f9730679eaadb0f5c6afe2c65f1e6038e88ab8e7d59531727b92b932e124ba65a50891e89c4c205b1e4ddbbeb9e3967b41b2ee6d6a704622465d61c4e477c8e219d2f12c261749c9b118998759602090b9bd25ceb5f65f3d655a90d8d9e2eae200b4306594c6570be820289a31901d9cc63fc7c4bb4b17c7c36a068c34d637ed6ec273d02bc78fc9c9d901bb73d32656206383e8f1e3a904cb378d4bc247d44b9575beac976aad52dd6d5d29491c2a394101a2d8bf949fe68814c6858c38e10a90a1d2268adb04baa43917428d5f84307839ec64b2bb64ec8c42a6b44c07bc53046cbb05b7c8e9430485153e8235a9e836320f4cdea041520d3bbcb05e954ec540d04eb56fe66511ee165d5723523bc159fce1e56c52444f608c65f1e5c03e3a276e2e033202915339e9d7dd83d7ce65e1566bccf72cb0eaf0cbfe05e4099a3ceca9fbbff6095dcb19688edc6cfb131b13ff7dedf9e784588b6197da22fb2917b20b17b73f2ebf35b60f31f4d38ecce560b163b5ab2807c176a491ad251bbc4f118a94536aaa14107ff385ab2eef6a7b80fcaf919741df328f5fdce1e891bc47273ad35ada78a24625938802fa50ec5e4b2b1c6af64765f595306a83717314325f49ab92e461d9d738bc80a9bab91527e28f219b48f07074ee3ca3b7cf3f4169bd19fc1fb03faffb8094cbf9e559ef37ca001da86c1a3d82ea278be70409fcc69c567e6f17a31bb08be5b7a7df37a7682079f9337664d2e2eca691ad00e6b5c9915d1f7586715b199d681e98a0e7f0058f62be2088237f5a7f66c8fcfce6d05fab2bab439a032f7fe75f5c7dffdfed950a174190630e3a7c1a8200c38fb6bac043a8ed756773826eccb7a07fcc7e9b506b799f7e16bd7ac3c97a8ee650e608efc4c84765a14689565072bcce0532fa70bd7e079a85a5e29200536ffbb3a70903af444cef25ab6f12882e34b2b602cc1f028bafd1ea613c8d3c5849745b3831cfce0d2e33602666be32ac20c2db7fa5e2dcf1ad2572c6757d830cbe5d94566d4ca0d1f3a1670ca982b42b0be0fb94a7708dfb357c756acd086dea0f2e6fe8ba5af3d53d2ccd179a1ea1bccc0dd3265ecfd99ae139630abe1ccb25d4e02110ef6031b143de435541415aebf68adf067e5ac4f492c87dff6dd0442b35252770d1be2e54e40e2535badcbb1e3c2252c285f84cd190c896305f09be027de810405c152a3a25734511fa86ff41865825555b66892e74946f87b2ed3d67d6c49237fb05afd12fa8b575b1659102abf949e71e8a909190cb196ad64166bee4d4f061c6aa500583041535efeabd9eec338306c2fbb9c2f98921d66e5f953ef54d17b2b4dab1bce9afea7fcdd6bd70389920672aaf19f015e657dba40a7c001993db6460e306e2cf2dbde3bbffdf1f184abab0739f415436565e618bf735343b26a347a379e0223152746bcd31a03ac3f5080e90a0eba4b2037decd8510ae32074c5293ec0d5972494c719e13dc1a1d5453f9fdcf282a1dd0cb78c694de287d20b715e393f58c2072503fed8dbf942794e4d81e5f75651278527c2faf74ea7443584cc0f556c8659929d372297fc15ce46577f50e9959b8d320fd71a21f64f5a9a94c1d74047dce9b0929722c9b36aeaca6daf87d8912aaf1ad68d659727447d8ca9c74f9a35bf5b0326d8bc8d25a8fcafc0c68f49aef885e41d03c30170f8441653b46d8a5fbb0a2cdef4ada3917d37d164aac4f02837f1ad52f13875a74cca29958602e30abfeef2b0ccb594be83d6aa2589152aefb538da6070b23b26d0b7c1cf828f71a2f9d4977eb1455eb9ae0050768f1691a43e2bbe6b73039f0d916dacd8fb94219343de6cdd9ffa787ba4ceef23d5936a5ffce7387d1112768e82705f701fe53fbbbd090216c54ac2cd83b737e619466fd97068f4106d878e4032bda41b754bb105bfbdf2ef82a52e839811bde443e99d37f0f2998cae51b1662d5c769682cbf2c04712869457231cb0ba84277803a704fc846a42dd418cd6fb7e43df46e24c3268f5ade699077b3a13032543015fe3f189609c337ee4f28f015848cb95019d1e8b6e93765ae48c3d5b2c5c658ea5984ea266036a063de6aca0bc11c8ff8eee5a0477a648db0337f7aee3c22d45e1ce80c3702ef544c3ce58b5b43be665355601c212a0d748de18bf0ed49f1dc0f7e0b6fa653f90c7a39cf1150bc11d0035d14c06e12feb2c657e8e97962d5a09f5506ace3365c131a1ba53f6ce43e71ac4b5f95c5dd9659c52535fd74de8fb8e6c40f5930816690e79835f7329ee756dab6c3e244321298e6dff123d0a8a5c7f2e89bdbc117ee0b82ccf6c4ab23252033f0c0646e56350cf41d7a49e4e416019895e8917d1ff675f89918c22ad95db8546dda10604383d711d1d3df2ec6ce3264b3298c1507fc52a12a15c82912151471a895ae87359caf0354ac6be9bc7cf4225df770e4f37627bb1639b20fe46bf105e8b2d46264de21d4951f5f74b040fcdc41770477ae151c14a3ba9f737677ad5133b58b06dd78fdbbbfa4f40ce77b13556e8afa73d0df9cbcf99d1e9ae67baf1f886c0726e35565389c1b9d4bde91a4583273a20679899544f2e20ea11d7598ff1cd252410489a99ac526f9f270cfb95a612e1bf367a41a87bb4c01cfe6dcd46ab49378d7e13ee7ba82af3478dd9345cdf49ce29063d669df3aecf9573af918db5caf50a7101bf18d227f142c933780cbb6dd64381d2551f7483455c59bceb92e7e7b55f42889b9005692e1aaf89f93bfef361b6a0f4ee79ddb6ab9cf255d3a861565b46c6e65c52a4508acfda698db7257404baa6a624ed72cf5f6e0d5c9f6bd89e947945e0fc653963c70c3e923b478f3dee8b6e20c98fb386266a3cf4894e6b753373ef226426cca145b5d4fc185f4f52bf1dc4d98a11bf6cc6467bcfe4aa6387206b2a9675cbc0662f7a447e1859f8db10e3fa29cc1b1e99b5ae27c80f47ebb6c80b6ce6c70fcd832d8ada4428adc251d43d33fcb445434299f53079896019200fc2d8eb3e1c268e15c6143e6128cdc7c0f8abdce9532d8bdfccfcafde49139581346e23b9afd2af958f6ceb8b790940db22eafdd7adac6094a4950357c15a76150d46b906179a4a3b5a736a23ff6a51216b13ee7cc51d3a7c9fd211b8a4de3ebdd90e5b8f539006a039447869ac17f4de3870335295d2c8033acff0c96e08a10eefd30419896fae53ab2b22ea00afe488566d4cbce8399cd5db2630392e89e5c3999bc162061b45ea7a1d4db38fc5e443671614658e85d36d9664b96166d43e6f88d9117ecfe4f83c16ff7ac93804142e9cbe3618f8dd23180a28ae8b630f3afbc3668737c2502a61975eb1c02bce91a3955174dc8281399007e8caf306f906da2c0dd3fdd15f1d1ecb0848d8d6b33b7c4db6de2137ec355bbf15ee5cea8b7eb36665dde843aec166e423d80180011a7cc64a7f3938992ab04aae1a87378db488e80d1f9f53a83f371b12179546f5d8c27d5dda0db60c26700fb27ba840a6a629e8b52dde6c24b8c36d7c70ffc7eb2153f11e5aed3571a85013a245f6499552c3d71d793e5c8520ebb3f3056db183f5bcd38e36e5b69d1a127631e50504db3580c9728f8529a6e55ae03b6f8bbfc2643721d31f5fd58bb58031696478310cb7661b566d8d5038d5788533747cc9d2fae5db604ca95c41e18c1cde09342ba958e9ee8012c9549374181f46e230e943460a50274059e9244378e88c55e518a13758a790514940589ed605bc8a1bd55664ce408e3dd25977058ea98bd069df8ee1e0d279a2dd409476fb3b4d95b3d85971dc05fa109e375ca160b79856ab55107d86547a7e2d718e0309f231159b0d8bf245a12d7683da49de59409baf664eb9ed93da493f405543ab6879d46a527ef23366383fb5660373619d9e717ef9e3efbc2b5ccdf8d2c848ffdfafe1646b5ae80d909a0575c57a7687c604470ea48989786bd4b06204e9c1e8e6c0f12782d09708f24f5d7573cf83948e675ee43a4dba63d3048d441aa7044f005a56932d4a231ab850400aae41ee89ee10da8ab98fc092bfb25f620a4c7e0a13b2138c5399b9fc1dfcb1de6b4f14d7f44b8f4a765a264b3c78a3acb1ef2ea4ea20b7c94d7a4fe636c41d19992ee809c43407bca63a2cae80486da22d89bbbd1c5f4fba027009314886285c6337a010d49dfa4340d057e13ed1ce595aa6332849080926987f46ddaf85ec4c6efafb265feb36ea924be2c053fa33f191b7ded762aea6df7b08bc865154d293700c432bd408a63d5e2021c1a0bdf926dd4213e260d0674ed545d4aee9a68ae314e0e487ff91d122fcb36f9752395251dfbb9bbfdd43c66b1cf01c7f5b8df8a3b4eddb1f726560b7c8607822c250ccf0e39ea6eda13b72deadeed74b3eb4b8d1fc1c3172e1d93c177f4f250b5efb497ae7720afc318b0670b02de9e9967740247d7b962978059418d0eaabb609de720fb80c1ca3e03707a827ecf546bf3e0317995c053af9ba59a8b4cd609380a6b57cfc29758170a98cd9389becd50c80798af23abcaf450b205f36aa040ea1978f9a24f90d1777903005a894a61aacfa64a36ec2001d06e8c97fc26acdc58a5424f19021a5dee4212f1e2299a47c216b4d5ead3a0e3dd0e214a05aa9c8ca94cbfdea6c9c33deedf79884118de976e87274e4be5c6dbc037150277542afd6988c8ecccb0bf104f847a06691637c3aa50ae1ac6b14be5efb25f9025e7c252852e160347e54437d6895c8becb650f1f1ead9b1018d3039290e6afd968f6ef2829086868605870213b82e634f7206473c761953d3133e9009ba6d53be820f736ef2816e7207718416fe2a3abdb7a77b2ac0809cff48a41c502787053d0475a6adce3cb83bcf68e2737bad99d817c90bbf52300a24173a3630b9c768bb06dfb4ca2d8cfd13bc8a0c1fa8a749ee1184843557367a947dddac0e241ba40d10611bda31068ce699df21dc9daa5bda97a422caf696b64cf270755e0fdb59c63a658ad306bd5c4f6525b3b657cef7b4f58e111c439794ac021f2d69697f582dfc209b42c572c056eaff14611db730ff5172a0b9e0e5d27d9b03384f9a41dcead3be8d8423dd77be04af56d0ca1779ef1c2a6cc36d1ab3abae9dad669cfb9e40b0bbc85a145e14cc9a8a645a652d55f7a4d21b47625f91585f0a8dbed867b93daddd4723ab93116fe534dd442ec7bfcd25d33bb6a6b0be3fbdea85afc02a610df2825294161a5a4a7bc4121b8e389b86bc82719bcfea05c0a1fb61523b9ace29a4d82bcae16b1633586c9bb8b4d22dbff97fe3a41341c7f6e5cab2a0cb862349c5c63829a4e0bfc249d74e951b873fe7f602432b2576ce04a30512f4db47c849dc7508f439caeb59d64626150b09eef5d31e2b19242a0e0b793ed2b67cf3fb018c3252adebcb75df7e3a63af1dcf343efebc83d8ffab4d51fd2f04d676233b0a92f4d90cd1a0eeacf16891cde6af503836f7b4c61ae513036bdc4b3d4328efe3a4c4f9d777166bba8d08740b89e2fc2d4a51764716b7a9405e27e16417d85c25cf236134291e18d5c513ddab2891ba889eac95614b2f4478c74058fa14a328a18628cfbe675be1d9629c339e6d84cc68f919dd3a5b84f52bc95620f7a9372da8fc0b85ed3851ebd8e1d224fb76515b217d7f44c7dc5e5fee9580c42d1e4fea2f2a8cec6a70b537b95d93a6ac92bda448ec446c69fee34fb299e0590fd4950a58f9908ec89cf7cc948da75a480e476f5445e986ea93a1ded05f250bf61a7eb9443c0e0c784cf5b3754d8cdd1d10dc1719bd99da732cc69918bee6bfde1400c0326edbebe0609aecf8d15b2dd30bcf85b052a7e2d519ba0c73b85526ba79bdef2359a816127d885f21c5a3da2699019e8de492a5f0c70072e4219c303310d293e34226df72d3b1294244cd9194bc935e1f65c5600d0faf2da7ac7ea9da9473725b14ff8000802363a95d0cac76a260adb0acd860e50a7e7eca0d32ffbe96aa0e51f9a191a6bca4bca0f965f37520297f2ecdae3d4ca4faa6415c671380137835f33689c94f0f539c5c2a181a5abe9c2fbaa1c5db72f78d61da9c32e94fdfc71e7328888db2ee7e9d1ca0a81e402add00b87d07e4544f2628ad73df09599fccb62a6deccd41795249d5e3433030ab193d908f0856fa2172b33fa3f6d5dbf8cfc6503965368359c32a8506e7172cfd3274fb33a1d8f0ba1503092353ef9305d903256be93eb659c95e3fbdc0c74d8c6710c453803a72e751aa0892ddf8e35574986410287db499061cd3f49c56ae9dae9938c64be29edb65391d3593673bded88aec0d27871ece300bbb314f1a8d11c37b386228434742b20adba2cc0dc9aa8dc3dad80e63089342aee64852c8cde0f773979b53241c6c9c9ccf083b2185e1c0fe101699935cee4c12aaef9a7b7258cc6baa2a4237c533732000386cb07ae108830178748cdc1dea7e89a629631680af881e7e52308e71bba2deb8c4807b45264dac414ad871db503008c6bc2d6fd575bd99918f0f83e8e442c165834967ac6117c8e861d22f8f21ed2f94c61194deed9a3030aa828f1c6e27c4f9998c7f211865ccdab128bea031215aa5b2091a4c45aae7dd763e22c895170740dc2dd01c8f92393f0d10614ab735e1db93cc3f7a3e6083d875a19bcc658d5e94723796c8db798f37a0d69c39864ab629073a89973a4b32e089d2f354b14800979c5643e0ea189c9ef3615efab9aa3dad3d2b1b60469fa2de807b6d9ef546d946149a422d566486a13b9ce56801177790fd9089c5e4db78dd1a33e05dd5dd02d62e856a8a656db751ff400cb92601bd8933feeedb32e4de46458ec52e586ce33ab1998cbd748edb48a14d853281e24e8403b01ee2749c6ecdeeb371ee4314c3cb068795cc5c2b262170641b1fef370196033d2269f2f6f2b2ac982ed7c894d4a193fd32faf3d651ffa72a5c1ca28891e6410cb1cfe9694d0e7015438c4a6a37f57885b938d2b6e9d881d1c32a950f99f3494fd0ada4048432fc4e1a619018756cd06d196e4e6fd777446d56f0e6f1f8b3fe8d04cb56aa2f6c14d3b88deeb6d0c0a46e06b581fe815d49c07e0a67f49115de68dfdedb2b2b7d39f4c133a1ab115a7b425c38d3b337b711929a5ff1f1a340f3733ec73c665c0e0d99cc4d97e9e914929ce5976c0bfb69c98c13b48490cfd3d06d7630188b634e9049f6edfcb2299ab92651dbb397ecfe6398164f655addc7bc3a8a9a9627f0cfaf488cc075ad46f6c082db8b93812e2fb9f6fd76309a12f4f71ad593c184fffe82cbde5f17adea0ef1c0a73cc3de7e963ee78692e2e47e843b95b09d9ccc768c25eb093c41c1adb4c74dbf27f7bdbe67ac03fc73248b73c01b1bb04654c30f95c6b04cdcba5801830a31bab5242f83aa64c31d21112f3e5d076b749e55d162eea8507ae542fefc45593861db6aea99a1d23d6099a049434b4260e6fc64bbda9220bdb0995bd01839f2563d5d8a441f65e518d6c0bc47038019f0dbbe59a09008f67deb2233ac4e7fae86221f1f9d4aa3e0ab47d8ef19f6675fcde530fe9441aa025e4e2bffab8e9f33de87d4f7060eba8615626aa8089d04dc3f83b37db0403cbcd7f1be1f6d3514bc7108aa690e04b2498e0462b326cef7a011386042b6416120a12cf28f46c400bb97bc8f3e7363f0992bdd491e27f2a05445773c20d074b5d327d5edffb500e1a92aaf8ae7293b9eb74c6ac033ad02d46c68d5ad3f7181b3ce4e16eec80c088b6dfb300ae624b954b0d72bc41b4e3cb1ba81bc1b4173dd7d14157f156555736a57f617cdc33a4059cf35ab46827d6dc6c9ef142a6eea99b87f507895feeadde015dc8f44dad07dee55cfed20c5bb11036","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
