<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"91456fe579c0c56c1000ff739a456c0a48766d244058da0f7fe8b7ed1935be39666ba14e6dc95951f69342192f29ea027ef1caf4354b1e385d73b59efbf525ec0ad62bd6c83f602c53e0df8828445883084e6bfd88e44f4c75a1afb86d1d5b3bb634bddf673e6bf59646738a99cc5ec808e706ee1a68bc7ae3fdf5e775b7167c9969e2993d7beed3fe89b63907ddf10ef47ff75768a41f7ab7dbe38ce8f055fc81048c366f0d64a4b987711bf78813fb5cba5e2cb3e6a962d87e3abb7203f5d7a2d5eaaaf90105ec6d139444755ce415dc8169f40f5d04d949ae1a2ac053b1ab82eaae79fe2b0ba27bc5d9cd09e1e5cf5ee35694df50ddf4722645b7016735946be282aff3622a394e5df7b2cfa3752a631030cfb263fc88290aeaa0ed9dc5f84b85a1729775fd0bcc1800bc666acc176b514d8b9551aeb129c75535b431df19eb6572a2b24c71b2bd4edac6e6956f2eeb352e691fef268eb5ef67dbfd0a67a158c0f6f5ff7bbd7f5a4af75852c2bd0f13c2d9582e74fe5b90a855963a99e0e8ecc39085dcbcc8bdad34a0840eb1fc0c42f627ac904ac912f1092024e6c53feb5de64ed3e55748dbdd03890f14e28c8dfd020115229c8ad2bb75d99eafc6eecc305b1e1bff8ff509ab619be3fc64e7c3aa58191fae668fcf94f8c806fab8efcbbc78c06ef1a523e1ab72a7623a66a1962e01ef16cec4ff3697fecf40bb392eff774ee1dd68531f480e17db2bc9a5529ad842d30204182e34c8902637cdd265dbccda3758f80d97c021670d049223153056efb25fb22412eac89861a2edd9307134bfc422634815d9d6f02f5b874b9d41e645738f883e01cc96e1ab459f119377a181455ce321f20688190c4c36b8cadb1f08df6fb163bdb0696dcb1800175a768a738b2b0478894504d5b4a05208a00fdfb559b27d8245dd89f13c2e16d280b9deeb6ede7a611cad35f4ac7fa13b0b4c9615b9d2adde0eda7f4e0a84de21494bf0cd5db6d09c10c1bb805b452c385592fe803ab49c4d9455661b136ea319f710ff6f9591807cc4e086096bbf2084f8643d6d3326e94cd45c36327b9cfa43a4fefd6798320c532a7a0266b9e2c648c4d31a594b25274dd84818080c9032f9f826521840fcb9fa309432d506c6f81c14ed0d92fbbfc62217afc6177fa4e312295c0f024b946a1f5908d8dab8ebf2ea9ae2675ba9fd1dac789b3142e227de87427853d6c6853f6af61e09729566026e15a5da65cdf41aac23f348f26e5fa9484baa8b872eb3c1a8473cb72e73caff13820832948b0d426abce493f743da83e588f505b476ea2d5378e0a758f165bc7ff4427eb69b66df693a2dded69767bd39a27a352beabec925a1c5b676315ad10a1651b2524a855731cf5d408e70f777dee664405741c4be97cb8f7ad383cd13473a1d0624fd551722c59f594dbbd72f5a9f2b763badbdeee527480586ff83703255055625916af29f65d6c35882b7869131aa0c7b65ee27330596231f57058825006eda985dacf2f4d25f0bb097969c5e723c37d073c3b4841a4f1fa26240046bc50d94a6eebaed02d64ea3ae0f3b378b0e5f9c2f3ed77b2d6ef16e46baaa88acb06352d34b1f3f7fff1e4426ea7d3fa1a09779b780a64a77d0d5de16be3873e03115afc81409b50fb2fb7f00cdca61899964682f50804540fad61e8f82656218f8f67ba1ce3affe03d70ac9f97aea2f90808260b7455f0b31f7feb479d63509371b0b04c6af0c6d7f27eb489776098cef86690fab47117097593355c87dbafae6d229ab27a9ece76a6bf1a74fc4cdd391115d7656dbe012b7ec546c448e63d2a81d731972032a5db47798cfff541075132133aae63a68a7317ef2e9b893861e937e1daf38972b1f18015bb6daadca605edac8a53663e3669c39fcc2dbcef28fc7c3180d63c91f19008a335ca1e2c90362897beb657b5d63188f15fe0e3d22e32db6d88e203d8b82dfd5edcce7001d762c4a7542ce7c1f56ab7e134a577a831170618ace92d80c98fa11f76d31b12e1784512b565e4a96a98d0e17da703a53b80997f660a8fa05d22c00e38055ba08a8d63be0a5c65137ba792eba43907d53ec7f46d43c19f4bf9cd514331345c2b21a1b9e256c3e4555e24250353b972b6acfca08580a363d689c54ae847087bebaedd63b65684bb8e5021586fca0ce27c97404c164b8dc0ceb2ac1f0680a44332e0cfb4b991d8e1d7d69a84ef78083449dc45f7688f4893a8adadd0647f16aeaa115ec68d7a7a4757305b1e8bcc8ea019826e6725d6b48b1713699927b18cf9cfa362392dcf91b1ff73638f738e43e18bc0bfb26c2a18187ad5b43433ea87553029b585edc4f84ebae1eef07dcd5c5ed2d50a3a6ec9420b92f6acfecd94f39f84a348474c67d8c62f601e42afa8db7fd938d060747c3a328ce7cc66d0b479a1d67f85e705ba1e2ea12715a6435d5a2a5ce705e985771496f1d19769eca59045613e0e7eea27ca849c70328f46fbc7dca4a996f1edddb31539d09ba064b7359f27a5c1579714c114a63a3d028efe557e072e7c6958b75346f42651a3856cecca5acc6d714c30cd344fdc378ded1837229be55eb0e66774f57a557a07287db7c34acc074e83bcce962d1202a330156cdc75b15c2e520397f29d84ff8bafae63bd8afbce0df575087e8be0ca35d5fd9d7f824c160d1512b63a4107f26d01b5773d9a93193770495947c246535b74f1cca5d492aa16eb3bfc9fe650738b810c4d296bb8959978702ad4e3d7d5bb79990c9b905a9a89e406d342666fc4debc77675c5a606931489da27d66fffe47e95cb6142fbadfb0e80d7d87438261a00fe43900f50632e362c5a78353c8fd149464b866fd395c33102bdd26f4149ee3911d40bc318b3c7b41c485e14931ad028f00f1125afcc54f880cbcddd2fc6c96c6a1b18b82bdbb51cb48269399dad756886da12f3ae20283bcbdc7bbffcf16d3aa38ff2660e71e4778bdcaa44d79a5b07ad03e6bf9fb4d95e363552cce12f30b1bd9d8c2a5e5abea0384cb42d45220d92789431703ec58fe7ee437386e4a4c90987f7095e3f2d6ff9d30e57045e589241f916ea27db38d05f8f5c344af4d4339f684bd1f6c8f521aa677a7ed3a45819fc3785b327d058b29483310443fbda503e14b004da155cdbb93f203a5468b9590ececa8d244de07ac52731eb1f1334dd79d29a98053b71cde5a3fe48927d762d2b4ee28d3d9f55c389315890ba48b700fe172f5feecb6a66108f44686fe78b7f4ca0865fd7377a0d86d6eeb2fd8dce33deba77c3fb7a6145decc09dbd192d0f4b538dfb09a13cef07ca5015c91052ee264a611dabc2437956a221c27dca9e44099cc6f33534fec4d977447ddf40829ef5d29b8acf7592575e896bca306e3a880b700f1559a5836e1513c315b531d0031b78711fe0a87322ce5fadff87b7412c4f06775455f3be7f4388df7351a20e9132b10e428bd2d5147343291c642351eb5031c0d908d6af408f687f60c80d63c0a21476d419a1accf8ef94704e013482f3a7e3dc2713416a0eda5c52508b8a9460fcd17898bf0d83d33ab9528f9f0df19d1a23905d3aedf92ce34a65309f77c0e0e8084aff4dc5fb7113942b6067ca4331e0be8e727b4359f7c8c3861de67eff1f3ec8eda66bb1af84e10adf391f55dde5c82d0a32d4513bd0bbd4673c510ef30af0212cf33c3501890a7f2a35c3a397517605b0ef747e9f8b9accfe5ec3f1955a6d78f9523e0f00cc7f79ed522466d4f2ec3de7cc10ffe2b59a1b783622f00b3f73f6f062f8a548c0ef07a06e8f3a9867d81f01ecc0a328d9fe86f573a7aaf11ebdfa43fa3ae4ca7112a175447293717dd894d5cec92f506d90a8fa0b03690dc0f4d16fa61544358f46a9fb8f7e7006897b7a399bc6fcc6e059fed42aaaa5523f2efc7a92a829eef3f11f1a6f2d75d6591681b34c8e6b6c08e7560b0d785b7716442b3abb590d578f2241e2c10cc556ffc9db3bbcb9f4ece477c6b50d27d20fec0c4dbc9b4d4fa3c6886f61c779cbd079d365c2558cd58308817ca210be295beb7746dc15a46942364edb36b78b27b0976c0a1208ee8d3b76de170f361a443dfa073cb0bc52ab3bd85537db14820c2dfacbc51e41d3f3ef17c583e40d24243b99fd2f1d8d0b05193893dda65469303d89b07ef23e811e6c1cef33f36cb7f151ad6f76c072e5528cf446f466ae82393fd4889b67d86e4a7229130c7235265e12ae5be594183635a5cbf4eff41fab287b4543022f63ded452a14db4b7a0aa7803aad07bf36aae91cb7f8aff91e0e601fe9ac46aef8995dd14db16debcf26121861876874dd3ea7ff7c53bd7af78351c0dfad559fa996820c69a1942bc739989c4c642431f36cb090c2d017ff9e09ebf771b42cf7eaa2d0ccbe9af590806e040d83cc55b74bf97911132b1ef0b41fc8c395c31b7c792d341c8f733944eeff79a137cb1aa087032a517e1ff9355c3887f17870e581be094cd9c4da39aafc71078c153449ce4395f9d9a78f866af687ce396b572286a1e8757ac13caaab7e914a975785cd80f16faf1d2285af0a38082eedc9fc206d534a34c6269df2d6b331917d2c2d4ffa3e3b4490468b347047db89eb91d192a4803c1664b00b264bf40c74aad5f9767852c98a8e05ffe72fc45d9cddb083e2d50b981537d9d460a65345e506c0287b7a4d89bd4663bfbdbf586e48c4a52e89a4df577905fc120154d98c2e09fda2aca77c7d700f315f4ec72d5eb1dde7f4eb7cdae603fe618520f1961207120a203776cc3bfb8b612063a8fed28017b501bc36c215a8aa5f4e8d616d32de5aa87b6d3f645ea2109ae4185c1f35155be5383b2d68614e42580d368a862283c5dc831341f5a171fce076d4ee37420ab365c37311e488cc4c38d015d8a40fd74ba22ae58a6c50ac25a837e03766988f22a8b0b99fe89a0d6ce4f7918eddf12424d31732ed9b7d5d870415378ff135e5d1b34224a2298cd6a92b99df03e0bfbc6628f8e5b35a360a4e3922e66d4c3911480fa55e50360a6268121b18e3556602f83f1d10fde8aa62e445f905edf573d02606de95358cf0996aa21a9f43f7d1e83dc61e8433ecc004ed815b623ad684db031de533a578713a1e0f5d1bd8eadb5bf5d12c92f02720dc7772fa978933b5cae70319779184e797ea1f8c69304da7f787cc9e9fc4652e597fed02316bf2a861777c2af495a70e7b84c90c54b7daa8d3e3bf4c2aa36a5b9a335a56f95f9bfaaf5016767090676db97cb5b2e80eee97d458a380e21d81e5212e7d66a25f31fe35fb641f4292180abcc199b5f42db847ed71fc7ed56aff426c2150d6a3bdd96b0916452025cd4c59973cdacff032d67ba507fbf6acaf90dc98a69820af276332340a26b5e2c0d16bbfdcb3e97c4eff54f255bcbbdc9dacd0381fe545a61ad53651ec55331d461b3b814aee3d424a25f715912d8f157002df28046d7fa70ff0adf5c120b96f044c5c522f35294cae1a92c1303998a819f2b1b1fbfe41fc1b7fb48e36b8b9c1a62f9a8d2b32ce279f4f73311e347b945289d62b6768220d934bb59f784eb3a7ce9ac844104dba595572fbd3838fc45a8c3d9cf3194f789afcca3770480888904a7dea4dcfc0df0c06766367aa02a4d8747d27aae695bb2269501f6b72afd9eccab56b215e9b016c763a5835050c3bc6c0b36904e87463d9314d92d31277bd331bc3b335e6ca718e0bd8aff9f2bd705f0ed07f1eaa6d3580883ff8f697a04a1399dfa04a8f1fa15b52689e9e0e2185164e994fed66be272423d4e6205d9d0837db2f207ad73c9c75c2be5a0577262ebef85f648cb3a3a359d8f9f106ec5866fd86802e8fcb1f5dbbd01885abe2ad8f57c1f098ad9901026389406ead89fe79ef61d50c44cf51e2b33eef70d43addadb2bc4fabcc75a3c20609a8800e13a1c702a55551931317c7e5c56e84e62c945503b59c13afef161b9a140f0913a34ee65d492af08a8292f6c17a207ec63d7fca2f435d8c096ecfff3a5fed56617cd39e1e2d4e5585f5bb86a8938c06175b9e80d87564e7ff773b6c2f0ad565550e94af69fbe1e254a5ba9663337976eb6756539f4f63eb5bd22f8d474e503a6eb7fcb0fcccb60cfd8fa8dd5d9038b69b7fbf584645349cf6a9d4bac40f79a2790ff9262563c7937e3f284f8e55b3e473c21d0068bda6736f8850013e3c2385aef67cb4fd934668c8726fc23c1239b6532547781d62f97b73b4725ab211112eee236809c4006f6e60751fa6dbc91873eea1e04665a883b2af4dfa3797d81de92060a085595e55c842812689509939f240188c7b88f8b786fb6fa04a0863cbd443b152cb1e75e7bb58d020cdfa5c5b17efc53f0a56752cf7f6c5f7004155cfb73e3f260a86722be44ee9e44bb48a8cf5c212e441a7b036b2e289b745f77c52fdd26b116e0d8fd514812d90e573bcd508020b38fe453c3bc22ffe5eb9f0b081f94e504ebd4cb8e7b9e667b201c6ca4a68336753104bae0d92f34640d74206a4922fe08d387214a8a30c8477d99034bbd1f0e453e7a3fa39fa3138336a3e6f92f1056cfd5c7299e24f472df80ad2e021f6fe1f071f378afc4b12893531ed1206647a0114c9d28f3ccb0191753f5007383ef25ea2e53711ed16c7f834ad5e9426567e53de5ea66c170a50161d65aaccb907f610e93e7d481b9f731102afc96da4cb5e65b8af64d863df4ce42d5113b41cf6bfd3c05aae7b8e4025ba61cf2605a7ac5964afbf3ff7bd27a48c56177101f6e0d19ed5cdd8ccdfc9e37132d33cbbe644ab3e5ae8835bff774a03c51507ed3e829f5f90bea47d23cbd56b7b7d4f91c2a1095326f4dc637d396182726a8a05c4f8e6a3b18ea5a9c839c5b4267aa76bc20ef47117ccf2691f34844b0adb504eca0b288edefd3cb8f794f89c39902036af3f91e8ddef6c659958f4edf50abb3570234bea303b29e4ba1c7e225d4e2884115d369a2b3104288ca14e0d848963107069b98a3d6c9c3f8ab0cb50e5b160087c98c317c90dba2d6f241ab78ad3fffd6e385d9e0e71c7fdd511275335f8853ebfcfd2e8de2d31522b41aedd70fd9ebd94542b0679d1576240807dd0f69018323bce685dddc73474e551be4e249172f0bafe02d81723bd4e59bdfcaeb65dbc6ca6cd65ab7bfdf0f0fbc0d2505ef9a4babbd68511fc3ee4ea8ed54cd607b867db344526bcdfb65a4605a52af1bbf66a0e821fde4f18e84e282a723e1861c19ebb9d21cb1320ca84148cb58dc4111d251b28dde6713164b0250644e49042ec633cc36c6d0384ea6e336e8c0b1d9bdb486c635c33f31b46cc76590e265aa628afab56fec8e68830cf4fb512d925c71f2e3c4d432f667fbdbb7895e4f815437ef0f6705775f81815d7d709a1d5f8dc1243628ec7ca40ee359de2dfe94ec1b4befc4bcc72e1faf631085029467cd0238951c41fe4a87b88dfd7280b436dfbf2b4d52c75f7ee46b71596f5afa24f79c04399472c75edb9b6245ceb31e935020958826ae3cfb65f54fb64f7faa4cad2dd0a836b763d6a740324a6975968ced7e537ea9fd46057cbbea6ae39f09d31f19d1733d35dca10acf40212a95fdbd5e89bb3c841ece2c9fcd345392351533f78dba2825c65ddf80fbfa0718c649ca31e7abae4742c6461b359a839ef4e75e2e62907dfbf05a0a50c37ad91456a48237e32c1027ad635c7aa4de50fc28a9369c1f4ef3dfa036a3821d144a893b871b112f5b7ce8a7684f2757a67d2f3799b567c30938d7757cc14ca80a4fd33f6ade6be9bd4cf195913fa0b0412dce3a2a42397a4863c0c0648be904bf98b2667edac5d9640bb392f77720c1f2b199cd30c9dccac2a54f82680c1d76a00a3b846a0a3fcd8aed0396f23bc8ddafd51390bea796e05f4e61cfc9c8a312df5158e0d03ae2a223037f04e5b1cb31959cc82199d733e11226b616a5078710dad378b64fb4f12e5a2c50c69b852163c0d1f2f11b0c4cbf612e4c28f00e60ac48ceacecab990af5a5ea74a3ee6d38974905821e549c618d03b835384e0c1e8e0a74d5fe1a38e8456bfaea0f5b4b7b08cec66478c5120011def74ee1732d62d6339febf92c646c4017ba5f2503e2bd4a84c96ba20d78d29867425f6bf3134f7d57bb25cfa6e3608a9bfbba5b00e3377c3ac86beef2429a8aebb934e523dd75d22e0db4f491a403899887d5e9df4e444eafde4ba717a8f1ac044b26b84741bab6d10a7e64e54050826a979ffe5ea7b3d181590628da4a61f8ac51d65a7dd64b1e75737638f379902d948be48ac6ae29075a1ae48c358ec2de59ba269588ea1d2441fdb915585bbde421fd9937bc42f1f976d402173c4a004eddd181e8b9a0e5b872da6d3dc246184543c8bca858234542942d894c8809fedbbc40fe3032bb917e617a0332c4dfb104524404a9d4fa2844e39fa85359295ea10687467e00cf59d54e706e0c8e026cde2005d6aeb41dcfdea23c182432b1b9be4d11012b399ba5fa6d62e00ef499f889cd06787cbada8d17712ecc59fde6e39ae9e737c69c6b1f3c7f56d143c9fe6af5ae3496a0ae361415804cdd7fdb37f613edbd1da75fcab2b0d2a2b40ec8bcff1229f30cf46b73359c4181fce187db9996786b13ecf2918fcb3d5b62e39da77da50fa253bcca0e28072d38e70fd88cb2527918a918d7afdbe7ecde3da977a81daac8189403c3c069ef245d0afb8daba4352d0e48371dec1f5853b2d965fe560e62772492b5f1c3b3abd09c1cf0fffb6c9ba2e789965eddffa7a953c75d4502918797109c8c37177bd072b446ae6f56d94fb8b448e1cdedaf822c1cf26140e70303a2368783f2ba8997e07bd39d07c2bc3b0d3c1fd29481fd20b50c948e4c142f47a89813da62bce3351969986768cbed3fa5f9517ae405ce72485972ed39b320524efb6b83b3aa010b80b78bcfe093ae771f709186fdbed4576bb45d0d46a65614ad1d2f72e036190bfb6b5de9b609d3cb732b6ea07942197db5c19ed1e52278be20fdfc8c3cb43166b1739dce7b12c855f5d1c0540bc607a0ae26beee727aef48a0a180e27dec691aec9465d50357f6c65f021016d53147611476a6c8eb74a186b8f07b0bf9c0b404b645c999fbaed6970c20c9c20d907801b34aaef3f2bf7361e62bad891d50d6eb846f16b83921b4aaed473a1548ac2448f9b4366325de0d44820ee823cf2858799205db8c236c6bc3e19b72c5d7e86cf3f14ac9e513eeaa508860857ca174c4093fb1994ad4408140853145fe7024d654ed37601990e6b87d854f46c4ffc46f2eff76d0c6baebb53250f13cc19b92050df4c0ad3923e23f092679a3041ad678da5d7c2f55d11ba6c25f11c902fe402ee1c531507fb7480ea147989534239b49fc48ed2b2cec9f5c2e7c49d52beaee5061d25c0968b833614478c792ade629e90aa92b65fbbd8a9d0dd9e09403a57583ba5ad5206b111df0bb6bbf642dd9dbe534ac4322e2657607c6f101d57e0dce362343eab5947a33f0c36881f6680e7caeff06db16ae98f22e183e1ca271cf0c7babf1250b90c423207754abf128e5e5c334d7b8139341af62eabae26c618f61bf07cb90f547fa0a4c45b77531eadcacbe4537e18810a26f3e4bba65818f71473f75b3bb10b87f6c7da2c2f229f3bdc3530e03211c72f1356c6ec1cbd57a1cb9d4bebc6a46297e49a44d40aaa381c471d278ae5e75aa600a89406492f8312120e0a646de4acecb02d0f20728b0c2c5a1ebd27c90770b12897857c82ae7df21970b1188c9aff40ce3ab03a1aab914a97b57a8f5beecd08f2f5700a5f4a78870329b08521bbd2fc6fce065a53e98cbbe8ec35bcee25ae3cd3198ab327577e39583e825a1a23e90ff7c40d207a82a03cf03b6774cef8060eda84cd68699854c26d7b856ac98d236cdeb8d4f674c4c997bfc23b31de774aa9bec885a59bf92786c211aaf5c5ab2c5d220ca68dacd10802038f92500e3addc8a4dff2bcbfa43637864cf97be762d027791d5d8e0c3930b9b2a72171138fefb8054a780293de5732a803fa1a2c20323f704a37aff6301d9e03ec3921737e859be6045a0094bc1cdd1d15bc76dee1d9046a1b6ac3e2a92141d31d7ffd28b543c0982e80c22b5ef1a65a10b59f5c3dd231e68d4d29b7fc0a88b452a1c045910972ee94ff59e8baeeb9ece8e98740db5e74ef1deb023a5df479afe04d023d987e42e4d77ddbb7ce5d9a488f62bc08e07f6b5f66ea35c96f0314d4d7b5779d929c855dd5785408cc22ce13f0b45995c053fd7752a40005d3a18d2487b2b907f777ccab9ad84e7ac5daae7b27d1ae5d26253aef1c765d896b156431107ca42aff014dd7ec0c63d39f0c094dd28bfa9d2bc3c8474a5fe71a430fa8b3354001ec73f9a3563cab784133691ffab90d9aba7867b23c199a199717e173a50ca9092552f62ef5f858e7faa4adc40f53cde468aa1cfe2471272aa74e17a5060b06d68cbb18ed28fa7c3bd805585c3fcee922c31b155a9dd1b0481c4284a434776f1857e41894dd7bdc82e9da23b7023e68f4b22030afaecdaa87cfc093f89c8007cc7b70b88921ad3dc450625f4993e58fd9898b29068f2f17925b21fbb2346e32487cf9721512a3554d712b6d1efbacaa91ab3f5c682b7f8ed71092189a4db08d3afbaa20420ca7ebefb919b07eb0ea9a1a725f406d88114fb4ebec5ce7f8db75d6fc03979f23b2005a35dba2c53d0f6e2800dd6a34614de4c9264ef056e21c8446a56207d6e55f73f99190417a8667b49db30242176b34a72c63927e1ffde21469aefc2ca7ad4fc381eb02eec410b7a485c48b3814dfd309d401faf53972d0534f3eff0c41cd70ab94f01d45c436683da22c22acd9162127be3ce8510bc28c5d007564c39509e773df092ddc3a216efd0d3edf770505f37b4a0c3ea3f0b0db6cd89a214eed7e308d0223e50d9ee027b400f513fb02669a5e94221d93ec6858c560d429d737c5f2354ae1f340aa858cdd840a7497829231747575ac43a78969dc52de8562a266a13f1b1df503ba4b833121c08a1343943022f80e0953477331c16bd12a7bd2832e85cf4afd793b6b6cfb7e6ea8aee1a3c478dec10c5b18921d04bd4ff25b9566459cf10317443fe11a5fdc75330e1f44672faf317f1a9d80d217cf46e18a11ea766b1cc026997453287676475414618c5edcec1847e48c38d3d9a09043c99b6238e625651df56b4d76095a780af15aa73a9b14a7b485de4e5c02b61190137d93278ccb69faca521e05e7e2d08c5d1b836af483817a131c16c70241a534b82a1ff3cbb585ae487981abbfecd75ac41873eee497b24be190e93d80bf96cc0db45b71bd52e8d84d72dfff67982afee74ebc6688f3664b563c0281571f5a1b9204c8dc6d87b39de48673c2b70b617b6f9bae17eddfabd5c4c90d4690ff6a9289e10bbff8a600780880122600b8cccb2f241f9d4c0959d07d3d23e40388606faa960098ce56b3a128e9bf4670db16b24cdd93b84d8026d7077ec5c09e7629939d71bf6a645e593b24861c184618ee9df3772861062839a9ed1ca564274cb2bb54ae0498161e6c341279e9720a6b428e9050891fe91b86726ee0452a05d6ade8a70653012da3e6680ef49fafa85e3c5aab792b955088bdbe180e3b894ec9648d842495cd58611a70f731d4a84c5978c664519f0cc7ee8d439c6024972dd375174a736d65e53ff2e6097e253f11c3cd861d9b54eb16d8c18807383ef0f74f99569bb1e11af61435762531b47a15bd8d8864d08379edf63d2d0ac5e60fef84955ec24c7a12d3f1beac3df69a6042414373008a666f00b6c271736e860e8a9f4d7da84301e054aee2e5db990db7e447d4ea688a0667027442833a303da0dbc082e0bed3411d5eb133d8e2c79c6eab37472fa6dd8933e12ac38bae6f626303ecd84c740f472307787b343df153c1a3bef10f31b2519dd12f339a9eddfb499f6dd1090d249d06a67985176465edc9dc8e2a410f5a05f43ea3d778102efad28e09c27499215b12f82db80e0d64932ea1d2a36f46b59058905e25f778257e0aa54801a37dd30b781605e40c8ab898272a6cb64397e4bc9d4cff1104c60ee5d570f1c0cbc22e86b9c5781c07e332334de9430a03d2f7a739fdc90adceec4b873068cc20c9c476192310e51ec153c5cbe7d8e0bcd0bb4e77ad1a39c3b1fb77cb2628979b8aead8566f609d9478027e44f4c76069fbe3908d96d3735393b0daf76e188aea55d98b623441bb5e0f85b57327065069451eb82ff25b6ad24574c544c8b1074e701318d4d73112936db4ce0f392cb14ccbac50d66baa5b53c79ac059eaa4794d5490a8772e291f05c56d69caa5e1038221bb6ed8832849056ec7cb82e90bd3b59a795f4d06ebece995396cfd04c6eb464beecd1e195e82ff07a1fff7fe5e39483cc8964402113f1e2f08f79f594dd285737827b6171a29176b7fb46e26cf222b0de99a5f1dc3936e2b867428ed995d4090fb63ea104fa99648eaf9d65cd93b7302ca1093d7e98db21777cc15c5aa2d4461a66cf67bfc0c19ae9cb8fa7c88a107d58e78561397abf353c6fb0142d3659579ed28a4ff088483150f00a7cc4f31f58c3b89321ce47fae67c83fd336c01c495d7806e7816d18ece6be7ea7b5bd71863dfc27e16fdf1b06a3c7188a448ba64419fd745ad69044b9c9d0dfc1eea85e4c72366b8024b9f647c96e1a6d3f854c848bf4a5def767cfc24742fb8cff8b4eaca032cf93970c396474f790848250bf656756b45c44be483adb0591c0354b528c86673c0a13e7218cb38cbda1d406cf57243e6648672ec93c2bec051184c69b35438132c3614df5b74e69c2a253809bf1ca1b7a54b1ca55840e1de9a307a46947bb58c7b715bfafa0ab7ff77e146884d1e6710b9fb0297d1404f3eb1ddbb60601a70e219a1fb41e136f1f8e0465fed61b14843bb93b8876b6befadb391cae3a4395bae94f91ad6d5029e7d2851fb999a6958acd7fa513dbd9f7991ad805a184965deeb7c4c2109997c308bac0edd4864d7a121485c5ac82fb788720eb01308e090ebca9a910504e2de73149b36c667c54ff984ed73538a18b718582613335dad87add8c3e7e665488aca8a3cfac78c64ce38a8aa7e470641e3175144bdb8b326fc051fc46988a3977dbfc6d5e498b15206c14ba1bfb61791cd6373e2827d1ef41d10208c74771f90d5c241298ce0adb9bcc0e659e291dae9f6a9fac7da61fbd01e4ff01542ac7abf05b022d086839f4b2c666c29cfcc1ebd8de06f0878a019906964964e1b3cb8ec5d1e058e0fa34ef22a3b3515019e46d58298b1165e6511b206b22fb260fd52266e12891ad25ba69f236c0c2d3192f3aa18b3ca11b615ae1bc8e7b1c4eb851679caa592309f2029f355897b0ece25c347bc874f75ecbc500e21eec9fdeaa5ce02d57a33d11e8888e248d31791638c490e8ec5a220c51d7d48fb5b44f7347a5f76d69d07c373fa64ef8ff4b2b02efc622e15dfdb611b1a1f80d4dac75b9e29bb1787fb8d0299c9549b4abd9149865f838fa893226a9fd53d9178ac697499a7804c8c9402832386fe15fc8c2ea38e20ab6d932d88a4d2b94bcf8a0be2b93bd9832fe81e34fb30571f046702a4c83deaffa515bbc9ab8ab3356ab4a4f88a01b560705e1fb7941d215903742da0dbf28fec0976727b1f258db42add5c9286b66ddbb10a7baa8d7f71e315d3c33be267617707bb6a97d5917951b5470e8dc9b3702976d319935a0e0e98fd2088c4788e68fd6f32a23adf6786cbf002327296b61beec9ec13dc17ecc3617f22f2ad0d3c55eab4efb51f4fd11016eb076999e7710e0ae6a07f17bdba6b0b9dcf190ace019ee58cc1f8b91e3b90b62ce50e54c6a41b5ad73410979099796b4200a549c4249b1d1b31e7b86b8c45e22539cfb916313144eaaf073d02a71ab08884d24d1fcbbeafec4151157d2461247a13f44b055550077830d203639087ea2cf29a5b550a25413ef130c438e54ff7b155c12cea420324e7ca42c423d23736e95c9f31b861ed084ec946bb3aa9bc3fdd4f74bda5f769bd45e02be5e99dddb0f7aa119d82005785b763ed3beb0946a855b80b170469d1b2b8699242283446ac816751ebe1b11681f0a5e451bb926acb9d7d50ac79bd0a6beb92b95f3b6f10339513d426ed3e0db12bab2f3d7d8b39bd34789bd60cda23bc2f63f6deabf8e0d3cfa95649fd84eaf4ad6d6021f3d241d5558a76d253a323cbc0ad1d66aedd4644f2f7c0a6ed28194211133bdd38e76da1e976a9faccfae0d8048930cc768fe844e4444f554abe9354a81960b4712f61dcdf5d9750d48ae654096ed00e2e7bf938e66df02a1d863c6d84bb2ce794e5e430b5cbd2a65017ede36c96625d0819b10aa556e1e210591d75911ee2921cc8e4c3bd974f603328465819d526618465903112439c69dd2d7630e747ed3f03dd3f88789b6bc48759b059c3ad6f0549df9088aa7344460b1a7515754fbc214d86c21275b3b0656674af45eac81b534abe8aa2e6c20da073b273472224985db34f806bef72637a947433f7ec2e174287d84a66139e0a00a98a233a550d0c68c30598f10996bf49e7bd57f0f7e1904d85cb5bb3f34a77d93a9e1bc239a2eddd604ee1ef57af91b2c9f5569119bde324f21c05bff4055ef153ae6c17ba9308c294ab4c9e1632b6786d84d427f1dd05a0ed00befc9ab4ac01f93ef640463527cf3f0b0336ce7ec8691420db0f36bc470d7446f132e20a2a887620eb3f38f6e9a175c70758a27c4dcbe3c21591b7404b10d86abd2904d1c60cf6ca178dbe7d49d36ea07ab40f0f38fde54ebbe31b018b3fbd248d1bb64a7827e5e9109409b9056979504054fcea4ca1641dfd17d002dd7636bcd943b8ee96299eadbd061c8972826fad7dbf0b26d074c8cb3ec9f2bad274b762e3e3f75634c9b1db67e108c4ae398606ab3db275f9f8094ead61e08806a8cb229e09ec671819cd18f6b282da99ca941ce13d1b7fdaf3481403afe18ac7310536541295b65be4cdec756e684eed5fce05b7e89eaab77293c17a5c2e27d5ff835de6efa315ae93d3adffcafa5d5dea8b34ff96866934f6aec15b409df3627599cb076d86625d6e33e292264e086cd84f94f8f69b1694c84db1d49e6b9d1264394718e31039a50eee61626a6b87ef3b782087c6d499f949f509776b6360456f99916e519bb341dc284373f74d59095d0a200a6fee888f644860c95dc2cd173a12455c37dc7b155cab216dfe672ba381654d0cc4b150751d8b2c8b67e3b88e1dad9ada167e01090e8e58648c5ec414c03213f2526ade5c05214b2a443a605b9c69f614d6a984cdef22ffc2fedb8bc891e536b22477113bb2d7b304a02fe22d57a45e5159d0ada1216fc430cf64502c6de2f45a79d66bc346d76a84671989d415dede37402707889c6dba83be04d775f333830d9c8dedb2710b60a94ffc653e87057bc16a2946bd55d677e3cf1f685a57182e918a8b4c23f83a2e4754910375014a796c50a64667b794591859688fe114716c0a1257858bd0a0b7e669d8248c924207bbaa4e5e827ab50f856907a1db3be7475cdfc69fb3b468aa87c757d601c2416370336ae735ce131e163c14adb28f882f04704f7e942b7935ac0064d607e25e104f3db52370f44ecd080ebf521dc62ea73039b615163a95c5f04fe81b34ea6619299dd3f7180d655dde207a6aa09975301d11918f9f4b9a2af8c2ec796aa87962ab81d011a23637c90d5a942cb4942748d9dff545097797c180c4dba581c1bfd3ec1703f752ef6a93a1542c2d1d156cbd90278bfeee2d4200cb704f8a732efdcf2a68b90b69bfcaa4a65d9ff421c15b2fff36a03fa5a4d4ef04d4aeec423c6694a2b96720238bfedeaa665f8d11ea2e486eb5163019be04fa0ba9fa690b922b400cf98105f50668d59d66b5f69c0d066226a8472a8e2d7fcfd65a68dfe00bd909883fc37dee8d9ff2eb4fe807c4634a13cf2e3a3060b5fa3883485984159e53aeaebc17ae3726b52d6aff9d3fd876f5c91f0926518a16ee20993f15c429f1688243c5a461eb82036772871ee7ef244c0d75f8da366576973e5b603770d904a547429d31481aff44984c4b33d29515d5b97fc605c570710840dd782624a0b75fb69ad0f7436637a96be0ea9088ef2c6ebbe88861917490b7ffba33102569b506b4da46fca786f31b08187ae62feec33113d29c6d699edff3b67668a4a003e7bfce5227e8a4fb16abd70be764bf58af96dce7843b9e859dbb25ac8b79d238fee0b71bf89f94f7bacb0f0e7c701df47a45077141d7e13a23dd758ba7f76165a075f85fdec35ba5edd2ba1d95ed487467a7a4766fce7a2bf30b32841319cbfb04cef9e7122c2146678936a7ad51f8a1eedad6221c0e937e3b210650ed285a0a6174db6159953091f683b03b21a786da7a6b9d69d9ee8ec967c6a5f11cf2628d3619eb29140d8c83818585c9086da9210c83ce7e9032912fab5d180a301e314c2c37ef2ef7bddab722c4e04b069a38251a9e3fd9422ee5672c49b309a4fb166ef76627e10ea500331dc07998583ec627bc80b6638efd6209412a0a5a6bc038adc6a4547d8ba74309d240f58bf63709d9301c6cf2de3fc6a0dca967ca241d22991ca86e591fa6b7f9b3d2eea00116682e0d9130d0af52130375bc38271cb3576fdbae238a759d23e717b71be1718f94787cc2f0dc09d64f78d51796e47e052a602eb6ad62d99e0a7a47b1ad97612b137fe5d84f89eab38ecae545f1d8e667eec6efe110dd278755ff08848dd731c036826fbebe7692e48d4a72f1201128fcd69dd463fe75421559f710be0b3faf14a1b9b285bc0506721ca7d8a0ef620d789490b05da724593a5c789863413b7b7a2d8fbb38652465c08ab4435453abef7949557af40b99ffa90366e719df875f9d5684ee440ea691787c210f19b37db665e32eb3470579ed0d4e0bffeeb757b7720649038cee06a18958aee5d1692368c1ddc605194212e6bc07bae11e27eea25b4fb35e91f8df06ec242a4169130765558638d557064e2eb9e9c2934c6586e8be8642e76ddb1ae8d68831c97af933ba047dba7412766a97a1a0de7468a0061632e35750e2f85afb83300859d4c56da2b83b17fc60b60467896579880ade0dc3290870ec53743407d3c26d28bb93619e8268d525cf9cc37fb83eeb7bf2e313600f5858343b55b3a426a0a64dae9beaf3c4966d4635d74faf665bf3b1dc8f3e2198722c7c15ea6027a604f5bb2d0fe3d18b6c3ccf831b0e3b5c57f2120a4f1b1e06fce6b8b07958e0132b7648302b6dfc2772b08e1cc52899ffdf62f81805e129ea4529fe75f11e2e58830977295ff3a7826f1bfd26fd98ddea810a664c9f2d6e639326b1bdcb783c8e693bf0a0558b26180cb3f6796f631e62cc3a2147df1f9e65f32aeded9627f91b54c7fbc79e8a05d41b4b8b488adcaf2d08502f61867712f46144bb023aa18f4dee6d962879160f313de670e4b0e8f75b7a75d930d91bc8ba424d4e16cf2dbd99c178116cba10dfb725f0f083b7e899cc9f95a3165cffbb023a5a5a1feb4392f6e64e3ad6f7c5a8ab221a2b6cd2c6b4f7af41e41fb80e272d191b13d72fee7d48ad82ed402ba4c6e61fd9be3b47d0e46f684ee2b30395e9257ead3dee270f9d8dc006d93dfb94a3a021cbcf00ad11a1f14eb8a57886ffff6cc0e0e4c7cd1c973610a5619b7e964c1f25c76dd122d4fd63f7c106cab6e5badd1982114b6100e9f11d78ece58791e0bca82d3494edf90ff5177e446187c65cb90be2866572e5538b85821d8024e9068df2f660e20ef66ee23aeb63868557c2abc48f1d5b5ea7e78b9b3aca74686c7d06d51074cf89245e733505c425a2a1db62ff30f264814e94d3288193862f031c9a7848d12a4ae0b704e5a19fa48354cb8142a70a4231ccb8e5fb0149c091699b356157f9652e101a92839e44aa1678a9d8b4beb846ad4c8ecf84ce47f28756169b426007b68569a42cdffa601e376e546206","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
