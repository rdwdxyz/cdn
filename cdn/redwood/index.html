<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9d875cb07c926dc8f5ae0aa90da38cce7960007d549df3784c1f44ab057aa41be537ea515bf30c913eae88ac4ed22b64268cd0fb76469f1498e055a937e60f38dd86154254a65bd45182f457e4cb5f7826c45cd5e69f992f4c2dc4f29318338213e763203c97bf73ab37cc41dd95f0d9bf188b3253023e4892dc536c0af23abccc5f7889e231d9eb01a48ed96957eb844ac65ab28c27eda5c113889a02714858235722b263f90ddcf2e06cfcd93e488d64269f75c7192bbcf715535db576e96736b6970c250b646f1a9ead36cd21c0f65c5568d7c0c25c9b482557e4ce057326ad3462cba241753c14499e9852ad4cf43f0f1267c0e84d537e22074a0dd2a78356e729b83eeac74e8ea2b31824465ecc1afb9f213da45c513a10fafb417595921d3a549576faba760b0c42b534df4628d310ed3853d5859ecc6ee8d3a0a757c1846415b41c5a5ed40b9a27fc40d30d27cd362a729a4e5d0052aa086e19eaf235b34a9619f64b1bce521c612a0a36b69e3e40f730abb91e7dadd2c5b9b6f137e65e8ba57ec3165db1fbe61d32e0d4ec271b55a59910e914c456ee4d3dc917a6a94312cb97d657aa2c9c9d69be7470babbc840e7f857ce518d91a95b0f64728a5686df2d65cf509a4a144e3feca583303f531a245f21a373e6a157f8946ad4840cd10733bd5b4aee847a98cce69c65c2e07363b40ceb59ef40d69aed89fead0f161029fb4bfd4f3ac309127c6984e1f30a9c3f12cab9cfb23b82e8445de4b89186d65d5e7ac995babc50aae5b304e219cd8aa1a6aad404815c0b8914b008888f081d993fd48f861ba20080dd778909ef2163f9fd9165077cc9ff47587fe4090720a5ed00aac0f7044228c006ea6c2669dbcf657f138ba38722ffed5ab7be3e96572c2df205a90f581ea09e87b40c1d5f639644985eff0d806fb06733d956591923ee95474b62b04220d982d8833c1b7232a46bf8a4884e4967a607d5bce585867e17833a513b2b3dea1eaabbd139e012e3221c41875e8858eb2d5406c3e738ab97b9c902106959adb1180bac0f5447a31d8ba9534e286b34a7d9a350af15d81ec974328dcf8e50a83eaee98dbd87e5a633acc80fa75bf0aaa428cd496ea05e15af6e98d18fe2867585f6156d6bfff15c23d8f6d4e289d278258578d91f86b4d549dcc102753b5cad7b74f971a2c60a05b214867318eb7900e77852705eee07041b7ec4c5ff5a0b0d644ff78bb70bb65b9b95e7bf65b162ff27e821620b2dc3fd4c6286dd49b8f33cbbe64b2d9f1aeca99904db0248db7775f05e97ccd6c27a6be3f36747107742a3a6765f297cee95ee544d4362455e68b88abc585a57ea81114a64114c17672b7888c91703e9f300caa66fb243663c09e4d11551d7a9e97e3d3b15598210a0c083c0f4060031f505f0c8d89cfa63b5f12f7f9dd2ddb6c80fe6538690fdb1b35056c361dc90b17a8c1be1cb7734a29f9d83c9cce459678239f94ffd3b6110d6a668bd0b8c182173837f08199ecf778ca64ed25ed8892ae238304dae608f53c5e97d340cbf702622c860f57e306750b92ad991dfa88ab6fe94228cea4ab25bb860e875d74a555cfef86d6ee06133600190e287c76dadc251ccf552728f33d730272671c0f2400e8a28218ba0053a2fc855396d1a8389af1c0a9b8255385fbe7e139c1ab87503832846381e2dff7206299b261cf77e3c1cafac5473ddf11feb2a5624cb696634bcec9ff534b0f58500ef0df2cd59a5a30e27ebc3f7b12c5e248ae76a0b14e1403deabec88e29b51cf042fdac4316b1e9929ffcd2555d533e03f29a547520dda984700c6c04c981651c18e017a9901038a4c88320cb314c0a40271d15d0d6e6d5f53491f05cb1a13c6ea9ed9deb9c83bbd0e615b92e339668189f20f915dee4b66732a384bcbb0d424273cdf8210330f1ab62374a079dc5fdef5d70ce393df0ef769501b3a86268bceadda5cd0a2ada9912f26b0964ab6feed4c608eb2cde673ee0c1c1ac63275738d249812e426d354f06544d2fd6dcdeda5270956bfc5a0a07279bad9aaf682e077fb77fecbf34bd4df2e3b719facfff4654498fdc866a18f5fcc4521ba9d8e0f77c669b1cf73471f5c703ea0a348b2c71683f80d1025a2cfe374d506e967d5115fef226c78583a968c7dd4e6c1d0c5d4b4745dd78b906a4255ce05b3e3f46325d0b3b8fa6d290c1a59698bec8f4e06e4472c79e684ccdef2893607cfb6cf5b1fe5d13eb55b957cfea93df41660f5888292712c99cdf3a62565ed2a01990fa09029f01135c260dd107cdeeb3a1e29b053dae8aa26f399607c1c768026305a9abc9b7f4e950c346ab9b5b5444459b024410471c78958f92162baa18103883bec27f09d34ad18e34afba863249c38cc68cc16096a9315b997aa9285e6c26a5a035ec7043d36e66c47bcbb58c581d7e73f68f0a07477b5455a29aa9c95f1bd88461e08d89e8b22cea0999f792d159fb4cd446454cedbdba9e650eb57ad29a33d900844861cd40be681a491c5dcb9fab0da5cc7c0110ed5f2377912be5dde69863e01fcf894490db5ec3a2830def4bf0e9ab903117eb23c802e595fe76f026b3fa016cbecd8b0579ba6f533c946f165366de0ef95e3523a43481720f9f05b77e7c3fb9fec0257bc32b0ea3560776d0bedf8b12a3fb3480b93860bcec3be20b332b46504372999f615ee15fff23d1ee11b8c2f4d07759a48ee6ae4a21397ff34992c5f936e9063fa4a2183c93803d353d6e144522a30aadb0f30cc2bd8007bd0726e274c644e204257e8753f9f99057991a2b906d09ca322618473bed93b0cbebfe6d1cb2b5184a675786602f77efaf0da0a0da4f58b52318662160cb847377d397a52ebbe2481ee81f318d6ff019a440bf1b9da2cc3bb48ca8a6f8ac88ef5d89c5c6e1f624dc0a86b015a145684775baca58c648c68814b2b9fd2324c4f21a07384b0c613a6cde26b3cc5f0e9c2555702a03cf722d7423d1e87e41ef5f873bd47d5c57feddee0c56ad464fbfb4230eea7ee34a8fa7ae5d192338771bb2b8e98e0f2c64d9ba388093e03bdfcec27f9a6b9aaf6f26fa988b82831e57a38255632a583bc39fbab859acb9af6aa2ab344d204660a74e50be2c43c19fc4580417703f8eb60d29a137faa321a759f983402ca411b13f19837d1c8d048dbac573aeb98860232bdf702044cdf6efc781fc389f32a187f25d3cd217233a7fb6b4cdfd6342ad77907061f853950f4702524e79b58832310f07fa9071f68848077293d014a29bde65436156a8d24d8ef98c7e73ad88cc72e36547cc0b281d53352775cb2451debed662ba33b2acb10664c63049f4e5210b6a316f12eff3afaa9a74ac9629ad412e87db34f86521e3d4426314b8f926856704c730e604264e870f39479d51fd135db5cb302bd09e03093947da24c8c42c91e4e41af7dba5aaf43965a0ab41cd1f600a4576c7c3cc3441df7974b4e118705cc02e4c7103a9044b3546edb4aae55d7323271d248cb02f40e9d93661ed7c12fd21ced40f872550e2e0ab837498143c452ff7743cb80bc89f68dcda7d7ce83ae94c2ff02ea3f4fa37dd1e1c7c537109b53156e2e90288f853533b3fa451603c5e76255f5d457652171a499b23588937c7b6cba38c42f0f131ddf76469eb97464b5a8d4810331be5e0cee0af38b35916c8c56d734169e2a83356747a0fd003e20e3383f621a6c90f519f657a813ca8a7ea67aa8c93bce3d2312460e849d4bffb4cbf73d03abf12392c65b99770877150504ef031e49169d10300586f20b5cee9dfd0c57443b596c4b72d8c706c0bb4759937d46552160ef88aae56d918a72eb242512a55c8c128408e5c9002b6dacbbaa414c931481f26c6b7c8557da03827368ea588b31b478a34ef46295b52c1057e22dbf923893c42cb30da513d0c3899b5002c7c2633462f2302eed531ca5fe3eb30cd7db292e4743bcab737e635804a2b62352e8e0966d27c2ea5ac60e5664c469ae250d8fdf76f5a9ae4f036ba4ca0b83fa11d707b4a09b48c76180d4b7c014cecdc968eb8b6282580b7cb8c7e125a04210aeff36fb5c6df6497dd4b9c09af9d92601abda5194702d22bad7d7fd0b1841f6cb97969bbdd4a486b901305c864d97ed01701eea3ac52c046bbacb1fba65e5d27f58c272769e018679af03dcf155682db1f55ea77f39d389e2cd78fbfe2e6ec4bb8c832057b698c7bb86d5654224965287b52ef1cca7a7c430caea066d529f60dabd65fa8aa09dce0aaf1a9781f42e1b18e57fc617274197b7c32f047e8fe9106381de31567e9b20402a0b717870eeb00a96d3467e257cf77c81b075cd4d6d3f816014a2218d467aea7c36c7149c13194655a0a12629708e359611fb38a8004f64ff273e17c62091a0d681df57f8e3ca02b9ff66c2279b14c37f380fef952ac063496f76bfc9bc3eba0281f21255a220fde66027b9494982aa761f2ba4a3c7359a05cc0817833c5b135091820dafe8683c4a2f2163651ee92c669595eea680aa2ed1848bf8fab3625efc9b55c1aa34eb1fef7e80eec4f2dabb4cd0e79c9b10512a1d20d8ed4cd479a40ba2b37f972b11ba5ad60fb2c1f5bb591c805879f0b9c4d70c3c0293bb101db6722a7eb9f32bd2a28fd4d6a4e86b7938f92b0301433f5b23ee369a8258cbf31a14afac97bd623bad3e4d2dcd3a53444e603182470189bb45fe3a85146850d210c4edfc63dab915f1c8ac190d123c18ae37a90c94bc2f519cb86b494d3dcf6791631e39bff919a98e320eacf55d6b5144b5342687de8424c1d3d66c276257041053e52dc7d62e69efc483439f9205eb1b4c2d100c0cd3ca6269674ee20823671973e74e5b2df27312e8911192d85a407153a7e522e4d3231ea268b69c328134d3e9f9393242aa64f3c5cd9a48aa1884ef0619ef8d0241a10a255d861f6ea3428b602d0b8935735ac3c86e304b138603d55284c813d1b5affea96cde18002d6b769b7f9979a707ceb7647f267ba3f2a60af7e754b2458f37806b772c9a20a2d076a440b29e614915cde2417b166cfabf74854703f7f9b537de1f059d72881d65b95eb67b93812d4ca16a5e852051d173a9c3a053298807fe91d68e4fd1082f384a371cf88f0fdb92d4add7b6576e5afc08f5b901f5f502c70911a8f7fbda08dd25f9bfba344864f57a1f610870a62691979f93fb95e13986c42d61328a284db7ee8a21788a3146ae5b52f6db92036a1e1caeb6596ded6d18c253d6ad6a325d02e478f793892c8b42613a44f512b604d05c556e4fe4475594f51dad175df8cabccbd46375897a9b0116625da11464d4f5ef703870231d2af51f59da82aa912faebf6748589f9c0a43394921881f740143152dca48a60e2578ff52e4f837b63431d71ab2a49262e6fa27c7505dbfa7c34a04486628409eced5d53ba7c10d2b772e62b836e6632243a4d10e9261bc284d3ac35717275d3b157e44b84750e4bd46f795b3546299a057de27e986e366277b1efd0c9b2860286e51f35bfeb093ec2c10df4b5b2c6293399ddd5e8a8601759208909120204a927a41b7d18470189afc4ba6f05b3d853fb291dfc951006ca9915aee3c291a65dc3c2c35dcdde1f8efaac6b1a98dff36836a10f742d96cbb94f4f39831ea716705ee532da3eeacd38951bb6973ec4ec58995bea0c8e26ce7cac88cf76f1a963c755382b98247c28da256fe3e5fef239967dfb08d0a2b9b2bc74fdd28d84e5b0c41e103762d9a54ea49982d4b2cb9aaf4e4184b981b12955815bb187e6bac940b83107f5bfb26523c21cea6ad0c969016a43ad035b945d0fe7fa1aa30725f7b62dff5f2cc1d8de80b1320469f7a00aa6eaa3b5140167fdf2ac62c03b9afa31664666da29ad5583efce311fd1b14ab3ba9a128a14c4ef7e3d33dba057f8978acc0f035160bdad8ed466c4e91f4b3685cd107f2e2850c0d385d8baacd8eed4699ee7addd9a1d5a51c11a41b6dc9e9092870693dc68d721cab831558cf137753397520cd505c21056c47997b5646787b9e75f5b49a9d186f3334da036e8c52dff1091875d1f4455a8cdfd0683b89c71486ca7264b6c630610422052c567e561c76cfa27dea9cc4be22b0545c049db0e4cba2abf7740fca86cbcc890f09301e2c32546f0a88fb15f85ebf6119a8b3f549decebfa27aa383abbfcbe973be76933f811e88a6dbc21deeae74b33f063cd81dd4a883ff95e93650f78711eda6f21f267e93f62c1757a1094da6c23fd58015b5c9d89df44525529d78267ef4d483bbd8c79ae8eebf38b803f7084c1930bd51db901549aa4f79f102b098f34cd091180a9dbe5a669f8704b6ba687439f50b9d8ca92bdaa52581193379ce2f0033827f0db6d6d82385d2d65c7149c7c18d4ba3fe175676d767881ae38f07e7b4828dbbb55acae79fdb1ad12f79066ca7c5144d9f04e245379f927a3bc570b0a00120f0ddb9c7c54d4cc9612d2e6cf0fd2dbdf195449374516c28358c82599994478181ff9e97cf422324d982684effb3e0780b419e2d6a5739aaa407c52d2443bdf230840ae3114eee82a1f5ef4e454ecacb3e875563cc8ca2fb6bd4159411a39a374ba91aecc794a471a9d0cb6b0e13530a0cb4ac9980c8392f84155ccb951566c8765ef22ee72274a0575b07fff4ad09d20af814b9d47bc5cc73301e4bd59e665c8d1cea99004caadee44f5eb7174ae995d43b4297bcad2d9331d07c8e7b88a993f3b2b2b92f41676c4131ef0f75b8cc47bb015936348f10160e449d203c1651a019102593b24b1088831968547cce83fe4f304bfc8fa17816a522c3e0357631cdae3f2a04514ca12e1b0b78de1905f2a327cf1fad692919144c8d89bae4c8d76631777c9e0f298860ce9222ad1ae0fc6546bd5d15a6987e4246228d77aa3690fc44b222f68bc7cb1555ef36a98e677f6bcfd0fe3855fe1e913d0105426fe83671b6f36a14a6227d4c136625aacafe21984b1047664bd1935f524f81b07a16b5a46520bf35d81a2620049aea7da96573f7405e723d8ed8cc98bc3a83de8b0efe93f7716efd2a3288317645e954ef51a0b17883f6309884fbc097cebac3269cf6c6c2dd7b2b0a4e094d234edee73c132ab93a941fbc6807a45e367288298c53fbf310699abd4214bd9506c801eec7b4db4e677266ecd82f238b580543fc7f5434c38e26e47665a438e574e2ac650bb3bfdaa5dcb7d1ccb15652e96ffd0e7430b7be1a7a5de31e12c8f7d9f16e53e2fe7d3bb3fd210653badb406cae4eb4fd71f8a692732cd437cc78e652ff2e8e967f004b973c98f0378a1657a1a700d4a1026050071835615cf918155c36c226bb3800b05cb6437c25f9f050dcd117a97a5277c478000fd957462824b3c588ca8bd81ae2d613d493541154536145fcc6c24cdd4b2cf57659942bedc3edf2bb55a7bc05189d51d3969db3e74441247bcc91a347ebf6e026a2af327595bcebb52de57e39eb13d7f3040eac8845dab1d5fc4ac1e02fc0bc5f9371bc125ce3001792cc48b48742f9ee0ca9ba9110125a1d08cd8a6ca994f06378d518a4fec1702fa1a0cc4c446803deecfd3449a2f37cbf78636d068affbab74680c6c2e5c234f27078fc9b27cf7247cc005ec0b65e5b1dc99cf3e201e83e47d1ac83d88ac30d3a63937e67a09061d6959e8ccfa980343558e04f153d723400a3ed98c98a532dd856629785459cbc0d908494161a9c7dcf4640da30fbb661b700ce17a01a3870c6ebaac5d4fbeb744aa16337a6d1bf7a5610acf9db7cf2c1f4c3f39a78bde65d279c0bbb43c68baf06183b122ff2a8b7d39fb49bf0f1a7c732d667a19c6c7932f4b25dc3f5e936208213cf33da0e5d1a02a5ad012adc676e027c16e34078c8125f67e06bc8ef5a3b74876b96ef005001af68161ad7a54c7c1aa990089c75badcafcd36418959df56d702c596dc7acf6a424761f47dd3e092d7ce03767bfdbdbf7e13d25805a4b4c16aa7d7656884baca50fe89bc91dd6be24d27420269a178e8b11711223fab97a97add36c65f373697d105af069595a0d59190f30697afcb72bd33245f393f69b399ffc14f02324ce530db1b15310e664bd4b2dfdfc9c1be888181e761cf768a5a8bbfbcdf333d786f598cb5a2ed355fd34fe905a477b96d463967bc0cfa57cdcd4ecda1f8d60e6a3793b64ac78a649100ae4fa5c59d5d65f7fd6edd1dddedbe264998884934bafa8c6201ebfa81b514aafd454d3bbd54f98dbd120a2ce1d06a2a7f11f8db696297ef79332ac6618bb8b9cc73c6deae573e6d624946449ed15b2adfeafa8f1cbad3d1c350ced0a5a9098cf88ff2c0e5252bb1746c30a51ff854043f491790d6117954df748245559f710e6ab6097889892c9b507fdbf2e2b8478c81caa824484b98413de252d0cd19045dfda762ec3fd5cb1877b47ef106eec613954a528ab2a483eb0e303e8673aac870cb10b97492593ab3a172bb927825689877611d6be5d7737e391c2d308c2f02c8040c39257dd33446ec6154a622926c2618d5ffbd5dc0d2c8d2e46d2faf13b0d3c44f9c60a1558b219694b81e912031413bee4b2249316167c37dac11d5ecb7d38980e2c41700956ab1818eef73049e2429ca445419073e04424d4e30084f02344e0117a36f8342e171b14165ffbf2d243eb0dbbac574bf20002bafe45fd04281ab12b1da05d54f1da4068a2ecc10eacdaa46af559fcfe5575ae5d7d0a67eacb3b101b0f6f7fe9ba8222d7cb785c68f68a9aa897a8c49ba616f4bc8102970918038159b662747c679d440ea4dc368354a32b0b7e8f372f682647a934ce44a20392c94ee2aea6f3c90e072045a7b1aae325b96a23055a76c5b64563e346acb5a9ccd5d108d024182de5d1f1d4db062051c01c22796974f34cc1d89084b5cbe3e1cbfb848171b839a7a1cf46b493e272c91a9c32a4ff90e9eb8f3b2a811757edaa730a7d6e6aff16d0eb431ba16ccd07fd641c87b5074d83a827788fdde2ad70562488ce169ca2a22dd86cba6bd19c59e5898b124f958aa573dd5ffb357996b39e47bd8df4541f827a07848fbe077b16bac6367f88cb64ed7056f2997deac4c1eedb0b8ba079ad624157c8d8e458c89af623937df719e883330b130047adefbd0fd51dafbaa98f8e8972ad6fbeed6eef586b7fcd2d498418e081514feba7e247fbfcc47bb39836c736fcdeff5613d84a8b5fdab2b1ba72f9290c91253a79dac2615550cc7e91bab2c4af2738e35c45389376783bf545f4781e0bdf64f125de17ebc599e61442dc0ca0dcd3a7520889cac3cd650d85538dd6a37be9c4d37ba5c28cdfceb822f574dec213ffe73d511f6489f753a1f202d97636da4fc55c70735f25488dc556264606a12212799c8edbab15acea43c8269febf31edb1383389e5eff55d4d2c14cf3fe8b1811b46f339d9311dabe3acec6f96f9041f154879b2360ff37892aa382f127b3a8772da777fd20835c242ffca9b6be846cf2723545aaa3723fb15abc286451388938dd1e7d0364a61b8fb54b2ecc7fc80693dae8ab781bcd5b0a4b60f12515b43d86005b0294421af5d9c8725628ae2b2326d91cbfbc5fa5521c4e14bdda42b41eea3b5edcec1b1e6ec494b00aca8653b43129dd89c8cdedd26ca7cb70668ee0768cd4bdd5dc1126aac56a731695fc4812bcd63bddbc23ddb222d9e09b3f6a64d0ebfcea56d289d52e57fde3527954327edf027e6a32382a8162898d5f0c5d1bdf726278f9fefe65e9de1f59f902cb8301398832aecf2c84acb2f8acb3c26ea0f2f74c5f1a400650ff66551f397fb515575f45330ad66cf87e7ec860975b9ac22c94b2102877f72c25a30e9c682fa6b88564028dc901e2c3f8379420ee6767b7f21624e266c8012a4dc1d289799aad5ce8fc9892eefb87c68a6acae6fc780c9ff1b57b18b43ff813553cdf05139671d995e336e73b63d0344eb8173edda96f9c45e8b0ee7348a49c281be46939434a1fdff85f371705fa1b00d8546384e062bdd508db4cef6011810b0ec08e12f06dade839e78d05eba2f959ab8429c55343d7a52c11de698f8d2f1669c09847ae762947f61b982079c3eaa709073ac3eb8e8c5607b5912bbb14fc8ce956bdede8a75bd60edc8cff5528f573c060925c81018ae226544bd89c87cd7c3b0bb86e9ef4a905629db44debaad176c71307ea4e4518e431d0410f4f45a3a44e36688977cce1369908d6782933f87422ec55cf8df9abeea28410373cf1c5bff351171fac5f2f88d780660f092ab8a3eefcd59dec906d7e27005c53d6aaae0971040c993c1db246de1ca848dc55626d70ee63718908ffa34ec4114b46b9a9d09558eb143ccf7da8f25b894d003ed07fb6dd7008c9177be855ccd4e34f76a5bf2104b079aea77de73bfe94091b906c0816db71ed93279ca10c4f9e2f6b4e70aa9035f232f013ef18f4c03442b1bc014dc5183db9181c8e69e759dd82e0d26355de3b6934965aed7da60fe85f6461f5fe1031acb3f0eb11964712fa6e99c9819b4aecdd7ae08299c09e379b3405d1551595020466f1ea11af3638ded4ea57abab53738df6fb3b8153955567aaa15c73731c4a30f370d4e18895e0420f3b646659bc8b46fd89b1af4f26a37964182e49c67e514e7fe0e79c50e47bbc09e1aa4c471bbf99d7adeffc3271c8f4bf1b413ec712c8868f14c8508823d1a0d483ea1379e7b9c3b1a263fb45020ce707c635ab6322e9a475b18cfa344d0bb8741e62a972a4fb33a9a1c77e442d758d17796e083fdc51bc45c5d30b31733003459c27317162fcd9d8c8dd5dcc741f7e0dd1186799869eda2395f0a49815671213206bfeb2bc749717384330aeadd732495003a15c6d0147028c8070595ec2ca283c83697755df43d30bfc91dbeaf3425af3f7033f1dfa938e5c6894725fd711fb679c5c108e48b8ff6eefe2c343df74ad735b3513953c4b194baf889a8f94356bcea29175b12f81286f6c39539584ee860586e98165dc09cb646bd5c2a0d7365ebb912e92aef6123855fd0ae94cac1a00ffff0fe30c47eea859740c4caa0728ab4722bfca2e322841f57741a220e921198a8499e055e4221c830663809abd97dba5557718ea777fa9350258964908c72541778e1c5aaf383266c2bd8d748a8586ba6ab85aaffccbe3e8c74a1ed771a511f6f1aacce2a88a688acd143b2f881e851085c3e1a4cdf4911d1998e5a0c1f5177f4ef84a4562f815660b99f19a449726984d04205e2c2110356ead70a42d8fed9a0a83ea2ee58a7635f381c934ea5bfbeb65d0a4ac19260511d95bf66101819f1cf448f5c027d978df76c264112176feed380e59e31c7bb6e19203eeb927c182d2cee170162fb04b725a1bd0d1219146b724bcfa1f3d82ff32822c50eb2e39b1d3ba6701c6170372fe26ad69ed2cea690af4978ee54e00c6376433b2ae1ef49bb76ffde64375c1a6224c201b1f7290985e808ced67c7fcba317dd8c917cf18c562cc63ca17e52bd5aef0c046eccd238ca81c887e09a290c0f4a4059460f23710db3623d55566ba16d8276a0afd7a0e5e3c7c770ba2ec3f7db9e92b43cd233480cc66571dd0da3ddb1c6c14af00cd106e4643d823d8342912290a465895d968db7e9675ced5b08bbd7c87901f695337fadce651aba9c2e8f5a18cc8c801ad06500ea5358a956525eea8491542826b1f118aa1422c574746efeba8bf8713d76722a49a07c7b6c1346a5070e96b7639cefccc13ef4e4267292f5a08673fa4b437c86cf1ec2ffcdf2a0e0c6ea516e3e1c6dcb69590cf930fe1b5aea3646589d744d2f079ef8e2cceb89dd8d71516fa6bd4c2c2fca6cc056185063993932b70db9c1ba3a69742a9e6c4c5c4d4505592e02209ca25ed8dc8f3cdfe56a99e494cef4b697adaef77768a410126670b0ac10705855783c958e3ffe2ab2f8a2135be433f06b84f993ca1236a78d99f1196c42b3ec8d1e78685a9cfb995045511cd780a2f53506967a163891a2587ad9eb0ab7197b31e9a49f1386c7554f4511f859a3a80d10c1a24b9c7729dec63d329d61d17c624c05638d2e42580dfda15ed3bc54ebd51989017f018ec51ffcabaf7622faa23cd174ab16a747e0138abb1241722f9b26269df32e12cd41516957465a7daea22227330028ffb1c0709da31915bcdf15f1a0daf4e0027453d55b54b2c63d5d0ec46db5ae2babc6d1b9ac25e0806959876accfdefe876c22dc0f43f5e5c998efefb0eac15cc36cdabfe4391612033347abeea7507a5c135c6f59cbf92d7ef29258e0ccbae0a64343addb367de212917aade5fb0497f93ae4500090b9fa5910578e374681a24d65263aa5a5e9bab044d1a72f239bab3c8414afb2f3c55ea695ce5f4afcd27c9b5c2e46a8469695154fb3c84e87af3d68df5d93c8b6d66244b43724cdcefd2ab321671eacc7f828470a7a7e41554a0f20f241c12f8f8f7c8c94d2990a3cd880f24eca65d13edfb8166563138729052b4eeb45decd862133ecc6c4e4c8b8235c41df4790fd6e676819ddcef0c44ec70e1acc35579d5c495644bd08e09e357dc55b7c9ea1ee528e56ddfe9c63b2c35b2cd572112fa4fe9abf4e0e7d6e11e9f016dda391b03ddc265aa9fad9127db1ba4eb5427006881d390f683fddbe4d59889f0f0ca314735b80e4eaa3e6908768c6109fa9e7f5f006c6b1a3e811c1ab82f411535a124a189c36f2a88472db1282c955b1b49dad90d45fe22332f63532a875c347b3c54d1ad9aa906b36347359d31f56abb11e24749fb97d288f3fca15f2e6ae74a8a66ee5f3ee2dbfeb4dfb0e7a6c9a32068b653e02ec7d36bf42964f273574a07149ba1492c33331b3c33bc1eebdceff580d303eea4a586cc7ac6bd5057262a44b1ccd3b741b22a1f019c50c0d8419e1acec295456f45a2342d99294e392683caf4a39c9a6f2b4812e12a3da6e47fc89b213a1e81cc8996e45a428977c9666d1e1c0695c12718ac6fb3860d631a540108f26016931aa80d0827d4f37fc4a4816844ee495ac3ea7260145e6527c3f435e5cc858a26128453553ee13d9f2274a624f68b63b03641d777c184847c2cefb4e6a975792a9900625fbf35b4bcc821ca886ff3d5d2702c65f3936f95c953bc4f523a280f4a024da13db37aa871552854dc5924dcf0902aea801a366e84b4793014622279a7f46666eee1f2735f1774d9b5144b15647c520169c1799e19a0bd735ecbdeb10c0ca5cdb1daf266ff597ed609b3fab84be97925c76d36b3aaa8135c2ad25e2eef1d413cec3aa2175922d7251e549e2dcf3b051e6debdedd4d7b2abd2f7a75f388ce1dd0f64c874bdc473bdccd05a1196a7b643fe4a2aa3abd0780704099e76121d75691414f8e4e70f5d03dfa45ad2f1bc386a04ec26213a6079b2d7833b2c3f96e6b04d2fd6811a4b3b8e738336aac361b631ed5ad057238e288364ff1586f33cfd264d98187414c281f7a15a5937f248ae5dec655b07889cf69d35f923fa2f37db282e183805b3e029ca0df96686ba986410dd703279c1ad8440c0493b6e199d91375305d6ec18bc51437adf1b7d813aad9a8bda2544d8e2b07fd193f86e56f35cada2f2df9705534c9f40f6d242c2dbd9682dee8a823c6ebd7745d3fb845a11ba82d9fd199a7e8b152e2c52184398bb43eb792a001019d5b1e40d6c4ccf035391704224b77eeb97edf734c9f603be766bdebd8adeb2b9511e189f99223a2e6bbbecf5f447a7a8cd038c071cb3ab381d4ec0718bdeecbb4b039ab739495078110b9be9311197f46881b446cf96a65b30ce0f1671e7407d06757068f4d80b0400923f34646d8d0014ffd745f5021a026cbd3040b77ff7008575162b939a90107efa4952deb68bbe9ff7df937d3c91ac9b33cfd3f852a5ba9a8cb1bbb10144e1aae3e15140cae1d27e4763f3099de22a7dab3665adfaa74cb046f3cb8e68ff39580f1b708ff7ef070ef5d01ba0a4f507743ed5b303454a22e96efba790c5ffca4e86edf5fac9115ecbec4122f28c3cb108b06fd1acacb2b38e9b4edce94b89f460cad1ae3fafd31b295cb8e8086b846976c85f34d6734e236efd46d3aa8a5463c301f9ab73485c1e4716949ea9f6cc887df56cc2879cbfaa74629bb7a7f7e219f36a2890341d495a4ec369bf928adeb38efcbe1232b73c8e61f38dd136da8a7582e49607ed16a37067fe49df8ecc9dc1f555a9ff76b3de02c029545167e69925085ff6baba0db608be21aac8e58966d8ace9914346ca6ce62294c2eac22902e6574f77d9ff1450b313a7b538ccd87ae3736bcb7b69cd7715a23e90536f4787428d61f40bd3db8349b62631cf1c3e01f0ddd8407200ee005e39dac76c8081e32414757025dae5d8e53649095148edf0f065a7f7d5c88c9d5ca07a0a9b147aafb1a05c617018e3ec8ab450393293821aa88830dd66533fd69d9237fb385c841c4e4f371935312043634cff1aed24493cd39d83ffc8c9aadd627231c95ca11aceb006b836444e658d18ee657864b45f9bfd1cfd773ed0e86f14566e43551a7ac0b96f900a248d450d2d1258589ed9b17e878f9f292f450abb4deeb165459ef64331fa978929ed6f5c0b8d766d6e76332176fb5c2f4ae4c97e1cab9d6d87c17496855a4c71c7f1dc3d2520a6ee79eb39908c6ff35c6dc7683d70405939ec2fe5041b1d107d7556136320946c9e5447751cdbf86ed398090896a1f72ae12b60aa309188765883aa332341d70c133b8650b2e72d835f99dacac5019c4a7b727e9d9046ec49a6311206b2589a822cc008c033d8a20760b7e55f67da1ededf2c216afe2eccb2bec2c3d2f50b78bc82b7c89565816a41e60a9b41e47f2bf416f3f27b61d95757e2e2a457486dc70f13c60db01c60990ec1f5cb28c58d63219cf6e5ad3b8949b0b0acb9d632212ed9a2b065ed47aea344a3158d5a98e4e2556d3000ad689d1d186fda733609ed3b24bf2d9bb8999b0722bb30266e7ced07b021f62c58393245ea78709919faa237ae64d1820445ea27843774b6f7c83316696ce386f2dc24de050f44b4c7a843fd2e2c3121386db62fffeebc3a32ced9d6a70017caf4432d6079626248e69033a9bd6d21e50f5c5c476277957560dc88ed37043a271bc2fbdc7cdce4a71f3439cb8e39e36d44459e8148dc016c9595a5af6fdb911dbd0c04b7953303468c5e3852cc875e6c5f54b8990c64aba894159b850cd9e49966a3e42f778831967c9719ca3c7ce0be2563a83fc9de4370108803f6df76922dacbe2fe0c1482028bd04fb407d202c744adcf4daf2ca66818f399ef146839432316b224ac390acf84a5c9eff8aa8b5becbc8c2d05cc49c668d189575b8cc90530b44a832786221d0d341db412d7b0739cb64785debdfd38bbeb3297dd247699811b71077085370b70b3037f9a484f40af27a5bfe2b4a29f2de008694b61141da2bdf3f46f1c0118593f4fd9e2ccb0fd8fcfa806860a0f20d757004cd512a2915e6ff2072fb20eccd48ce2dea2f5f3e7d49f7d0eb661808ddfae8ad1973cbb901ebc1fafc971a30866dea64609ba5f9e535b23739dadea9ef846443aa75fdfa534ff143ab375ae5156787bfbc548ee21a1f39c0da72b6777b2ba12b5d3409f3b0329c50366d493003ed76382dbcccbc1aa3b48478556e729b360aee669bf2671a2d1a9b824de29cf09ce77e0c65d098dc51e55f480c85eff150688583fd435ef44da0060b2f3bf336a199c1ffe3081c98641b74495132b432fa20b2bbc677630c915a859eb7feaf57da245419f14c035dc3ab9c0e511e23487bffc25e673179245531f6748c2f3e8ae6acd53791fa221b0c2c251e38faffc3d8fe08094f419313e6ff9bdf42d497e003b40f9f12e3910dab3fc81a708f85fe0f78cb675f2eb7d2e6171b92e10e9cc43eb0a82c8c55952d8718a3ceff9447f39b9bd1854a6720bf5e561afd633f9f6a49e0689c3951b60640133a23f1b4628fff1fd791e2c0c25b7ef57dc77d5307400b841f7a5f6a561d206fc874db1bf18c7f845462f3240aa80827eefea8e43938f243d726d1b7c33443ec58d8913010121be7310808ec0382ab8614073b0db36ee1adc6eb757c9cafe760bc2203a3788d2901d757f3d93ab463cd78e6104769d02de0cfb8104e93e6df61b57f2f20b98bb556dda7ba3e5807e948d5689996717888fb1dd909a11ad1f5297d04d31559dc574fdfbae027818b302f7c55f8b69042057506718e32db8308ede28e228cc15bc6e503527017555ea1049c424d0cbf9fe2986856e89add0eebc54ec5914d0a9f7b43ed37ffb23cf930ac40bb5063d824944512306152ea3e5ba800db53076dfaf19309414c5e69fff2e337f1b3b3d625cfbce45939849c42fa1e9922e55852835b157452f5bb651cd43e7550dd2c80cdf4064531bfe564f0eb0258dd86cbe32b63aa94492b8fbe176e51c9ae45574ac41b96b373fb3a5cf6ef3a17c40a09ee8de23366f074d4e9008fed432b65304950e7fc015663535a42b6ac2d362212ffe84ad0b8e5bf3cd1b15d86edfbc16dbe5a80dad6565e17fe987ad1963e7f453a8c9e8d62258447ea4841a9801c2ede816332f11db62208f495247b54a4e1c1071da23f3e17eb53eb1852ca8729ca75bf1902946a6769781d58f9497646b54e27a2b34aaf711b1049c6ae25dafd520870064711cf9a0a500487f429f05bb6dae9edc9cc4423649f12f7758c4326b7f81f3e586d7ee81200cc459189e312dd507de9f42dcb5d30e68a0afca17991b31080e6c3d2a20fdad46790ad027ed3f95a59c39c49690d974f56bf71fa2e25a2ff418a182eff047a2f439227fe47806fba2d4e0e979bba2ac932218bf42423193df2caa3d7cb6fbc78e2cf22b22daf1d719839f113c822920c7706917ed21ede42f429b2396504b78f4f232ac165afe1721fe996b7da09e6a28ab22ea8bdd957b415f17843c0f6be596a836b41d7316ea396f74b9cab6958fefd070ba210dc73e6d5db88f3b72c2be14bc349f7765486b00f21c684ce6e7abdc218bf296a2bd4ce34cfe35bea9c345369fda5233a9f7971852c2c27a79678e4ca30ae509b26c67a9c72abaf875daf53a080c197ee3397467b2f1d5e18d2bbdf863fcdf8bc76aeefee24597121448c199870a5a124af6beba22ade2d37e9cf107c8a67511c2ed9a8c4aac4aacc78b5d952747129e453f9fc0534a7d0872b12725c23b1b64379bf2f8ecb51e1bac0725368e82a9a582be034bc694862a3a9f315d1bfef12679c88f3ec3dcdbc83622ebeb5a5ff12b71a3f953cdfab6eed625f9efa43ef4f8572a6068706c25948ef2f7a00f3cc596904147a6be55dc372fac3f429cc92f550f0bf6da3ea97646fb96fd785b1eef8a68a1d39be6177737daf3cefaad1474a1fdc3f7223e13764cbc65ec9296817c84a2caf0951f8a30e4702c84476f742e59aaeb19940f96104e5448b005998234917c8d3dbb5be6bdac662ba9c2748c9afa9f47dd225047eccc77dcf226250d25f3a514a723356dcce48a3fc276b6bc8895d13ebc3026dca404fc5e11270c0c568e6f9ff19d00eecfb1736b3a27184fb1ecf2ed7c3aa840d7cc707d3bb47cc3ee7d076c0b134738e100b4becfe4e45a70b60909262469b6af2d9134498bead546e268162cb412a9f27809c5feb43c4b21145d3e788888624f4e9e627fc98e346328f5d52f511d648de29d902663a950ec0b2f04c81b42b82652e6c3e6da2892ffaa9b0bf47d0bd70618a8d4125411f708cbebfa8337fd7a643cd6b47389f78ac29c45cc65f62f07c192f31ebddbebe8ce6965c174259ae09b35d447874502be96562f43d65fc5720130fa4b402e3294bc00611a65877e91f73f22a612b2fc04204fa16790d5014e781a4341f2f62dea1eb66286831f3cf33edd3a0e6e96a9d69c18832f2aa9602c191b16f9a70c992e98a731184d61a3d86dc81632af073cb7f870264eadf4e820bbe66b28cc950ac705a50c6918db5615135b58f5cb2260d1b09f12aa37e83a1ae3f8d54ad99b28dff","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
