<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b8a35ce85d83c0d71cf0fb6089a9ab2e56ac3c0eb0b37ad444d848241f34960692bbfdee5909d4fd633436cf04d7cb60008cbe3cb26c0d3f1e924304b73d55fb921355981c78d0c6a516742a77ed8a026278c71da29480ec94389f90f27837c9c96a78144e17765321b66827dd43f88398e25cf80546dab817ff1f2312680199b868fe315415f9a6280fb972ece14d6fa21723638db9edd208c27fa4838963c7338c82dadfab227d59e3df03eb9f40f42159fe200fdea4b7851212def89e3e861ea50c0dde48e17c6062aa171de1329d8bccc167c247f31feadae60ba66e128e193bc0190f9fb7810c301219910d469caeb642ac798ba030cb105c5093ebfa036b4ffd3c62512c577d916b59f35f997bfb13f1dff40afdba9f5d540fd5259a87c7661ceaa706e5344f7fb3eeba6277e8c02dffd82b759a3125c274030a0a2e5cb11dab1701413c6131da9568dd586a48abf9f5cd45ed1e5108f37aeba63a86cb1f61b6e6aa1aa8d6084da99ecc2e277ddd8b8803685bc22a648cd9c98d0a61179f599e2f2d4e85e932880dca63628e1dd3d4f53e59f0560f8c37720aa3c91f4af3a950823009a44af4c3c3791e035f86dde8f8afd0b9468d77fe7b7fdadd78c1465f5ba18707f970e8b6ebdf4d7492fce6332d7daa895d7f661144fc1e5ea4a1b3296e048f5d996a700976153a057f75f71c2557836058a22f2f98b8cced73a403d9226608afca3cfe0e4162932b849131440531425bbb9077fbc2d0b3f9c922fadfeb532d909b3a8521c6dc2253df805fbab847a16858a3731e7055100834f3342c0e6673e256e0909eb446633678923b8d6a57b8588eb396ceb050df4243dc3f2075116fc5b676a549c5fb0f2ddb7efb3cab7f4a36aeb1b050292e883bc480fa80d0d1b7caef7f46c8136db5307b2f0976ed9e63f46234ba351d010af22112060289cd3d84279f025c5c24de98bf40cd34beef8400fb5b4948e4e495a458bfc1028c021265ea8cb16f771f07ecf07d69a8f14fc0b03b699584013b20999602da143994ea1d50d6e613480aa2ed17274f82e39c2d180b6d50b403416ba70a83a5185a0f86f9b073451f4fb61d624fdf0898970210aca3168d46a849e1fbb1e9e8da5f2807c722a0b810c90c39c91784f2f059532321ba1aaf504b2b97d5645bec6a27b50241309a8a5d7277f8ca4d044bf283316ec86b37aff3cbdca0582d0fe58cb8c6996d57577a49668814f798ca891382fdf76230e129198fca3f4b764ead65920391d54820c23bae188a981c80d813f10732f904239de6326d46247208e34a88b84a2af3957871ae412b08bb726632ab81e4689f6709ceb7d851b92c1843e483a908a3088b6e8387d72c65405df676180b20e3f2f17d1a3b9a712431d6070bbdcc040b1a4dee68c00dcddd464ff32e337dc3ab73089390f56ff885f7eacea076d4ce690f105519588f7036690d1b7878f3793ac84bdf6c5d6cc68c700d07f7a951b7a833a56d4ec5c78cfb92850739173213a3834d2b62656c33ac6c896451bacf3f71c0ae43ac860b9af073f301c51872f95e1a85d0179f0c527b264a1a1a5f921716b9952824759fef5ed9948dd199ca5142d9843e678d2894713d2d3607887eda4ed8af56aaf2c0594e8628aebdf412b310896a3acadb1f27f0ceca0cfa915fc883bfcce41c60ec072e87524b3b94da581cb190c10baffe7541d15be4f19fa6854b2740e26bcfc166d70abdb20aca29bff0ad252dd55dd3f442a370b76f6dea8193649f7bbe4652b03a6699d4dea9051f10dec794bc31247312c1462e332992b82eeb6476eda14eac7b8e8228f6e2b73caba26520dad298efac76ca528a5fe1ca9232fba40ffdc36b0af728574624639afc38abcdb08ba607a2e0e96926d34f055f6e4ca78fa64b133b837ea6cb0677661ed8ce8d9fc47bfdca6185ecb04218c128c7b49231abc4c85ae2b607690d634ca4ef88ad8e58e6cc8acb107c66d80fef760e405e4e216824f1de44580e49df9c37488fe36aa28f0eee43eeccd211750199ec69d4ae02b5d0e2e104d53eec0fbbfe000913c2d9647a754508c18e36bd8c05626bec4377c750f5c284fd3d24706bd0d5fe206e744744323e0680cb8f562469b286f700ef3b82a2b6937c3df3cd8e5fbb217c7f417d268f42b17e5650f304ecca0071f351dce0559882a68f9259a0720c3ddaefdfd0586f620131573f1cf6b436839642c374bf7abe9747ce5bb1a15b8182f7e18f9dea7ce49312df963848e6970430c7874321e3302dbd4317d5466ae66048be35269149aae148a59e5363fa1cc0467c8695259ead474929397499b35a1c2270b33b6a2ec7eda242014e5468a9d19f104214cb28d06bb50f4015dbd17749da1c5c48f446f09fbd727dcbd650cf06886472e83dd025a01f701c36a59685c0bbc890a09a0a1f7ced55e5e0257d644c8aaf5db7677d9eab03247608adb91e6dfb04fdf46cf412d337a96df137b0ae147c7acb92c54e7bc502fc3eedcdbeb530b3f60952f54b4659db43a4b87ae5ee200a256263e21cea5dcbfe690049b7f768ab1d4df040943d7f92a6175e64fc48534edbe6a99ff8bb117254a6ccf688c37297283da16930f9ae39f73a04d04b99c05640af5a5ec3b0429eeb3af33230ad2833f594b7a234b8e5dc5e9d54d9bc60990e548e4108c5d6509ab65304f5910affba0ca58569e31deaf2097d3a0ab713480a57413a1e2c64af7f6076f5b4f55e181db11b70b43853abbeef31328924d96c254c79df135d94e6a940e801b7d70e65912a4a4b870eca86b373e45f7ce98def8897ad7f66f992001ff8f68aeae56a07e1190d8020723a144f745c389cecd35a11c6dc187882fbbdfbf74f6d2b6678449926888e8235bffb9cdba608ab56f7406305725bfc7751f5a782496c083cbba54e82949d14a128cd2298766174f41c37e39583a4c16d7259f18ad981e9022864a816ad3d1385b609d8690048f4eb5106a64472102d42e6f1027502544b1d76757b40414a0cae9ee7132beebd539834a8171210178bd5b7824f9fba67c757c7bf476fca9dc9885c0b251130900ace8e04e1bc72323bc02b3b09b4f218450c17f72dcbad5675903a04dc3b5732594209318c646550e373a33e07c6eb21b733ab9fc6ee04a334316bc39ef41cf8db94ad9953ebf28059de2561a7081ddb67dc56c4c964171dc9803805828b5d109e44e5b94831b33b5cb2b29da780a5c7d45e26b8758754e03eabe73ee1733f6d8d02b15f1ac746d75cda27ed9db637dac92df979af7cb8e57894d2939ed73583d700099c2d89ca498edc7f0970708740ca4dadcf626d352b8d3bfb49c3dc73c939d6e73097fbebfa1b7452b1b07a9c88a7d4a94b5404a07ad8602d69d80500b8334724dfe16991e82a53fad96009a1ac7931967c715adfdb23915aa18891b3888619060fa1257c69ea50e5dfa450892cef26553f5d39b18ef97f87fa40741e443bd14705dd8aab70c02ddee2b67e46aaac8125c450dd581e3e6138566e106d17770fef7292711b6abd76eafd953a92319cd4875eb750d425c129116eea4a9328d1d1b419b8e0bf686cbcf5ff9925a21b02d23951d3b6d8be69b5c19401c395751840658da6af2ec6017e557c637dc8ad1c0e32163214255683ab01ddaa0053089ee9a96d40e8ef1bf4daf49c144e9e3e24f16864c70a97f56edac68454bcde27d8dc508e607116c409e79973bbf8f3dde2706d65e551cc604954b548886fdfc788f1e52d23443d74ad68105af80700e327673c88408488417ebb8fc5f00e4ec3b60550f620d888602d98bee44a319cbfec9031ab478d239b6cbe4cc969c2d6aeed3dfb9e432a68ea685284f6fe16cd1537bef32c2def55fb2f0c1b8a4124691a735b495b2012c4452c0e2de521e60ccfc064fae8442880e49de7939d54846e6bf9ccf5bed2152385eafad865c2cf79eecddf88d866f5563981bb96e852c9fdaedcf0e63e2f9049be67728ae03971ea9fcc83b7accd1480031ea90206a06bd9cc16cee190b544f79c707304079c91d78b881559400a597bbf74c4fe705d9f3d26fa15ff31048bde3d4b9112da56fad489a3717d50688d8dc037067415d1aab29056593999921b3d2c32c3c7a247cd5891808b5a3a739d7ff60a935fc376136dd090ecae2b09a72059d04409030eb5502f79c0ed53b153dbc29e6a38fd3dc0267878d404b97c90dcac6515487070376bcf4ec1eba98b02736f9cf15d9ad1e8ab0e5931125c2d41ca98fde6b5cea3769842e22b51f845bde88d44cd9be9ca9f119045ad32d6d0643d6b0b9996b2b42f55ac14bbba9086a12415aab6e00dbb32e03eca9517b54505cb2af6101d5027ae2a9434d5887a634c744c011487dc6026a3bbe8b1d6f79605236d3500be818ee23b4a16e3c8de74987f8ae80fa8f0db976917721ad7a57fa6ec829c9b4fe245e417f2bae352d8f14eb944a4cc4072c6e75d8aa071627db8f88a0efea1592de450e3f3853332206032d01b0f55943df03184b04c7b33464ac453eb461b0e981c590eca0a32ad0d54e2435c639e30e1239243c05df385b56f1dd177c7a6df7d231dd8e988e0c9786071811afa94cbb971d680bc56ae9f616625a354c7a4ed0c7bfa624994e3a3e6fd1ed9ce07c19b26867a6501fbc4e5f2b6237dccfc36eea00e77242d69cf4609384671737a3aa8ed74219c70f47932be003f79d1033da123086e8c5e995ebfed2964be1134bcafe305735a14c219cc994ac6923a463b322bd0b4adb67684c2bd2e8f81549c7083b250e9abde95ab79c74ed83062854546d7293dadf01a343819813abb18ccbe554bf8cdb9dd78db67107aa8561201ae1ef9a89bcaa527891a38b83887daba65420c96772ea008b93027868f941ea699c6a4648b5a4f7be9a099be3612596e84de9334537148e12a75e1848bcba22dcc0a24a3e58a53ee29598ee67763bb9449eb679dee3782b3ebb6aa0ef55df5b9f88c18d8faf17ac752cda7fb40f983532e0d4acdaaaaa7bd392fe8f9c8635758d16e1b3bfdd77d87f54af635552af1e2fbf1f49291e3fae2d2ed06855d7fe49d8b071065cac51b7f60198155ce5ae245c4570ccb718fff5021f1108a7ff0c49e7d88f4bafa4c0f0f1fa490184cd99c632b58f39deff93df4fb818d7256e2f87fe6767d0cace65a6fe930187a677f40ea841a676a5ca2d57c441bcf8601c76534293d9d3d6a968a05bbba7e5a68e796ec935bd3ff5955c6416d7c6f2b9ed5ed9eaf738fdb5276315ae10dfacdff7d2de95cb87efc52708dde9b07cbb1ccb7cc91308029a15a4ae13b5f5f6368d2033f9d2c07fdaa991346d6035d02c9e9b1a15e762041124c5deec722e8d1604c86468d6da6f509a77da1c11b3e2f2421464fb500a48693b4a7f37502ce44c41101736bd4b51cd1fa84cca241082a5ce7141daf0235b21bbf3002998596e7fc86e5f5485ddce59e925797ff909fa781fef4651be3eb2920f48459b8f21b1d3a46580bb75079ed1f204bd72da1e848023a6567e71f11dbfafe60242c635761b099ec2ebf0d0b52a9d98ad7259b4949a13f2b6cfa11beb29a27ba9d1c6fe9cde1682154177cb4a14d36f070ad0e3c0494352eeb2d3666e32a09d1e136298c2ea346401aeda965c823868169813a09a15f37eff63db5a34a9896b26c8f4f6e7517d00ce97d7368450f7cd3bd6a5ce2bb85b598bd8908c0f9988b490468474747f93fc3697e8b86f054c0727e7b9e016e0bcf9a0fcdc1eb5a482c913fa81b62cd70153ca8f8ea6fe90bae219c1067da66f05b6196cefe9d0571c36d05482e8b7deb46727b837d548532ab6e02f71fc17a7934dad6e637434e6e5e672a75a0ba3cd51381f6f24428faaef8766738a06dbc9e7aa7a38b19eab26759342ecc4932689c4ae49305ba257179fdc9cbcc76a840407f13cefd7bd2d7d34e786d208a1bfcda6036805a4561470bde282b49f0298f09b09a970419c6d98d35519e3658cca77e0eb00560844ccd79b5a4d46c28cb99da0b633ca43b23b0c44a7b9f026998a2f756c87c9f02cd07552a3f21b4c2c952e86259fdd5f94cfa7db92146029d0b08322ae3ab320eb46b52aa4488edf98a4a650a8dc2976f72f758323fad5b99af556001d4d1440159095d2ebeafaa4186941c2e8ffca183f0669adb36486dbb9c91a8ae00507196804cd2936635bea9ad8b732bc8bf53fbfd9697b4ea086b043bd9647d9108cb7e07ddaa6f32f1182d5dec005e5ed22d87fe96e9f1b769fbdcb566379f15481dde8aaeb50260be480b3581168550937b2efcd6811ee0a4eb3d2b3263576a8e2397b8c0a72a7c895f0785261cf8dc5f841b44b71139521865c4505f36257e314a24bfbd137ba4472b1255b5c04f26ce0e52669fc48b8655f097eac5c4096faab1165388b90bc60b153a952f1b0d4143ab0c27fa0b3a83c93a3eca6decd0d283886f01e351eff67b0913e6763ef0ae586defd3d76689faa5d4c6a53b816f4296146e4ed5bde64b2f30914437f8c3cb3e1d9eff263908231e9fbaa52d617f3d83d3391dafa5a2f305fa2aa2fbf9d1eff7edefaba7255ebb76fd328d7a330b2dacaad3525ba8d2181de22e15a6ca61489481d57744e5858a835d17becea88150ce70d4905f789f543bfa8a0aee1cf808a3044859d9f2ef69f58efa6b4b49322f4c0b06a91482f609e6f82aa8a75ecbd4f4aa00ac67700accd34aa43da970f5c7cee52deb833562bdca53464a279bbfb905840aafa64cdf07d6d0f78285c0c4b7a9001382ee7093d91e3524eccff5064dc4138e0f8b75d1f62b1e2fc3090e0dd3ae2037ae512f88b33573c8b8564c85e08507af3c84aa32a0dcdd519ed4f5c667d35dcd76532f4c1ef3ac411cce2ac065bcf738b1288ef4e99dda5fa2af357ecca15d3c3762eecd023a4463bc43443bc423a3dbb49c9eea1448f532c218d54c98dcf714f79c1d7b7fb3204ae08b2fe455443fa5c703b6cf886c68e94a185706aa03eca935c6a90293b2b73ca514a7e270940343798640e17468cbb123ad630eac0d2b47378b3f54b2568507df4be5e8c563b8306a1329de52b89161885d38929d4d773b2da434e3fac6ad176a5b7f61fa86278ad94b4659998b9a7690ce71f9aa6dd67026840fa56954e227b55594ce8c5a472406d9ec3b2864b11425dc144c92a0b138917b61e466c47138662faad13d7700128671d758abd44a4b0954ee99aed9efcaae820ab825d91a5b050414c6bedfbc958caceaf21d0a53ab7d7f9fa6b3634c643fada7fd0907d2f527d3b1db5f44acc52993543dbb82f6597dea7791b22542858a1ec1fabd9fc3850f651d3e2cc5d9643f6cba1933bc9485bce787efd4c75dfdb41e2f82f61650f460cea850ec7560c47399bee68701fc4a67b5b1f332ebf0b929f02583be852585cf25cf192183eb4482b5f1ac3c5331180e11952f4c9060863843728cffb97e0d48ee988f9a0319f7324de3dfcc404967ab3ff448c33417cbdbd3034ee4d26dcb7ce4ffce5a87946d3015521cff5320b47e201c0bb2768fa65480da2850d8b60566515c7202ff69475a0000acb6fdcafe751df2695664ca2dc1421df64d15c8e9654dd4992ebc25899a447e365b13505227be944908c7f09813395160144d69b0722f2f40b5add6de2b096aa24cf10df9f0070c25330eb71e8664ffdf546c5abcd7406ccaad2627c87d92552035ea11a70b8770a2b039bb099d31008826b281bc31cafab146daa8e0ad0036020fa56448d472a181ce927d0353f61a23cd8437816128b7547ca2b0a9700f8319927dadd593ffd0f056d091b6d0bea193cbc7fac29f15cc55726f3052fbe8eddfe76b2de98e12949698ae602f80b74ed9c00eb775a53ed100b3e6b77c8078d5f6cbbccd3108dd99002a57f1b36e7b6abd8607d309caf794eb5ddb7314a1b2f1b23a259ba4db70e018ecb6b8412f01bfb19ab599cee8660f85a847e60dea1f9d51fedf91f08e6718ef831d10a00f2aa726ba715cfc4fa98e8597a326312e09e421effd530dce92584cc24671ead8be689959dc5e83919bd9587379cb2a8c093f252c894c593e42251725a5a4194c99cdb58689da2126ddd1ed15e39f316bf144177c7e2645ec92f18c1309db109d39b095a2acad91b27e5957297efddb9fdbc17a62c7490e520b627c3eabaedea456ac0e553a44bdefd90659b072522f58a179f0d0ef3a2875b9f3e36d159c4a7939d2c6732983a9e7ec0d140ff1234cf6902195d4fbc6c445e21016dce7a893cc63709fd5e3d98b7b314178cfeb0a6c58268e663b3f12f60f244f161b920698aee9f2117eb0ac98aed849ca9ca302d32f083d7a60bc604a70935ce4f9ab878677d399c3a27293563e4b6e4c66d121a568dabcff404f1f4e7dd5eb59bf3ad04dc2d55c751e30d7183d137619437689a740273a14520628dd4cceed68f03c2866fb091ac155ae952f8ecf7a277fbe66fd2c9551b84ddf0b021a05568dbb9ec5cf0a071e8ed567dfa9c6bdda89f51a334ac438ad164cea358bb4fcd66c4378c2230c20bd36832d62543c085567d544283b716af2eb300820b614a260e70768413322b5242b353d63dbe638f79b5e01c2c5cbe32fefc966944f5a79301d35d0be9fecfc56e3ac7286f0c7c2a4c43cb760b7b7a60ce6b9fd8731b7e327abd4d4c19eb491efe18711ae1ad066d1900e29052fb18b6e8eea10079b1e7063dfc9ca841208329d7fce4f0e6dd83f3f1cd41597bde637052538240e919cfe6ff05bb792eef3742f20b44286a574ec42b02c1a27a17448a9686c59b6c1383ac70f338d11c139309f532092ec92aa66b1b6dc713d3074c69bd3a988dc2c5a3eeb298d94b3466833f1df4418a8810214fd65a7639b14ed5bbc0b23bf7c3f62edabe1e0fc680ac55161e609f01834b16a5bc36a26c4ed95486717d3b9d8ac21d53ff2af9c4d19e7edc4c11f15ee8fb1664b4e26f7a57c4b2c7bbbee5c5bd47d70706eaaca3e2fbd7c5df231292917fb4d81cd07c7e4c43fdb4abf7b5c0a1a182360bfb586859b992f82298e365d59e2fb23c0518d09d523923f6d80b4bf9ea923717683050152645bb91620e51113fcdc260da3fa4c868ef442081676737983cb1f34a401d1b8f499923b3c6a2d19dc263be5868d7cb34260e81b3b44c944ba334691bba8523856d84b63b4870c9a03cbd463bec05b18c858afd757887f64e99d20d81a07d25f4c014c1f42fbf20996789af88ef668763eca7388dee3ad3c09b62f2751b0ee4958010e889a0fd16275be5e8ef1c3120fd7569cc785d524cf75a469dd0c4e014167f65360a0a5b4fb5f3b8af3ef478e0961f940c4dead3d69eeb02114cc138a1787b4ec6b1fa658038b0c554289dc16f6b4952e2ed08fb4eeab32be74abd8a7bb920189f22e29f0fe22ec7a73578098f100f11cae8bc60f7345c3880efaa6fd8de403692905afecc008b7404e39ce028c755ddf549c5528c840d391c869bb783483e056b4b5d43c308513adb43284c99522bbb9a2e3ec5cfb98a5987c7a3ced4f93ba99a7a0343ae59740c80b025925cb72c616d9f864a92bea8dd7d405e4edd83dc3beff767a07cbe7ad3b8117153a87b175f7ac8a749630b2691bdcced68ca68668b17cb2337c13961ef27da4f66a2a6a9bf6409b43d2e77280710d285e366f81ed3fa5b83043fe77a371107e80582805b4f95c028424c24a1a2c1c8ecf34aa45cdf6e181494700a6d81ea021237a0daebc540e43dcc0fa7b069315c8d0efbe0083fe1dc224db355f1d32fe60993a32987abac30b6444d79ee3f574e1d7655e18bbddd58eac5d95e7b466857bff6ead0bb0938a1a5ff299619c8064c5f06c252facc10c910441a789ac756b56d3d8c48ee709d9d6e26f816668e2e94454e85a27c9bb925d053207c6b28248072d4eebdd42041bac1b70fb827a49300262b4e4f1115a7990f36fd7337d545db74e859c328744d85a1f8af3fba82cb8446624877c45dbe46b8ac37344902cbf14c0d72e29eab0b1c15f048441c90705e2cba1ea2cd2f53018e1d0f39504edc4cf0cafeae593e365943e4651145c75a5c3bbbfd55e8aaf85e540931282b3124b89901b529cc77d8e88f02ea57a04d704a9acf7c2f0791bfcbd657ee71af29c0b077e9649a81336ffda725d77916495da85207f2a9e61299da64b819491d6219be39ac929cf4d07daff41e2efef6c7cada58cc1d95de74b1fe91ed46cdc602240dfcae378fd338b698fe538f1225ca47ae2a8512bcba1ddf4ed518ac18dec7c733485ba217c8423396fbbb261b15a4583ba797cfcdd03ebbe16fb890ee757ef43ac7616a6f2e18fbfa3ac6a54171028b65bb6698a025a2f1ccce1458bf535ce9847770a3455f68e2bb6d7b5c22731bae2f3ed3fccde22787fbf13697ee7f7c7c6c186dd6160ecaf97ac5821b371881d3e48ce0fd2425f209b717e15a3720b86733e75de3c98044109ca9b433803913aa30e2a2d1015a030200637266de4527f946e5c0c9d05884f557d639cdfd6b6762139502093bd555da7386042be6c8d325c9e8dedc22f5561768303ff176a2d782359f2e31e4756b9109c8c68a99face026a2ea48a5f0d61f902ee00a55b84a003477de669583a0346e68ec319940b7c593f4d770c4393de4cf5efcc75b6dcf5af561578a93355f17c0a487dc9b6f11fccf8c42d6e8bd0adf88da90ceb5502e2b7611e0f1447a3050330238c909655ff8da20ac0eb8e15f7da23d5c6c12f2ae2e1265d2ca1a20846b5b1c23d76f72518e2f38dd33d990e55e8b42b4e07a830a7cf08cb0d4a2f0779861044c5cc3a191ba496c8a37c7c956a3fbb6100c28135eb9d0ee5db35a2b2abb071b1fd6fbcff45959a54ee92aae6f21f62030bc254484bd4e76493efda575ab42d8a1d18ec03db8d82e311d48683bdf1b02eb8bcbcbf4200df53d7c4a15b951d6856794649bfcc79d006d943c5e3b67beab6b3dd827d4fde217fd3ca23d0dc3ea66803a9ae70d2e946aef6c15b277acf2f8cfda748b00f5b3464a395d3e177fcae312e523255434d08603b68256be94def1ddad4d9ff58939e8eb73bdc9148ea11304b930b0538da74b012cfefd80288e84f9bfc2fe26e6f4b88b148e8d8c93eb4bea6b0c2576002b71933c8ca7d34a87650a3f9d2e4a79545e47daee98d2204ff4c77b9a3ceb7a395dcf4600a9f648ee3bed8ca3e003af9ccbae0866c3781f1e9410940971cc9a736df4c6bea64aa227b839f9a7f2009cf87c0b23913e09a7f70fd751a85d34cfd7ac90288b091cfece2fd5699802c04e84269e003b439426a6c3f639345807df945ae27232e746967cf86f0dfad366d420011a675fe546da20a30f857ee2fee3c2abad4fffdd2638f1793a48fa30f0cfd56f6016cecc433a11ded06a3d87f413ca5d4c59049130031a1dc244c0dd1582f21cb9924c176024f555184a72ca28e872b2c31b1a615f09ff01e0d3c6e924e42d9c2104043ba0c0a49ce7b0d92693329f49c1fbe6a13c68890e1d0e4f27e37162d9fa50a4a547c5a2d07ab84d4f4d72b3983ec4cd0d5edc5dce5df5bf1b3143a971c4a9380985cfb382ca69740177c15f99cfed011e1a0848b5ae21adf6ff30b6e2930fc78093323945d5b47bbf5c5bdb3999dfdf0b115db12f009363ad0dcfaab9b3ca0e07666036cda26cb5e4a582311d975a07cb2623b687ab2b0e646f543999712a67781a0214bfa5c5896c5594612f2ac899ac89318c1237889de049410c0f597bbda594146dd494e809bbf0fda5e087436854fe4223798b633917f239efb17d897b6a6d9156b2ae66a4507df1afb52e528245e65a51a7dd727e0a704c2f76a8de85ae2e187c4a5d4e07c97d5cf6b65cce9594923ffa492912735003247d362f2a0f76b9ab2b09fed0eb95c401f637a7e59cd014e97750a0f6eefd4ce11cc3e78c6585465414bd019cbc965f3b3918256e74600b897e1eb5caf74857fede73bda70911e7a816d5c32f36ceed09467aadbb7cdfb5872a11c57b93a185a15e8fa669181d51fa18bff386f8592f3ea92f6428b0f508f111ed47dfec4345bd08b0c76cd590b16e2a5db53c3745318e25833e1cdb647dafec02d947f6b9d1c36856293ad9d32e6cb3485021fc0a69ab26d2541bce11a28429ad74c2003ab99441a6572ba5c1b15670de960b4f0db1e2030b0f3c28a1fb1381004f01a711f57e81712d7eabc98d0d3889bde28ab4dbd27711d142d373df4daaf12b60b3d91ff4e7aa974f7cd7ab5f42910b652b1591d03999e6cfeb692cf1a0ac629aa19e3fff89ef6e67a042e3b8729ace90f53c75e398e0d49c5d239ca32281068c3f598d80baf9390dce64fd8f43528a28ae99357f4aef8c46042bb80b19646194ec1b0b645aa8c6b3adea0158e7b2ddfd59e2d262051465378483c52063e3446146a6013d7595db5b319600b00ab2b39316ab23ae382c7c9aaff63f3143215b42ab87150b07929667e6c01c666cb5353e164acfc1f03385e6a6a334eda69fd9c51e2c2d36f105b338891b3491f44488fd208404534882db4ce717a034dd59774559369d7ea5b53106257b52d64d9941fda0f967033a8a5293d151c1a93da097407f1e020307a388f5b0329c5b9173cba5f7ea9467989a68291c317a2df1b6dd788ba529e406ca988c686ed015dcb291fa9c81b774677666d8c51246c25ab2f0286099593df449b9fb88e96d54c88973c433de155e9144d1db63a73ae0fce904ec31f9bf99fcf8524968cd0abf41f0a2ba0dcb8c2daa0a1779c6c9ae3f4f2c49b176131d399e3e3623195ba5fe9c9c1edaa1e8b3e4d43a2d2b8c82f158c8fb70790d302ee51eac978ae1ceb4de6d41ddedcdb56836ad5c42c7bb3925e06db64f142870e16566fe91e8b10fcb7145feacb0246e4604bb3a8b1d7b663b209cde495d708afc13e2cf968159b9c5ed0007fff339bd4dc031e03fc48f82284e3b4d67120fe581fda4b6b1342c486273eb3e6e62c4d0b62514f51777192ba3a2f179711c8ebb180c545b0640f3f46716324007cbc23a22c2981ea33a2c1a6f6496446934cf7579abaca391c52ec0a6482a5e6063933c703173ceb732e24bac7037c7f1951557024239845185a48a63ba032c255e97c793f6a75fc7b339b53c2049005655c8e7215b94af741d0ba595d945fbb1206856942ab599eb8428c2feece354d1bfa9db4e16038ba9b97e90122906af586bb057f20a78e55dde96004430b4dbc157934ab74c5335d7ad0dc0a25945ddc18b8ef0f00828c8d2a1efda72d5cc9e89442bc6eda840628afc6753de83db240acfc22a5a35cc78ec256e168c5eefafce4e4618d605bb200118faecd95e04d217b317f3da878126f708d41b52481ac0b469f621c947e51e0116db2cd69f2cb867b1b028da662c2c2f011b91a3c4a5a92960b496d369660d2de11c91c2a41fac0c686b046fafbb614135edc9f02d56c2311985e70cf3b57a1176b8072b07fec887d713975abce6234ae1ebf6da23dd4e2ee1e2c85b5c76fefe10819a0451277a5fcddeac3ef983c2523e10c1df82d06fd40652d85cf84b6653d9263bfb2a0a7e9c4eafc4444c594cbf72bf401a0a06d4901b5209ed451c7272335a17bd95512b4be06f2c4365d086d411231f3c30986f3bcffd7a1fe0a20421833f5cd9141a6cfc0cbc4c0c175ae6dd7ceb77fc70b95903f081b35d65b90edcfb36759bea880aac060b31915688c338536382c5ded41feaa685f4943a4e96f5f8f5ddf2cba70747788a12a6669ce49c6cf0f755955de43ee061f5336364f528e17859f1dfc7d83e27ca45eb2d1efb2e3057a560f83978ffac499c11f39373105b7623a7a45924e2a4403fc778fd6544b4a56485772da443e34c159407bcd4d3f026ef87eba6be16e68626d11596bb0c8c4c0ba2d2a3e9ae2637e1d1df31123077aae34f975996e313839c831f7460ebf40d42ddbf33533be556ce363f5b8444f4a07bdb900d62147b624118265f96e7ac2ecf1fda240a64e4e638819e8bc105a1285c2ad3aa70f8792815ef6cc8022b10a8a16c2941e694dabe05cd6054f7e04ab8eec52384e4cd02e3d257f614724b2fe48a70c7ee5883c36af038d8b9fe09583f7c56abb463c21129f2f9e53b10955e0160af9cb2294dcfe210e1d3bb9ad896eb196b35c0b39f3dc5811a22b4073ddc1d772d8fcd8bda22f42eb0ec77106c5956b6cf6ed939553d24454895ce8d5e661095a4b3d151e033abb7fc169751c6de0b8703b8e41fcf9a07513ac8e7942b41d1626a6c92b31211dc57445be12f5dd6f75fa51a22dd155018ca9dc6a29b0de20540bc80b0ef263cecde17a71e1373986304d3b570069839a808ed4d5c75a3fe67feb55370bf619813b83ff22f10ebfa92bf9ee216d2e3a5ec3745d79e3613f70fd3d0a5546e64d0a6c51c445e2a31cfab5d95f08451f60c2fb8514e20099918af8c6ba1747e2724a208491cee5fd7683eb21581ff113f6a2339203a20522596074d84dfd2af965f0cb557b086ac55e02ce0f639c34050d5f89fd5608c8917fa672f1c0f7857c27cb1cf65ec8794ce96b4aea5222d120985212ce5fb538de01d63dc569e1a59a8cc77337ded8240cd67bbea1f57dafab26aa0e6fd1228210e5f53eb5e9a68663d5f0292450b22f982db851eeba12e53795cd76a95480555d0bcfe9974b0acb3c5e9a9e2557329d3701ea7940499dc49f265f406b039c6b2507320b52d1eeb87ab33987ca5b1570cc3aa661e761094d5c0e4ff03b9b03aff311a945161803be1ddd0e633a6a9e085c35d366b9be634ed3adfb0462849ebc7e83453bb83f15d1c034304d211840719f4ad0eb58e8e2e1265de63cf8aa981c49875e577cbb9dc1327bbfb17a4ffd41166163872f0d481f9d84f2059053bdf4ad9a79ab0d21c6f49975bf4529f32f409f5ed596aa439ec9a3c0f272ff649e1081b768a157de627757b879b521c09fb3bf3f53d30245536c083cf95d4105536ae5e1b8449b8c82a69b05cdf2fc861cc17dbc64948d181c053334d89f7e2c497f7ce4e5f2ea92ced1937467949c10fef914f0c35577ec5507f620f9815f84a37e7ccabced37f0aefc83874861369a54eea46e30a520d6ea680fa494f6bc2216f4616129674742246e9d920ba579388f16d8bd330acf9dbcfc4e209dfcb8ed50aa0aaf80091fccdd8719b45b964d37ff5b3c3459c72e9d146cef9f2117f0d4487db3072e3d1ea1441bbc5852af4e600bf491aa67f25b2d90cb59cd538993be68b25bbc630532f02219855e99435653ac3691f8998cd7740e720795c83cdc966182138571e80486bdbce961d6354c090e9efe4ab1c2de06c1f0429efc9e776bfabb1979e5a524afb827455ca3eeaa752ab442a89e619e4ef96223512fd61315cd44ca4fd0da163523b0886f4a094daadf054dbb05e7037b50dcebd55f362d167b7717d563f9f578e44cc4bd0a2cabbc1637992147d18f08ecc07b127309fdac2b930e115506e90575476d10917aeac93a2553818d72281186595d735f16d476d611cdda0279cce10cb1ece1d8520b7fe0d7c3f2215149cb7811016a17c2e06d1c673066b7a6769f263ffa82f63d0b344b4747426432319e2a4199566f5163dcf3c8a045abb65ff96998b159b83422c3ae4a60af96ce314465a7ac59a32aa1c110b1b3e1c0ebb971f924642953e1fffa4882a5410ff32cda4e7ea20e6270a0407f71bca14a4db7a386ee6281f52adcea25a2aa5dc3357b22b6e0f2f08666d964eb6972b67b141bfa034386bfdd4fcc4a51d728b2e7c50f507b7bc153b59b2fefc0d49b007f161d793716bd5112d02d4074150d17f3c9dc7abb59d31e1e3964636353d8e28e6f5c3e414719365553a2c716b2b902a558d1db9523982dbb2f5cbcf6fa70855b6f52144f0ba895ec292cdaec51dbd36d965725c28aacd9c7e0012dce0e64e65b87e2146311c32c060e48b2eee18f642ea0a0af9b2a939e3dd7d7ce0836e2dc4a6f95e7260ae7883e1ce4354712ffbe5a35ad75dfc1a2e76dc9e34fd9d5b414f3d4d121114cf3d5b3de4dc904988af3b3e4de3f62bd0d9bae5e00489a89b2c8d7c1edc1f0827b77e463c646aa88c7f782a12ff942145d6bf7d939c9e7adc26c7ca72b206dc35629c1dca1f732a78d228e240775bf36d48f2f858d4302cb19eb0c308d5c022c28ff949abda477b86b4624533de1e5b6a2ddbddbc625c9b5cf90766433079c4f9e20f6b65b1a333f0165429845bcb165c2d1410838055fabcc04f2f7fcc016d4fe107ee402370bc87d674af97d895dfc5e7f4d7eac5533b06cf4088c094d2d618abd034c45bf9b1b5683f7ce84db98e6c57a56d775b45d3081f431e65b0f810b0ad4854351adb9443e587acb17aabc69c2205c5f345bc4cb80375d3f88304b8096c467e8b5789deabef6452799de46ae64284de3ee98b52b5ac8b42e24d164b07bdc767965804d7155a2ed17957b632caba7d62416b4db8657e08a0ef1503122a97dadce7480462cd7e3c60277f2781aac2f90b8101283e273a36afb054b2d211aed2a2e527503a1a27a67ccf6b6f318f02a7cde751578170f9b3612fb40b30c3e17f2ad5177e17ff83acc2af04c9b149e94dddddfcc241b2169d675760de513209f6148d100f29c9aa1d521a073729a060503e8c751f25d1dcc378988d0e6c092f7310572d2c1f9326d97596087d295310f83ebcf0cbd64b7a484d91eab7472c6f9b3921271143b97102a4d712d0f6f699b6878785b8811c279cfce425ed7688d733e289233e7c4663d80434656fe1d48b7e04b48f8e32dff030e6385ee7b1b982e2c50cef75df87d6df9894e1bbfb97fc451c2e0949babcf578f40b6db3a1a2ec7b03a5936e1ccd8ef08093693eb7c809b04f0325b6023e97924de9625b4c86a95ff71496d7decedcaa59b118323882aeb1e50ec77319b54cbceb438e0df195a4525fc1255afd3c12132242f3e2cdec9d4193816ba4423fa8fb51dc12f95fb72c6ff3e826464b9b3103b82487424f430dcbebc912f38d0490e1b74a289fcd6f87274212726cb438960fba0657bf1ff554f1b765411e9e93f881b214979623f0c7442708e97c94b169a8dfa33757dcb3de6e2b0b3ed79d0e2f6765fdfa861086bd5eddb53f9e542c0340df5b805fe3030e2db69c258a4416d607220de84fdcabc172450425978d005b1a5584f5f7c64f4b31cfb994fc39033c540e95fe9a7a146cff18fc1a5073cb24dabf367e39fcabec460d69def3817ff34d6c93beca9f599e9e16ce101dfcf6a6c6e3be16b18383560f3621e0d8d0be28c47a85236d7ef9f643f596e2adff8ba104f43e9c5b94df13c13850bef9cf32ff9311174146e74fc9c018b8961d1432816dcd4801dd0d153e848e8538ea541817eaa1f8541b193b31ec05ef7c8ba85779bfd85515dc4540808eb3ad12b4e41a750026fd4317de80a906d5c0389a1c7d2f1ab60ba3af93724fee7dee5256569ceda3d2e66fd5c2ed708d1b03ec2ed83ab7b777e1c9e77781a0faace144e8db44056a384c912e4c7a53644d3f699cd8ed021798c60c244457dea19e84934dd7feda457b7e546a4d53cbc19446b7e87418bf7a96b8bac8cb77c46015a087dca7e9cddc67c79a6986c1724b80ea435422cb2418638bb874d01b69e37b0c14eedd591bc520837c839976bbc95ceecacd9b6d97432c44080b8e54a5cce9b0836ba823673630321eb049b74a0723faf7e914fc7c0c5b16c0d294a2bafbc5c8457d88e3ad572368eed7b41daa80624ada4decbd0b891f7686ae4824d265a18f596933724bedda300c2132e52943f1eb4cbfd7f868485458920a3cfee4ebaeda20f30246a0792752363317ceacc0642684f5be299bb33761a7beab5637f03e920a1ae56c96a13374cec992ad345cff405691ed8a09154a48e4d254d73c7e522e9218848264dd83c7cde6ff21e2755263f8d3e792c55efd1a7e4ee2f6a9252025ce868660f2c188d62a31ecd1da4333ccebd9209f3b72ca2692","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
