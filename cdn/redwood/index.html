<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a63314ce9fb3e2e06ffc98eaf3c8ff84f62f5055109bf7d13ab7bf42a5204f6b418dde89717d2f5ca17d1a7819132074602e80f0c70eeffbdba2ce0ebc113b7462ace0b6eedcb0ee640519b174f3fc28f3e46cf073093309593c7f35abf4cb3c37cbcfd4cccc83a8e151f489a984b45ca72a795ae95623af597244e98832223725fdadefed36470a8bc953478c9f3500c4a55909892e7da34edf5762755d1bdcba1e837753bf077849db84f5968e9aacb08be2235b0e26b240470fa717fb9f4317294f3853ff2a93b90e06ef9e706ef93e1a663337bcec2dba93d46c46fb5d2a2ff0870214479d41055eb5ca2de618c267d53ac37bef9c405c343b1cca864fe0a3a0ba88e94aa36f5621e3ad8290d52144150cdee67fadb7f6c098950a0cc4d9c949a9ad6faac531cd5f5512f925cb75f2a49df2f1c160f3f9b209f3c13e61d31fd0bbef41449ac4158ac38a2b5847c8c09da2d04d11c977936c874620b8054a69cf95149103e06ad14a2693bbdfc86bbd76e69739406b24d272e87c407afbd048750e14cf99b27298cedc786eff0d27af0de9538e9cc29348ed05df580a048375b2d920b2e42cd6c1d6771eeca6572fead2a43cc213031ce8393c5bb22d807033a2bf5bbd515f26f8d3bd1e956d75f140c5d72ad80d0a44585754fda1718f68513d6e74855e238a860875feedbfd0dc76771e03fbe8b697fe4b71f4059c6a28ce8df274fed64868dbd9bc0eacd4d3e80b453b9896a2277fd330ed29e86e317337cc00a43d8bbda5f07f0269e208b2441a5a7907e63af7c291ad0ef74ef018e7ecd90a6e538b364dc31e189fb28d05813209d618d56e8f5348691bf3b64c371ec8af1a754b3a5096edd2a584462a272e699817df0f8bf9fe47b30f93aad3343ec6b3027c80be349a9894e6a2080fb99e5f04805b7427c7a1ffd8265df06788fac6b3ce6351facb93fb55c5c77bd2bebba7e75445a0976c90e12c1049f5e0a88828fe5b4bd05e71738fbadead000fb0f1435491bb5ac0e0cb5279d635c0cd7a35d5c396df612fbfe1b7bf5abcab0bfa3ba06cd529a2f3d92120f71a32cd97bf3dfbd47a155713aaf58d75148900585226e9f417f8786ae488761cf1c88c8d4ff0ee4cd33dd8380b0cfa29f24f6007a4131527eedc0bfe3ca4ba585518fbc79a9bcc724d82414cd2b897c922ba08704d11cf59f3567d7cd61e7d6fe671ded983e6afed7fb084bcd205f7ec98326e82ecf42938a6ac4eafab96c36858e8486070705a240577f6fa82ddea0594e668412fb2339f1a9ddcffd6a7b78e6eaf226debecf35eafafa5097026d0f0a607b72f97eb5b8a588cd13a26a34619f36d02a70e7a582ce647b29b338322a065670855bce146c422dfe11462ef6e0c06727da15a8c054deed62b11015e6df8e4d9366bac5c576b7b9babae3b3cd841e0f721a521d6b3fd1c71f38d013d16a48137b9e44da9bae95e533aa905e02ae46a49adc983b322a1b11f48b4f74f17929477fb38fe85539e7759dc6fd9a16f6d31cc053ca393b6425d6fd2d67217382cba493db0df74841b7b4c111f40e1a3b9110b097a75a0bdba2d97ee11fc79cb86110a544df56139d1695096c81d8726c15828c0701865d8b4334776f9b09d5de5f50f539c99198962a45ad1ce3ddbdd311c22eab95d65af5f392e4518badea2bd703c4e3d7da236c8ef80c35b1be3cd77a5968c7546a2d856110a9dd24091e9f8863a93fde8ac071747c1ebc2908c525269d5f1d647951f241f0d77cf13e2b4699efd291a7487d5d827273008577894c5f06e2c2f9aabe0d48957aa2764d6cffea95f6076bb157b8ce1dd493fc0e7e4fbbd2279ffb0035c57c1c074a8ef0f6c42c27be204f4a0aa7259ca74f25856ccdf68b501758f94e20736d3ade36411077b193946e304268457532399d50183f0c33dfcdf4883692741d97b141cb873b20bbd8676841dbe90cc201161e9e91579e9657a015db9c264be924c4b4da9ebca9586c29a8e48980be7cc78f951f82ff4614e8cf3b47221d28296a3984276fb3a92014e1fc7007d97ce669bde8743bc0ab7b2e47354753ab11f54ef0edc10ab5771bd1e8a0079ec4a897134f0beeebe55977f8d4f3cee04ec42e9aaa39b37520fe621848c2ae7667ef5c92d554b1c3e388eaa180e16f567d78eab6dfe4da210619485c0dc982620d5a3386d8f94540cd623b3def1075a387bc626dc470523418f672c44766a3a8fb5c3b609ac4f9e8d9dce862f73df0db266fba1e3d8dd75b7701231154dbf7f5030bdae4cd810235080ed4ff2ed21e38f164dd948da434fc5bcc20a9b4516fd23b96133684c82cbfc076dba274bb51f319f485baa8af1230dc86f765b1cac53a70322f3de269f1c8981cdc176dfc5487df3456539c0f06a4c0598644edf2150c43013dba40cc38951afbcc12895377005987e81a08e59244a45a9cad93af500228d974300429206f2554f6c09a95837fe2e87c7399514a3f07226a5a5a03f52880c80ee365c3c3bad4ca712df7d9fda0fa37a16015764b180a4d13cb1ed66569431a08fb8e1a43183359d59e4da5b8db2175096476f4570f6f5ac1018c2bbfe9d934e5247cdbbc5ba6f9d95260634cb070ef49c5044ce6778504405f30e17dbd61c0896bf52ffea31a50950b14f0039604647dff16477514335de842844792eac78bf78576a948da8f242a1a11c940a4b184128518680a37c78aaa290572becc90297d234354db4a69b4160f83a5b4f16171f8ce89d82e913ca8cdf9d29a1122772705cd84db0e7012235af19148dde125e775b520162694d2bb1c8f9b3ea615ad054acac2d4046d9b654ced44f7687d0e3f5ed8042f62e2b76adad37d51222841441ceaf05fd0cdb701074f87c755c0a148aeb0ae4ed5a5e7ada7ed9985bca06fa3badcd7dfa127b6df5eb595824f0dfe80cdef6ca72e3e7aba64693a5bd1b6f31a610da789356cf863834104d47af56f0b113d247231089aa4938319083a1a4c0af16103420efa6456352b3810620246a3f4e6bbc58e5c584a0192723e065870271c29a2f08e5af998c72a25cc562fd2b84374198fabdb092173908b2923f6584c5c869aacb0a864396fdfadf009db93ed165563278e15f333863c61cc79c0a4a1e5e47abfffc1245c595e3deef4666d8c228f801506b97cd8f88fafb5ea3bfca234822b07f7856fdacc422e78503e50199a810435370f99a11938a9c0d2659a91993d7383b4d6e53731ba65683a0be842c6895d7e8ee02d3e81bba52d50bcfb8f740e9c481530056a91bf74bc047f5be86233469c14a9218415f4630705e686422e2f365d6f8338ffcdad6a13417bb492ebaaf4c409b111af1ce85d9878e66a0b8a0433a47439d6203d528f06a58c8a1896e4de8d1092ef47eeb9a4ee810b9b7207a9a9e67482287691121998320a419d6a3ebff4c7a3c987b5c17bb40496ce73f8e83943e57edf023004e3e786eafc3b3ceba994c1b33d21ac61ad5fd7fd1cd17b7ff068247ef4843539ab957d83ee78788f79070efb9c1f3b5324f7e9adfd6aecf22016972a916ffe2ef8f01768a0a6a37a3a9b6c1adc7d67218fe84b34c09d47480676a0a47c05d94d30d1b5fc71d91c48c0894dc9797f1da0f5a1847bc2b42fa496e7b7aaa71e792f97270a3876e7d76e35807941eb9bd5294d5810203f46c609fe6953bd9cf7edcff9cfbe2bcf0ee95ecf038d471b0a44bec7dc9e6291de9ceb3cd0c25197e3b20c17d5ca79b21f2e5d2a7f6fd724822bbca3daf28a1bd503a7c6b23f4dec8c5a3a9dc51ee20e572b0406fef15f1361da8c90c233c45939ceac02396559fa76ed4a575aea27411e114df82bb369006aaa6117389ea3715bd2fa9472a85b5be52984483e00fccc94ee5a9bcef6d562930753353ddbb7bba5ede32a789d8585a262a81df61e0f9557daede1b45190387065f70cfb7745bd71a6370a1480aa10b8ab2b5a2b05c614a0d5a334a19aa9fb13802d82082eba8fc250cd5e69e514834587fa83600df7cb8808ba602d6d895a7195b03eed4b4becead46aa4188e1af1730fb0a16fcba5435708df31b4b659ed7a0bb0ac495970ffd8fa630b26433428574cd3e12701d9a1c8b676c0c3202e77abbdbd9153ae50907984f3447eb317c3d6a72ab75741af8b1b44ae3b28e155017f23b678b98186f851ea079d0ee42d2ded4fbe04408010d7e0e5ed61fb9a07460f9fc9bee453390dcfd79a787c5f6e4ff349ce51c9af10d184f2a04183b6fee2c74843fb82fe412246630a41b2e2da09fda31a432f244e30eb8bdbe3df94181e14edc6003ed13c2f435f917340f810a0efbdcab88083df15cbe8f02a140a15645efb96f93d1b05e323f0e0f07229d9bd24e84ca613d0089b65d6adb191188f04ca0136554e2837b3bedf8a25ea225fbea661a58c6b081d28bb2e853545d06f9f1457e34734d57da99df406342763d6b114ffd4dc3073e742b105b32a158c30256268c6dd4141bf4012954be9881effe9eb3f4ebf8e43fe19afefb2f2dedfc0cca71f53420828bd8011f2f3fce122345dad51363fdc3ec17ebf19b23a3d5f7b99ad5af14bcf406f9ba5726307a62f4a9488f2b00f5b6eac98504b09b52dd567afaa0a9d4fe21425e2d4586241204a13b174d86ef632fe7fa8f61f51c820623e2bf47f2eb159e9b91a338783dc0a953b9acfad293ac1ab2c24718fcc638774cca4756538049e6cb74586594dfa402b725f1d43ad77f246904ee50f56db8a12ecbebb3ecd009c25632ac629384678f8bd19878d272813f71e53086ee2a6e7037c04c9530ee39fb4b1fd9b85838cb148a0cebc14167f5e645af79cea1e997ac574923c1d0a4b73a40b11d6b2ae1df8989b04096a82fc7f6fa64cce36ab6ab9aa03d1376209f6628829f3061704a4176d2da9e32e513c75af9428ce12d0cbaea19102c463b7263b55df35742fc71b59a868d479732e5adb7e58f112a9e361c442708e9cabdcb689b456bb4e5638cbdabc556decc4aeebdea8ff7f5ad97ae3a1ded6eacc2f1fda6df25f1e96734c1625523e830ded2237ee5d81a7b3e948eb8975ce614a462b4bc7c9aaed801130481ad1f87ef3215d052152ac5c90910df5c2ee706920fd7216056e3291280f8cbfbfa9477411c44c6b73209c0ecce8e3d012d511b912f0020a045ea7eaeca6fe9322e723532e393ec2d830a711e210dabe24a6522c97d27eb0dc43b270bd7831361b3b72e559d23cd8171dcfe9882b15e5259cc7818e5af255f4f3e781794cdd6f1d07382fdb1bb0e95d4030adf70490907149c1f78d3fe68c1eee7fd4d9f207358746607f15ab73c09a75b921e6c5946f8bc94d48df0fd3a9873194e7afe82b026f334008c2138b697c10e6abc5714913f83477bb287e2d8b08a054240e730ddf8c6f53b0884a0e76305ca4a76371a17d4b06e96b5e55cec8ad0a56049a76610c2eb61bb3f5c591f7f73ef4d0019e15698eb80ab377337a678051f2da6d02b57c4767b294a746a3c53df51fd7a2f2cf7a8628f26079dc8013e6d94aab27fd366e60c38f298c07da8ba47f458f72dac14c84094fed9cda96d0d8d4a8ed30ba3b82a6bd086eb46a1b70c92b96a39410ba8c20fed53c57613982e0116bb6b4fdf645e6151b5ee6c6751e48766ba51e1219e15c35247b590c29ff759146f056350fb3f945368d035b7628d6a8c0dd9f281fc36d5898d416e30bf5dd73387757cc3f1041c10eef1c76f02e1eb1b597f3a18f105b5d024fb5194d77ed7c17e46164c272ea73cb72588d45d89b9ea7a1b22dbf661a7c74720fbae823b18f3773e8d0e93b257865aa1882515cc9970cc44752082be7d29ac051cbe20ed46053b14a1356ecbaf726ddabe63549e83913ee95d80a0a214f8aa491760e9d602a19c02f5523ecc3701b7014596d28a0e45a9b5a2cfb19bf8b9f5c7d335bf9eebbe9a0dac09f56b6ee1d287639b2ebfcf678cb54c6dbfcf3bb1022983fc1cade5e95cb59cde9a3d2c3ea87cca3b408a16cde39d03a28496814f7b242cc4824ea76a46e0eabccb94796c218af6b271dc46af06029a089795988eececa33abdae87be98d7f70ef40c6cd697acf09e42eb67f8a6f6e7af87b91dbacbaa6a411cf992a09b899d3ac2c6b58248872bb28533abaea93dc953846c5b9f4655fcebc44fad48a2c0a8b39cc7b292e162ae7c6d800a4bcf61bd3d242f2b904d462e9155ea5f41df5911e07dfc2287d069bb4fe739e2d80bd059656ca339958f710b4d40b9750901ce3204bb155f5ef08d2412c0736a1b4f53fe727bed4c9025f7cdf0a481cc93a465a84578b3f2d261ae36a09456184a90b11bb7fe11de3db975eb38f5608e63690f71852cb8519a15e6dc65ce2a00c8f07be7a47f0e42b994c8e0ecce188de63aba95952db6980e1369dcb8ba860b9b465b830ccd8f8ae36c6a1526cbe14fa9f78f2964afad0ebcf4eaa155e6b43b61ccca6d05d9a3dad0153f6a33705dcdfcf86ce370fca7efb9b4c06cf04fa4289d0e511dc7b50f5e8982278bfad46cc2f5c6955a5ed5aa2f57d6381776ecbf2fd11ccd66ca7f5fa8193a606af95403a518750bf731f3ad584467a2b00bc81a750cab9064df4524e5e876064c17db946631c07e55fee29cf1a998273ef0317cdfe5a33c188f44201e1552a29dbf8515bde7cd8c6857152f8dcd1f4e94539f73d4441772c77dd42869cb1f7408349f9a15d80f209d668f25c2e8a5a0ca3c4fb24f3b878ca5a0eb29d8dcd3e9b87982126c9a57e83ce08ce250b706a6506ef81e81583e1db3448fc400745376ff00732b17bceacd213e78c937ad9710fb06f03d00cab82c25ca6acc64461e8616ff953e0879d8438c448a06234b42c7b0a6f4024000aaa376c9a660fc425d403e8c6aff59c936d2b0e4ff1e9df584ecac9d7dcb8970aa9bed4497aedbb4eca2070a4d3947c97b47e1fee6a403bf35d57a27ca31f92250669d2cd587e4fc3efe92e16f6e5cf1b554cb3d099c622140ecfbcd119946a5577b46c2aeee66ebac99ebd65398ef3ee6e1e899716202aa1cbd93c588c986d7e5dc398d067d57b5a5602f580a390b7e0fe0e3d8f3719322290c91c9e6da58f183d468b23e7b91a01a854ac8ebb31c3a8a388432ff1b7ab06df56fc38ec5854887298f87f4fcc26baf0506e8c4687a5d7d0688cd84a865240e0c3bd368d0a74a9a60d0e7831286eabf2f37b4737ac4720c2f5478cb1d1fc8d7f23e7400821cff8e66a8cb8eb131e85c277c1ef799085863a729f6335d99f0557176e55b678e5a94696e2dacdabdd5c9624b04de083e7392d792da48d15e2dc0fabb3f999b2844b865845201c4cabcf1aa3d68f284fa4519c1b28bcb23cdfc35bee719918d98eabf1d3b244debf55c49cf8e4ea2747a52a4f6ba7acc455b7c8a2ba9f5b76880942834deb44c5e1559a3d6b0842d90b2168f6bb07107f413044b4c23c0e17c2e42e15352ccff6250bb9b028404477b1cabe7f4912e335ab575a523758e3469fb034aa10bb831e87b90e034914e530af0e71a8847bd77fe452d637a97c78aa8f47ac8294d097ea2ddf28642b934092e119317c9b975cf0e539db711345860c918e4c2c051fc03141dda3c1b61a35b8776003a4b4716f4e732f6fd0932634e91409c4e5564f0f60ec0fa0b282001cf68280a2067c5cf0ef33fcb2d0e4087b1cf4e91342aebd02e1aefae34f8d46f3191a05c88f4996f880f434d3b2e166815514672d5b617b0d4c7299038e2f55398ceeaa3d81e03cc28accc343d7b27f4b50b45065882ab03266d8583566ab8bb777d39f3017cc2a29e33453d0dd9d0eba002cfc29780a6a47f86367771b7a4a7bb4bde4d11882fb51671cfe7e59f6a2b69854fd9694fc8660e9d4df5e59c96379b59ccf7347f95a6cd87bf71250d858d423af50a9ab52d4a07228ee9a39b203f91f4df6b1ceb778f34205d2e98b9618e780b84b3f96583d13ce42159e9c9c10674e3e8aa05413651ec017e115722c38ba5bfce54d6a915da1078d3d6891b5015437f06dad16d9cf17ea75e230b3fe6948e82a8c67edd5d4f31e8d1cfb3d4dfad0ba015f79410a511383064fa1ccf2e70ddede1445f34cebf685d0c886c60c98ec934438d0e7e61b10431b7ec9e0163df8be6213f6438fda5b49e5ef9bdd420610a1ad29860cc481a6d1b8d988ce07a17ab134945209d768542799048729924a52fd8f0f197b59ffd4c6e9a9d932eb25864e4bb0cc92920ab60ba0e2e9764b0826db8340d7521fbeffa5689e2108d4af21dffdc7ff61485e3d112a690a63d9116bf46ef8fe65ffbdd1396e58192e88dcbc27bf09a59e4c1f92576e36f6dc44297c0c2addad834d11e0ec58f83e14510359bf71d15b11c73ec6ac7e12c31795c126e04f5982cec5634863d524233b02b5bfb352766b1a89bcef55e74fb5df3b1bbc823143a72dbbd32a89a75d7004c2a74f201ae84d98c8900023fab6a4257c383ebcdaa80add7a306ccab674857182d10599c8e36828da9cb52a4d45b2e406fed3d53547f49ea9567f4bdccb79b7f9e85f5e7a609aa74bb7d08cf909ff3b08fcff245a9d790fffe428de250b6866914477aa18d68795539c8748808fac7f575d7a7537999f6ef1beac7fda1917d712e88996529228d4ea86b2df88f2e29f87435d1fb1349f2b905b893db171bb3826ff80554a80b273bf0f8849c84345a9a60822bd61e0242eb629d8695305ebf610c634c940bf4e41309bd3e794c3923a82237eeac77f68210eba1cfcf0ff3999e709ff60e07f8731df78262bfc0207cfd034de7b3408027116098b5d919063ebe9fe0fa4a599775b3f2ffd7f8e4d4aa56d79cf48ab0c62d77e343358305894011b6226335d5d012e3109fe227adc3f39ba6ae2f90c7c2f33cbc549d7678ecde1455b67f2a5b5957ca60b3620dd3d9a6d9cfe28eb45992fd247c16d7a9f7be67eec257f0d394995704c2e522b13da77936f8a72c6b435827d77b87113ce2960c869e2b481a644b7191fd23d9b6a244d862fb120bd2520985099741461420855f1c0527279e4b29d803793e4711040d746d3c7a99e8ecd0308184e924ba7b66461c5ee3009c59d4cb352bc58d5cb1b565b11013b425cabeebb66d21bdd2253af4ac2c6ace7fb140ca46cff6110e5f340bff76eb1b546cd590360b519ad0007eabaace8dba2d22824b66a25b75a20688dfe25533a8c3f353c84359435ad6ec84d7791f48aab99fa64dc59b8039ed5c747c94299212daa1bbef27adfb1962c4990e6d1107ad352406e657d9246e380137463a10e3ea693d02a7eae305b32948e769d77018443c2177d4a218180cf6343a407dac5d6a15f94706d7d99f0d10ffef0c448af811bfe6233ac1557afebc08968a381205efb2d8b90c10cfe84da130da751840de77fe58d7f02bd59f8061a12681bae0e28039b33c91221d9af14a05db0620f828c8da4cd5f949adbb22cc80df1c162d83fa2dc5dbf9d0f1a132dac46ace5cddce365749b153f1fe10eb6516ec095adf053afe0b045c8bace0f8a67536c0a389f96c0615af983696d472b9839920cf42b9bb60b52b697397bab1b42f84249c1ec6c8f9cca9761a01e0199812b3b917db002aa2f9217d7a3f4cdc3b387265f0944b62b010abd6f4330f74f7b7912633f048bc4280f0782eba467df411b7ab9d976b18f069693ab27c68d270cc82478ecacab148d892cdbde905cf60418428d8c3d65fe6be6585eedf1d325a82a7edf2869955b9d99983d2e1eac79bd20af167a8a842c93ea5002493c9c9cbb5e2a7381a75ffa8516df97c82d892474163a90cb3d5c3edc93f29bdf06966c353dcd1ff6ab67851f62787fdf2fe00b91271ed0c27e31d4ecf3248db902701f13ffd705931b207cdd1a2a744dad8aadb500b88c6ecbfdc94f587d846fa3770b1f6a3b7866dafbae1cf03d682dd0a3aff5ed3baeff5713976231539f5c5fdf0d005113f131e1e1213f9b077faa719a385cc381012ae0ca091fd2f53d34653db39ce562aac1ea34b01f0f7afb4f4e8efcacbbce56657cd8081a017c9bd5ff3a2ef28eb031e2e57e5c4b5f8d2e6a8247b79af85773fbdaf22d207cc788d3f282b59a45529f2c4b6ce02e2180f87e1b5a3f97cd424cddfcb71fbb040764a4ee6295cb7e8000be26186b7bc5be84f743d58453cc27bba7e5607ff5cec7ab6db182d907fa6dc017e7ad6228e7018713020308d19568b3e92c893e7ef4194b4fb868d4ab6193a334dff9b4276086203f1dbb6f03bc1886e21cd3369555b43cd4d2a6348e60f25a506ec3270773fe47ba18976189189441f3a57a7d7206cb17f08cb9fb2cbebc47e26fdcd3fa886e91ae90fefbe83e4fdf0b4a668bed77accf8c3aec56d6cbbc5ecbc6770b471dccc2b0f810edde39d17ec2b447c2b881e02697a2995a6b8e90c40854bf4b4100ded8e101a0da718c5c336551a38ec136558417038718cbdce92c60ddc400ce3015b8487fdbb0304f6edcdb2f1d8eea78ba11abaa565c021a4da824df19235c20ac51118935cf572bffde995bad78921a106f49f77cd4d0c12298012c9cfe389a7324ac9f331936a1922abb2426ee1d9277e38605a772c51dced9953929735afd132bd381a68006b113ee72f66aef7efefa89f7091ecaf62eb4fe3d1003e3a167ab1600f0811bc61f3c0fb05bd0ce7c6103f7b084c54e1d56fce17a456b34b6c5d14142892cea24497206495bd21d67a15a2645fc74e8762e49dbfe0119c025dfd16116865713b2e594184287a7422a427a588d14124b7e3e095e56f4b1eb04bb7bd672c352d7828eda4f78eac3935f2d01dfbda7225338407902f23d2ec1b2e41921bec7b1015e55981cc6e387405c12ab112148b8b626cd9c1a7ba53827b3acb66f151c205a49ade646082e0d7dff073f26037c5a710626fc96ed770cee8e3505b8b2b7322cdd82d2e48c2b895d8d028eaf2ce169d9e3522a173d5fda3b464de73f2fbd4c2430a94a3603458b03711c38a0a2d2745edc10a4917a914ab240ff578263cd632dffa416ac86ab77779de9c122a8d8209fa6d2c3f4a9af2d2b5825a6f7e1787163efe29ebcda77918093884c387a04c55d370665ffbd75259285c43d56f7aee737dc447eac38bd89192f3f6a9a8eb4b249d1116d5e2d3a7447668e7e132ae9c17f9bf873fd7236146ae672410b2ef922f07573412a09d9868c3211645d588c8ea5e5c2fe67c3f92dda5d30a682bbffbe3530c8441769bec4403f9723a0c4f94d4bd98d9b457df32453f91310f3da980c2020e2b1b0231c7a4efc15af0add69708d45057ea845953a3956a10c2224f76ced419603bb07afa45479f7cc538071ca362424a8048f65679193982ba39f247c24d776f1952526e5bf84c234f70557734d1558fa48bcf3558cbca0472aa3677673671b7d10e30bf9e51786deca42b18851b4c5921821091ad2ce164e70be308647fbd5a7e239c36aeeb1080b78b6a233d54025210703e0cc26adc9579b48419b91484c9c53447da86bd744ee98244f506e74411f2a4dc5a62a70de065fbd671e6491a465b96bb67c9f7f3a0fc4c2547e616f5bb3fa3b9d828dd29346e6484086f3993a91e13e570f9ba2b65b9455a0c1efa812752ffa2f6d0c89e1ff0af8eb563e59c8dff81a560c39cc22ec38cc685bf6cdccc9a98cf49a2046951ea9b02cd65bea54b0032a2ce0e14d79e7458dbca99e953a4cd2879716bd2daf1d685278387c2dfa3e4a356ef2233a62a0b9b49d7011b550b2aa76cd32f137b22a66708ac329fec4e2d92f1c6345b2f8be37bc12c59667d6572fe0e7fc4bfbf5d15b468c8faaec5c60df3df73cd13db6c83085a2dfc65cd07f73142e629e1ad1e66d6b6e2afcd853927d064674915e5b9babe7511138a19db08fd363e685d583c916ab8158bc56ec018b80e989e1de29c7792dbba5e3d3a84428558f493ba650c3d5a374ece16c0e5a215226c9d761db6294c6e01ffc952cad5a94635dbf5fc5740a398a7e6b77991c7978f23db77682ff80d80bb4deccf28ee1a8c2572b0b12feb74485eafb8049b050c314abfa44d57a5e284866018bf9219de34ea7284b0b11fbb4af7c0051e109579d889178cf2d4c33f6efa0102f7059749cf21bbffaef01e06e4bb6b580aa3e136a25390f24f18b8484cf1d7a28fd71bb4d3dcb8c778a1564d14584ddace675aafda6b4160714c1dc8b7045b803ab5a21e7227c90661a2cf0285ecdcd738fd595e5575d4d3e3528af0c97bfc75bf0015eef6a4e505574f551a2d692ff0b3726c6e3f7bd790d5b97a0f726bdf2ac170fd406b584245ad88605bf62e7dca21abfc21b6030fcd1488c12e7efa8a33eeba2f3dc7ec04457fa2b6e815099bec55a67b0e1a7e0bf6e9dddb96a834fcf97c1541fe07bcf5f4e802ee7ec137065fdece5729db10eda13880ea8d3f03cced8d2f7e57fa8d25b2db6327720c10e99ba09ce739f4a74c137d2992bd7e90d0777741fcf457184f6d8213f800412124aa101e87dcd133bd4a857beb07990759f05fcaa07ffeb3581bfafc181db999b801419ff70c6011ac83d3e1f9efb162e88e41d059a93287d90ba94e8952c43046636e43096b63998a13444afd938716c8275810775ee55a3df31a80bd3362efb715f3c1fed240f0fd0129ace211ffe98588d7d00a6900c7bbc21bacfd8d1acf9185b4038502bf5a4f7166896f1fbbd25bf66e4413c16adac43789ce9cf328a5da170f2168cd095d208e3e26aca4f85e5ee2f1ba7f316420e0f6ff98a3df8cd7ad6ffc64c1775502aa13b75bc99cf33988ba4d8cb62cc05fe96099ab0d4bd68673778f34ee29e57da23cae8c117c5c5324edeba0178615953a73618d4329047f74665246a606a6f87f9f96d84e220ac4b3bd8ad3c0461512a2cb7a328bb3113550347cc952ca867364142a3b2e2f2f043bbb650e83305d4be657c3a9f85c6d264a39159664a1526952f00436a29b14d3f2d3fed011622a97a15150ed7d190687a9566feacaec122a7f9e43234f9663c66be83a3118e178fd8b2f6b2d4d64bbe1e003b22e1178463244dab8aeed74294ad12473c16859776423288c1378da2c12488c3a2645da7316b6b5b60a0b8e87cb581f4eb486823f40c7dc1f77fbdf109cb85a0ceb391b6ce13720b2b59b8016a6725b5873093f00b401743c1fb8496508561254c52875bc5ad64f904d8b0d209950e656f6183ce6eb7b03b719eec2a976bc9c76f881fa755a662e18ac6cf598ce0b15362b111fb5617e22a15e5666ad4d5c436c014fe5b9a84af62ede26d10fdc6cadff45375e458a72ef00f47faf80ebfab351f972231d8a3d705048eacbe02081e33b9ab158c2132e3490b675462e6971669ce851025255ece848610b2ffe5341d6e17bb20082f4b7c4cb7101023fdf51e4cff9930fdd5c93c32435bd68431d99d7469ce00d8fe330309f48de22aa50eeb2bf8598cc6c2051e0f34981af908d3f517ad737972e9198070d0c090ab52107023af7001628425cf798592a86288d1ac205eccade8f44c6270534bf58dd3530c44460f03e2481d00dea90c6483483c8f069cf46ed556e0b7cf658af2f2350e711b8451eea253a44d0dbdf3373f2b6254d7edd1afa6c68ab193a3d054b3531e1361bc842e11a78f0378e4aad2b4f2396c7c9b56c2861ae27b94cae008378fec61f92f52708cdc50cc8add89feaf776a8fe9e2d939736dd526c1489ffed20e3b135900a922a930b63a0e38780dba3b29c018a5204bcc6a3e72489a4e27454057a18f969e76c54c655a54952ef4c059fd4b7abda8d3031ced098755a36341bf7036bc7a69abc9b9178855140709f1726be36535667d6885245d6b1220ff72819a36c84fbc9c09c9d4b942467f67fb8c03574af214cde3794b7ba5e16a750b32b1997d145cc9af006283ee4875574b7de6c865197b7ec960f08172cc2121320006205cc9fc58a237141d97db3a976dfc954d6162c57ebb7204dd0e1c56f170438a7d5128c5cb727a7059da79f5b2aee7be34957c4f7bf45544ae5c75917a9d42289b66f8b0e89aa5f930af5fb73d67d00a3de2930ff3b6e87022e54497a02e8a9d9107f3ff8bcb13e2c3a90f5aa7ee8060b68e8fab4e29e6dc2499a85dd958d9f5fe52fbc2b7a7ac60c8bd033148f755ee37257045d7997ee47717b52613ec00f620c47ed614f98ca484d83e9d3eeeed0cf1dd66a571c74ec21ee607292b9bd5112d02fd036598bc435a3c7c61cf7ec3c8de9db7548524e87fd79bd94ae4bebbdea6e5a83a40572a110252e8955d017003bacb70db45397022f621ee38a52a1865c90cc4dd8f9eeadc4862529b5745a40ecbdbcad584a99c39745b63874ddcac478c702c4027c8b3ca57f168e79a44a146ddeab22faf24eee05c3cb185988bf989f84af78815ec79e38c7aefe6c8bd87ff01b3534aa38780e04a34d4ebe7f470acf251a0cb16c9c10b2455c8e3bafdda55f56d6d0a5f0585e3cc19d56aab7d73c2ebf90e0eb6541521077f8bb54510c196aca172c9e38a719462f53b08760f50d0fbe42dda5f5a694ad3d932d2b45f1cf1683039f1756a8cd18aafff26597f17c4e4466f8cb4cc8ad80926a05364856e342306ac9ecba24e9740d1ea026221c064d842b85072165b4814f30d198f6a59eda0129915f0711e22c983ad76169294f9e85ae4f12f74fdc5432c383c67604a45f2f897e5648f9241161d98bb0a365735ff0b470b36774fb73a14eec66ca495a48171bbd0d373f07f2483ad5a550d1f6d092417d189ba3113ac7dfaca19fe1f41578b19830b655e7dad4f9df39e9177c4b7bc249a479174e323bc84a793ade07d42e080ed17a707143271b320d7ecfbe498e279c85fbf69fb04f52b634c210fcd75dcd85dc601e5de7e5cbf7b64762bf329fdab9d604ab04dc735a4dfa34b939737c2d4cb9f8f1a3f13f0089563470d21044186be70f3297ea8dddf9419054bfaa7f6c8da3e599d885d48dda32572519ab35389c12859e90ac2af41a45f542de48f25fcba4cfb73528a34bea61c77822bf33a1a5ae606a98987f4d9f5f40b8250f355d1f99fc7bdadc60fa50c6124972f88a7aa34fbec54a99381b58eaf3aad307f50b433180d9d4e00515b11037419762535e41ed105bd3da7c7386c49b4f67d37157b5a10c6d383e0c4fcb8c5db5b6eb43b714a75b36b12bd54dc98354a256937da170a150f572ae5d784c0186f197c5a893e162504c302713b0321bd14272174592f6a92568482d029450c95e2c03414a0a50bd2678f982f3c71df7e31853477adc3fa6a78158c3129c20068612a04ed0506e7f0715b6f497c7acb761177bb4439a559ff42999b3b3b147274f73a78f992fdef942edb3cee9fc5dff3914d41f543dad6350b43c2c43b2026b3dfb722068c317a01dc26a16dfe5856b2ee4ebb8158daf0f4309a4f64d8ba3fb7bf731097e3063d610346470d143c9c89f16d97aeeb0ae177d623bc6c4c6ec93c8a31b679e1d39d2ddfed8d7c5a672c4604f11501658d81da03291d990251d0c85cd71b81e3bbdc671c1d280ee952845423720ea025a894f5a76e334ce5a4a490a6289de5b252851ae4e1a44a8fc739cce674065e2e75898b4a9df895beabf5fff1eb13959c7b1acc3f42b2a39298f482698a609b289f87487b5336fb07f6801db02db764c666a67bfa73645c5a4eaab7c4ab8a584f48858ac0bd714ddd76551c05e9ecbfd6c303d7af6f82ed46befe35ca62158f6bd7b8d26a7b2ca1c6c3ee47cbdfddb7d1ffab640c35ba955021e53f823dc8b7ea47a98f6774bb91e7392f2704c62e620c4d1f0563d369d7b766a6f761241aa508c61d41e577f1baacfb711807d3b444333c756edf9803f764d953217d95446b24f5067bbc0846b86644ae22ced40058e06fc383fa0d6d9a6df9ccb7b99c8f698f5f9488ddd59137cf4f14e8a1dad8ea822c48eb956f282fe6ca67e637700acb95cb46f6ba104a1c643a35c16e2d0ba1096393f50a094238d9e85a2a2e3bf49922aaa53aae0d106a822d486d1b56837c1f88083136d2d407c32a35c6ec1c42fde452749c8a7cc521aa2945e7caf5ac031f9cc5a38270c98b8adef0c4e69fbf9e3d5cc7969d7a6b60afa950c7b0c9db03beb91b7e9bf82f3343717281f70606da3c5b6d4cc58816e75dd2caf7a990e9d040878cbc88e8a699b2e2ab8c16ecb1a778ba345ac46270d3db485eda74377de06e623bf6550ef1af7e8b8b585e8076c7cf1e70e6c8f972fb3ca8197280dd0ce49fdd187a7a4393629c1e255521c697681429ab1c7123cfce302ef40cbd5b3d9a0b3fb9c415168627ee2fec04ad9e786ccd286cce501e9de19566b900ffd1d8ce9708dd934f1b3a3a82032ed5c11c8c668b0298939b503af14c851e7efa63c7fb25587113884ed5f98c52407d65272562a79e41e9699d725148c2f8541ce8fa1ce7dbf221050031500fb82c219aa16ab303617e56668514eed97f2298314e1353c6d065b35fb22447b97fdc30f26642e69737693557b61cb1561b3dbe64e292a009a19021d1fdcc3dba6f4025ed6caaa28f2023e16cc63f20c2380c52e31548b85f60292465c23a8f651d4124f944b3f489193633c3957f42392ad759c699a4afc27a8686290f20d6518cf0f3eb766dd9f926563721734231b6dbf167c5769934e03240b71f47442f3a59cb8e7d2fb12b7b66cac0e58a946e3972cd0c0c9edb0cce8c67216411e1381932fdef6bcd317a2c33a7c28d66786e6c3065ba4ee568dfd112be60e2f11cb12e0dfb5118293cff37dcd1a2fe4fb838cab56136b545ede74c843249a847736032ff501f1713ee345438e6a57e2a1bfd5b3fcba2436df5dc15b7b5dda687f4253981e2de9a61a65cb63af7a8ca61b24fdc8aa4737af257da89e100aad76c233b749a760afaec49062442e72df3dae8ef7eae2d818907aea4f118162ea7c4ff834a5145c9ee9a72ade1e8521ec094297df99327d64da7d74b9fa16c283681346b4650ff699b6826b342de6dbc04d7e553ca716044e75271e8ed3730972fa4838ec6193590d3309dfea43f496715445a4d92eb61eef3fdb3a92cd7b7f8aed026a3336ec5928ec209493a6ed4e0248ae4111b374239fdb7cf06fede575bf769cdbd667f4f50856767a5f415695103194ac52b4c5e0fd5b2e0e7e6e1e27c2e9e0f3d95db29de9df80d32001220c4ae2eb307f148b5c8a80387f6adf9076ff4a186fb324f12085cea7817c5b036ad7b176662c21e6dfda4f6f7dc554c4e78cb8dba03e4019bf942e847521271fda765ccc6c7c627d9c18b3865bb5eb3c63de7220ec2a1fc485b5db9fae0ca12aedadb40c5a44aeef424690b005eeedccbc84cb3f2ffe0fc5cbf661ffd4013c593b656549301095a681d6b72e7a041322071a5b0b19ea41c4f0e5753b9d67cebe7e7466837504b012811b544ee101fafab96d7b7f22547ad8b0883901e9741e3bbadf168bd53fbdb16af5e44c64c07a6cddcdc9a88f5af58231333c7450993fb0673f6f0e6be33835bcc87d142c9ad38d78d1a2be5ca0243c0ce99302f95067c31dbbbbad80a70a6e32ceafc7b59e932962f22253152f653f7632976b41d39d74a4cb53f87aef8bf31280b66974c4ae33f49c6f316c315e2183cbc73e3e1e48ea50085ce9e251875b976f47c91d7a77de1be78e5dcac9dde12ecea1e14f812fffc37547a62e76f91ecd02c83f54875f41ac2f4c1cece8e889937bc285f9756e30d68ec5aecacdb6ef2d1e4c808c6fb179bc8786c4bb1e251838603244d859c9ec5ea4ac08b451adf8b391c8dc17f45e1a3993541601a2638ce5e37de87c5496876e88dc8b3da72e510a46396ccd04dbc60219c684895006ab58dc16009fbf3f6ea630640bee9495b84959de03906230bc091ea2b5ea4d2afd18ae2f22f4983a97af84893aecdb7618d3f85d6a7d469aa8fd843236f6ab97eaa61afbda2889265aa5a8e133f7291bd53396efa7dd12af26c60f69dd0f7c88da63055b1123020f1a5ba96cba50987f8cfc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
