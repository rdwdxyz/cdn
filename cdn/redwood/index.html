<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0a0faebd65afc2dfd8bf2e71ecdc7f2bab3b547813f42b41e47497176a55f4b1ea4c23e5f675008bf1d4645e9fff5ed8f9f62f8ff71343af95a72f0bb7523de3bf97a208b6e72328d7158cc03f6323fa1b1d2c16b8fda4c42f13ca72458cab575e08cb85cc3cc75c3f55bd3d050c0e7a26c16e7c65500da5966a7def15fcdc9a6441f19de29346d25b406e83d97619a0c31244581be8455a22eaa8d0782bb6d6683967c52489f3c5ad6e4513e2f4fbc29dbbfe45a3fe2a3aa7067868524ec5f903245400780405cf3b67abb770740f8ba3ebcdb436d0ead18563f03a704acfec88bd0f246e74e34c43f95b2d75d7eee739b104195300acf0da66b9fdff4e66439597255c9381c9cd9488c0117323048a940af4678c8e1043cec25d5ec3a0d5e68abe76ceb3374e615e2dab94f9383909db876eaae466db84822ccfedd7a999475d42730e63f91714b04ad918cedd136ada5f164c78c9c7fe9831fdd287e1b239c72838857ac49ca1f3a203f69fe404a5631a14935330e91d90f3457c4c0b66dd92016caed0b1dc3a638bcddbdffa74f1fb14159929f6eb24b09f4499d8585f29c6f8830ca42b1bce2285df1e3be6ee01d9d2f5f810e223568acdfb36b540b87111924e8701b6944bd799f3c2ea076443b31fa705da55165292da1ef7a6bc5d6da31e771d91b63a6b043d5051805c21e96152352cbefc4ba81632473700dd4c25e14206277d29fabb2230d1767285ec772f7a73152f5979f11c306f772c6dcfed1c775c8f7cd1346e9fd42918828a4547e3c1ebebd7b4764387a94b4e2a217803548ab58f53dd948358ca34814ac0848ca1980fc62dcf66f102ad25788c03c67b7d028e218c7fa5bc184343a4171f74a1caef2ff5962485d5a5fb67f5a741e03bbce4176b6a92e460c44b3a9eb8d9a9f646f51c771dd71791aaa2d1d44c99d1097126ee9971125373996dc64bd11eccf127b08425280d7bb9ad9bd7398d33d94d79396ac75c33c879d20216dc4f92cd3ab937132f83e0e4e2856c7913b8521512c28ff5f8eeb030cc6c8582a222838e66970e33fc6e5209dd0bb8ead65058ec5c0bf79048563a431f0dd76471ccda49e316af95318431cb89a6b748fc93b38de566ec3c72186b949729f2602e078f922605712b41b096dddbe30e2ea7df35210c22e9fff4fe87121a914b395c0eff98fe5d238fbad46a44409085ee768126683ec9a12dab3686ca087179eeffeb06b8848c36cb3626e18d588adb5c12300fa9b4d43604c0b2bb93de64db23c6aa2213ceccca88bdb840edfca4b6b0ad78a1a30a62cb9b0a17382c92583a1d69814569cbc72e589e2ef8c4fceadb79bc64afb44c5b865d1341b11d3f9d6904161e5bccd623894be69d964835feb58f2922f68bb6ae298dd899564170c22f44dcfa8fb20f31d9df6117bcf9b6df04c06098e56778065d4d4bef36e9d3ebcabd139f7256c419185d785f92ced07bbfe89425eb597f2d8b7de4664aa07bef3a51fb2d650fdba0aa62d993d1823d40ee86a1162c25742a080a42c782699c769fb377fd35482c579f9f1ab76d3b55fea191bd5ded58ba61623a5a01106d1bfbf3497072d8b5d4047dea238896b72fdab52ede6d47755979565fdc7ed99d4e4ebb9e66472e6f3dfec7372100da7de5bf09f0bdccde41b7effbbe4d9e558b2e3d877865c443a14a6c7d988505669d32e214e8bee0124342cccfd7bc81af2a05b23aa715682314382a1dfe9c91efb9f9891f84df6e17866127c5a4eed28a998c96da0c796df7054c9a6b4f1aaab56db75e86034c70bd6340f625f3768c6f35c4e1f1d43578e44c529035851e5f00ccc55caf8de855540c5b271475b4ddc0c89cbecf91e0b0d56d10a42430db56912927a9838a7e43e9013a05b1c9408286b41fad20c9720fb44f32d7ed38704e82638bfc13b02b74d7bdbb3eeadbd81048fa8995378c62d6369da215709f0f01d804fefa005a145af2bc55be7bdb7b39a505de1a0ee22118940aac0a451d1a4c18d3aa673f8a2792d18cbb178c69830e1242cafbc5cf5857c24e3f2d90ca53862ca228513dde4e7f56925974758d21914bf143423b2e76c65743fc01284fa69059065121a8e4cd1a13ad8837a547b2801a199037b0d44826632415c3b0973898d17f6ca82c8ea9b341ffa98db092191bf84713c32d8fc69410ea22d1a8b32796cad2455062c1a85a687f5f720533b02c9e108a56e227df843c3a199878f1fab598f877fca56bd368de6b4201c149df18b9c948caf4a13878444e61f5edcb9f38dd971c02572cac50f4c07ca13d089f3be22bf0764df84fd0d63b51dcd63cfd66288f259e312ebb0e40824d161b3e81e48f3f12096d0cbdd9c2019799464b353dba885b8f72ea4ea81d9532243dec7979d28228b29aabc5b03e6616269751e5507c0f5dde9652b2dff51d0da3602d51d0e1d85f4559b76ba4fb1dc6a99dedab8693eb48aa046377ec5226c4f89fadb61a6bbe4935129156ce84bf7da9bc37074bf60b554df4298a638fbe3c9a51aaed83cb3a8bb866519a61d60bb64e82da463beedb9d57f50263575c77b85f06bb0f2a347407f8d0129b33e405ecf4ee22d7f2e12bd993846434bbcd7ffd7bb2054777bad99bf7cb1a91a2eb416c37fc2a50b326fe29b09ab54c0a87266ac6d86a5affcaa1030e103c10e89f3bbb7c0fffa90904c2c384991b5fcf4286b45e022886c931faf715ecc9ac37a1c1e323190a1ed94b262616b5667e49ebb43995b6377f45124ccaff1ae2c3ffe2e7ab92e6ee6f549238042682955bc52a910489f67d544d3a3ce60a284be51cf0f83c301c0400375e61ed9c3df198f4e278029db6beb01cdad7b855988d20ac19d32dd024a44b562debd80f6aac94a8862326186eda6efd2a16dab72157fb5465a35d99d1975bb918ab8eda9ebeb7dc3299d404bb98301ea9d0878324ce8546988f3ddcb82eb34242524d9443674b38f558de581d507608c56510b3bfd25d2bd9333107c0814dfbdd787b33e17ad4e1816b715ecf8926d76bdd762f3a4373d14f323b3376b488eec44663ed0abef137dfb71dba2b20f8b8bfff6dd1ea361c1ef99050e4792557e92744149d246f35026e6182739f6688709175b5fd8573d5d7f38eebf96b33248ac1cff69c559fb606cea41bf13be6938702daf38a6d55e6ca50db23ff2f3f6c7e785d2f1249453c0e17a96aee1b1b4fb60337d744706bc5396967d0e32123395abc318570efd31f89b978144a02add5f3482b9b6c11d7bc8ce329af27b174a6c8a3fac4ed5aac6efb7e6f4d152364c14b454adc50d96b2a4a00231c011317e7e966fafde829b359946440d6fc3103e68194589fd19ef05b746d87206c9dccad7d5f1f6ed7c53f15543bc4582df5f16b390741d049f15c4c534bad0d6916bc401a9da122e1ba71ce4833226677958956b983d2d39aade3ec02dabd7cc1603d15f1c115719eecc3775a29803bbcb44d476977f3e185c6ed02333de57c014a9fb672812a2a7311c75180a9643c87ffd629757d33bba71ddbf5c05e37be52a2e39077677522e69dbe050b96de752569ddce0fbf96f0d5936e358d58106bab58f32d8cdc03ecf6a02a8a66e1e94cdc0adc97bdd4a90a1fa3c8ff0c8d6f4e3ed5947137500ba5793eb77532f38604cbbd19c1910de120576930dbc89bda6470edd81bd36845741161deda7665ffc6ea8b40c04a7dc723d80184dfe1dde692ad02e967abc9ac37510060214b8ed7544382a7424a3d1b1a340a01560ce23cb5880baaa6964e520a9c79cde3668aa365fb95a5a3711c0879ee003e7e1a582e03d5019355c91eaa54e8fab5c218e381321b56e5e30cccb007d8d9327215db1f735f3042ef916d3d7cb67b9f5017efde5f387f4a3d0a0a836ceb294e5674559efbbdc69a7b9995d36c742412c636b0574bee14c6d59232f6a601eab409867eb825db0992536ec71f2b79e81f94bae32f6d7b29f34cc7da39231f6c399dbd27a21a7342e1b71db4989f5d7e97d35b6d3279d1357842d9dbff9c055b446c625f56a8dc3c61751c5721b421c2e1d2ccc6cd62542c62cce2792597615bca0631c3a18b6e784f143f218f2559016f811e1ef5fde7095b5d5ad9e887494648d91a78dab21d67a5697a15f58efaabf5d1caf69c06725fab71368519c3c94094371a8f77f8f82238e74f4c3b4425b2ded90a2fc13b9a1b68a64cf0011c8c91b4b60b301e1d3d06788ca04091ee614a796d604bf4bc5c263114c3459ecf123568a4c9b9c9fe3c81df77324b2018a2d09f5190b2d1d2bd2179a084abd6105264b916c6a4e940d257699a8a62078199d706c2252e7cb26d64841906a4c905664a6c77e6b12e7fb951187ca807057e05cffbf6fc86785151da239636f44ae7216d65708331423ef97fc55e06c1f491ab47ba69f82c5aad8f8e1471cf6767f5bde2fcd3e811728cd8573484eb01f14f88d54b98941df3f4b6cb6edf11ba2137b800e24bc47b395404cad751e4dd16b6b2d600b8eb06a48eb1651a7c738b26a2bcdd582d16bd4a8f5255e9ad2c78bed08d6c0b4392b798728e71c85dde7db9a33af64432f3f5f8a7bc91aa241efb2ca02ec4e35acb69e25f4e781ae1009bc7c9527a16fa70d4081245d6943ba9970a41648db9250deec5cd81d4071d22f9c3d7e6e5f29e3426b45c6741183513a5f2aecc39130ef9a5af6c2557a8848daccff5ac1408f5988e5da9e18de11921f59844d5cb689d24dd2024e6243a1bb95c8f9bb051136ee283e45aa8eb7d125c50c19a4954e2e151a9445fbd9cd755e0bdb291885a9a5953da624be59515bb4df47d6191fc593584480298aa5d674388c138b56f1a074685f056b54cac01873bf565abc29cb240444d780f5005fa4fe55613b671a78e3082df073dba8414b7ecba038a74df38d2ca60fd719acf8e92d43168f8d78243985e0ae9888ecab15bc120c740d10d05dec66fbfae1361719d05f6576bc3ea7e29a94778139d961065e9b0396dcfe7c5845fd9ae85cb260afffc5885e9bcea592887c397d80ed728d8b0a0bc48892a6284e3a958e33ec0827447b7cb0252c3e070126bd1f3bee773fafc491cfae973482b657e5290a83895993ef4043cc2cd90d711a56b83c0bba12b331023f335c1db6b900bb63e947664978224d703252ad7d6ec9817a0caa7dcd9d86633ecf31bf213adee6aae3a78de8adcd65d0d084dd900c064a2b7c934dac733d26c47d89fd3551777490c2519b0c3e34867ad72b8d0154b7b44e7e3d57c59f2c62c37a9532ab4a1383ea025d22167d7a7fafc9a66736782909e5219bb81c4f73cedee1340ed28581b8b9efad4e813772e595512f4f04f358dce8a6296a1c62bd686ec4b06fd82382487eb0e8186a7381722e93e072354154d87d3396b88a06d16ce99b077cb1b6bf5b0789845bda36a2b15b3a0276e314b40fade7145f513d8ed0c34922225d7aca934a41afce2aed2991aa469dbbf518dc03db2aac0ea436eec4aee3ea555ec5aee674b15e59d4016ec160e2de061672102da6b9697e4a6e9846d63dd6ad054972cea503adac6804732c78ccfba245801e8eaab26d1766976a134a2fe7d030dbd1beef783fca7d14263dec36810007904d207f02163da255b107ff026894058ac9d9cfeba625bb7e055bb660c0a718c3e41810f419dbefa0aeeaa6aeb2eb438a61b1451009336c50024ee1522069f72bc62526cedfb1b40787112639f36aff2afda59136969e8afb9bc6c3d2ebaedd3cda7c215dd5f542cfd7f3b1989edee0c5e8ca17498c141449ed58887bfa804f835c06f911e364d6d7c110f96fb1c7b38b53700b62cd374314a752062a73bd3f7744c9de325e3e48f894dc5f4e069bcb38f2ae047e59152dd7584d1f0fe6898793dc4d9a9c31d58c7d8e0636f399eb18cb675c0fa62348080f3a57f7a02c799104b0315c201e817dfbf2e05708630f5c314e4c8680f0416fb582b190f6a735fcb2c228fbce6cf2ac6dda639d3801f1c58cca3347fc8de689a958cfa3ebba2af3c33bdc56386bd6f3649ec2a08a453d8d0f910cdadbe7d164b18d3d5bd1f01fe7fbb2f4b138be336668277ccf25179b52740333e0dee0a437bf8084d9399ed3fd6b788135b9738b0aa1a4706b3f65741834548f75d61b33243e47150f2a746a13340e2b2a0941f0e54652b2d8238c140dc6cf9480db11bbed7c3584f13db22d5bcda75f903d9a3185770db253848effda131c95fec64ba2bc2022cbe1cf4c1ec71a2eb2ba10099c9ce21d76958c47ddbe806e0664863c17046fb913e64cf4a082b51f22b989a44c125e43f82c0d5ee76cda2febf9fcb829ece21fa05dda4f9a6b160a95c381b1b12f81cb2c0003ff56b40de69ca6d34bc887365595a205ca4aaa18dc4ae0a8c9260d422ac40097aeea11934ebe83704217d312c18b64f3addd44ad36a1e51f1003f1dfae7644b2d2172605775f81c1e50bf8b6d864b5c052677d2aca92dbc447f10aa4be5c48a070b2c22898282336042ad74a407355633b51c3ee87741083fe50ee008034be9686662b3ecbf077c48b1bc2300200085b8515034ac88d5170f15f8ca33dde6c1555c864177f0b800f36cb6c6cf41270712b536d9813e98af5b9f69a7f67469a29b271876fd675852c2b7ac7c038410cdf0af8bb4ff02cb5bda4616657daf8b56eb00bcaa1d4c79ed4e8e431c7b93d3149c0386533d33c130b8f6d227193c98e4c2b829b7b05af33bc31b08a00de640aee631db5296511b814ca3f43bca20142eb91e8f2768f03271dc8669b17a3b468aa750570f7a5305dbc8c9fc10a400c0651c64420f0c1a47eda0f9610b42fbb0c5834d4eccfd40f7ca2b9ff6b9dc352c371c0ed6218cf2b659202ecb13c3f03fb90af8bbc0cfef66b3b14455b543ffd25510c3a7b3d34189dab1fc8b3c7eabc39e67fd417b6ea3815cd679b6a59ea2a52df3ba782a63d4f8746bc77d6b312da3aad0fd21eed7da6c3e99bd9ef1505137aaaa3aec3339ba128eddc54f3c43e064d188a4b35b8173a9227e80c69982c658cf3fcd5ef568030ebdc18cb6273e2f012bab3c5803da670eeda313a0a99fa574dced9ad2a6e5d63410c3bfedafe1e7736a5f4360a58167ae067f6ede1a86265236583db819fb8bf785001e47c44539112d7665fa4048f1004672576ebbc7cdb2b4f6295f3001846b83298e1a9cc1e41d09fbd2d6370ec07811f6c1154f59562396636ff2a2ecf6b93b889cb7c154cc46a531cba8a66a9f46c9e4de7edcc1af8f52c6229b6cfa08737060b35f869f7bf9fc90280fa5b328d6bc43f2c9930d4fd066149454bda4a7fd65451ac5a5372c46ac33ae1c3d5aaf333178683bee344415947d3c0aab7e2f85f1e753e64ff6dbda9ab0d8590ef885ea97c700ff7bb5d55be7e0cd86c4455cc1f50f8b0e749e56eb3cda777cf0302ceceb6f37f4038b2b091d9cd3a2fc26748789c02604e942a5525308d371cde0da4ef89412e3f7095ab85c3ef370a4d9ece5cf286b8c3b3f748b21be3a87185a68a70984d10fc065ca97227d0384a7898bb2ebf7745ba450e44ffcb816e1ce6426e6ee14dda9860d3f7f715a98932fe7ddf3a6d6ae1e26fcc780e90d9d56a5169a943a63312c72ac52fc1699d6a02632db2b9bf1f79bd6914790b1363e994efd925c1dd010a4de79db1428114c41971e60e1f01ac66d7af9508382bafaf69141683d8d05f162a527e3fc3c13fd192fdc896b5d9941c0c96c4a0ab2b8726e21b38b96fb86684d97fbb03fc5ccb13fc371c0481471a64218891f2e95cbce88bd8fa3d547261401fdb62309b813737b0baf8e28edfdbfefd4931241f85376e3c8cb8e15d4deeb59e031ab088dfc945e7adfbf4eed55df5fb1bc82c91da927d6a10790d3e0e9bc4602ee935c3fb1f623891e13e06b3bc5e55591dbaf112a1845195ca85a1e465ac1b1dd75b423b89516832f33f630d3503b9195ccae3ff3519e404240a3963f117be8bd88f657969a1d3a663e34e2e4a3d7033e9f73a8cdeea7a257230ebd2875fae12f7bd8e2d47798c6d0c4279df2fcbbb87df9c27e71e2f03ef9c6f7639b0d73a22c3bba64dacb9f8face0e994c3b54958a035dc58419848c9e1ec22bd4e08a9e2e3a74a97aa7c0366c3191cf5ca9cac46d1cb08e0440c0255baceb55694156e9ee633ae3b15e01c135706a8e4f5aeb6316c9f4af88c7cd6d95401f6741e8d3f1d293a753af9ba5887ecbd46d2f0caaf3cee8bcf75e22d4d19da9068b7ceb8bd2a776e561eaeeeb242dfe22feaef9f42b03653604860db25d2292d0ea6031f84f48a0c1c20f38cc1615c65344882599fdb4c3acb3df9ecea8558650ce56dcf5b0669edf4dc8089014648b06455e9e45bb108c09c6eb4bc33902da25ba1dd66e1513e6a387cfaa8dc8f086b27c8aaf5b8f196b6141350cee404c3095ae66922d316ba21be2fad6f41d3d69bf9ae2b42cfc5713e4d560cfe3522329cf052d631ba051434880250c5a5572ef33068be799082b2ba7a22951a5b91342f0444e5cb3c5eda681b250dd3744ddcb0a6d13fa2442c0b3911d219a68028cc58e96cbffa033b24ed945b6b211e9055dd482707de7e4431f1e25116ac4ddd45030ddf2ece2c96f93fe216c38c9f1d2fb2265601b63e144491bb13cd548b91af0882d2e4775bc8e6034ef52a86f66eaab6904cce40ea2dd3dd01584f037a11338d1eadf0e2c3e7de7b0ce5179a4f3a4475307f13935c559d07275409bae4492a1f3db06a15ad7c6b34b695260a0c7ac6ff899d3e6837a36ee01676dd68cbb6c8029eacdc0b7c6462dd241a11daadf42a3a7a0ddcfa977c83312d2452ce8db0ce41c91c2816455151b5fc83581d029c45e93caec11ba64c172795b43fb3d5242457cd8432b433e209961e55b0346fd07595cb835a05fc0b7aa1e5822602d3067fe815ad1dff43ebdbd61304bb401f4740669410be65cdef68b9f6d5ae19893f46d24243b6c4ebfab42f630b0750757fb513a75a046d3bbcf662068c1ec77739167c54c525e379b3ae879c56bf0b0ca8cfc36d95857c2ba8dbc4c3734fd2693952713d3425541df50e34be08036d2cc3785e17ed821595ea2f37b059598699200c0b5c305b811c7faecbd5e19ad9cf012cec26e28df261d99bd98683da42242802076bdf93b2d94d85017b3350ace7c1850bbc318bf3ec8ed111ddccff15dea8b07e8141ddd9e4af2b5fea6b36ef7181df9443dec9467ea2ad4aff9efc313abbe891d7aec3dd3cc95ee494ff4318cad5341cf72406df48d7c08850e9480a1e54fa9b6c70d550ef13132c60342f70d2f8349dd5829ebecf96b82af36e9367769cf01b16bc51ae0680bf1fa26f1febf5438372239642747626cbe934e215008669ed4f27a77c9760f4935aeaca66c795f3f05eafe04a74fb61db30bddfa20c8a6b6ad1e5cdb1c545cf3490bffc3562d24cfec4ecb56c6b0db8712cdcf6f8377bf756840f3a529e72fc1377dcd5a4dec8a12246b011f8f006ec5af53ec0fcc22395f07a56a21887c36ba29f1f3942bf89c13d6b1edc84a61d68f00e361ee6a4fe792c6c91778847874ca03569fb56a0c416e642c7dbb7603d6714a392c113e3d93661f416bca4b1bbaa632f1098e9fb95bad78b1d52c493cf0d66970784bf60cbb78cdd5f3645d77747afc5e7419ae791cbf0aaa4dbcba1cab4210cd4488688ff211b0429a98fdd15cf410d7893b7f95ad5b840dbedf3b492aaf25820df4c204252e100e1018d097cfe8db381287236fb79b9dee6f359c8e70f44a3da309348b20453af977dc678299c455aeedf11f4e73e46727b72105d69078aab45cd249a96518572fc6625e4921a689d6821d2a4b329a577606573abdc808f1e39b9ed51cf716f209900483a5c89eb55d674dd0aaa0106cb876f36b45226620ef7fbf87aef22157d54a06f4238b0f33e0638b95305ac198715ed6c50ef2ef1bf38e6d721886ec43d820fb968e1fc4b9c1d09aa7a5e6d02c37858aba047d242a28190f80d6e6bcfa19b7671e56dcd2e9831703d3d0329546a2c7f04e7e4a17563a00db4cf4635bb16da311ef5260a0d138151939054f1d85158d07484e4eb003f32dac3af812a1e46022af897f34115b7144eb206a25744f7cc20b900a99fe6c73d9653f90c78f8bf2ea8df38e43933d6aaf3f163584238aa0280a80efea80b43052ecf63584f4f3acdc90d1dca8291137dd7239f0b759b64375ab8cace56fb2688bdd25a29eec86f3aa3686e5327bde6ebd54de3705d8dd35b3ccf8d94cebc65c404faac8e94dd3237bcf2547af6f03d04468e60bd1bf922c848d1f20fe0c72e5689d0a45dd1bf8fef011765318c3aed55b2bb32dd6475cb809a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
