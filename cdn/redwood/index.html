<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0ee555d4f487e117a31d7d94711c26d90798cc85ac39ac8772c9423a08f216fc52244cdfb28689c0001ce1d8b9300b8f1b42fab450c6ec2f289bb13afb45700beb8a2cbde61e72dfc30ef3d7b9820beeca0db552cfa00d6240bb42f92d8de314a3d30f8badea48d3178c2dcd14c0c56b6dd1f5ad14e7e0a289c1c7539395af6975f5655e9e5f25e62bb64af7410d9cd4381b89f93254437dc7b63c36d6211cc4fc35fff85a31d43c00a0888684675c4d24e341c2eac400439403ee2a25e2c6da7ce869a7bdde9de1330a10679759c10c2ec4b2959e359572340f32236e9144a72ac271d4c87236051f0f61e61d349e951c260a322459c819d1c174a68617389b9c206dee41e2513d3c2a032c989c77f1e6549172dbc5fcf4cb9a397c193e3865b4972fad77305d360a34c3f2009dc0d17242b820c12d720ab78d56cd38dda4148ddeecda1f65c805e033e221c26741900bac5f45e565017a3c922cce64256103ab870fdc7b9d671ba39124d458cab21c077ddc4e1fec123630651d4d24dc6f887380677f3c5e4367a709a9f54f7ef106d9322de8202112b47b76d3a84a2b70715a9364bd12e5d8ed1457e0b77d13068c5f07ccd6f33c138a2837a1638604e2ca2a8b01ea3052671d1d6491a793973cf8d189d4a7c44cb2aefb5a18a518aff0b27f930cc1fabc2228d2348674e3f0e94de58b65b1e6bb8c0305c822137961539b903c10952240da337477f00331c69b31aad01b56b97d2c5d251688f09a4fcff9aadcc11b6effc84a3306997b439b91c368e9cf6e399da8c9fc822b5fc44e8354b66cf644b2f5c205aaee7959a5b6a99933dc7c13e05fe81f3c75d00a9741877af73903bc5e3c40249eecc069b1f2a78579b93995811457db9775d19c21458d56e5cc2e7ea918509c933f536ec96f4fc2de1f6ee15ba585419ea4c142fe6b79fd4befd5071c4c457b41466f355530de047a0b1307829a561ef394dcd6d751e03c09e35edd1ef0fca92728267a34b8edea2a18ba51adb7b33418333785e8f299b51e5aee36facc4ee86a03e40f6616ab3cf5eb03db535f27b39664665060bb4f03e0e76685865c4ef63c4c52cd2679739a34424d44f1e697ffc745992c2a628d8d216c6c580ca2358a72b7e42c2649611fbb7fa52cd2213568f39dfa2b8adc5a3da9b2fb5bdf5e4da235580c02f91e0b27aa0729a341f8599ff16be0db13aa8b3ce824a51f69997f73dd1da5366d0d05dbe0ff2bf624efc35a9a6ca4c9513cd882f0ffb86324d5493fbc7dd6336974a4da66433aaa27708feccc2b2786744fa3e3f43b2f1d3ee6667539b2b4924edeeb33d27bdd28e0e1fe63643da7850f4ea5cf477e111fc9bfdf663354a5414431db684b7e5c6231f9e5210f254a871d284d6f0f80d4209beeef83c593931bc33f1018bd878a9f1d16bdf024cd2948e87adc01e4ed965712b146a520508db22a225641ed0d3cba14da6488e6c75becc53769057ed7d03e3f66ba6417d1227323ee47b3ccda280f5b74bce9e2a57356c16f35959f09eff89bb6c1123448ae455086dc11f4ae171ed28e9f62871a3720c622cde69635a0d7aa82ffe81d665a8f460ce85a2b0ad6ae6cc0a04101fe94cda56a473e258c2db73ad4bd05e973020bcfc6bb090b16d93a109565adf76b8ba37fcfe710a9d84533f297533eb8ec20061d198f9b42039067e8691141b3412725bf70400a9f195f424dee2968dbd4a5e02f4467702c9ebe549206e7514093e455bab1308fba0dd34d96c84eb48cfbc453bdc72b1beb2e24a907f0d1e474e0dc0cfab5776b2726c81d791f67a9e3bafa3fca72b41ad690b7cc9b574d02f9160f1f59a13323bbca9f2c8f86188bc85a589529c704b8f4d9003264be8d0b7744c40a3a23c75e8af769ddeb4999485668aeb00e97f316207b72623fbe916a1e08f41eabe12941b68bddb2c972bcb539ce3b9ca59563e33c0c73f944dc553de9f349c0cfaac0e14e704ad002f15224dc97397202a778d68b34f46ba4f6a7fcd8d06cc2d7ae9e7d853ae30a160216f3925d6634d24707fa1014259168b76bb99694c0a7980ab14719ae1e72e92d518e0debf8b6fe9c1329af33342df2882ddb6d9312d3a74aba3323ef7ab5cf97f4ec610d75a77dddd99433bc94208436e6b6e5bc9e4ecc8dd8c357fd9af28a2bdbc7b6785bfd0eb7a1d918fb2233dd2d1649ef2d41ca44b2fd7c6baecc9c42d102335cf445301fdb9c2b0f553b5886e9dcc06e83428e1df82db67cf35a2e5a54d34069a0e847aa0b061e832a7a786b72d513862e10c070c46c3b55ed4c848a836b8dbd48a00df2a398775f7cacbaf4a9ef4d806e2afafc471eb664beef10fbeb45c58fa8658e1ce943b1339db5166bd1a35c34f211e4665f4df50849ea0d5ac003a2d11a7025061ac09d5a807d5d7b1a3cd347ad8b4f8d73d0b4f1111f66f2cfed43eefc7424c58a5edba1bf3a9df5806e1e4459ad1e45a18145d959173bdf5991c230f983573a039672952eb268b29290a8a5bab93327287cbe8b27a670ae4427d0dad6b43e47accf03eda1b51280dbc316f29e270ebda6c2255b8f73f63ea464e9fc9cf8fbf7c97b1ddade56337791c42c21add4555adcdf1f12f7eb0ca20ab23b17afde1a74893091e308facd78cf7ac98703fd24c08a075995d0d272a46746ce907697d1b7203ea9deb333aeeaa3e4e7841ac4a2590953a4a6f92f611a3a50081a962b2de786e2fa46670a86977e3a7269d2cb74e4ad3eacec010abc0df48515bad136ca3020f1a7175bf6bef1e9e1fe26178a38d499baa9346f7168c5a217aff7ee0b534023cb35240ee2d1960181b1b05a4cbcb086979263dafaf424acb8e253fc6ac994d28b90c9498a04af45d17b63310ca9c13efdb40bb0183f41e394642e1247210cfc122c1a11a2b1853a6464ff2b4b760c66e646c0738645d22a9da94c68a2a58d9c435effe60ce62dff82d92c7bdd5038c9056543417475eb5084feed8ec8ccb2885cb853a7535de37f7a784232d25503a33f21cae2beeb9b60a85f129c3e1a793b0ac234ab11bd2a26ede16ecd12a172e4727d35dea478b7aef24d7c74d2c4e12b06e44ce61d58de2fc15f59a18d7c2a8104ee849d43f6feee3f3b8762653b283c3617ff0b7533a51cd1621cc64589b0c7ad939625ff07fb25b22ddff654e2b32d892fee871033003788f346bd2831b75830d164ec4acec844618135a714cae9c993789d0324c5d3edd75f9fac47f862a6382a0b39c05bd469d106c459292116fdc9afd14237fd2d2ab8c8fcc28d8749ae339d148de7103f75b2c652b9131d7e2f15dc4d70ac90cdc45fc3a3306ac1d744e10a0caa9f0742fbd79aa6c29468d5be2f1cdde5bd7086465f3b2d5c4d4488d416e3c1a0981884381dd564b51be096af4b9f40a69b158badf020c23ea387d2dcd93b5e15f55c5f5e8d990b2492c10c483b4bc4e76dbd6eb962460767d5cb345c89bc2b0683c7fb57f0c66046310d6fcab38f40619920fce2a1214f223379ecd0455b38b7ded839ec5b911d8e118a9a3cb2fa8abd5a8f85c06a6730db1ac62032bfdab06588080a1cb818fad41230888cf2a3ae09b2b12f62b053a2964510a69b19315af22e35ec62b8107dc25baebdb24808a37ef944c0dd989aca536c8f9df186842bd270ad22cdbf9f08923aa57fc8449a5c12b4cb3d04865b0d913bf5e14af5b74a7f36a2ced9150d6194aa674560473573d340406de63af7ae97a5ff0731b682afc1b6399fcdaf9a8ef401a21063031402b9fb32ab418e8e979127aea93323b26668f49dd409ea9918e59d2c8a674715e61ed0c06f6d10302fbed70693887e82ca66029838908a4668d0a1e4656902d0344b99e70d237334c779e5ae8daabc443d24fcc6227cad0ad04ab5eb85d3328f2ff0e4c5418b08e96a2d72238a325c4c5ea69894a319010bee400a2232c0991679e4218d2631c967f625fb9d9bab0670836132a1257fb4af79af157809a275bb5a3e5843af4d61043b6fbadb5a8003ac318d18f0914d58ff11cdffa50b7a4f5328ab26a963f285c4c3af26c72f0ec399020f47598f1d8228f7be3e66297200f2011d917af7546e296a13cb9d6bfb537f759a92f74e6e08dfa5d577e4765bd284afd01641e6137bd12b0d59e717c7ce2ae04338df55e23d5fd683d9af88f8e34eff81f95057369f94bcd66a216041a3142492612b4754bc7f882eae75091f5ffe040a5403d6d893766b1ec375daf96aef2dc17ac600b5b76580fcccfdf31f4fa0bf784a06fa662e2a0bd8d2b1d2f8be05c20e7ab3de5b39cd32031ec9eb042f7d541ce145dd55286d847fcceee0484b4184f77d831ef45477b84fd6be0972324acfb37040befab91c7b4c8ed3c44c87c78c7b4fc38be87a3d447ad119e41755e7a19f84cfed1aeb032b41336e1cce27a8bd6da2d8b324761720ffa8cd1dcd17b0f85704acce21bd504b1cb184ed18ebd3824121cb2d5301af0924eed878159a9e051bd2299a1183a0c298a92013ebbe59b586eb83f4804b95a61d734ec9a90ba1fed7ea7c91e4b25b51c55b6235c84bc9aae6d50a17d5464f09a366a01c176386f7e0cf3280b6cec68f16ac9ac9423d632b8ffd25ff794e913131076310b25149bd117ee67c5dfbcc21778ab5889062fcae64aba5c3ad15d6be1a595d294eaff76273a8a6cac81c5d2b673df76784cf5f09c29034f8910bb1b43b8fe9264f5f321b79438463cb46ffbb290e4a1bb4f945b01268278d28bb40a80cfd656d74c1382901882212639a477e3b7ca9802c61a0dc5ab662605c29eb9b8e5974b2f65fecd660542e98291c2d1f9f8b3c8b823ce2fa426739bd1ca1ac35c93592023c70c8d274db4f981564d79cd39b264f590d5e5be2c9757aa6987a20530bfd5982bbe7a70f5e22b3a0033a6aca81c90fb57712244442ffdf3e19b52b26bb7aaf5e4a4fefb383396c74c3ebc3735eb356add039a660ff6b40d448b9901dd625bc50f383eb0c2d7bfdc91035409f828499c5334fdf9a8fd0dc913b915ce7795d9093691c14cb0c8b85bb46b1b90e7c0d37d36e56105525da25675b033ae469056faee47447344e602a88623fd4b8ff2c1cf3fbce979ca083ca2761bb5513022fe054452bc77a134dada196d42c6333f4b7fcfbc10f29ff6af701160629c138a9fe2d3c76cdc5517aee7038bc71def66a9cdbd9450772bc895fc56aba1e404d292a82f4f55053e48c1f17c7cbd0adef828bd6ebffb2a2f78d80b8db1ade4254d8d922160187184a547503e026cee3e15430ba8d163561d035a053370898ab3d26fa2dbfef81c2a467a0c9741d19070d453340d9612fbb09ec67933c73f8f19fa768b7ca066f54f6ceedd0a543a1be5746589b5695e47605c3bc064c9ba9307354ef2a156427e6de647f5dbad560a607f81512f64118b4e33c8e4ca1aa0988e2f81560dc1ea76ddb483990666cd1880a9fa4670642dec9dda08cd5b23b5b3677659d1ae6e17f05c7d66e03d8c4157d9287909078181dd3cf8df34bb5979fef8b6a914d636e7146735327690d5965eb6affb9f1f9e0810275b156c0b87adf18d24841b9a4bef08c78b8ba0c0768a4bc1550c321d4005b020290f0f3f82448e30ab4823670ca78484b5cb8b3b9fac17b4d07b59b30c10e64f762f4b0659718945a58e927bef7f68e8b89ec39eafa7d17375902becaa04028793bc090a3d7e2da280706e7547da91edc9620c0605b80ae3e559c66f927b755a7b83d49cea7ecf441b450ecd7331598db7af1763298717564453788fe51034633d36be180820c89dfc55b7b5293772040b947386d3df84275e215a50653d5c27964e61f120c2e8a00807d4d0ea34ad00efb882e831d0ff0e8a04e58b87611ed0aadf7607458bc9a8bcc6553ed016c7ca5dafd377030b309b06b40ba4080a4894149810e15ea6792515eac664a623f5629569e94dba7c769b4a84504e511da7a2c07080c67614072f8ca5a99c4e1ec4154a78c9cc0dce19a1a625e4dd0fd2add802cebd8b457cfef7797bdf09bbf09e6be1479e3e7079d3013b37cc60bb1ec5a0bc28061798ca91793bfae1684c208d9f4774f7588c90a614040576370a7d122bf6df0bb9baeb16fd2923c64de63c8ee1a7c01a4cb0347083b5f9f45a2c8891fc8bb76a2ceb22d82f9ae1c9e7c66e816a3e6fe36c34c8da47b812c96d02ee9205a7778ad1f38c2eecd7c4872f4d506dbe6f2117e32f26dcd9b4270ca1d0f58760776bd612376b2b504817c0f691822d05cc7580369d0a42863eb77156515e1d794d142a0dc594e9e9ade589d6b4f327e3c2867c79adeccc28afc11fc4a4af2279b379246406386a2c42ab53a2b3020464431304990698dd74e94afd83829bf397a8d013febfd06bbfdee742d6c50f7089fad0f2cc479b20ec9638c7d06f512af576156462f510b94928d73de2d6eb13c18914f230c2ca4b997b0951bf3308a185279ca2143a7919ccfb43acac3a034636f69df93bb40c5c18638db0e78261bc1515696f3b6df41c90ab0d6a07bf54bc470fccffd90cae599e2bb2a021687ef01e6a8ae7138dc1ab61bf2fbd42dbc4d53f59e661a547017a1c34a7631cd2551c90c7b76a7bde4023028cc80240655987b156a6b24492772c9ef2367cff7053f4ba7ad71349c589ee0e9ad5bb645d562ef6ca51b3a7b0c774df9d7a00904be9faa224db3f4979118ace688c078aba3f3837ebe13ea092befbc02afb4cc542cff5a864fd49f193c2c338015654293df2b393e52fe2a3c5bf8a8684a89151d6eec043905bdaff164e29887129b45507efed38dece436ed1a3f586caafe0667d79b07dc0b1b9d65ee5119d84017be5b79b7d2134c0c3a7b34e0383aa24d74edf3dd3a1f3d9b37c05e8d2aa331448f29ac713333d6d02a6be00eb2cb7f9b183135dea60fae4149f507659b81ef96cc6103394be9fb096feda7944004a0b73e62b153f02ba2160bfa12de97632388dbf4916814b1df293538fa8d742f3c8c7ac4fb09a85545a332350af197f7e6c6d3397a158033c4aff6a69fcc37c7025f16088e78dd8b0e3c4a9ecc01ebfb35fed48eff9170b7783022a1c6636fcda6bc7f5f79086c1d40c49e033ade12707b6ee4c009ca8354fe93c562ce1440db9f2c9dc1b2f9fc5f307fdd9384486b21dfd7168d3c5e1df58a1b65f86b6b30b483b377641a80b8142637215645084d4b1df714df91e9c995cbfe3459b406fd1888b537f265c8bd850e1f4e16b4ea7d852590b6a627fc6ecd9a8eea0720e37f6961f39e27bc7ffec17bb86d0c2f9db0c86c91e7d16e971eed41983f37014f7425b78201b0580db7d06803c2682eb86266ab6e4eb8c57d3de4853e9ae6672783e0dc35a293fbb886473078633a23afe75c30824bcdca9d11ec51acac5522b02fbc42900e291128428094b87529286da832a9f61c411e2bbc13946f7558a96d3224a143f817f57dee70e46b7e4e5c38f9d191e33a5db873d7806fcad48cb2d95ecbba640700e11ec461529d4f08e5c11317d8528199c03de9b75bc4f7ee997968b43c19c8e7934b0b5e31d8b71d03a7db0545180e297c6ae3c65a5b6e8c4dbe80ce03f9cf5f9deda34a72dcfb5c593490a7db443e49984017c8f4dee0c78593222287c8700e76b996bf24c5c2ec0287c400c6ecd440ecc366aeede90e4424f39fdef2234cc244c89c24c438b39fa695d802bc78055be29b7f247d2534656afcb8424ffab476502fd6bb807d2d22e4c5e5dd9c4ce7eaa3fd0852bee64bf97852b63ca2e26e7338fe4765c669c269c977f5d1a5239971b582c84610c3cd4a29bb476158a68ef945481c6a063e51cfd9d70c43fb0bd848192e0ee50c20410533b495bcc0c8eabec77d665ea0c42768f4fe1a94175d48b56cbe8ec64493c225aa79145acc95a5f706d3c6af93f27827ac8697fa4ae6e8ac6b77af2731b4f39c971b68745ddeac1a68525de2c5be745def2dfc2680f76dd34b2db24efd8f0e8d5af851690eb9a4e2b0966632211cbbfc900d98315f4b4e15f6069b1c204e2fca6022194ec4033ae376a20aea692f4a763f29c2b73a4d9cdbdb238e31dd9c73645a8900349403ee6512e93f092a078f59a19f936b9351e34ed131ff5fd5b526a6499242b9ddcbd6f4ddbae53c1f4110685449914b5bc5da38e8e0180fff5dbe1eed446fa84d35efd066253e9f810db3ff3986ed2cf35e215ffb810aa98e4672b3107aba867bd0beb45fb08b1bfd3f8dc63d49c72f22c7d0658c972b4af5ded1191f539a27df4d985950fc79eb1ceba9e99a21ca5e795cffafce16f441f8c984ef16936b28245b6d22a5bb600f159c9e4abc9a231780ba25b650b677ae86ad8d3e370da0a16c6f271c461780a3ba68d89403a7ab0b6c5324a997d235c331c6b64f97e83af74b9136c4a55665247843c8c6edbc5742745f32478df687076acb181b6933413b99599daf5a32e15ca275fdd6618b150a2a28d8881f56b51a216b287c98499a69f6ab3bc79ad74f7952d55712af2fae2037fe35cfc78675c3a2c3fe368bd11439185f89040143629392946e1f84bdc36f2b47d9d889b574a3b9f49b2e2d7782c131469426351bbbbc4ca42c61d8884b0e7bf428b7e11950ab8748dbd681eda65bd3c03dde2fa917daa200ece83182e601c262e4768b7a6b783715498ba479fd21ec3285c8ce074ee86681eaab5468b9b39d9ef2fbd14f1d83d463a2906db3b002a7740ee3e85a4cd253792849981da50827057ad10eae8341995b819af7a6f91729848bd1d26f7f520d3a19b56b0d38f4ed42b8313d70ff25a16bb7443c1079a1ae94ca3e6463c57bc36f1069807ca2b4e835e0ae8e62e0d75d4f3cd5964f5aae71f8bf0275820ac920f7a504c15e702e08951966dcbf8a3adbe18b2a27e1156bafa31a09f0571431dad6447cdb491aa69b4482b2e54341934c05ab3448d78f67f3db84ff07194ef1cfb8ae1772af362d5ed205529b58b0565aaf42f6497fa8355efefb12aef8a765020b7f5f690fab6b52e13857909bf2ca11eafec6643048255bd87e06176ab8b80a02f1e4fc2b2dd1991f708c0b1fc01ccbb8ca758f909d4d7c4072bfcc5ba5e82a1a63d43613362b2e1a2ccadb6f8bf84c62980199f8562ec3d887ef334433f9e7c2b567e22c5f3ca4a28ad0823d45ee4dad64faf69cb8a950e8102c87268ddd63cd0066c250c538415dae7f7c8582e7b4dc40bd78ec2b89b775a8a5e7422800cd12a1909878511312d758eaa22ddcd47e94d287fbf8ed2a061c195c7bb607e68391523326c10679f6ba27d83cbfd1b9fb0e97be259841b55cb43eea9007f399fb70129e3d34772d4980de13a337d19cc07f5b7b1cffbcab129bf3b43be0b92569dd3c10f85e394622d8479b09cd0fb65a9da747aa04963c95eda4dce4ce31fcc83e0c011392f40690e65f1322f32a9aed4cafc5d9c9340149331e8142ea4c8f56237cb302f6fefedff923791256c5da46717855053fc3f8b3fe88760724a8b7c16ce2a8fa44ed9a50fe4c13bd793bc9da168cd350f2e0cf8e542eaf7ab11281280b5d6833f2e9fc6255f213024cd0e672fa5202c8a80826b9c619e5a0c1ec8837f2c8e46f1c6eab2487025a7e8a24999ca3fa9a3f3de5b1524d8ef7f9a19cb2c5f3902520834c75dc03ce6cb49a1d286e402a2435312a6e6adbab8c72b4dbe4317448c776fba5303919eab57009a09f88fdc65698c58d1e0bbd7b2045112ecb7e52eeffbe9680177ace7a882fdbcf4518f6a55ebf812a2205488dc5878d70d2547b3cf54c2448db42edf546964aabffb9f64e8a479881ce4ebae5e11b692861779391b9dbf41a0d6412ef49da4c15bf0332c3680b0667a8a50ee26c47163605463611fe5350d13c79714cf4dde6cbec532129b12b47541328e7b7e92d0eca428485df58b0501a1554afd29d0fa8a110a955e1c0b9d96ddb9bf71d552d0c849e291834701c8702cca8754dae94efd20e7d4bcd56e54f97c7dc3118f948d082ddb985cdf4021d7ebee555cc29877be1c1cb386c25d3d46e87bcc38171890316230246c484cb8b34c493dd2aca48c12bff6fcdf9d3d3cc91eccab93dc1c42b8725471e40a2d6f1fa83bdba89d366cd78ebc66d2686a807de003b51b77c67aae028fbb2db66ac32facb4478fb7d64b88af1eac365af70f1b0c7bd366eba474aca920de2f46b5022fd787984d592cd082239f79b68ce0d858b8a2ee927acf445c06954d10d3e8d22b77420738c05bf5a7fe08a91f6e0ef0f6473b61c2d16901bb99d9ec2992b08ec6e6e1a8a343e67696d8451012fb807a595373f98c9d3a9eadb6dadefdcdc4a02fcfcb06d1267a1c4db63bdb17ef63ea4a0e3da409b3eb0f1284340d51571937d2527365679cb3d041fa1d9dd42c39b5a37cbbce316faf831e803149afebada8a732bdf979c3f2aa270b7b28404edc02a52df3a070af8857cf6d1af00ea9940749d8e12243db3c6e057030533a5f76d47cfabfe751e36c3aeccd084f1a27bf1c413514be43cfea4763391a3eb944bde44dae0dd3267e989bfab9538ae3d8826761783aef77e1b7bd24895c094f7438db1d6b04d6fbb29039cec5d5070a832c3e7ce9ccdb87c24161b9bb217760109e9763084fe5f32b76bc78a66161ef836e283f95b07270bd0c752475b018dacaf8c6b890489d30a5b0876cf28093d9febb0c555927b4b1d2180e59087e4b66c68e7e5600ea0c2d6ae7a3919832bf15e7c8bdb74690cb32352cd05f887f6a102264c81e4c4afce296279e1e4ae5f1420e0120764852389da011260c4f4c976e3022a35827949e0fdf3fa971077a51bbba73055387ebbb5377d51644e6fb4802ad5b478011de849ade6e39ad624e8d76e52305be7df44ffac18f0e7c6b02e1cff68f250352337321b69cef8d7eeecf51572ebdf1c9188a9bc3ad0c9c745c4787bb30e2193b3fa8c4be75b66d25c9302e1cdc17d678beb3675ef43ee39db6622fa97ba8b1d1eed53a9e5518a5eb890b15e1c213a7ba102f4226e9b279443eba3731f30401bdcd930c3af71ccd1d7a9ee35bb17e2a93dc44e69289372db8af404adf760d243deb4365b1acacda3feec3248972fcf144a36c9e9d4eb82bee246fe100a23bce7071d7e6543b9c683cf55c9090b85274cf5b0d16492be8e640410fe20594b0fbdd96d8e24164a5f7955bcb732a39abafdda38b42b3c7c6c914e439b2b588a25c544aeb2254268040a01bdff58d668a96d8dd9f769378697bc2ffdb8cd3271bf7740dbed14266788ddb578238bfef3e84dfee36e430417c0ed3a2543dd5d808555706be6ac63d6205c55ff5f005a86e896195a81479980f2e529b56616efd71d3033aa0d293b01f399165accd0ebaab9b417f1f289f23784a6d7dabb81b1ab6850a4bfb4f62a6f30712679ca319a8a2d716b42512046b13272ac1205cc8ba16fe353bff3e0fa2db41572ffebc5790de3458b10bba2ee2a8eb5fba0209e01aab294902531ff5752c8d599ab1b3271313d25e070d8741b4b05ef9a5b5c13b418521d133d34f4bdf0f801982e1dfe4934cda585e6ed3373e8aeae2fd5f9ed33650b46855b650a957f0364350daaa69115fc4a02fbaf0d65f5f5935622fa98060811198d104acf44c2b9824de3dbed0307ee0bcd99d545987801f4b59cd8df27df40adbbc9f4e746a8f2d9849a12712976e4aeb9efddc63e889242663ce2dd0cb8c1e6b519d01bf592830f967c690c3c83ab452d752c20e9ca41ed3768c7d873ffd0487f0a3d01fc1ebf1d1569c5d9fcee590da8d8d8141378583d2b7686f1636b3f6d3ee63414643815e9b7738db83c585ef8e5645d48aee3deb7a3b8e0b62b6050059d694f5d69f82adf5a13221348002f364b12bcd54cbf10016db6f04d827fbcc8e0ae75ce9d5962af809e72f8acf3ddff207e4f7d0bb72d31cd9b9ca77295639466c743fa167fa3ebb44ae4b5b6a13071357c31f3d217e3b80fb495c294bcb05a4b5406a2a84b4b57ed45b2712a254985eb6fc56b0686ebc4cd63778978997f959358e3c899df0028a92f5bb206af123447e33fe27b668e400d68f5c08c95124f0dcfa16fc6dc9403bfe7bf2e3ba123600f78c83ba3f588c2a0ec2b81384382fc1e02916ef34cc044796a00e365cc4bbc297fe030823931ece325d3ce02df6fef3cd7f1457aaec1b20a8c6281923c6f523b2227b4ad815e837c8a6af8bb9e8f351b40259e828e42a8fdf8252de6102b58a91eb1c4590a0db98390b8c11cb0c5597ea340cf8724d91e92ef142e82a959501fc44ed30b7df56863d0b79f9b781de12f38897c3e0af1ce4b10c1701fabae1eb46ac4192827059cfcb3f02264b4e0e99bb591b43ea37700b244e6ba93457baf93cb660f60817db308b3333da1c3b847266db27025ae2aae27d2e306565875a1b1bbb588dc4ded9cb284e68459de319d71f528b619bbb7ab3d4cc8e33b19e16a40f6c3c49e59002c64f63005c4e4da474fcac881ae913a93eb1ab7f8c809013a8dc6b847de4a01fee0b0650835adbc175c117729cbd9be4d68a7b6740a37fe090b527e0441a3de09a4de095d7420a9f68b326a6eed9a800f21677c7a8a35dcd34bfede72a5d4842177c95466d82bce05128f97c04bfc3bb18062f1ed5fa0de405b0097bcf83cd339897c32ad5a0124d0201bf6ccc17965325b36c7064e80772d078460bba98886ec7e55b6236248c79d34c00e42b7bd63417289f9016ad8edf8c8e1354c8956f67fc51d04942f9549942f46f77588433ab00c9ca5affb8cb13c951f896a6416a979088c508a3902464367e08c422f8b75eb7771faf7392b9ace245e27fc577517b8ffd427438fbf5bbf874f148262acebbf77a01ec0e0a36f271dd455c014bf569e98da3862af7a53a4a9bdc3a3a67c31a4901aa8d1e74780140fcb7a28d137717d4c3064b527ae919291a0d3910a77066c9a21dad234cf8b847a5eb203704af9508b31a4d52130a2ca352886e65632879521fc84313f31cd080c7e3d49ee04a4229a3cf184756183c2b77247e5ca901847b4318c728f1dc1c3c037bea1e2522864af254b1d22727d5a87507afcbae48b2d86609c87a3d948376e498567867a4417c90eda8b961fecf2a551776011860519dedf720037ebf5543380462f69f2347187ec1dce50f0c38c13eecd54893e9ad76b415cf3a629e299f7dbf41b9f5b2a6dfcda9da8356626ec9307054cb81070fa116a80ecb4540b989e79737ca71d7956aeaa3a7b13003bce22e94270e6a9a2d8085b00c3534e46927bd9b24ec48fcff550419fb2bf4a8a298e071b9df0b554564e3441a42584f71784aa09c2f00e6a565c1ff3a8a3e0124638d3a6357897390e8059afe69aa5f287d925e0fa154b2a17fbeba101df22d6e7d6727ec2bec5805707632e566bae5133d02bd9cf0e32977a6b7d3379499f5ed7b63a9f543b1f2963d5828871f535974ff09ba3f12bc48585201756170e47a40bb4a17eb645407efe30d5c1149588f8711a2caa2b7e046b0605725598ef6e61f2a79e90014d3b8b9d3f5eefe814c9bc75b17b37c58791cbdf8339f13f04b1327d208756e3e641444bb6505398a6dff2fe78d8aea397727bc628a3ea50ebe296affcee2dd33696b1b2ad1e0c749cbd5fa255591474489d02767332d9c59e9d99e23e5963f22184bae04fb49b1a355d0804a276409790b07c05f8a67aa5f047d8aa1b2f3eb6cae15371106905de96ef649ac55f0fa8f7da9e278c4b7e277a577679da632b53106c438cc2ae7bde597aba6d969937070b78a604251c964c0634888f7193cf05ef1c0e4f89a7f37c5985a261860abefce40a35fc01e623307fc8c468eb55b85c3466a3f97f4ce3e382dedb74c5e934ea37ec0278716dcf0741d0b8dd51d8f0740b8d2c16701cf2ce59ad46126ba2e77c23f09eec2c89221d783d8bc0cb63f068c6cd4295d5f5b4b093159962e1ef92bd26a8d5bbf5aa78a6fae9519f702f0424789ce8a783ed093cd6761a3e9206b9fc62c05de892fef123d950444cb3907160374693db4e6eb3eec5d4798c1ba38731fafd168bb20d635779069ea088e08d2c102da8b7612bcd253bd02a26ebbbfddbef1b1f348049ed4e4145dca56de6e43bba6eef414821286c241a763756136cf1d3cb095e2eb02787f7a2f0230a88ebbbe1dac3225666fdb918aef5284179f2096a35417ed203dda3150dc6e7a941db088edd3375f8f6e798a3e96a9d42408551875c984142cc9852803a537f98c61038fb827ecee8a676d5e8c9b0fb2e1cee44a3cb6f5934711b86a8cdcd59819a0d09812e31800335cc13315afe80fece1e44a6a002c3c732ff97366d6ab0a4c2cde4eeb2281cb03796947748ff5fac71348986eee26175af32b1fde4d44365fedcd5b2d43245ff47a2b28a73139ea94aecab875710e6b9af9c901a1c158dbbba8cf3357a79a474cfbb68bd0d695ca1d88571985ef6d53e4ac90ac13cdb397b6fdea0cd7de883e0411068d79780e957f59052b1cb919feff1335e7f803519b15779ecc5503fc8f62c50f37d603890eac9bda6b67f555eef2eb112096831d2b182a1007ab8c7b6cc13a37323364748fb35e2d9dc1ecc07b0af5ddb4f4065ffdbe65b13651b9981a4a340e6058e03b01afef36191200ca0a2d4b8c5c6ed79409f446430825d41c0a472626fd258c46b37ad10c32eda2c174ba3084771eb65b3b4d108ee5b1442c7def3315a61715098854a8d03a9f7b49d51d68c836c6ebf4d75bf795d99b712593a2d60eef89bcc09f65c0c3b7ea21483442f8a43649d71f018fe3c549d4bb6757d4559d8a0157369aa6aa670de999c87503f265c061d25a3c9221ce18fc5074bfe9b9cd6355a7a68ab588c392f6d2ee5db76c7afa9d2d0ca11471dc6a482dc6f4d09188826c33e041e48e97a5ad7e4821e7a1ef5eb3c98e9da8958d3658e5a40038413f960e85d3e96520706ef8b6b2027b9c0df5354fde4d396c0faefe15e21026146f35918977dc466f8e92be64ca882080e9a47e024d3899967162aa8a51a8b62f5b6ba6810de208f3010c0aa78e0899cf6ead8771b024b0163847b89db02233423e920398c8cbcf5f9ab8879","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
