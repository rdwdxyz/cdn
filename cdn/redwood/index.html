<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c9929727bf397786b927cdf35e204bfb0d9e033049e7f73d4b0678d3832042caa59d4230843034491394b379b769eeecd4848e0194971e06d5527eee5f120e9600ccb5216c485a198aac76dff8fc43b00e6e2c1cec89bdfa3961da3906ecdd58597471fb39bffa268fb3aa37a2ab7afbe2c4321cd8ccce32de1176fbcd102809d6f4128fce33cdd76b834a34a92963c67ae01c63b4bdcffb13759290932e6a477360167933697f03f0882a89ca176100239672f8da5c6258221f07dcc831689a4442e1c72e51d1dd3535ab8182f448b03116788ddbed20c1951545b13c7db44db84981c862c4e004aeae23d1650b97169a63d3bbc2f7e8df59414471cf25a59bca82b6898a68092563fea7461a1cd47a4d6fd13d9f5f7597e41d67378000e16416a3b126011ccd06d65e3c9f1607efe642e80c956ecc2de0f00387780117ab4140e8775c84b467aeb75a833a199e10dd5e1ee49f968f54f724e80a4203771740206d69ec4f3738386dd53dbb11fcd1c36c35639109bb5019132c8693c5e05b7fbaa2ebc276baacc75228b21da5e126e2e609e9c88edaf6af4beecbfccbd589b28bcf301fb40d501a7eee624ccb622eeac2ebb7bbfb34bdd8432b633d305c3da13caee86d0953ce9191a805895541620ec84a4a69f907eedafe9d46af0f60657a3c713ba7bad76e58c6dee46553bfeb09ea3cc0fdde26ef9b270537718650659697955edc028a1a15175d8c8a6551e682819cfc236614dae49d336a9ca8c1b01ab75b7e5d1e03559cff50ed0b4e9d6a5b12e77a18b3364ee7ee31bb7a3c86864ae39364b5a3a834a377dd3a5c08f8f61389d646282b3bd05ef06a443a1318748f44e2dd5d1db592d10c7ab903b130c56482418a64443da20edd990a4a2b2f81036680e569f375d7f2790fe6d05c36e570575d749ca0c1692b481ea542fa8b72de3c29a2be156320c4f96ce7bfe1dc620cbd6872717c1662ec791d3ee5084d9b2d44fc8aa1dfa75e88ec3336fe6b4e1473e687e9eaba536970cb9391f37e2c4c673a913771ef59eed3002aaaebcbffbe003beca875bcb0f84de02ee9884dfe844061e23bd4858693ef3667a629e0c140866cc7762df58f857085d03ff77ade455492c5bdc07849466f4888c149d66cb4f8a114a61000a33f5bc40e557d09be4d581a60c87e7a5c40728dc64e477e43e98e4da6434bf31935d9f90111f9ea15a0c4821fa9793c76a8d3b40eeb6f0074293187bce5bd358fe48335e3816be1ff4bb4e01cc9303adb874823c1103565641184ec789fbb7fc925ec436f8e845262e3aa2afdaee3f09d3cfb6f78026d460b70dc59313828b981fe75a7f1e2cd7d885e9f26dd281c414c54b83d85b8eb9a08eb73654a39001f4fb31459d70281097888110fdfc6ac6b30af816f56105c1d3fbbafb9b67767ceb6033a5a315568b91004c3a07bf4cd96c73867fb10a9a727245778ab2332efdba212e2649073827341fc7441a6319c28f45967fbfc5c3c935ecb0897136eac9cf104282634b07d7c31908ec739f095849db4261de93edc1d861a5019911af2aaa9bb38657c5e78698549ad4ee3236fd29ecf2f14a072bcb519f3ff06f9d7467c4a56a4760604470c9be619bfeaa596b0e4ac1da95f51539cac4b8e518a547efad104284fe3fe8b6ca1246ff57aca19b7833920b9c74bf5cf50bfee56a8b6bd2331faf99a7d59581ca9b188ac175ef324c918218627683d496a7097b976e3abf7cd43c88455eac14ed6c88af73cf2939202936060f65412704a772f206c345a11d116f04862c8f743f561391efc5b37450b0afafa1e9f7fa5af0ddcb0fee9c7c17f11aaf4353ea72bf1bc5c2ec3960b82d0e79b9373171c18103a676d935597ef8a845e291a20f83e776d1843e365179c015a9a6489a249a374d8dd2e31dfc389647c825f6a370d801a9b1aeee78be0bc59de6f9a39462654f68dec6540361ffb311b9b3a9b9c7f907ba326a6248d415ec04316cc0dc5a6915f87f9cf852b6fd2b4f918ad2bd10f9c68312ba735f3933d053a8c7d581e9ad87f99dd8e70490ae18ac9e2a0ca593a52e2a9cb47958460e58f7e64cefea779d2883b5ace7819d76dd27b229ecadda333eda542aed357fa22b6d9dfcc9f93aafda743f931db1db6c50588d698690ae762e1fd0bef16de7ecb6066812a169d574074bbb1d9c0aee20f5f15ce5f5d2e713a14efe89edbb7c5e1d83af545f12f49b7942723ca9abcc5813633fa000e3f7466bcb28acb28728dad4900e28f50013b5ee5d5e15edf5d2db40260f54fc44c6241c3f23f241d6ebca65b4621e32cdfca675a69637e84a06f10122f9f03dbf75e94f1903a062896caf89809e6f109b1a11b1f00bfbde983c5c046d7b24be8d58e7511cc99ffe68da6bd5edcaf4d581887224fed96d00a6663290532fbb3803d200301052a310c70d0f869a068e17c3c9aee5dc3d206c516f6e0dce6b2587ffabfc1a6681c1b4f78912a268187c3e6ddb4c35bc9348fd4eff55f995f06ff672e50935d95b1784c9ed2586aa4362159cdd8f900fbda670516496b16cc7e21f6a9da574848f1232489fcfd5eaecb5d4a66a82ae7150b30d4913477e8a76d97db2b969b23e453a659b8f7082f49e293e909e3223365b40092bdd0c42cd33cbb40167fc6dacf448159c0c7227b188c5dd80dce16258b0f20cf915a8cece5998bca7b3ff99b65fbf62bc0f57b813ab99f3920141c318345f9ba2ba4e8f228ede1262def1916d374d43ff5376bec090963f517b7877cabc964d4e65f1db92e245805756045eeb57c07060943f1949fa4f0b380be64725cc9bbc351b94367912558bb6818e043e99d2f9677f951b292f8ba7b032a043ef376e143dd29ed2ef0295d33797ada2cb70c2971b656384fd762cbeb2492a35506dd1bdb28a60438bd953eb08a71953c072046cd5555940b1a7edc21f678cabf59b5f41a2792384c0fce3eb974520b88306f854cba552123cc236b4deff95d73dcee0c11cf0f83b5d455fb6cf82f568a8624af6d27e0737e2c8948316870c2647ac57c86e2923a8fb1256ab77c354c760f0fa88a49e390a1ee6130d0a59a1374ed3a17040c99b50bfa7206a0c2901cb09f8fc776714b433a1f257ce7d8f291260c6567ee3ea678d59eff93fba0f841a7b15492da8a7e0ed0494ca83938e5fb264aa0e88bc09a04842aac6e64076af8ccd772592dd43cea18ba5eea394dcccf66679c218e26bcd9edc48c63b605040878c2e19bb5a9c88c14108e2b039f547d41d9d9bf95f67c841530ac4d16ab9275d292ace67357fea6efb9531b49bf1b690830f85a660be2ab475a02a4f77e37a4020465143decf4206010f99a952b29307a1e4e99165d49af22e07404b9fb468f4459e222f4ab57a128477981fd8e215b1f0af93c77ed9427259e41f14b38a20d3ec91cad5ff377c18d8c071c14f79a788514ccca6b01adfa61bb33124e918996e507ce7e5a65368d97c405280358f6d9dca30e6d69d31d392718f304c815ed34aefb377a10b2c2c7f662a35700f66fb541b11fa48d9cdc4b8179c83a63c4e547f1a771d8439021dbb9cd7f5ec1f94d185c4c730125ab4de34869f2eaa8392cedd4154b18cf978d92dcb7c60614fb222acd53653947de335902f77d962340af8889a599053dfb4e01463176aa7b80c1cd063f27988ac9e67bd983671a50990bb8b09307ee7b6e0a442d69b390db96d3610322326b5dc98a9226f052111adc1d8d9f254289f0b64a349a8b7b3b501f90749344badc0a6d096cc7eaf7fa87288506de2fb312d68464e14a07866c84b9840b834b59eec9deb1bec17d8b2eee4b446e7a251e1b76bed3c86bd6f1ebce0e8591531a7d36478b13084d7b551d2ea1975804cbe5e51546fe53e7bac5cdad0a4f4f5a80c2727b661d358bb98681d8e75263e53b64c0a724a169cfec85772ee22c25343499f3b444a3ee04b379e4ead9b475e7a6a14d2af4f1f5d8b4dee80c0d5191e03a49d4dc0f29b06a7033cf10fff4c2ddf44ee891ce86427b456e84bc894455f376db48dc3c41c27156df9bef8ef2839491eedf60909734924ab48e7506e41a73fe63455c2da64083737a365adb8b2767d463fc9fb3fac553f1548df09cfc6cd7b38822b50e5816010a9645be3f357c166645b2c15bdb464e4148e0cc54d660858c0ca2dee6bdeb5052eef3368981d27e640c37878825950aef7a9b9ec217dce4f86527b493d6f8c38c775980ce4dfcc85d8323894383ed435d6a583e794eb721fdaec97b12658bf0abd1c08774663fb53a3eec721bc4df18c3731dd3a74791a7edd625b367ed7e9179e05c17405312d45784bb4b9bf6e241dd80c6c785af377dc6c5fa2b7afc48f80c19b34be3b7e6c8933d9feb1f04b457d09dea88d8c0a2ea9bed8bbf456399c8f256c76f0e847c0521707325019324404095e3e215249038a3b9e1bcbeefa1e4afcd775bd9c75823c5cb2e1928651107ff0e450884bbe1263425724a76d6f7a177a2ad690065bed87b76071aea8b4ca2f462bdffd01054a2dd8ad80008aa10022b7dd402c4d0e468bf1709a6a4d2b98b7b64aa9e46be5e9a3e34eb834e11c481dd10369f508d3581e287931a23dab7ead84f0110e3213bfef63ddd8fa219d3e497976183728ad05cfffd518702d810e392e6e48802d8e7fda80a6a99cf04516f5c2fd6a1b91417e3b605e0ef8b74c6e591a068dd335cd2fb29392518b22a19598b6dbe1a0ad067ec010d84b0b6d8656fbe39279d1ba2200dfaf53e2f531971497259936e13bd43c9b1f807af5ffe601b0507890a73dc10ad78127203a6a83caed2b94b76b3c96eaad8d1990590902f2d3fa9370f58d72855e01679b1822b581836f5158b963aa78b6c420533a9b2342e0a13b172f6477fa177714112f7d0eb339ccc35d2a7f61daec042ed5ae6f935262bdb032d2181e9e3667a761d9dfb67988c8218df3ce04a321dd1465e7664b177e317b9b52f2571cdb4389a377134c13a96b813fe489e70abb2630853ed1ceaffd4344742d8d5644095ba8ff1c170059a33778cbaaac6d6383fe07673c1a29e9121ca8b1638ba6f605691834a6fdd802b8caed3536580f4e0b06a7f3f6a42c354e6a1ecb61f8a78dcde4d6593a7360cd6227b73096cc978cc43700382287dc0ced17ecd3fb22be2b29c90f199eef434271c85c9dd59995d2820c47ced63595735007a0d920614ea911439df3030446f169d5f371fbb431d2eafc619d7dfe6d86e24322f8c748e708acbb38c13d46c6a79014cc5c9e7246b61dd87b9cc1325ec9deb36d63d8250bb97e658fc52e4ad3a14ff6b063440e6d499d5ccbbc9904f9a260444724e91cfb39d276d4be5515837aa01ea39974e76e630f86fbb45f4feac9f6a7e28beb5ab3a6307aa37c3336df2fea5fe2eac67fd528673707d4b4543ecf7f3cba26a5dedab513b2a2b36fdfe8e1d22bbdba3b9d3877b9af7bf44cf77725d2886d8d6dcb55274f5bbb30123b797fe3f3776dcf425d157bc28b3f448bd2624adc687519c136f42f9105b99e245da2b501ab9ac98b2dd56e6f83975d920309e269874d5c2b046af3c3e0c9a05f987d6fa37ca6b03642dc5196331a8dc60656b701eabf66f5c40a067ea25b65945a77e244391f10951afca8c2ae5f4f9d57a27b309ff97ac138da17d6f0d861bd847e298528871e25eb9e966ecf603f33d679ab883ca6bc067dae08d5842ad06418cd5c274c6010cd63f8689a611ddc9a44727d182d8e85badbd6b853cb98f3f7704c23a5cc4b9fb53a533660ffcb38c44933c54e82e1c37360e6a9e05fdaa072048bf2c3f2765ec6d081bc37aa07293dea5de5b9a317c4a9d199ee533f76fd0031f0f9926999df63a01447a4190cc136b8dbc30a27d6ba7f0f7f8ff54329d4a985900e0a7900fe2d56b5d9ea8e2fcd6ffd9347b387ebb2d1a6a559dd7600595539af4ba1dca7c6b91edafd8eb7356dd48a635652cf7fa4e0408b1365fd10f2879110ac3f9a993dc5d91f6f4f7b5f654beedbd15c3e630239095dc944645cc3fdd8e9576d85d59130ca5da5895fc480fcbfb6212ec99a2b305ad268db13cb5a19f7cdf23fd1fd6cb65cd853e430de3a2e22c953f8546222366080923cbef4d444d48e1e2dff03b07714e874357d42ec6067827472ef749fd09bd1990a2faa8ee97260bca86dac2fc42305a77d235170483022ddb2db4d26158e631782e1a0a74478ac594a2095f9ee20cd8cd995f4b0f8f5bce2e5e3472b8e187724fa0a95fb9afef995b66c740e1a670c4ce5818c467f3a07dd8274c2f89e4d8af1dbebd61d62e8cda9250d4dad2158e7dfe327f430ba26d44f46c4116fdd2f84a9127fc53b796b32b83c1a45de61dbd0b8a454e4887dc27f4ac1d8fc61994e9b7b59986f477d3527786dd144fcdefeb00f20ef68ebaa4a7a7490aeecc57dfd6b0a573d342ebfa1b33d1b191b362cb7d1596809ceb5aa23ba2bffa4176a16ceb27ab33957460705ba7bb65e09e43238aeffff48868feda92e2af790fb91e4c4282dec895b94f60de10bc0eb7bff10278d9fd7d6286b2d350e90fa58df33bb2a51d7e4a3586bd4889749c972f73faafa942acdb328ab099ca37d20fc44f5f7ebc022006df7d35a0277d74c90e8176a78690fcff0429f7a3340b389ae55dd55c3629b09f6d51e727e9ac7c0ce49fc74b39ff5cbe19802f74df2aa8796a744745e2858062d6b7ad00b9e393f34a803f37c1ec04cc2bf9d9285fdc1fea73adaff7cd5b05f8842e71de6b9dd0bd8dc77d2c2ca91dc1a77246d15034d04b7540f99d3c6380c3852b5983a42eb512d47642245747bd0b5c3ddf3c96114d5032440a8541d01e30bc199fc5122ccdc174b042ea6a22766eb086f5b6abe930b2dba72f9c88cd5b152d6841c696c8bc41c543a4ba3b1fa8f474d89866068ff6e3fa7d48c9d6412a5c5e1d7c1567e3bc47d828b3daaf6f6bae25bb720cc06b24fced1c6d4767b9be9ed1d08db4e8edff8395c18128ee1215bca426b3538a762d94f75a5ca86aaf14905b51f2f55786b249ba88933fc8115866dcb636e48611ff0250c97e0a0221236f08b59753b8ceb88f674d57c5bce452dcf74b5b1c3a942c189fe76826ef8383b85ba21a24d5a59fa7e89f6437f4f3f1e428f6e6087b9ebed3573f01bd2145a24dbbae5db401db88216de1d5c243cf649ac6f6bb7e5543f0d27f4ddf6f7a79f06be654fc56339fe556e14a274fbd192c38d51e8121151f4eea60dace44bdf347b2c8a6d89a7ea15fe1eabdf36118e837bb61b3a19b7d0e572df0954efd34456a1902ad305e555964db4f57b59d04b56af45c8f1e7dceaaabe5d94297d2bc03319eb3d9fe132e607336e1a2ee69a85b8997316c367bcdcf6159de193c70bf937a195f08a53c69ace0269c11060db165060bd60408a265c753d3b9f222f34dcf4eac6562db540470325715c412a110629674fc098271c60da139c84d4436a0b04c4f85746b6d836b754b0e1e34248cc2b355b50cccfe60ffae8a79d0bd40bded2aa4166cbc27bae157c20880948ea13422ba899b1ad16e36edc13981900074130c00323a716634967693c296584228f1e0c200ccc43353a88333252c7990f4bdb2b560492f17eb500039047bd833c274b6689c921052bbd2258b0b66494eb5905bc136c3a40b697f8920d127847bfda73967af0c24dc28f808e1b281b457dc86898ef009651a70ca7792283dd5dec18bbceb9a9c4d61b3e7e6096a7eb2d069d944968099a30d0410754e600839606a97fa3006cc862d17b807dee603a3ee94b81562a1083175ad813569e13337b7d1e7dfb3abb7ef65364dd546173fddb66f7d1ccb99a36d7d974bb1bca0fce2a4a9489e770813c0fef1a9887bb4449580c7e0accd5a5c0d8fd475108f5f529e84ef8eef50d920a6060f82d4c23a32839c73d02a8aea8d333df8775d50a92a3ada517585cced57c625ebab5186d266f4b1d38936dc655149dce72a65a720159a5e3b4838b36bd4ec3507e9b6253398b4bb9c8b621d711ea7cddb6cf0f198e4b64e7eb0fe2d795cc3f048121d0c24dc5e0df178dccaa54e0d56b98ff435c7fd5438d87b5743cf717b5647b5c44d4161d81d82c51952114cce0ffa18c7656f7d8658a67a3529b0ec21137986ae86846270c47c5e60c6459fffd01aac81a25afa7f287529d82bb16c192a28c078109e7008eb37579c34d676c7332879ec8703421bc2b8df62dbb4743ee65ff746debdad0d70d3891574978a3839fbc667e5377fc044b4fdfd200a53c5ec6be13ed08e86edfa5267e3b039c3204190bea3dbd2e8ba9d4e0a786dd066d936f6990f72f63e300e9202fed23614789c1896ea75e1b92e899ecd2a5e9c597def9914f0011af0c1041682c7ae91b64d802ff65b4e927388a2931b33acc29f5c4366fa464189cde75ea0bfc056bade7a4328b79f12b73d7feb5bf76b82f08cf575e3d1b6ea4fe3e69a94590425ecbc6c06fc89a860a34829b2d5b2bbc1fe1495b2349c8be7644962bd8de4f6418af1fc00326d02a2ee198f42c04848ade8c7d3868687761cce71a57b10e98af2b08374fd13cc6e0e3c35f9d36559abf2c6c68e90c7f141e115dac34b83193fba0185440c84b5000b06ff486bf87b529a76eb87ff839e1a74eeecef5c18984826f7e95b17232eb5d6bc5f9a7cddc035821a0adb6a550b30c941c0f181b249ebdb982c253febf546ecb9164ca1f9e2d64455baaea3ecbdcbd276dc06cf712c6e7c80de3412b7e39708fe29f4504ec0e5f49ada5dc777ac56ba8fd3cef20dfe656b91f92def406eadfafb5ad8783184749992f65fdc10949d070d28f904825fc90ef0c3dfa5868940e43da2b05c617b5a7a92a09f897a6a19d89ce22a9a58c84fe284f0457abb195b5931f94445cebd0fb15a0100dbb71211195dd05911cff42a104730de9843de00e9e1a57a94c77b3d8211546fbb5a69c7edb6ef71a066cdbf1fc25b7ead7a9d5b41419d73f0318fc49d0d31255e0d49c2fe8d7f5dafa79f4e046e87bd905f155285e67c79b2f30ffd38380deedd89353003b2cb577a3067ee86476cd9af20d5b15147b8d029fb502c34bf1252b2d0745fac0cb44f3c8299a131f674a1a87a163b01b1d44c6949b3b2e1e16d4a74e65be5dc0b2688437c75dcb50649c044d457b795cd9b6d4ac44839cc78b94c44e1bcb2701f8c453f0d6f5b887d6d0ae73f8c16e491ba6448ee44c02cdcdbabfd23d0bcb7e2282fb5cb2e6d8096495708af692abe69fc7413fca648e3cef38f08f5436764da044d33fde0f0e946a1cfebac9d97af5addc7a90e71b9bad0cec76a0ccac99a04bf3d63d752bf37c7b1d4630da6660eebec09021c20e82db91d885cf4383a0fa201e06590c280c77d3026b7067d929b6fff18e36ca708a8904a2fd3ab0c8f2b0cfbea96b51a05bf5c80803acbe01a1c5e0976a85f90d31d253f8feafbb498d595dd2592a9dc5fa3e3b4bd88bd6a0e77b26fa6d8d23d6e96875b618f11c098c6828d6dca973c27526ba5b7972ac471f7e3324d0d973cb2dab43dc477f77786191aa14e55f340bb81c7bf945eb4727e7b2279227a8812b71a7de037917f26d7fe61867fa560db9984b1337947fb3ecd692f74bf95a80a25caccc3d841b8ad4c3d9f3b841ad3db4707b9b6a3b84b9d98584a7e94d6ddcb1b758904e78fe3eb871cc79e0fea76a1baf01fda2dc8218299922bac1d4f38cd4e7e60447ddb5c0b5ecbbe9d9ae84c85f5ddcd0af8252545132a2b7ad2998db004d3a366016d1caa47ccf219e15fc9e627e8e42f93c45f16a9305e4a8c1a1c86272a286c6a1fcc88d5707ca83f722379a09df88e196db18505f7d6c0efda094a5f678f00f4f1f63e9fd4db1d130aed657516daf615ab3097a668b68d570828af7e545ac95744372dff5958087665639c0e2e7291e5a53c8d9eb93a5fa779eaf79cb49a6f07c871fc4d2b9f129c64d8e04cde5cc3cd01976de2e3db9a4750443c2d461a0b864f7fb7084ec8faa2b5deebc243a25e393b8bd7b7a903f7c1ca478d2f46aaef64751a51ea8957ec35d9c369c1b4c3afde8077675f9a88a12dbdcbf57ec5288d1a1912da1086ab156f7456c253e59ef54f0e7704573d07dd2a2895a0d13893c5cf11d9444e78e0d71929791437f65af3dee73bcc6136e3f8732b150da6de8ef5b15c2ac2d5ca83cf430d6aaa7cc3c63f3d87193371972a0c8ac4df3d6d1a111799e313cefe080e443781ff923398b29f18b90f9bc78c065b4b55bb076926ea913820a697eb00154e00a17dbde31b48041f0fd3562a7744dc2762c6627093ff30a3c91f770c0a7366605d753d2cff4576d5dfde229f6325c537b8cbaef1328ec593a9171989c2ed4158fd46fb3d7bce6423afacfc17f45e7f56b350f1966c499b56dc8ecda91d54aac8bed1efaea568172391e1797b63db1acbc3dceef5e6e50f8e0fee14790c23ea75b491211a6f27990ba71b5213d4d868123c952be2eec15775785e6eeac400c0e1964a3be3bb6906a6cc52e5fed7f547e42863679fa6297b6e6e5a7f9f7226ed606a022e3deb4320fbf43300da7ad569010001f92e4f3768f3fa7f14ee36f7591687b6da02360ec7c9d46cdfae01705849d9e0fb10d8b487b887e4aaad0dc6538ec3e08f4f6c39301aff31cf3bfcbc611e889b28da41eb8a8f869da16ec299e7a8977fe5744d3bfcc58a775e8b922355d4539d2fad8569fbbbbb19c3f4bb17cf912a3cb8bbac81390d05db8789a4a05045eca5188aaa111946fecfb738ae19c91691ac4c30a26024082e4dce468c6c936c5431c42587fb18086fdb3997cc401ebef20d649f01784b440e7e3ba484ce1a9c7174595909515129e8bef5bdcdb750907603f4202f8c22c449a5b459955cc41b4499aca68e95a7fac736821ebd60bc07831064238d47651eb48357a2afb3253572d20d98253106ac0fe7df412cefe3ccaa69c74a2d2eee240cad53d43bb64260a87b5392fcefc047b8f200224bc0f41e65dca7c070f077ec98b9f5059802a21966bc0cacb5650bfaaab496caf650c30d4974c8273b3f61213fb475523c6abfa023367e17f3fa13daaf199a3ef8c5d8fdbf44127e116a5232ce107a01694bd81bd00ed6642bb732897386726cd373a98157a95a95e1b62df98334721704a8e167f82716d261676b07f2907c0a57805cb41758795c693c41f695257e75a9fb83e5b8bb6fcc5e6a166d04c5a98a2bc3c59187cc37064bf73ff732f1905f835c9e59c53dcce69459bc0d63d3a68ddfd4d957a5d54c43275b414233d0108da519d7d8f19368702f3feda6b9e218ea6e027c2980ea4837bd4850564ed930ad6e96e57845ae882105c2fb1ff5e9e84479067a7f458b6c522f4d8a25704140f22551fb31ae57140819aadc2c225aa27754912816f5f4d087d6c934cce14371b542d94a2eac8e55faa5a1f019bda68363abf8c5e7b45955abb3215d6891dcf20adb1db64331615efe1b37982b841f800303e5f08380f7ac4698c74ecb246e54635130d3fee868082fa7f43e342435d0884b81a0369dcfcdcd1cfdd3077b6d6eac7a311624eaeddc72fb63ed9ffc94a28a9abfbdfa69bfd4d731fa53535dee26dad9b6d965a0f762946dbacdf0012d7f814070cf7762e7ff5960aeb081a9cdfc0dd18f8d16b461080b30ba9942313dbd6439a464e2d1cdd416f23b326af06ad6709f5b6f587756df82e9fb87cf8f58215af6fdfa279f15d9bf50d86786056efa26406dd519948b8efd1a31853bb66620706707e1fd5182c9e5c2ac8faedacca4b3f0d978669991434a8b3586e8aa05486d214ee1a941f497313d7251d27de12889c71c2f2a006dd2fe4a8c364b66877c2ef21d22a321165c8bbb0e0a4efcb454e435403df55a83ed07d31d316d92753d245acf600379bebba72723f530c045e66c124ff0e5cff8348d81e1d0d0c49f1876515cfea2bbe8e0dbf2ca3b7e386dcdbf9913b57e3d9412a5a0c5aaeefdc835e5c82300b03bf383dd4717e9f3f11469b43c56f932e4b4ff3d07302abfcb276b335af68b9bd1705544e75981d6f6e8f25b463fa1e277578376c74fb4fdfeec678057f59f9bfa22a1a3b5e72d36e0f2d9ac489ec148228c020998c6b1a51e5e074076bee3615d0f841b890f679f8729610639a05ea1da777b0c0cd3f2a951679ca8212188eb627d24cac95fe8f9422bd76ed5c1848a10254c92c89a300dec06606f94fe339d4035e1ea2e100d6c0c5df008d91e110a9729b43f59892417f212495c0772f08a1e3a915dce5e54551de2d462ee41fc44dce2359bbc16aad4fe0894b026f937ca2745637bb44bfd30f10e4cb1c369ee7dab977697004368d9c7760b9b037176ea63c251b8461469430330b1f096bfd099f9dab3b87bb84c442328a7c3d1b5a5338a77d969ce75ef02ceac09010024d6521e2be624bccbb1ab8a2d245674c390e4d475419bd6b445ba5b8a725e2f9371bdb3bb2f4831da7ce9461fc3063a10299576eb084fc5f2b386e29de934157501268284ed786e9cea277afebbb98cda61dff82ebd734dd2de1382346c524542fa67ce90cf69e8c8084540ad177f57414208bdcd76fc2f11e56d32bd4618868900f77d1db7a7b54b590d0268cbf10cd3fb6bdaab63c2abc4a3a74819a96269854a8d2fd585145c45b02a638ecc6e6afb7179c5eb26ddbcadd0e583619805c25ed0dc7121c18ee57ae230e5337ee96b254b4ba92cbaeea51f841f7b252f858e9ccda3ea13a8f6d28d1763305a8887fabbd9fc70464186fa8e1375a368cb66e319e6c5297911551080e54389bf038fdcd3d523a734ebaad55a4e97f4dfadcc1bf9b8b61f5de29395bc2e0d5d5463cf1b8b6bf6e50084d9c5e041c68b42ff9f318351ca3d513ec3d16a152513c423e51683fc0036ec74cd96fd2fa1a9e6cb8c9f34747afae60da28741aeba0c2fce64f52a8df8f5252f1acc769ae36b716e2a500faf09d9ecd067ae72bf925a8fabe5f8869f38c0feeb16d8ffbfe6a34874e39c94c8930395fa41fc3b48e64c14e50db98199f6e61d035bef8fe2aa54a7629e17463a34d8eb59f351880289c5d3f76e3b8885c1fabafaf8f4cca83c3913559e8c7cd50f4eb3d53f8d377ccb3774781bb40518fb198f92fe6863a9dbd23c7186f5023bb0907763cf90753e709a407f6a067551e5e19190c5c823f69059ede64d7f822d7c75730a574a88d5713667ca7886bdb2f6bbd184d4a96ed8117dec9b31c9650a130f5e6deba49369dcec2a8d2fd79df6711dacf8e1a9c5773bc8955bbf658421f13237426f52e225b633d4682d86f7d2c36ccf7a2f7915c9ee087aa2ad7a62a3374a009898b39991c58e7c9d5a6c4a6b6df3704a52ed8574427559623d529221c44c5e75f79d7cbbba9f555a9faa949e54f68906e82b3ce4a423aaa9ae07497a788b0769ffed91dbf1cbeef053ff755494faf44c09130b92a4413ed24a7846c9abc6cf0e0bcacdecf17d58effadaa68852a40f6586e2d8c9c072d56373eca1dd9aa5365ca751f05f6335b94a32a8586ae7664d8c2ecf0092f1cd8d0cb8727732c79c43b96d52c507bd0d533050812013713ff350fdb3b0604a0fc309aed1c285763019c31c60e024cd08bc4793008849c61a824f1f09418cd38d51753a7c9f2c2bcf586f5e2a4bd5a1510fd484a27699c1c95328b5435cbe6788d946232848a3fa92abdfe508b78a0b71fcacb0af889a160255b34d4566a6457f4381d0329bafc5af4ec30b14b941bd0cf253e275ad5a6dfb615222922de613a3711e481da32982b6fb4aba73700d453352ac20c570809788e9d711c420acd6ce375d7d94a15d0d547435558e4cea6d9a772ad94ecfac081dc81b2853897fa23d8f8084e5f39af5c000f62552c56f4a3f8e88949c0e21ab5a0e563bb46086197741e82621daaa56e6314cb89319a5222132a33d85998f73cf8f2b6e62d19e3d6955492a0e91653b50f269eec96437d4a5658f9f7d6995a14fcaac8fa7db51531715bb8588cebb7a38b06a1e0b5a652a938a70eb0dea19be5a5f3e86c5a33e282b85d5ec2b5c13190b8777b3722a47a05c9bdf03e34d61bf026779d117da867338d59d77fa91a44eaae693e7567b6d26a985dee07f24c8d376a8a2bc41a32dfb5ecad89c13b363b34ef69b1da53ae850663f38f3f135f69ec8e190e614c3d895d60e21af323553a1fd1412fdd0c19c732a860e4794af517ce7885b118db4541a96073ebfa71f497d3de3ef314d09493e28a78be812bfe3b553daf6595b0c1928aff3b1f2f6a71ba3c62f7bb391a7c1ce3a41fa41451c8d2db7c0f957af4e8e286cac4146c88a3dd753fb48e992a642605de6e2dede7128f7b561fec4f941b4a81eb902cfeadaf8be03450cdca6ef6322ae1017ae6573318dd050be36a3c8c0f31a8fcadaeb239427c51bc5fd009bc65f606d8697a3720505fba28e1e3b518635c72bc436e4323514e9b5b92e8d2ee0775aeabb539aac0c91490cbc27f32acfb747eeb2047bb69f6c92fe88b222bbe1fa6c1e716fff1f65007877f91f6d8fa0caf5d2bc783bade007128f871b59c398adf0949357fd5e1ff0ceb740e73fa54ada25bf4c91f7b1cbb147d8d8ef2edf12a6a60ce2ec8aa928a5ad3581e95e0fba1c4d42c73a0930ef64063e95be41795fb81e03748eb03c861ef72369b958e884f71ccf7eab6d138af5459ad966c615f6712446b9726bb6b7c9de7bec7b207657143286dcaf73e2d1d9319ee7098397cabf3f43a5badb48c85557127be16093b5dcc24bddddf051bb933459b7a0ff3d4d2c5cab494975fc59da4d73a6bbd4fdc4dc31b01fadc7af71ffe29d0b907c3e9db463e49a132f7cbc5302a61fe3ec1e51a2918c7e3dcaa8f1bb43ee3498acdfe3b6ea437c8185a649633bc8305e93fe76b66d9ed6884fef5729afceadf4a84452c9be71c642fda5d25bf7501b72aaf1728b923529c80d655347144f3235e47b626e5c6bf111aea3f8174f985b4a828e146df03a6d09d5b011e0f419fae4475dab7483e521d05c62e4d3f1e94d1712d12d62147186495e778d2cd5a3c79d99dc43a34cf0bf0c68cf3480097041e44d0d7f7965e9c225fa62ad5c4654c9654f6ae4bdbdda9f31f087d6818ba135f388ea195875de6d5989fa3471b0f8527eb698259d5042280f475c6f55581d02bae3af35875b9ac6e6b21811552bb89cdc74be20f7dd3853cb4468b584ffd3da25fdbafabe6587be8b0ff5bc8ed07ae8cd17d1933cfd0704484a740368c4ac2c59c08406126ebc6140e5cefdfc2ace0f37775c246d942787d3cf1d3238caf11e9a9c7260f6782122d8790defd6b80c8d5f9e709ae70a182e7fb890e4dbd5c09933b9c3a989f98a995ed17edc4db8dad31e48c7b08722490ac4ab412b5508d006d10e2fcd46c46cf85f98d8cdb014bbf37552194f3bf2141c594a36cd65020a629cc551c789ca69094726af47741ad641a203d1531ce46db91ad29ead70aaad28e8c59dcb426d66f660b9f2968eb03c07c5b59bfbede73ff26f6627b111f41dbfa464fd970e44f40a6fd893db9661f510e9acfc286cac89abc47ef213a4c36410b3bacf0b69c7a7dac957e9b5125fe4bccf377417c0b4fe32288726e4bbf5023d8a723311eee5a105354d40683adbfbcf64441427d07a097ed18b68df1a1e59ae962c2c6ab150177b19b9d28f7f48576513292169fbc1770abf6e730998e3333ea7f23b40c00bf349884c4ef6aa53de0e96afae003ed8dbbb55d3c383b5a672ef5e2bdfcc8b2f60324fd67187fd56ae7c5b7a36612051062a4ee561e94d4d91aaeaece88bee3c140d8c0c7ee2752e428a3088bc2b3422a6875737d6eedc4a19b585c1c173b9c2b0fee08f2935a5fc290eeb066e8507271ffa383d0640a337e5893b9fbe24b364b12b8eab4434869bf245f4f42d9f729ffbd895bcdfe697ce4e3f39f991f8543860385bfb8d7b6575b95f627e8a7194512928bfbba9e5d5e134af27b4e7c1d3def4068be97c0bc4f77a51b32183cb0329f04c479ebbc9dd2043a90e566c1a998e3405af907c682147500fd6d5741a2b207c05479baf4ccfcc67a7c4f763226830fa4dfa059dadc8a3a4ce6cba0cc9d5aa07f03373cf0759f89cc03fff7589e423ffe292341a920d6ec624074ea012d9e8b94c31d98f68671560f47991dbc14d7e5411d09f31df7181fe758501f76fd718f993b4af12d163f6b2ef6361377c41a090493303fa64ee87202c4163a85b8a2ff952f1f1e17438e8f6871daec74e856ff0b05fdbca2369686d3284b09658d68ec3d5140153fa3b1ec6ba1e9db38e150e7c2e43327346c78df68a026d3495bac29ec919e8561f32cadc8371bb8fa78de488d1150a306a10403868140e675a6f61833c14f717ffe77fcee67ac253b14ac159878b82ad370f13780f9fe9ae73c339bfd47caaeb1ab484a00b5f896335d1c667925c35a9a2328bbfac18b7d2244ac124f82dd8b91bf6c88f56fb0f1815af9fbfc558d8604d02442e972135f56bd128331873fa91058de1d23834e13206beb946d4594ffa17d0c4116415c34b8d8d4a6bd87662627f5a649392b8fe5dc8d706fe17ee7fa93b374413c6e7d49f3495b5419d9cf45706d10f36447fc37576957483ff3ad592be14609dcf5c6e63b88b72ea31890e8c6e102bebc85d493bb2c7f58e727b65f6a13f6476818fb8b91c0dc54d09405f23056b500b88cb6fc44fe988bcdc52c3339c3b2b50586dfcc2588445d7f430527b1d603d02163a8fb1ce9158a6d75404a214b59dce87e0ea072a99733e6ec036a4b6ee5ef99613f88a8b86ed2a06d95a6f4f60071ed650999f346152a288446dbda2c248ac686fd2ea3ac86765e7e33f313af8f37c9b4c02dff606c56c5c88bd8cf9037b4a8f45db1d596dad8aad29cd1539e48ed8149ae15c9b147fbf34cc8828a2ab3e954bfb8dfbc97cf62b7fbaaa9817bb6708a27746c4419ed5b47ed2f0053c51b6ecbe21df83e8123a5e712ec551b056a747f706e434b79db974f5d3a0be237217dfb06a49f4e3192ee020fb32a87bcdd9807d58859e6a8e540635e3acd3cc1163935f4433dc60e207fbefaba4e36c3caeffdbd3cc6cdac5b582ce63d60b98c68ba337823c0b5fd441d7512ed6c8dcce6a09ccf0b443b85d99550d40ff9212339faf8338a5e653f13d49206b49c6ef574a90c026ea822a0e93b49527457050001a5c0790dad03a1928d7dd78221246384a4db77e3f86fa8f1038bf14e96a8a2ece8868dc3b2ba479a0238a717b793e213fa429aef2ab7ecaf4f39fa3e299f400447c3410fdad3a72cbab63c4091bf6b586345ce52d7a13da79ae43f7063af016ef518b1fda56c3808ddddb2c131b69abc7bbef94c1496c4111e4b04274e25d1a9471e5868bf9f9e60957e6aced32895835c797fc14a3bec8bda73169f40b1e8c5919d4f4155e58fbda441f3589b74446756b94896b1920304498da3f712cc321de179a7dabe65cb6aac667faf3bc61727c6d594894d30d34ca21ca5bdbb071bc75c0065bcad1465ba0804ea360766be0b6a445362ff8e1564ab9f030da0673caeab6795ef731bbbafa00b2a0bb50aba5fcf3b51a8557bf37604504db93d079d005a36b4bf04b174270cdfc2e6497b18c26aadec1f5a2046ee4d9f54b3a711c1ebcd9626782821ed0ee8e93317a8204947ac0f1da50bb738a735e5f3e8dc0b2430ca2b61dde27acc47f3e9628f93b0ef127092295c22eac8b2bdaa33dce322935734bfd1cdff4f2ecbd48ad9da96a78d478462a81197b5fc07c07b77181ed54776a0be661f664232d084651a0c9edd422b49449622164078117159036a0f7792b993ceb33963d22fe680fbfa31c4914e5ec86025e832d754b33fc15c67837634100bcdfd04c7162febc7837422d004192d68eb75e573c216f7a28aeaeb56580c1936fda66fb4ae0fd30947e26a79e118caaaa68f345d7ee5f1114b71ef4c1ce7316f3189c23b501ce2dce1b47c78881903bf77cd7f6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
