<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a615ceef800d03b2d4ac08b9a99ba5f3a46dc059cd4da13b38fcecf4bee71b8f43dfbd211f05c7b69534ff25934b99ebdcc82519f42e077c432009679f93e21d1793a5372002c198dabaf383cd9f3e580a216ed21be36181a584f80cd16a823609d881e4223d5f673aefb291cdf5e5a208dfc145ea09df2f44564ca0915d92944ee0920babd6f1c0ff78d3b7770ddf2687c0f6f7d9befd191d41da4ff5148f41b433e220ea629a25db491ebd16bab33d744000d18f96917f3d23f4832a4a11a169d0a0db8749e195a3608cfb06b734d310aa72a22b7cec3590e88416a72108b57543525ee8599a4442e4f7162c78cf2926738e0c831a38bce0eea04543598512d4fb3a4bcfb574b369812d65c63436cba7d3fdc398579191ffaba35657f764d7ace5295e4f1ab012753896626f94e5c2330b43cbaad3f6fd0c118f5cd27573252cf7f12d7831704b4137b811d5f44828f2949febccb2a634c2afca5526969db7a2498283ab7890b94ee8b244bdfc5a639f442e2c5da00a69b38ad44a4154b39e40d6b64a26de99de973f25bb015f6e4af4b5bce82c087f8f6660f58c8d40c7891f516393695a8d36bf48b1cebeb74452c1cdbc1b13f5847af3294d7268012d5a1e7f6d9292aeeff8a7f48933f4e20cb91b0724a6ce42ba6ad8f363ff3f3df62d19384ecc595278c3079dc32cfd526cb88c4a884225c36107ba51ddf04a27f2608fd2eb774e5bd70ad943bd19edafbd7c78697474136b3adc24057247b03ea217d01bceb74895fe22dea105d3d6d4d92b7457b530d45bf360cf562a6f97ad7b31f214871bb4be87742d07aae60a20cf4422f634884d0eeffd94d92216fbe3e9513b70399cabaa0d069a4026d5b67825a7ea441811704e1106fcbab992be9a580da49008c29bb507193b4febe531e39c9c7a1b6eb2eff7ec9a014343968c62141b400a158e30ab7a3ded5587fd3a51d79d1936971dc0fdc6704aa465c7089215460ec1f7c882f168e99810bf8be9368e4dcec55aa905f37918abe04ff974783956956669d28bcdb21a8bda139d6470ad33a191fd3f245f65827fb2daaaa57d6887f22df2633e85b4071744b3073232fb7ad7f35a595d60c7d4ef2691c28c1ff59c493de096e68a4a81614f241628493b6c83a0850e27183ba76742d4f4b9ff7805e5613ff1415ff0f49ac7abaa3cacb9cd63c8ea107c24845e14f1cb3a0f0c99c5ae2586f4f119b9aa4cac5d26366a4be1f802bedf2caec5e499c8a581601246f1493b3f9b8a0b7f5a8a2f32ebf0291facd27c36ed4b6fe1726c0573c643aca6977ce15a3a2b494574f0e23d1a3f33b559f37781455195ff6933d9a947bd5d9d0b823a063082cf536cbe621586d6c1b04adebd6ae563b57c1aeb1230df26042fcfb0d25f3dde06b34e46750cd7b95370ecb9b6c5cd9f45d02c647f429d7f5c3799e79d8c7913106bc1dd143fd3a641ac1ea708b3ab00334135abb4ff04d1f57e1b6563019f4228fd74f2ab2667d8cecd92ee5fe17619fd825b5b2eb99c11e7827e5dd1d7fbe95bbead51b7223d2daf8b072b50a7820854f4da0774bcfebaa90bff8b1d69a24cc8ea60601839df03dbfca49e4ad80179930c77ac0c2a941e8b6c3f831ba9cd2bfb3f70edf480f8144ea0233143491dce19c6a669bad1b96c025b14a9ce1b66b572664c949ba843313e760b0f19112560767c1ca0ada6987d0ef1b40bbbecca63c54dbd75a25109ba631d7e8a922e2183276f552926b294538a223dcc9aedd65594bf7cb77f9e0f2ee927f2683493182c47644dbf2ee8a7eafc92e7d88da34dc0821d6cd8219b72112c71cc3f4120cfa2b7ba3800b91032fec3fa8ccac628ad95acf848366076850be96713b79a912408a2cf49c90b61a8db8ea22283adc96e98f466dda57497f57de0982c795528d4c531dbe633d33a1fa8b85b7a8fb3f689ef0ca80484ac20b761cd07a9ba799636cbd04df99ca921863b0466fab56f8c4290edf4901cb237c742affb809eb7e2687f530d91f0d722e78c5a881ec71de9ee852cdb130bccafb713ec66503cf74c6dd056a0bff5500e467233e2a483c4bad39655f2e16134443cf3abc6315857b789da6968b7b66bee6aa9a5b9bfbf211118d6228a05785781e2ea9fb104af20dff67bd928342a307ebb1294f7f6d1b5e92393415d3805c77a5593687e2bad8149e903770d0b233ab06e2868a2bbd1566282210a0c797de512c75ba72e059e9f7f45b3678006f837ad6df3ab24468e3aeab78b4b13f4737ade649686ab1a0bc48e232c7116b58c5bacbb345f5eafc191c9c2b03d5fcfed6b1ebf9c17a03bd351e80f0a7a70733d4e4c56a5b87e41c13a66d43efccda2a995eb01c523d05e4805f584c16eeea48be3d12f86885d1e3662e83aa2eee1e59e9bf14cbf80c03e5d6891a98b1014eedce1af9cdeb6865cafd0128e3a27f6ff694e24e51dc0e8dd0a2a911804d61b4c1ae2d34a362d50ec2a7dab36d7028a6e518a2ba91f03a6dca012c7dd0aa52e3122262171858b86537b3f303cc25fee7be816cdfc3ec217514f8e51c4fa5be5ff3e6d9f49af4c1fe9d6f9fa85150f140f7b601d1c957dbaf86b0caddaa573e8e51a864e7a0de5e2f2a56bca34d0a782a25e41f39bc5b9cbc49b7559060bc42ffb76815e7455680209ea78b724e8b709b4c26ab79ec0b7cc00d3652c454452be92b9c7d16e52d7fb8f4205ef2a87dc9961c57fe5d5c984db9a40733f20878d7da176d3cffec41538fb6555509a7c913f096db0e831d3624cd28a8d577a57643b3e145a2b8911e5738b04cb68fd28485de79ad307ad42488a056b74fdd524d518ef0851dbbabc94d0fb8e689e895b1a563d866df8a6a9fbdbcc374dc6348a9781f7143d29289194b6f60e88fbe23d43c87e256191e957e12e8835b9f3e025a4a4f07c02c2e0d674784f44668531b6cdb0cf88b638e4fd0eeb01d1ca9771200fbc1647f62fe5f4e23f4f82af7c86c5a2f3cb99f48a522bf54f766d5614fb3bd608b48b7955c4f9870d79eb0ba2f482ba53449b3d42c5a06a14f130b0635298ee8ca7bed9e6ab69644c9a31a4b2bf144f3adc0e1ff9a8ba2aba00b1e0fe54fd22ac83598139d7a87d554d59c8608aa9ce72fd197652f1451968083d24cfbb118c2ed519b2865ca5ec486fa1f2717ead6fea796c2f5a3fd1a384e8cd4c309301458a804a8ad634840a0d4eb1510b53949082fc9695ec5fdbf47f8f8a4db1d303b602f244cf430944885a2569a49c9cff9378314af3f7ad4d93d133b87ae3b3e450460ab61895743dddce610224aba5202331ca23fb87e8cc96abcb5be198cd9bb0b34c19bb23e01644685195a49db40941f65ed2bc9aa240cf8df6f2eaa8c31ec61d5da833a6b7b29b23ff8196c0a336e4acda70c869222667c35bc37bb7e596c98e92744b62ab8538db18df98ecc939a832f3a0180cb928a4822f587613bc6f4ca232a5e68cb5242545ddfaf5d9c0bab810a1773856144f0d3ad263e114cb34eb1d0f48edfc189b74f9bc4c866cde17ae668c81c9d2940072928b429c81b5f6c8949bd23b2807eaf9a44efb0eadf98a6769c86b09bc86f3dcf58a446882d8a10e4b22b991cd055d29be3472091deaa629d448851e1283a0095ba7429d9eaaf38dd5a83755a6f82b913bd1757bc5c7a394ac9135144a37e35054c60fc8f8063b846c411da2106a1f2d0ae7b0f4301b7bb8083e93dd12bab45361c5773409cc9c2ba7fb1b90c8d65e59b203763861682dc9163bb2c0d78ada881bcb842004112d6ac99f7ed533cef5f19b64399e2d48f6ed8fd4c97ec6e8fd938d91f099177b36741466936740512ffce9441fcc0c410f809f5a9312bea2cc28f88868b30b6855e9765abc8bd7bf9b0224716225475e5b131e417ba12415f069fe870fd089a9d00118d0875235f59a652554b676c22f5bad90b22bb8fda8cc3856f5546d3f0528b8199fbe7a3c08035c7803acdbefd7015ed0009f9fda104a6178c8be26b2c9c1af5a017af3d3459e3a81f1f37dd71b5e1af8f4a79feee6de5286f9fc029bd9e0835f258f9eaccfe861246ede02ba8f73cb28b7269e583feca59a645c7aa81c497feb72575a3166ecb023e19313713eb5610da13923bbc9f0d8f252c2b1efe9c97af293e8c8b3049bf1b693b26e69af184471a7c2cc3e1dcbe00f38d03d8bd45435069486e8bd759d93f768f0f48ba9581da4e2db9509b5bb01d86cc7be9941919a4e8bedcac296088803a791eb39f771d14b6dbee9c6b5b4156f0ba94f650ed6bc520b2b75a90281227afa3a373b2e5f2bb8b3b8b60f1acb78afaed7b7e8713f7eacfdd3ff108ef626f4d49469e110fcb2f56a1ac752d526729fd6c5cdf9279596af387ca33dd6f5ec32a041e443f618b49e7706fb446351bc7f9279aae8a616f74ba31e0fd23353bba07b2cfd88fc44724b3570e8971f10d09c5a813c293af098e1a1192f57fa14a63dcf3c5c97ff79b5eb0523777bfe506bc7b90977af2dbb483a1e461f5bd56c967ce46757b0732a8301dcdecb09742ae30fc6a7c9a4240e9bef0c8985d5fe216ccfe2abd8fc9ce2d6fbd539f116d7f35583bdd80f6bf381d201000485dc147b2dd047b493ca3615730813ce757e92dd6fed60561ccc1a7d8fe6b20683dd6cac295094dc50fbd0c3c4620490df9b90e3b85b43a56ff3d2f29071640573d931bc0779dc4b305edc126a75fbdb0d0f646e5ba0b830dbdca0e26f414a9b9c0b31e01f50dea13bd4ae6cbfe0973480182544eab048bbc39c7db8c35789df125399ef24aeb2596d2a88a97374688a901aa78562e4b185c2ceab8070721efb45822c46134da2dd58a72fe6437a9c304acad3075fae85837b209585f6693f1a6ced318da6024426004983df409aa41221fe5ca68c7f28014f554a3143d58d791bc0a3cf233cdd88fcbe337fe7822972c5a1aaaa95d0d3dad8b4a1afad9ce266bb3b1e75916103eda09345fff9113cdd991f95febfe5d408b24530528a4387d0058bcbc331b4188cb66ad9ad6bca31b3aba92e0efd8a276cceafc49e0e090c9afb6308396cd347335b87de0cc9416781667ff2b4b57fba6800be1d0db15fb8dcbaaad1812478185d8182458db86d6d3d8bfe7b6ed896cc86b0e9a885fe20faa6292c6a628000a1987616e7f33a57790299bba16c950a8e03c751959443d3f1baad0a41451be23821054fb161af4d85380a5fc308996faf8611c9399d9356835a49911692bf52e1a30e532e0a69a62a5aa766638e7ca6bdc6e6c658b88d606ddaf722c46eaad2456e7017f3f7ead7ce979cd733dd0d1e312314f47c5736d2e57ab19d8d223e3f7c9ffbdb44313cdd4df26c9f35307e6f5e0df5df5386ffdd1e134a954184c149f7221255b1d86e4461b9a0c7f8f18695d71bc852d1dca370d68a71d098601c8135f59719ed5e4dada3419898c12d1c2758eb5ec6da75094d98a9fc925b4a81a19019e1a2056af17d3692e34413f960f8ec4182c1574dce4d8d2efefb2173b1fcfa59b68baa0e8f0a51330d791d1aa517bfce79fe5b00df25a217d4e8515ad94f0a5df8ed549438c7df4768d53e0ded8b5ed17c59c2dd8769fde34add3f8bcf0638e60825f2ef0b05ad4e26af4cc793c928156b8b13cbe76eda71898ac459c8c381d4547806f59b84cab894343162e61b988cc1b4b8c1462b87c2382072079cefd09e0d05f1347e658c7607ab6596abb84ec69b22ac6abfa8d9f5871238b8ed0f9680e1ed3a982fa95c7a7b134dd4c62c7190c349dcbf0c013c6410fd445aa407ea731d6638255f28ca53bde8099bc33d985aabf89ad89b6eaabf6fa1b798a38d9f5865d88454fd64929c6608f727b9f730f21c53ac34f9847a72338121463b9379ade279a6bc199deb9b1ba92153cb8e207480c9fb6a49940adf278a6ffa1e846548367c3804fecc061ba305263740fcbcfe8613b0a1494c69a8e1ac1825273a7cd7379b3b53ebe76679342b5491aa5fafcd2da38b409e882733a507c7d5e596dbee54aa19cfbdf1e0a2091f5ba94a3ee15ac85c7e0e8a8ccd02f061cdd449cfa3dc85c241068f013d81df21506bb5b3da077ceb8bef3345c9d0a08bcd36d3dccfb0eb42994cb877800cd373b66a0c50cfddd161ecf0c41bc9334c332e8cb351ba954dde350794b3d4ae8bd230c09e8bccb2d00b97e5e7d260a452d871c77b136a89f0383bdfbc8bb17f5047ad315ed16ea37aa2316ce081b9604c4e48603910303bdb1f4d521a008679dc9cb1feccb7e94b028d3f2e801be29ec621316477e2da763997eed76a03b27bda2cae0a5d2dc5e3fc596de59b1f48ab5e06ef0c426ee878f4c20ac651c096be2c7a75f60b4e0de2b3e270b64fda192ff12c25a9604cf896e5f61eb1962b5c9486ade510e0e3a430228f8e24f153b4842927b53b578a6a9a6d8f80fda971099ad46f979b992e50193d12dc5280b2ebb6037c3cf2c18c3f342f972990410158ec1ccc7a169973e5379508ec39360c0486fb84bc273b6c9f30e1d997ff18061619ed6793d1ff2b286516864c467e52d0b45a25ccb59e1f845983821cb2a22efefd2552e938dd6ec605c6e8ca2cd1d946e482175203877c7535b56cef667e8c0caaacd2d47c9a29c21e611465f632da139e09626399e89a8264d9e4deea2b1c370666c71c275239ebb6622b9354b1ce9c5095223be7c6e50dad5ff7a8a89f61969d0ffe8b1ed1844b6f7cb5cd56467d019c91bd28564fa658ffedf18d5d5ed6c9d631c8b2a043b7186cc2cba020571ea0c3c2c651225ec7419655d70fed1379b4dcb7aac8f1497ffd03fbc952afdf56dbf47768da67c83a554a23ce35e8b64b9377278b582c4d5e96fd3e3adc70045d23250b5be6f64ea7dfff90fceae62c7abe09186d6c202bf13f651f6fcd52c0bf4dbde7344426320e194115c15fc652f41c538e40431d47bc5348cd90ec66071c1359d9bc31bbfbef8e0c298415c925aad1a65ed7dcd527da425da77c43b3d76563446b6ce41a18afde13eca107e53be02bd3000773771e4302cd92f2c78d86cfe5b2284c16015ba1a4fc4a4b919273e41f2f86364161e938738b29496ebd78f11a3d9de884548e29cf387f37c510a6575f07d4a1ba706c84d41e0c30b843000cf51476333371ab8bd0f64c9c1f5ca2974e9182fb9c1776989e235efc7696e655382b8c4a9aaa127543a8dfa970d92ec11f564bb28382fadc88065376a92100eed9ab87a6761421bce5ece24dc99b6c5fa793a6a16f1f9f1f6aa7b454d6c80df11e5bd134cf0e5ffadaed60464ef480807ef3b676bb279fa84737f1c157405a95115ffab2f3ec9be99238f4f7720c8b98c443e08d4cb7bdb003caa7652fd10934e8e67d7404cffcfe270d0c68a8fc9d50a5686d7e24d8604623b8816fbfbd77889520b2c9adf49a0fbbb7a68ee10be5b58625c6b4641f04e2d84c2cb38f27839e7e8064470ef926ac4ff4871513c70fa4ca409dfe3b8f53e39447b449116aa7f014c2d17fd8667b8577f35310f61573359364c2d5255c822a799e6ed4dad01467f285f749dd4019730e4c3f2742c401982ba70dc9f048a6c0ddc6b36eb858bff6363121e37dac723dcbfe044eef9bc0a2a392ecd577324ecaa61bbf8197814159bbade75744e0a5310ab4021a47929a45c01dde1d120d0d2de528b8730c95c52d9ae445e910a39f639ce8b9d88921d90e7431cce004cc9f899537e74772b13192b784330287c8ca43e0e8022bcabb7875fee3a9919c0322bc4e7eca60623b976f0b882f42ce8edbed076270b0275310c119b5b48f4871ef9f86ff1550cb97eaa2d75a7d05915cf3c4c887696ef7bd7b906d3ad9a44534d58fb0c729b9a68d2c1688bf441de8d1a8aef52f216eaf9db14c5fc3f75851ccd2d29b6bfea5811a52282128c6f7dba40fe7779fa417eef7986f4128e30aee70efd02783e2731746ce3cb76b751089383ff4793a64c2c03cdf4c59e22e40dfff12ca2e54c67e2033ad1e4af77aee0a95c2edf7b9a5e48fe07353b19ed9a6daaee61958ea3895ef414ecefce733741a418cf4ffdcc5e787fef2edf1c19a75749ed9d0e9716538b4a06aa16aeb4bdc4a53b1a306737386709908d9d174459bda646d4ef2b561f15fcc705fa86a56a47a731f1f27424d8814a3eda676fe89043562826e074120e51fc5d67495d5a98db3baf237685b98694fe73936a369f6752f75ea1bcb285895117003c5a2fd454acb95afb882fc66aeb757acc8b5c9f020feed3367f24667f3b2020262069f899e27d97220d8323350c7d8715b0d18dd2590fb58ebd28b163ae33656a45b6553805ed3314cd561137bf87c45d38e3373d9314c75c3e5a9e4628d5935cf8c711f754cedd1ab94f0a81e64289997b6b7687ba1f90411b63431b0c7876a2c641008868da6429751827ac0cc60d59d00c9ba8e1f94eff04a4533a70a9ebfe915caaaf0efbb4e6290d4f8d347de17ad7b4e18953b6a66d35e56bd55077502bb1aa58548fd6d1ef670aed158dfdd2cd462aa98c8f44dcdafed51f8cb3e35999ec25c40927ad5d7ac3a9876b3b27a60bcbed3bb0ca7f9b70f8c4d3c709a72a55d46b03059db43d854619156279e3caf0ab05f7fb477b13c367d689808dafeef47594777898289bdfb846034f20415da9423f0d0611029a53f2deb701b7babef6276aeb6c12a8ea898cb1557594b05f70688f978a9d617f998d9674775197653c3ae15e8a001d09fecd87f4917ab6be30f73fd4cd475ccec469882098576b32c3d0cb398870ddbd740bf91e2d33203cd291767e32968754851df1d9ab7d44acf0d8f2bf739777ca20190e1fa4e40f996cf2db6f484a692406e6a1fb6e34f38707c149a3c1c4833ea9bd1f432071b3be299ef208afa1565d70896ef17302224387cd69ffff1b4787bcfefef56ef55ba7d93600cb9fa644a111fcea719baedac0e0a085b933e737cca860ab991c86a7be36315840f9a8f6e0aa7aec986b337c648e0e7656290126c805e315ab915d7aa696b124d0b4d0a8ae88094c69badb603ec859d71bc8176c989393b68622c178e60d66122f4fc4be61153ef30cfbe6b77499be7ff34f6a6a641eba9e42c9a23de9211a7bb72372156d25565a2ee6815b50b8f1020530ff61a5d22f8cc966a319eb0fc0ebfddf6a3e615277fcb1c36177d3586227a18c43b31bcae6b96c7022e79ca130650bc2fc6dafb7e730ae1097b30907a5c9f85aa87a6e738bc97e194395df8dba0afc76b1ea2060a71fd0f7e6c14f65fe7aba5988c03ca9793ff139b9c5e580d6dd21a1ffee698d120cc890e54c6f5862e10322dbcc5cc1aad1182c2752f9d925b78a996d15f07b070aeef0874ebd393deefe4c98deec457b3d0337865d35ed299c0c2bc37eaf8f5d2e8b0bf7e71dc9d75f5fe7741f4c1ed71c8d2451b6ea274b40c1c79b2c66d21462071d1bdcedbd55a020a03aaa1aeaaec310e5d63db49e4bedf8490504c410684633afeadb594e245aa2c552521408074d056e7b857dbe1b44a640d097523c198ac3980a64794a60d173f61a0fc5ac6e97de4aa4e26c8806af75a71f1463caf14230ec0de9cb5c772f7cb09ac732ac5e6f6c0ea3be5e460fc7390f92d7eb5b548609d20efa0c057922f54aa876f0da7e4ac79c66522c99b2e279e7155b2508fb4297fc8e5f85a490d70b559f811d3fe0a9746170ca9b6106d747f3692442de4b1075f33a3d32c69b71de345796bd736b3451ad0ee6e425f98a2a4fac181db36f8e18a88f37b302102220485eac9c6367e71e879842d4d0aabce7197c40bc4066c9b8b349604fbacaa670f30de43cd254069afaa9a9a32f99c485843ef0713306d02ec46f65900be6b1e1a2f2ac576652bffba618289cb0b09ddef0bf7f2b1dc6808bdbd7e7875eb00bec89c6569cc2559861338147a217c1748ff88a8dba705df0478aea26bfbb8adaa3b7d620a229c039a73b3be4d1e390d2a181987ba2ec0682f254da2395e4df8825795d2bf43fc06a9a39f884bd4918c970f221866e75a0a81b22108a75a01293ec3d6a8b9e7a266c47e36e74ababc1236c8c2967cd34f9503269c9fe30660d17ebb0179ce8f4dff650f470914c7a014271c59d25f0aebf99c642da26e64f47df5690ba61e41c13b700e6956a80e2c53745ad5fb105b236767e6556e843ff2d9d53bbe8cf9bb8c3405b8c62e81fdb792bacbde5339351549a3385a634c3bf40fb8687f8bf88afbb29439fed3e961fc15d8a90228645dd29674f7344bfa4cd3e4464d978a422bb38d998dedcceb35c9fbad52d36d2b6ad2c9b66f863356a5b64a2020695c026314aafd2d1d0d669c712837423945b51eb264fc7fdae641a1e381b1ab12bc625ef6ee794e4ced916da3ba9a2764b985bdc5c97ae54bc281c34819f2b9f236a030ceea6ad4932d1badecf3f5cf873a198045b8e5bfbf13067ee2ce904586522deb9bf48e61dc558d68f0d981d8bff6d88b28487cf77fb08d50091cac6275c5f9e8e44f3645f044d52f963ffa637476dd87c471b281486fba0532233d81932c36e2320fa961c9c2bce50c1878fe38276d89df360b216ab5e1165d90c2d1b2c1a9f99c2defb20cdacc565d753cd042ee958825ceda6865513784ff45927d41ed8469694c74af3a8d24c6a57fbc1da40668a3dc78b4f4e2e3e4af9e8ae74139b914041e253e6940036ca47f145e3e51594b0c316adbde1923f4d723eb3c63b361cce5e2317831954615d468300b5a08acb7cc67c1064ae09a919545b3c6f34860d06435a9584d2f89869a86a2306664eec2e85b0ca3cebf9314807c8fdb79a4ad9592ee5998853d180264bdb2c6d0c87213a29bcfa24f4b616181d9aa1fa64780efcc4d8feef3d0e57c98c599aad6103795518654ca8bc5f45ad0e95c08da3a2e82c6d82e6a21dc366429cbdd8709806be30fe99444c963798623a15534a37579ef1e4f7d1fcd4de3ccea7dae5462590d03bc254312ecf286404e8445411006b71859cf45b021f5c05ccf584fa25ed5b4c3ef83752d626dcf6296c8bbca209436e20c887d662e6603ac88d1b915a2f0bc0f10629b572e7cdb304b45109d98a30be7e97b45bc4e8c85b31818b3589ca6f4e95aefe1f4a7ba4476fe4b896f80dfe889e84a4acde83f409e3a445b477f5e2462144833653bc3fc91e09143853df67f0b6cfe92846e4fe8f6106f9accc06a94e5230276e58f017bff5ebe80c7f27ea1156aa49203cbe5098badf091d616bdc183e3b82eae6187ce1b28daaaf46fd16556933ee6ee324a08838f3acdb4c02e232154763cc36cc6f485be344ef9a5de396a00519d0e6383ac315ef1d84b50273109fc9518d064c1fabdea569a9eb44b1f422b2ca63c0bcbc939db7f885635e31fdae28f32ed0a44c9fed7698d787b00be92b23f829ae8f5c7d0f767711fcc8044e8ec70ff19e6eab85aadd9518dabf8ebaff059c28c58a498d77fe4bdae865e1a0ea78ef8d3d56fcf541c0c36d3d954fef8e8fb9d8060c33f462c764bb93612544df87f1024920dd3fe4b855c92b89faddee711d300d52ae045c1a5d034b958d0ba88c7b2908f10819dc9a7b92077d2d44c8cfb063dc931756a26296909d1d42b39900dced39f7b9d203e0fd01b78f21753a38713ec17b28f1a39a66523bce95be5350f61c6d2d6e5b47c86ee1b0cd361af2976d6aa3eef63fe435bd7907c10a5025a28dfe3c164cfd5908d3ac784579bf9a8cf676d522ed2b89eb3742390931ae772374e3a1c27bc5d4d68c269926433a9c2d40440e02dc1e409508bd76b04f79fbb934d5e1364988962f905682c6c5f708a2aa8f051d759e44d72ce9495af3c2ea7dc8b877b2f3fa5c5d4e0fddd22303680abcf9856074428f1bcba9c711aa186eadb4f220344c49574568b5e8d4f76541c287e1b8f567c3832413ad5fd0eeb694b234d48570d3d9743f5f104f9edb998ac39f8fb03d72be2cbe5d95cfc3c31802fbd91e0e6f752707d266630e2933a0972d2808a157ead65630f75b5357f791a5cd8b2dd04b319ee8a589d0dc961d691fb2cd6ac06e7c7b6f045385ff8bc90ed863ce5f45bc66fe2c486caa09c08c8c10afa1764e32ab932d07e21b5c1b47f2f2a925082385e8459b9fbf4d2384553766b30ff3d8cc0260187030a2a037723a8dea997222a133303c7fbf00a72389993ca5c332beadc619eec081ed27b1833da7b93b10f69b5f8a42ccef14f8c5028d6e87646c9b54d6d96a37f32add02de5a25e3fe29a7ec574f49ed04ec111fec14be86c5103e30fe0f91d648c81e4f0d871afa62d61664d54b9214ddd37dfa24b108a25e8b670a491807eecd01ccc9e2867ec01034470f1baf32ba57af38731c688a9b527a573127e33c611a3bc814dd787d921520c6aae45414ad100e6e7363cae8cf50cdb77f2fa38956433229153b33e602600e5b5d59901681c1f732678b798f7b1dbfe716ec42fab37e9c867886d0aa7f63010feb83e00c9e64284efc702e1ee98e1245fb94b410d4e0bc7e2739affd17fa0f87f2de331ad2cd1cb777d0ddcd102c8dafa57d9eb3eb21a22b4f47624bf72e424f82a6c8417de86d6ea865c276bf932361529e9899983f0b9238b7cd1a5bb39123beb398c8ba1761491f1ea16015d23881715dd17a767594fe3cbcaf007278cd84b1ae687356aa973282a3cd63bb96279aca03a819f5e5e82f079cdc5f76f7a0106f2b775d608360b81bd50c73301e9d3aad449f16be63f6379fd4658de39f2346635253915c4a5e3e72144d62c412a5848775747a7db81a30dc6c7fc090ba0684b750a0fbfd0ce4515e7900a1e5fd2d6ff4fb8817c8b71778a777da3eb6cb8a6376077ecb68b191d26eec40f03accb56a975a422ae43c9f737ca357521332ee470d2e8ad296392405cf15e7eef94bc8407f94b4751f8ee4eba7990bb61370c601faeed7931b0776b4387a1e7b0e3e8dc42b1e324a397d12cbb1e8711c8734931d2e3f7ffc030d051103700e70d9289c048588fd7c09bc780fccf168e67bfac58066d5d63f3f3ddd3d887e97474c77e14ec6c42c502465515388cff6b578aa35f6962e4499b88aad76441e0ca359350ef3f5c1cfeff4249a13fd6a3b0606e6c70f97371c736db39f2bae4705068db38d301fc9a2f3a38c4b9fb440cc2ea2b2b4d36c3766c4873f60a5f99c4bcd4a53658a80a39988448c6e61b7fbb693d135f77a0a140b3c598e401f050671564e15fc9c9abc6fbaa9a05307d7068500e02eec61283ee5998502f7f8b9d1da75c27b015d5c808ac11e20a5eacd68d5ddea8a0ec00169525995f9565e2a8b790a2e7840c35b2485cdf9d0705f7bc5e25c14acf055fb438850ebfcd4cb7af881f036528305cf88eea9e1c7235151263981c5c61a283c28bfb1ecb8b57153af5f1ffd7d0c5ef7280d13a070b987a3966358510c6f1740c546c3b273369d7a31e11bdba68b6b6faaf581c070bd71878f7ca7c090eae0d13c29f487998c4152b56a683dbe6d1c9fe277ad0798efd41a19d81558c303758e1404e689edce70ebdac7cb961119a8b4eb18271f7581b1214f1dbe54d987f390d4bfbbb82ee31bf3d463fa138681f624522bb712b0d46996c92d9bc8dbc8cb9ca7c00ccc6c29f5b68cd3e6911560ad236743ddadefd0eb582292e2e77cd9bb8633b71bf921e27831df86444c4a74b4f113f83c6f1f4d4b6c4fc9d9efc67b1c13d655b6a5c167d091059c19b685a075e658f80c0209bb1353c982d02585dcce2e1483e54892a8fbedbb949ca2ddf506797049e896cf6dc7d4c9f2f8964c0d365caccac5ab1493cc06cf29b3812c4be7e1ba85f6ac4e2049e96556b02953cb8fca0ed3dcdf9ce5b76406ef19d4ed96137ee9a8da98dd876d878abc77ad828664697b6540cc4b245834ff3de5d123adb0e9bd4b6cf6f06cd79492e7bb7ce01dbdfd054e3a087242b5066b765a867d1b665cf679a707e2a34389e106fa6e804a1631821efe118e5fca8e16160db378466bbc35c80774cc14e5fa533e984552143844553feefe8cfc2543589918bc79da342ba09ddfd491aae8b8277e3793bad8844e9a845a61eda35a8b1396a79c3e5da34ba33afdd5bad82df273071ccd9cb01b9eef1be2c979b06ddb5372eb5b1556c7f4a19191eeabb6274b2cf128002e3156ec0f98b39dd6bca51215d59fa07fe101eb835f8dee84e2d22f07242bae18726d00a3d026f798f27d1fdd9daff5b5058477bb9e97e50c00782ff255d3c24f8c3f6fd831b013f86c0f163ba01c2f509d995a11df33bc01c95d2f519973904245cbbfb0d1c6020191a91685ae65e8aa2cb24d6970453f6843cf60563042c9abd20ce1590f887281969c62aa34f66b661561b610597ed4b599266932c507cda59afd848e5a67969f0d9b3e7c5ffd0fe748e108ad82526c137f39646f6c011b058077a1d7f968762eb654d33329e5887abf1e4d7af07959eab046594c69fb5e76abe4befd27f0836c782f302a88bdb055a2a26535ec1c355b0969da9dfb29be1fb7540a2de039d1c03dc1eae74cec7a4695890835589f6d2eae32dec58f30ece1a1075d0ca7a8e4af2c9ff9ceec6e9f142059b3f7cb8768f65762fc5979560c10da66f61d1e0225edf71b3a19344e2472e8b08de7da4477ad2115bedfc68840def87d41a70c25da2b8678e6c45464ed708288d0a12b06d14cf655cbaf0aa62cc941ce62b3d4a69d2181267325f32d86ebda7bd32d46075ba78c3c836133a0c941cc2e9fff29ed4606f35852bc810bb38a61e95b044d9d9e24b629899d0261f495ef8bcb229cadcf5c04d43758dfde8e7bd54188a1ab2abc7cbfd1d4e43a4c7751475958542e7e3e21568aa22fa107042c4d45c7c107319620c045d124e8ae69315a6c3cbdc70b106c414f0ac692aad1923086f001764fb7c51797be38768005cdb1ff462c4f002137caa207f3faa459c2fe0d78c15846f360b916fdff50ed91170aceb4c43bf5db98b40fa6e3f585a30bd18db345660aeceb3f8b40c1697aaad335e7a325825c353e2de052447cb21ef991610bdea3e6d0cfe79597994744c291a19b90987837b1e034b976cd9c3f4b0b1b5c85365a17a728cc2b7d3e128de8c69a541381928707f78f00b96ee27e4785285f5477f5a38a59b32fc1cb91370dbccc973d96bf9c64d8af07b234884ab65dac77f069c2a585ea3bef4e6aaee51e5148c163ca9b13156ec629842bdc0eff7c2defa513a7db256244664091483b086c003a4be8d21e0e04eb7c73cf58083d89921fe8203f6d3d70630ffa168a1dc20d96072e701e92b95e028ce291887c7563508b91c508fb714319a1fa537005502890593c4abe581d7f42884684d4563b9174010cc4526e441329251809ff6c8b2c775989a6f5716bcb4d10bd2823b9095385801b8cc14f8fc46c3de6dc1ef7e7057bddef419d99e306eaf4fd20fa470adb1228d0143859f708f513c4b0f4f1415fa4cc6789d14496685220353182e751ae3d8edee6eda25923f1cdf5e2415e874dafee20929f176b3386e6388cf3032b1ed9058296d0441e2ecb0221befad42b2e8c643148e2587175ebf0a4d071bc1c083d38fbc4a94b23724c78ac5660b036c0321223052179b90d883f7b028137a55c63c0b835bad607d9760a33bb109d5492e87b1197117da664fee7bf1ec46db4cd9d79cb4d42e8e2538fe9b9876684efca8617af966d3248d5c7720de5b17ed95303112889ea6391e1aa1d2952e79bb3c6232f380de26470ba732b2f771c3732ce453ab5978c07cc94491700012465249b3f903e6704cbd6a0b7455c045a3ea1bfc418ac93861774ca627abcd3f76f517121ce3809d4ac9fe9bec931565da83839fa4a577ec182d3fc082bff910e2a2dd801fd9294e00083b894f78c41c0d64afb03edb25e53182e0a13473172a57844ee0a68783efe05bbeaaa6331673da8a91470bc98022c074bc9b742f616756ae61101378aaea178f1c8bb683d11eec94338143e269ed98558ea69ee468b4a39761f940aec86bc61c4112ec912c5d907af3a54bd9fd961581b02695986b727e0807503c1c68de33dcfeeb81c70b73730319b9c48468b494e177811d00f5baa652f058f67e3fc2d2eda20ad214a1bb7bc1679c663ccfc461d907dff79cb11f0c3ab32048ead6fe900a585dd4e1d91adc59f80d6d964d0784158020e116cddca41fd34cdf74ca93903cf700070867160e222b93ab5ad26b13fed9b1c2b4016ba11cbd356e17ce11d8d4e992016ffe2ed08aca3e6409ae1f3350a7c51696d08c54a35e096bec1bb5cd7437492ae73230c860020832fd23b113c85df7426cb32ca2b99aa0909c78646ab36fdad8c65b0ecdab4fc6795e1619a2d2a1a6d3e43a24dd7a1475eb7196fe1df981fd7d3325f3455997342687bc4c66d2dba21cade93dacd0ba66d7173352f6a165aa9fa67d12dfe174ec1a6e0e280ff6b07ade02dd21a3d891f49292caa26ffb96d5316af82e4f5a2d35089b6d800d63c9e3f7687a6f3149dd72efcbdb6f6ea3a8f55becd469676749c558822ea34752da01da8575de6818524f61b3c8e5c4a22607e97cdf7cdd7d071a9836e108c3908d1619c62d7aba964b82d4d2fc1d36e7d4aa4c0b08d2a6edbc9f3e295621bcf9decfee4966d1550ce2002eb18ee5e4485ecf71f30fe681160f2a818e21bdf125913c44a450b1989461b85d0ca5f37ad19a117b7e4483779107ccafa9d42ed4a494ccb092e734516c9d2d07f70bba20d40b22546d49c2eb06dc2ded0957bc8a98d598f58d0058ade99af21325b4b06abb2986de83662c9046da8464a2b3f7e5a6ba1d541cc2af3d9c7ce02384572904d947115d1ad5993f0e89be5cd864c0d914825cc172c3f93ce801719068b095fc21e12dea3b444bf4d99ce088e4ceb6f2afd7f143ac3746a5e22b441db7b683a53f17cc432756660aa38d64af9b0fef9871b84014501d6495c7ad5052a4e7d309d9a8ce3dbbab6172fc262741ad2131f7dba83d08a8a527fb1480b288c9a6de5603513dcfe685fbf170b2921f3ba118d9ea36e00304e508fe8bb319f7ece00662a390eb38c0f023f7b41931a0f7753b2c2ed4f9ef3749a08510c3f1748c3680656cf16a7bd47603ef67ff1f654f4f543b5cc2fb351a999aa678c6fce2cf5fbfcd7505518060f4594b640ef0a53b9bda43bdd87958ba79b3194a89bcb2fc3406a6224afafef59500e334d3b4731cc67d4978f154eb2a43e02fc680b9317123f3441b876b66e6b6dc8048b2f54cd5117cc4fc99225fcf0f46a5543e6b83e5409ea4f2d698404e6963d7ffe7cf39c9f6de1e2a0a5654324fb7d15b4742a42d4db73fc5ba1a2322bcc3d5a866da9ec772dbdc6e0315e6791e56f5914c1fc171d65dca277c2cf2c909074a99c6b3dc355b954bee2135caa60761aa3249ce37e3c09d7a3e6fb3ee38d3a374bef6b77307ce5a55d3e936e89dd977b9787468fc8e40c1570d72b1593d97910f20e50ec926e9f52f94398d7ae960607edcefcaf8adc539609022f913248854b95d7f4c279bceb19cba64333ad59b343ca26caba8096b9da68a8f429d10363aa3744bb4ebdbd5023d6d7d527916e1e65f1bd3d3c8a319a67f58ebd4d9316e4d3a48a19503aa10660c86242cd952286fdcd81026d813a4a03be9af6cc16b600853fb3fb54744d5efc12a61cea8932105c83f70f624e7426206e86b53ce37005058f753f68f56f33632347510bf7f13569af945637bce34a38e1073670ee28d0bdc9fdba9e4793e7cd84de7a2d9334e0d7a4f784ebd0c668e0e3e01ad4a1f038b3f8078a7f7adbc5032f84098ab17b0c0b333b4112a381b579234b7c38896dabac046fbeffeb87d23b3822d3f7ebf44ffedbc4cc61af5b818007e8a454384eb04f479d6b3353dcef966e43f50af493f435ccc3c9ef4b08375e6ee50d52ae0aa650f7389c149ae393f2a3dc05a211d638be36fa29bc5066dcd59d8c4107356c284fa0ca0b6355a1bc0770c2a6e64e1eb735effe7e8316ea143d6c1c51a10a190f6848e9d9a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
