<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5831460aced903701fcbbb3a71a8ec111344b8575f5ec4f2f42e7701cf3656277ce7bbcd024d552cf31de8c844f57afc09fee8c3c0a6c7be31604c465cc708aa2a43fe20c13d3e4765fdd40dacf9a8b54268b26d1514132ceb3b06ff4006c67ba8a611204ef9bf10f7763fdd222cde5810be1158e176cbb731eb1396408829680e0a2a2c13f12a4ccc0f82603398fd9093de743a4d32eea782c2699b56f90b00630ae7c71ddc97e91145420494a93a6dd5bc25f334afc64552695a4e28ec8b040ea70d51e7a526ac8e60a0992a034b2bd90849ef9919a47491979e49aeb774dfe4edc57febb339f98cfbbac57b5d648051a94362196b0a69bd219a2d8d0b505b653ec46f488ccda10e276ff96acf092d2968e1bd4120a2bdb012dc78507cacbc6d7098af58035f12498487fd23ca0838fa2bd62857a81b5e9cad2c8e3c37652449c2ce5d106d2483c17646796a9d65d1fdf44d89b4b2f444318a3fb114d61540abdb5c4ec10df1cddf3264f7f13f3868ecd1f172787f8a7813fce570ab8061e5b0d6aad61da169a1d68b41feeee0a8f842c950b8dff8d085371180065d2941c2fb8b6febda11e13ca2c7301e83cd63f77272cfcdb2303ef75031aa1ad31cc4486443d94315dcd8bdecbe4b1161f28cd192d2ba76ec0dd2baec5f9e10b9496d57abc9831443228a4536009d81a20d82087e46e7ff51d943e8f28fb5d3f2f283f7e1dc446b50f7051ffd504dfe81b19380e54074b7a65f7e7f8ef60ad4c7b47ed0b11d0b2c9bd2da98e8e672c9dd9536da0a4fdd73cef8176b75389240cc75a77edf88f7be6d2a8c668f8acb73a087519ccb497a0add89e15aa49b5ea48d7260b259b0632a966a6a2a8ec72e7882d88645d7e20132e7dcef00079b5dbc3838075044c31539a21aae85f6032b74007ad0a6233b9314718481a8500b084362cad12cc72b20d9970472dad2fd7d4277f021f0744475a7e8a366e4111248c1c7de044e8814af6800e32ce1e2b091b0b6d8a0663c68d8f75fc19d9de77bc13a5428aba83e0cb850cf57bb536a15b1151cfa6ce6e9af8c8d124a44711a577ce21cd2a26ea603554e67b0b25b09bf4d067975e558a54f2c2fc84af3c94ccb80b86db93cf318dd3c63bff40057a21582cfa63e3a50f2852de152e90e2624f87f1ab3d5f178c3ce44aa8d93f978e57e72ee459b702fd12b4b8f6d8c0c21941889e80f9f2db4c8b6244906c9e977a9221f4c94779d1797a996e18c8e80f095327491308b8d7a08586d05e133592824caeb8be19cabfdf6fdfbc8856609e3ef28645875adbf320162fca30d07bdc8b1b53ff1f65cda25b6a0497ca845ba8ffcaf7db627129883ebdcc478cce89c3992c6ccbaf4a6077a645a61829d19d2cdbb96482575a09319c90f3d67c7bf83e80c7b4be5783981e98f7e0a8fcd14a2a8bc38e8e37901db4fd6f785597042f4d886d2ba0e5151b71f3ae796982b70cceb4320c5239824a16edd2c06131845dadf24d378296be28cae410a9bd24ccd46ae29e95674ced86146fe2f2d723734c50ed55a68dc8a5f0aa072e7dda1cb77a2c40b20f536212cc73908c00ac78d9dfa5db03feb6f89ab36514e5c6c59a68b276eeb63dfa9161f1a9bc0c9e43577778000f3eadb032c2918a6de1afa2a61807a1e9e3ef04f77468e991c849a8c725e61b8346ac481c4be19e1f69be926ffd8644f3231e24bab81edaef0e7e41ff9088260d7821a0cec3045144937daaacdb4e7689973b3af05e71bae7e4b67de212511fbeade6f681310dd4e706aca43149202a6a0f46161cbe59a462b4023c223ca2fcfd3214055739975aca8f7c9f9f49e0dd60c339d3e99904f691abcb2b3f69cbc901df2e2e24bd83898a07449774efac7eaf6d25cc435ffa9277e3a957ee963ea518cd3dc12030a4bb07bf8f3402488b26d4173e03eb924e9f3b2c3f0efe93dd8f195999531587677b3a577a7fd5f6176e081e30dfc83c02c23d844f65506495873fbeded2a3fd0d9dce0a93e241bf59f35402525115b3a71193fea870f43c9f370e89e3c3f6b89eb02f541cb14d3ba189afcb654807663bb81f541dced5c12692778fad6e4909f91d15aa4abdd993ab67c819436c7e0dc6cfa2586123236184d9d6ca970e6799a4c34627c60d7beb1d1bf1321a52e20d6a81edccca2b836cc9b582ad2eed26da3cdf9888b3eed13508870c0e3e19245d16b497a85046533e7181445a3c8c07f0c47d2012d02ed9104f427b1acde944bb1a75ee53f413f04c60800bbfea65c4fbb22191382ca47fa5c374b51c1e8334c2ccb4e01272e834ccaacedd11affb7e8cca52b1c0352583ce041efcbe275eb73d023264f6d3a8ead9a867d3d6b96d152d1cb048b34f2f15f841a54944c1c8d58a2b445c468c0e5ddb942678cdf279f967491c559e093871b66b2f450595aa55ede46aa4692d6bc6259eef590b3d1a36257e559a65d7950fea4ab0b9ab85421fd3ed204046756072851c591baae1cb805ebfb00b10f66c090f6a335b433c9dd7acfaba0819212de6b9b32aba28722853bc2bf1c7e6cc991dec26790d0a83f610ec3e25c79c72c91b6400b604f7cd5ed558139baaef8180ea54b42500352dd4dbfd43597414c0d18e0a4eb3adb4b03d006c6fd115a633719ff1c2bb191fc5b6c07a2376688e979adfc545324e4bb4fe7569eb60533b141151582f6be31b15d949a1ab3d41f4c419bd48dcc733fb762e32bb53c3eb4a9949bfbb7b387fea6cf44c3979ffe057f10129c64ca6816075e02f9d3d593c726aba17331ee94acc3f84204aefe108b733093078b3a1cb84eac26a261ab6693c0deb521ac494b4dac1217ee94dd8103073aa6ce3972df302a6d23b5fa7c0b53e9cd78257d399ac32854d22c93ee2999fb3155b925e7be01ba43a449c06260a72b08ca3728f70f6c9faa4a72254fa3d5e441bde490e963376e092790b5098c33851dc576896168c90ce1d0109f9c9a7bf3557ca100082d152f28dc0b39fa8018574d2d74909130e1ee52f2b48e35e18135216faade47cf58face30abf9f75fdce14d000f120961b49f2789bdf50cce22d92a4d1c0c5e82b811d5c71258b9447cdf462dd0523244c5d4b361a43facce438a16d79b3fd4529be8e96d7f0d35a49202fa6aa345f5032bd6d873127b77caca366efd28b1f770c71a2f4a89d275e619aac78de20abf7f70c3d568d2904fb637fd356e2b1ae8ffb2a8b381c1c85e5eb51c290af9dfa5a9b7d71923603b7616053dba9e438746e0366fddf31a97d2da55d5334da456f042102558d3d52a22662eeb39ec4f0b3d5353dc66cff428c0a49dc4249719317b4ba23d1429b5d65769c32b7995d2a6a8bdea94e1b410c8f561de9195761f571fe8e9466e2354b85e4276a349d752ff0a9306b6453af9e1a884af5f75704a1fa132508d82a8219a3112870b6c5a40c962132d8f2ee67668b47fb72e238ad181c8052f79f3b7a84a30b5751b6ac82e13f2134d8bb327504a8c4c9b2c33adabd26be81c653fa8ab4a790c0ebdfffa437ed938f97b439bb1b2724878d7963ce86d03fc0ebeea53924057a2332187d09622a589175fc5de576e21c856f4bc2ff94f869bb9c7723a5715d2f28ed96b70bb6b744118dca79b06924cbc9d2449d52a72d1e79e3d2e7895eb06e4e7faecf32e395db1ec4dcac80fc95d47f2adb3f50637de31bc7237285a9c4d8bb267ce49061da82cd428bab289f55e1b10e980f1a8028bc2787c837dcd468f1f22f6c01059d63d8ed94f760ee3e1ebd01b97d7b8f2a79a33de6b223326d41b8374cdd073f22cc56e099697417c142262001f0125ce53c882b82a74f529ea481e96c5526e3629e59d13377feba1c1549f20d6c36b2e50907a767c351f45aa69eff80e5329f08b5fbe3b5e3984c7184282352bb8f4fd06e0e68c11afde6380887bf169d2abb68c0b86b5a871f087346edd6290b05f2895d9b8870a3aae3792b6f0b7089fe423b234910b3634472cc1bcc227764c0ae181ca63537060dda44e944efdeb167ef9dd4856e46d38fe867a86137bb781ef052528662768801b670f4e3d2c90c7d950733a1112a905dcf741256f457e31a9a2808b089b830b3adeae776154e67d7444ff18a0e04f810adc262f289e53c0f06a84b06399562e5b51df3de28c0492e6bd5c3e878f4b026554abcb9d0e8d4601d5aa106f864ff2d355e283bfd2c3c81f623913fc92ce879b5eb6a1fbedacc7d4a3220168ecbb51fd0f6bcf48a8babec49db202453c6c0976f7b3d78c483bee3308f8d546444c946e3ea94dc98269f88583b792372c0b96140b64054e2af2d31d44839b0a2232543db5056e9b337f37b4832a86d0fe1a34194019dbc2a7ec3bdaaece23501b7c9b47275eb082760e18638ef6af0095877bafc61b1e56acf7cc14611354d5efda20fc9a14ea5d4002e41072b8eacff8e28553237afb95fe825dcdde615855fed000836e94f5dc800c4260cc273b8a886343be498f7016b8ec770dd2e0d3ec1001175004d0de5b6a6ef27c64f8beaf1eefa1583bf6fcd4cf8edee9af8eaf04b7c6507569374f3128f9cc30305c7bbfc998a58ba2dc94567815eac7536bf9876f42fb32bb2ec761824589ca654fa0fa7f561d833bd3b1f85741c2d1484dc8657074bf26d42efe09d3be2a0a3d3446082d6979eb623b55a8cd927738ddcd7490214a1d805828b24116b6571c6e74b844d03e6e590bfa657d8fcb6d4036093119b7467265e94c1b143f1383f8af34f5bf3605266fb043a8788529020b9085e34e37215205604dd438ef1f1b2f5a77706ac3a8b8984eee738fa56f0fa320fce69f53c576f0824ddcf25afd5bcbbbbc18d875ac1d7f2d43c55de88b7e1141e398190acdad4de0881f0803c78267ebc2de9885658e2948ef655843c34fcb4b9a2ea94dfe674aa244e5b068a62721d76251ef72beefa7e771e64080c691becc3d49ee3e3c3083156ef5b4ab3d02d6bd4549003fe92938e4edc72e75b002c91fdbeaa6111378c01d9fd1d7b6378b3785ce13fd50e98c790028fbc2087e5f004a584748109f937dd532123eaf6ef421464d99381195a60e2f5c1c2b24521964fef76c93a5584148abee4f46620838c2c90eccfa53fb8e05820ec89c5c7617958dfb00741825bb272d28a17c24e66c255bb46726dee73becf99df6bf2a20dd92a72c69d89fac54cde0f8ece07dc419250d8096e52647558c2604594e3693f70975519008ded2249c979e150b66f105e691ffcc4c9de152fdedd1a2c0ae067331324578a6b74b036c6d249c05bd29135944a5565db0e45fc03efa6b24106365c63df3c4908d9980d186ec7f9d58fb44f3485daa8119591e0184ceef40bf57f0906fb742a2be0630b7a4c0a14f47d619ab5bc44f4d10ed9b50e5f18bae779d6361f5a1a82094479c80750c4edbe74c64aadc38a3611790892244a961d9da78ad91ff33acc3cebda7d9e90f24ade03200cebc539ade2acf338808060c11d29a990a8eabf4c052aba2bc0cbdc857af006c11e5cb26649852eb1259d580f23687cb6febe7dc75d8532c5776c4babace6b25b32dffcbccf6f6b135e32eed60f4811ee430557c7abe16ebc8277c0d8fce9b65daed9eed68d0b5af99e7677f101ddfe33391b4544c3825b8aba21ff37d323e6c627d083942f7f2dcdab365cfce675d8ca32340c82820ffecb8b6fd5664880cf4c18eb78c702665a06791235cd78aa55bfe987eb6934d8a2b4983e93710c5eb691a5c38a2d1bd00412d78a0afd2f8c28b2c0ac302770d0549cd357be25e7558cf82e71e3563d73c452760baaf064396ca3566d7f98f9f47646252ee0ab5a76c742f1a0b8a8ee905547b249f27cd1d8c4a96c4808780de4bed5b731e343d36cf05142d54e18a3ad4ad7821e73284e39c533114a787b466b641bdb757c8ae57ba62f5a18f55c18d7deecfd4ff4c992f1e1014130c21739c6ca9099dcd2a11752dc67a84d56dcc77774caed28d20469af0a85b6fd67fbda6bc3e6f73b03952e4f1457928f0aced6526ea5c87e8efd69e7d43a374d2f6c9a686abf7e01b5bfab750fd810ab6b7e9c92cc4122825989db940ab860dce3dcec2c8432ae1e067dae7ce6aaffea900f99054b9c3e91df645d07c969bd67fd2040fe8a4f47b79c6c3b372cd82175f44955ab2e58b4994e2d82689d5b874e77253ff811fecb9ec843ceffd251de888597d5631b9ff4afa691b6218675b8e7ba555622faac0e0e1133ee3117e97aeacfe6048790612f1a1e0b6d5d25e47bff90010d0512587f2e7eb2a02de5af111b2541cb69458c7613e549e9cd6c4e91fd3944c882ebe6e364f08b13785cdfba3d6ca84ebab2a45399414507899248ca84dd5fbc0f60307ef9fac4dd3d957cd28dca50a85a7f13451322817be1de8b967595c83b9f8672bcf46b42ae80deaca767e21ef828301ff6cd0d2cfed92759a8a939b30bfbe3335a6effe484ccaa001de1308dd83b291bfa8eefb0d751a089ee8e6b79aca6c72195348679606de48ec77d1b66b38946e015b6213d370adcb896d3a1b838227ee3efca2cd5519616cd5ddf859bc0c12095f160e4a0f4ca917128ae7a58a9ba3da14b6649b19779416cac39c94f7347cf8899eab36328e56395f6751dc14fba619a038bd734b145eff17a7bd62a3a57ac1fb282c3aa009fbb53ebb741fe3836328ef32b8b11b6448d88e8b3e6313b2dd3759d91fd2fe07f67d845942dd6e718dd85cb382cbaecd6f44cdd976e7e279c4d0735261b2b01b80455f20dda771746224d03f997386986238a0cbd3db876a189dc710121db5b848bd3495380364cc6500dcb387e6572452cd8813938eeb9b7b971491bceeceede6ad356d552644f8072de5936fb727024132127a6e6f7bf59618917626d30f6c27739131718315afcfc3ee7dfd850fa55ba4b18e7a60a80e00ddb0ea68476bcf8de497727e549056c839cf101952e660c2d10511dc07f7e80a5a1ca7ddc5630dfc3a3a725eb3ca5725224ca617131f2832e8fea091c554ef940340f744a7f50238157c5dd000289abde267d13e727d6607d53750527636195f16a015f5e858fb9bf8cab172d368ddd81a431014b1679cfed073d99d1f85c01e8432718c68c0e0cbae3e8e527663bade82960103a22d3767c8d5082af0490f1eaa4de3120618403c5658afacb549cb42b8a32b21a615ffe97aab093ca0f1eca366b3378a9efc5f05a00a1aee0e91ce4981bb8ff7898b7e5af2bfcb8b997b6ce40ff17519e8ff4ba92d2da635af6aa264dba417cb755a1b17576ee9af2c0a5114be324de0f31f1de5503f4f0e9798eec39faadb773f2b1bb95bd57d85d246cde1a38bc11dd992ad9a39cd8252e85806ca77f8a8b191092e12550e4beaf18b90af2e3de79da288a26e52b4ee1d28cdd42ab40b94be0e1ab9479434e9d8cdc2c740a0a11f027e60142b03e6b303e179937dbc937cdcc1130487662b68628b65f3ae9b467a2445f00e2de38351664e4b4ae26d5de79e175f37540c6dccdb3e23b2bb8b6b4d47d5ce19017f7162310da278ff411856de3ab8d7fcf2d2304f086154ae1a8a7fd202dacf0bb0642b9da17e791501fe86f727323267e62287548d81c89ad5f5ec6fae91eaca866af8c9b61cec3b298d0ca4a237f284698607f64da77cc6d6bc4d2ee3b7098ae15496ef08fed4d276b5149dab5222c4348693ff1a5a2284be5e4e73f85848751fe8b6a7031e688f44958f9d15a6b9876056dfdc52812f2130408e925fef2174ffc1d9ebf3771df04ca2e8bb04e1b86b1a9bcce9e112799aecac184299fbb1e6130b936f997e9e43caab57b07c624cb8375b4fa6395c4b61ea8061ce9f4984fd4ab34a20592cbf3e5be31c810a19c704ccdca4c59d18a284433824b9973967ee226e1162b8b206a96a787a2eba592d6f5034ed49049a9588673196a427200865e91e8927576cc48aea25e7345c7bed6f9e56d2b58a1d9437df8ebbd520871cf6297caf2836d6c930c38989f33e7b3222a06767a90e49345142edcf68ada4a30c117a2d0f42833a0bbb4ec7cf4538bf98b0845682657a1a765510410961e648b53b61cd2409af081056a9853b702bb2ec63e00e8835d85c2c2f8cf39c859939d1d0e5c8ac99df598be2328b94833b3ae4bee9971e4b22fac80156cd90abd8b26f0384681de61042cb0027a4a523f2be30e79f9a0d103d8e502010affc1f65766503d167e33c77ab74c5067d63d05378804a7453e89b64271be1f8d127c8c2856be55e9e75f060bcc70c619cf8e769b99c6c9aa6270ad7038da3af60dc0cf6a589abfb448097343f44c2bef198915d04110c83c11260de434500086bf9dfe66115fde4700beb2bc81502399e4c4bbabc72efde79af81ab4a0bb2a46b0c3a7c406d9d9b523a3fc3223ad62c5340d4283de57d7d641f98c5cac175126f99199c49cc32c37d9d9d0709a498e03809d613cfcd17a82d60548bce198863a47c359ddbd4c13c3f40475d824ab49d7de0cbcc262e3ee522d33dc893bb9c2661eef0d4780a032b933d630cd5e742f7bae491920fbcfb765aaf57bdfca0df09930f8bb1de4c1527ca52213e9c8f502d01566234492e9d97235d7680a92e150a074d8be0ffc93e091f257badde7202edd12d47a94990849643104694b23f282fbe614ce26ee3635307de3c28d0eb59d93eee098dd74f9edc459507063fd573687ed1906999091a5a50aaa6d7afebd131cd69396f1fc597395926583618a920879b8bd19bc318c017b06eb48cfab04e0e1de231d4066a528cd396bc061e2ae01f110bd8e8119ee26d473e511ab8ff540086f944fb029ad42fcae9dbcaeb03a671ed859fe7b4bbf58a6d4bbaf1289dc32c38aece7c164b376b9eb3630fecdeaaa3c2fad987adfa7c8e17968106be336caa6c87e97dd722ed921d5c8c4f9408dcfecaadb7c33a8330e30108e29716afb41630e3b4cd5883489fce13e39e7b04e901ec62c4aad3526d56ecd3fcc42c0471c9d6a8da34aac5484c79d2658ee5cc98d4dd704603ca69743102685d21e97700cbafc99f7d7a94abe65ec4bc5b96652a944f7d24da0f58e8717765ba606f7cf913926c4887c642f37ddb22d8d2d6055c6167575d1f4cc189a9a09791433d5e940911d6c2e60b4f686acf0e43736ab9891a31a05aa07c29463466eba6c3c6e5e227f69eed45a80043699f2222a2468207c781cd10b45563bdd37badc6f0a5fa8af3b0e7cd8667aa547ebaf4a6bd3e8a59a9037ccea513e156ebf0b811b7dc900c0489133c09804471d057bbbf4498d9fc5a541b1fd4f0a160f1705d66cd11d80dc40064d6ed938fd9d8b5f623182b8ba1358a1e52c2f39e35bec2d70b8a3b94ef0f98bf6d284d28b3822a9bdbe2e3101e4aea455eb56ca5516bfe8501e0451a8b8707ebfc45757bdc985e6c5bbb8da8d3a10e95fd73f3ff02b8aca0c3f9b4730003846c7847db72cdb44ff434b4b7daa7333c26451fb10504df57aa29add1a87e277427d4da3af3882c34c76d1a6cf275292ee0337af00ff018a58d6a0b16c8122b469dcb28cf1cc78ddbddfe99b87065635d38dc6e9450bb4b5fc36d142dadb729127d3e75291430ab69749c4b7a6f8ee442ed28f3a2f4732f884d8e7643335193026f120418202236c8a70f59cf5de279039ba5b1e80f793d2a62eb0193fd6e7baafabdee500cb05993843fea5570cbf8917a03226b7ba35cba4e91f69644026ee578d277ff21b4a2fd519859daf440285759b35c48f8015e28d1db794bf9329303b6f65ea9326a0bab074152cefbc0a64d6c22cbca944cd6ed770ab7b27d384e1fd0a7667b7dbc96d60461177afce22238b6824ee661b70469f962a8d47479193b4ea5d57778399833e6f6b27907850d8f26a3929fa746dee813197afe6900ef452fbab03f4cc6124aaa1be4ca21e4b2904cd5547710c057c27dcadd83610303956fc07b81082a4ef7decabcfe95bef64756634358f30dd155e0ddc4ded129fd6935a09b1a71c6647902851efe6fc624d9edb90250a601359ebf7147d34da0a6aa0f57332e0ad425d597b774b5f11481e7fdb9c957efd2ceebaee7467ec79e584d826fce613c1a418d9f4512f4e7b0b13c78b2e22844f0f9a51b1ca1a942f2f4dfbdc1282c5069c5e495d5491fd4cc3909808eb3122ff8f4305b6de19ad2f6bb19e8d6c095a717dfd66f34d34ac78e3924e4ffabe30ef73a6ba4fa4fa186f40ddc25f2e4e97ad981c159bf6abd5d9a1a620ce8db72707cbb80d521103376908dde213a9048ef94f58e0088adffc7178cb6d27ea77b5476b23499574ed67a32bdca5c79ad5e85ef85ab4b39f6855bf55f463bc67d07c512789761859c0899b0e64c434de4777184cd494ab716e6499d90d02d43ba95c70cfd885226edf825d071dd0ad8118ffd233a997c970e211e78bac9a99f6d9ce467e2f147a8945c8ce24002520c8368d216d34ad8005a7e909a894274ea6cd6d5494a60c2b5d55d3a5c567dce497ba5f9ca7761786cd99a4581fb9eb1a10f96d0d38e0aca239f3eef3084993b16c22fd702ccd9d85531167ff4251516d3b87aff48456f52a1ccfc4db1d65b889cf6f9f3ed7cc96a44f860acdd962191507958c5992797b146aed53762174755b6d1c4b13f82174386b151919715ce66558240daffd4298e4d4b1c99c06d328952682a19c7676bb2722e95f18d77eb68e5ba4eb308850246ef934cc5d04a7739872ee99d88af0d0000a35b0ed5419b471fbeca6847ca2961a571196720d2aec63dc4abf3d6578d525398e4415286eb5017aed8148fe8b4f269dfdf6be20c65b69ed5fb90ed3a7d7e031a547180b08c9de2450f2836be4fed0db54bc574274547adaf1c9d6785d98ed3c444b3e6a8f7de55f6adcc5044a065afbebed84c7787b0d3834cde23f3ecc2a44313d5ab690be2d8093012917157723ac8481d9a4343b691c46b7ef6ab617202bbf576a5481aded313332759ec0ab18b94792120d7f54c8e5f8dc8d393e438cacd3004297c9466dde4d455011d82e6611741a2564433e07d107943d1f778407324d266357eb012fecaed9f3f2c2706df62b003e5b7c119e8a738c22f762895321c6eba23188fa2155cef47c39a4c7d2446ae0b01eaff2e99704311bc0d39b509626bb3e77b2e4d65543e4be1cdd1290fd39c2eeda48daee48ef622d35640e3ebf6f9e82f15930a3f26958b131f53c87b5d80b210081028fd54135450361c67d92a2fe5f59bbb6ade0c7649a3ac48dcbc25e40600ea89e8af07c422cdcee7875301fbd7e43f2429c9d1768ce28022cec6e825e9be2faeabd0b980ce876cdad7e85e8c27d42e8bf6aeab0b78884eb4ee167c2ce35e0071d844debabdb14d3591453976a497be8714ee96b73aa008dac6554dc0e2e63002c6caf4b50947bc1f952bae1a3c2b5da097a64df1eeb7e0fd85870b4939da2460793c8a30d68165922ab002e25391c8b2fcab813ac9700889c0d8f7ed0b8f00249b1f02c8063d692599fc82cfe8a804abc91b12519c5fa6272e410de3df46e1e217fba6c4fe0659a0020e8b2dd83d7ec279e0be09ba58b470b5467c42ad32f51e8868f57a0d49b9b4cece51af4e070cb118826026ec764153fbe16dcf13a42b00164e218684399a27eb945e45652e93623bef813e5c665c38eb7bd2b135b9ca11bb434aa603178bf112282eb6949f4242c1e391c4ae4a5930916038f91e96419477498914a26de584170108980969660f09017a5d6541bc549d74939420a652dc8ca2d5befbd4cc270c9ef0d62bc85603568311acbd19c828c719ce2d474c7fd9ecca54f33f5709d4cf813688066594bfd983cc077f65c68100c6f01b892827782ca93f60601d0ddbc9cd93a3a290c58ac85946fde530f626bd1552a767eb9dc680bcf0e258f2be63497a5d041b46fcaed711b1cef7c0a5c95689bd315fe600b8e0e702b73ad62fa908665c9f2171be02df33042a737a59a8734c15739b8cf7a18ceabb1687b716c60db2371855ac81a204c6c0ef5f7435c240ed8eb17ded815e76852fb4daf6591b5f5bfa8a776025fa4547c7f1f6a0e4b5dc7ab89811b175d5c4051253c7550b3fea42a432b94e9421dc4e6b21a5737bedd9f89e8a02a5d349864bf4eaae72db792aad3381f725fe5a0f9602827fe6981217c758537d973d0472079cfc392375caf1d1ba743c5e82575154a910f4d52f720c21edf2ff145fe6cfc5c89e58fdd00c424d2c2aa985555a59941913ddc9b27c20cb20bd9b2a58c413979bc612aeaf3535f7266719653b965bc8a7cacd4d4c38f769d72cf62d3836bd0e88292cdaef829812bce98d8a81341bd9595c7150fdec413fd77c8cba04cc0a93194ea60fa5712eb9101b7bb72aa12a68f839cd9627c8c00be29c18552e157337ec5a2e990ae93469a7a7d59bee2eed4794caf88998083334a0b97ae5753e1fa403040fe0212375458df4a3785c1363afddcf3b49aab688981060eb01e00795c53ad50e2a91aa62d5f8d9236eca65419939e8d76c95d0fbfeaa3e37d66bcff6dc2680162778ad8b129bc3086e5a8a9f1648e1199e8a4651ad4dab0f7b052d0ebed7a44d794420dd0b28e02afb138500fab762ba29671e888d253fa7d6626c08f84a18218398ee117605f2f4681028e314c99fd85bacc8d6178be44d8d4bd4ea94e0d3b95fefe4836f87a8baa6b4ade24ad406ac4943e40c5af0fc92186a04896bbd007803dee1ccacbd2c3083eb99a911ff3d932bf27f5feb4a43ee8134016ad5a3adc6456352dab09b910fa0ac1f4e96a031ec2a4991a35108ca920e8db75dc358b8613c4ad08df1e5f54075f0b4a3f1ba77f6abb68075c65e68ce190920d5439e3eb970dc0852b8c7c6b65ee673398aa458512da11a9ba7680e3c97726726c02c9d5534ad8b3c7e9d55db2065a31bc25564f95425eb0b54d5bbbef1e5f0e51b8e75aa0bc90fa8959486900ade7f85124730e20f71b1a847f1036b06afbc2af15c8006152c9249271d43bb1d22e4b859c0f6b7f0360969d3ad11ac6ad4bd179d48566b617ea67076350a439936f563bfaa9192fd55983b92dc7c69e30c91d967e46542e5c470d51e92687e5f7cd0a9de88b4c31c81019d4ab29bd9258fd364db3e5773eb1f538534686ebb6ef0fd1301ebc543a1afbd36e3e31bb87c2b4b9f1a331325d61d41cf3290237db78126728c3b73f3e065704a8914a2f97a2f49e3f58322b281615d961e8059c3439881cc612b1f7b7859f98f411f3fd927916d6f1f430d9fc4a4834b0d39bcb16775acc0e078ccad8d5d6372e438207aa06b25c28072a86f18ff350bdafa6f8f64f7360e9e7a6f3370dd4fe079900306402cea93b4475b367f6cb38f716c404432c4a6b85a060f87e834b36e99166f8e76da29dbb4482cc788312a5222cd20d335a807dc8697b35c13dc8135536e332d1ec4b02467bbe4bb4ca89fbf46ff6b26fe77bcb671bf84a2636b701f889604aaa98d42834c4e6c26495288556a39d02a6cdd3618de1ffa618fc1f7fb5612efa80a5161f9a152a786f45b96187a6f50a06b1d930a0fbb32ff5b9cc953ae118e6d59eaec5a0281166b3144612d0c080c91b64a08e62b9f71a6c7b055ae64bf14db8e3d803a218564cdacdf5c6bfa81d6dfe401415318d6d708a103c4091375c6d36401aef9e9b6ebc1b796769ec13d290544ee65e535d49859955b3be6005eba84e4f502656da91f33740c233bbe021e7e110be48a57a54d2bf1a8abd5f5b39f11629fad34abf9be3df1b188e0d484d06c9440c66206cab2eabb2b5adef31b3682bfc78fb68220adac534344d63604c37d793006a7d325f14885fe682b106e234d6b47ceb1c9f3079a778e14dbf852b100010acd57d18ef591bb0cc5ebfc0e551dd92bd3c5e7abcc913c4fac2c944afc8f2922527a2f0ed7cac0ea67aa0f0cee76ede8cece0b4df0075f09948df9dfd6d9617aac8cfbcaa7fd35a744cde2c457edbe965c3a26bb52626b82a135370245e91eb244f12a7bd99739f9f68747b259b1fbffd2a8a2fee471f6b52be2d16c90f111b81467433b40fcfe3a20b23e43a50b941795d9d384a00c88b5ce7ff71ba678ec79ee8dfbf5249bff1c517555567ee4783131df86b6c114d53414a84c98e582e9edb316184659d750f2914dfd19a66c34c48de0ba228d3ee633dd2ce5f5e6c4694c37a131b2f25e5663d483849219443357227e2f1a413fe6c51191a1258684103c1ee94c004254eedc5e4b594f24090cf7fd9cda049b6cbfd04e3855cbba66c6aa27fc4682006426f80f0a52be1fc03717a728520332be7718b9904ba0c202bf6228b55578f29744e801a30e1557627347af7520c04289eed75950abcce5e632c4aef3187d712d098fab610f88496e3f9638e65db756bca251bf6b0c9db0e1c0e041a741a3899a6b0699f0b3720d726df8dd42677fbc6e7dfa8e2a5cd371390c658a4ff034ef0063ddd21191738306f6bdafd4d81db1309983a3b1510c47ec7fa7bfeb96a4d6cb492faf9787a590766a2b49c585c7577bc6ac42ffaa487321298950a18fb6d735d89a61cee77324546cef148bdccc5c3b17b59ca10dd6a6365a2f9d1ea62b2c3d254253528bac390cbbcc396f4a6122b5d04a01c05957cefee1d3abf61df8941d8f8575e16ee85b420df65b0f9b0b241096b62bb18a604100411577f24b18229e7eccb19234f9bc35cb7be83b7b12fbe7152ac3359db42f74200bdbe93664ab4de8301e4c4b7a5f647fe50a0d11c005a34c0546ecb741e8db7242f72eb88ce22cd077c74dd1359acd22b726a251822ed971297eef8af9dca7c8a842b8e497b124d1846936bba23ecec4fcb91d2e448c19ece48b53069715b0da4898f691ad7319d28619d93709d0096fd9437f9dbd0d6522a0936379a10ca0d48a68c0926d9d987959dbee157f02ea1eca1ffc3093e6fb1a09229e2cd63c5c18e839627ab242ed642396708841fe644156340e34cbbe3c66025be6290936ffdac1e47ef6de142b22818522c27bef90c49b330bc585a0093f241078dcced1718f448224e7745be9ebbe8d654745a35891783cf212cdeb390f4860f8904039ecd37aa547c73d35864a47a54dd239721f2a9c080dc9c2a8e781080aff0412670cd1836fa752d6713824653bb965e485c107c9ab83d5a29dba5c18fa2c018e2af1057d9ef9e0dd38fb9486cb6215d7bb820279c7d7161a49b3cc75daa888e9566d99690c0daae8265b025432348b2c5bea34e6d388ea2ab31e4881319b62b424c69889404e6bbc7230328bf7d4764b65b523928f5ebb33fcb9296ee8319ae44db28cc58f9788ddc2f691882a992ddcfe503ef43fed2c431ec050b48e713de5431dee916f0dfb55dd5c17077cbc479ff7442a9df639b54a8ac35b9885860c2e2cb1a3c4c476029c72a4090009ccce8167733c3cd5a94d05a61e0872329d810cc06d832681130b9f171c967eef52a3bea4597900516326cb9da2caedb466c960c74caf405a0c2af4f5f557e969c2701a22d28f153ebe4f112917eca4f79c51e38558fbf29e9e033c70544812d91d037407c41aa142434d13cc5d214190016ccbdf03c737237c94091b508df4bd6fe73e950830ce713dc1a4e0acf52c2e7cb7e304472a3cfe24db9076c98ae50549b1bb03310fdfde77b603c77d67f80152ef12e36892d42a531d7f1fee6f56b39d82dc8a9be0e51341cf16e72103060c601e99c10acdb5e100e029fbeae0d99323510a81a4e07d19fcd593e695be97f0107609f6f9c8c9be3ad3e05eb634b8bee5ed9646438724d1309ba284aa04724e5358b6ebf91858eaa69eb0db5b12e37599cb4424eff459cda52ff7a3ed6f4ea1e4b0494e9dd92806c2f24ada0d54a1cc97f2130abef525ffa773b3316ea22fe2fbc7cdd279cf797224a78e51fcd917ca9f65356301d9e829f820e9dbb4e13334d0bb60e0f3a027ee578adf2bbd47b653633eff8b2ab9f1721748646a0fd1efd734417fb8a2a8957ad68b0188b4acd2dd2d7539f80292e2bc42f65b275ac4bf6c4a8d57d6466f9ab866a275343af143354d3a962980a1ec2ac9f36514eba2654e50a90eed6a732f2d26b2a9880ccecafbdea586ed8c75d1c908be7585d2cc7995c0d5374aaff3e351f888b1f7f78d204102cb6474a0aa87b72224d30baa2ed2fa60cdf00eee33dfca141974d5b46f9039ccf526dede00552a2718343ee451a106e3e94352b3ac9afe26dd00d07b4bf9f15bd6a6577e6a09369952eee7728736c623d93ef9091fec91087aca36e3c2547e79b1029bece3dede7c342a83220a5dc93cb264c896eaa6ed8c06cf16d59678b3162fb0e6572187ca84ef0ae9721e97666279423dd3366ae326180b7e341d8f30a0e1c8e9ea1664220051807bb90c38e5cfff9a6bacdfd8dd174386e4942630b19043edb2168faa4f4b1f8a0907736ee30d9f0314b56c943940585feb3e5d4dadcd2bae0d753d32175ca46ed8ed89531f63797388257d0e47360fc645486732a0715f82838bf99824e50b6fcdb002288cd3dcd07df4e875df771e20fbf9ffa768c2109694146d352ba8ddb7291e6b48916b1dc25a161439aabd8d44dd7647dc7cc5862ddbd4236366484af1c36c9c054510ce9263c977f928a55e10af32cd13538fc6c7eaba805b4e4642041a1aeedd43d519abd38b4f959ff1face9c5ae2f4a0fba0787ad35cfbf5bf7c4160dc3c3273dc93b11ec46060f1abc64008339cc81c78aa1ef15838486a74420f780f0884b3377fa2d2fdb719a75ee0d84b1e608a99a17c86e880b90a359da71f210f16209506e32454bcb5fcb5046e83893d357cb1cc972dc0712e4dd924f4b054b54c7db9be522d0a6b730beee0e96d03f119b9b04dd5f5f3ea4244f3445dc2665e1c2b22c1d97d820a07b41f6c7e3e68ed1f8b028420375b2df0416d09419febffda86be1668d3c578982dbfc54ff396a2a11f80bf03bdccabf42e06a1f4759c7c9f2712dbc4c8403f23f678792d5ecb9c11b3f3757030621c6abeae0a267da6eb78ad1bf2b4a5fe601fdbadad608a623ac549e84399e5193afc2fa8aa4a50445c011a1fb2ddece8e74b9c4236d6dd532ba199306c599ddd00572c98060e2ed24826533225bcdc9a340da0e5ed39daa2d8a719ce52ef3adef26e44b3b1c655000cbe7ff065e634372345842607f91ca2829dc862e8ee0ea0ecbfff029fb7b803a532c82162829f564ec84a79fb9be6235be38446663af54ff1639f10a787333ec0aa16131ef5bb3918ef2ef5a670d9893448c5fcc2a7f878793c785be3cf4fae0907bcafa586e4a38eed8e9aeb41eacfdf8af10f693a6fd7f3256ca3331a57bbaf1ec61dedbf48e93325841601ec02c951fe1ba478d8d6583df2675ae66ee300a5cd2d226fc2f3536178b9727d6b3db58906ecb54e485507bd4ab2b5856b4dbf80ec5f70531243bcfcca55f35d2b191117a1840a62d621c760b11694c0362ef4b3d5cca8deaa93ea711b888ed5dfafc287200aacf2138490090d9e57dd3bf7058491993461e043a8eb985ffa5e8f7dab8d33eab133aa38a029cd3c72e8aa98ef2d38cfc230606bf8bab9eb1a3c2a5ff79543e7125fa3118c227f0493c148d89c90edcefcd255bc61a08721eb17befb0544493c4ea7986afdf1406e4e0cc8403406ee6574786e13ded3182dbaf253ef607d987bde327ffbeee64cac2a1a0f05f600e95b8c3c25b14f39887b6e07bce6e41fd91511f2ecf21e649d9e1497a1ebcabea537c059e4b860537cc89cead1cb69cc9a3a3d33d1c70fe98c447d01af6fb02fe3a141e472d83d0715cb9951dc9db94053fc7cbe099232dc45e1e38f7d6558d8dff44360e9aef3189d810f37ed294aaa59ad3cdc9a0dd4a06f7d41d60586479f7744bd4bd2bca2c23d2df5916a693c6eed35f59099076c365916d7fab2b3390dc93890c1aa558cd7c7a654842380cc9cd081a8d9aeb8efdc6bc6ca2a6cf428966872b7b108807d05f74d4c062bde8577632e2d18236e3b4144a2077831f9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
