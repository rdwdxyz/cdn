<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"59f5ae38540fd963ce12e2249d8e711e3ce3863c215b5ad679ddd84c914ebce073ccf0b8655c21f69eb6c0876635ad786ede38ca6946632fe5cf5decf654de9343817312dcb4556a767ea854bf0ca6c33b67dd8eb884607bf376da728de627ce38c4f436aa6d4e297f3e494a3fb6e3c3f26e1528ddcaa444b1a8ea85451ba49666a3ee206fb566e982c25eed53c847241542801ada3cfbff84a045f5578ec7ed22261a7bb9f45e9a701082a61584b403e0f003b464dc67cea1a3c1ff4958fb08268bd6ab135a012943b207800f610bbec5334d2cc31ed2f3c39ae07bbe6d95b3238212a9d5e40dd1e39f293e93b21f4c4d10691b20cc6d67f66315d4ddd97880b9ff6f267c02f6924d7ed90c3a7de8ee8479db621c10af7a71c056d5c7d8698807a569c2ed15a42d59c0bf754b3585a1d368b4cc96bbe18daf955e1633850dcfab27b738527becefcb3cb31c6a192bec939318bc67479914cf9b45c906b3144dccc7e6ea87d2fa41a91dbf382c235afe5e48c80828a609c690f1dca4e3ab1d97ef38bcc955bd45c75b6198a0bb748b5ead139463b7b5651ff6c6aa8888c78df744e0311c3618746dfd00836f7e3497279f8b1bbaae994638036eec6db024593112a542d8326c81c2a5b49ff9798f06b51db887902cffbabe21f995d8abbba948ac2481167ef12535c015fc6c5fedb4f9516d38a4eb7f8089c7db59434b7cff67b76e27e9aa4b3785f1a5f0b4e5b72d2bfd15cd7033744b6ffab24bef4d05a76f7a59d7f221ac89db282f4961ddacc84ec375946478991a55c255363712b3ad4f9a24304b97e5f7cbf80664a5d010db438399c76b8aec0d4b78c7e822793366e0ad350f3d07d4ab9a7f352a18f0ff818fa5b1029a52b7b00f79e5d83030ae94fc73c3bc9131708377fab5502d1e98e108945c319663fc764120e312c10bc3e35c9e4a80a150dbbfec4f64234e3c2c76856023bfccb9247da87c5d28d0ba38bb1c9275e5d1a425fe743654275192388cc29a7c3e0eea090c5999e19fdadf7f22950c4794ac15336e9492c369140db5c04d391d1fe4f75e8351c7639c0d06d7e493b6c759a91f7663a4a6b9d38234067bf1b9a700073c9305dbfc3ff599d699c13754a965d0761f439d2b567a1bbc42e449c8aefeea1b813405535a0f5b5a451442756f7d439bb8261b714ddb436537fc2a705623fedf99b07e5bda5e349d80bc127f70eb2b7d7b3e7b6af76f1efd75640d0143a29b3463307b3f930ec5a80dea6eed5272aaceeb452dca8721eb581adbd85cb3c287f531a3a9ab492d9226778698111edf7d529988acca40884c4d16edafc75aea40b167ea5998fb01ce042bffaa55ffea5b4b64ec4fc97ba0334dd82e73f775842f0b2f7212a004b3a17fb3f03395122b81234563e2800f8d91ed5c63b05d7a9e666aa72e5b4cfb4a7f2c823086e5a0a5825f03301dffa8d77ed0dc15246e2bca0b200efb1f06cfa392f22b307e07f851427ee4b458d750069eef24228df97c9bbdf4dc2598a1bc6bc5530ba7899cd3b643a259c91131925bcc58de5d213a85a128d0a6533ca0ad99d03ac6d27c59d01e5d29fdfaebaedface934b6430431536875f0abcb5da10a4518a6309da6d698e41ba919f8c9fd59176a3af53d0ef6d88cc8aa18c49a652a7bf24420763bb42f676d988d3115b30551d0785281fdc97c5f48714114e48bfe09a6e189e4a3b51c15c44bba85dd24f54d4703f31b90912162a9855b8ba989c8eed6113d20939be414d1ed205bf76f22d4dcab84767f8ea5997b456cfa95426bc276913aabe6c059ea23791325faccb6451509eda6076882511249a066a700236b0db89ac59e382421aa64ab346c0e238b140a180206e953183b71ad2b63f0ad9c4a2e2b26e96eaa1f86f2c4cc4d7fef83895e7d8c6b4412ad2c3c66adc96257f3349aa8bcb105230ca72657f02de4dab00dfe36dc516f5f28e7ea35d81f6c7d42b64c3b45a19f3b7c48ca18a55a12c831e63669c959006661bc97032b79878dbcdef8d7728f708d07bc49af65bccc7b55f9d2b7fec501bfe5570cc2f7c6bfbe7238d001f7d67e5e705d41a8b1ac6fb0b647984468dc1e55508c292898b7b06b89afab58ed520967c81a37ee687adc3b54ac3ecfb112d165cf7e1ab7f7b2f5e80a74ed6d8028931a58d4b068f98da76935d8e51f49774fbb117a8f4e8ec3ebb7602b2143bbe029a382e4abb69995c1d0b42b7b08d65d6a5acbc36e2e95acede0bcae93e8fd7663b44f7e8ff3f29051416b0bfc0e915471c42a033173b339e0764f5d02f844c420135c94c592a96213c860b803b1a69ce62d8733f877cf8890bc90b4fb77c19e94860555cee0f255973807b70ec78eef84f5310c656e3929f2b15d91c33650fa9cac5c7ca2f65ab2ae617e319fd90fddf9bbeeea19e03216ae1423671b1c5995b9515d533a4c98f720b4ec54607f664772bc98006592a2beaa581c9e86f6ed50f88b3f56a5b6f7eba823a6147e228344ce1577e801357984ddb05d7443d24bb83d2b377b871bc38623f6c781c55d14ae298c6d84326bb32caf3e6ec862e73dfe0b73ae48d99d6ebae94c3956bbf1dfb5f457f4b0afd0c70fd6d1f4baa84ce2abacc96b90124c57330f11a86b1b17d74c09f10d65a37793efff82234fcebf2d342fa3478de8aa83c71c021a894927249a3070d576648f87e98693221117e836b92c2e74ca8b58f70ca1be96ab23e79a59906a07beea6b4751814946bf6a260fef03af88a4aed12e5df72efa418fa9fa5ec5664d6cf6b64f88a9d2cd69e2327830da55d00bcd702b25a1ed11df04f2b7dea5f7ce558a0de58fa20ca558a23b9533d8ea2eb8d77a54204422699c35f8f021f78be46bff8b604dd719c40d6f6761f3732dad18fb53941235a554432d99454104bb43f401c49f6db751cad292213350499184ab1423f622c6219a0270d170b37529de28bce27c0d4c183bbfc5c5f11e5b01683e6c56ff0adee68d14269d46b86dde32a564dd711489e352fa58a52a8ef9cc4083b9039edd7d17607844504c4dfca57ab412fee42677c9530097438dc53c5323e859ef778284f1cee1a9e9c7b61371e0dd9c41c46920f06ad8df0269f1d1b85311cbdcf21159da6baa4a1323392c8ec9ad8e11aa3f2bbe286fe64c5c36d426214fc3835bc4e9f3e30f3ca0369507821c5dcf38ff3c22d3fdd5cc5029564a4cc243f93df2dd46e0e5be8e8da7c1606595b7393376db89385b2171d22d16c89d95ff2f6d2d3f89e6ec05d645c40167db249543d4ce68e63582a2a42491666bded67eda4f6835122ab9c235f27d73f2629dd66cb8bb3ea303a17ccf7f5dee68e5fe07e23ad019373b27e173ce4a3e984afcee438d229fb965a6700a952bda93b1af5d548be6d93e240052fd0985e49961679ee305d672850dbb68d2e762cffce0ebb591d25afec301be3d90e36953299d5a4452db8cda63a5f5493ee6745a94f1e0ca24fc8b2a16d48fa77650719c14ae26ac7223d4d7891c5e4879931bfc3712667ee90312fc874869d644b31f3ed5b6a9a9a9baf17973f7aa8ce8897340a84141a25777332cb346137a7519492382a2c8f281e389e4c0c0ec0217e60bbf3bb38a1e4283ea4c6e44cca3bfd0f9421763056c24a3e7653a86e8f95ea2a44d297d6696523b2d9f1a3ba4a42c7b7914dc6e8354744f79b9ba6ef5d4dd28e0e35daecd42ef6c20832b44d2dc7a5ed58d773d4c834c90b83c58cc968bbf5a3016868b336f870c54cf55437e3aee859f5178125d21bc7fdc8fe91f02659804ea1018cfb1fc0f2da755f17aa0105578a9f12de6fc7abf75246413d0faf5df7657e9da03b98ad926225a85d2e42d57285d5e297955044ca8b72098c101c3aab0bc7340ab96dfa0d2c3e0e15b195fe1c06f676e7f477a34d78ac386b22e7db87a73a6aa0c1d939e96defa64aeb66224c8b545af6d8a9c8996dae33af2b443370d283f61851b692495f286ba44d1bb4e958dbfe991b8fab6fffac468430cca4277c5cee0fbf39c40179d2a8e67fd19e3aca6cf9d2041077df4fa6edbe9519016ecc064062ced2f7437955df923acf40f8bee8b4506d10a08fd1a4131308fab3c4218e9dbfe5cc373456a87ffda010d9ef4e696e9fca83960b52581c9c294be43618bf4b15b6eb2e27aa52f86081d539d09f4fb83152d0271da2162a152ca7ec987cba81ced7b4b82feeccb796204c0f8e09715e0e39b3ffab966dbd1e7c11d6ee3d26a65ece6123015e4e5306d0bc4dc6fd3012ed0615ffc163f5b9b5f57fd0b331b0b4e010cc59bb462ec88fa29c773d618f998fc4dad0711ec2150e9ee9910ac1ffb2ff031efccee880701ec88114505699d5d7f1594743532745be48ce1246f70064df905ebfcc1879b7a260e4f86a11ecefdedcdbedadf9969f1a8b4c55a5756b54b3754233721bbd4189cc850959ae69bfe09baf6e5dcb1b1df9a064c7c2d7a49afe912faf732ca6562b2b5782cd5046e5f12219cc1bd6e268bb5a8cb96c009840820b7c69e87a9ca8eee842fedcc50d71a2ada31b633f73f5620b534420fab86264efefdee89d2e4d5d160309cc2b17feca8c566fb140d2afb23ae164398265ef51f45ed7cc2f2ad714ffe24c87232f225a18c40dda1ec31555ff048774fa7058c28849a0effa3885a3058f1a765ec332b22211a5eaf0eae89c96703bfce20dec37aeba617a2207bbee9c12c4f00059421dac58d2d8a57de63152bfbc19937ab11cd57ae7dbb7676098c217782ccf35c5ad9bf8fc748aff5ef45484178d04eba1ee96fbe9fd5c643e28a1560624191f0d575b8731eee307d724fcdbb1e91ee76d3f29cbad47c2cf04f9d37d75382a5de106cc454c7898ac259674fcc1d2f176d7723d566db02692c6d4e5faae28280c7fd196bf1b0a19f017f4331671ff2e8c359051da1811ccc1e4e302e2f85d4472b0a18f277ebbbfd08877d855562159a7b78c54b2c77654ecb526d0fbb4f80a39cb0b2f7e9acc2fd103bfba4b88317f2e3f554e5fed6fc7e817f32c9baba3f287316e198bbed2cccde3302eb7868f3d2f2c1c9d2faa90921a07a1be1b32d2344363d9450d284609ce6a89e84643cc35b0d640e59bfa867ce2c24460d46a76d868c675589515042d399f67dc953f02367de81af04c202020b4014ccb88fd45e86357c5b4cc8a09ef17790a50a38690b17572a341aaa7886acd6717948e4cd8ea5e0a0d37b158f23bd56f728bfc5af3d25dbf9b37ffdd2a7edb34600ddd9f8dcd291c36da9a6f227c6c78e25f61ea3673b4244d72d7dd1eb750a7f2aa3dfe7e868f656c592c2486f29adda558563b0eebb5947756e55aa83ae14e1c173601693a6433464bed6d366154c4fdc38b1cf6f36fef63026b9377795828d7009ff2afe0d2cf9390a6525512c9dc53a2fd8f65195d498b2a076221a9c253a77d6968bca477006e960d5eac1351ed74b6b206bd8686e11e521bdd9a89b673f0bd377f96d94da109d2148f282db954e1454e404ee15a516f36b27095bb2c4cbcddc369e6be5236908af4a74fc84b3af20e908f279af488d97e6c1477aea87cdaef3d29232a87c580f5fe3616877d13a94fb0905ceda0e3005400f498b09db8e093f46d56d1e538b87eb4a6d6fa4e22c9795aaee2ce778e57ecd8abd81ffe59e01e60878f9b3bdf765e4fdb3433021c27067bf872adf614b8378cc8d071106364ac788cd41aa2c960c7e9abd258fd674f52e6838e7d7baa4f3880dd515cbb0bc18906ad9e21a1f2a5c5dec6c826b428bd0471422a58eb8d9a71dda3952efc05f60644e48784c694c65ba401579572273db7c25641f0e75c9f46f4278f10f7c5ef081d468b6494f74689be38e9fdb6a2db8bbc0b409ba0691c3cbd9166c91cb3dc23e448f539165917e3c22b9a9151b639f84a2356ec01e9cde32cf16fbcbe8273c24e786b9bd7339ef6827b8b6185c9faf4f1d2f4aba71d18633b215ab881ae3643beedaa213065ed33b7af24d135d8987d9931abda393d3ca57b8c1c8e83e999a2b02286bead502d970e17294e6c804cbf6b6896efc4fea145dd7904e951270b471747a96dbc68c809ab752a1c9b41e5817dd254cc996c9a07743b150d19dc40d5e0cebee3cefa6e6cc0e780dda3f6c9681a09c8e197b2115ca1024e41c15a75daccfdaf148d4266a82ecafa09ab7235594eaeed0b7fb00bce9fc776d059761da2ebec0615b2a973d3a35fcf8bcbbfeb99185363689c87882d5c9f7e4babe46d3f83b88c71aeb57490768911af704b95e9a5671c2857861792dc3bdfdcc826e3a0677f4e038f5fb85cf3538791951c86b63d7f22904e4a9cd5d6f8209ff73a40b1dbd37094db459a0c01e4ff0117e12ba8a5787e93fe561acd851cde6d3d57e92b9cdc979dc519bf230838ff623943b9b5ee27f6ffdcac79e4d5a1cca993dd98bbbe900413d8192de1894415b366f7068c0ff2077ca84db18d54fa1dee17a3662043135129d63834370a4eda1fef8d67d3c494e08ffaa4b507550efa3e223b5efe5579ffcfe6c5b3e3bd5f2e4968ee88a7466e768dde84ae808890eaa5e152ccbee42189caa96a6d4b5f0c96bb910c7a5ae373bd7aa2ad4ffb2b43d2c974a69501663edd58d5f9bb53db5307cb271a2b81d4c0127d2aa4933585b1d4995bf9bb1bef263ad42180de065dc6374faaaa1be9741586b4e02abfe7b687d4b19be78462df31e71b98ac61647c366af8612102b8db73ecdf19d87ae7816fa0a75e22d1dc819bd3fd5c9e04dcc061a185282f1990359d7f30971239b7cbba5f77002fa75b30a53c79b577c313a6879a07b24fab9adfa7ad2950ce0fd58786d812be390085e6309b001ddc10f271e7714e133401937319860733d9c0e24b567b429501e0b941fe141713cb593f6fa4876903121fc154b5da5fd141cdc5833e27b825ad7e1b8731b6a541883243895b941de3c41cb6f2be26147174e365ef558aedd811a319f606490fadd8b44b548aa5abf1fc52a715ac20055a487de4cf95ada16dfe6f20583f040ad23b2a9e03a72e1d5c907be56a76e934e27b0100848a902c9e7b5f7dfefe993a3c8a3eb22c397ce38bdfc32134e9f6fdcdab06babb30c67b5936a26b8aea156fd0f1f6776c4a7efe7cf9929b76c93fa9feb5c6db29436cb1b08761067c8b6fab030e176e58a18e12d67302b0cd42c53517a9f4d3709efe85805dfc459e9242d4f14b81679de24a9036135c50a17867cb01a7d6b2cc3b4cc181b5f84ccfad4ce46c80f7b7c1bfd91297b9d4f5ccb03d36b93644aee4d744bca4a326adc79f81659abc17a9d818af91cab134736dbb27fc4b21ea189331b772909857a21947246666234fb7bfa50c729e745e87ee42196650c7744aaaa26cc35886529d25fc0cdd2d7116432e49928a60918797c32a4638235c11e68c1f3664bbecd47168c75270c57817368f5b4921b5733448bf9eb5124bfb9dc86b3fc2152ba2092be9ecd4bb57290125111d9b23cb4a92c36d29e673cbb0ce94c3ee14431f2e0e8992c49449d20913481c90de4599fe195701d15c713f0ae98e96c3d94b02b2fb72344e3de6e0b0063c72f9c8374f061f59c36ea1ac40d934d1c144ae5ec5882188f679212b5fb50bc72817c9db7316343f0eba422cac5cb67bb72c13e710989d6ae7c8c97dc293064aeddf438b23c9e3eda165b4be93a1ef62d113ee3be64c60379e8babab47c9d7f821b9c62c55371b01e7ef3164f9c078c903ac8b3322e8d336229470525780eadd0f35f39fbfabcb5fe1cf7ea756318fc32f6f351e3f48d666b5ad6677758982164211531f380fac22f2571f23efc3e6e8d9abbb7089f7c6c0be499f9d82ad478b384453e01c3a356732df80211cec48d67a3d4511426f073261a371e22331dd8dbb0937f20ebde357966c69093a5b36ba1c31ae96bf69320bbcfc7cf386667de26512e5135324829e721ba4ded044b7d481d1b2cbf2f8e55168ab8597eaa0b3dbb6503934ca543ec91c7e048fb7434227709da3d483ac1ebcbc42937532a2ef5d0b966f637adce9038f554ddd5950aa5a7bfb7364b47c0d82a5995c1a6cf8526faec5d5b89947469d7afc743389f1d9cf398208cc1f63343bc3c7a2f93001fab1697159e163f71af53e5e29c7408dd7a361cdf19fd3884e308f891415615986fb266d79a7f8794d6bb3b8d96a195d31c61eaf65ab5afb9e679a44b5c0b3194e0f7199c3c534a6040f491f00304c478e42353ccc87c8cbea0941595026b74407fabe5d9cfb3776fdbc28c9ebfbbe461f401fc4b88cdf8742115c80d27e619bc0bda3a773faf924c479fc524ba08f11852c394f60461f7c5dd5a004a5c57f31301d482826febbedfd58851185d59815d2690a2fd55604c467a6c24aaf8170b90f0053195567852a8959fc9d288e9a43f5a9243481e9c304ed57161f1089045f87f0e4a48c7ae1da2067611286fa03d34662978bd8a78b6069ae8640db0c108a005090c6a0f52c09be1283f8e299fe53282baba12c323d5fe3475177a4ddf17b3dcdfc8c7e616d809d21fe429ad516e21490c305333adfdc4e2e15d6fc6529d12e3538cda0fd566d275c325511409a371f2d63b41cc4b60cc26ebd4dab2aced31ca87fbd7e652eb53af04592cc99460b0073d9e8c545f20a2a80c06a276b4e19ad87958bf52c5233335437bf918e917dc2e1ad094b8b13323708109c777b9acbed375bc58e3247da8059bee5cf884371d7b1b9acbbd47854b55d1d2168765d9eb5b0bcb34dcd2a13a08adb4a2b939d487dd5b4f5dab0dc3610468f2284a32c4ca9920716c4233cafa648cfe9f19b899e77b72170d87015cd87b15d849735f3ed9491322e420bfbb1bb9cd3a9eef006c0413c1af36ed2c1a872c325cef78a11d222da027d7deb37e3f2443724e79c96ce10d0bde142392c8ceba6677e74bca6f11f90f7fb4b59b22ff68ce66eabebf4b330c2bd22665909fd9a8ee45f7c0b0f613c9f151fb6e46687a6f6a28a532704bbc5d1c518b1dc817befb5bb63f8d86a69cfe15d7df448513963aa436df9fc2b53cd6f4529db817205b2d7c8be114ac4cdba88b5ef7470421bf76952a1a0bead04dcfee66113621807fd6a5d03762d18c20bf2225cd227930eb3eb226e794b15932134d20944cdd868a4850ceb472d10a570698d2e3860616505f43c918c339512971941f5d673d7c0a35ba6f37751596125b75fa38c837ee27a102c7246bdc0364850ae499b831e42c3fa8a9ead7916825c3ca84e876f2f18b1a0423adc5d8e26959eacc43d0ee9bc7fa54cde49b5366ac90857093bb4040074732a4898c1867c78849aa9dbde209c4419d28e96e5f7e872c1e0f34493272493ee3cc0423041ec3a6107356011334ab95ffafa320ef8def8fad9a9897160c8cb4d7d1c273535430b09a1377ffc36f3249efa5ac0c4b04241633a8ed07774da4dae807bd6bfc5bb0dd01ca3cd064663e5f89e2d6e0f5a05f4f6d9d8996c3988057c75e2bfb8ca77b0277e8fafd5eebfeeb26751cfa801a051fed01bfeea69631b0904fd94284098e26a045da1d1423f7dcb113314826dce6ed36f6a7741227303fef033b3f4f096237fbd9ddde1d71ee47cc0a65f3d3ae583a173125b941baae67323aaf5a504022f4df1b2e4ad09abe5d2d3d683b807c8a6751b1e865403676fb9bf7d429fcc627b722ca0538401a05e90be34384e4ff1d942af4cf4f8cd43f65c2d1d8b9d9d0a66383933f72dc57abbc9584f94b94d4829e6327634b16904cc440890aa0c210cba5bb179d5e3991c2a414047b128258c2e812913d31ef7101df49da91418b9c3ea4603f90a55c21f147d123c4020e5255644ce8176f613ace76823c8b023eb77b838b37eaa41ed57854669f1960ccee72781246dff6c51b836e04b2382c3e67901545d240cf440b422c04066c94ddada9f6ce5e3fb7865e613b451e7c6ad83845e430d4991bbb0212cb1924133cd764b1a67ca6dd40ebaea151140db6f7af8cce852fffd0c5d58971d4bcaec70af7c9694e818242d92f9668cd0f84d162f4e8f78c5c910dd535c6eb25afde820298378d97924e3a9fd85996c59cbe59d27b589398f4b375fe0074222746a968a7960f22cf9ca05b7348216fe52c24cf6ec225ebf5f42ab18d2899566d9527fe81163fb1ec8eeff95afc518699fa4e48f41c3faea2350a9b8ebf3085a01eaf2cdd5b227cd76cd706db2c4018bbafbe51b13782a52ef8bff4b36cfb3095ed745a5e0e05ee80d697239a581d8da8ba76672a2669786358487766290acabfd07ebad7fde490bb43b6a1c9a71dd15eaefd77eaaa806a878c2ac37e7889d31227a8d07a4c5be284505cadd01fbeb16b34863d2964639255fe488e8102d3515b169477b8133d94ee38e7961a6405bcd90eda7cfb52e774e7e30cee810504fb4aeaa95816e4af66943fe2d05bef80a92f5991c6c10599593c79dbdf5a4796e64ca698e6238034115b5b8c5690ac3712c1d75feb8a0c8c7aee722246f3fde4239fcd03839aa34a4e2a6aab9621e9709d6194e59bf51a11fbbf4bc525b5339dcf28c2f4293d704383e436d54499a4e966024ea0648b260874c8bee67ef23128ddf8daf1e949a66f31e18029102bfe4e8a3b238a8a0a0d96ae83fcf1905ec8c02bca2b38231e9a1846ab603f90e11ece3d4a09865de58a5574f5f2bb97af4e64415b375ae56ad416db9a21260fabe6487ac6b540a7a1f25f6091d976a682498605c1c33ac246088a884a8fb2083165095eb86e79e3a21e8d888669b8c5948087b95af474f854ae44bb7eabf0a7df0469d15e3b42b402e1cb9a5ceabc21751b80204a9cc51df313b698e9c822e8d3e7566bcab4d4746efb66658e6ef1cf95651444b5974adb7d4bdddb158b78256394ee4e9b943353647d1268e839495bd04af4e84a463f9f3b7f0e2dc7812764d95902a49ba5865b96adaf98833b9daa3f8bef732defe7b31e278b6215f51928dc7c6afaf35e81fb8c7839d31f622431b3d1044f46452e45833830101b9c9e76c2fea68580d24d3e30a1abb87a7db6c9dc84dda2ecee6ef3eeacbb137cfe4465ebfd7e1ccb693485bcf7067a9b2549a6dc2659962b85bdeaeb4bbf0a7bff8acb069723e33327a2ea5b9337cdbc3adced3300b19ece4b028fa2f914c58f7c4a4d2d45e720569e3d5d8fb4efd93a9843fef21722de86cdea0422615b92f993e9fa99d6bbd15292a6ba0b14e103addf1bbc20392110782fd784aa2c72f813f15d1fca8ba05158692a1568451d4ddb71336b4a3cac1027a4b3c01f0dffe0539f6c3549bf18981b3f2dd362699c23830732861e3f961366effdde0a9cadc0d690453bebb84cdb9796f4673e862d2e31c2f24406caa8514022f50041bf9ec224279e8bf9c526873fe6085b02ef2b1f01978ecef825e79bb34fde3cd2d0e910a473d40d63204e9d4d20ce8da89012ddfaccc8504584d4421f230a4e6fa09bf34967360877d64984966f2f86c9665c4d4e2def411f20fc4f6bf88f7c86059a6eb76bb0b855533d014f035caa1542a6e0197663e92bfcbf01c7b2350879e4744a2c4235aa7f68588e4fbbee0e47dae3562f9e527e6919807d7c5eba54f3066629a4adbd9e66c55fb6a2f793b62b1dbb6e5fa4abc1c438dbd1349d21043dd3a8757db18c0e13a7e67a4d75d07ebe9a2901fbcb0e8e12345a672c5b1fb8c73d9bb4fa88449b400c375a5a761ccee5243a25fe8d43299c1b1f4ff7646f045cb7ee21d03bff6b7c778d3a6d73606bb02edcdd53d355b7622fdf04e3213bfb795f47cae7be4add26aa05e09ae584f7065eff9984a0f2bede3780a17744dd4f8a31910b8af44094869127e608bdf473f8595c0a8560787c0df407a16c35b08ec470017cd203c077e589a7442c6204fa9291e1e49b46a2be6a913e1842612cf87e5e4a713e30babc8e5e26f7f3b680c0c544ef7fd20ce79e54807f998acc399957dda00cf710630fd8e23870641777de0762d4daa6f1f582e428022aab2bd1d160cbad02f94d45acf08c496b8947022cdbfe15430df8fd306f039f24ebd2f1af86d0af2cc48571bcc2b86b9884bd43e951bb30dcb0b9cbb56451033194dcfdaa718a50eb4e26c3390334792c50a0217002c57388d38abc247ac25fbe506b8c949f663ef580769a128e56e5c197f0d6ca389a084b52ec640c46fb02e98dc61fda7b2a93e67e5276fdee7875550f3c8be8feb4927aee3f0cdca219ddae51d3c961e918affe362204941066c059a6d7d994ed94dec89d31bd099ea48f5eb1dcd0deabc4af49d9a3736ee9c35f20e81179ac0d88b9a101b4d7488a318d857cdd8f45f5cbea7029c4fc480d41313fcb81c2684c2aebe8471a789b4d6ea616ffac18f29bd904f25bf7501c8ee08f7038014a346c40ccefa5dd68fd68adb6e15b84207e76c5d82390cfd54c8736585e6e8a3eeba851744c2627c0c3374b8c07ee3c61e8b1cd2a7405d3d235871c153bc9a519caef5eeca4e31c0366142f2819efb15f2becba9c4c37cfb618455c9a024194d21c5dd3c2a548f3b5261273bb1bee0a7578e0a609172b6bef70cdc09d4f42e6f69bee3487fa75a9a3a6310b81f6a6f88aa3df94fae9c0b2371ac03dce4dbdc86cc33e451cb98c7a4557831161b358e6a400fbb3d6704f6df596d80e4bff5e89c72b1bafed73917bbbd201907b40da26a4ee1087ad267ee623194b7ccdcb29ff2a7a2d937ec6dad36de36ead3ab4c1615b22c58e4bc5d7051ee8be506a1a1685d9f0be351b82a109e2716f0321b713ff0630e578f55cb11be9bf10a01abd84313e1afefd6339aa35a98a0f70bbb65c2ed196289d50a080e62188eb070d1af879cb2550c5fc2ab648e24ac08c350c93072658c496deb0eac56766ab2e0b0165b9a41a7874874a1638c2d4384b7095fc73fe3a97bd7d84d3fa857fa5e0ac8cf878c3e78b248c302d9427d1296ee52601fea77cde0719c24b109d501413b1e71f60d638c6c912cc07da8c19974fbf9d4e08357245683da666262ad3cd920bbdfb667806a29041bda665e4971e03a1364d475e8bc0f0e6de2c59c9d6670f533b313206120f29fed80546a27346b79c8b1f9af37b03a3027f97880eeb2d016ac87b3cec9a4d880f32b1c4d53fc962b34cf5b6beb025d4eff7d2790799227115dff1f8d1b7fa35a109a1191e3a8cce4bc961d4caf72cde34c0710a0d02ab1557dd8b0f38594a535b0b10bbd8b5ecf4df49a3e9cc77264c0a84c30a8bc525b4905be2631fe0597ae001de867e14714b13d049e0926fb0d58bfba0d0df9c8ff9ae0334e607d3fd017e678ba9cb54a27843739eb85c498961f45b0ab1bea3666f37c802bbb7c703107f0331fd4f79af69db06d83807a2c0cf77ce306c3a238dfaf41d33f4a637bc8dc5c49848a96d7e55174dc2651acc97e09a92d6d620bbac61ee71d097602ae395904c03a73e71c715b5cac198b5a0890f5dbbdd552759c87f3f45095213d0d50cd1b04df444ec92526ecb43a6ed7f6ab43f07bbd67b7464c1302a56bf027d66e984f01f38ef2bf53eac827d0a8b0bc4ccf5366fd8053700dffd48322cd135092d209bb2880594f940c6353160db548d61dfaf819a5ee80fae203b88b320e2cc082b2df3421bbbc65228d7f8ccae37313357ee96d8b1615910aac0099bfa91d3938f1396999fe268a49fe4f05b325c110320ea166345d8bbdda66f13be7e473859fe94388656e97d3daebb6b04595be69153deca20b91bff9aec54d6ffee29519c921413c6daed1a766b969bd2f415070ef06c17967c83611d7f5ae3bd51fe574d0e86d62e6cea889856468f1321c44d0b6f015ac99fc82ce434c9b9ff939efe6a76c6baa1317d7dc4d98fd9829f4efd0c302175f4f1b96c6623543291aacbc713a00187de1cd0c2cbb1bc887388379a120bee56b62870558178b789bfd429e4c4989af09692d4bcfd5268be521d2acf8a58c8e9f60483402c6ba8c7e32572effcdc8ccaaabea4921a5e307e312042e5409fda67afaadba864c8ed42285297572576347d6afdb27586e83848e6f568e60a6a2876552c2dfd915076cf69c97e5a37127e6ed3b88906bc0a9426b8ade12c1b006e66639bcf8cf340463235ad5000aaecb12e3087a58d10e4d4941d10da86b2a95fad61d11283da5b2eee160a8e1c81925e608bef1e61aa619342c3b0b295ec06cd7bdd7cbcfef09161bbd7ea2de993f047d8f6f1857b9fe090a54b3c7e3e22c7be4373748be5ba5b4c9ded347cc2e9dad26e3acbfcd6ccafb38d32a18ae241a88a64e8a9272b447fc98ab420c33d42795242ea28be0ad47e45759efd1c0e6f93b34f511603993de533205ea29fef540531c2c55062042a029685c140a93a8b2fb93a8893122cafd527792c75f33e43d82cbcf795d27b2a88fa4ba814a4c4b13b364291521278d3231f49575ff55617f72b465566afa121bf66b7838316bf7af06654d52688b3212dd5b77c35ce6307c8855dc563469f5880d32a75d2cbd7258235a2da857a2bd52d1259ee3b8515fb805eff65c2b124ede64f5249ea7c9d24c2560d95e3b2146818dbe2833d8616ab566a2495bd264ad19b5cf024fb7455b15c8d66d5fb77827b1ea0a8d51699334825919aedde808790414d8700d4ae64e437f7c3e4cc3c4243b2ed0ac9dd530c5c54e3ae8f36775f05233a6b90abcbfaa6a7ab230d60d58a744d47f7943838bebeeafe5f06f09a4277e2361a9f91d1eb173b828f8f4bfa3adec109d93588a8280e722539d2c201ef24d1e300934055f49ad5802f15b3585a16212b91fac944f32b349e80af918f862f1124a73ba42948a253da28c6b44397c43a8fe9e666fe4c54ad17bab66a35a182a083ecc5759f82e5907b08d1f956e94f14edc3f80383935e89c132a846eb387a2cfa1836c09f6bbd652eb42ed7a365c23a466635ecefbdbd65ad645f4af4a645c3a71294d086635f09c6d818e687b5bf4e6332b09364e30f3d319bb92517a280663f1b1cbded571ff7643d1c23172ff2aefe7b0d364c6eb41d6d3ea454ceedc11e5dc4c768e82a9bfe11c65c4639e516fce428e19357041b29a28dd39a0bb6fcbd29afc997a7ab22f7e8d65be4dec29bedd039c022840e28a697bf9cf6bad8075ff26108c7edfffb8f326a8b8cc5301381cd8a5d1270952e2c35eda15c585fd763c677df265f29ed356d2ed8d1bc79750796e93343f07a81130f3808c8004af4ddab39323160ca1040205eb684c841eba2e3aaeef048411df3f118c8e18ebd55cfcf33903bfc4c7f0e1cf076a6a6e2274293d9e9af8931f079c9fefbd630fe2a9492fe2a8317507c9eff59047082fa647ea2cf81aea65d3600716cdafb0d414148d97ee7dd120d4f6d6e24ae42fd693b7557a16387a1397b19a814f067c78bf51c68333a4049c9a1207e4bd6d1e68c1e75c237f1fd8dc2607ee436136cda13ec114d7fe329ae3c2103cdd31612e2fe54c4c5ad5d656302e42400ffca43521b3e49f86b338cda7f9402ffc1838c60cd708ca25e62c67352ffcc87c8cc16791ea5a9c8ce193f9e9353c7f52a65515580f42eb36405b4b20ddd5ac519a27e89081bae9e80d14eda7aad49286bc3b57a69bc502a93c20737824d879a705050ed0ea1bde1d60ace8fe14c9b875e709ef087a7618c86a8cd090e6e4eef5b7df2d64736c86261d7a2eeff25c940984cb49b57798904f56f0302ded090f7356d7e26f08b6920fead1e9315162dd788dd7e06898ab40494d3cc9df019d2050c790e6b938c2cdc7af0381fc01b8b58a1578f5aa93584cf53cb4f124ad2d39b84e06db80d91a26e3d74ab995fbcd347c4fd57ec2a50bf8e2c8875419a2a01eda7357fc4ce820bfc6b9bfc23a398e1b17afb40bed0cbc3729967baf4e6863e2f7e1fb1005e07de5e78ad192d15b3a05596320a5530625d882af136ece9d71b6ba009bcadea332feb2ab1c8d98aa093096a8bf2233bc2bc78880ce5922fd735692d8865f17be8a123aef3e14f4e8ed9892b5af1df13eae6b488d1712ab0f79d3f403d815d727128027493afb52f88683833def736e143811293cb6ed136a25b467f4249eb02a0b8cf36d4557f3c8ca8834611eb2049ec7cac9fc07d8c66046fc0d99743aea0eee9dc2d62567dc16210b9215c16750874041b09d96adcff605165c5aabb3b66d72cc271f8ac87e3f9ad31c7ff6fae107b172c254031ba398a16c0db7f846bf2595066d6181d034608e33031c3945250c4dd39d29323675be30300baa8c4dcd9869d47e08db3fce09a7fec4c87ebf695d9cb203e5324774a4ee7f61a1d16262df2eea69653543941a47a8be7cdd522b2aee1e8465f228bcdc8e44d3702d5da06449463dd99d15a1fe8e763f0644c89134c46b456c846df03233ebd3c7764ee4a5a466b992d6ee058a1b286fd2f0014e5871b6a5abfd739ed47c64076473b3258ad4ab1fe423bd21e0bd19fd756755f10d0a65fb5cbf7e3bed7270fea662611f9a914b1055220d51e5b03ee97fddb8e628b836db443d2f403928b2b3ed3d6a64c23e7c6def425f4dbfce848f0c64c66ca92ba4c39ca63431382dbe3fc528390dc50d70666dbce1372ccd565ea2591047957798167a576ac713bd32f7b3ebfa2af996d3f0b9953a284edec6086892a8affe5318ec479fc7038e717a612c0c2f46f9de31b180255018d28e0f2fb5bbd51957668487e422618894680ab056391b1b6c5566421e92cdc0c148fd4862f4a837e8db8337e1a48ab39e99d1f6aed23034c700013d65f96fcd6648bd8411eaa7f8adb1ee93477716bd6cea7ec70fb8108cda64fb7cb2a70048e81fa4cc9c8bd468f17f10781e0421fdcba86ceaea86e859348cb03350ef836fe7dfbe7f82b208c346f5e9d1e9337f13050d66583f337350678777fa80a98c28e1200187a09b6c0c7c031ae8b0f52ba7e5a85f5c70cf12df061c059ce616b91a4fdd10bddf9d5cd336c1d5fc19a529f58bae310fd245c107e3d4ccbcd0a7e0315a76a94acc538745713ecfce17c40c5b0e46d8c6a9c5b4047026c9074f875a6aba98b9a5dbf410e84ea150ff77232a7f1ddaf7c1e533a09c73fa39f25f1f67c91fcd03e6b952168d677917f2804074bf3012f40e5293eca205b2094f16f7f4445aaf74906493893173df51a8bcba48554f7745d5d46d31e1c300494b65431c1f8d12315554e22b5af6ace9ee7f234d4bc351f5ac20c1afa420c7d6b085cc6e2786dcbb0459d1ecda130147aa7e82621dc4136e4fbc3fbce999573a3b8b0b3869917e4e15e7591662eb7b707f5203462a413492379cd74b92c1a193841e1dd0ac560e10af09afcb4402b346670069887f0d4f1b2c4556cea8c01f2326ac64084f3b62e2f457b9dc0a2bee5c0e2b937b13ae43f9722bd9e5aae2c23d3b4deea0790a8b71c358d9f2b31d16f52c307dbd5d08c825a2355bb09fdc80bf71760bd848eddee239b72f262677d9882f2362e7012a33bfd96ceb43ca99ca2683ed67d67c56b375af776a40cde03d407f9aa16e3588afa52be709226b6b0df04dbca5ee56be570ac70a8ba8c90f519d84bbe9ed8f30a323036120271e64d50bb5f65b77206a63c4720f25142a21073ff1f249b0c73289934dbf6d03505dac130abd35b9dfd8621e8705b869dd7282a9e0201073f9e253b1c94d3b6fd66b2a86964658a097ec8a4e8fae99ca18ef5f23aed6e5e4c470628a6fb8d250926ce7b51d71724e4bde686401399a623e1a1a407e0638911c82c34f8db89ea1ba340f2e2c02873cfe41c61d49f44f5f634fec5220e3d9a834032c42117305f14bb3fd0d45ce87f45a8e004379fc262abfab61e09c519642675a9f2861e2771c9d3095dd2e6f83ee78fe9cd3b883dc07f773689c0025b0ff03a258a34b86f630e1dbd416281b3ae4352f22c890a2231aa8322178f589df8546459dc61ebd1adc844e320d984a198ffb7d1a76ad0d79f979e2eca96213f7f206009523c7d9660e0cd6590b1ab976106f9c4a93e68af591a243ee72ff679c52700ecae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
