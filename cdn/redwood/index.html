<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"61be5d92daf19c38133619512702f561e5692e74d7eb5437e88c2dec297a7ba0c6390477fa4455fe48c279eca9736312a25c80f5f8ac11b73027b88df04d7c9ec423da6b45fc4475ddf752457074cecbc0ac55d1d6520831c4b5901f2a5205d763c29ec89497f4e455ac4e5ccc621591a0c768f90f3849337e35619bbd30c4294da643543dd3ff90c3ab268a4a9376e91c5db4d12462e8eb0b8d42fa0c16f3d21706b60212dcd8a27d09ff527834bbc8f1f99d293bc81bdc87d93bc419592e5b98f6aabc714690d8e4bb17e79a960134e82c8ccf503871e54a3e5183d14a6cf8aa9ea44003966aca7f39ec6637d3057a2fa3acfab4193f8ac572ac5a5eade56004287a5dc6d847043ba38b4ec39bfc415aeec5ed7c05373085445839fb42f678af1c4b191c92b9f18bf8744d9b805db201bafecf539339ddafbff477b1df1d2244cd8acbd875268bfe9d23e39a3d41d34076f269a0263c0b891ef0a8f6bfe0dddd1c36572861579c5b4288719430f3f50e2b54deb13d965dbd720a7ca8b4c422e15fc35368ed3ed37be6dfc33d2cf2331441f7ec529eb6fe71fb3fe9489eafd33fd4a83c7bc323ab300c55ce5120471436d1e2451849c4f80ac794206a6bb7095f65bba0a131d6251952274b5e3d79ad07d26805387f58acf6b6af94256b1046371b9f9a97841b42e3296235c840b262df5f8b2776a4d2fda7257c84c8aec6dd840f3d382908d111bcef20962e5f5609140256155e684b5df22afc6db470999bebfb205d4975a69e14a52c837ebf62c463f5b10a3097b90381e89a0af242ce3dd079ded9b743ec6630744f00180dfda462267967e3a0aa1c125027c0ef65e16271f26f3e3d12d3943254ad6061f7d4b1f181c4546424688461ebfb15f1d8ec90616ad38d7cda4c009ca17bd4903638a325a83baa9177b0d6adb216cbd53df1bf00e00f599059e45a66446b9afb2f038ee70d2cd1223f9f6d19ea5468c8b3e9ce959a1d001b506002527f3d6acbf2f6cfd8a98476ed628d1f6d6734a24b69facbd4990d0bac726397ffb857674cd72823c9fff9242a3a876db8df571b3175eb9f251e7489529b44ad3a75c7cd247cda84f51607562e081f931be41dd0b91c62a9ae61fbb20db9ef20dde5e381ab0667a6e0fdd6dbcd933cef73a7051de858a1fcd89ad6015210a48c1491cffff05dd9e0f54b26346db9c5a023c4693e78b1159f8bea263d98899e397a747c0c4f5f422a720530e3e927b719dad978904872fe567e1fe28c9c249ae2d6031477adfcf9ad68603d81752339b265b3606d562ce90c1f3f6f083edf3731bcb6bfff43d6600ba1081522dce415b96f83d60d273a4fe8e557c857b4bc6fa0e3f5c4641cb2625410aeeee7d55d73e9b033d5a5907f2503c9b18a6de66cc303ff2ee7cdf5321002a558566064b941b1ec2ba1970562ab87095fd06801e414d666363e95beea360cd54bee627fd440bbf8b7ff40244c68e62de1aa984c6562190f118b4841a236d487d1ad85c2ac48ca8a233ba4deb9b8e72e4e825fdd3cf907bfb649c820bad7413600d76a2e91668c85ba48331666a69adf8d1cc12c3f8f25202956002d4837d1cabfb924afc6788f0d172a56f88296db954ac552d6fc288a9404f7eb272de5077baf73f131bba618a24d8dc9a1b875098759bf719acd933a65d79677e7dcd9e19e19e2e4d2e704ec5b76e95ef79f93626cac62541ee332e8d28b45f9349a912c814c9c4729d8000af06e114fb8760793e70fa1caf576ccad54385efee516467d5a8bd25cb61f45c011d25fae5f2891c1a20f67e5445688db7aba4c455c0eefe7fc8c7197bda374c16a2e902cb5e06dc0ce5436ccb780468f5739173d7ef2b1f5f9d52f8e9cae91022e7a82497ccf42093ec511da10564eb4f0e39333da35da405eef667e9da874aa3114119e123928e5a18c823f434d2f091810bac8ea99d01fba3c91a42281cc7823d2833d31d38c5f50cd05fa4f51599fa249a3f06ff03539ccff49350e8048b116a40c84bcee00922d0a85806931343f0ad1441e5c126a69cf105826cb2800b6bc9a161134b69df6cce82e81d910d51fce96ede1e2b38e73e3c654bb3c8948128ba744515e202dcd7884af16cf93ecd9969dffd78cdab5eecf484c29af03f3206fec9e1d6ff0bac82a3140e4ffdc4d474e6dc702e10c9aad67217257385719df3467bd9061644b431dc0fefd84844adb9467309255abb4dcccee44005a4ecf821fe729b82c7914218badb2ac914c7758f2aa92d8abf279d6604944f8692225fa9c6ebba8668ca60af5084567f26ae00d4d72f083752774f6a5d0359d14e194e7a8b431060db439a2a934b031dcf9f0885a4a078d9b3ef5f99bf422711ce98124eda1fb0be2dad3e31f7a8368c90f9060494d9cb4a6a32dc366d36c418047066e070e96f66276d7b6a0d854694361141ae94d56de452ae8f4f6dfaf873774173686288b669fc52b1b4f510aadb151171efa6ac805be0df88044fdcebefd5bf15665f4c68679bc1cdf57ad80d3f68cefe2b4621f5df505b3ef990c5dbf4d5971e65f1899ad324a33de03b2303177b61fc504f9d9ad9c31feb8d49121f41f8b5b9c40da06427e866053ac892c52aef256ae15f6cbac8dae28b832556788e8b09a0eae76acf45c76aa4293ca83f111ef226cb4aac9ba984826c6b6cb59d2c8b1cf8e493fe0eb818be94cf2286f88eb5a56f81792d94566543d0036f86342267f758a8903d73a488fe23b3056575f78c54847a58c486e463e537f86d0cf1a361431e1f7922c92a8361223eecfced1e32bc744279aa52d38923c87a18c1e1a6d6b632adbc80d992bd6fea68e0e634893612bb44111d6ebdd1fe8a452f2b6fb0e6c5137d945535200c217dd70b79a0401e258e7004e81eb3c05f2b490dec0017d1e09cb9b3e9d7c792bb82c4d10d112476cdc980fb583b9aedb57ec068c9b57c8c87e4b16d3de8a8fb2d35b6cbb1b4c3876401204ddfc974ec2fcb5190d557c56c5872897b84e8760e0300501f21115c0bd8cd606bfc96534cf659d2d7c90dfd4735c026c457f0c2f109b107a327b601a0983ae1f41c688ef15f24c207aef02f738582d1246f4ea7292b35e7f959b2568d89b7722c69d2af1268aab1515fa9ef05f55f7ee58aeb8a7c3c6ead299b9cc0d66f18d6bcb97afa48d2991eeae9ebb3920991cbb9287c88d0bbbd03078b52ef9be5f474040cecadd6b3a2388dd1ca7cf0a0ba24e0828ffb304f52124e8d8ed2da26186c051b9fb24cf48d959f87e112a3070496c473936526f4e57549ea7926eba2283b41fd92dfaae136286a1f9e9efda6abc94491236c9a95e80de8611c4beab8a4eae05158846e21f1eb82b27b77b0d2ca47384bb7e4993b0330a5879e5ccc2b03e9f06eac1713515c127bb59b45988dc6439141e8d4509557aa4f8d62f8e03deb080fdf057026da06b914ae108bd3ac6b8a376e71c47d6904853c239b938ba5390ebbe17f8e14e452b016208815c4a5f88ed9939cb595bac11d9f0776cb0c939e5755386fcac4a508585cfd68938c3262b29ebfb0e247ae44dd97af70109629afcd596e5c2b8efdbc652fde98f681d66d981d99b0ea50681b3a0911bef3d0507075b783801226587efc74528ae534daf6c80282c478a058da707e1a733608cb5f6369d7b959425c25a1eff80de2f4d85c66008308225616196aeb1ad4865335457fdff65f6df852b844c4f31e84b1c455a8dc3dc62abe5c1baf31bfec85718397c1f1985807b23e80f03f5827f31bffdaec857fd036ed6c608aae92d4dcda859676e22ce3ff40d47a2fca65b83c1af6fa878be0e01337c61b715c87616ec65ac1ed2a2cdce8689f73a6f3ec338e9bd9503807682e18e4d2daa67117893ca7286e375f91fce49cee32298496a0b0ee2cb4937d1740939f498e3f90ee4a02d5be4e8be86a3d71b485ff8fac8cffbd4fdd8f0341e36e334bbe858f61437c189cccd389e82b156a91f2e109f95f5bd867d4a626a2eea83ebacbb43acdc17af460d31683c27b1c686d0ceebe23f754e8f9ee6d270a1925de0962ca3c66cbf527674d79cb0193a9a4fb4e196e48f5c4de9fc05af9472f0a07a48ba6195b69d211ee6cf86dd2271323943d6c31c34d19181c22a1f3179ba0a25bf27f94ecf2c3bfeca0c06e9d77b69fa21ef8f702e9cdc1abac6be5890c821c29a6ebd1d7d2b55e4526fac5c4d9a85f268db681d1c8c219345614dfefc53930af5c4decb1e912aec9595216875ffa963baf5987077af13ebafe7dceba53a74dcb448ed5ac54d1506e310a2791d76ac1efb5046651110d722aa6d00f7dc0178707aa84bb4d0d5e13108299be97d18a80aa1c6c334767c4d5e3b6e4fd180f27c0eee38518e77ab246b832918037d9dcdbf083d4e3f2fbdb8337b85f6a76d22c91ab870b71f01fd68787cfd6f1002820103a3c2bcddc3ab9b58edca1c534a708224d448e82fe527ed12355d3c7d6aea7ce2bb10dd997e4fa941d39f4cdc73437125f78f62fad58b14480981fbc63e60a0c720c206ba4a12b52998d1f8f55037ba96b7c536a15c2a12da8ab1a03e108217fa28d338e406173b034ddffff0f334e9dfbc2bd88c569d875508684897859525500a9f7bb26c7150e331e6bdd4e493982b53d148dcf73c413dac89a89b0b5ecef255c64ccb70212133bba9fb77462a0e21a7d5b98060b18276b4c08b554fbf1eb61dc3bcc4a74fe43ef5662bf58efa7ce6562d8946117fc63ca82ef3b3779970689c3c5c64670fb204cb0289fdc31f48625405817654a3d59157dfd21db54d9051d8b4efe92b0a62b4312e806f6cffa1942ea91471a2b148dfc111ac423d01acece1684752dcd27d38b8ab298a2832b5cf8a049df21aab35d6a9686bcc3612891080bbc16a5ba5d5376a08d9317553ce6d7520c0fbc695b37ce282d7fec69c9e83fa41f2a631981ead76d095164e6b1b86232daadab3b3857f4392c8eb3668e49bdd730dcaa792e5600f50c6031683250d9cdbfd59802e7678e46a0c8551a7a7d9012595052842ed6b5862392826715d16801281828a8b69e0384f8fc153eaaf9292b6b738acc0b5ed9bcf1493ffbadd2948fa88a5afccf88c1ca79c0df1cbb302cd8c65f6ada14189863feda2895566308ac45ef06a7c98e6e35b4d5142225054f8962b50563cd6231451432bd10823345d2c35151cba0942dc50bfa82ac292df41d3b813d1d8b4e7bb77620dfa579802e6535060e50ebd7bdf7a45939d769732dffbe560cc4c796f8650cc64e14743080b9288873b1673b9666f78565d0b645c63b0332185aa65dda58a42cb5003328e56f6ec6f12597224f1d51df99e39be23343bbb726fae70bc44740c2df0618991b6482bb99679636a684da16513751aa69c6ac97aa6624f9dfc312a1c032ca802df8fac40ffe7f01af724da9f5aca9bc61467efc5d3344f471a6c8a31a8bde89b96ed45462b2914e4d88b44ae35ab023f9e8af2fe2987f3b7c99af1071a2062b2bfaa9c679ad432016c61be4d6641349bb53217145f9489ee36bbb1db8225d76ce5ec48b52716c3c3461b43ac7c34268f4b53020558b1bed39d7f34881db15b6eb1539165fdb01a0639aa5dd17f712a54ed2f6eaa0a9eb921a6de3a7a557f347cb18e5ce31e19f06564063b030277dd9e8e96fe6848c3f6390396985905b01219d13c2c3c5a7c8fd9a442ab7a8879ecabeacd4052f52d62ed67e6fd49074d5aef8aa5ce84088a3e143162b8133a83510f3fd89010a0f2aaecb299ab4d583957d1f94ef2cc946d9503572449dcfe9e4aa6fb83079e5f3670b01f33a2117d411606967f303029d7798930bc182306ba0ad85ec715ddc6958f6796953bb4fed4a226103c42db735bdcef42890980a3f206a57e4bdec679673802ba3739f240b74a7469bce18ee7ee211ae61047ee342e1017fe917c290442c2704e737f7ea404744f990a6852d253e0c1aa23742ad614222abeaaafe718ed5d8f5b5aafe5f190d8448e7506eaeeb8d1921503a25cfc16304f1f8d9ac6da4a52f25f74de6da48ed232e934ba429568c8d3912b797f9b8345a838f091adaf2353d089f508d78d479109871d84fe5c27b143daa3b39a9812917ac25e712c478b347d5776fde263aa93edb5e88e82775d0ed44ac3b7d161d77dc5445116f4b13453509eaf3b32ba2b46a6eeb03be95d65ac848b8d516213c956b6fbd19cc33de3b147fbd29e4f0a2df6e015026709fabe0ce695288c0daeab270c7da95e3da3bde48e90917e1ef8548277581738a0ad346234f6310e2532cde0580f88e38fffb102b47e9133dcc795af43ff56b5c57ee3d4fbe6c78179ee6bc692068b23d78d1e0e384741d058cdfb89c3afc19a4b1033d9da6e7e2ffe836badef53d8662481cfe299f81af18a2653ba5e3add685af8517f7dbfe5e6c08a8cacd68785f0bf64aa13794319c5ba14924eb875761c28ec0facbdb954144701117bde83e89f0cc7890d73db7ac207ea1a3ff79647e8e07783835683bff2d5b8335d21274316e6615859c743345390775788c4fcdf6f63bee16bccbe0e58319979bdcb7f0264bd86e8c2f15c1826517567f606d14783b4c7cdea8f6c64aeffa42c3aa53028886f3e543f2d9acc5007f695047b210befcd8871efd41c391f07e33f01676b1672924f730e39cbe301a0c6ac692f52cce4e617797161fd83b1fac87cd7e6cc465027283c9e2ef1fbe27c7e0e1dba7e483f3ac335fe1e149b532a6bf6d21be44cdf3761ec68a9f4361c44fd3072e151780a75280af9f836c4f56e8ef1bf3efe00085d8228e225eead872f07130c3cbab3048659e69db23665ce2acc5d119598eaddc6829cee6a3a2734727e715797a2e90372ed5e6a606c0b969307e55d4c234d769940616e0c3e8f6291d97c7768da45a4036f03acf5be566ef0bcfad3165d6c5fba6c629a900071969e0da6da2cf60d6e2755ae6a058834e0212eec0465945dec0a0c303c48650c3a8e916d0115f354521733e252267535d47a4d56f43c911727b9e6acbbd8df7fb0cc2aa3e33fbdfa61a2b13aea385c23cc2390aca5afa29ca2009e4783b5d78dd5f2edb57d24585bf17de9b4c52ccc2ef1325041f6697199e8a99e60d575fde9589fc3f38a580eacb5f7f478bb07b83d00a70e61c1a322f5bcf837b821a6acf57c472967f7baf2833b93822efde73a0ec8fa939e215d9f6363fc55e183884ebd781a8634928dc6ddd40d547eaea7e02ecb2d85855c7dee47173cd6309270ddfb25cac8d255384655e08ac815cac2ffa366e933eeb3ee1898e1390051228e60f4d1575341d541516f71203ccdda69933951dc6fbed0dd9df13119564a7bb7b40ec2cb5faf70bcb6619692834ead00e1bc906c3934b293759c3601b12fd5c96c21f8b13dbeb384e37eadc2e2712fe6accc6df81f19e63dcca95b2141e7e5c63cd87adde264de5370dbaaa2e843c21d41be114294471d0746979380373697bff3632758c356befa686d67cc1f460fbaa2165cc827f391632f1a6f2841a967814acd1a3d018dfb8f300f4fb013dffd398d35fe4b8180054dc3a62e2b9094c9754962abe227dfe7a504441111db703369ee57198135de68a8581fab46ebf08fb2522e89d566880d9fb3b6c019b6340e8a55cab574af1e574320301ac0887d7e06ccf66aa86eb0386fa98b027550a40453d67ba07764d7a7d7966aa60b11687cb200fffe5261d8c67596cb138890eed8a386eb4631d8a3f674da98427492fa4f27171b84c094bc54d9effaec7e92fcaa940bb4a9a6520a2a02f50c118ee9b8ad9f8e7f39e18b1b980d73300083e6e943acddaf32543b5cf3a47a4cfb5316857ddf0badddfae45778228188edad309449041c901fde832816988a2a55e72b192c75d6994cedfcdb527c3d80f512049208ff5e658d08d66fc82edcc0a311acedfd2df6e9eae1c708d1f83695bd9aa87e4cfc4faa7febb5b8b7f8f618c14cf04107eca7d2a9f9f573ce0231f83fc2de206eca8e1c7589c4999703f7e10db8fc10ec75845ebe9a4a9ff94c0b9fb537a13d90405bfddde84813b23f9d3ae9450b5e319daf22effbf6a9a97c70099b60768dfcc5c24d941f0a57d5c716c94c6ff6de4632c9bad32d62763c4b46af4702c4bced00cb1e32ca217d9c7c36667ccaf8c56a34294a2b143d55a539779cfec5bff4ae6fd1a6fe898a1532ce29f774ed8ef56f6b4882aecf085bf1d64c1cf5843694e117e018c2adc06408cb4aee18ebc074fc04ea1fdcb24d609816b1a636b77ae21ce08dfccbceba6f2929eee68d8da42011374e7507d4e83cf7872b1e7b6fd5413cb968fa98edd523cb0bf735837840c849fa91011724ab34811e266eaa64ec6804b592541f316310eb25e9a28f34791f983132c9b4af99a487045c498f5ab792e56327e969822f7d0c3523b217dcb2e001a565374cec7b61b9be2e2ff12713c80db7c70a9d958157db24bf8584bf9df684e4c9c68efddbbea37b8c84187f6c2848f8d6bca1d3ccc2d5976e2992a6f3d25031f710dbe24e533b1353726366a656cd30438ec1a84ea452d4e9f9fc9951a573ec242f32605a36596f1f68d79d6060921325b03cc066b97691566bb2494bb94a5eba3a097f72349642631c0a1d0b984684dcc15b0f20a17c491c487b67390eee890158534ffbf056caad3066a35041e89a8e8b7c76033eae1d11884e644aad21e8375a2571d87341be569a52326b3552e811334551a8b38a1e8c6f24703c0a4933ec8b69488000ea99e10183a138940ce57aa49c6d700d7ac3af77ed2668e31c93929e94f8d35c5ecd896e122e643c4761198ff792fe838df341f0cb230204cf16daab9ce8b54fad2337a0ae7193224207f56566ee8a0d0fd2d4f5483b2b5ca164c182f3f6959941113f154d9cdd519ce9dc8cc46c21b58a0ae1a24422d134402b6d6f352abb5b8ab729f43b23f2df7b93996b60b6569639c5bfcf28575b2c35b6467c79cc36111c64dae4f7965e40bd92d9a53f0e3d45ae99dff2664c960d0471e06835a4be28f7f64466e790221302fea95453e0451b17fa9992fe8e0f7c782e41e1896ff17812be6f2f296432b7073f93a8c1d49923d5b971f254d014b4f0e2559f6fafec2a9e5d1dd9d22deafc9adaf1e5da06a182fe3f1b55049c5dcc5ce48f005c41ddf3c2c7326c960d58a83e6c01913b3d55193a4acee6c4bb4a5eaf93d513e89bb8c153f41099ad712f98f376706a7eee3fc0e41ed48fc842ff0e5a3d1fbcbe6857f2419ba1e19f5bfa902324d105fb3ef8c9d4934818bc4fedc2909784f5d063c37ba8dffcd00bec6c4b97510acf0a54907f6d8053677f0056126dda10ce6d2e26d51cd87bbc62b20beaddd0dbd351456d6dcb28beaaad032fb3f038878d5a6017249fea5ce455bdd862bf420767adb9fcd1536b3e6f92aad08991c3a9fd7a5617079dd79107c62c8054738e6e069498ac27fc6aeadaa1594e0e7c28df13133e2084cc8414eb4ccc8cc8a012ecbffc4b1843255425a041175430d2203b6c18fec933f754cc8316b8eb5c1a15b0878221098a34e762cd13245687dc93be589f0ba9756c4f0d97f09d11e1632acea1cdf6ba0eb0630abd035d9a765d156493aafd80645376e193b98676f803789329bced105a925cf7c5648d4f2fa0996cd1f86117b41ca2f61361c395916879be4bf173a370ab865717c70bbcc87369c1e061ab4947195473383beb954dc50de1710a696694d3ef8156ee2b539d95d27dfc4ceaf9fd3734d59d3ae5c75a15612667db8ffadb4316d2c2c7bfdfd4e436ccd92ef99372593181a4c1205387b87f00b9410c07a7a798f8ccff1f0132e49835dda20d7805b8869ac59d4bd56da22c21c63a27e851c3040b484f7248ab8f87d60177d6be2d16cd5f007d20399c8b5b0d2f6f4b225a7461e3cd44fdd31e706b6a9b64ac213ac7c5ec0bd30dcb63c5e272b734583bd2d7e1114cbb75346abb8f8f4c1e5b582ae64c3cdf5f4e854ff74ca76866056476d79f776279291db1488b00d8de364b65ee3cb73a0d3c291cad4ceb40e5b5e2494efd2916872665724813dd6508745b05738a7ca687563da80d7a6db4fadc9db0433092589b6c4d51125f70032304e459af668bc6b180450461c89d01293d2d2a24e643a263fb99787b23e65e41a08263338ec945705c4a22697b981c843f011b8a6e6a13acd411e46c2bf3a985e732552e0ce0a46e6427167ba8cd06fb9620099b80d645a0eaebba7970044536db3ec2d2c05f6f6cacd148d1bb9f3d6ffc317df07f2fb0eaf1e095c8bc1df14442717b5c0ca42be59c3cb45419daded14c5730d80fb8f99e173196fab25518f91b9751ff5e30851db46aa112ba00118f2380a050985503dab92ca492f811b3f8426340486cb8b345e52219ad79773b9ebd55c328d122b0596e9729d09a9ff4541048ea957d23293c415bb0c845ddf80313db5e24d8b5f50c290f1502538a3d32e87ae49ec1e61240fd46ca1d6619af2b0ca7664f03cb486aa0e094f38168430121a0b61711cba2b10a0fbe0e70986d784050c9d498108e39c84e33d8613d54e866597c6ad4c14b1c11e5c85bfdefdfac9d23ba59a3131964354217816ef60a2143b9dc88ff908639d1f0dccf17f675c9eb755e53711a36d68fc5d79c54d070b8296a97070fc34f3816c7f8e6a3f21ea2d674bf731b81abeeb85d1507dd265291cb3ac406739c6d2225ac41fe8309eae702809f02a6785cb5ee6172b9993361e656448e2b70a9b3c13d4dc45e973599ecbb83b0550ce7cc30d71f0ea6d8ca59b63c945d72c1d2a504290a5097d95828d370df3dc0ef9e7d0959a81778054a94aa4b6f2f86a186684b666c0f4455c9c7836bf25475dafd3b1e0d36d1fda316bbe1f26554c9c7fafaa32b41af2350f45d538d2d1d8665b93a8b4b55410742e15d04a5217ee35a172694850d6bd0fd5b245ada3ce27500c177b7089730d274e4ec8b628ab54c9de477d61bb87a4edd321de81b33031dd0fe968942c8af483b71ae121aba7a92c4ae9e3fdb4b16b7067d3331a66c13ad7646aaa91dace354ffe9f8d85eca323ceaa1d8d1b204887a29fe94c91e748936ff39e67132625b00147bd48fa207bf43b67e6f8e00204f950c8f0f8f8c0e61ffcfa032c1462b135e6bef3c7791d398caa183c8ca31c03657b741648baab56decc09af619e5ac470becdc157d91c4fe29069954b80fda55d7dc0f14d3835749f41ffffb5a81518968bd91916ea7b9dfe9cd3e035ccf750516841b12127f79d162c2891013f62c4e8e651a556871975d6f9e208371c2aa2b725af9e5de7b3e54b076aeb274272d2c4c5d4ebe66fedfb1c87433fd476bafe875fd04e32ca0e9ca8d01b82c7caf8cd10ae703ace8bfaa33cbab7da01eb35de9e7bc637357e6b2ce926f917518d4dd09a13cf175c0b677d6ff032c111b961cd61ac8a681d76cbb18a869e346beda1f07506db54abc622552b208ded84de6b1925e4db309b57e7ddca521ec28a2a70bf9c14ac21f2239ca3e36253c0e4fde7feb33fdd2d9823adfcd021d31595f17b491cc7dc8e5ef86a961a2f28cee4f3ce6ce47ed96277fde1b3b6f0cf19aaa9c11ba8fcb2b715c05242b001263190267766414d1066a1c4fd3918f7278961d3dc40b18c6703444daa4eb762cc3106be4e1ea6c1393bc4ad1782dac30155fe1c5cf40a2951200da8d67cff1aa5fe7ae3a4c91ae101aaea5a26eb8986c952ff8a29dc336101727d7a81e2c16783a28aa963e96fa27ac7499229c557dea32791310d69ca933d612545a33b7a08dd2dfff279f8c005b14ca03395986ffc260c4bc5958ce0f7b9d443b04d32d45418b8677158ddaac843ce7260b328e9a44bc533810af4b29a1930cb3316793499e73d4ec6eea57694dbfefeba249b9b038903f920c619a6ced9e3fea321f3997cb5bed08b8f3070ef77d8dd3e653737d0a17deb9fefcb57a31cbe85a608021057fd21da3127eb3588ec96065d0d993bc50fba29399138c29352e6edd39717fbca80183ab8990e940de6cfc1279754a171cc5a4f7b389a7dcd2d09fd4b9b9e3dc1cf838885632eb982852c87e59e44ad9ce8e8ca4a92ce17df97cc7032416d782aa4ac4a040ce6f61af9271603adb583a75d649e5f347b20ead0fceeb2358bd8d1ca2002f53c4f31f328983fa8a67420f5978db239b17c8ebb8f564f7803b387d890b1e9bb035709e3d669df9158144bce355fc635de579dbc5ef3387e509264bb3e08e04886fd333aa8aaec4a6fdfb85349ebecdb948a67ee306e22c9cb702445dccbcd539530f94f62139bccc6a24f4a068f2dce3c79471f8490aba5ba930f04709912bb8e9332a8c0e3e9afaa82feca70ce6408589bd24686262bec7e487c04662e230518e4fd0daf009cafb67c41b4cbd7e16ff114a795ab2dc0acc82299b77439aa4b1ac36e55de64cc2cf13f7684936d5ceeb4bcf6b7513e324c31c542ec21578d95792b73e55fdc5643dc5b3699fe0335c5e711d061b8b8bf6514af67f15c4e56774ed2d65def007fff6f36be2cc47b222ad1d779665688e9bb056a839adcf0cc18583657d9f2cfdb7c527f88f9294c7cab4526e563e31ce64e974f7acb187cb2b5538157483a6fb534072efb0cc2d2372e91138adb908f86410515202baeb7348da147090e2f93d242737c3d59156759a11d0188996d65a0d08971a772055637dc5e4e8644f8ed91278cbce1c784d4d18f04563fee788095e7e3928718f6561d2c482e43f05bc4c3fbc60c6de80a6b5b0e3d2a00f7cf255da3c5274972485289f56db2d9a050900ad8d8d9b2ce9f7383390045971f4618aeb39e97476e5c3e0b0398b4c4407223ccf16259db157b55fac903168d69457a945a08848bb9e6d2ca3b92b213263afff6492ce7d0ea3c5602092064ddeede0f846bd78a684115cf85044c06842feb96ff2f8c3a53658da28f287b389ad245aa7a43b7276f93540a0fbd8595b638ba52976521cc0382976835a7f8507f848085bbd15304666cab034e76812dbe52765b707eddc6f98b0ff497e90dd2849bfecc3f3cc42bbfc1f99a4b02775a710bc78e0431029798d55c8cadb1e34cea444d06f9917df96adc46fda05cee7f2499911ebe27a6e40e2b3146b4fdd3901eb1afaaf6e1863e239b9ec86c278ca841f5f17eaca26dc16baf61e423f6ed9551435d102f6d4d9f588b1b11370348725ec18d5a74037f71fb9a23805fd6b78d41ae5874c415c9a1ba69a332200407fd752f3a817d21aa0f940fd79cfe553161ec41807a0721053d7b94d7bbeff0cfd4de7c7ed67d0738e63e4daa551b9f9783a0fd95925f47219e5c65f7c96476625e8a92da88b47cdb81fb0868ebfb5b9cd47734a832aaab46ccc8c4da631707954c55120732251842b70765bd87780a4517a3dd2ad0ec1672e2c7218a182bfd250d2af7a57f735d839608ec747e0ce99405c94b233c427922f930a8380a9d26c41fce8d53dde0604a6adae95b78038e7f578db0228e0ac1ee81d6c6f3b26efef3cce9866d2965591cfaa95aa4a47bec9d6b04a4390baec7f75755794ed3a348b1e515da628f0f1e1c5b362948d7e298eb9b308709deecb56ea5061970c2f2d58afdc9853245e230f53d8ec48b98ac80cf657043022bdfd9214b3d4fabda29005e0fb0e92a0f98038cafbfab9b213a297f931520c2d61ba4bb7ef16a4ff4e6b1b9e464ee1ea7ce1c7feccfb37592770cd839827cc2bd9423f03c793a8149436581adaed7c7e40af8d5b9958bc274f10b8c5064d1e220c40b38465d6fbd1dca7ecd95f718745ddb9144467d7169aaf707fcb06267cc2529b78a0c7a213ca8216170d99a1c7688ce35f606df20e784428eaa928b5ab3580e55adf7176033c3d700c943e037b6f5bc2ee88bc0547f0695c10cddf4608f2b8530c691dec9f10eeb5ed77fd8fb57fdb20a97c1318aa1f7886e3716d50d60eef98e30c9d4b699fb6a278ea2a9ee04ea62c76619c55da39aca5da4318b4d574705537a17de6b02dfebf9d4f571c09dc859eb25b42fc23bbcfb368dab595d15557aa4b4fde00114b8a5ef45dc59b136acee48905448ddc5ebb596f10d13fb3edfc350858f3dbcbaf68ff90b4b2b2556b82541c726978834e99aa6278f600ec06287553f0472b5128b83fa28284eaba00295d81bba95ceb04fd35fd7e8b6ff2c91a1188f578186caf4219cdf89098400ae13f14907e3b93aed494af7a78fcfbae646ccf7ad62b10a7700f16f3b52d1513a8605ebd2429a3a6fc7c054aaa6213db65a5a00d484b9db907790568dcf6ce2352667cdd37c178679320977cddc1b8be8a3ebaa69414e5e93c7824c3342635e19a8030f997b295d4014c40b9bac463dff19f4946371a90bc0c186d53cef848839aa827578996ac2a5415a176e07caa194522153303de6540adf165e6f4025e9dc73b2c5bb076c71e14559d1d80f27462d655ecc18b57045aa5bd3eda9abd469a1aa81460a8594fe2f86f84f4cf4c35ade1191bb9acebf4236c8d09077b68288c3f4a5ddd1f643132bbe9160f1adb84b6c0283e23f3f19396289a4118908e7f5ed46d59af277008d01f1db70ac3d712edc00164c9cbb9604038affac0537c1aa6dfadf4c2114408413223d3641b5c5a5bfcffd96711bbbe7a04da27c9823cd0a1faa6d84e7a8399e842aa2d8caf8811a0456b062a621b65fa51fbb46a19fc56203cbbcbba32d31c779a572d049dd5a8a6af0d3aa9446d507a9e1806fa306c9773d52eacdff5f55963d10f17962781cb0356a44f98e16f9db8b8213a2050f6b9a65e814212b2befb71b6824a6303f6724a43474c4213ecfdb9e625eb3072e784144893f0fb9510cae8a50e9e063f2b47e55415782876c0556f24d7d2d2c536251ababb128babf3d5c14a48cf98a528716a5bde9a76fb3fa9e24a74cdc830acec41961deca85cdd6f433f17db7e2529a018e3dcb61e1bce5dbe23ae0ed109eea75df5d7d402fdea0676c527a15f39edba4e52b54867600cba4812ff4a3d187f0b097cd14d885cb13fcd61f1106fdddf7d99d1a3412cb87b994bfc31415e94bb9abad2a0ee78e570c4c73721529c233f57956991dd9cdcf73b98589e4ea9979d927f0d335d176c1b1220781f4c06ce5d606f464954257399d9e9116d651cd3b7f35c64c1a0ebe7d147a8aa5486e9b51fd5f3b0e5ad4684a67d0fc4954223fef198f9f94d1b296a83d7ea52f436b15a51e8c2a0f360f1b5380c41b477bae79462fe66d7ac75431e38f4321655743f81312ac870ec970f79486c5db941b111731db2840a35099364d4f3c11376cabff92e59e221cb69f0d81990c3c3ede3ecbbb239ad7c479d562ba0b2c3505628c46d8a0bb6849735dd636c42f75cf874d958ee80d0dd7e57d19e703b798013cadd66de67814279bfe5b5d352ae00330ec391e736c519401e31fe7209c280b53938f8bc3deb5ed8ea12bc08f2d0d933e2f8dc0de8dc70a2ae48a7eb444d21407dfc601c885df87bd72630dfe4f8cf259c1a326c93e36b0ce2237de2f5691835c1bfe217c09057306258bdcd82446e470b67d3a4002a26199a1b44131abcc427a22eab31661d2a0300c211a5dc8458c1619b85c1301d4eda9e91cee1444dac2568410f6d58bb87e14d4ba7ad33d5815691069c7c8ae858f4009e2b5c14b358b71d1446389888b5c800b97423123f494e729a76424e3efe66b1dedc23ed2fe9fd4bb131caefd3fd5c4e9e128cf3220dbd45e07dcb858be95c65799aa5717294b72f58ac6cbac308e0e52ce0ccd433491bebb067d7ac6c88650ebc7dd76a70e45edc2b7f4f9efffe9b38cf2624e6de2481ec8c865dd3af0f3502e20c96b3b8133f1505cb45c8e4e6c6b754bafdededc6077f66a8cc5c7a6933264543dee07869b432bf0f71b6379807cd3642378f95ef2abe5e48068bdc6769657058df08929a885013f6c89a5d8c7af246c18d4ac3b9b591a2e9a67e5a6517bfdac49cdfcf29cc03dd25348fa69c7343d3af650228f77205a1f592d5d384b44920e0c0df4a8864939e0a2b997ea33ca181fd7e460441167f06b0a5bc505d0b1f20633aeecf34125cb65cb30d8ff6faf2f34308c608dec57c112a7d53e13f8b8edaf3f561378d2f6caae82af305e6c400219ebc3f8f46292d7800eec792263001e0c540ff931a054858e9310a0e133964430a5ae5a5f8731f9670f28418aa5c52ebcbf3377813cdfe5fb75b4ce1738e5899c6925b0ab5b4e9d3c1e3afc3d150655088d7db82a20154531dfb35fc3260e38e357c170d71d234c35c4f9ea32ac36ac5ad4f602c8cb1192bfc742b89ad0b0f74294f9869e5233141ff1c88562f847cfb5016700d578e9368f3fac44736d346f7079169e024288ed0777f3de341e2ffefa69dedcc9d25599c90a0efbf6c955a1f70460a14aebbc2e16ca3490685463a33b3e6410965cf7122d8b510cd9aab8d32efbd0f1221ad1c468e173276a7f9a7c323e25ca5a7da839eb87739f4462790257b81094d6477c8147c507dad290cfadc62d288e811ff3455f801a1e5f604aa092f9f5d96daa6796a4028fe0534cf02bfa08539f1426833b4206fe3094e864d70e44ece402cc622cbad4947b1202f0633beaf1b457dc299ec95728649f00c9c0e9eb4a0b47abadace4cfad243cd2e15fc95dd8b39758464e8e77ef179bc0e927780ac31d206b1779f03e5ac196a5cf26a15aac3a3fa0865a40d3378ab0bded5f575e6ff90bda6a3367d82c2b77db061f6927a4cb07fb0a4eb34b54ddd4bdea4014f274633137f5f5bb75617fedcf46eac7ef0815499b3d9e2ffec2306d8609b750b58c3eb994a5c654185a161898cd3a81b877bc14ccca3f88f449ccfb2868a1ab89db5afd0897871220e4072fd863151434634f081f7dd6295352a718891a94f4265caf08d2b9f7e4fc847c6fd0088787e26a37a07509b812b2001612ac65783b6e24f63cf26beb0365310a2bb97537e16e506567bee01c64f7b5d05f9c470a5ff92e7c387975525ed0730a5eafbe11dadf2884cc159e7a8504ef574f0fa4a029bebde5321f50290e7e22e102c3f1a7b678d94a6b8166e1ab995a815dc8a01e6b4fa0231fc8fd895e37ada4b4839b3c253374e828e37808fcbe205ae807d0b040c6f8098fcfe6119f7ff6c65637342dc5d96b1e66543a8d0e59b459ca9e14f15b9b1b6202f857bdf9bf2576c92e3cfdaf21d0561083fa042ce51cf3d20a6407665c2125a273e19c0f226be2e373fa7c93b7b87a458c1b512e7e65dfe6b5b64b1b83f8dcd734d7470ddefb7a3328c1e75d21a74f3914deead241d85427a4e6ff2361a50e295f0b39063029ef890c8488fa489b8b6f019a0b296adf387a06c9b334b8c5ec60cd0488d2c88067b136d2b92c1bf7f3a137a7a0d39f4b572ee283fef8adcc75a488d90f412f35862239414104390cfc4930d3ef0d0b74dacb810721ba447192d47faa45b74cae7773deb02706b7ad01087cba0d0eea1344cc29abf3daf9e876429169ec45e8163a22cb597783f1d61b0aea3283b491e1647f09f99ebc1dff095854720b472450651dfecdb7ff35fbe6c1a6ccee89521eb56dec16f545fd1f9a941d4b208800a61712d61cc3a0c2c7a74cea86581faf41c1ca79df716d6d1c2a97dbb675ac69c4d30e6df122e19a006b3adab28761b5f60fc82943ca9be6b9cc8872ad3a97eb205f2d41d1b098f7a633ffae1be9dc2e3a33d3aad2835067313c0a0890e4dc0ddb6706542f789962d827be6f1af4d15f107d06746ad90e28e12ffcbda1ee312bb68a739a1c020d0907d757975d18a1e031c4175605fbfda1891b9fb3816d55aaed46e1957638d2b868748ba5eaa673321529848a71994ec1b85c6fed39c740357316c5f14f20f504b7bd2b5c002153b0718bc1c6c2b3dcd837a63a4110fa350058d00f82a18a36f36191e08ed2fd1ec332d0cee862af0fbc1d4a2548c505a02ba7c8cafb37d04d0e44b2aebe39c7cdfc640d914e4c5efca22e460fd17","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
