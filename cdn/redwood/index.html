<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1d32c2cfde92c8add260f7242ce0a29c40ecfb5dc5991be6818cdd6130116463dfa51dca4b832fc1f19073071652c9d624a64aae7286e18c26b0608d533cfee77f36ef2c1d7816a655aca2168de245ccf127327bb6da2e3a1cd12233c364c94523b063e493c4180aa14210cc2e2f5b113ee7df00ea6265aa6d3a32cc034a6fd86e96589c665b925308e6f3770b171591f4d87ec68bf7cbc39ed11ad1368de378bf778c0ad3cb0cf9bd7a6f11fc9a3d934e938ddc4f4dd98af8b14330c7692567e5a0a0b9d9e0379c34354f2df12d2235165de6bba87b6d11685f7fe101a32d1e1afaabf15bbcf9d9777a35f1194ea4828441618646739ca76be7e7485db671233910c612e6e90469dd19ab7005004890ac5896fd6c4517d0b223753c4a980eb39e9aab238e0953e07ee10969c936a777d5a0e519e6db3d1ac712590c135c7a107a4b613fb7ac094b7bd1b336804d7b7990860be3c71382b5f3b6c8648dc12a7035341c8a2c537f232fde6545629f45072f6c0e9b08d6a28853c0f1e715dad3acaaeefd845e06f0fef965924f61a5ec22368eaa278612050e4e7aaf34a9075328cde2a5baf2b5ce8505044414687120cd1ccf7345e3986f617adb3679220d184f5a6a2e16891d2761505e5ee3be39e6eeab11910b85d771a547b9391aafb8e0198c21571c0ae617638c7ffe898bfa9fe80a6032aa3f3a3446ce326c53ce09462d60357198812532de9c33b6cca6ada34fe94731fa1fd74b2853d0a73431df917911f52b3fe54ce8a85baa3e2880db19d77c8847c5923a9bf3d79ffd3756c10ea49a73f88866130b97d43d725b7a111960e6125e78b53086138cb9271152f67ba3db3815feddc21250b49bdc5c9daa745ffd1a964e47f2f49c35ec6142bc8590aaddb365bcc6276324716a1f3be34edc0430d262d6fb337926d3ec61ad32dbf223541f3070f4f2c2f351e866b81891c85d8e0ec1ef75395a1cc1fe4b115de5e65af1d2622924ad720a4b86d25b58ddfeb54b208d3ae28f9737288e9aa15c28a998bd6abcfd36883b752423d12f6c3609d7fddb122ef8ebc5b6caa8fd27a66fa65b54701b5a93b60bc1fd9ecadd3f6e2ba9c0ba3f9151abb98c3c41ea000bb6aa611b08fa738877715ea4996f6911544e7f976ab72563cc1f433624143802645cff6e582b7ac718c2025a58d6b7652044a5b1d2f63adc13f9a5c95b4b8e35d8efa118824e197eac7ec49222ac03ff95dc54622e6a5fbd8ad85745fc6694c8154e7ab829d829c25d1a2c82404a467ec422e73b261c4147ff2a3e59971a414d21f9f4887baa16fced97693d80897cdebcb27ca25f5f38ce9d738698d6e7df2ec67eb6414b45f79f1803e3c193103376a1b972c256a827aaf3c77e855a7f9c42a1c2d63e091854f384b0d2f774a78403811895c4097463b4f11b1fbcb4b34de45ee4c706fe9e199252a3e5d50a962eabca233f67317890d767592d9fb0586570118645ec55488523f263b7ab54fd11d158fae170796aa94f144260df99725149bbb12814759a208e8a6e0bcb54e0c243c6eb9e0e027912a1ea24da95f6c60ac5f473736d2d62770d2c5eb5a1674bf6e4b5e86a36c42c752e28ef1b8f56efd12acf96be015b18717455b72917cdb5d597152f504511c07f9c2dbbc4dca10a113ba517cd0680209c4209ec843248c6d509b18a9258f942fc2df1b69ecf04ca08dd55741596896f18415130d58c92b75040b6c1c2f0ac50adb1e4dd0176fefc2d3881f49241c09d94cdc860520a5d689b4c7f9559522dcb2b3528ffdc9698489a9f8fe10e7cc2e4534afa2b9c048c8fba48dfc4e2dd4f77e422f7804a91f9e300d86f4c8385c7d6dd9a98410eac5cdc7f81829e36f00a4a81ca34071d110e16630801958897bf762d4c6435311805566366cfee2adb7d58e005f1664fe085484225395a2ccb5e14d193263124cc194255cdaf816fd565a234051eaf5ead38feeeeeaa2533204c19a2de6c3b0e217d4c9806ef366b578b7a4ced584fbf143bf0fa107895072670842645121a62749790ffaba6169c82c83e125092cbf72a4e3a9c9e4978b120efd103197c5461499d0e27a407dbe77d0043c8866094df0db7eabff659ef455675b1eac890ef307d34d68c5ba39629c3dfcf8305dedae9e65061e692fac033deec55b1761941497e0522cca2e86a331db6f3ecb751a2b5ae6b2ca79a6d389515307ced1a526c2d0558a998f0596ff789f366e0df0fe734faf954672fc67cd1e3902c19ab6908e83211d069087818662c10c9f2000f6f1afcc181f614e6936520b0fac1998dc16f990e9955f27ab0cefc13151971f56a99a1092300434ae6975cff9847c5196873f73ceaea2e835e91c09a5744ff5befc19fc5f6e0721706a953668b9a615265fd23dfafc47a349fb5ba41a2c4490df40d341070b8509d219400fa69ac8976c26c6289706e65fd6ccf704716d3306995e2da0ac2e70fd6b5c0144116f8306ced17ce6a52a4a2bc94ab09aff8bf9cc1b4dc3eb33a447932939bca2061e16e714932553ca7a998a8eb0ab3287f85cb5a28e247bc3f96bc62df08412a1d667f4df331f68f800c70dc7799e71ae934bcdf8c27a5dd6e3cf635a5d5c8bf1185c4f6902762e626ff689effcd480ed7b0b2bc9475ee80c3919297ae22f40c5b26cea5accac908d8e61925ad0624a79a0b29bd9d982490bbaf6662e61aa41e623d032c1770b3119baadf196ab0a76f6c335d8a3fe94b72331b49b0e78143791781675bb2aedbe190412d0fa17a1545a852b41bcb52f47c3eb9e6363b7a69843d47663808d4c12a60368e2f8ad6e1d353fc30318e679b26883160974ab2d46704b69c2e0191450c4e3f645a085397be8349da2dcf2ee52a546443f9b28fec2fe9030ac69f274647cde32147c10eb60e75340185149778055a91e3bd918e8660c07dc67228b5574e63be402aad69dc05aa4dec0715e9b4cfed760549b1ba2a8d5270d7ea1d6823cf15ccae5ae6a9a69cb744cc1a635c6494ec714b7b3e4ff6238ffdda5f9d748f4bf988672c9b70d23b157bfe697c8499bd464fa85fccba64a0072144fc8f5b11ddc1b1934b4d9d4cf86830249171fb939566c13a1039f3e60d38283723b54dda8fb3ca8f2b4d4147013def3a471bfed37c87acdd0fed193a65808d2602a686f38d34a1b74faee00a0a5b4dbc0ff7a0da04377c87e6bc3bb49657167dc732cc11a0f76897b3a53c4058b1b813ee3bc24bd454db121e39047748db7c6604139cf2b082c205abcb426a1c4994b118476760ab5abfc8d358d5c69286cdba9400b56968fb49b17b94557d65020d5ce312be72e01a8b5d05a7fad1f2ec0459973979b01aff5b0c8aedcfa28d49c7cde898f3f0fa6d4b07ee65e0ecf3e805a102c4e3fd891677d822e377e511cefdb62da43ecdcbe589040205e143732317a7b7fd30e43daedd7c83bc4cdac955480a22b637680f6025e50906c483d5dc60d032bb8e324f957a7098914598a57b0c4731281f73aec6fe6b57f38b18f652be4a5cb7fb10e577fef8c52340bced7e458a198b96c785fa5023743d211be51becd058946fc3b2772e868942d00165b512c5ce6a46e27045d38518c102edda4b128b8e3652f35249d4838d7f8b51693960e815228600644d67d715787b4e9c48772074e2f2d2d3cf4a9c9ab3860877ee3e897c5bc9e8f89181024025a0d24da9d9b92d414360e9d926c1a12ad32e8cb8ad3ef8219f5e354e82fbc670670b76b78735642366bb53686d00b29f425d6b3876c6d80d328911a7eab57a387194e6d3ba21fcf2ba0b298819af95c9113b59520b093eaa25a6dddf7c477657ba1f68449a2961829885d01d21625103d617cf46d1bf239126826cc6c284ffb7f7a5b74664df20135c48afc5c03a9da15a0df74cca7989f3628737a6a18c49bc09d0f476009a0f6103429f05033d56ccceb07f977cc22ae6b2952529cc47c17fd98a763979db9aa46bda090728116aad4b988c965b4379a7d6fab79bb6887d94d220eb55e0a7bf0c37082828a6a5038f1b502cef307afc3b1cbd1eb65817fe663013c8f55a0f003fe4d919e314b912f8ff9e3bb5eb38ae2a9dde23974409d20ce94f6c0538ac1c9334dc3a5c40a5260550dba4620bb053443c43c9b27bf79acb0e64b70cd78db3106984e960fec098bab6336438002b1ac31090c7eac3f0126e161ac094d32664a7b04dc7c0b104b05455be43d97f9799080c10a7cc585c568d4a8fd58f2cac356c9547f32810d7213331adadd62d9856e8c389fe5d244d4cece396c88cba03be904ac6d676484c964423d3626ef442caa5f228cbfa643968ac1e3e4d42c7ea9547920d31a0f5a579c3ca31ebe37db3ee94a16171458429aa17574bb258359ff7c02ed9ec80a95502904fa3612d172ec410bdc16f55b4367f421aaa467e74fdabb5197a6d418cf55bd0a933398af0722ef4b6215b291472542f6ce0f95959c6c994e7a177c71918af9bb7c8b6dd89f6ac34bde35d43c995031bfd62c1d7aca6348f92c152776cbd6750b1a93e5a346ff5cdf18fabcea4f609aea55b548d6da2ea73f4774027c710f6940aac8c3fdefee58f50ac1c5fb5f74077acc01ff0ae3cd06419d8503c1e09d055451782f0d142e3c02f39efc691a9bad5717df0fa1db3534f0bddc0e7b5ae50dfaab9100e57ab959d2ecdc4715ca25f20f1a0e6b3c74828624951f945dc561608eb42b6c4929e2f4145eaf66ed2e162c58710efd90d3368cf44a141c22e357490d63298a65a13f93d13e506c6f9f4f8d77581a726709d05bbe4a06b148b919b544a4f710f7252fe56543ebaba3f20e44a8674fa9ff95a43f74751e71a19a333d1d0e99899d74db83fbb16052d584e55913310a568d7c21c4c0c4379526d8168e3ec1db91d04c6e55f37bccb8ab3918655178ac1311f64539da8f2f96b319dabb97b561ae830c0e2afae079d1260b2f606315046115134c712803266a736b34a73d580574e8830e6a266bd0aa04833e4adfc8805a4b01747c7cde1d130b2ffc6b5bc707ca61ae182d3da5a83fa19d7d6c59491c47f7a1094975e3f2506397d6bd5272aa324364e42bf01d90369ea71628280d2eb415ff18b324c975381b0857b5ae555acad4eb152f211d8c8ccdbf934fcfcdc01d034d4a7a36e7176adf3b7c4f4c57e9fabb5d01fb1add2266e33b9a3614889f08c4116ebfec6598015209913f07dd1dea1a9652b147b2e31fb7d8c60d80bafca6420c51fca9851bc7b474716f922dc1a13637b7fd33de7133b4ff4b6a23ee9bd0cbdb9053fd4bec2283f1b4256c156e75bb2efb8867f5469a743a47cff4df19d9398c2b7dd99ec1cdcbfd1956906ff0538318a35a4015eae018b967239a54d92807b2902e247211fa54007ed42997e5fe9f46b3084303ea5d18cfa453aa43926cea64998f78c4acf7aa11e196e57fa3ace86a313990b359f44d6e969eb0904640939922e29f79019a8ce299c43e2a5eac6c8b560b2b029724b33ec0676d51e5021ceb5d54146902195f9300960a3496f0131d30ebf3fdf1e54fcd587f30603555ea0faf244dc3ee062afe375c35293c8ab3232598624577c5140359b762980418986b5bdaa635d7461e7c80e06191fa1ecd0ed597c200e3f3d7e3e71398b8b03bf1f606bbf20f4d4633f04809641101717000070d02066a616c881bf0b4bb752d412a93bd6339ae32386322c2b642e8771886d43a3da2bbd09c5a293a5155b6839418972485558aa22107b35cfc5feadafaa41cb679e81f6612f1c74927841cc2021d1e285a05395ce19741cdc2444906a953ba8e9290cf00120e377f1daafa1639a36918bd89768fc69f0445bee7c6d9752f8cda4edcd537bae84e40c74226a37690debf3d478ff566cada32892521f49922eb65630ce0a757e75d3a1c4b12bcd929628d569baa5aff516e869d81fdee6f5d9678ebefe9dd74deb843b1df00eccda751f0194bdc2d42245147a23921331e6a0160f0c17749c786a9ece00163c72f922bd79ba81959b07dab328a9a3ea77f380cffdc7539e7b5c5c14778422dfadce446bd69cce09a8403f4deddc77adc282434c53b0afc617eebb2b041df28890d4c6f296626824c5bfd9800b244927ba8b256292565d4901f1e099247d4fcd1d785536ce476d842d1428613b49575c0cd88f1eae1b0290578fb2e2456ff6c5c532f49ac4726135eb4626f81437ab7935312decfeab9dc76174766ff6357ef2e711f2d7339fc209b680956e12858cd900999d39b48e2a3e96883d53c869252cfe542b99d9b2d4467262c6e999a62e5d32206755807113c86b868b0edb60cab5b5728e08cda869fb8b012dbe2c3310b8c7e3c4cd8e7980d98d989549664d8bc8484d82be5aef5491123bdacef8c2e7ce1116fec70098cc2af41c504796de4e1484c5d66cbb5006a2ebd2235d2db13b839397ff8781d25db0b37420479d0eda4a4c028f68c6984f11ffd86f60497930d4cca6fe3354642ac1bf2197b4470610122d2719cd60fd85837b3b9cb8b1af13ee1d927a6765eea20ce92ae0c58a28bb8df322f4f33f5e0bd747cc28e416604ed78e43ad9832d19d82dca155a37cb6c9d109d576ebc779394734938303899a97b7414a915ac63720e9f60542ea3daeced3bfae66ee99be634f610424d4eb85e21810c70fd0d7a16b9101cc1a6db202ef06eb535efd273af27e044bb72edc1a4c003a78426c38e559965c4683ebccf214f7e5806e56bea80b80cb0ecf089072f6978ff7d91e4ae2ce1154ec2a392175bf7598c25f61d67ec790edefbfbb838329a92a6bffe2475f769209cb516c15b8afbe31c707e4f6bea2e22efb09fec8e3d59987fce45e17fe58db673613ebe28a1a1ee0c58164cb3e2f24a91a793bc207ee6ac5b733fc3a5775d27ce411e3128308646e8a3f0640782dcedf2943b82be1dde68ac79a04840c750e975202fa3beb3c6dad7256094e8cc4f31ae511928e238df70be4419a5f2207b82958232b52319f99461efd5cb417f20dfa7e7730d203c4ea880abef97cf6960ccc8893c64c79688073b8cfa05d431ae790d30d869f56a9b2df44546ea0d18fe5b4da2c03dbfd89ed53c31a4ac2bff6b85e4fc85bfcaea284b21e3b239a68cc0e98473e37d3022c1052809f37054552aecbd68323cb6ad102e4337e7c810af6aa75c7cb89126ce5fdfb75cb98968f60a1f6f5dfa1974c1e4af9d36c7c4ad830e8a425495e109bfd1f45d5d5cd2e183ebc1b0f9ac428cfeae3a2bded1b3deeea037dce1e763391217fd26dd1668c154456fd0ffe0ac793e6d78d46e0cb742e45cc674e70e95c86f7f21cdc7811c39cee485bd1d1b537dbf3efa130129fd5158ec0ee5bf692c06636cabfb75ba62c8ddc2e53e7d8a6132df305f86ecf51b25bbfee1e956c44b36b099478b8783294cd7f11594a0a978fcdc9d7508409cb96d1d887339f3b86e645f9fb84bc7d8beab7d9c5c0470e2723416399332ccf2c7c5405780e84fca99199a504eda11ede71aac9e98a6ee6ea7daf46146f236f0dab84a911a975a61108df780238b6626b51b8f45878b70950c0c95a757d275de346e5ba11a67ee2d7a0aaca364f14245496f3c02602ed51d9511cf1526d0edc3d6e54b617052b096ff412fb189f7e6554831401c5a1f6d38983bae285c92a881dac1cbf5af18a1b7d2be91153bde7fbd90106f0ba8c6425827f4dffb841b8a46eeb4def1aa293a7dfb9fe12b7de73f9293a952b04df9f4990c0c28448dd0cb1238e595a851fa95e3d896112c52188e0ccefb33b482e5d16411cbeb3acd2b5e06501ff927af6d2a82bfcde05b45c642e5bf1fb21010ee6a392b20558fa8cb0237cf4e1b9382e5f7e9d3c258380b69ba215505795db2f1706b4e9aa74e84c02c4b3930682f8c2fbc8c8e089cf1988c92601df5cdd38401e5962f81470f55e417fc9f2f7407c194f0f52d52536eaa0a69555a3392a9b1576a3910d1b70c93d0eeca261e8d8c18f93d59bb27b955922fccc38216723545272638c5c001271c99a79db39ffcaaad77b0396421603d4ffe87a029645dece2b2b338a9ec67f5c4828632a10e00aa0a0771249a6eab2db29e091bb7b6e966b60b0350fc63f69e00962ea9ed1662db25ff5abd8b617f1cffcc6918c94740a4ba6f5d1f5f21faf639f61d8d04708f5a4515c2193635dff82db0a9436a42f2b4c06017d4efac45d9ed09c26935ec024af55fa72d38bdb5c75b32a40b43ae81775dca0bd4e6654d4e693e17d86ad0984a6e216e4b01fe61e7695a32ae2deae700c72559cd1e4af58b26bfcb922e93e35275779c2fbefab3b2fee0cde1dcba23ccd06eed803bb9ba987f5d4fd432b18a93169f5f03237a4e0860bf8d13b5f8f7385efc34ae3d14c55d7715031667c879469969cdd3d3635a7e7f1be88169814dfeb4248e749966bc59fb9273b3c1d92d79a4516209162ea9182e536f5f42693912d7c6c60c4ddb6344e037126dddca5128a4c1b2cd3fe02755de835b7bf499d8f21ab678756ccc75c2e8d1e69c0461f7bb1812651f96d7befbc853c6d7810c8e5199c413f7a9700e5690b96d29ab1a8423447289c6955a1843997b507441af785cdf1bc95e9fc3ccb92dc43f10d7b9929904ac5abfe4eacc76a88ba6b391794f144d47cc2f7c95ce64adff2edfacfa544090da85bf3cb1e30af4bf7028d163fce6c201c5b88fb72000d3e7b1591aa92939dc638fd4eaccd8a6916c52055be77c823825362d346c575225ef812fd4f952efe89980b3d20fbb30956f73c3c63d299fa197605ec5e781c6258a75feb851f895d62288c919ad1d31423825a09735ff710c987c4f2e4457d2f23a075cfc03cc8f59c374ba6f01f5cd64d6b71a29925f745b005e68c30eecc2626cfd0b16fec2a293002c0e2b97ddf61e7bd65c03aa135d8bd0ad8f11fb438bf73c21b7b8cddbc64db765792eb95c1392e4c5e3630b1b304620b26e93c69195a630a17ee1941a7e4cadbebbd3fe926e43da304d1884d61c361daa8c78126b5a56ee904f6c23b04caf301c656d938a3d3330ad0dbe71a02954a15d26534d2cda5ab0516eab97577258102f1bd0b60423c481f61e6bb4038966f074c3e9be97c4f05e28c6f0780c436eb89b14ada1c8f9e3a7977e73c251a8aa67ac4438ebb9624d7694d4eefd0c559de4026f73cfa3d01438c451c0ca30a6a247ac5940c4d567bcc87f584f67280c92cadc79a0e53a2e7d138ec1e30277dc459b23ea57c07e62e8628999b40f9eb16a67bd8ddd058ed276ff142f39ac47e4b74fa3d927640e980430352d70a7c7a559e81dce1abd3a4507ec23bf7e4a82e4489bdfb920f7cf40fa073b1e5d74aa8882c7d2b23797d5ab0f40cdcf661a4dfb4c6600c6cf39cfb83a8c11d10053fbb46010c830d382ed6d3be5f655f97cd4b60cce9b6a757c23f10623aef1343220e33ad73568d53d99af21c0eaab1cce6a7c598e109276e5f50e4c78e10acbdcef1397d680ad791eec7ab91847e40c3f93ec13b6f35a689e3f5038e94b61361699c8dae02691aade79286b9ef9109e3cb8d134001745bac48461acea0360ee446cad76bc1ba22d39165685abb3c520d786e1c05bc9a2b0cdf81625db25a845f8899dd22e0dd4a7b2539b868a9c268385143fde69df3bf862588aca852f9dff6e84b1c7743bac5959b8356effedde5fa29992469f093bb4e07a4f95e24c9732b21289a2688299fae61e6389530d61ad3c714ce63d42c5d234cc9a4ad3a6766cde5230190cba2ac4af5f1226fd4fc5f02ba14291f591abb98129b802048ed6cfab25d6c65ff2baa143ba6edf7835f736ffaf012de6c110c9f84799288b9ee7a42b76559c2d56d471d42b29ba1ca079a782be064738f953b59003d221d3b82aff4b264f7519ce54fb271acd83afc0187195cff969d9097fa1de50fffea6119ad755e4caee60e3c6de72cbe9e387672d0baccbf7aba68c25ac116a53882570071b26344964c3fa39e3f60e416287bad05c2a17794cb4989ccfa9c0e8c0df0643187ee5554583051ff9e7cb4feff80710de9bcb7bd2d13df2e4baf3f19b6e0cc894d3bdb37cd375aff5df4e71a83f7105dc750c4e4115d7b390a8095fe18af18859166af6226f598a67c3c08e04ae25433cb5ef4e63162fa5d6843d37877ee7ed0535152070543d7a024f7990b352888bb22d37235ba97418f43410b7dc133ad962689065981c9e064c4fc53bcefcf39d8b06c8aa7dbfd93e1b1576867a6919ddb6ca0eaab52c5e20e6e8e23236040bb1c701821d45ca302bc92068d6d76060e074d5e383b5588c933509835b65be07cdda46e899919e9d1a8cf2b9bfe44c1664a122cb60905c6588d2fac750d596b912a8dc0e5533e3f11d7a5bcdacf4e8cfe7f0539777376cd901400dddf11ac54f3a21b10ec6de9e3e51082a13d31f54acd26d33ce1fbfa5034b1a6489985391a500d9f03b4f43a98f5cdde723ca567af24ab4aaeb5548e45e114a14553fbd6660005971c65829ea5befe7d23e05fa07aa6971a8a2a3e61671d702b7b048c2dd70996b651127b9191c5a4278e7b6ea8c0d0de12128babc3c740066886a8276bbca3bf6a98ab36e820f16282283e12f83fdf362c270569b5b415d909b04a2e79aa12c15ce31469afd2cdd982d074244a9c8fe0c1c582d5d150e9fd91e5272e970d24bd0a6a0810ed94843c78d506aa91beb38f40742528e177588d9e52b64c382176dfdb1383201627093ef2c374b296a0ac0758127f49f0b310c14bfa2235d6464d3c19938781b4fc6247f56bc7defebc29fdafe907de3e07e0103fe2f69eeadcd5e6f52188ee473c9f5390b71dcd14d77383a933b4661ce9c8c5c6a99b1aef4b15084caece49b053dade1ab339f14b5d20174038bd21310943147e4f00a29720d26c9901eec8800fcefeff92a3e4518c21bed5a5b916eeb09c13d6b6aed85ef229d105adda309be0ad4e44c7cb8096a251e2d1f7d26e7e988619c1b8cd26ae3c114a5d270c2a11bef41a85c8dd19cfab656c3e138c8e7af52488cddaba40451654b9a21c3c6878d688c76304e4928e7d88df19adeda0df43906783005ece3249ca2c057da35e1671fd75ba62079440ff07f8af994fb6014a9ee16ab7706a8a8ebddb07dd88df15a8bc84704ff5b54bbf0e07143357d513cdd5a9947bf54f9bef8e6fe8934800ea6a2cfcf84349e12a1065c5d4afaf0ead8c900b96069533937b8546640e0c432fc27fecbf643abdda31d34301d5a18a92630d00d8fe0d78bb636653f96369c5183f0567c6082e96b607aeff2d09157c0b0ee10d2841b9b5f4bccb734e21d70186450b8097c7f1eaffdd7f9c537fab6d3fbd83a0cbe3e2ec0752b89afeb3e750260339eb3c5eaa104d1d0e8c4654a5d53ec8b99ea530a24d77de32b111b3c6f2ac5bd71f1b74ee7d4edbc040a5eeaac58cdb2cd72e9301c621b773af7579fdd6b8627a78159488fb69ffed474f3c6787d913ad6f4a5e5cf64c60c74e1a7d08056e5a17b764141b8e4d0f2d8a6ac1df460b88eff8d90028c2c218340c6f893c6aa8e9d5951457821c68947b5c2b2e2be66515c2454abd38891a0b18f930020c67594ad5c23b4d167db933047b7ca3b73d1bef6602a36a4d65f3c97dfa0dd4f5032334eb474f714faf682939d4ab0ddf0aaa7a551b9e35f7fdd5c15a89b7861e62b8ac54589222a5c787f4f7d063b6fa45bc52884056d1dd11658ae779b6f40899a068787de2f519c962e95b09a2f16d1098d5aa518f07b3c12ce90a5c932aaff32eea438f6876d6e158aa57ba8aad7f238843c3f46381a0906f30652b04c3e1053fc772a0efbb0bdca4f461396e69d636c0449d60714368673b70b87fe087c25f3e5ffd35d7aa592b35e456db114ae20f844ff317d0452a0278a0221434b7b63f48bcfe3c72d48a436b95d651c124d4c68d5900e8cc0290658866bd2990f3e6962e31b089d37f981219301dcbc8c40f41801203349a67363cba8099a642a333c148cb03eb06324481d30cc84b854e527c924eb6b08b3fc2b4c7b1d37741ff6f34bf6b77acd6e6c7d66c7460862e62d0f4340999fc6c196e52e95d4283f3c0f2b476440158c9cc48a3377d56269966609a6a3863e1b61522daa1b0b099e035c0d2deedce1e11883543ba9619382248459eaa81f636acefa2cf0d1e187c58253eb81e52df8865077c1e4cedd5ec4b3ef11ef8b13cd0883515d7e5e519de98b08b429dd771a1d7fc0c9571c6971fe42f840fbdec5d45766f04f06117e66ec41a47dbcab1b59da52ddc10b5b54a64c8fa0e334ebd39de12aed315ed0337597d002a714013144fbd97af397f3476b70974ff1b1cc19a1f58bbfe63882eb4e1351675ab2e61318b96d3444a1bf3286c0c11b94ac09536d2fe41d25e0206a67aad9586290fe98646fe4558c5b74e0a1dca7d9959274d6281ea424e7b4800762de48e6f1588e9b49aaf47ca665ff38c2a96136f14c0d303af5c7daa6feba5f60d30c63adeeaf33536fe481eb5a3a657eb3e7124fbba0c5b8c23825b964efb1443125361fa60060ff917e48c8ad46730c88e85ac1887de38aab6dcc12da9567f43ef9695f079d4b85cc32ced3af6b21fcad14d34a7a5bbe66545a3621f3400b9ff4abcea2624cd80fad736cd8cea7f81fe598bec2f8e4a2dc92380a57419ea4ea529a2ad50b45d7d537fcdedd30e4cce51b08d51d038064b850c71fbc0c485bff01e294246440fc301ebdc1f807617df4cc8eaf658e0a0896a6e14357b004568ae9e72a4b45a341bce6008a2fbd8a33cf7590f9f7cca75045f68ce8ad042a142fbb5f49d52bf7d1cd5c0d33dc8b616756183ddcac5e4ea7af854bae45d883d548a41f12aa9d94fc3a32c7c8a72fb3fcef99a9ba2b4ea500a6b5d58da598ef5e82db5d0fa8c1031e737c806ed73eb394c69053a2f87de6a36208641ced7c6888aa65e3bab2c07f8fc98518f99fe3ff2932805704ba7cc8d1f818fef793dabee6ff37bd9f2115f7c6fa0f0808151e6e524eb9c9da693b00aa4ffc55100a42a07427306f0a562522d896da74b7512cf04440f455f283ae4bc025e4bfb4969c8f9ea6f365dc1ba6616a716bfcc4c3a5b77512736d39e459dfb183bb853ee965c8777206393f6228fb960f1ea553e6108f0c19461fa739cf7dc3dd82b2dbb42602c56242a94f456ad42fe8a1c44a788781d124e652147a07955c8d5aa364cc39fca92068d5e030faf5cea17354d020f606c3133e4941c20a170100c08ba3f484865cf1a80682bb6e9fac4df1da1ba0acea77e26339da1b1b2ea37000ef4593eeed755839330f156f52b9ec5f585761a84af248be1e54c477d57f3a42526efb63f9685f6c99d22d2182a5614bf435001cc08118d307cba952bb7844e547510aaa86279f7d433383ace562decd45a3bceb6a4fa0c5f922246ab086809f16bbdbd6e1db0e7109f28c6e3cbefb33539c4fa1393457437d2ee69f6a957003fe76780b2d3a292bb19718b1af98e9c7ed732a32e1301d11e269cfe4e222712254f1fd8e5a5ed0391186cecd0760a496c5cbac5a420b5bc9d00e94dad1536739ce9b91c1d3a19b6707bbddd8c9df8d1dab9511a5f1e72928febddfd23817087d80b5f15d8e450317cf2b384a3ff95ebc5af6ac49687aa738a5b2568eb13ad192891b43bd583b666123a89d89e91edffe3979b0b24fff5da877edeb7fa9c1405c8212d525805c3c695b166aefadf6fc9b766bf2d55db08ed319abb30ce7bb445718ebca978381ceaa55c755ffd1ef2769646519c2b27603243739079567688e12b917b6159161cd0a7515c581f00276c7fb40bdbd8751dbd6a51917bdf692a0397ce6d0e032f4a2aa4a433d0bb41e2f8cd8e3cd4d09e5513841eaa00f317083a19e34277e4aac017dde21cfcbfbb7577877379bbfcc78c58dca86027cb393e797ae611de35b1f92ecc9365e0a3b7ab48b8f808939f0687b3640ba312725c7ee1d29cf7a1b6e10fcca57a1b9051c82249ea6a028600fd6f7940df48793f582cc3fe1d300057f7805a3591cc5136f21cc534c27d4beefef4740a63fd77e0fde7ee7298078354aba8d44d8a22f6fec2efb66bacdb442489d6b4a2b84703bd057b3001c21b0da46f785940465eed2db57a9029d25ef2a1fe21e9cd8f8425a9848549629438f3561d045587c7a169f8961f311a33e3bf7adeaa8e017fcec42564c59a6735fac868463ac5e74261ef59668e09d2de9ad66033fb1bd0ee5940db23db24701dc37de3a2e5d4e83a381d13b0eea349c0edefad3fcdea9cc5b1aecd09a029a383aa1af3117299521688c43f574ac1c8a3702cb2eb2a49ad062734a769cc6c80e5430ec048256a3c96be51452341ec11a81ebe15fd493847324c1d058ea8a48757327c55ee48b235eab9c202a1869a5c44978eecd44c1817abdf6135ea10c91eb68ef4f4efc125cca1a5aaa9456b9dc45aaad32d2f290925cd8a10a040cf04aab59f4dc5d0ab80ebb9e9f55361c666eee3da7e9095c660d65e86aa04861efe2e12bf8ce036f048d4f10589e9d559a0c019c068a80fc347a62151b76ded34a7d04e46f7e6a479c0ca30bb5911ceca69f6e04df43c139ad9f5f56ae68d7d74d7a55eb749db2e5fb5724be51a04c2d950d4c68edd797f2cf3b38d1a45f91b4897992d9ce4e7618866cc7fb7608b49103a1db13b95382de5adffc1771cdcd80f0cb18558eb0ee0960636cf35a52f47a2b61e5fd52c83aef55572b26e1aad2af381061b7925cebed412e13f3207cd28f7203b692c5f4caae8199b8bdcfcd77286e6322f8817e6cdad815afb4860364ea994395ab598900efce4534340b32d8cf0912085be472a229ad8326b6dc51abf893ceea8c33c3073828ebc7f1f5ebad4a11c7853281ec0636ad6c74bb81c46cb0606d96cfd14b2ee816bc76548be115535d42a9abfce9f300ad302e78c640d9dd0ee436689049b7195101ac8fb5be0636fa0b2f0b0a68104b6b044e252631b16c9e23b71d6fea35500736b15ab9a2832ba4de3f927953fb54653b265e7b4436959b9f1ea60d7beee55cb945576422935c1cb09a9d1e42130777b868c325277e2b88cf972e70e0f0fc513b404b28e970204369be411ca1e84aaf72ebbad969de10fbf8c2565218497f74038791d8bfac6ce360cfc127903ac25ffd47fe0f06124c2a1cacfe922f5da1dc7e853ccd624b196e64bcc209c309960d82cfac43a38f44144a9f4c48aada0fedb3431ac7c1df3b2d51772e6c61e5faab29bbbaedea39a01c9427b72a60314f0d3e1eb34fac959c683af21a5f761d1af0be139cfed915d4b8437fce5dafdca4a052e0c2cf197a0458c315dd6cb66ba0c750dbfddd1bc8b40b9918bb2a7e9f3e6f407c0a50247754c0fe7393a8349263c4ed9eb82912793d4c79517b5607be9525ef99cac94fd70c42c25d8bcbc398243be3b1a840047f873ed780a38567b0f17e1f02205e1c2ff50fcbe082c777c64c0b887d36f3837e05a536687f4579b7494d14ef9a154aa96b938838cc7968de326396d92f87b3deea64a9b1ef4175f61ffb20e82538026543d75dab315a49dde6bf2ba3a31e7f6e09153abc8705d42f64fdd9e1466d7be2dd0b33945f15c73ccccdab32dd4fac455d34c9cf380ad116cfd961968bf2e1cb5496ad62593a8c6cc0f4ef5b980b1a702db6cfca6832d758b19afd7e30f1b03744afffedb8d3e29fe51b425c78df7b0ddf86df110f7958f7c3573c124bf086b89cb2bed0eaa8900a4ebf9fff12a8120cd7c1c2b0e27e020edf9bbc775081ecefa6a7d69b438c5be04837e1a4e85776776a277f3c47f6c1ee05e91b654b9a0b19f6883f5fa037b493f9d4f6894489034b0ca7cd35e4e38a9ac075fdb75ca402fcf09d7cab62d1ba2ad3f91fdb9a927b0b75efdd17fdb9fefda3db5904653ac1bd512a75ad0093303a5f2bfa18063c4d9ec90707eb08c3766c86ea3a3cbc0784a51d56a94cb3bbca070828d0d48d5aa2a4518fecf4a83c89fc72d447446ba0f6d203e9e5e6e037691a9deeb6359c4e5fd0548ceb61fed9826940a6c27ab3b5c9eaa0d4e9324aa1844ec5306fe28fd23feff7e8a0a207a7c6e9ba3331c15019d5c030c462cb5998584580999c73f0835eae815a94b6be655f19f86b38ee88070831be5827b6d2ad569539caa9c61ef4698d60623fbdde7d8df874c88ebcc2959412e5bc9713f78e876297d4581f4b5875047faaed2f33cfb946d6acc19ffe73b3afadd292f331942496dd1aaf039315d11c8c134180626094ecfb8370052f03ca6c95546dffa44d1f69e0816de1f54904846f684e8f80e17faa589138c7436c5e8436a977a7eafd37f7d2d66fce11eb1eeafebfb7b2499cf7c64e4f3d180edcf9ac8d1427733bb5c356507d2e401ddfe2b8a062ba34ab695b620dad6434b28c9189ba1b43ba67259e45c93920e1aba2120f14d3bdeb19bf3675bf8cf8fce1b72db598037b6db04f6ec8bbf150d117afd549d6b2052fe00899a4e488aa1b84a6588e4c0641b35897ae49bfcbb72008f4ece9b7700100758f68bf16c13e5ded9bcecde19a74fed07a3a9b05415ec8ff7cee1066b2fc8003eca4a8fa8753ad7c0e7f08591743f0f5d396fff04ffd4831fcdf9cd1fe83cc3028b8cd1264e0bea6d32de06d7dd6b19bc304d1d65b38f270d466683c2a09a2b1d0f6a7fa2cbdec81c5be0715421662fbe205a2df34ab0d1e328fa21dcc3147150a6c2dba3437811a8cb4c7e02cb412b7c2cc9a63312a108c562543c30508866765d8e8b0dca5e48bfd5f5c8c9fa7f2f61b2d834975229f253a9c0b80ce46425aa442a61e569f946ce56de911f0422fa5d7e91da52f33003c33b9a3a6a706ee7fe3f4e853726d3f6edd814e4667eea9159feb5712b96f8cd4bd48497e6bb6b8d8732e4af4186529c41ad2993f6c839508a990f3040a1f8038d5ae48081fbc0d7e3f4f01fdbabb31d936f1a6b6ccaa70f22918b54c6e6072895039293709742cd2e4dcf2bd5d5ad08679aa43e043f0ce25838bc9b313f69a4190a8ac8842b534fab3d5a4386863580569bd8df2a350f5d79f34c538ae7bf16016830a261e7edb2fd929c841b88cddb6d269e8f6c8d3497efd0b8668151f60dfad6a2fae636ea1eac68435d03e3f58a01f189e34973b7530aef7edfe393b62e60fd8affa30ecfbfa7d5d40eb5b961fc34b8a564bc7069d20dc972a77cc1feb58bbf6422272b6870577e9d018fd8a549c2a89aa727ba37496fd89d9647a376147f5d9a0888a78eaa7df235fc1a4712ca7a4ab363ba8cfbdab0ef104bb44fb7c89913a7ed13f3f27770a4188b07c234061b25608f73169f7e9b500961078bfdcc45cca6fd792bf894000b9266785199a1c89ab49895690f26b264cb955afe7ae58824fe10adb1c063415ef102d91ed9e2401f8d861ae3ca89681d4c0bb7a959c4730b499e0e1b06d495b1be96c32a806f34404fec30d207de85e458bb500c30a9dfecfc411d7362c059e9411db22dcfce0b8798aaf6e4f5612b7f071306d6de0e9444b38f3c0f9acfb591e00bbddb5b43d20df478f3bbbbcb01cedcd0125e6bc12096dd68241639fd470578ea557c98114b8cfeb5628a44e82e026751a3e45c8ef69a4c32ebd7f617c997c6cb1ef517723d786544a06c0a6e824ac71e2a812f33f396911fc9c49b4e8eccf19ce2857e691548916ba6f0d5414236c5a7fbd9ee715694157f6e87f860c593a8bbe1490cb9c0007b4fe9cc672b21960778b461a090b9786fb4ef38e41582327c9bcbd3163e13646d1275beffd03216ec2d3c99518362e5367e94fe668ec5577e2f10fc7022b502948927e7f7040c7c0c692b3767751dd45cf532d33a9d96078bedc342691607fcb13bcf18ab7163a11f005f7018f58e010ec97a0b400b5e3fa2fff7f6bf3a27e375541ce930048250e6e84ffa38da7da8fb9bb03ae9356ccd1b0f546fa1d07e822c434f13495ab5f6cb2707ac78de77d496200222699ffe8e278ab8bbaf6c6969305a77c0159b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
