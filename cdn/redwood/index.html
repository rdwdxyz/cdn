<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"96bb2443a9903bdd64f9e46af1951feefc152098aa18bf92aa2e8944f83b81f853eb4cab004e39a3dafd94a86f264fcb2756db6a3ca258df3e90cdcc2092f8a5a5812d1dfb5c2eab79e424b8aeb17ea9e2dada5466eb2f88bdafc237dae3782e10db9b54d7d1e519799a79c3b2588e278fb6c3f678c85554b4b68f61a847d5baea6acede55f211efabc39a1c33c821b67b1e3f6b71fedc47f563cd06ffc906c32b21c9ae0731f05aa8d0b02f65b6dc9cd5cebbc097395327a29d617c152dca6290be4ba2938cdfc106db46df51105d2accb0d80a84ec6788c3317385e35292a7fdf7376fa0741df71a21770f5cac3fb1d4f5cf264fcfbc61cdd644515a4a17d65c7b1d7fe4dbc06ed722ccace8e47865ec5ae3cd68cd38e9eb6306ef441dae4d17a709ba10fb9400ed4f62be62ea730bc9d3df8f302d9803d35eb900a24772dea0274b96888c913a4faa690a77f145f30bf514b36e970376436efa6ef34c28852739662f8e7df26a57e0d390e4a78760393e05bdb98501c3ffb4501be1cfccf42f7baecab296ac6716ccd60ef1650e5ef378e78da4f0f6db51f8d0dc7f3ac735f0a5efb761654c41f4ce20ca7c487cac9a99e6052a4f017ffad387b98400c71bcd0c0df7570853162d95ff73127c41928ebbdcf4cb729f4274ed5a01d6e5d28e99e6ac95e3cc8b99cb29fa11f4a5f13cbbe3b3c377d14b6aed7777d429d6117957ce9737b3419f8ccf15820511f9cabc4a53e7ccd04e8881fe92dba838a00a9e26926b432e0348fe5a2b9b7f142c3f1e19eaf7b4c2cc4a0bba2fdc6055f3d67ec014752a5b024eb82328f4f95e416db121fea646043e68f02722d8332ac66a88a45c96556e499ce34fb80f146b9ccb0412454a7777805980535f60f07308db9376aad74711a5f71df299ce2c66b408dc35a2eb2060a8dbc15af591d7aaeaa4e9780daa5fdb37ef1421778be3c6b7bd94bf70ad7c1592a5d2da498ccea73398ff41e5b7252d76aefebb4d20d3ca61243dd259ae00226c3dd88f2a6f6ce21f9725278c526d6086046ce4c2497d2f88ab85bee76ffd992eb439b1a817373973b764942ee8e418643f8c9f1f27232129171669cc6b43438cac119bd808f9f78445f6383da15054192f50dd149fef9e1266387da886792760b0e8f527e58f188093eb0687b631016ff7738a1806b3610f88bc28eef3e5e2cff6d5401fe330689c814b8982fec2b36642e2095c43c44e7c6a37ee42bc4eaa39aa586519f620b184991884735338bbec58917d52845cca369c80cf7cf50c5087d8434f79ce02b4a6b37aac8c396f4de7846aaa0195b706e814349aa12630791d675f9cf02cf05093218896ecb07fda80fd1432f72c1b15a51b820fab5a1c4337aab6aa630a5cb7a114e3adb69d46a207f526db2dc276922aba039995d99f77c639f5ff6ef55586cdd647f807279bd508abedfe80e6b9687d398a9f95073d0b547ec177df52765577be35deb93ac044bbca2199067c86d3267c3396bdc1c971d357e1ef01fbb4d684768a52b8aaebb63806235b05ec42ada5ef64f8203dacbaa8dfdcac4e093ee0add8f06ab5c9edb1ff3431eeb6d0645c77a47260218033abeb619d172a88d3c79db52bdefb844ea3d54d6f943551bf1ba85185b482380cbb188a93ff1c28044d534fc61d97a8206be4d07d1fd0c95aefe5208b231220d7f1ea35d01268c84bc3a3ba0007e403aedb6212dd1353dde67befa4840eb5baba4b1bd8e6afb0b63395a4de9da8875043b655465bb9c8b94e6825e6c8ea1f6bf835921869f68874f06d7cad7fd8efa61cace903076421619620a2a4d24fc91401ef65291a44f9bdaa7aa1558264e268944411129d8014e8bb75ad71b2707a3e933d7564bbb0593dc3a003bdf456c3c9e22d3af2ab75689983cd505137715dffb6a6935a1d45a95a9e293c1f108c882733f73222ca818b16914739c864e017db0d2e3c2c53b6dc2c52dc70b826e7f51524aa2227758c5a391a4856527310fe026ae6af5c8d03899e98322e4d99be0a1c5b055b9522f353e0e4f55cf36c5bd6ddae7915003d2e994995d97ed5f4aed12bc90aaa6148819fcdb4fcece7565460dcc7f29f1d655381f3548e8b44f39829981f3a5f806c13d5e8fe0b61e2454421a0265e3a34dd20ae47d68db880cffe3265fbd0fbe24baeecac479017288179c0abc79b36efe2b1268c9cea5333ea1bc76bc16101d7bf06b9fb3fdc3d66b67a5acfd51d97dc81dfe93b48f9952b975cc746c059880020aeec92a67b109aa450e80500095c0b9a174ccd30e5eaa7448ae4f21c30d9daf0d5c846adb96f3ca4b4c106d116ca528ea0c432988245180f96c6ae5c3391992eb9493382d74fddaae86dd5f0f09db079c85a43f97191dba99fcd5ce8ac1b7295462ca9bd8bb4a75e66dd0520c60a97b985dd6fe248fe0eabfc908519ae078caef027fad9219832976dec3221a3591353aea68c84f17a26a84eef6c0078f2dca72582a2e5b2d48236d79ac5e60dc0b7ba4fcfb813c534bbc2c2c200ca7cb0b4aefa9a95dbf6b92350ab3cd1d6771c57387497ba8adac4121b47341f781479eff94db3ccca22b741a963fb67e6c13dc4c45effa1588adb449a5f9dd6ccdea069d378acec3cac869ed2a6e2b6ed4885b0520e43214a12c81a2740a47191e587c10865922d82c808aa644afc5d9102382b1279aa0af3bf4d72b3bd8694b0d7cf53adc43d5f3cffd85c79647a039a34eeeaa810990b32af8c04cfacdcb315268f4c4b012898f55291a968326dfbe0908eacb4e38bcaa0458325f0ba7652de7fd6da6cf58b25562d772f07b3fe486369c0f800d500d25bf442530488c4c701fb51903e37390a4bdf3d73de83a603418002d152a314e6850883f46887c9fc97900987883485faf2d96fc5fd774d197a0788432cb333e9ab91bd94bb71f6ad6053d6e109c74dc7b0f0f63c610b089df94440ddc68016c897bbf8e6de33c054787433fd9dea74494182389a0b34a761e838f8d883d1f0601f67fc36c07d7ffc3fa7eb03e2107f51f738794ae3b623055001900d1b8a60a2b8beade5e22064791972010dd0e30ddd4d1b36fb49b30c2a43c50ffc2ed0f828061a2fadf35f7c20ed848564054ab14c8362776b2060580389b27c5530b63adfad5a0122205cb3fd19460ae3352d3f6c6647bb74c43858468d6edc51e37e1057e441544b8366b031736c747e0992becccdc7d2eb18fba2715c91d9d6386bfa74e7a8bdcdff2e5933f819a548ae50baa57daf05e901ef88094ae741c112ff9dea7124f56f016826e14c6ab119174d084f4f57c0d339e73e66e63cf9c764d54cd7c99892331374083d49b6f0e51cc925314210be139e061138d896fac2401d6ae2672f3870ef49c9665d3207d170a979107c40b31e6e6710fc178e769e799e8be3cb90b0792b7658ff17361c5fdb406946583e9fc5a0d45568836084ee40d718efdfb6d5825524cb694aba7402d4ce1c0bfcbfaefb2dd8bca9f002c64a13c7a6094597eb25ae95b5039be080a08e59aa5a8bac8e81bfdfe950fe46b7cfb6fc35b096a74b055464c672063f5e4ce01ccdd9b873a5b0257aef9c021759ddfae7b286a5be9cbbef4c8e2a3cf08da6c83c87150ee1796634b3691c544e44f55f9c0f976a4933b5a1bd16b4ee044dcf7032c893eaba6afc255b57192349d7022fa95c03f5c27ee6711ab6b789901d3a53f11b063649b938ba0860eb3cd7d2f762bcdb770b9447525eb0c82d5db8a427ea40a2f0fdf4803027db382b556ff3097689c484bb4e219ad730ad4fbe527c69edb344c0bd0dc213c5c8396e7a7f4930b5c79ed5cf1ca880afb2ddfe12ba1dcc5b11ab3d0ba51638ad5d999b0636940d47d12c3ee1444753d3f5cf95f40335c5beff44986a881fd5f0e22812b34070dd0356ea8512b8978ac6f43ffe36075a8b710ca6a70cc5c0501797adc771beed3d2d15bcef0bfee4a8cd7f8f0a928b6cefb693986c8eb08154e18d3586ac958c5c5586b724e8b99d97938aecb4be1d73a4c3179168e493d7bad1c57d86c334feeecedcfa13b6ccf2900b6c87261cda15a93522b513863b8a3dfa3e29f4196067aae364bd6a5793117b722440bfdb3c679926b4a2d50fdf71fe18df9975bc22d1d8a21eca74cc214fc52751e5c116397f67489b9b454e440e065140c98d7aec449d2fd23a7bdbc9978b50d0d20f692a19f03cf5ce1852d42647f8a7c8912c3a6ac006a8b77b4ad10eaef11616e7f407127a2fbb0e68317e505b22abefe534e2ca9646d5cc0e3cb1de03b66c85a5bb2bb821848d1036683eb6b160cdaaec4288beab36e73e526097605efce9a4ac9deee8fcc5bfe5dbd5ff3994bff2c41eb2b7e0e31fe067d1f8b4e554f71eee9ec447feb327cecc41ebf54e686fc1cdbaea792a804cb77dc2e5f5e1f85455859f6299d6aebb96d6a5e6302648937df0b41dc3dcce7acd9c43d815e9dec8218311aa8e59d2c62c9ba1249767689b0e9058f551cac8f4e6b6a50d434780ed8bb3579d574f210f7a2f0f0b79f9840a161babfeb78cd42801047839ff01890f30963c0b52e363e93cea76a99e5cbeca45d4fa9440071ae5e4699e0e270b537c671f9e25112617c75d5126f520b41b0b03fdb206f420b038f82d11956fdb9844d56e9ca839b852df85f9836e338f8071fb7d7f961b6f27fbda393dd9b8963cd55a185888b23a35b1189b1cff8a2485db364b6226a4ebf7eed09bff38df10d6cf69025539c497cb801c7e35468680be593234a4b10275b631968ccb4c5e1cbff77c272f6f6786d023c2fd4687e977bfeff6e639ea006c4df006389016f3d848c86c9fbd5aead8654993e582e25e71f7b59cf7c0cea56c70acd721e034d5ac9e2a0d0ad5ae8be0eb96651bddae42bcb0b17171a88ed1146bde9f4d79319284a6bde17460a4c010856b97337e6381e8fad212a3bbf32a8189e3c4f0df13eb9344c963daa399bb7b449b183fe4a1053feb13808665aebd890ad7e3220b08efc61049ffc9b1ea873ce20cd24fc5c07c3c425b7d8f0d27af2558515032d6bea680cf640fd49ed1523ddc4b28a2e48e0fd2ca57b0192624dfc1bc02fc79498b8a1cc591da032870aa9ca5e3168b3f81512783eef577e4b18f5744945e0bffdd108f72ee12dbec5db5c5f4f34a6f2caa2fcdaaec8d3bce801af4c6b40c5b9b98d7cd7460385571ce124f93a04f403d79a92c219d2827d57b8b467c95825476fa86279ca1446240b33c865fc433410b1a875354ea99b50640a354fb508285dd62e4427859190ed3f2c5649bbca574a8f2eddaa89da7b8d19446f163a9a016d40a5bb27110b7d06d41c1e7f22d5d89dccbd06d1fc651ed75ec43a8407230abc65cf4acb43a1ef77f1e7bc6a3a0bee1693a8e9fb82b3ace06b04b79008ed9f01a8db078a0d019979928d530e68959b8dc8bcf7b7e15e1fc0711f9c2d74a07d39e0c040813b72f598b875b09dc30231c9ff2a1e94703d0d19ba8ba5412e8bcd2748061161294334cbfcd33022c0c4d10b6f321dac71a7a1216f5ab834f52e489d41694e351008197fe9ce2e45c4df84f0813654a20371d253ea0dadaa90313cc9ddeb2ad11597f9bfdf6d7638827b5e118206dc5d61fc94afb146e043133111c5606ff52f86de659475b3aea16214069443cf90ceba6251703d8c8b0e516ca49b4f339fabf0b1704c9df2faeb81f44b0958107e858a85bd19d6f67d55a7cf0bd400e70380c6d5efbaa4886ce79c0b1f7d3e35f823cb8449c15d0b509630a718a1c180fec98458691d92019748c323675eff76ff25921a2e42d644382104d19b6ad431aa0269094ecfa76455e10ddc8e475f8b18eea20c112ad5b5b25519fb4f654e2447d773024f62a3c07d39b2849396555b03553591a0d67f24a711ce0b3784124094220539b593c41e32e2dbbcfe80fad0907eb203915e20f40b99ef15dba72e7cfb639799d0e29c106a22713cfc296108ef108de772d427ac9b3c86e7a90b79241906f2fd266606651584f6270304aecf9c87aec7a81ad3014756a9e3b7584523f811ee86271b4b8ee0311e6d01edc81d24a943068f4371d2f5809cd5615a61ed4bb472e656ff430996346ca0ea52feeda53e23ce067e4c6da4ec28496b22c8e8250043e44cadaaaff74fda3389f382b0c182ce8af3d6a85ce8d9d596c3eed3bc96f7d1afa68b59358d32e45f7675745ce3ab0271e34ca7901df3345e77fc8ffb918c6efda463455ea68b2117df5622936c73b960ca84d8781f35a4e834f7460b8c5ad4df9e1cb250c65e8f53e60eb708de00351eb00035df93c4b486ee855b607663e1b1e8dd3bc293bd31eed32d67d74cb2f4cdf9db9c0dece56dafd6c6eda6bfb49749f1dd9c6ee8537fe6cb518fe5e60256d3c586d9c6d59a0fabc0d0fd7a2f13fa7d65d8e1f753a50a2f17b8436d633091b9fc6ef0eace7d46e1b3936a992aee7599f6aea28373bef86f590211fb9fe501d8b919af42f2b8134b1f6e024b5542bf4c5b3ef5b50afcb4325346a774053f85e6ea4dbf2c4a1ed941d370e2547ac0f738a1e05d25f91e3ebabbab3176eb2fbc0473703aac27cd53561da75c7739f653c6429a5b7842d02538a8ddd58e73dd2f2641f7aada5d843b07f088f2782a7ae9b310a7d7942a90796f0fae773aceb432739ba76ce9a5c461661936bbfc806f5eeb22147fb3f78c70c449b28cf5fac018002c2729d3126ee27dea1539a48f95e4ff6fec09b4088b68e0351f8069b576a327b046600c24ac1a9a5f6cead9d44b24570cfb512a330bd3d3831aa2df3037205f488f23c18874cffb426636ebdd919ce318c039c92d3ac39d539ca90bddae216cba184d4a3a49336c4a1ead55c2cc12f26eaa5ffc896191c1beeaedf0b902cea66de10b45c52f06b77732f91f293f8ca34edfd99cdf901d4fdd11e45033fb0a2539e280cc9f33fd273cbad41516353a9f71f539bb787cd868e1bc487997ef675927e56433421b17c8010ac0beb989a2384ec6edcb1ce35a934d3efa2d02b7bbe6b05e280ac5003311300cf4ba297eaa707c6710dba1386f13a925567bc882c976da493be591ad78018e052003aa757c19435a84416d4f316546a2d89e2ca9ece782c11caf4f8c4b33bdca28d3ed34d5f8488389a41c8ef1e69e88f3bc0da5c20ee70fe21ba8d7092be5f73fd5e8b50d1e4b56e41e910fc6dbd1f078e900931de9b306b856e961289d60b08205d1da0b486a004e246752e6423aa3715716d765c043c345b82e098dfd2a654604b29f2934bf3bcfbea8d03e65a68857aca88308709ab393722e9ef255e038ff99c1f242840bc7d6575c7121092687dc0dc5fe3e8bec3e6f9cb9411823a99b150597a6cbf685aa6e858b935282d7c5ca0bbee00126f8b6f94068ffa785a1c7b84278cc659baeb81930b93bbfcf4cbcffe947ddd507e0c8a582d1f1c278eda72609c143686fc9fe46514d8064f5bca2e692db883136aeec48920291efc994eb7f8ca5739a353faf9e0c1da701d20184e8ef9a5be5588997bed5cffc3939bcd08e919c60cd1c9b38e3adfc37bd1db1a6826c7d17e85071b34f181ba4e319268ad5c4e711f44b3f8321fd0043f3b4cae0f681ba7d184614d1995ce6b5c4421d2b55891282229a0cd2e3a94899bc3c37ebf68570a9616a82f9cd07f60501704da9de13ad562bdb24206a49ce45ef8e62c1ae08ded2f447228616d2280aa239311e9016b4ac75e7ce120a961559796462b66fb192c6eae6e4179c20741c669108c7cfb811d17772dd13a45726eb0d388a3d262e726809c20b34963ffa980b9ccb398776442399b649cdcc6ba12a8b2976ffe88747996b2a063e46c397291bad4f7726a4288ec511ed1ee3641723a7923886d6c8077259259cf9e76b5d4e8b78bd2922893912f8085d1d0917118912ff473a3b23cf9dc358fbf23bdf8a546299286401fbc8d03217928653df6893ce239bbd41484b6c1666d0c93f9509dd067593657c92a24bc0c68d204aeb8c7563d45f5244dbd6464bfabced6e0756dfb51a549f08ea12c74f9baa003e333dd69fb70b95eaaca6ab0d716b96bf7780dcc308e35e4f1fd2d7e51a541e392f3f28230e90c157fa000787798f4cbb59d1e3d86e27cb373f55b3fbd611083280e554a6bad9331cb03b18fd4f0fdf101e4980bfbced58a3ef0b3aaa40a08a5b954f6c73aee34e710bc1c8557ebe645a8c1e5aba32112ffe9d695eb4e0525d77d5fa8c5498eceab27b3e18c0da16b6260b2f909bd72f3aa2e3ebe2495e4a2f7b0f350fde69face3dafb1874974c990e4c7bca0ad0d24e88385a12bf6754afebfa0bbeeacb88af6d09a7c66aa1a97e5103be21d82a6910505316ab2b2c9c1a1603ded130ff41cdc87ac3316ad7653fe8507e006cb65a3c5cbdb146632e3b4852e8cc0847200fad67af71f218bb3c884af4de8e6a2017d84d61fb6a0e89f66ccc694878cc0da1dc6106ceaf707f3d2eeaa08b2680add3795c383c1bfed529a307e3861d1e26451f2ed7a7ef075adff1b64c790b6c803e4df33058417a5f46a1938bd4257bb61483c090dccdbeedcdcbae2d370c3e37cf79d66f18361107392408e8795bc63e722b35b681aa352b0fe80011d10af0bdf4a493fe03f1d87967815d199652800a59e8042925517bef9691d38e92b81fe539c62db22e62fc3e86cf8b17432f21d0a39f51fad187f782b7003e6a6a0d6f469fad9bfed7ac460e4ee9df7bdd87faa9c51b14f4b087d4096bf9cb10b8213aaed1bfb50d58c14de9809ccf08f5108018cf2fa58dfb0fa522ea1f995c54823620410540090bebac5efb6752ed44b4c844613c16b70d4f205b76d9013f3242c65f53d2dd7c61ac535c9d3f70a1d6773cafbdbcfcf6aaff0d3ecd9d55d72d0641de7514980c0e9ed782d6b458ded78f0e147dfd072b03b797536a372fbad5fcef9090d157e51a4f6f1aa6c5f687d8bd6a06f0b4589e73eedec453c08a569245341e8594ee82ad59a40c5e7bce1cb75b62100ed76b0f27b362aade9b8f58d1bfd30d8c8e086c732a6a1815fe60a2e5c6970f90b6103ed1b6e4052d739be13ae0f8b550e5f31f4750f8cc4b2d0c5c7383bb28ddb29b092b91acc3d26b5dac954ea082b816756f74678a114ade3c2789c6bd472d320e111d4510cae187aab8fa1552b40ac859c49e503847f1ba727691c028d5a759d1a9945c210a56f1496d5b51daf8861d4b0afa6787661026b04a296a0964e53592f738b7f663d8ff9a60b1fcfe966eea96a7d5ef9f33bdcaf3542fb1e1fb6d18be082cb97e40fcb9a9924f2046a5b1b9d076f8365ca7f9b60fe997fbc4c6f1e61fb421161e462ef6c137a4953b90d2d6084cf829c78f12573501b6d75c2b9b61804719174b07a3823b2c55b26fa61d633e4bc0942ba642afc66b602b87d83498d94d30bb7dc64baac21274d81f7ddfb46a30da38187f57a0e5b4e4f5908d8c4c218ec1bfaebc1809d8cd8e75969c687b6ffe7a7d4d01ffef9438dc2c1ae406351034ac68a1a6b7d8dff84f34e668a33cb32ab2eb50a66ac4ed501a838592b4eb0862bc8f272aad288f3d17358e21d18820b9a3d45bf1487e9cb78d384bda7e94d7fa2e9235952359e0bc6860f53da98f3be071645a84dbd1c5c11eaabaca731b8a97a6bc2ee5cac8be55d0de6c53ab797001687435478454e24d514f190d3055065ae27143b64963761dbbbd5bccf9dc93a881bbbeb9759f0dd7234d6534162c9342938b102f900b78c44b0b43cfc95d35c01ab359041091927fa679dee0e5fb7e12248426efe0fdc0be8b68f4da463c364bde72d274fc4e176d91b4ab0825bd6aea253d6e826e50d98930b2f5bd8466a10272e8b34e2745e06c58bcbef9e72cb6a08ec8aa3af851f0b0c4327da1d7d8b9061bb4727bc24c1642f0cb3e2cc416cdaab8b9da6dce23fbddf8115e2d7427f23a9677cc339b12abbd6f173d6497c8bba01c8e4e8ba18413ed2dc18d063c6f6d8defa1e941dccb71a42ed3e4d0ee7723817f9802d31f8365c9575e8ba4a08bf315cfb77c54515501f276f8e14491719b9fee187458ec46a3dfffb953a9afcd1d6fb9d59c8937937b8381ed6a186eeb073450300f3a4a26944cafa4cc1893600c1ca9845c441ca84cfe3dab6af6959d2a194b282045485b309659c5cb708438b160ef5557eabf4eb08cd5aae257f18e733bd436aaf0e0dd059c2665c3c8fae7cceae79ba66e0079ffcd93507b5faddf059a984162eee431221aa04fd85e7eb5934be3ec02308c9f9a40aaa88ae3b97c2ec98ad0bbe8e144e5fc1407ae8fead3c658b8d6dc757ffb958fdb3c2f3bb4dda6cd8adfcdb79c9355bcfe91d79c8e0cb474374267c05881f60420c2cf3bf1daaf42deb40eef3daeaa679f0c17e4bf238457038187aabf60dbb46356ad9caa2b0a16a55cef1cad3943b5c8c83b8cf6db2fa10b0cf189ddb23401e4c3e4bf753472da372c7813b10e2c537d446a55bd1ae83be01574392a8071559686ac74cbcdcfd3394e7b163f36b3d7947ae1fd5add74813d4606f9bded76cdc3eba5e29c2e72eb1b6750111fea7c618c14d235ab2be260f7d43bb2085456c1d2d0818f3f54ee45959396fcaad0d49e48a694eccd75214d602dc2d09654423a2c59b2b2a0c07a3a75848ac0c137e4a381d6f2fe323e0529323b84a20a5dffab9cf3f2f7345cbea981920d6bdf77a3b4b5fc118d079aa0dcfd267a029ae403f046a25da328049d61d7aca24cf1510e5867c7596f2436521374e389275cd006dbc130e2f1ce1d4761fa47674f1a720eecbfed090249a545788f79984de3dbf181a9cbcc621c09d433047af944ae630dcc2841010116eb31b56243c48df065f232358a39292f0b148d90c912d193691846a0a92821b0d527d3da66dc3393c91d90339bb3d1f62bb74c08a1a9743f7299e061d4470a185bc16abd24ad9a67fc1067b1395b690dc856b9cab37165a0038e3a4e76c5abe9eeb0b672e4073204637fa9a6f72223ad1dbf385c1b7b67a38736238d33f730775e15c6597d0666a55862bf86b49d860eab298f5b3f39621c865353b766931ef285dd43932106927437fcdf41a28fb108fba607f73f56408338af3b6bef6ead2cc4ba4d55ba2de77cbf92bd7ab196f80f3d5b67bec670ff7792db33611ffee004680086d663797c7d2cfafacc352ff0f4bb02d4e7f00a3caf7ff3593ec93b98cac719ec3db085923460b2c04e13594e34d4ec7ee81d6811cd6199553f0743909a5b4b134d7f26bf4a57ff68b86288aa7920f2e79aa5479bed71cc7724c62c01298e3e277df545a393e8f1a50254ae92fc373003d164fb309d41991cea65775a09d6845fdd2d31ff423c283b1ee05c85d24f410df00b1c89ba33a546e7df1dacbc4bfcfb51ace26137244068bbb35ab4fa32ee102d04ef55dd83ef53bd70412fe74aa239a55b9c89db938e7b5cfa08c2e48a2e31cf46a1f78c65e6f6c03c00f01417151b3275c7a532d09df8ed4576cb18d3ec5193f62c5dc4bcbdde55e367f366b99609caa62282288ef76034146aa468de96fc725bb82e4ee04b79a91e1816e0bde22c0f76e7b21cb341b432c299163ee3a2c9b21cbcd356a239c87e963731c3d7676bb37e1f40c46146866441fab3358ee72249e22463ddc0a9ed38cbc9c07ab3c747d1bb2e5429f10f9fce5ea20928c6da2f5f4cd58cd1dfdb91b31f9fd7c0d882421ea5d793e74f2b258be842b152cf5296edd972939f1977ea4aa0a73055af09a1dd81880117dedb1334217674be824c691d38782a21b893e3e966832e82eee20b66fcd8fb0cf0c55ddda4b2b78bd66ce5323dfff0b82dd4421946e59902a81dc60647aea5398c070585b011bd0926e0fa2d373a9657d3c331b43c85171c6f2a1f358f530c1833072d994e0a919acdfbb469498b5d6eff87d8da1b045eaddec5eac419df83721d13fd1369691168189c8a2630812deda44deb28e52df59f9e786d22cee274f5b443c928939a3d06f7376aa4c6d62a1d7e2a3e5dd0230c8ef764c46a3c0103d86d5d36a0871e5f67a6aae53ba8a97d16b303023a48137b6a067ad18502d04301511dc8fcd2de28cd2eb7fb70501b9a0f6231373a276a9a9ac0c55b54d2696d391484001cc07f13f62042ec7ddb93e98013e7b0ed60382a1ab4d752cfa96a9d8fe7359203c4e6cd4d1ec88731a79ae3a903f63a8cc01d5c6299066f97521ea7edde60a10bd868e183edcb9e1328b6015b3981bdd2383bb0c598a2c703aa06911871d26f0fe82aef3309d33637c48a0bef23c8b977161485b9aa85c5d013d4bf1172d2af79f2002a70f82d1fc83e503f5d77041fbacc960390ed18b177deb5e503d96bd04de41d3cd539ffc662b94792eedd773f276e4ec731995344c789d51ae1d36f6c5728f8b826fcb258efbd532710045498b2b63e24a914b2c025f090d3e326a94ce4295ba1e81851b748865581c91f1797139a7fe32e34c346c27b3c349286869359d56834be916e1b1060c45171eb70623f74b6c6ba510a8f1f9a3dd6063e3c9d2c17034e1f0299129ca3945097b3acbfce2ff5833cf6f2c38f66c7da4d5aaad12add61734a6d920bcb8ca9b338a3b4b242d8b3de2869f9e767f4f699f23ff6bca06514f426a7d5abdafc5714ff99a2baef46c02c366acbdf8c89c506515ef8288659489b9e3f1a51f8549051847d85e92338b5fd70962e27759f61f98348b1410b3c5a0ea60cda8c36be6e06d8b89181d8b24542bad5fbe98f7f3d07113edb523077e5c75a60ff8acdd60906ea788399cff1ed058d3af8a10da3111fc743b3c5744b1d1d2abee81e1e0e95ce07c7dc3188b7e54199d79cb0113abfe3faac0203f2151c8a7fc67a507a1da2638d198ea397c09dc028291c2f4545a920555dc8e3416d67dce7ac616e4fd9bfc3f4b2bc70157ffd96c2a8197f117c067a3fba09716403d8380f104be7afcea4503d4912041c00495e3f748b31d7a570f24ae8bad1d282602093060818be965e8a2a7da3e7d186c476547715baaebf2a6652b10c18e392f6332c3c35d3bd96385fac202a237f3a12cf127c8c5369dd1c1a2cfd7b3f7aaecbedc42514352bca7c8c30ce4b2f6f26efc47a027847dc7af3bb2e78da8b710785ad50b0ec106cae0f3feba1e30b0fd5f88955b749b2b47ede440ec1a0ff0eea47038b02415bb765349b9b982644cbf6e1bde7c897389c2e84fc5a1aab5d326b4532314251ec2778b37849b5f7d53308497086fd6df992ea12b0bb065debaf572f57ce64e8159daf02ede56472c244f6468c0a1ce478eb187cbe772deb01aef0f1bec2fa64d0b76b91c1dffbc1bf3dea9d09d0cdbb465fc1ef851ff7bdc72476ac5635c806e4182d34f5879919de4a248e27d65c4c393b95db91f21e2afb9312804e9d5e19146328622e142cc122a831a650832eea73719600c5b34368bfeea1913d0666f201c9d47272840835ebfd83fd276b3dfe4150b0896095926f5ce937ca072628ccc17ef6287fa2cdb5c88641d60a6b88110e4d35d8827da41da2e3717b256bef3049631b023d47596dca1dd0ea35b90eb88c07b8760df25b6417ac661c586ce2e9bf1dd76e38ac50dc76cd29aeee9b4498da0f4633272fbe78ebed0ae47c839948f10899e869f85119c5f51b7e82214831ccafb506bcf3d08be5085f720d02cb3c7dc54fb1aa2e40ffffa7ba0e1aff72be3246e7ffc61de2b59b4cd19977971e69f3401491f76cf470b0c6d42a6e2353e348dbd4ada542a556876a90ec24dc2b9537c0b89d1b607d93a73de3286386ec7c97d1db5b175f65616e64cf59c264a5f9a80fd87519f59f71cfe0e67baa34d30a5fcca144e3db190269da06c58de3152df80e876934486566c1135e03dc2fb917c3a0a171120654227474bf9f798defa033599fd3a7b645eabd38d67cafece4001c3e25a1f22a50fea897812ac72323c67527f6be375e97c193d03b457ee6f3828bb6bf43ac6f3a315ecabe751d1702c72c687f12761f0521f28d07a3645c1447ddd52fad75a790a9bce8c19f51fed06b9e2f04e86b102a7e6cb381028128820393e15409556f9752c29509102fa01f78fed4099dbd86f55377c5c2b980741f3146eb9eee4b345ff6d231b609292278e43476961705a2b862f4a8c5ff3b32eefa46f1a091a2e3a0c3b395af0aa4925ae46f0f8b24420b3f91614d3911c721a924bd6019a5c8587af22b243228b61aad0f09bf8d1d0d3bf91cf229a55d974c142a9287b02e89d1e1ab09d35ecee04a816df056f21fae453efcd70222f5e8aa148b4f6f947e46b38efb81cdd41afc0b4c6ae2024bdd739ad865e67534234beb780fcc50a5b56a079f9913635794babf5e0ef476c6174dcd749f25073a35bc642504bed88450e4e76ac879bfae785083e0b95075d4f7168e909a410ebe9376238ccef6a9af859a3a6c419ecbbe0700875b56e478a7a20956dfcb653ba74ffb2d6d101b23ae669ac59bae4ccff686dc879398cb4ae9c2ba9ae95b72c597f939b47e6e24132e24ff76917c2b17c1a8005d70f5d6eb45f33b3b0e3f718fe019ab0805d18f8ee34c852615270c1a3ffe0062d78b584c96cb250efc563915c5898e64eac190881faed2ead345223c620ef07d49527c7494ced4aa0cc901ca4675a2dbb172f7fa7f8694d0cff0cefe22136ecdde83b92b08d6a748fc3df9a61bcb19e86b077f9e66ce269db323a08cb419537b78f11d394c0c1c4a187d7d785fc990b8633ea4febd532cab61755cb81d74e014e20d508e505d29145f51dcb67aa29ebaa88d6ca259e0c12e457bdb6a7e873f60913530675332b6c587ce37982f380fdd70c6786c3b94d6252f7730991a8876894a8291f0071f8c9e730db09d1bd4494df6c8f912a7d611ae7c5ffcf99f3fc01244f32e0468c5d4a54ec6e6bbf1822af75e6584b956a103a16d586779997d1e71e68aedd4f24766a24bce5385f8351630a96dc385b4dfc8bc644f5d30582ddf60bba1a5046fe80247e899687c6d437032ac869d014a5b84510428af18c054c0283dbf517404216b0d2e52c4b3921ae1683cb7781f1be5d36a58cca4f52b436b576a6708d53e8d8b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
