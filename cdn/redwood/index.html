<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4d2b39f2b2aafc761ed7fdc6f2f019555b5ec0dfafa03a2019879eb4ec1b43ddb232453ea16eeb807cf1c7aeddd7e5eb7705fcb9c92432443bf8bd3b20bca66969aabce51fdc6ec737ba224c0c9af559c9723db1dd5ef3bf7ca064564099bbb9a50e6f4cb74820c42ea3542d280cbbce18f6b38f2361590d63a9abdf1982ed0d65c86b290f2d6f7281d6739661066467fe2c9878dcd6e270370a6503929fc7e592eeadfdf5b707905f254ccc61881bea8878688d1ea237188b27b5deb76863879c15e138622aebb598d5b071c917e9a1419f5fd952bbd90a24f05d1b6f8920c3f040d8343daac7c9b75c1d83b426733aa3107453c60164e983555a718c23b60baf59660816b80d3ae668ce84b1be4943c1fe60131ad032fb463b67b1dfeed2fdce99e9d3324dd9c631ba149a1adf1b116fa07c76e6bf1d223c19ceca4bae6bf0646c5b2478bc6e464df3f5d60a9aba046803c7da642bf657128df9d373c6fc4d153acb30d9cef8193c6fb08724e8f26fe154107c1c6abdfd5e80fee6a266fc2c01bbb41c6fcb933e808c72404c19cc92675d50ca8d4018d9f823c1a2bb4a0ca972102f3fb50ca46d76c4073cffccef6f50caf0c557a6d22e29f29bc0587675d48094bc02cafdfa45e62f934fd099d9e01d403c98ae33e411a464211226f7d985a4529242f7b15124726321b8a25b3041bca996de116b2014a7cb5dbe37ac1680a3455d8a185fef3fc02091bebec073cb9cbaffacd1dc274cb5386d5b0c541e2233433a0ea168e4d3eadbaa7c0f5333e830216070541cc99a8931815ea5142be687dedfd4ebbb01abc53c59e1767abc8a3562b6b245a49c8a48430acdeb8f87a5d737da41f8c950e346969c3a98e837712d5422fa1f1800d4759b122196ae10c18fc79a2cb30568394b736392878bdcacb17d1f4c524c1fa8e5719e6aa9114d7b18cb342d612ff48e524f19bb9d319c3e584551c5e7721dbc1b7697b2aaa0b6b32fb8511aabb5e0be5c2fa8c85adc6fdccedb2e49e555bf06c4db9f96aff7ee61d34493d7bce1a9207a48720b8561509d82c53a166eb2b3ea4e5d7c7a3c652ef468797fada8cb4e7633c20cc152d3b03051ac3211e454e0ecd5ff07752e727f7f4104b887bc15ee3eeb29be7cda95b4e4073eaedbbf863012f325e5d9b9a19d4c6f814d20e5a2e7a3fe0d817c3a604b009397e93ab7e884158a64b29850da7153b255d6b27549e4d313f277309ca8c5d4e853839a2f3258ded2393105c13386d6e437342a471dd033a21e72d4200065466893763d04792e13f241d7d983ffe7a5f399d11b2d1dec9731a8185d4e52892425434b2b85d8ed6893e25addf4e2c5806c9167a1fd7cc57ba2423d9f09e1af6ce94d88e8d61215990e41594c59c8097362b31b66815853bf0a14338f0310c562d2938aecd6219d640397a4d2dd609bae38d3d5c98342b8ce778897d30a01e96d8a8885e55015cf54ac7e29b38cd4a06c99e7abdd053a402b10ca640dc73e2c99179474c631df470fec349b30862861190aed6789c9a7568cdbc0441fba85e58f23947788ec7a4399b71f1228cea594668dcc64667a1c69ce0853ded8f088a81784613dcc9f1deb04185fc8bc8ee13f76dbe27f1dbe751a2c78b957abcf8c987da141504711beaf5931d29e9407438f95e2b0ead84c3af1432cbd126b7b1e1cee20b4d65ec3fc34549c26605324c5c75d87c2aa4025fe2354ccc5d1cb208031b226e004aa3b328281e38ea68a6ae08b764dea97d42416deb8e09807ab0435a1185c28380e4f53b78e40e646075705b332ee7628648ecd47caaa05037953aa1cca7592ec7d757de42f6a7a281d0b2029314193e13c9aae61c6f385faf2f636c4e21b1cda39388c1d7fa27e3e70890b7fec7a47175c74b7f8869f831d6f46ce279c9832f870116f1d2a08faee01c544de6706efac5def68710c7d89da011b751488e39069f2249cc3b1acae09ba78995ba1cec428ec466eb609cfaa185d339275d8e29d946fadbcf107c7ad7f6572a9366287bc109d8198559ba8ef68aaee791b8702bf1c5b54ea7efd091a940b431489757fb643522a68008acf187cf29663d253be95726230fccc6409512da72cdcb48b0a83c5b7cfce14e29d4d1b4cdae59bea0ac486606560fff3e98e39a48a8ba01c335b9c08b5fee980fcd8eeefd1ba1a879671b8303b0b36eed31b9c7de1ee979afef7e3e149876aa72a0c6d2399e095883f2d7c200e3c2dfc18282b0e2e45f1503b1bf51d93e985539401486124395d21d87652fd166ad50798251af47f23775f427369bf28bd9643ccca5f41b9a34f476c8bf2181c6fa65857749dc57d4a3a12d2dd527418357107a4751d07584c42961d8794da13e98822b306a15be85bd5bf65c815a7fc8d541a41d6960c7c0ced8433862a2dd9e5223a4297bc44acecb7389095ac2b243070391165994119f6dfaada7a26d5eb8d733270e63586793e149ba272712e676fcb7a49586dbe05d3bb7b6621cec02317f1f255b303a6b5e9be1ad1d50824a8f086f54cbe1e0f75da2634d444a3821746391d0444f7fda3d60a0f5365b61a99ce9e79e8c360a57fe73b6609fa9f3a9316cdb6e3c176b0cfef397f5c4a40e72818b373caf28f730b642deb80997062418bfe3f80623d0539fd252c368381cee5a86280c22842763c9670934c04fafafcbdf31b921b0b7f6906be8884ab289a03ec500e1666cd0d3520e94df232832cb3c70f55929246c8a00d26700d3665db120cd2fdaf83be5c533a9c0d4c9ebc0ce7d88c9af43ddeda2bf1cf1aa3b2a114087d1a42f17409e343057aa42684431383708bc4c4b44ff9cdd249803846f68fd46842e3381313ec2c6a3ab05c7c6fcaff39e25ae52be076858910cef4c45c425eaf69a34b1d0d3c5f5e2e3a6657fc6d38b126765525697cba876587843659b5364a1e2757e214b79d53aef7d8356c767bf2e30565f568af5404a97aa5a592006467e6211f8bc1914a79af2d9d51abc7e90452af0e2193074f24a2e05fd647c890c328faa86717664f72d35d9685fa0a469e0f41564f531749f6029930611447b218edb52ab27ff94eb760bfb82e9d0e2f0f7aff86d820379273eeff2674f9c97151a3b0c0bcebc14e3a61022b453bdb05b68b86389a8df3d8e78c73ca1ce1c5ad55c8eec3d8bb32e20e24319d5e1ea11ce8fb01f07b05c142b713a3282856a562d1a56dc0dd3748bb4e45142d4f80b9c5d91a5e0ba79d806e1c5b723fdcbc270f96f14642c2d9eb9d5363d1c955f444958709260f0d42a5856ee042956d03f4118d0619ffd92c9e425ec0ce0c3028cb1302679c6ca52e745ffc869685cdd6fe6f51de67ff820c9491967704a944476d34a16b19977442b95e1822dac13fdcf714f6effdd82f6329258b953c0b6a2ea34d6a07408fab1fd28747c390f9838344c9514c0ca622c06d729e221939b2117d8f1a764cfebdeb05a36265961609161388beed68521b9e49f0148f1180558a26e1089c9b6877c9b323c2080ff61be0be7878d2efd49707ac83854beef7b76f060828e4a03c9db141cdb76963d574262d7e1ec348290f688f236ec7cc9eec886e597f87de56fb332790561ad11e922597d8703fb5ee91bcfbd569b81d03a6f82f27716e705f9abe161bf2097bd9927f11325f814a87bcbb526f4ce44cc6792812e5e519e41153190d09cb4f23f79072458bb7189153ef68fca168296cae9755f514b9587930f4713beac46e126043c8c724d1c3c9894a6df93fb5a9f94cff26d99e170b8aecc085940b6c5f57232518973b64aec1a166af5f7eeaff8791d31ab2c4965d72f7b1bb8f50b0a16201617eea1f870ea62fbdea4c25eb94e5c29a97ca04b10f5a328d21193a75dd8e37f168dde1a6f106ca52593be569fe16b1256202fe018dc0e4f397e952dea6d5fd6f9166f4a0b1f6c15129e6179b39b6d4aa9324888a57856904db0ab397b3f565b9c68b7b8ef2cbc96a9d343574be4f24a536af4dccf4d0f3ab94df06be619c5ae410b399d220e96b581edca7e55aa5ab8a27a89b7379fa968a3497d8d19bb9e106c27b83cbfb09a5da3e4582144702a0b014c6020e0b75756556e708534f874e7b8cfd294d403d5675b2d686a539c8b1ffa36238c7148651dafa3fabd08798e545f6571708eaf9d1e6695da7bcceee318fc7e063d6e93a8a2ecedf85a276808156010ed38ec1e7d97f4166f528c7c73e568f1404932ce52a7ad76d6ebbc1083603b32f30a6b8028276cae94e47933f4266008a908570373db4b95d452bcae9547e6ee7dcceda653d24af2963e930e5f9e0bc047f697dd167b53745b1d9e83e11ba16da7897c4b75e241adca33dde9591bc865eb69b3472ca2e606f8f29d95ab145b1f46a04e3d2b8dff9bf1cfd04d88fde71c2de9d91b08f7b7f7441efb35c98ef18bacb2f29188b8987997b3a7899e67d3d7f4ea78ec25ae79ae09e54b172f4bd261390f7b6354cd4478aae2883de48269c4e1c5d382e1415d5d8b819590a4184f113134c7e4ad5a56e53c2d89b71e7319d2b4876349e59ed0ff1c978df512734888adabc68c18ead1763299b81a02cc8348d0a735107f0b5462b1e9849b97af44432217b3f88236b7a25f6a67af4b173448fde160604aa45f489324aa7aea009a84a87c15a0683c65979618d864a2f7b86a5b4997997b9d3af9adcf59de9c0356af8ad92a4994fc34b0e0e96cf624f36eb31251a69797fe4a73eff50f2515661ae2ea57f4a6b26f49acea97e93c8e923fdb371cb1a4d667dadbb0c4bd1e75ab78c781b9a44e1de2f76bd3a0a373120e5777b938cf93aaee73a445cedcb02d283d5d3114760b29272c9550e958173f3fc019626f288bfdc98553375171ad9715ba2affe674d48847531e81a5609a658e90f51805a1506e6bc1ac49965e258ce0bfefbb83f5bec95e7b254cc3dc573634f8d07275b3df3231a397bc95c1a82931dd4d18b25dc0c15f00fb63cb06a38dcf1e6af245e3d6865e8446a397c1177a89337e8653272218033c83dc1469ffa9e05b4a0728a142bebea4107f65b30cfb69efe1081cc14cac4f34b5b660bf236e535955fbed6edd4fd0b9d5570ddd78f9052fef45f968d802ce4a2fa8a6b438105e443b16fc769a937aa5618b4410c00fb6378c64fce8f85ef803d8d6eb7d1055f0cf6f54010bcf8896f9c4255e1ccbdc6d039a4bae6eabbd89a76a85ab73e17e434c39697c9d9b7432a2bb59c92b3f61a70cd34e374a1ec2e0a8b18c89c7cd20ee045951d314c56519e5cd44d00f1a0f67c6ada8d40e83dfd582b0ff68f5f66d1da3d24f4339c67359ce877a24d16762290d8d9ae6308abc31926e9606936f52185afdc27e8a1dd9a7e4268a498000f382fdd529db6bcb7ffbf35963fcb183badef2c40cfccd04b905d4033d3f71bcf706b4344a5421002daaf5ab49d19c6d428325f189730804697ebcfc78abe96302abe7d43e57b49357bde4bab8648303105b60e53b66e008f2e6e34c81eec1d806ee141ca19a4fd9d865697e8224a38106d7d6597e52962fcf1799e6c6d82378e7842f7cf22d656ce79cfa4d8382d6e4bf40e15619f5096ba950dbb9fe8da81a0e15abf1f668abeadf2ec21733cb58424dafc9b37b463d44b93b6d10f563c5d893818cba1f7b17bbb242204db171c359d064191b550f6be796893e4be8a2c959b0e4c873641392c8138d2924c457bd7150a908e3a5883f31c336f41c2624c11e1f4a54b321b611b9eb009ba0a5c9ea14afa1b7b81de9c6d1e6d7535f964deeacdb85e83d6cde30aecd31805c89deaf085c774721a0db7072fe5370e1e6715c06b73a8cc5b2aebee3b486087b689c7161147dd1d6a464e0d8f6d7211bdddde256b6a7e67d5668ecd99eeedeadfd6a64ec69d8a598bae89388fc15a32c55c0af4b7f0c0e4c12d35f6eed5a20a4e82555c20a054d38e4b5a27b52b2f57087474dfbaa6f3169d572ff7e206dfdb38c9b306b21c2fd30edd10d9007e39c2f1d5eb31a24bd0aed3047b7dd15e9968d112994ad2ae784ededde123a7cd15e8bf2673455b76dc21fc5bf0e3468f37f6efa8cc44718626480cc7cc3b9b60fc1a04910bbbe4a0782b940cac5f4a967ad48779e6691b441636d793343a869350ec5d4a7a1427336394992f115c07cf2464f670ee34c6d4364918ae4e35dfc70dd53060f4f20c69582ce3408ca09099519bf6fe56080299f4deb3757d8514565fc1dac8158fa28631cef92d7605e5a552b6e75305436bcffd33d01d60c115db1685a194e84a99f84604be68ff7f56f41bce679a4d165ea71db1b61bbc070b634f649e97b68275f01ced66e087b6fa09eed9c52cd6f1990ade63b139f87edf5eccdece4a65bed87f3069de47f039c5a7138ab103dde856bed98eda52e07da6331c4f9832cdfac66cdb230fa44a60f5669c7653a66dd90cbe4541300e526c914a77f7051bab8beedcadca84c7ff363315d08ddc2bf4605e3fd73248a7b0f324cf0524564b07a7bff440307150278b852af436851cbf03dfbd719f359c1efe378d7570d61746881923fb542f56856b30e8b1a2ac8c151bfbf0cae15aaf0c221a74f46bbb6f452dfe84f461fb843424c5b9984354ff2284dd58b3349e8a97a919fdd726de47269c941c8594e3cecd227c76a1460ae21e7cda123d14ef355966967c1327a10c71c361ca387744d1c2826fb810820e0c5c90ec3cce9aae3c8f1c47436843597e55e3fdcb7becc6ac694b14b497e4b3e14762bd6a2fc2836d7d84475b6056f78674b6d9200ec0838dfed05cb03970de18671d2736d8cb757c2f0a8fb981b207b63737a329788a041ac35151507adf1fc703ffb7dca92239368e8f458933447ec550477e1ad74f313bdea7445583ea96ac5f8bce56af1e6f03bb18f84753a4af342006b9c3e571f2002f3d67c8f808738da1278d3bbc930870802ac081276e2a5f1ac0205f3a700cc3bbad1674a43abf5c64cf836a6d20868c030659dd6e2f954cef819d425d7953772a1a5726a52f051937c899a6c431e955204a554a7c8900590153487d657321719a0ddec19cbc7cf08c495c0af37ed5380b221a37e6ab51447d93be140d7e3e3e173b79387b72f771e8b4bda098533da0c9c0194579c47681ef7d68618cb58c81d9a60c3492b67dfd2524ff594edac4deb05d4106def96e55fe81b0c20ed99af4953a5ad487b1ac3034ac50a29e59d619909ec7da2bee9dec3ac73a6ca819f22c1ca148182aeb7547ede72fe7be5668e762b8a5a0c63dcc516a907c5aaccbafbeb7bc854ab9c8a22707309e97765b6453d793db9a41720888c02a8653b20399ed7b7d62f29ac4ec873aa3b26f771d1b2576aba2a4d4f9ce7e26143ad03f107f716f9a71c6fbb7ac87836d085a8b1b6c345eb346e3694a62ee9f45c8119b91df8e15d26e9283b3d1da0919c609ba9068c5da06bd57c61efe2296b43390f8ff20755dc59a294861de0b9b0757ab73bce87117091480c89d9a882f10d3076311d8dc7116be2d02f5a6687720ee47b83d03890cd016354157ab8f4fdf737f3a872e0944b657d4a1c10facd4742617f486c42a2be9a121451181ca2d9adf2478bd4c9683f3e6aa2e24143286f9e51ad6d9578ad77b8b2f91a7cc6a9b0c3fa920fb0d3a80a3d0bf81713b9ecb3393ec141052a8afe181503d96de8e04e2284a675c972faa3402344daeb0a5befd2d7a65042d38639245f096b8a3110796c53e6f0dec299c8cb2334ba156fbb296b0677cd6f9e99631e6df28b7069d618b645bef4d0adb5114fafbb087e1e52707262d5bd45dcb9af9516db305db7abbac6acea7404269b07309b48be9e5dcaf779c5e00f193196b22ef7181a0419d0f7cd0ca91a943790973e500126a7e31530fd3808b4d8d408896812a865f35203b35b8e965153f36d337a3a67c1c78eca40d225bba896d917bb1c2f510252ae7d59462017fb97ab33471035b00aa1dd61b8a2835e6387946537b15016d179a608afcc22fd93757c07b6c940f06080b577a1e0fdbf04930c5aec461ded5f3a98a4841da263b8cd2ba0ad153853a9165bf9cb29a56b0395919aa143c03049bad742c728b70da513ed55afa61d4d637ddda9e727ba4812cfaa590382023cc5c0fd1da8456412308572c602704ac59c2919c9b582c11d0a70b8d4269accfbe27e3a65d0be810c4e1b1e4c9e11ae2fd62072cfbcc53ae1ff765562a823374f36020eeb00308698f9a05c16788502bbeb8aa6f5b57b384b0a46feb0b4b800ad8cbb241a516498a90f2bda79e3fd75f9c025d13f555eca992ec29f767498153bc58276ee089baa4501aff61ffb85b7e04d48f15a1e4c2202a8823014c71f87a4a9307a142b27183a6f5622ae15d05a1846b5cf62b5decc1eae190a7a28eb7d6fabb1f7687dd51f3f5d877d900d9bab2a8c9fc7ac11d1c2fb0b2a765d8bfb98981a5c68bd8cf4880c25d95eca715815013a2f8417722dff1a1a1e6b9d1075c2539e6e9e7cbd890a00cffe09b8d3c9e99de28d9aa0f1d01e3c9eea77c43c9a3ceb59e50f922606ce7634b4d0f992bbbcd5dedb9f0a7470efce6a4a2d036b2dc02890c74312ced44c9f116fb24b734e79fbbee0e26e7dab756291a27cdf96c132e28d026fe478ea764cc631e279472aa72b7b33a65dbeecfc65d4b0163168b2365239e8047afbe71e3cd6da40d41011288c1bc614dca33956f59d1caf8ca13e918261c3e0487af365adc1c33181f31c004d3714089f280d209237f1e9171db12e479ccb490d9fc96e8d1aa30a93993b939954c3c8110d949da4ffebe5f0dc71542768c433ce10af0d8ae75956d17a889f1487d020a461efa88cff2a944c85d72c17ee7ba40b8c2112e1d89b9a6ce32e9d4395f5b0abfa0805b247a1e3b7dc5e489d61664e8517995f2f0aed4cd3853de3d759ede2ed86407efcad1c6f715d8b91003d59f8cde03a89347a30d37b1f2321a9a35e26955db7fc548c30fb3998e8d953569986c746c2af4b6a4d91a17423a241ecbbf7aeced765d284c356af32732a9c9c3cca038e7065bbd0aace67070f190e8ddd288c4c8212ea7f993fff7274af9b93b07e3c3f0fc96d811075de6b5c31f4e5a3a96e5f6876ab44251f4964da79eb1f44cc4f9f4c77eacb8dbdd95968a1bd70a82be92a80057d8ad1005bb49d52741a0feaa64580dfb5592a5620638979979d139f8a8f61e588225974d115efcf99995dbc0381088e04745b1955c98c647a60431781ffd346e11b5cc62d37f7cd0c2807acbc41cee8f360de67d9e83e47f2e2d38ae0b9931726c18f0a4312709329e88274bbeed3556ca8e5a4c723927330744297a7e0e0bd7f51cfbade457d9f48dc2c3070b347aaf4486168af1125704a959bd2166bf03f818a1b81f91e433d56bf36632eeb7235f01af65528e8931bfce5f41a9624161fc4c56bd860ee1bd476aa2af0dc2e8739185db8c029dcd8cf5b1cd01a28cb5b2375f754d5a4cf70d172e58bc8b6eb8b9eb2bec5f6b1e381612e6dca9b399d89f39ff39dda6c70bd6c22d3e9bd7c1f40b64b1034a781c7cfc85e7ab838984092a22cd8a0bddf83d0b29c8607a13910d764708671456450c851910bd5b10790c6e058c7096eb94dcaabce5148082c94d947fbd9ce6cc461a02230eeac9df92df3006da553e741ec557f10574e3ba5867c44154c2fa420bf413cf89f48d3c761e33b9a70bf501769bd910ec359937c4168ac1d987156918f2985d1da5714e36cf8b3d518d54dc6afae194f28a7112ff9d0dcc39d83e6a68666426402b80b1966a3777540d89e5725e76ac17879e3fb37738d9ba7de4e4639ebd03a515cf297af1025cb6fd649480004f6fa9f679927de8352d296373d196639336ac1804807f2784523aa50a385b090cd8e1be027d6336c8515c05341f3a08796c9f0cef8b1249151942cf5e8eafdc945e974f4995e1c01c807f84d60698690392532d9d4e9fbe90a2aad761f860b9401f44279b5f07a984b468a07cca89edc0779151c700444e3b88e49b8b6b7f3c4fcb5be102be772564f69a9850304396203bb80409c5b71daa41053bcec0aadb22b6b699eca0d4f135552ffa9183b1b72c52240f5f289a2a064eed7622054a065780b49aca0b7e454786756ad236bacc6dae94118f81377527992b1d48dfb4b9c1859ca916891e367859071268b0e84d50ffa8b6a76902359bd73a5586618040a22ed8277b7a237cea44302b63b812b6342fec5081396353fd270f9d0896a226409c91717718c95a78ef45f7537cb6a11e483d66d13d153a040e7c21e087984825fb6164e1f863c33e9361cd524ef79ae2ebf7a7ea28e2f1478d3538fde90477a93e5f18b275553905e537a7ca02ebddf6b8421045a003e2a52ed38f27b3e9fbef48085a09ba68177b3ee0f4a58a9067118e66054812b02bc458752e6daeca85af366c7bfdd7290ffb44763bdd838ee2defeb3b85824124735b9a4c4b171b2216064cdfde687c50c8143cdbcadda77ea7695556d67f4f8f07589dae00d32fb8014cfe318fdcdfef44d8c014a47627ab19076389f69b4b9bc47065a4a2a984f55fe3bd76a54d93251725ad4462c5a0f43fe6dbe4162e405b4b9c8e44bb9f7f037bcf4ee24d9ef5d10d4c3b8e250e54cdf3edf9b002b1acbc98d6ebd80a6f73c92014ec766a7a72dde50ef39ad3bf1f966ab9c7836c3ebd11c4f9e23549ec357ff763120f311c4119464a7bc6feed7bad4bf3c49bac9a83aa27f10ef90c535058331d0e039089c84ab7316b00687bb776d48bb621d5e9314c72ddc8f085f7d870f4e39e30b7ec610386591fa6a23b346e8e899e408a254e6eca717a33cda3f06dc17689504be65145c36cc8e7e10b88ffc05c0087dea82ecf37766f97794483b92afc7b7eec37ed02714beceaa08c538007951149d67234a03790b44063d98ace18588f534e7ea564bd14d0b6fd4fbde2134acc9cfabb0c7e4282b77f10b46454c47a8a2334568869ea9a2babdb13f659fa0b208748d62b657b99aaf5a75a6d55536ea341bf4d58c2cf3cca2f9a20d1ada175a72dcc66e045050dc7796e76f7afbb04e88fef4cb37ef4c1158c771f33cea992ecfc210f2964866ce539f766533683aa4a7e1ba3885cbbd44a494a336284740cc3244b7c247df1454a9cc864876c8357ae49481186619eda956478dc793904ac5ee70b13f52c5669487000ccbdec0242b264d2b66cf90ea7fa475165ce65236e211f48b2fbc92b922f305e5f6cdc17d59feaca2ecaa2e2c9604964c05aa7ee17b70ab4e8121c67fcc45f3fe6dcca3fddfdfbf27db7395138a5eec848a06941e9cad357935b51a928c3292e15332a51c189f5a028ccce8945bbfd128372c48867c70819c258c07812674312e5a1d978662ae498f2be75972529898eb45969bbd7f1fa4d48969119c808ac6998f46a31c0523c74c9f34fafd78f3b54b0b99b31f611b38d15cc223aa1f874514dfe81cdcbbd8d41627cef5cf88ddd186b58bbe1231669adb50477bdff06cd00b88c901582895914c5020787d2ce0617b2f9d295a3e1059f6f775918a1a92732e536f18820d7b2aa0156d449528d79276ec3497089ad4da581183819767a9fa17201fa166105ce6feeb3434e126da77b91fbddadd80364d631cc77ef2f79bdb9c2e5fc19d66cac6a52970859b83bfffbabdd9ea357499242f218a881cc4588d137007875d5d4f47c9e81f0c30d60be3f43a0819f7cdb2e57a7148729e6405878845e2f25d20da262ded58c1eead85f28f43d91c28a363ea3e523fbbb410ecfc82f33431aa6945b24cbee68866b703f06cd29eba36edc04be979f68923fc5ef2f71749f48a687edc2015d5f684dba3078fe5880de01b2345c0ddfa617eea1a051c5eb0f63086735a46046e6909ada01620a398f86ecd7c2d97be04c14e2c6cacc4c6ba3b0a68f1912fe5d773eed8f20297bb1057254ad214c170b54911afd4e7ac9cbe216a7e6c5feebfd0ebac01082f7938cc71ae15b96d658c98b541d023282d49e501fe61fb5a0760b7ad9a4bdc66f45380b3514f2ef74a35d870a6997d2f2d025c30dace63560c4fba974be648195ee506d79ccc52d3b9033713d4a5fc7f1fae1b0a73e6f25375d4b7437ad35947fe83f4a7ebd92eaabd8ddc69efb2b6ff23bf696700188522ea250f8b935945558ceb3659c5811405ebf229d8486dbe6f50932f81d6d7774467a0dde6b9fa93591bcaec3034af837e9940192cfdf44c209d91db562355a4a1f956b1967e4a8ac14356e50e271cde6e2ed42c043c2198a074e11edac780165268e9ebd621c3d1cca60d38109566bd48f773d5df01dee4172126038c6ce7c6d8c37025861dc1df93aa3eb5ae410fffd54bfba5288d1680e3585940f4867e7c8cf3847b9ad784c3778bc48f31c0336ce4b05b97f95090ab275d66bf3a9d795c645f620d64cd807c78c4ab67b82f0c4a129b9abd847a542321344bad3a70d8805ab90d20ea2eb7898416811eb8b3f1fa257e18a064f3af60e6f291eda83c4998b60b013a78f194a2d6659a3fe79fe684b0e732c0318c8275c840b67bc97192a11807c9daecc1f4599cc15a1bc0b97b443be4f3d08f4ceb58c7728fee8f70e0ee87429c4c036b6ed686b30963fccf614c90732370a70f071ae610ab207839a38f7604558b815904208234b978db2dd5844f8d7c18d4e5c614fdf27ddcbd01b1f10c6d4467b7f9160b1bf13a01924c2d6dea241d486d2346748dc5a9e90b7239957caa0ec603878cd8770f14d73e407b9dc9413bb450620cfd24f6882a9bb51b73346f9eff6e3a60e00debc0d04a63560dc213b6ed10084aa36ce16318ffaedc16e88a3aa03ebfc829a1f6416a93e745662cad92faf06a206ff789c175a72823b287f33281aa0bb6d7c89c53d22bd6eed327d4e55403ef71a2d545fe9524f21c939dc8df001d5007a736c0244558ab07efd8e56cb0aaa76ad17c832f8faab46fc35b67b38867c11bd4ba2f9da3faa174c5ee973de3ddf77bcdba438c043b661e421eeb8bd129149514fafe915357dbe98b91f016424a6b28b5c64f1f405cee9997838fdc0c3951627bde9923b7808d2d6de7fa54b71fba480e127e9d3109640852cb6f7bd4332764c87c288d2182ba07b3721af815be72b0a0e859d87acb44705034a29abb51bcc09c74cb73ed8341bbe5f85ee22e45248c1909d98aa4f5bf6afbe329b151f8bedfc9aacd069e905a441825dbbc3ba0eb23bb05168988fe2739db5e23ae1e43052e35107853629868f6c7f4b2ef5fef3ddfd30bf5185623d83ae0d02435128356da18d1c44a7570ad95235c39ab2927c1a11efdcb4f1b94db77f79c29c0be5cc85537036a21c4dd6f205845a3a7e050d044977de0901d503f017637bfad484c008fb1aa8a08444d82049eb0d4e60ae2b75d2aca009d0ef96f57b48615272e9d1b5dff37a622d37d63172754c1aac0eeaa963d35b5a8109804578fda9e0c1ed79ecdc6f028854a4262ec81997eb0ac9e22b0656e3b00713a222e22afbd6243c2d2f1a1ad2467f35b94efefb942d104ada95ce7a6f3cf81d22608f48727d6011e5ccc998246c4811a037c07a07ce048d31864b7b67f98470e27c36c7f03817ec9d1d74b8dfe3923e7821070a8c0e367272597c4c261495918d5ba265eb0cab633043b2b5aad00479e3ced5ee744f5b60eac03812272816769a3f10f4cc00224ed420288e3952b99f5f343322e31e8bb07b538719a35a29ed80fad3b07046220fd8c93d0034632efd38ecedb3e4ef56766302c093d55b5ae48bcd3eb9ecc78ebb6520423394c10ab5efd7a410caadb8a5b05a26c2f45cc54a505e00371b2f0a25f759c5002d68877c9af5d3631c96d8eba953d5a0cfde9581fd6ce833013b665cbd9cdb84057f0edd492834a9bb571d1de7457a42c4a9d0d97e9a46a46c4446df1ca412b877e17ed02146ffa0bfc800a8ce3a966204debb782298eea06ae321f9dd8aeb766808748667a2449502ce4bc87829d0bf723dcf4fbeb0b601de3e48c09588249480c36a11cddb2fd6a1b086ceb79fcb7a04b92d53b44cd0d16d7e74e827ce56c676874172aca488000dd30c49177af50a07abc0ec07d16de1cb2559dac9b8c1f24ffb3b135acbdb77704eba5af4416bb851b6bc842567581c3a8d434523e051c880cc2ae70b2ad6b824ef2122c5834afdcf4be4e5c842bb444fdbe3bd7a4019ee152b1a6efd32ce591414625ed8c0da689030e176bf5ea3bd1ce3380fc8fa9e3fc1ed13034175df10a0a0570dfa5787297a6ce7137e05148186f507268aadb78475da69de24d41341440e1946a14f628dbf7d8792e9905ac4a0fb60e3c300057aad71149d0eaef23db3cdaffe8cd4443b57454b600b3afd052fc58d55e892bc8c10a4a877d9eadbe9fcec018959e47687060675da4156100e36bfd4121836ea5816818ea1d31d6abd5d17cad8c1502444ab841c9193412f26c82320e1d643f0df1c3a8847c7963739a343655b202a5fd2fda01b3c53f9d9b74e2d1f3ddf8c8a38c5769ae84542c4a5700e471bde14549a81c4d2bb13d6216fbbe4d0f8e7e260c3493024448fef7d94ba2324aebfd2f5d16abcb27719feed0182f9e9d47ec40aab366aa7f6a6687e30a574826ea518325b16acfdcce135f4965c7f4f8aa729cadd0ff0919acc9c45b77d5b099ff0e6123ad825babbb5581dd420f82ccfc7680e778345314c1139cb6a93f7821b426f86fa74b3b0003bc95c5e52f9a828381a5755c127a85a14d6289da13000ac24d8d934342f0d5bcf10a37a81d00977adfb0fa8c8f53b9bf679de3b4cbbbe0dca9df0d8d82002b8a334f63584f4197ded92c0a97611e5503cd6802d96ac8f9e2fb7d1ed5caf7ceb458942a714beca4ed0b6a08b7b25a4496962a7b51f5b672b87a60b620f6cc96989757ec669d4048580fc4eeb2f3011be0aa3a0c8c297e668b17a4f4d063e0f3b155eef749affeb22337dac8115d628325847fd2d901cf2a218402edac1db3bc9795ef0e28f015bbb8dd32e337f552d768749bbad84477e27ddc1682dd57192bddffd9dd5021ad6cc1a1f5218d2e728f16016d0ed88833f5515483fde5a56bec4d6cba592a802a963bcdf342b6b7284120436f03690d27e2df1f50fe09728c2758ca5fd5abaee12ea6f63b27f11c8d0387c7b07a706ac458c8b15a48d0a7f31fa4dade938b228fe62dcf3b6f8152d16db7678e4e4b26b55580803112eff237edfaf576a82cbde80ec441a6520ad4b8f348eb490d7a9de34d02bfcfcce0331790a2d0e815e6effe1e3adcb0ed1614ec0d5c39dcf942bd981251941529aa5ebd8887bbcf944df2d40405aff803b7692274394fc1cf1ef6b681e6131b8b367c07ab874e3f1737e7f42dffc34125706b4daa2d76545f524b82fa0ee09e0f7947059d9b1995b0450df520956d1fceb4e644bb53a6402d6a6ec6f9c11e382a1fb17c918c5265248d5e2b6bc732d7fe23a6de13c793c32a643cfd0dbe82f79d840d4e6dd980d89589d5f834eaf5c45896232fcc5dc4ce045d66b983a39564d0ee3111eed1f5ccb0b76f0aed5c1e7712fbb8946052949d812a8f3c52b1b299ec6bb62869e7ba37c849f483101641a37a360cb16ed66f47273386ebc5155e779bccbe47e1b894694ba9e40158d17a3e3d0b003ec4fca0247956cfa793b749be560c2e8688a8ea1043c6fab3b21bdc6583fe92bf38bb558753ff53255a90452546d7890d622bddc20e11368723c2e5923a8718f4a2345410877fcfe16d81c35e6681fe401053cd59d98ad42114fb8f9b39d82068e90deae1ab5aca21c20a94b55261cdd45a6a20d8c245d9d78e849bf4d1102652bd7a633523f1ef8f2a33dc6f114c6cdecc62514c81abdcc70c105bf8d80f9fad23df8b4d9037dd4057ef9124f95581f3cc8c04e7411c5bf215d1ed958cc100ce806a3518391b46e5c42d7c36935d0e6f9bfd5086a643b50ca43ea61468ad569dfa87f6550cc7603b3869f0957d3ab723de62fe6ba1feeabc88fbd3840e8d046d8ccd5e32c2906768794bca24c9da26acbc88002e542970a94dad545e09b3a43cd3ad7239b199d8ea6e0a42e71c90f1e06fc84d796a8bfc35aa105d2b96d5edcf46e615f47b18e462d1e9293517832b76a71b3fe38be316eec2552a896934e8732f48d89a1285fac57cc55eb99de8665e2ad55bdd27def60502aaa9e3460cac1a584fc5304ee8bcbd0cc4ef0edf7c83a1856248aac945439322ca400113fe027210d8e40282f2ebae741313da2c8d9f4649038ac6b2305d3777ac7b568df55d23c4899b5cbf5c32d884300b633870a5097666afdb5b2fa29d6e6c56abf06604b203191c88393690ac0c209c468bd8c57eb84f62e7cd9d2fd82c7396ef57864325474e88e4fd4fa8c00537d5759b082e1b9605af1b2c0656471cc2edaa1ef24b48e6f3fadcff4a93eff63eaeeb65d4159066f7fc6c40cadc0b90403eb8146515bb64b3579c09985622d8ece2f850f0b225d1e62d5efaebf6b201de73f30e8454eb99c5ec6d3a53565148fdae776b545badfb013fa1f453ceb2b4af643e2027b1742fb8ec1f2ef86355bd666d8185765b2f7ed9ddb77fde719ee43dfd705e3adf0739697470e78b36bdb897134d768e72aac91df27f83b22439e8f676801eea5187d3bc7fe52d990d67d504cfd9b80d76ea800f92a3db2105b20dd8b6a9f7a8b4c3575870607acd69eb50319de967bb63c7ea37005e38d840c80a82f8401c746e149106f1a0ab1edcbfce53ef1fd186e1ff166756341b0295dadb2790f0242ac38c9c0237711cc3e4aba93cff06ec13c87cbb5f86f66ab915df5889f9fa234788fe927a950a5be837784cd50bb3f9b82a87958c0241d019633fab7c8744db01c1a8690309d9e130cfbdaed883ef5cafbc81cfd85e46858dc25dabae4a9463d8cdfc7166654ff9cba6ced92897d78fa6dcee87ae32a75301ad5cdc797993aa6754bc8707aefb965a16f7d29cadd3a6396f86951f40dfaed846e55942ed2dadfe782b070302f8a43cda79e08afeffa8227451bac7462e7598bee867ea686548b09b5781c5e3b8e3235df22e69de73340d457115c8ea962a8c1b7ac42ffead669e437dd50b6ac6612640fb0354ba1d6bfda9644e213559093e402533c4d8b10b8a561b8400823a7f21a255328cda88e64be7c47385f6c79fcc6c7bb99c79f60a7376bdbe89eee8d6fbaa107d94b6d81e336b79e043ba4bc9f2423e374c7c73e5d7e358c49f9d303f8a099326d4eaf06206aabc49a1119a9a9b4c5d6a7e09b6efa37ac28a19fcf22ba202fc1a6ca3cf6b846863f39932ad293c87d44e2460d19e1b88d39576685a759360c8061f91638b8e43ee9f6c7b1475659dbf6727761ee27714ed4b7b6b0a77948dbfc4c6bd98e9b5cf367cf653deb3e490f2731a49bf9d9c1e9d80ea0d252497a285034af1df4166dc0667378020673faaea050060d1c2de7d63583179bfe94ff0b59b9b789979ed627418bf4ee97356e9cd9c0827c59f13de8b2ab470931ff49ef4998a32ea35d226857e4afe74688bda223e530180895921b2bd1c4a3e839e4cc5c670e4cb3d3780e2ad0817107bc41f404cb34e5a01762893cb28c0bfa5e4b4f644dced075ff2bfb3fdcad459e5a66b015c974da6f7713af6da26f3dbbe32721ff12d58c40658a5158c33a18e15cbed715bd38c1725af552eed81ed035b175679bf2fe034ada88069d371cf543a1d6bf7a86bec7ff2a538e9beda460400826fdd2276c2dd9c249666bc3ce8ee779902cfdb3afc23cf1d9eddc5f44dfda1f50816defa57974ee4935f0716bf02e35a6c5377e1604f913118c27a74b6877ec8ef7deaab9b56fc6ae365cb044e205a8e29ca0e19d7dd220a282e383ea2f84f0e4182b372c890f3590faf5476006ecdef8e2ee4021f52b981defdfbb48501bd0ead75a73008389a318ede0f143906b8631fc2dd64adf1d9939de550eb2cf27d2fa9931b608aa456b624c65a50426e68ef760f5b61c2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
