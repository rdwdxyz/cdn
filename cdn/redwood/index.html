<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5dc47560d891348a189d8961a0a473f97d40cfbc5bcace541abcb54f325ac340ef3415ad6443fc37927b0fb34a3b861be96903bb68dc89d5c215091b5862c4c5149eebf9da07170066fa9f6a33228c3ae3fbbc2a1500e566ab3832d00e5fdd2acddadcc2cb4d9cce2c0a609d510920ea9f821556eba96a0ef640030e22ca0b24166b7443b9387f92ae036439ce67fc656661cda01f324a71a34016d73a3a7f12327df1ed7376ed4f0378ab0f80ef7be4d3673620ddd27b4f9c4aea84b02fa63ff9d1f14bf7da60aafe0de2bf32ce0c6a9a302a189178fd790b6854b810ef4aff7d6b3c71e406784f34e850afb498c8b83314a88a4e7fb4528f84f7321261e50778d708b4e9f2b1b7aba55cad6458d47a08aff976651a385e0e0029761a345b8161ef65119da7a41493c9387ef94efea5349da5f903b6b012807ddd375f5f10fae3dfeaca90f8d538b2d181395cc9441f0177d92b9f0363ce1a3be6c4191c83f9fed71c39679818b187c392dc0c6e28a384207a2aeb735541ed7d90ef8f5eabb8b68de00d0504b37714f422e101562cb8c32c55abc82af492c86684c6d3affa97bdebf309485651f0de595faa54fd352a4933581249e583abc36e52f02ab0b67aab64d31defa0185e0c422f3015eea8fa93adc01d8d2adba71f568fcc7b5c8faa5671de35a123739d8609dcd541c6fbf65c6ec532648fcfca22b7db989172c84e061701ec70f20fc09ab6b171a2c3b28298b7d6d4c1653f79837f14db5e50ab9f7dea0310f276699165f77e75c04fa1ddad5c5a56ff9d7592d32ea9062515f13a3b7b3b4e2581421ed06fb8fec0feedfb1fcc687570b86466483a14e2f8a81ee6b87d90ab0d70966964ab7116e1235997ed6a81889dfcfaa70263ad9f83ab23052551a74c331046c65732f931f39b5a60b687792b7212cc6aba6ac1f072eafa4fcd795cca141575942d2388d7f5247217d3f75cc0d3fb5eef69ad695134339abaa539b19f67795c2c8791b65873b15b9df1acbcc35af3030e00de54e19f685ac2be8bbc8817000ac0cab893977f4df6278611d4038941bc5d3a91ed1bb37d1f9515bae23998771efb96d7458c3dbd8de122f46445dd0bba89b47e682a09dcbfb4aad7669622876e278b4245ed1d3110921f9d86320884eda326ade73c06f4d52a1713d5fe714e6f00a13a924541ee0a67c389c2fd4f41e0b19eefcceb2eebf43c554ba51d74e2a3200dff132354159699d81be9245765a427bd1ce56969a7dacb4d5a79d6bd4882db57993c225e6833635179e320c628624490c7f327e0f85ac23ee278537631fd6d32f32ea6f56799c257d1272c683d1d698dee741dfb1f5e3bdab5e64fc7d963d418a4a48758696fe1a700435084198c47ee3b492f9cf99ea62e3792bc7ed0a2f6c5473c3c9f2e816a6fac42a6589e9cca0a0999aa96e71a3f0e760cb04871b78bc5bd753dacfef14713ea4ebf7170a410aa1239d2c8f8c8e9b39bebab3b980851dd06cec2ac894f588e0b35e017fd2068c9d7c04712ed359ef684044373bfdf6c130c620cb015abd65ab20407d4fab906134b2df8bdac25cd51e37a83c04429d135bdd3c95bd15431cad46ec522b0421eee8fd1d0d344cbe674fd746663d53f4da7e0ef0c6a004f572d29758e0edf6aa79c845ba4a28c9666ac2709e043f0bd1a66b128aed377ffd06fed2c7412ab0495eac73c30d7ecfeb021c5a8ff133f25185951598cc5f4b5440db43b94dd38edf848836674f5557c93c06fd8c49c453b8dd6176864efc262afcbaace363038eb2f0145174d0436a764acc0ddec28087bfc1483b142b8872023bd5b6eb68295b03c94c792fa623c71b0e47726c0d396ade1b9923f5f0fa2c410bc7e2dcbafaf99b7a9c7e6c3330ffc1ca61e5f1cbda19ae88711140f037dc301ec20b2827f926749f048f932f95503de99d6b7140a36f7ea641983ac6d5978c3f665f402e9509a415a54989da6debda30458aa48ec79f6b9f224a61fe3e453f28fc55e1ab4b28211687da62df157fdaa33c13f0e903daa79d9ac3b85755725f626fbf02afbc424e9d3b896f9989ea06fffdc1dd30e79731e60ad6973e08ecb87103584c7e1c369fc28808e186ede14ddff336608ecc0fdc19128c37ffb5c873bdc4c2df8845b5b88f1e022cf22a70761e6f0703f97d8ed4c29b6a92aac9979b63a2ad0af98db6db0bb2836636943854f3ea28461d4734efaf6c9acc25241c4f76dec0695b65c110e5d0766537b25ada72354dd68acbdadf5af3d5c7b67cb35dc6991a41de157445c21b3667b452acf1f4947872ad27a2ca5983cb09abb513e13a73c64e53ec0918e1413584c66cdcfc843358969dc23825d53ce7df2825a27a8e924557b8f7300dc04d4b048cd7616baa1606d362e1d2ae0b6bd5369c5ea01a659be9054f4fe12fd2630af18afd9153cb1dcfdd9b70d72d6f8c8ac5d975cf02b4fcc02f257c3700051ae2965f5daede4be410949d119ebe88b90b93f15b19b5999a7413d924b4cdade867ca15fd87134d41c36f63987ce64fd356def1db7c0a2005c91c0adef48b97a31e48cbdcaee5ffadfca67be2b0fa90fe57b47c7a7271ff706b2e8b96ccf204831a89011ba36e3916ef843a88ce3738fe1e7a455ebd491f069377927193f73c4d19fda38b5486435feb28372d66195c05219dc1718f5fbc5558189b35c0b81f196fcbe92b3426e04c0e8a3e9a18d14f931e537a553ad5fb198d09a6c7ba35bb91bbe51aacac3b1dbb35278f80cd6e16f8e98035ce55183719fe2eff3eef3802eff3e7cebde8518e95c1217dfb3ad7c89346fe3bba8cd9a45b21d595f75fda0daf21326d33ae0707c0ba8736dbee8d04725f278975a377a64c4aac3aea54c51cfee615bc9844b6e7ada7cb26941a27a1e0ff00d729da29ea300079f5b18a83caba6bd0cec3764df5cf77a2460e0ff7b99aa7f54d640b02a69a1de1805adfc27069c21d2b97536216df63a23d76c0d61fbc41cc279ea8f8718cae3e8e8de038d6fe5a6d9db10e6d209cb576e5c045614bed47b62cc7e81d96ce1c223c6cfe7e335cceeaa5b59d905b4cf47632cf17f65911655e679eb53e6b5f5aba6082e6f0590e7230336eae239d077bd49bfc41f6aad91414163a8f330a3913d156246c190fda05998680c6cd53f32c18bcd919682a5fc91f58773c1ef3accb564ec6c07661674a548a977fd5cc13077d50871be625c3d5da8cb86df3f62b681ecef521e7da81c1e1f0f396068a6bee7f71673a66af62472ba680a03eb2ef21ab13f85da6ef4ad0122d39ef9be4da7554fb88b3f43231a42d1acb78917d3c0dc21339207802c9ff07ea692ae105ac41241afe9361e44c10b31f949864386021cbe342a61b6f1c7fe3a8f47cea612541394ec77768b1ae02b6b622c3393c82d62dd8d3c4175a8bc2d72126995de5e7adb76f994eb96316622e004d391536727f2f6f9178ab651597096540b995d12f8d31a261e88ebed28fde9dffa1975daa9685084f6887e7ba923827406a97e3242326c1d82aa08b7ebb5a3c7e6f3c32a4b38932070e5956c77b6a50756152708e130dc7eca4b60167257163c2651d0d0f81cc0e2d32365c0e16a97ef8dc712e88cc50c2879eedb35b51342b0d1eeda1e031a95d2faffdd5fca2c7f43ed7c544e92e875d2455989f702bba194f5da0ac429166fc3ee588f795667196863680cf75bfeee8e265c13dbac640a0c882b71356eca8abd9bca0669dfae65f33ae22aa31348c4fd92f5058129231288d8a01b718d7c750480b6cfb08fd870d9e794f144c0e7d9f4e4917c871cc41e76ab1711359cc30d36f3bd660008912bf674fcd70f71b4ef24b6d813b829c5b63cf2a55b4e31eda0f1d8254762177062ac36f80787c25b7511d08e384f805d53d291d9bfefed414014215cd9cd1ee8cb7cd6caadcea9c0055e1eb257d6a51f88e91858ac8175eeed4f067c504ed8bdc6fdfc9ca8a88f342e2686033c5b5f817e71defe0010a9954e11f1b13b44c15dbc993b3a8e451d73a7f643aea0791b5f17902e03f1e619fd5d35e68433a9865fa4d3dab94bb34308626490e3309aa08f085f1d55df5ffc9da71c510b1d939d308d10a29e0f3035513997cb3fb3635ab6723fb412bf9c462ea056cae7088cb73ac55c986fe1a6f5d436c4bc579cfc54d93a4a3aee0733360ccb2c392babb6bd2ce2849a5bd677964dfb012a6886563ab5018a5cac23fbec5bacf47f42a9eeee0bd71d852202c9bbd3d10dccf4b042bb5537fa5831b3e7e9a0e1cd4147429ad5af91856c55dfbe60891cad3c2d675d65624572045971d8048c4f5016fa30f58708d14d6dd8de253dabc75e8ef9b0649544d62ebf95cbeb83a050ec13a32f6945ecf12dfed9bfa5e2f0f3b45d12afb71b3c41bf7d98e854cd453bb5220af79a280909386edf86c99585b877f43747586f2f87d87de74fbf600e483f22878060d085f51aedb46f8ca3855edfcf4dcbed0ddd06a4aa60349e0712602c8ce53a30bf3975c833aa94d31fd2746b44a400cc29d3d9dc6188e6ae8ef438b647edfd9e450015694be6c0656bf882b22b3b311292e63a383cf2904503c93a20339fa0a391813946d821ed86c0e9b0c3f82145afce9ab8b7a1c6eea0e87e4fd6e8f9026b3a32994c83fbccddbed66fd4aea45b2675f9d52950ca7adf7981130f5cc709fa4fa7969246a46c47f671fad3b334e5584b18344fb42efbf343727de222f191c70981d65e7081ce5740473dab6584a34fc31ba7b6929618b3b8a6b9719aa1f92b3af489c6bcd59ef32b052c09b71749cbcb0a0b133e79115ef73b049f952882a76ce858f4b868ada373ef78d70b4c37c72f9fa5dad61cc1d5da7b758ccccb1dfce9f50ede561bd2a2badb0e09666a8df2ff423c302895cb9b5c402d5fcf2c3f688e57e96c4e3ecd6bc9497088ea5d1211635754dc42bd2f9a9a4165df9a1f716eaeef9e6bbdbe76e07f3a829de34a19ee95be7fbdafbd90be711c7d0bb1d8159a396c448afe8895d8af5655b57319baa5491d19d27f2a39bf58519e80aa38b10447b78ea2d546094864233b9b73df659fcaea4c7fdbfd4776cc5d5065214d8ca3386f563fcb64c0376fc8d0e29223b4efc98502401cf37dc5cf37470f61c0d3d984d3e43847220f9f0f9d3f19da86d15c515eaa221c7b37ec96509767d2854879d9794a009a52f3e960fa30ea0b14d8d1351d2a207e71aef88d8b328525107d884556f18d80d1c0b6cba49bda8b9349b350c6d840f31c5cd2397aaa5c882021081f0d56d510047487dfa3765cb70b19d69462b9dbf07b3336ce7b9cf8bf10d6381b2cba29b85fdc8c925c87335a5f6aa38858aa05e7685ad0ef71c5c587130be9e164ea603a8e72d6d359f8b6a3ad23e72979740c4104c335f91b0efa20b03ae778195df0c43e730a14a3f70ed4fc28131c8490266511aee90fba3bd25cb31858c5035d05a74e4f4b1236d491bff9e328eed1d92118aea9f829c59b06dc094fa659a1906edab937ccf21b0ad3e62b89e2f6496cfee2d558485d22d946050908384867569dd4978dc84d59c4dee8bb3f768de24d885339dad8003ca34ff55abcfe9935368e555fbcfb52e66d0e6514f5df21a12e44d3d17b293ff0ff8ca3bd13a565c1542f46aeca7aa182ae8154ca95233489f5c19a71e8ad7b866e426d256d5361b1a294f837359046c58c6ed73f3dfbdb8a3fe95bda36cea0b139347f5676fcc82f347721106b0afdf6250147dea604d5b2e0b178e6866610ec6ef0fafae61d1c7dc27a3bec2674b7f0c9a2da2f0be868ec89cdc9b7f679272c8787692f40227b9948073d82e76f74163b5718d4d7b513a877d0dda5a7c1d6e9d4064a112d57d2dda9cc78b75d447b0f695958d0d7b7496d0b44eac1542ee706bc3d4fdea6564188e3e03536cd4981856541886ee74a0bff2619d0aad04d888bc980563b3db445bc41516085f38fcd531e9f6a87ac6514c2c2943afb84b2dc56a4cb1b70aaf3324614433d8089f88b73680079f11e783735014b51f1437da33cf884b58a9d553806faf146a2f4362eafae6c0c2ef6bac67363374314439ea09bd56fa25cea81b34e86fe93db622cb865987eb8d174bc5bae2aeab23e566ad33b3df6bd70596943d8555c317fe5a2f850472a5f5ab8da12587f9d160ee0b23390c21a24c52b1e3cf4a13fae7cf3520d3b920c8781254994ac6b6408b5e7ca5a428114caa080ae7c53ce770a87741161d7b2c7b5152a6c7e6bf799300991defeefbb1b0b7a8bcfd1d0e2d99383182a98aa255fa234550d78a514f63218b5caa471a490ac979edf71a28ace8675534dcbb0a15f4a76ea668b74009971542d2c2ed56481b67ff844cf2d290e7d1207dbf5d14836b2351c1386438e3f0e4fc7ec2c24bf9c359d8833aa2fe4720b43c1d50e8b694c807ebb9c846f1fd59bfb017631d61da700396dfed67b18b7f87a9358861ec877c9c793b6a1fac05975b41b687f7c477d8d43cb696044422fed7e53df125b00a4f17cfdc56413a3fe769ac5aad75f3cdfa9ff31d79a0472cb30a509a0ff12af48778899ed3e7598eaafdf0f7bd3ebdb98adfa4d9d0cab3416c36f75677221e34cecf2555c29426850ba53f76fbb6f0ae8a5af500f9a09151d90a2157647d3cbf0afba2233823dbe403b679e1df52d548bf877996b1a999c2093a40a97abbe6084ee417096a2bd33ad33050862cf2aaeed9f0cf19f66416cf3ed4b0e3e9b0d453c88b85555243d5ec66b41f7db08136bd165de524ea6d02e32617339135233f056a504ddd036caf0e1a8b5a40f5f317b04789812216efdf1bb92664a6d2641cdcac8c1dfbc9a2e9716bfd5a0ea226bbf6f7cdeafe25096b6cd3df0a7166e85d9b0a9c08cdbc33cc4035f5a77051efe2bc0e1f261a6fff98c0fc043f792f5c7832a97d598c8bedeba13ee4acada4ed356e907806b615b94bf0c98aae0e752bf6139bde2a24776f1e2accfeb8db91f3bfd7a37dbae5a7f110f6a8374aeba336886be32acf8f4236cc1c1ec1f417a486ada3481395b686f1bee0b229709983519f0e9e64e84c91fc9223120bb32601057a56f247423c50088f583bc2017378200834530f94dbcc39238346991e44f261808e8f33315710594c41f47e3fae957b4c9cd0fe1f18b9aebe5bedf445a074256932e46d44e4172594137408aedd980fb99c6f6ee8d5a1e21fd3badcef97d3fab032b997933226006f6af5f968e073eff27586eb65f92337e5049da64a8ddf3c8d90dc3b14a9b6daaf1da0b65b462f03e933bc0cbff1aabd6df905685b69c86e10a8b409932e239b54eab76e8889f6fdfd3f447da2f10e31ae57b597b5700691daedce051fda8408d403153d0501d6a224fc5d913c0dbd7441b96b08d0fb04d5ea322bd28beaec926a191bb649312ef21478ce1a18f200bfaedbaee040290c9b9d6a6640cbbeafc5ba51fa88c0a7c498d50912bb2dcfec9880bacdf5f3b95300f3b38a4af6539570d647cd0448a15597723541a31bc2a32fdb1993f828c00e6a8b9595e0c5196c530a55568a74650e8f95bc4fc126d6b0b6c6ed36b7b66b0de400d1db33a25a608f7dbdd8ba65ea359239a8ac89609b68022055feacd883cc848b4bf2cbde93e7c92702528a04975e9395052ff9a8a1ccf358c3167cb513f1eff30dfb1b5bc0f6b6747cdc4ccd06ade2b7013479dc1dd9c8fc6b26c34d272a957e34bebdd1eb8c8165f40004117402ab77bfe8b12ccc445eec028a2f3feaae4c9a1c70cdc42088642ad8b9a87717df4f88dd1fe2a5bfcbb78fa4d9240e89ce708806bb654d91808c324ceec2f9cb696e04469dd54c4d4155b01383876f23d8a2bd960a96628cb8751a379dd0305a0f79059cc04b01faf58ae2a74ceed993742b8f07460ddabd76529e5ee15090ae1d2521e0672b6314195ada07e11c131ec9ad0f3cd2045afbffe8c8804c505d43a5282949a03ca449c58b3a646280c75e706d9448a70270c7e5f783983d860136ee83b407e6e0ec8fda532e86e9ef9bbc608a31fbebc5d0d2e59aac3cb246e25f3de8fab86fff3893cde7b9a9f48967beefaf1efb48a48377ad612299901df19f064f5ffdc1d3a51584326f9c0f853320e2577e4a74db68af732199030d5b7e5ffb566b3fd43087c5b3e8eae7a4c931eb4c542ad72fde810c6c7f533d61661f7ecf71e1d18811b8dbe9fccaa9027e5c7209ae923d154443778d3b199c89a9b6a80e29d86b861f7c8e9b83be30727433f1ba8f503909877b5d93ad1a89d6a0d1b0518fdee083091856585786a8f2085bbe9201413f484d9cd4f9dceb0a4419230d274a6bfec75ceee3246f501c7b4adbef74d1e325f88f486ee08e4d086f2264deef6b5d2625186018acc95245a59a2d2643564ccb341fa58445108acb4315d5401e6eb45c4845f7fb8b560600375124bb48526b6ef345765bce9db434453bb8aa15975939885138ef4232c713274b261651ee3fb5229acb257ef231bf5418b1b665730385a37eb1ba6e0cfa9b01c139fd9d9e589109e2a107f5e3b3a18a2138a63d6fb316f0e4c5563d43b5d9fb1322f5dd51ec119a561c0dbb04e539ff1ecfdbfdb26311af06d5713d5c82fd433f5e8b546bda3eb5b4ed888f5dfc485840f6c25d2ca988cddf67344804362e4e38dd4428bca4ee20febc8571a1442bdd461bbd887b848dc2e6540570e02e303839ecec8b529a15f22a2c116a0695be7f678e757a02e6c632b62891a6528087e122680f9abe5ba1ad552cb83b31b99a4f8eaf9b0195f2be872f98777e54c5261c35bee7d696b5c3623a8495c45864792bf44ca9dbbe09929e737fc693597da5e77e71f9c39c94b56403ce7347a86f1a0f133de96c4872e9d09046cc6b28ad769326765d5238a765fb40be39ac34f82d79724859bd895cd8b9f95176af2b4a5de6b8b79600e4dbc33b327cb99b25e0cf72d6ac1dc4125d44e1a76a73e81d6e8e17f1af443934c45fe336042da828149e2682ae496917199cea91b59d78b4b5b721698c6af27175321b1d2ed9f015b1c355c8624965c16982650493255a1418b8faeeb1ccb5800a047e1e22ab700b0aeba3fedfd16273ae12e3cd9f568196a28a2c651b10261b697de47e427c21dab13544c4d946449ec25562053fe71ac3af3f19dd750341878f94253d5fa0e0a04e6a2ae452cb366ff6c1d59f10c5a7ae25485f1af205ee15bf5186b77801f5aed53af8ba3cc994e9e6ae3e805039b0942a9e2190e186e7222d53c895399f905d5447fc6e03c38af352b47d4b1d84539056d96b7e4584a500fee00cd45fb4c80be8b7dd634cd3bed5f28f16a87866082264b6b0ae06e2dfd28312a81292d16b95e555f110249c6b9aef758b330c61fda9789c2189e14f0fae7286bb89bca16e372a723f06cb33db3d851bde6fb96558b2e7efa843a7fe9fb8ed2dbe5e538699d2293b0f367b39722aa0f92c1f8f2b76a47d38ca8b8f68890413b96afdbccb192c77957e66c600baacc141470dbbe0763ec485445f851fd2946a70547e067a4bb31fcc3ca0afdeb8b17acd6a82c65a40c4847653c8dad3be5af5a8e93a3515d4c24931c39462a9b48980695b7d06a5fee9066513e73ba665cb97578c19fa9450c6c65c7f05974af183189e4d57d85ce021530054f8fc2cf0b0f7f1731b474bb14567206e9cf5d16a64d1783069fbf32b04f79fda7c9ba61cf8522e36e70e2374b228bea43b5dd84e330a5a7c71da99b19ab636b49fece40a227fd20ecce9cb2b4b68884809d017643c9f6b56df1e7dff66827f0a2f1a0c96117050b1400cdd1ab54f2fa6d567bee4e74ea9094586765ff43fdd50a14c6c9eda0702cfb77d7404d4fbb59ca24eb7252abbee71d6e3c141f8ccb2d428190c13e087164526f07c8f6ac34c5cab53c913dad8d886cca16d0474c491866aca66e6dfd9247ba8de5e77e2dd2abfd5a75a39615e97cfb586948b30451f94aa46dc82fdf6cdce49106519a099cdef985890e8d2ad7e779824b799325a9c491df9cf0eea77e368a3103bd187249abaf87f1b03a438e78a0f8c66e70c2291c77169123c39cf77ad0d1d4e8ad635f0920b358ec83bc19875d620a4378f88d0fc8c097dffd9059b8f23d062a64f4ff581ad858339d26b99c7dfdbc1c91a3a316ff8e4303a50e5cafdf6245a76dc14b7f1c6a365e90de8ffb480405538d842f8b9f7f80dec37a6c51a15698ce532f20f1a7383ea8ba37b5b98294dd835cdeb9e6a495c23fae175f0f31bb09621357212e33ff5720faca0fec21f1fc7958daec924f95256dea67b014f2251ccdebda12b493328473fbc905933d793cc71956642a1398aae9127b0437bc699c4c3d82dd26f5946b0e76164f297fe6bf232e621edffe4a8d75a40c6db550d72085e02948074c6a40aa059c44206d07a474ab32a95f71d56c47ab612095c9df0685c02b286c7fb11066ff7986ace9a6789937860b3f230ad8665c945b3eac73aad74f8376cc3975b3cf9477cc30d1a76c1f5e325cec014fb96bf338d44c9b48bf6c56ea3e80f88def6e43f1f87d9d84c7b661e3fd93afcbd3bf3666e757931a07f92c3fac79604dc0a010583df33f4bf5969fa4093221fe7fa48a0d8d640429d83209115c8f2d8f7d3cca6f26a95656de25902ecdeb653fe560192a8e97d4e5b04d817442d5031e9a0100060b894cf2154d6e3135d15332b144c054b726783c1158561660dacb955f0cd4798c08df46b16be88a46ad649909c0906dcb55cc15edfe7b10e5ae64d8366d8cff94121d26f8470ff6984e15aaca96443fdc6da3e5faaa4dd58e6dac925c0cb42da11355d90aeb24bfd4dc963781a1af3dbd8dae35dbf47623f287814ac7487b3476fb17b7ab66c813c59d39561633fcbdeab56de36e4874cbe7172a9e4964593fbe3e4cf143ba231684b7d0d1617f074162c736ee5c6bc005e1706c685704eb1482bff7ead5d2afad31c50090a2b5d2a3a3cb26f25da5167b01095cd218138174e3614099b8f78c90df2913a38ae7e1edc3ac3246b7283c10e41150cdfe47c284ad0121bf6722db3039c25f39f395bc030ba10b7fa51cbee1708ecb489eacf37bb0d1c1a90554b56e124251ab97e1da2267cb33d29e208f4f9254cfbb3206d3fc91ab9507a5b70c6ba6b6074f56e74df9d7b473770b7f1a16f887a568c8eaec81dd1875a8a09fe90eeb0b02afcf2537a35e98500ea2f8a8b1b79a7a8bf0aa940c88c0ea2020c0240c9d9ca40b40158d9fb8ed51bafd24edd3e1970816250e392f85624151bc3a2554215e48550f8bcccc579cff87c1b28ca14a0cefb33236a6c3464391eaaedff2a24fc396e3073632594167b07b6e7345e3a662b5de1bcfede937b2227be613ee99c23bbbc8a5138156d1031f0f6741e6dbe2ff9dfca60e696dedf981c4cb2aa4e761ed3d6bacd57ff59b2ad74d23007c7946d9f69dc415bbeaea7b51e40ba973944703df8cf9da49fb85425ef54bbe53c8f9c23b8e660932a94c62fccec781c29b604a39e4ad6b9d8bfaacb60b2535c2d3a2c9195566964f60b648d14e53f645c6c81f3c9caf419e4743df3abda822a44fcb1b0b29d8f9884d390a7bf98c178afc9c4e3a718c202c989082bed3981d45f8cbe88368565b9bc36811cc702bf6f376adb89298de9ae39c7d83e67da8b6a989eee8a111252b2cd749a29f274a83447edc18c6b4e2155a9d28a836ce5c2dee7a289ff3883d452a888a7fbde873efe9956c9819850f6d602bc88193d8cb0e01c8e96b39db524fc139c87179a19f9f1a69b539200dc39ccbfeafc1ad03a7ba9e6e828191e6989dd7fc42cd06bbbdcb9797f819ee686d2b6c51c5afd5695a90a634bc7b69f21fd73edd7a1a8c286d3540da498e4256934f59d8834ee398b6e7d07cb2a8b43e510e9a223ee074d8e6dd407b227d2df896f3c0cf0212cbd5d1eb5d73fe15e96f8e2752f5b8513c3846021e45b4c44ca0677440d791e97bc9a211908290548569e892af33fb318098fc1fbfc99217d34a9a2eb4194a0edbeb10ed9f7d32cac5f5c3c1285ddc0524f2ea50dad70b5ebb059938ce9492bd316056b5b496deaebe132f7cbe47d32ce96c6e5a82eb576c1623dd3ddc82cfdb7be11f5bbab82d315357df1fda64a00b22fb461a0750e7dae1f3f5edf9c2230c0ef48e6f768d88e1b7e9ad87dc0a865542882d2b1959ee89b6dc9e57cf79eddd6f1fa9add4d63358d95d9be76e7d16da8dbc84d4207cad88799be9b5a15f0a52abfc2c9698571d8068f22e2593cffdd53cf4fbdd3a0a5dbf9d0624dcb1228c02d6279f607895d29eefcaa8f5d7b72b68cfe03843a13d19425bd0ce8d9f42a88b10347e9d49714311c99ce9a6ed9dc6a01d1a9030340a05f793f3e478be4f9e0d610e05e67b5a696a5dbe2c4ef66c8b8b8b6751a16404036cd09799d9197e1a99cb18531838a552db167ead270a151d07e05167b20809130a654acb28468c962237776e0d32312509ea6530aa6a9302793df5d0637e7347862669d75062aa5e4585204e182e33fd9bcc292d196b053375c198eb9d646819a481cf345d691db0e69b23669d6489ac42ec37bb949a58ecf6ea5e3a720f6098736d8b89b26aa488548178b7da1c977b7f9259a4d8c7d6128e4f72a643d14455323eb8c183699de81ed7ed59a93083e780fcd3d567a2d93ddafd9c9083436f3e330d2db0cc1c4290fbc1c4793157ae134a1f16331a9c97d6d2aabc5a2064cf30827c1932b894d85c9f585797a02d1ab58df26689d118e319acfd3bb5118f79c48dc4c71e675bc9fdb9b38a62a5b0a5d437c52adcd6e0ccb29253fbd52d2f69eaae48d10ef751cc9f7c45c8d8602eb75a491d6a6536a26cec44402fdcc3c22d79b744533c4894ab373117abf301afb4a037cea7cce506291cb72968d28cb1e9c469ff43a7d22c667a964dbb8462a4d2ea8624fb31dddb50a6077f596a6addb446c6ec434fe257a349a7ddfe2fd618cb4a39d8a47164f9b77b98962c59c3d26415499852323786512bbd1a6f485de3c8a84fdd98b205173bea63893f883518c7820cce9fab94b37f0b615ee99f95eec34e06ef130bd6fc57f23cd8147ba1a31ba9efb391390bf8af05bf61cd9c6d2bb09cf9d3c520813ea1da6599914434e9675a8c4c029f53170b73f7944b93762a2346cb8beb7f8db89b0f6aebaadb10e91c4463b6de96d72f7cacce75c644054bd69e766df9ce8e62b52d6fdd8dc038cf0f10578abf7e678d7cafb9e7e049e5297b7481d1101969c84dcf7632f2839c25b1c0ced37eeea40e4671b2b0619ff9844dfc509fd59dae6a12a841ed61a4aa34bd4900e2891ea0d89b22c7940165b8b586cd417ccf3af0e1270d1746eafb382d69d997191c95eb2942662248229d151ad951875374b1f98a6667f816123fad84a3637f8253c48b400eb0525d766903118c0048fd163c80fef585300f1cffe3df6deb48f0d1b5fe9ff85876a3696db940e4ce1144fde9a5f2e0059b28579f0f7c40d14d7b4362e35cb617d57824a32f95768f35f0dcc4c25e44c45391ebd93cab2c2351451563c11ed2e824d3a910fe93ce5c80ed55a0f59b39143fcf04e468a4e1a47a53f15fb15f93f93e81d69750e58af4c3ce9336bdd01eb14805d3afdb3de218286d9cc12b2e458002f421814daf67f64afce5cc280a9e4aebdbd7e36aa01c085ed38ffe5445d35be356f8235130d35ad4a153e0566862b6748bd4913314a89027a70a0cde5ced90324a2c152eb7687a326f1e9af77ae3d81e9d1a90b3ab68e453d5a83626525cf50276f8f4cbc8e055e0acfed49f6851877f4dbee50bec7c1b2951e03ff617a82518873ff86333b3ee459ff7dd434c9177ef3d1171f587c128103b8b2725ba78f46b00019dbf4a9df04dd498086f85c5b647ea6f4d9acae5ceabb314e8753929a336fe23f3da9e0a8ef491e8efb91b09761a0b278dc514602cfa83ae10f4c47795125acdcb8c1b64f81aa0ccdbf4b961784cd08dd4ed25bebf85dd8938784ae3dbfbcc81d62be322a85c43760d5a58f843656868450d06a4b0c2d616f626d2fd689b756d26ed62fcebba53f55654bae6e1f63e789f4506c2a34d2bc2e72dfca680d2ee90b3456f9bb2080e14ee7dfdb9e8aa3bed5169aac021bf2d6cabbf967917366ea79557c56e521cdb95481008876b3218f15db72183575d0d68788b5b629ded866bf762a0e16049be93fbc3ace8703d252cf118030c68a071d947bbf2a56403978922c1f00e67e83e6efcc105dbb664fad5641c7251a59a1d3deea7e68968c3f5094f8890dd000a2d7f17d897599e19c64acf04d1366d4a160329e370875a4e42cce31fb38adc46530dc8295c1ca8e595270edfe024763c25a90ec4acda018865f2a28cc71dac6362e9ffebc21cd58d09ebc85ec5077702f689d756d3d59645aa050d155810233499cbfb0f9e37acb4142772a82ce30e195c369a5a9feecabf05e2c1fe507748891474568a355622145fc2c9dd828252e7f1f9991a39b8221350ae0d2e945caf95ac133c591fcdfc4eca28a386a669de6ae7ad32deb93fea712702806b2be3dfbc49e49bf3e7403caa318eba713a589c0c58ab4fbbcfa587469c343d24fece9a93db9de9f208b7be74fd43fc189ebc2f539db3d73334b813643dbe9fb20911bfbacaacf60a11a6f285af7420aa4226e3a07e151426cf13738b3001bb536866c6f54d632ef1a9b6f140862c20a05928b126b701813d37d7b4d3e1b748de23d6f8b112b458afdd10971dfaf14f258bd44a381199fa962781d4e2317764359fb3c19cc3c3babb2c149f862235fd5433e06da5ffda9d471c340664b1f4a3649da95ea5aec78b305bebc9de392a029425529788501eb6a84eb3986156f7442ce717be2d8d09dca75ac2f1ecd5095820ee0fc0372f442851722ec341a8eed3b542602dd49783e70dfd713eb2bab7b206d3d1fdba74e1fa12a823e7c4457e7e85187b3832b028e063a5918065600e22e81a511379bf6455b95807306924181a236baf48004192b29981675cf18e24f3a1a0c1e3ad55346ccdb27729017e817261ee9191676656865195327a38dc0f5171b6191da9e47127","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
