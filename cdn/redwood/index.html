<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1b84afb8cca3725c0cb794acf8bdd3727ace63751e3139dfd97c8cd32027d0d095e33ec93a84c17a8a9ffb2ff21bd8421c3c5880fcef7175b2b1cc15925e9c01e0bbabe02d47a60f247d4b8ebf25303dfd99aaf233f87eb2ac96fd00b59c1c7e64b6ddc5c1fd210d1280e0e6b8329f0ff22b2fbb2c76cf209ab90ca3a9329a278365653a4e1e06605c69dc3d580f94dd02b34d90b16fc70898bfa16184680969ef0d1394e8088e24f6c6423f0f4f9ac835c44d97adbe6c28db8d1ba7e269089984d466c960c36bff152c1aacf927a6fa37bd3e0c3229877ec545b8a1ad54f8eaba8026117f9a0e497696713c26886ba5763ea28aac0688bdedc10693dce0c62983da540116dcd624f4623913695970ff741d6e2aef499b0e8faa2884399620e55e4e6dda3e453af158c8cd5f5ddc5676e4e6cde0a13170528ff5a8bbb7728e74357a1819fb2948854a77de3baa8a23ce32f7b817932022b9382bb818acb08a28b63b7cceab3d027d108d296017669e2a402ab60859105b8284ab95c110a4aa5a19dc366361b6fc0b0e0a45d9ae6058461cc46f77ca10fd9180a72ac663f16d1b0c14ac5b94faef5853331673311a7e8829a75ec3a4a532d32f4fcbdcde5bd91ca4890b21d4dfb52147eeea3160c83ca2a681b9b9194908aff85bb0b7cda6a1a8aa16b70e436ca1cf935241ee1171bfc0b8db2fe8970401b0baa077b46030c1fb2c58fef3cdd95482a90356dd6868ff7d9ea63c0b7cc115f895e8a39d1b61efd2253651a13d22c30f417020f995c0b150c0d58432bf7c7051375aec8d19db040af645f770e0eb38c561034851cff5cdb0337f745cccf7441700c588575a398fc77146cef9f267ccf86b8ebfc4ef7a928037058fc847384b629878d2bf270e402583d86282823b1b6ae1efcf0bcdd6498e4c8eced94feabda5ed06e98fdb8e1e7a2723f6740e90799f3ebf416625a31742d708a14e5d7e481eede0d1370f3a3a5fb8e05ca8de16e7bb1aca6488a222c66cc091116a6be62760c36291ba932eb4d2a404a158807b73ad66cffca323f51d19986e58e3c707b91c46348ed4ce736c5b0c93653307eca455fa1f8fb2bfa7f7c74cf0eb7e159584609400b43773b7a28fff9b90487b642d358745801bb5b7bca72a464309014ba7e94cef62b10e2e021081eca3a7dd39371e606f1f478ced33731442bb60220b20808a48d68c435c42227e00d3e377e5815dd0f2751945413c6acc280c1432192bda4da61ddc8d2f8c7dc06953f4448a314f57fa31fbce1482c9dc9e4695f31ac06a0d3391561617cce0a03db908c0aa37dcb3d189a9a1a140944ae88b2fbf034989c13de5e8c848bc82763a20a1a655848b08d57f8eec2dd78902a195f8e0fab553c8abf5881f0a9c21a6ed4a307795beac846d6efb19da833e5b4b05271c7c9fd5ee3513aa619275b91e0ea2bd4c9e4cb9bc116ee7406899ce7db6f27ad6f5db8d05c819a853cbd888e6d0cdef4453c10b9f4d2f6d00694f0fbad23fa54722ec15f8c7b3c5c9a7aa8bb3e345d3e60632db69a72af336590949fde8dded7b49a3146ad482d0ae590a2c7d6a603122b7d8ce33214af86cbcb0e55846cc100b7da7677a6ea325559699fbac4738dc3483b73b84fe20c662f093e81713e1d7f9f62f1fe4c66bfc4432d6da796f7e8a1d5fb7de59f05869109ea24881c4a2caea09dafafa6b134403f9fc883e337f2266a67bbfb7f8463ebf48bd96bb5c6c5142d2d644e438089a5389642a400959e987e964bdad593456a442bcc6832484c5596c7cf4bb0975e57289e993526a72c441ca23d50e164f2ce87ee4f8b84f1cca978c1839f233e40e49609049a6b9489c9ecb673a1d81f82f35c92adcf3e0ca36d11bec78499e41deea6ac37001f213cb042fea92dd39874baff18a3473c08e3defe150e97a18da05770e2f87e4ea343c3dcfc02b3fbf4e431656fc1bc741cde8164686f72baf94ff7749ab8a2173be1c3944a70b24ba03ca2d9ea2e53601b422f85a1900eb004d0a0777047dd0a99957f5ae486b4ad203a70469ccbf064f20bf40697a6dc81a713ec4ce6138468c1f0a1938e400c0a7e7aa187e1d83b09cd346084bf4f991828eda6f5e741b8daccb6138e424882562a67121626cc7f9d25a8134d08741c55c33e7548b8133686622c48652f1729f2c67d23d545b7dcdd03e92152a8a51dfdb402b9de34745eb7906d3cc138318cf5f5761b1076582115eb7e83d8005de6ffd8ad14e3eb54f561fac58088345ce2a816fc8c5c259065a05da467c396d4c37363500b22f98e1c1df3366bc8aff69138e48d72ab44459a209417d142aa9010f2094154e65cce048d4be9586c09a10b9b89e5f4414c045fcfc2ebd66b4c28c07a023737fbf9a6c38ac8a6a03bc482a149373f21bdcb961dacb83cc493d89e9ff957ff79cc31468b7186df9c156a1bb2d74373455d2eae93105c1f1c404a823098e5c14ca709562f3a7f92da4a76ed13414c2b025f8e990ec33610b31e22d376d25e2432b2cc28f292c9976ceae3628c9c0222de0c2b9644697260a9506f9808b5d04c6a86b99bc9738041dd949b5ffe4d2d87623b50a5adf40500dcfc71242e2b9658f12b51239532cb1d87a0b7cb69cfbaf8d230eb6603675efd2a224f181a1ab24e81c36d4ea7b010978e764a0077809eb780c92d08b681751f6b29a8578a8b55d40814714eeb67e58a67a5499e09cf9c3a90badcc50487117fbd0396dfe5b12843f36a2ea0021f8b9dbb7e4a75f6264cdbfa878370ade30384200f282dc76dd4887238aad51bf42af86d6c125ac63b5531e3746ef8ef9705b210875991cfbc9963b0292a1f367d893dbac2d61ca710e6aefb410cae5b8febe972f07e2cd24bfcd0ce10b4fd38744e5cd943f1911e259674895ec29fa7f7710529f922a7fedcefd1167b5f8fd9122f39cf8e4682b223b9b86167cad0da0094f216f38e749588f186bfbe6823afc99498d36f4c71618c78061850b68831128bbf07c14c44b094ffd87d10dffa24987917dd7eff60785cfedc3539a70525d3f818a8dd436672869c6a3da70e2f031087fc2df0bd57f6930001fcc82726ba28cd2ae231946bf0d4e6166e6fc79eb5788fbbfec3fe80aed10d879a0ada00aebf70a6e5e1ba3c7667cf6b3bed019c7f695f29e8bded5b09ad55487eb570d8e741fc9f8128b62418ba0396c57e726dbc32d23f4566acb2095bd59e8f1859d272a6ac85858b7738d5df7013fe5e5599b6d4c9eb7bb986b222e5bf9e34ca1937d48b1497314a6e1c8e7862125432ed06c8dd01193f50a1387d8b4feff9dd38e07dd36a63137bd835435302e6a42e9b4fee31225b9303fd92cd15da9d1518732c43969da5f8ed5b3c93a8dc79282dcf5aec12d8df7ffe4250936746cb6252749cc12eefd49d347138f8459da05037662a39cb1d53c45c655091b296efa60e5602e2e6aea26b0c1c91460a27fc166bb6d55a4a8c1cb68204032713f9bc7cd3a920345743d8e1086a2353e8a28a01ab231811325ac779d1f70c903dcf4744ef4b981c186820124b45e9988543d864a3f69d1170b26c795ab0387c499e18e3728585ea73ac110c32c2e32b8758810177b0efc556d92720fef3e49f31dbf6041f2db4690f1c222adc54c38d7fb652bbbd359d2c87cf4553ecde37a60447c135099bb986dc2515422467b93bdc50919ecac319a09e1925530ce3f55004d6a0cd0844c1a78552793e10f729f3c508ae744309d0d2b092f5ebd69743b7a05d59646400258a0d1b66a180e29cb9aef7ff0885a8597112568d5159ca2ffa3b3067c7af8ea4d57aa47997a07a4bf8f365eed5b532102a657914f1d94904fd24f1eaa84f9e6a6c8342a1bcf6f503fd46583df3a4fb5497ac0edc3fb00dbb946a65c0aef0a9a7174c67ebb3f4defeb52677bc6c066c474cd9cdaf400c47fcef2212cd22b334172799738209294b6dd99e37f424ba43cbc6d2751d2aa75a9384936961c635939fd360348d171573aacd8042a8f2badb177ea0fc9943f5027bc80fd603eda641b7c5e663fbbe3e6563f8eaae31c45d70bdd160a81361b221b01f3a0a993f90dbe889c493a6b1c18e174aebba3690c17089bdf155e3bcc6439558268d59cabc9c5dae730e9a270df59959879286fd381d10c52d5c039b2b67f665eede0bec3655933bef2d23b24626bf34cadbd68f2b289903095fed1b54cde1890174d79c3fb513096633d14ef9b91d5d94aef966cf68ca64d7af51061f93d36764c86799d14c5597874dc7f91d6e91122592902efdd3c3c8990be454501f342e02d7cb53aa11757feb104f67edc732417b60c36d45400230f3d7a85f13a7e034c9fc6829f50d1b62a693f6716173f470e6230618f326287d4c2e550a48901a9e0dac96b307e98e03fd0f9723a2285cdda3063cef74828c99a4bb24c64670be4af4cdec7bbc6ee9037a30a63a9bf819c51d360277dd907d8fc4f213fa69ed7350ac0a347da6af499cda63552abbdbad8862aabf971c085f3b27223561854e87eccf8de254d1d0fb6088e018535b35f11b739f86860c06b10f849fb28ef3514366a402d354a42b7ca3b601833d21f6e1fc2f4329d743c3ae5e0985d017b1a374f9f0af47af5bb1c0b72d4e715673104beb53576027d5226592c5e89e56e0bcb6de5d47da2190f50a92a299d2a0bbf57fd92b7555103f58c7c1426654aba00d1366e184580eca46914436346a198bca289acdc9748a35b5c44bf4bdfa42c45579ae014996015550ee6ce47ff28b7f72d4f603d4a19170f6fdccf169e47812a2bb55bdc533c6dc405e51fa3422424c142bd462ec363b94add0bca59f252597c6272f3e096bc795961f231b95517a846934f2957278dd66a181218cf4416b5e08db83b6dd5645c3645514259b5aadd5abf5b33021eddcfd685730ae3b53546ca7f07b02041bc233a0d3917632f5649ca83893f8304e54e9f375e029d6635d043a3cc1255de9e30f9c27c4f1ef5c83e4bfae71e10be2f985d5d5f1a150e29cc6521dbd3c6cf16148e839b4833320471cb80edb89162b0c02aeabc4e8fc8e7d4f320eb62cf45f76eac8a02716337807d50b7126182881e1415b2fe66259cca75632f85476455226799a92b135ec814a03ab6ce2b7d3ed9a38f192d258a3863aebd1754afb1b27328450c5561bddc39c1765e41355fc14360c67b4937ceaa0bffd475d21e80fd92facb9b75638cca7beb9fe1f828237fecbbd0c2aa5f0cdac197a70b09578215ad2e8d9bf7d62e1bff9c5e793d53c934cea5e6d4f83c7b76df4417e9be74274fd40e1c65c279acb394ff3af64e54f1248a093460b1270040633138c2fd38ee0f5526113285e5b03b35130296801b9b2c55575fad233fd86726673c8f2ecd99843077980ae9d916fd7e747ee9aab8a010f8edd35a17769e3676de7f916839c78aef45aaeed0d2ded500258d85166c5b12bac2903c1b7db8d6a3b7eaf6deddf49c6109248d4227c9bcb3f7bafd24074c7da94d9061801a3de7c2963e7f71bda7652fcec7e0a1b9ef7b9cdb1c32488494be3ef515fa6bff23617d074761be07449a5290c3c90097bc4b8056f7903c0163df82c02677ede3ea53bfb1a23df407bd625f7849e2f0af01d34e8d9699a1a5cf9fab15b802f4159b9451a9a7be74bd0927f16111b3d3d36e0683ee3e9194f422744eae2f71cb32ff5c817661f2c8b5585f2d64667e16d8604e875bae1653709a890db266323e58300bdfda6a9fb668a4be678c6d6d245e0be011707ca77bd6500b13a2287bb190ee34c3587c33d5c6a5f057856acc4ccc838d69b9f5b78053a871fa4d49ed50530e08f247bc4ca45134221afdd4bffc033be5a2762fab0d01eaeedabfde87408c739de1874c87d1d1b95b669020a5feab4962b9d4c9aa7573502e2580d2d7025848f338b22c82490440b1f132d02a3ded1cf386f9211908af29e3fdeccc1e75323ffb832e37935982534ba5ba747053db96d3bccb08a5f935e8a242619cb57fcbbcd02446a807e652fb1b7bd61657e3486d1228d499782c47e75703e8923c4562d955c2ae72dfe79b6e466cd3dff1ef2da6e81a00932a590b06b6293a8862becb60b261dbeb4c7c779663ce336cfe97ce2159d2f1e7a3cbaf7edc942b4bf1683e91225f8becd1d94be3ace35f347480d374f820d01d95f2a5d036182a174b7eb3f6e468b41f78e65e0e0021b0f01981ecca0afcebd8131603c110ae4252b983e171619a0067ba7890bad4a3da64c46a2166538f05d275c5c32dde90aaba44dd36c37114650a9687995b3de9b049d1b64a371d4f1d4c96cd57524c525a6b754d75789cc89a771b502d66d3d844548bdc7670c450f76ad5144d679599c245e9368eefcf3bd51f366a7d0836e8aa7774f4b08e40655c3ae0b71d0d2d9c410533fd83a28bb19d86c4eddcb2f1ddae5c6f31631941fec9234c49ae3c306c04604992ce0f7c2553e7ba49fc7ddf65923481f6838b5c39ae3cdc67f5586e9596cff21a1b08f5ee28a89acf30e5f8902cf72a729ac44d6cdfa09c428a9e15362b02f8f9213fb805a21e730398c2c0fca6a5edca9c06b3314d5edfe9b4e09d4fa4c18150b78d310be1176a741f8be6842ffd922677c4cf2f7a946ebb5a45e5eb5531d006818766c87c44382c8313c42bd88e3cef4fa6d7330af76932093ff3a6ec3ce4ce11de933e16a063c42f2a8a0a80653d28d0ddba32f2b853bf7dc0568616f53c0f1ca60c1bfd2318a03915604e646d206ecb874815508b3e28260d5bb86c95eff1ebb7b7730824fce957d22f68d32a41781b0b64aa2c59003ea6e1dce3291cc09a29a4617b9e5f3a7660825767a94ddfa3c8debb5f45e0c22d21457398b1456faa697f3e4e0cc63a5ed30267f523749cf1ddca5c61b6cce903ec2e9b2dbff310ee8e67dc349386d8bf116fc56b1cbac8cc72b64bdcd60ceffef9dfe196be4e5e0264d12055c28b336c81fe15d7429be36b05228e1b84a4496f39713b3d28587a4bbb54e916f0c7a2c0db5e564345df7ee752d7876c453d71ddf6cde6ec90f5cf29426fff1a1feab78a93fb5a652af426f771f50b229a61d5f72bfec48bff00ecb6fef67e11fc7867f1b64652af5b58b65fde41c4b5cf85c6a93dae50f228cc23b8ac4204541f0cd7d39009b3af8c6b7eb2e9c47e6eb2c8f447a49b69a550d02eb5bdf28041195a010a18db268ab49521fda48da263d9c6683585a6ca9a9e3f303c2bb19701eb2cb0c68d6439a42fa0b5eeaffbc301542cab7a3d24fc1d2ccd1fbd0cd0a33baab61f8305d1ce12c93c84b77953ac8f1a62de21bfc98183acb277ff773093523275cfa3ff394912a73f13be55240a381cf6bf3c4d5fa91cd49e8eb7d287c5d34339af547870451688f40b64bbea6a03a5863bb4e1460fcfcbf374b29980ce49312546e0c3cc4af01bead05f491176d880a13131c362d7373d7cb204a2a2486a875ceab1eaf94bdce9687dd77a591914fec8ed7bda2fdd691ecb545d4994ed75977519ac289d946f5dc2ce4eab606fefbb02734d8b812aa9402054afd8bab69b5debc8685f0eb9411340c859e3ebf75a11916c9359d9740dc9c25acd6b5a4b0820d7b30bda844e7c469338d6596a21fa70dcd896d4bd90c4e0b0ab2b90897b7dd276708e73ce0dba5ee9895d7f3664aeb9ab6e90ef3f37c2ada912abee10ff8553595f894bd49a5c46e7b8413f2060952580f2d0f7603f8dd3b469ef001e41a104a7862fb46499220bb223dcaa7295590e74ecab7cf7549e61c83c2e8e6b12995f954bbf954d8d1298d1f69069e940f57e68fa0456d01b5a1ea00894c8acaba125c9fb2a24a9f89c54c4b6d80d056f2a9f1ba7dd15c33d41b0cf4d0a64ecea5d24931c3e55a480c1e5dd2663ee3a7c62600b58068793c9fa78cd488a28ba2895f47f3cb3c629a88d4887ea59671ddd9a3e9004b6d6743f62f118adb3f7a54c560dc6763212f86394a0e9583218a43fa92031a96cbd2c1bb38f31266259b53f7ca78146327b90bed1bd9d6eecc32bdc32d2a06f77a573760e68c73903e2e267913d62fa66785e59ca4611ffdae53705b6d4b2d92613740be0dcc1453d5dbe9530028a9b20fd3429646968757baa04c6a53a9a8b8ee6fc87a12963f3418fb8b35395d952dcdee190d03ec7fcd483247c8a1eeb560cccf8bfe04f620bbdab6b1188a4667635a646b63a74770438fad82c8ee6c803f4c386c7f668447b4f6749d0db1c84b15f970f964ceb146ba17455de74ebdeff9228913fd5877376051357d4ca2e91631c18f18ef0ab25a368fa2ec7a6cfc77f408a4af392b1b37bf1d640d0736b40b7c723a7c1a186c609c801c7c91e123a71acf5ddf413a31cacafaaa964e4d1c4315b8386e252bee2f6540d726a74990a2cd9b3a276faeec9c33cfc1f6b0bf25970a54e0730d0fdbb1dfe7b412e7550960f867c5cb8e21441cd8def0d785af0f7146f4339b39877b6b8153ed991b2b101c26cf563b48fee3da6ba7559498cb1b86b5b81f6b726f8b9b591ba3e78d2a4f4f38b7f7540fde66279bb4999f24f94050a7c342934e4be2d62809e0b29c15f292a01ecb2796419a83f3e53e930229de0364744e874454ead73325450890959599a29df6d9d9fc1d4b16de1c5bfc0eb9f168d05ec757ab89bf959e633707553e29d2396e798b8554a778fb2ed4c5f5423b2f164ab21f9f70e9680ebd036e2a51a23de09717234c654f4c8c2395d23a2c7ac1863737de570c22cee783e80d4bf88381a5b5061f75a114272b4571c809b676d55fe7b2a11b752d1cc2f7f5d012910b4132910242c5962b33abb5534200419c862a2938e72359b9fc3b4f849435cabd279e36edd9e753ee06ee2554ce2a7be303f7130eee956ac32d7b6a043c0e0516ce106a4390ea58f0d94ff91f3566b6357116438d3bb71c75162580dd7ad8d521a9f7d4019074e307b411ab458a2a9a26423370c13d57665b641601f7b9682a5396504638cef6156b5325a76a627a80a3097a96726f04b21d2d5a4bdc3ae7cc6d43093842ae299bd83f6d5b43dcceb7c51b74ce04ca2bde6074d4f8539bfac3f6c5da6786a3145d68385f40c9bfaf7b57241f1ef8295bc4d522d4b632cab53ef38eff144549137c4260e64efd6c2d8027664d4cc249742fb0afd3c93e2b34393e815fcef88cda2be0deb85056eb6d6d3bf5966786d8e0d39a45a262e19ccca20c5f226d81bcf4fd79ddc451670ca82f1ad78f56344e03e593790d58c60c31a59b8bd92710ca74ec3ae72a84bc056b341facc9ba173f796987597abe2c376b96b6dce0278ac0286497a969f890864e39ab1afed18c03df4d87cc41a551006b0093a3db0f2304c03819ed0115b121a8cca0f96f6f8a3495886bc1de5edf66dc9e9a4c345b4d405cb08d8ec719d6df50a3a1e66caea193ff21158bca6c7a2171060adf687087728647f8c9ecdd8b39025c20a88a8840507698e2278fdc4d489db2d863f493630964089d529e7a5ebe41a73f665d0f3a3668064886686149bd9d9ca69395990da4d38637a367895cc1bb6a544a52c741c3b018c43ac658ab5aac10d0b62e52cc961f00107a71c4f63af6716ca8a8c23aa62a4c485f59b9901f057a119b58b022af14ef8fa4c10eb48eb19cc259f8baa80845ec4ba203412d5548bb17566bfdc3acaa1e5bb0afe3ff8a0da5fe784514c69e2122dd312c3a536a0ecb6a580d7b341825cf7a46d228f89604e7564cf4a131cde897574be206feb8222c651756d9db48ca1e727c90666256d619103bf6d2b72259b7cd88fd8d74460201760d4d77caeaa79ac7c5678e8eccb143ddb2e95b7ea894dc8bbc7383ea6aa8b24e66854b6a6d9b62f732554d1d88379299eeca0481497a14dab0ae012035e8a2a258920faf433f0304f43c34224d18a44da0621ff9690d810305620c387963e70edfb8f4e4d38769a96aafa5f297c6c2bcde6abe97745c3d20b6c7d16820b0a9c9a9ddf5f4eaaa66c5386d72526537498c1aa3178abad72d028c8ab3d40a2d46acebe755b1900af93bd4d566af12c2c2688ac37dea462aaa58229330ee1a2a33cfeb535331ee372ef34f770ab500dad7e146a22a338c172d6ac7343094874fa052ad7800aa99d177c32789b7e828485c18e81abdd9e0e76a56521b189e1eac0b5fa1cf2da3095321cb9060b739bb3a66d1173b7f87f7bad3f1d57b46b16dd56c86f5b2c6468d6a835208db271d00d8092eb573dcec51143300d0bf4e1a09c5390b16b7e4e1fb2f07d3e64fdde52a7ff84d333415383fb1e706258957d91f9b8590e8506f3dad8ab26bea3c3077b0c3c11f487b854d3a6ea34714aa465b09e7ffd1e3c9e24b69c8785c3a98bfbe011a4e31a65c8ec17eee0eadee8723ea92886b3ce8ad16c6d27f542d78d55223a612a38dba1fb7c99a4f7ab709d23c68533fc33d8176ca4d3f80531399a6d6e91dc2529b190d328b50be8499344b3da89cb87035206d4a6be43fa360bda08f74eab74a290507dbfa5a714752a27505b9ca073ed59db9c11aec86c203c27d5a4a4b0d0c543725f0dd5454164533812baefdb4ae9da71a7f8897e16aca091b4bff3980a4bb9de4644a6143a932fe0fabf90830a7cd437abd50d97cac4cdb462f1dafd041deadf7ba8226803ca6a51b9f405874f204fe7f0d01225063a8445c69c6fbfc6fc6bad565db10c6c05e75b8e8c2adaf152fdf57033538b86853138cdfe3d924e7029986a4b1a411d750e91fec58eb83188fb91beb68a669b9dc92073c4cc59257aba7629a39b42e1f6639d38c12b744fa97b5e4cef7dac7760f114f90105aedae768f546c822f97e768cb73a776ac626a8cd0e36eb96a624bcf8ce0e3c7f14d3032eec84551d5099cc252b24f7692bef05411854865fff8eca4c63d0d54bfa5068484b6bac1d2b0bca21bf89d0a9d61163436ea13f1422b41ff891b123273bf8e2121679f2051cbf973fc536f6aa0f9b402166b0742c46d8660aac1b68245b36dd0a1a52f8f96b0743a67b2c24b6ec6424ecd34f22e03f1638ba902dc78c270c007b09e105b43f467009dca03892025b00b888a1ee930e4470cb59391a00536317cc198132546afc04fefe50e737edcac74a90f334f6d3d3c6746139223b8cd40f82f0408d6a587b8da5c3d326e0e5e01750f00f00ca8221b04bfae3e8c7657fb12786e20463e7715e4cb991cdd79473e7045d30dd966f5791fdb55dbeb481e1026cb4ddbcea7a90b2d5b728f1cc7df564a1389fe37cb9276d6237c8564acb1b205a74f4dc40bf2119dee483ce57cf53186039524216285f7d40f8463fc33200c76a9b0baf2ca4dcb5baa3915ac826e1993798f8c276d29d83bad818b08a70524646108b9e88d02e7cc76d5ec2f5f99a666754355006123186f588dfe724a55843a1ef2719a8f2b3ab3eed9815813dea8dfb2b9658302c4c2af334e90501c3d03e15695c8dbe209fe165bdb7d6c66aabce68602cf9778c01505a487521c7edd2e994ab195715c0bdfac41ff15880bb1ab0515a1f4fa0b5716ebefbc77cf4f2e712458b101dc5c0ccdccae69365cd90ba8f0ee648dacc541f4cd648d773ed5a2875c88953d3a0a4c584ecef9de13b70c004353c84adb996a4ff2bc78a6e55db446c45a0f145577c314e6d33db2316445436416dc4e9efd6ce0fb673bb87ad56b63cb902166a0ce1403c956ba6e78d79f3bfd0736239f5d16122b017dda0b8830d868d9db6bb11956454a398371488617cc7108c943ec790d1a274578663cecfde25d21c0c1892d5418cb1486a59bf33b37d6e3d41e81eb4ee09ee0aa3c5b7fb437045d9a223064cba4d2e315e6304d56df17f661abe5488010e8aeafa7881deb7176a22712e73aeadcd8960f8f3111d99511e088d866940898f8fa3650c68d24613b5afa9c466016b27e8a4516e5ca0d20548388dadbc809375e03175243f69ffca6fca343f9019fa75bee81e39bfa8438c933f7777c30e780a916a485947e1e7c3d61b4a9d642cf8cbf8857b51b0c68eef53735e8f4793a5f970010c86fb5632424aa96088025c1a78bde73fd020479cf9f4fb2501b1496330cbc67f39d5181fe80a1f154900dcd77f56c1b70bbebaf4eb132e8f63b896ffa458ee523279a06d525004d4f2ec33254913a5851c3305d7bb9ec47a3118e5bdbb780d030ccbbf544f80738d647fa3fd91da295d986103ebe45314c1b30faf571f54ffa57a49af603efd3d586a2d11b3964724f89d5b94f3c87001975cbaa570c7c7c6cf56ea319e89a4d2b02cbf3ea64d5244b8aa524a2012183a4aff265efa416c880ae8b6e6915b2be934acb99822dea04a09f11b079f7ccb41882c83a268f4f6795571df1cb5cbc2657851bf0f21d0a3bf3fe45008a165d1228f696996b3e30e81400a54ac862d7e9f262f0899042e6557f2f684bc552544ff03149b091c9c4cda39f3205ae856a09a308ede819d5a44dba4a76e2a6f2a5d17be55bafb26aad50c069fb596caa6728eebefcb8f2a3a3fedfc6b2a86409ef84177679ff3f6e8632b2dd89256b83ad93ff86302452c558df7be7494c62e2664e5264228d0b5ae193c67f80664db99c07b36178e0c6c3c772103c42feec978b6868a5973f085b5f3774a0926ce064a436f2e1df313d12cb45c219bf3883f568520657834cae3c0ab68d76f63b8da10495d0df3bbbdb187ac39dbfb11a92de14e6a928364691601f39b242a4022bb7333899e6dda1be578867d3774d7b8c08d61fc01968c8738d2147ec7a522200bbff4227b45e118e4956021854f26f21899e46f21c126119099b303fb26ad78e2d4a59db835a5248e277a428f045e364450a5c6ab8989128cef1c01ab1e50b9f0c6a6fc457556c05a2f4c72a355866f775b00f3c5855bcba356babb5f0c2a1ddc2181f5b4ae01deca4964563450a5fb84956c71c0e22dedbb7aaa74a740fb816378cc0cd754026e6d15ea6772dbe4733e0a1cafdc7c05e9f6f0fd42898f2aaabf66afaea64578dfff9b63af67f59e5a52bc04def461eaf8991446091a056063cb12a047f21144f5f5b56fdba19fb366da7da31ad66fa91ffe323b8aa3269fb93dd0e8788471633f99a9d6cb47755c5bbfe9f7c92083e59f191d0f8baf501965087011a8b9837d9192af218f4407cce1ffc0b982e0d98db53e315c9d33c223eea36ee16307efe397fed359a8a0eb7b78e44c78e647bac99d654f4a2aa8328ffa13ea0bc8e034608ce8674e458c79eba279cfc2dafb2797e663982e182a892610b13e9295254d1fa530384e052b4e4304d890d34762cad6a00b707ed8e56066da03ee2d7312ea7773a7f70debd626f8e4417425635a132fb47f4997b90167d35690b430832078c96bc22633ec1f2adbe965d6982b8a024125706b78f29468b21b474a2e762be1ed0142be261f4d845a41ddc6714ac4fcab953390203a86a6da4a31187dde4984c790ff7ccf99fc2460515a5d8704ef229f0bbc76eedb3ece002e9ab14dc79b4f3c0d9ce119a36bfffdabb0cf48544307811b1871ec877cd6c7abaa94002a75c494f6531afd6083be89212266adda5207836ca5066e148e3bce85c715fd05b8609e5a9e3addd3d1037f39ed1bed2346b126024b6528790207fd76611bec3ddf7f1b52671bd8a1e0910f7e993b01a27c977240dade1f612ed03e61fc1037ce1e2c2eb39e5e82c58679be83b8f13f291e94d91a7faaa4a04b87e6fa627be5f6b705dd2419cc1cc15fac529a56ed6ba5d6c86b0f410d773449b69f36f98c541224bdeb9a7bb7380b21ebab7d4219a60fa38c15d2b5a54fcd2d36e5c2e808818fcfefe1dd0f3e49c3c404fbcebf7f19f527fb4307e871f88a8b414b9ab297a99c0e0570457a801866dee402b483bca35d545403202c1da29a4e394ca139083a532ffa4c10d03f4f5cf7bf37240b7e354c9dc60987cc60a35b5b35b5ee0918c73a099b4d5282287f64e77282dcd36b4b081d774506500b1e2d31797bb719c0bdeaf62f00381c4f0cc914e133a281ec5d9c514582ef2031239d7afe536d84668172bcaf7c551af40e77f78232f8dac80d65a16a909d2400fcf558aedcabef966659fd42ef17ebc7720059b3c9686d6c28de803f8d54011648be3974865c89512f904f3bf9cec3a92e555702d6e81e2fc6dde88c98a88da450f7819c1b03a900e5d493c6780b350142888fc5eb7abced6b5d921bd4f3cc9598c867ac33da8990854b87c0a320ccd953f11303d9310d3b921ffc3c5de0ea7843bb6f8d4532c592aa8c3887cb4a2aa74177beacb92c3aaa65cedde6fcc90cdaf6b133626c1a794110cd945ef7bdcc0f2a125e743d2e876bd90da64c386b81b8b9108bac32c710ddfa8fe28352f77d16f570d1c326166ce0c0d5eaaff80f81aef177c384816a0110c1e96fd7b8ec2bace277dfa4e26a24bb5e15c048f380ef9f7e05014d4a68e458561f9d77042582f609e8e9e31dd9cf54766c5797e4e361c363b290c9b44b9a8779b9dfa8d5ff938c2a5db0d81dc1eec3cbb7288b9bc5ad2479335740897a6c2c3b00fdb145c32a6125c76ee015ae17c5af992357d4ddda4f619fbb0dab02d3c29cf5e9544b3ceaa9b16ab12811d64a3f4b226e281139d7cc97119961db78834f7ec89ae66873512d0a4558d13d1c0fa34c8569280e77be3e7679ddfa4a6cb0943eec8c956036f3084a101f06ad05e3e4f72b902d7a2ea0cbd7621d8e1916eff73ee3a7c228ece9db2acd5cd943b18658ad968e3ce4e23bf58a7332ac851ed61e6bbdc3716660e7c4f852fab0b6154c9a74e2a2a10dea63639a08c4d9a78b70220ce5209353df9cf8d486d750338fce73213cda83f17ad51f4070a65f6eacb76e1415b993dc5408b12b4fd7dc53bd8782f26714e4740cce279a39111f3506528d62a09241caa6c3d21b0cc9618f9b4f8f2f1662977aca8bd7fa419eab1d0fe036576f71347c70a1c12d9d4ec4ef641ebaaea91a179e65e28e8f36e9edfaad40bd0690af50cd5afd96e932190e4f1eb384c38432eb10ec081b34aa6c22702aad0fc47af66cf1d1d9eb96b25f0b2b75f1ee7642938216475927cf5f7dc13f2aefdcd9c3313d2910df4ddf8e55362c7097b1bdb24f429df1b0e4cb18298351a910d6b8cc8cff5eac46a8e7dcc8e5e6bc94a9ca07309f5cffbcdab366482b79a5101a50b56868d4074eea80350a9ef211d1521eca9c1dc3ed807ba269b88100299d922a6df5c4824ac4c800e1e4af5a39e4fb5b1c52cf7dca583f402448cd593a7f7c6ff4f33ad4fc00f4c27233b24e53483697d74672c256016b402de0adc8b90cb819e020c2cd1f5ceeb570e408dcc6ee6c7a1261e62308d7b2867e5b56f4fcfa90d053baac8667ade7215f03683a517f209575bf4cb753ac43b3796822e176882067615b87400d76acdf5e7c891866c8c2d166dd44c07b7ad143051e2d457d8a62a7b60741a4908b6680386d9d9fcf426271d9aba33fd24078470750495d4f6b41ce8a4b6e1e9841f41ed4ba2efd82604a145ff9e66ac58e1c18bc2c85b7bcb45a7c8854f90f6000c8525af62b981d241b77ddb1aeccc1e7c608a5e67c6e89af8b9ff9f0b210c8dbbe57a05ce35fb27b5d33e81b0f2ab31790416c9650c31d82733752e49cfa244ade1156516a93f60429e29aca2ac66f9e0e015f11bff217a1950e0da2f6bd62235426b984aef6d1eb9137a913dcac5f2b1a60fe1c61595d44d140f3c6d1d804b443c5461d8da90631aac94c9354756adf8a6cbb2f59a461935ce45dfec0e3e75b69f5f5db665f59100b6fc08debe84b0c7614067725a725dd0914863729bd819e78f823d93d949f0054c017e4b7a62a0dc41c74c73604749cc9cf55d638efc3d31f7e9a28046dc862b9e3198bafd0d15cf3947d82b9ee91f145711d78f8b4df5d2fecb9296b43312fe7cb5f35a3d027526b6d48665ed89c83dd25ced50c446563a9fd6a4c1ce6e90f3a777652a706deab3ba6cc38b6f7973f7b6885008ebdb4d8b5dbcece9bb3d59dc5509a29af5447206ecdf10bb25ad6920d585b8be98e6990d369e63e5e912f0e4db17be966ed0b08d2585b3a48d0e608e9557253663c56b321c77f82d3eee553d74ae7ce04005ee4a7dd6cde36a7e1ace3862a9f57bf40aa22c806f795925c09a8247bbd0900db67fe1498fe4410d159246438ba58c544b5dd8bc66bd28bd6e78e6af98862f1b22daee4a76d39e70debe3aa3585b9a27680131a47d24d890122bdd94ace984861620d2ab5a14b865f14b77370adaa91cb14d5e632778b9fc6b2b491da0a9a10b472a7fb751cabd3e7da543eb90c0d4568c4cb95344283e1c7e151470efcaf204c92160b230c35d48744bff0d10cf806b094e41aafb4fc168fc638298344f43d55045304a6c53ad59316a6d073362f1176f074d481687a39a2ac2323c99e88a85e39874da466fbc6c969258f20cd89d55eb48a0fcb3d1c8e3eebf63a5ad1406879ae6c4e3a12399801a3c3e6e2ef86dbb4353de1dc1f4369a9b80503ada6bcb4d49375f96c2e8281deb69034f95a4c77b017f26835f81508ebd36398d9454cfd729ebc69ea17f83666cb5b5700e62a5034a4efde9b13a189aed1a2e2bcf750c5faff2768a9552c15240d2163ee411da2090f83350af2b32c0dd277449e46612ea3442a6b57ee24faa719b81f65cf8891c438d3f4af977ab84fe6e0e866b8e30cf8fc568e81a854fc7281a59f3f741b954efa2837757032b9dd27657c274a80add88917cd62f5fc8440931f9052791be36d42428ff87b185812edfb1d790c3329111ae07dcc47cfffe3111bf375529fff1b2296e5ae5e08febaab550ad1447574bc6ac5231118e04d8b457d66fb96805d399f5701eee74da1aeb2d2eadc99a2d52722e5ecc98990beaf5b1d302aa7d22270800479a9c70a643b85cb1ecc70c686acd64bc1904680cc1a3c8abd306150dc67b3c082477a2fdf42ea0cb5b94360635c7bf37480db78b82d78d876df819d3cc1e7c9c612d8d72d9262a36d093776da32f9ec9b96e85f5557c61ae47f7a649915dc886f245405e93d2cdd9ea9e39144f8bdb8f0692d95ae038b899d5eca2caccf01674461bab4fa85e983f2d8525da7c449ffffb96289560893535f183fd7531638aa4e71e1d5c57ceb7a76f69f70e458eb6e21d7d9c4008a68d90514dbcd710d87e670d3b03f598527e4202b6d2171bbe2234e1c8e0179ff48aba431b5b13a822f10708473a107f1188fd1b5c027d5759bea57fde9506e55401236a3379b9f0ad58a0f0694f491a277aa71c18b822c9aa2c9168baf41e83d7e2cd040154dbd6643c71f8288322627f86c915bf43bd1f5977be916f05ea9f978ef5288d092c40ff574f2aed6eab1aeff17d08e2b47162a1df3b605fc4bd845eb6dc63a02d58c957a357c3c658b98226a88b963751267cf91de2b2053b17359ed0cc2bde4c8a89daceca79e4f1ad5b5b0459ee277ad607b4a6386ab496a3217de096b742fd4b7144e113cb179749195ba31ffd6e6305aa4ab89bd3534076eaff820efd12c609d4d4e7f83319454d417bece7ff2a6f569d7833b2d11087c9b80ef1d4d39489ebd5ada9cb0d4670199f29a71ddb07b9d63b19669f07e07531f91b44d9559e0275f6c8386ee3e909aaa958c1e291df446510bfef9ee450e52407642b1c707524e5ebe8c2afae2db7e0c5bb2d602479e7ed616f21c7ba6be640926170318f3154abd90dc37bec0d2fe0784963f523c2e1710343f431b9d04eeb3b46905d15984bade6189fdc676fcf31ec8ba62dbd73d723d1fd9381bd94f91fa0066dc5ce52c2c4dcf18cc521cc75b980d61280b198cc321b8dfff44ec73516f3183a2929c9ddbd7756b3306707f8fc2c22e0b2d056e93e214680c15ac97d08b7cf95bc4f24f1499367c885b0dd08fc1011b572507507e017d1dc4efca84b1ecef24740a6b5f564fd6d484915621adee400322914be08384b0261c919227274529861a5443a168eeede5a12d91c20bc07a01624c194a590c87a97ea3a6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
