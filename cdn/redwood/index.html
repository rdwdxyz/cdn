<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"48d7bb653cd47f1274b8eb1efab9eaf99441f59c7e13287fd2f55c2f25c2c1d1d3d51fb298faeb768f09fa7932fec23e30426ad376d2dcfb69ff38c763e293969932cb9d0a09f2bd3ce1251ccd2c3ea35b300dd79e77bd1ee799c27ac83e84f48b6c10dd25290337694dba1516f2a67eb87a2d305449c0a3037372ccca5b13cb80dd1b8aed200865d601a6bd1c5ff28f6d9208ec42cc4248f7fb2f185ffc3119d0c19d27c97f5cce0b51af4a31676f78d02fc97f267856f0fc6f497786b3b871cfb77f8df4c32f754166726c1f7c4f64b049a110a5fb2d82503ae17702c37a017fef6de851cef7dc831999180208aca991224d66fd189e23a71e219da00dbf89c44e39ad388f64b8893c181cf8fbd31eb2ea935150d7c72eb39cf4a4d75b3638a0773a815d52ca3c08aba26bd52d235478007b4a80dcab8999a2b21517d5633b7e3be0115c5e7a9924be1d6085c125d32285552c8c3c3587b5180e5ecb9828bfbbe04258470a39be0ff3f5122c580fe2b58a469eced472abdc0c09649d5277c2857a385bcd8f0ff698203e14a4023dc9d9658ff52b93bf91a5eba2bb47bccd0e6bc01f699240c858e98bf772b380f997a2088da8daa2fcab18b03fccc0c3913c3a40478ad3aa1c18729250211ca79e3e3df2cfaf59f9f1622021b92793e352fcc1495c77d2d634b850ac62eb0aeb28e988158261d5b94fca301bdf09455dbdac5ab7771be9caae8f5cd1369a3325442b3a1f2bffe78e8d982e6726e68307271d69caefce3ef91cad639b2b529ea1f47f5083c065292eb5702c0a34f5df823799ef6254c2fe5fe283e2d2b3d000cd6f1e016f7257acf192098212fb4433c90eab3e3f94c3dbcae40abfb0b9b5a26fffd24da5db4bb20b3807296a8b7809cb07d6f9692699398489e15833f230e4a1fe6efd11c4904f6709f61ae8a8ea925ed46540904be4b3ac8e9176538332f27f4a210f579d3eda57c77990e4f10ce3501b6973e501920392ddf09aa71432f82be310d6ef3de4a6f49d6eafd9a13c9e230bbce0c6c135c229dc17e6aebbdf7cd1c7ac10d0c1c61b13bae508f45d8cafa6ed5aed05e66fa64a30ca9cc96ef52082a9735cd838b0159548b43afbf391098592ef042f13b98876ce3867abc60a26cb5c1a7ca182fa86884cd4a3e21455dc02af560f3fc8e1a0dcbce3aaf56fd7b85745812110a92a4f7e0e529f72d4c9f02e687800e673dd248367dd61fa623e7a863f7e8223ac31d7f12bdab2d87c919b6647754558eed8ea5829f1dc9b0458c902cdfb3901ad25ce1e77d96cde73e307fdb4b43f8635c21385b7076cd92163122b30e4b173d4b0ae08b52f0b8f859bf87053ae2d9e465074afaa2a6d491ba189f1f259e7413cc2c8716b5dc3745419ef2b07c0f0bf626b06e4d7b910cf16bf8aa7dc291665d430ddb4df20c806767b4f8a25d3612884c6ea2cb68cc74dda320a955f4134f7ec286ae8258c0c06df8fb9b3340326a5e00ba173e737a9d8e03a83d870667fe4119bb0a8595f1ce528768693f919d828a2061ef94680f673834d3a6ee287839976ffd9339ff71aee52ddd47f07805b2c1b384dc096a60c910dae993a5d6c995eca2abd8fbe70456d727d13470aae600cf9879590c5f136f26069c85d605a1f6cf4e43acdc88c71229e2add332e168d04f0232e8f20e10c38134d9c5dd4db91afaee47af5c4e02cb872f5bde8ad3ae159349a3d132f3ba6aa1a547ac491720a206573542e3438df22ed8008de1985c14d46d61a5eb72f95673f88bc4701650e4829b7c1ab19c75fd5c20b9c05f726998642845d15f490633fb802f4b5f148c0e9867a41c3930aa77a7e1a829efc099faffdcda8bb40e8b1b82188be999e0446cfa690fa1a9634c107bd420ba4830165f3f5ba4de7a2b101a044cc976bd39488a063023d9830c97a09af53eb5c225b447013e3c7168982e4427a91b984fbf7af931ef70ed303ddda682297d1045adbcc576e93ef5520552d4722c8caeee147b986eaee0d54c51f79ae206e82eebcbf39515a7d93d3269dba2896aed5a92be55d72555ac0fff2c1efa2eccfc5f2b2111cfaba7ab56a627fffa91f35458df72c6a7ed146963bb5efe7f194e67c448283a2bd0b84479a3c3036151b2f88c7beadea07561cadff98bdd429a2fa767434d0894299f3a317c748c845b244bec5055f2e31f33b750c8122767372b0f57717ddc3577b9bb3e05bcee6cb1b3a023f0996f44b1633aa5a73d1b57853d297d81d75d6eddabf9881bc79df4706968513a658a62942876a0510fcd0694fc67956da16197bead75c545842ab721371a6971e55fb44c8829470dc1a8c6cf595c13fc74466f14743d7018fee36a161d0ed6171cf202397bebd4a47948e8df8faaf621059af83197ee6aa6c3cd7b16eadbebf1a0e2de210aad39c7a94400bab51c08e4f8ce641cf6942cef9125ce0c36e947c6ca311644015dbdeea115833f2c24c7dad33d561abac7c4c086cb73dd092ea0436d0bd14dd237c65d1a913ffe22d924d82263228822c954e88fe6706e7e7d3e01d93bc54636b0413a69fa6e1f3c63b0e6a299289974f40a1d1d36186270f8c3c3c08822b9ef6b8c382e4c7c1547a2776c6f86f82cc6d94baf4e483aac11755bb0819e9e79a8e1b91b88447a3411d70201e5c703a07ca69186456b65a54efae4e20e14509990bcb4a85076d3fdc8c7ca71f18e7c0b58077fd871cc2f2a67841610bb6609c2e64afe6f05129185f833b08351dc9c90f3911f899250108175dd3f0eca7d22a8d11958867718cb773c9aa7a85c4bf44be3b10f7ff04d71c33d80f56e84aa17f15b8877c9ce2329c1e921201fc6312d3c8da5fb210a6370785fd482f82b957ba0520c9d37cbafb8eb1d6d8a4563b736cc3195fcb781051c8aefa417ffedccaf72ee486c0df54cf482ee36c4e258c3a4f9a4734ba61473c4eea0e3179a5dda5909b06d690be13141a7e92a5cfce0457fcd4ca416fa32d994b508e8116e010ceaebdf3a1604f9248fa02e6f484a5d0afd78d95ec362991d8b3b5aac7c7e0caa8ad78f6b6dd582f0afc74d6f38620f240f957b2f6675b45146dd410a85056d1330f50fc227b0de00f3e5367af5f420dd08ea5c83871d5c7c36c37b573c43607555a8f692d5bb4a22f0a1853c6b0a2c82df20d4ac4c398bd9821f9bd0af7443d29f5804cc0ae901337a3996a647f6cec0fbd0baf7500cea59b55ad81d3acfde42918a233b9c8c0a315f278d30ad88b1f7fe46d0aa74da5c4629d4ba9051e2bdd9e312e0ab936d36232e07d752f7de22eeccd2291dfcf634580914f19265e1146475d912a23825397159c35141703f76028c35b6ff8329b5f8e6eb4406c211b67f86f5acf400d145b8144b7eeaa0374748c6a3daad8c405bfef77014a82ae6b86aa882457495a26737b37af9888e2c4d9f861dfd116d45734c38897cffee0b8b170fd6be61eb6c360c383ef2b99ce0ed71f99f4e99d2b98218240a6e810713b68f6400147faf91fc9b29c459ce9c813f5afef80fda71c683b84f89654a25f6c63be8b6fa2c65700185619e6175fecb18ed7d666385a5d67596d20ed80ddbb05e06956f145955e37e02dc2b799e38812c9cb855bb22d0af43d1ee10359bad7140277402f00590d50b3adc98f6e5534f458d02440974f292055f72fe2a4f64a7df8a4fb2923d64ff6364c7849d6ad540572ca95b05bb5177bb8f4202da33105c4ccdb2a732e97e17a6076ae74490d9001bd970e243150f16a8a5022dbac1f02b96ac8ab1dc32b808c07da1e376c6391e9dfc816c55be00b13037fee6677b8986469fae30e07a01fba12dc96c93454781c813180c759e4828fe142165e9b88dbd29e7010b5e3b64532ae32d89375e11caeee904f93cfbfcf065c91794ac6bbe7c2cceaf8b5f06d90eec65abf4309a8ccca69705489bed3eb1839b1381d3b070221ce9300d28d02cafcee9b71d4a3806bf683a9895c90741d5c53af3b6985684f46a667f55da0817af0b5c77a5e49631ae54dfd1943665fe63760d9f2771268aa033749ffd05f34f4046dfb2a57bfa783629c849f9522a59f89588715ffaeebbc6caad39522f89ed57f94fe453344fcc3796b5866996bc7d23f871bf6b18923a2c068c9d0a760eec49028abfacf97ce0420c7795db81676333f4e01932ee0f0822151dbe77ce17343c9c11187b0ad9d6afa73e9593598867f051ba66eba097fd7d7f2f0175816084b832598860c1844d539e0bfdfbfe8bb2319ad064ed412036333304d5d3863fca96601d51d03fa76e16a92c01c59e329f51bee8634ed4ccceb1587fe6464a11b62eae5580ad127e447f969bd9fe8e5f6b09c366bab81f7f194d6725bef1d33da5f3e3b991be8ac5931320397324fd5d8627c5803b186df184bbff69018fb0ff457dc543e2630e535321944d4a2e5e96c07978df9ba8f097eedf835a70dea35f375b88b5de0b3bf91f0f346450eb36200f19032cebe4f92915067481591c55d995c0bd8af5e0f02f05c68c02c33c4ddd8f18cb545b12d8c7047496f8dae69881e67cd33b6b674151b1b9ff82c0fad4f709937b3581b79d50f1b9468b07c1e6bf012d7c1cbabe6f716f79fa5e80c53d298131c8e183cef6a8e8c1ce96e132f89c38d44708c6bd4574b47cc68c41210a9a293af14c9f78025e0230079e8252865e223b4758b4dce2e4b1a744730f5ebfd4e560f07222858c6ac09e84f822907ef84594770b48ffa0e8ac1b03b7daa967099e7ee994ebae4f032bd338c64e462e55bde08f569e9157aa80725f47ecff92354e9decda983c640640ac1118f0a002d59eaf75435495f0a8794a6ceb722d36149cc5dae9ff937665e2d1bb0c7f616e4dce560d64584080d87ca4171a296dfd18db15808d6bff6fc01d9575526a7c10d4000299543821bc5045d926320937d4436a3f677a8c724bd30f53978aad0307e1eb922fc2ba8bf7eb38913561243d437d14099bd7e6d26ec7689767e9b0cd69cc845763f29a8df1aea81d449e8c762b99ec833d1c96aad2d765956dd46d36a17bfd9ce4f3c10240695f5bd38c6bc2f2c1b009cf6958020b335ca7e57818b1c4af20b72b6521b7335cb5bc62681e354dfb58d596bf0fa55196a578b0aa6d62684b3fa599ab33d8270dfadba82a28c1f73e2056c765d37d9c324ee4a6715b378d0281b18024bcd800e5d88f12c14d4e803f6cce73f1266b3fa66a2e867c559865e3d72e28448133bf62a6faea4db09035ed071c982371ffffa838c495ce3c939d90c37a8774befa35c3292d071745f4adec99060f0ac95fbe9947ff19e783a46d62626d5864160dea2bac5829f462530c3c340efe500d1e36abc4471cd4efc1d79cf58372c06318ad8c7da6de0b2ea72c2f638e79260d706558e3a3e237af850a532082f2129228857a061bdbda245b9ea4036a2c717448ac2188bf1e03a800c84fa9892b8b8bc02e898075f7e11139e8c77e29f078b9a216491edca3e0499108a7d89f95e8c1664e5f400ebac3f0e43ef5403f725906cb9704e497d199f37887b88f2e764748591b2a69183f45d27e177696350f1ffbb2d2041361fb4a9906a00725d38f5fc8552acbd9fc1a760dfcd3081aef87919fa4dca34ab09058b2960adefe1d1e45c6cf033ab59dfc38e6399cb5b2849178f6df8963e07d2c296738b7a45dc2a2c034bea69a74be8658909b47aa361cfeb12ca3141d698394e10444effbec35ccec56d56d462ab101d20aae54ae1595a8a3b5df31ea9f8908fd55c8f97a707a31f80a3a0f90cc1d903b8fafbc93d2ae4af1edc940f2ba939855b1c9da712d4841effa64b850f2b44b879f0363e5dd3b3c0c510b2265969b34379e228ec52b4ca5489ed702a037682f414d0a959d61896345b08726f25cb38787ceec9a388f8d0377c70030f46d9ef1233a3cd96c1e70d2b14ef1d81c4d64b4e267ee59a0ccb5f3831bc39f201277712dc40ee4853a2398c275616f680d9def35dcde4129426db9e7ad87d577c4b82684cb33c46f9af5de5206ded1530c789b8fd126aa5e64be8194f3d95eeaf0f9639fcf050605d01de876b907eb9fd8ac66831657f4b8a2f0883e04b32904340c60e2ae414bb580db8b3a0c4abcf5b8b3f664c6fbe8efb619b56c1e8051f7431da5c09907a83e00af10917d6e7f9bbfadc994af435a6337699bf2a03519070205b1583fb112caa85fb886508ed78e703f2456e7a2f40fe9743983d1541294e6ff815d4c229bcadc7a6a226603edf967b83b914501a73dc84c50b44e86fe0035ee45efd83dbc334d8a59db1a248056e6a13dc23404588b6a8aaef01a6d9b3737c7ef07a36a8e76803bcd4f25de37bd4d4eee2190714ea0f3d52343f1228cff94a6d9140cda7be13f059eb011fe7e31e2d2e995211f91fb9894240b24f5e68698156cfe193d55a5ec6eb1e1b3c5ed2c297ecfce9925b313a8418808e19571cf52e23fc3d57fc0e8185544b57b1b4338dbdd21e92771dc94deb5725f05ba570b368e350cf71168b8c5efef8c00ea68cbcc1cb1101842818a1fb423ee525ffc173d02530015dd74910ae7e54afa9b55b71d45f6aceffa20ef4ecef5f4b283b1f1c37868afd439bf4bdc1a4f02084f839fb05e896fec05639115ad2b8f992b7f34cf628b6aec2973a0cf47158b8710cb18e6cd188260a13d8d253b232f737293dafda1c31e5fdbaf498b1715d1c3c16372b9dfc424ed5a3c38ef2cc328b282f70056337b00319a084e47ce42037a2e1a7c743befa67be24fe5e6ae683e9125900ed48380627944e1483db9ea1935db523e33f80867997d49ee0bc930a4323fb4b8090663cd0013ed22b41b11e19f5c01f1f3388d68e4279717e5a953b6a04d670b3d969a67cbd45974028bc32c78a12052035390f37af196040d2d01cb41da3ee1f603b6777cc394c4100fcebbbc00c93d71c59347acae2618dc26604aa35f761ea4bb867da18ef748402f05f4d66ec8d01620a02b8f034c5f7e83fb43f9240bf136f2463945733aef014950305aec6659fbe1f3945f87d17139e61fa3eded978e048da33ba4d7dc210294f9b5ff31681c6c1d2ac75fa19607b3b346572832cb2f2cba9f37b32d2634b026f8c6adf38f0b66706fa3eb9d7a04ab4b1bf2c1d1116094c38c1212a583efbfd9ab7b4bb6dbc981061aba5cb9917d00f983868a5c653e94e193c665f29dbfc7863770bb9cedbb50f2814faa913aa1972001b64a678d80fa979ea019bc5ece03f4022eba607ce354ce0789640545f3b9fced30553882adeba4c9c73d7c0017b33645726b32e78c340b09ec110063fd278fe5b22013c2d1a58f7f2fa2d480e45c826236d2b62bdfb8ed00b355a7d6f185bb2363992edcd24b8a4afa409713a6789ccb395ab2cae0ddaa13ae94f1e1a95dfd332ec223ddc326698832a562a764db3000dc20e01325e4954ba44bcc2496c95ba9c4bc65daa67781746550b5325c2029e3f05083d9c644d2600e46fa1289b2fe7f54eefa9aecb410e8196c0d7009b5af27adaeaa2291bb80ea24d4c80f5684c6dacec2c890544315dfddd192ed179f889f582ecbf11d7c5319a85d6e1b47ca1d05544ab1e28dbcf7be37566fd1917ebe4030bcc1a0406a0bff2092f6021ed4cd2b6a54c0bcc2d28b06c455588efbbfec591cf1869af92381976de2caba93afa46d61ad517358a2df44c5a82a01513d5aa1db2a83fc5381c6edee0ce401bd59723948e9a110a84f5ca637dc879144b55401efee0363b28a78098423599098f8f39f2f3b6f41ab3967082650ba561ce6d76ba9ed66095d69b07be896075533bbc111e13f0b76c57b0ce50aa990ee40656f67af104164cc715d0829180c60214754b94a2766ac26a2248924c322da7ea6b55d7eda97c4ab064c58b37108a93e9dbffaf65989d8b51c349edaaab12ce1e2c560448132584f13662e64d57242e3ea16c6c7bdaaba3ae19a77e1da38dbd209a50857879a6b176767f844b06bff849476e841d339eb137a0394cc20df3a1facf401c874c64412b9d6fbe23f1f2f057c01bfa7cc8b0a53189751f52510da98a0100de5402b798aabdc3bbfafdcfb1e56d703ef359da67a1550dff583000282f43d1557a9bc5272222746f963a16c1b7f60878301247f5478ea85deedb095edde1e396ed37305cb0f82ec13c34e08984154046432d274e3a938a6adfc38463ae4981e4fb8037b48542df3e5fc0fdb84df71e9f55ff6f3c669c83a1c14510728bafeed3661d6f4a1cfdc710ee9fe366aa5efe2d78c2621342074f284da6095885d6ed2f3d40ecda28d5423237b02d1e916fa575782446259f55aca018936c1f4e7cc366957890eee60868e24eef02c6e9260e9fdf786820751c5bb15b8a03fd6508fbf05eb10f4330558a0241b50eda7703404ccba7997d2c87c7a59b9b67ed80405ebb7316dba1f353051278461ae196cdd0e1caef00085e6252e1398c43d2a6f903a550aa8031c41dd7179bcaa4d4d11b1f9d75ab692ff3880be9103bba4e77cab2a2a2c23267652e86bc8482fee7d89314e5d943048da0ee4dbc1754788b64a6befd7f7d3ba148838cb5b4cee9dd64a1bb81ad4dbbca22efca8255c3fc3c6354b96cadcafea36adbd05c85a89603a87ddfd643c0f9d2d7fb1c44ce46760dd935c24b72bb3970a2306b91886a2caf12a1196fad2756d71aaf5001ddb48a9d9c5cc17314c0281afbc3166c244851207152f79d9226235c9fae3b8acec156027eec706a5c1d2615a3ebc5cadd9596d70aff2cd09019670d8bd7adc4016d2e7b58c5c84f79b7fbd2f6b7a7c5f096d81b60e49140b84aa311de4ca89c18722dd53b9d616a0c82a1b8296f75595acb212fa25e8152cf025c51249c251e1abe47b8f25e46aa1f2b51e4e9e90b354780414869ce1e50a7fd0af6c3056211e801d6f09b0171d404a9da0a27813a5d2c18473899ea40a9a3083ec538d0ac051f936546dd3b7dde061be15842c21c5fb7fe4a8be06a1bb3f8db19b7c91dbba7370fa01e0364ef361c75936ff273e5bb9dea9f5f8bbb06c4d936f595e3f6013b9d4ea94214724cf82c2731c9cb2f717b4e57b164863b61dc42c457e9b1b82a9ce9ecd16bdc62d8f99e5ee32a963861aa5da84d764fb3d771585f4f5c750faef06031890a307079b376fd3e1fefe49b8d42abdbc9629d5aa80a4ccbe9f000343522ef7f11f3c7a03614f824c472eb8841a30b83af7e5942be4eee3f3f70022c9f60e60f0289b5f795abba8cdc0d9dab1cdb3e7be7a09046fc7222c9d1d8ae51783a840957d59e2315d08f268e529347fb15767128085beb65d1027c7db4fe755c1e805c69a311233251f20adaf3b8e77b9fd5393ed4bf59aaf73be49fd223991586f8d10a5ae60747b037a9146c47a8006da0a5f9409f43a187a1b8308ffb25a2d1f7218a6e03ce9cebaaf6988b16b8380c568e5bccf5642a011c3301eea5d9d5ee9c5d56c94f802abaea89c24e99cea6c8ef71e38ddb2386d9efc280e6baac56ce058d75dfa47f5a3668ac8d2d74a1c4dcf577fa276dddd9c06ec25688d99cd45ec8540d30ba65456bfcd16ac350f4aa04f152b55745bd2a79748c8973990ca98f16255ae57426a29dac0de8855737abd0e579d37b4bbe349f74e8e92babd86b8cec0746dac0232b986357dd0c4867ff2b009595abd215b7ab2180bd2147af503d59d65a9e337a4f8af041e17cb408d80a6f4435bfc64be8048822d9176f9c8b26ec0bb76d314d69157ae2d4f44c5418e74ef0e0e09c71673114597ad259ee3f75481d5093c3bcc5de2ea607d724f622ccbc70421efe60bbe9fde557c432e1073ab909bdc01450b7a6dba6b2c50f3087dfb4e705ad46c9e44e0fd6260cd0087788383424bdf8ab150f66dffd299244db82f0f495f5e057ae50003b70c97efabe936ad360817003827b39447aa5e5eb31fc87fdcd6bcf9e9891cd81148748f628b0309ed7b0afea1063f56b8b6da4a1da46e5fc6c8828fc6adfb68c14111573842ce61d2656e0f2e73b5b9d07ada51cc38615b297dd237605e77ee452d28124a8296f5732b95fa6e892de1a3878a292296f553408449421cc25e89b08842c75c7cd366013e88c97db683de64a29e0e380f61cae64cc660893cb27a2f68fdb01473c7f067ac3e92bb7a9568896cce1d06aa7ef82a81340aaa57c1ffe00c371762efa238787314ed0fd169a6ce8f9149ab6fab1fc77e2980fff3a91120ddf100836d5c4ce4a630383bd41d589af0802a3a6678ae9b20418efa5e2c9db726eb4d7df0a295e9e59ee0a4b7dd5c855b02635cf8c0d397cf42935d564358e14140ec849758a57ff89ceaf3e579fa6eb269f3e26a7bd45aa571ac31e0174c60883e560a23eb5f6ca9bc6262cd10adde3f9afc307a13262d09c942a44c95acef8e6087ff786b8057026912c667c0cc8e081a40456815a7f49b5525d70905113ccfe71c15e7aa812a60f446d6873d7bc26a506c3fa832d0f46054672fdabdc8d81601cd430524d6b3097d495579455f6565f9eb3d4c4eaa98421ac40216ae27a9a8019b8ebbec002bdcc7ab5fdc6e13df80d327c040bb7375f23d4aed9602d13d7fed1fca570972cb8f954c5c2eacc300fa7c3e3329ec6e9c1fc0d8bad057df171d0a4890f86664da188bf89e3ac2213af8e5f968bc031aa5d8769f570d79f5be7d149775ca6ca6036309d7e228dac80a7546c4313fb92e81dea827092367299a4c89ac4290335a78d3908562b3f53c773b187c7d48003d5d9117c823adc80b3839a1931b88b8aa6f155f086397f14433154394dfd37fd2d741dde967227d0417d4b14b91fde502a1ca512f7b4a3f5a257edf3187dc418a3d69ee330d94e515cf3b1b0a107264cb4ccafb00a4d41cd9d5eb928fc719466186356f97cba237cdf2a3bce999edac62290ec40c2d4a2ee45df7d5d0355a5b9d57f29b3c08cd69cd20990725c23d8232d238f59f36c3f5e59b6ee79480f9dbfdea750a2ad3532fd516c629c64b8899adad0950fec7bbd4f3642ca212c915ff34724b7f43c8bfd80c0fbd8945582b067f0cc4461b57b9accba1596e70a7a080b7f4c096ababcb3cda822fb3727a40177ce5a9fb870abe2efd7c4ed577475fa530ef97c6a9d8d301f70967b974c7247a3ce78e0c12d48903a3a0b51653743a7483ef1c7ac81927b2252cc2d6f69ca0bd5a5cf125f5ecc7fb71e645362409f4f49c071684202cb9381b1eacd84dcfbbc7ba8a69ca65756b4f5f3135fbc79bfa9df12609684624c0a72dd3be1abc8ad185e207294412a9c25bc9921762776a0d271f1b38f281c3b6f40c6e2e796f1b5e8bc79a0114f468768c42fc8672fe4e6c9ec45f44178bcf16a90f65a50ad14bda9dbfbbd73ee9e7ef82c77254aa7f3e40785d27ca8813831cd8d8445f41f0f3b14b565b260007efc2873a3157a9c1dc399df2a44013f84183176d6708106e31bf9be7f764a97e711c927d83c0e1335febf338511335e902a5f817b1e69ae34d2a805d3f463ff563e038acaf8412268e729669ee179c0fcf712cfe11e5db5a3333864b05b12bdd66912817feaf950459316428c6c489bed4dc52e36ecaec5e5216de7e9330c831defe3438a476e7862750b8e4a7529fe23b2b77aaaab252edba12a23c3f948c2f482d195df82197b40a426c6059dd6b4a14d2cb1f384d93568e403f1c36f8495d4fb7939e01cab2a1ac96999a554351ab11268ae34414da4fbbf7bfdd739a1593538a8bec87eeda2d2c549dba6c7ae360060e5e4097a40141357b29d3068ce91068fd57a525605ce018e7a0233bfb7661cf117e58df21d937f825de3c7d103f38c08ca0dfd78ef5db9785dff0b7416deceee257377bc1ed3f410973104a8649912fa1bd98176d9c0c90f20385cf36c65716e6386cef9b505f952e824fdd5243a179de6685d5c8d40f4fcc9c5b796e1302db6977e4a433b3b74a91124cfd2fa9881c1512c272b8f03eddb29cc4121d4b07833f6395206ab8c6a7cd8feafb5db8bbdb6b622d4c7271b78f4b7944c04b3ab73d8d256aaf39752ea13e9022729377a7342b7d84dbea03c7d9f52782a43ec534ece1641f0106552a7a3bd79a4753f99b73725bd986bcb4578046d2cc9ddaa6e8e3321ffb638ea62dcd2c3c04e94bfc216bd5a9ba20034c2c44d5e514482e2faefe48627c53f56672265db99231c6871d9223fdb65a605dcd83e734b74b9d8a05293a6d8ee406d053eacb5131dbf87fe9b496efbf7bccfe8b565693682184b78b8193f315e2033def15eaa2fcd1c8dc8ecb2ad7b97e4c2f747fc6d5932dfb1abc52f7a83121b3714cf7fcfc24bffc0bf8edfea41e8fcf165b45e56351fca474c98a2ea67ca5d175560f2165450538f5de1088246f31aa63970f501842762c67c3063f2003f01f5d825359395dbc7c09f82e21aef103d43fc1c1784941d86bfacad2a667b36abb4bee4d6bb5a815b297390943c898414af75886ab1f72b2f474b49a7ef693462e0cfb112e859dc07e3e45da2eb00f935401f367c6843413365ebe8bc14936d38f88b2258036e5a79d0be444919c76cd9155076ea468072f1b242a8ee71daeb0f335644e616a46d7ba48f0955446b1d20eb902270ae1c4a567efe9dc2da0d2b946da07e13780694806e70c0e64b7464d86cef4cecdab3c0ede799f26a918e65ccec1179437cc50bad9f6b4123ec3207c7c50683856695998356fa8030df76e557d64a5322d28c5b2ecd442199acc0054a88fbba151dfa92fa7d096fdfd510c07c326e35492b3ade2a53c39085762f09b53c39674a6ed8e46cb09d38d4ad488604fee4f95918601177a0333cb3a49562eb1fedb5c35a64287620cde7b98fdd57b3aaaa329e4830920c672b5b03d946e5dbc741c86be03c6b3584891ae3b811b11afcdb819a1e510749222c518271e6f2eca5c0cfb927fc2cf39baae09306ff1d24c798e8139906cac91deeeea6cb23bf331121649f29c9b5f68e82e005d6aea7a0cbb15fbb4cf95565fc64b0370bbbe9f13a479746463cf51a8f6a97cbd1ac9dcdbae8ab8ab8927873572e2044105dd3533dba9f2f0beab5df3f3bc7ba4c35a925c5eac9a77d1fdc05b3f976883d22dd198c5dbacf12c6d4f41123e7ab8787d627b8ea87a757667fe1bb94ba2fc76b79c69c00e4508c0b18324f218bc82ee71dd97bdacd9c0ef1a7d74f2e8323fc04587ba0a2a70b5ac9a17deca150aa3f50b8cd55912711faa5669423a002baa87345bd51e0889e37598c3ba90e8b19570af1b733464caf18421e61b4fdd2ab31c5ae86a3a06a6b97ff0db3e4cb1324ba18be42d07636ce25ef496ceeac37f156f1f8dabc81256ecf79ebe3f24c81e9a6d5f65f506495ad8002f9a08e5f3330a9d6ab1fa2e12efb55696c1b1a2a7d4cbe4080fdf7e9f954ea51f356131a95580dec07b4aaf3b87e32b4d73605c6ec3a76d2c23cc4e32c750cd774288cf6564d6357190aa223735f85991f0d6b5a91b02746d48d52e2aa7abb1c99e3799e6bb47a0773c9c2c652f4e841f31449692f7bcefdc54f6b3a907abd3e5f42f33e83f5acb9d1e3c5480596a3ef9e6cefbc1008390bc339cacf41acf85300dd267d043bf5fde57b731096a0a8d9c3920afa6424264b57fca4f2873f3c79396095682cc768a616d4d9e3eadf3f42f1b4e95e6d9532a2e044ff8f4a0fdba35a9510d43c5fc2f999f83f4f807312759f3d1103ef4c234b3b3ca22c7c468537ba9a91c3fb0ed50de730e57c4de25ef79d80a479da34956dd6340fc29b0bbc32864c584516ecf40b644b70e8fe32711045dc0461661f6de0a37f75b865113f8d8dab845a3f64b58edbd379dccba3aa781543d66d2dbfe1c509a10c53a1f3a1fe19ba54297042e621a701ce5a1aeef258d49afb9960b715e91a715a7841aa10a3a83eaa1d35f7b4a7f98b8c91469f7ef124fee404ba52c6df9cf3ce62e9cf88fea2fc417a22e57e9d5074e469b826077a4afafea5a14a6fbddfb9dc1a56a99a066a01206e172b0bcd742ab619d9de7dd7b235f48a762c7985b11534821136f224b94f0d1609c48a00895f9d73c9207972078b1b5d7739663c3095a2f8ad6ba856ef67b002cc780cca6550e7c4080ce82f66eaf5a1ccccced3b1505cc9c7814202028842aa4ec6507fbf55bd40f8fbe1fb01cf7da492c5db5785cb0b0a31d0576b79ab31c693e1e260909871f8319480c3307a7600248d7f97205e5078c3de01fa815a4b5d46d26cf83d04ce99626bda625c497ba1505f518d5c74771f6b89d26f267cee67f53b18e8f1bbb0c4c3436f88495d4d1bbc26e2e95278d0da7b840f4b7453941ab600ad1457e34e6299b2d6fa9a8fb3162f31d97a36588ff47f5fafbcee47bbb72efd0e00686023347339f64b67673e8e366432d6d81fee81aa5c96d9a5d3ca46f326be58f4197e2e9f79dc589c7a51da192165c6384351d2e03dfce294bbb380ccc9b13b517f8a6f17c48782a2da1770cb2f4bfd15cd752829cf176a2211f265898dde27c40f25423e9047821180df57ccc90763db92cd6e7f07f2cf65f0e30a08b56435abf2d4318c6d0d22d6260114a116b3ff2e846190f721233ff146c35ec0a27a6e588e32633ed2821c1442bce3dbdc3eed4db774faef767dde41b39e27869007000ccf5144c6e19b038e88101799248b67d135d855f068333d24180e8dbef44575276e40ce9037663155fac058e08eaa30a0e357332300d4b489fa063203d1ea4318b1ee11d536c69a5fe388a8de176e05d97d5353d0be962166170d4e4c2adc5d55fde24387601875b38df1dc0f5088d9680c29a986c9c36da009e33294dfbcd3f718f9184becfbc90adb8e18fb3f3fab0074fe61a89df18bc29a21fd76fb9e10714c0d59ce5839af8ab1c8db560199ad9f2459fef59ab355ef9b1f3812f7a1387d2bc532834162abc85228a75b7d3b23fee7a4c5ec138275cfd44f519f0f57f5a479149b10996df2f1b2f5ed414a69aebfaa48895783cd36e0e29db218f86ae1e68e191b02906a2c8450041f007c3e9243d5564658cbd6ed9b5b5750766d0157766136df18a496c6a10e8e6b1fd01d3b91bab013a1bfe59c6b9efc7c98766d0fa5bd5d29d658","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
