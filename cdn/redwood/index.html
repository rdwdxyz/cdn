<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5d19a2d2fb8e5b85e7004910bea267ea29aa68c88cd5496bcc1d4eb3cb22d04fde9174fc36570a7eb7dcf5b87f01976d3c72aaed16e9a25d3a508d064da1649b0b517c2788df0f088366d16a08b92b631d3e987d488a45a3861815a6b13a72d7f9530a3a6e78a0fdb5a21ba622382cc272f191ac6a367ec329ef4b1e130741eac88e0f4b668bd7a2a7cd69f8284b6da384e6c2da6793643c69389a567f1197adc30eeb520baf7e980a9007d2934d2bf46d84179851b519dbff390bed925865823e0161422640e9651267115e390d713d200ff04de67abcba47decf73c0f31363f45129be07f4220e126a7c1789d36a02b971a6532693dba311c0cf85934f691a9ea2b60a387c9ed79f17ce6ace0bf16754cb5e047c0cc8da2a069d222b02d84d4656b121c540d5d683a6f5b40f82f36c2a1cb97c3c0f55c729f10598b1ae423417315a288f35b63e520a7f139fa558b5a1fdc842538cd78822d34456de4bb6743e82ed31555c661c07360dd7bdebf6487d08ef3ec00432664e407966753877bbded419daf091611bca75b29f3ea4a8e1e6c3c0dab9edab5612304afa4ad1807d446d000ad49652a90526caf43d29459dc691815a942add8953c72fe21927058dcee74dbbde4d4ac72e606bf3c05ff18305a27b306dd45a9cd1212caea5005bb05d78d615bda787eb448b9c8b2b4ee369ad1fc3bfe7fc01091b765ffa94c0ca4184e411d9ca40e1775d57e2c1b5a18c28d16282a261768858f0268bf9a0a7880b8dc522e7659daed5870e59ee2fbd46b06b93734dbb464c4ed986b2b4b502c23b9c5450a2e78f00eb2361a499703542f3ce1611cb2565878a6350c16f657b27ed593b6373fe6af84f5150588cf75cd1163b38c73ca66d8f149349e31b50c0c8101606c173dfc50a97a198595e0511bb70361ac7d1e0d39ce32bddc1461f4ba0bf289d87802a3a7c770d45840dd1f49c380864894aa6eb1a58ff405814c314ebcb80038e2fc04cbcf2872bf676fd1fb30d9bff984484461da252427d7eeb16fa35bd2a3a0f3b5156b485784e87d6500370bbfd1e4187216048c67ffb2ccaeb335aa91010b407aae448a11ff6108cf8ac1166988a8a288a437ee6a7b138706698d3261e566c63ad440613fcf00548053238f91fae64825ec31c95b9d2da3ff010d0f5a68a97d87b1f10ea66e458bc38969711d20b0c15ed044809d842f30f26a8f6c0cc8e98c97ddb107e7dc353d0eb7cad93bcc8aa7f023217ad36e6e8f19331f008d110d652d4021dafd5d76bc8ead3b54841ed00c9d4e2057163cde2ec29276a5bafa34216d23767024f07a2c1f647d63b27f491aea67f383407bb5c6810e43a9627afddd446e558cad59430be6a0d458abb4d9224b2eac42ba863162e2b506bf3707378596b69ac8e7176e538d6cddfb96e6f673ff7060b900a3716ff6bf26db59b4395acc2a549ef1bcf4feab95c6aeba02bad555fc7567d8147e92f117c60853f9f4d6b4566a7a0296c352ae835910c810a7fa7ebabc6bfa6de71e83fbd4e76fdf1bf859b74b669064064d71982752f6e03bfdf79eb49ab47aef861b2f7ee5ba680c977c477c1d39166914c8065942970aeb62eb2e1eb26c8cc87874add1f1ffeb561779d516e61b2f6dc90645a87dff80bfee95cb60c69545e45fe8c5822b7a5720d3c3a81e4064cc91df48460b631d5a2b1df72e335102a30ec3dfcabf469b6b18977bc586168bd5dcbadf62b7d1666f1e90de8d930c831b2851d12a0eb0bfddbcee2f1770010e4b4bd35bf8f16446ba4997b405507abb77e0961368c2851e9f9c8595c0d601b1616b94bfc410a6e8d35931200eb7eaca764987ccd5f8f9ac0d7139f32126704714b76e86d260c20133eee227c91541050cf53fb0174356351a64cbc43b509da4dbf42967f865fe79d2af93aac1f4645ca6a4d54c65b09eecab49844e04d6eb781291d56ddf0c630eb8087317d189cbbbdea0ca7eb72c59bc01fd7d0f7287ad574109c3e2f576f75d88cb17aacff645c3d3e81cef834684fa3ca6df91f054661edd35f7ceb1bcdbdd6a2ff9abe1f75c6187d7fefb410db298411b1adcdec754ce1311337b14f5fb250a055d42f7b30bde5bacc3692320752577d5285f77565fe342855bfae5549e5a4c84491f0b5e197ca7c265dadf580202938be49dc49feedb73d3c373c0c8caf4141f83c78d2bfd710af7375ade5161335ba5e1c237f7b440b5ebc8adb3aa9ae127e6fade1c2a7a4a52cd0ac85c73fe40c158a6dc0db980aa059f6ccc1d609a8dcd74959a7d4b10ee38c52814dbe050d4e45177185b5ae39845f5a19f32ac4afbfb875d1320ad7ec41a7c00bb6d72467b3bdf5ef0e4bd04acf566e0bdb2d54f72761c78b0aa649de5626d4e4eba493462b2780681f98695a0d1dd5654329eef61a51c1a06083d27d7ed20aa1b819c2f52c033ed5acf95907fae047f03b7435ba2473c42cbd196903b313ce575a40626cceb2ccbe280785c90458f2bbad6c5844a9d33c016c156e62dbb861ec8e32f67abe12a07eba7449e80019d1275359c8615d30325d6c9414f0556e47c236f4b511ffd63aeda7c587854f801ed5ff01cb660c15e807236e1dba9d579bcff5656154aa43b5fe6e417902f1a639eecaf871e506addf8963febe8f36cb8f5e9f742223adfea5d2562b6691eb6f0229c08fae111def8eeb3bf8008ebece28786564235e835883ad8ee0871aa9d74b60fe61b6db8a7c0fbf5e4f2f670fd0ff7c0fa958c7311600242a3a755d15a62ee5585795ba2fb973a3fdf6573e26355791f2b0b54b621a5bfc6bd36c0a365b93f22fb375c2b2880e34758d2c05ff753b546f79296172eb642e9b7ed1a2877ace78ef828cce14a6ea85c851f831d49acabbec6e0d952ff7376e1fafaedb45313006a0444e501d7bfa9d496da46b3d39908805b3b00609065f3e9417c6a69f28f86952fde454df63584170de88f40564b5b5fcbdf9c522c12110e69ad44555f79c8ba039d2a1ac366c796ca875e7cbeea0e362fe9d4e9abc7792283043b0413df5ae720bde90dd6d890b9a96433c1dce0a49a2d5aca98269c04e64e88d172518e5a5f22ffa1a5b41170f1fb9717687593fc0e8d339f46f7ae0d29de2d1542fe49e609eb14c24ba8a3992fc3fcc21867676b62be965a0c03fdb04de93ecf9da4a612d56578ada6e5b84359d75ea82000ddfcc822a6b9a940029407921e4ef582fd02a0c0e19338a0da531c371770c943c92bfed4dbe6a90340d43f6b2f09e2c363ea662e7925103b2892244b6a9669ee3efe17225c623715a83845246e4c3a571f965df7356517029fde352b78cd02e4b1e5aa6560a88d31b574d4e73c4f50123996bc681454debef2001663be23fa6137da6fa7f326d8232a12e044c158d3c8cbdc06c25358bf55e929ddb9a926a5b4e9f1ef110fd1810cbea392bc277b2d4deee59fcf2f2da34482c4c2d1c3ebb5cd5deaa6b7ff4b3012b251000b7de9ad83a320c685ce5e02c41582e653a2bcc5f86893413a59c75b49d62cbc5cf2ce4f7e945c90cb7e9c720f73f96c0a6083b56e82008d8be2aa6cca88724a3cd0e2a3be291936a39c48273d88fe739efda79cfcef4847d6282d932d8417a204b93d80ca44e3cf95789566098d1d61629a3e3f958e7199b14db0d9507a1fe8c2913efd4a7f2a61ff21610688b6c13795594f8206e5b000a262e45d96880f73cffa9da17eda6184df0d3923e60f260867f92f91d8c781e616a47c45ea874cc137879a5156967f1bf16c86579915fa32dc9ecb32ab797580d9beee274ec269bfaed123a885c226b9e63650b99d8218a973b9a65ff78af2fd8fd53d5c3bb67c1a4b046351acf583a9f336332201a12b371bf8cab1c9d651e50a30230473b29bdf249a98a1d57be45c7b33e8997790aadebf34cf31b44dca1b1f58727f6608c17ebd0ee4957d0a0c3970e2720e966922e684ab025ca8f6793295d1aac352ade2a72128a9478eeadc64c325191d66b70fd494f9c638b3a231f7084edab3efe1af3ad6012e6dd5aaa531b7e7326db06966fb990dcb4fe4070a73c5aa376c25f947b4e60a20da28af9d48db6efd637bef7749b06d4c4b8b2efb591499d030c3216502d2684411f220d9f2d715c0216dc4ee031f8bbf39d002e8d99d0466ea8e6e477ecebbe906c744dad3e9783674535e2cd3d551ef1d51863b0e9d600105a3a570a4dd6e2f1d751e42c3a29a74f98f4a8ac4ae781f9808a7661d527ee61b9d62ad6004d49047148d152113a39babebbcffd60ce6269ce87c826caa55826611eec95d55c7b52955573e1a17ad2252e75a5b7f432a649a4e833ef15eaa481c261d3b8a35fe86ebc1fb5605388111730fef611e12a08006aba6cacbac59401fc5d526a2a1fb620e1955572d8e0eb46e27734515cb1eece1f022e35e12f376a362151c11889f9c5d89e81b26343ecc3ecaf580abb498053d1d8b5725decee797235613d781626d830a6c04154827d3b8b627bfe0f9df65897d0690c79bb310d864d8656ecdae357ca04e05a4c9a66d1ca478f68dcff94557a7aef0589be625f2eb00789627f730bc86bb3a5b2b5e5376e1567c2b7bf2e97ff1c9951f39f0a934db2595c8795208295ee15f88eec3c3f9eb6bfe9711cdf4f3c5c2c8fcf7a07e5a3afc1a1a3f58121bc9b10c08e4c3e04429cb7036466a0937d2a6aaffd9504dcca49bde8d310fae35e8aa5dc156e138b100edf522e02a2e4a37f49eaf7925b4129d5023c18ceaa861505c8fdcbe77e2b8ebd0b72100ed44914a9e3633d61903148e55d73e8e56c648b549af6112511a8f43092e751aea745c70384f272b1f222a8c6b1217d41893e8c3dd4b02c7f4c8d1559e6b34fbde563dc2eeedc9ee9a66f4c19c1b1fbaa68f855e60fded43431eeb243c345b279af64be6033b0b4815de359387a728f9358dc01707d6a7e22752c616e1f435bcb763fc1a92c5beb5384f534a27de07386c259c99e0e4994614693b8daa89d26c8e4374c5af2dba1446eb179693b73e350ae5289c194e39e23e061c8cebbe8482338c4a637cad608a28b69e6a3058a02d3dec85de8db8778969cfe922e2840d5927b2dc50fe531415fa562969fbce76da0e986cd0f580c1a2549accb6c4b65858d53e78d7d99cd521fe0741cda4741af0bc88a6a17dfd0f8c99d16e97081c4dbe02ecb42cb647042c1544f604c7a6c14eb987c9f5df8269a9d47af50c30737a021ebdf71a384840a574543f23852eb971e3f950ede86b76bf5b5e46c711e2134090d70b50d22ce53b6344f2d65636530c9d04b07b476e1e501e53cc9c6b90a04aa76422b87d5418eb625f78e92c3a06cee0f9ceab7259d866536ebe1c8a612dcd72d8a1cd5cd9286503135f053a0660c4126e143aa6ea9b88cdeb947a2c0013c952fd8fa329bc34cd6edf7abe2071a5d202960238ccc34c1fe5a90b6ba4b841e8ba7b9d92a680a89b2c8d201ab98d03419025634de3f004d007fa2f7a08b90b6604af303aa77c52321ce35488e184ffff3bc79f0ac4d9b327ae4bbe8538d30c1cade33969445ca75b9424535839864906431ef9b0c1a61a15d051e7e4eef38ae4fb3a7f490bb05003a6e016ef0e409c1f5718f7953f883c72e0dc2b204ff7f97748db9e2123a39a153426157578030c6b756a36d1266c076af30e5476aa007d19af07abb2ca234a6b839cb433695f5f56c85175cfeab0dd67df87e689f0615cca8688ad0dcbdfd8d716176917ccbb165956c46843db5555633ca70ef13156a33613c12bd89211a6a8e3093f43254e42a3231c60e993026f53ccf9be4e7d3fb244924740bb58de7db4f2b503804249bc6fadc908f03c41d4e1c150a206eeec8094d60d381733328bab8f94e37b4e38d635a7baa5cb60335f697e8ffdad1476ed2e22e2120e8e353ae371bf91dc0b219813a409b0755d1035138824db4b1e6dd7498d2f98a29a4cc589b437b5e7e9569f254bdc375327bdace14a9abcdf7c4f5355e7628411cc02d495fd5d0806154016d2bdfff6c621773860f5515858a3474214510ddb8020381d2116d73ddc45780418fbbbdf596823d6db149d1ec81ab283b543b2bcc724984f814f5f21e59ae412355a917d6efea27a968312013743484c3997ca0ce00abecea477e3e71e0d59444be846224f9797f33a5bbf673691180124d2b554f5ab2e117b31d0a8da34f265f500039f63e85b06cd3bf9c8b9da7aca4b20cfc736474ea1a630fc9b59883fc8137509e4c93ca8b6f9770f605e901b307eba9ba9e1b548f6b1c6c8514ed1f7d7b3cc0a21f9c058e90b93c89a246f0dfb0a0dae71cc9d3326b3e2c293ecad0c4e3f0d62727ba69933790d9a3a0e58b394468ccd867826cb4424f1312ffc0ea5907ce6838b665c100ba66d4be3f547926d5ac8039fe3c6116dcab24e9d1061088b293cde7b15aff3b6f79d09e295e65fb621837c88f218a670ca8f0c1f90985e7e39715c53404696f4830d67da9d1e2e86277a2ab7af4ee204066c0ef481df6da6dadfaaa24a4c1b7215592a1059d9635c44a35937bed1978bff2462ae7f4236a957d00221bf80bcc961c421825de81cfb5a6a2276eea18ddf645b94405c0fecf39940e82e7b86f6c52d0f8fc116027adc4cc3dd64ce589e06756e3917b6229da391c87628370dcdbe2cf453981527aef640b359273d63f377c7c33e93224d9f12645f33f9908bc7897dcae46ebc00069f378940a9e0a8f36291d8803ad8abb23ed6744599e1184cf17b46b06aef31dd2fd8eb881a1400c4f184abdc4813d594ba0ab3ebd6ca78bddbb39f2decd4ddfa389a5d60ae55d4f09f9d54fac255a7b8168a323df68857913657d871077a43ba136eed7b2796fb92db5f6053d12797d3dbc55df5f587476b4a58615b0e0cccd4a1717ac4b62050ea64a3aa098314b400e25233fbd3b38bdd8783110a3523e11596d5c91e5447795871b0f3d066122c48dce7cb75a38821b9093df65429759166fb7a31b361ac9c75834fdf4851fdcbdfb9ab12caf8cef47aa4be30c6fa78bda0f050c6f8de79910d964d1632425f59d62ed7d141d0e19088d6f2ab22a07eed5ca155805ec549ba1d7ca3bc01c17ce74c978b85864f2b8bd7b51d42178d7ff6968e8ecc03bffbdbfe02f8e869ddd59fdcac9e85a547df42b76a01cf57e305ab6695c4e0a48177df5027887a3824be4470f910dc6b144e5b70c5a3ccf6027037df6464cf36b6e5f0c14af8d4ed49ba6de55514a08ac9cde4bf32848655c1fe0a4b43054c0140622ccd2b76158ab53743dd5c4ac19e70441928b7a6c70e7c51154f871320c09b0860f6e081abdf88e1a2cee6d942cd405bd3cbea48f8319889adb45d2be7aa1fee95c3873e6155df678f626ce11c23cb5e08b8af57cf0336c0fffae24879b34295c4b0b4da8421405435a44b997c388f4476e90c3ac38a341f6b4ce44bb262bb540a8ee92345713b5c53a00591843fcce54a0899a0dc7e236fd6d2c055c9ccc9821bc4f62337b65391959817b5311d6f41906c100bae9883d3f7d01c3a92e41a996ac1d93b23ae72c991a0b59192e7ae6f92f9d356a9c100fcf5baca4636aadb83551209f28cfa509233203bed24f913e9c3c91ced75337eacf128494dcaab6f47845f576bfa723dbc80ee251170db503f64ce9a27a7ea46d7ad843bbccb682311359298c7d9ac36d9d414e7aa367104ba90387b01438db44ca97bd2d244c805edbab83749fd863119bd0411520e471497402aa1f0e3c26674c10eb6872daa6322ee8fefbd312946e05be653de9f18512343d1a25705df05e44d8808bdc42c4a5c64c8c9ac0971c58dc61c585408dd5ec69084cb3478765b8fb6a21702ae61132e36ef0cee4932470d0ef29e18cb05c7f31d7fd7c68a79a1587f889145f592688e5d892681cb2cb22dbba8eaf4cc38023b53e076066000c43c8993b4f8a8bc994f865254bdacd5cac469d8d5999c1756525b017caf7dbbce169688be56632526aead49a67fa2a58c1ffb3290e50404e044b4057cd9f8cdda7db51ab4c83035cda8d1c95c5dfcbba10eb65100ceb116d76979065a31cc42db045f409e1bbe9dcfa908424d79c2f38a6c37e24236ad9fddd99f78a77e28fb9601d6c166b4498345547e5ef51b1756d2662be86911223349ae72a2f4377db700901ba9c2c44d630f37ea1bae2fe9ed9e26db2271af322d2108474840ba89acd0c5f916fbf8e821b343bf3e4f3c0503908e01b099872a538fe255cd95a638652f4c41c4de77b5cc2f1707000a234054c53dc2316f909769ed37bc55239701ff9411a2bca64f769c813919c45acd717fcad7991d989d0e0a66b04ccab7a950c4cc651324a1827876bf5f7655f8a93584d392bda7828d66d03fbb97425f88e672cd0b3191fdf01c056de2e7f66e542915d8e230de1c466429dacd1821d6725486376636294c8953762aca42fb7f8e31f46ef2f03ab101ee34a74e7a474a32bc6200cbf78d915b3de6e132e480b8cd9052577a93d65fbc802cf997aa5f43d4b2bd2cf32d184611690173ab540a6b56048daf1b824ceeaec27a89d9cb5f3dc805b44442dd9e6796ea17b1df2337930439c8885e4f58419859ccd7baf96cde46f758459742b3850040406096279bf2f85d4862f2b3fbba13fabd7801f926d868434da5ddce614821558c5355eb7e82a89f246b23617d3bda97e16099f0247abd7594ffbf70238c677336e2a99f762225dea7e1366154f68f3dab66af59ed086f40fee6047f6396b0efb267fa44f25744f48ca91f48ffcc6ffb28b8d2b20773bb67e717cd1b3fba5ce0ad728347e7e515c8069cd03efa4c5c84be85557fc321fb16526f59056fbc1785bdcc3bbbadbf2613bc4bf819c5f3c5365256078ee1d25e7bb7c0f89547c41f446ccfcbfe04c58b798f72753740560868f90b6b7f31079084ae2ec2429f6f0aa0bb8958c7bd8533b1b28018a6e2b4d87d8f61b0e8f637e07ff0eb0861ba150a9e111d3b9f3b32f70c942bbfdae50ef5180ceab43c29326e03d737f2544279ed408e55298f4b2ff60296a2c7bcc97668e3d1db69d5d9c372937e23a647e45f516ebf4d843a657c7b6e6819fc853498dbc13f6aecb455598e2adaa487f0223d06e19b236770de750ad57de5605930424d2688aa3818061574ec9737ccd16e283f1a4eddf68ca77fa38de1283f122af42f2c3d77b4affffcc99871862d649fa8394aaccbd9a25ca10345bbb79063bd207ca4cdc60c1183a8e757457fc1cf4ee2320568f84117c87350f7f123ab6643dffff56749f54aa1a3c281a788f36bcb39c5bccd3db50ed219e5312e00b46450b79e9c901cd81a6f42307c699a697da842e61907ffb1902b52eec41da92a2454dce8ea2531afd5d38b7d080e5218baf778edb5787e3713817a99f129eea0f67432472c3d012e44a4dba304a9ac30a6eec38566121fff0797e87c5a76a4052723f670a5a9ca4492a95a11ed1cb875e7172e0cd2f7a57e2540002397b4ac282f4446e3610883bce34e11dbc5e96ea2797bf247d1a6518104b9f11182419731fd480538ef293bcf9ab5631737c2604898f80443f412ef88e2488285c89b1573c7d1b74f720cf29a91d8114157d8ca6d162204f8f37284a02342777a522e0e042caed9e1233aea49c5ad356634bd814419253d10de6e5c30aa3f08b42e79b32512d8c3027305943632948f78c867cdbfc8bb1a9ebf9babd190a38fd6608c86bcd776381b4e80bd647737b7db0492ebdd3fdb88e1abf7e91fe6b7f97b3bb6ade8e71def53febdd0b58ebf0ddd4502716153165915afef6aaefaf503fa09b30dcdbfc2309b0a97044dc92098f5b7054fc54da2fb671742cd83692df384f35625307f82fb90eb07abda0f62bc445a1edfb85d06c4220c5c27d08b7107eb046c702f532da50c352d006dbd8dcc2f51afbccbdd72a006ccd32ffa0f0fe07dbb0adc859766ed7737b2c2f6b434cb838a8c50834237262e2ca2c0b1aee9521c10f7b6efca4cd3b1618944fa7b129dda8ed5fb207d53ccf1cde3a76b86b209a48e72d0278668e90f74ea6ccdbc97a6771c3e61aaa37232dcf2eae40a5ed9804cac040364474ae67bd96e1ea344244c0b0548cb28d25185d5d1d3426bbca98f30af72ad7ee4106c094b0e9ec5725742e19234d05a6b6bb08f37e77aa8ade42f03ba35cf1f1e6e9ea2d027d3f4f36226a0335b19f1f519c9033a36f8e2d3ea51ed0430924c2e780c1315aa483acb8bd4e478ae36558eaa7cd5c7caec6d4abffcdd6e69c0be4165ef2f207cf823a7e063f305fd8e28a7280db9ea48c9fa53620c5f237aa94680c25510957259a37a119e7e6b94670965caf789e482e8aaf03387ab5bbfab7d2cb3a25ebec215ed73715d8d11fe8cafd7a4860a9682d9d3bb92e9e1d34c8c22a65082427ebe48bb68285a3ccf60a3439d41eabe17d57d7846fc79394bcdbd3969d34fa3dc7ebea1bef5ed75446068d035934e8da29ef4d6a153d11fa294d01ccdf4da567d28210e2e80212662fe008c51287b06d4bf52d47b796777bea83576016e2542a18f4c1da0ced09ff4d0512e8970bbb0944b77e6e8624e92f993bdfe6249459c70eada3901fac55446d28128e4142e6ff6b46a190241fc648158757375dd8c6187531ac29268f2680bfd3652fe3b4614dd8fb037b26531b76ec60b56ceca251343b682edb0477987ed70c04dff55b559a222288775592ec435d632e6c2147db9076ee63e33c711b6214c6ab41ee8da720af795beddc07a34cb9e9ef68b4d3dda8d1b28a287118723622523d0796e80cf5b6d34a76d2d595f609a8dbb50a347c09c2f53606a5345f87230066f24356756f2103f65fd4b8c920ecd1ad15c5016d9ca4ef5659681f86ca8e1fa21e80604ddc8b5b2d2a05267e6564a2bf785c21edb40b3bc59aeeb4660ae2de7a54adba0ffbe9eb82e4446843edcd91cf9d93e92983f33b77dfd98b858dd198529447c5128ed7d2d15ab4f6422a90ef9f1e919a5ed85ce81348795f3fbd6af5a8fe3d0a9d026aa0ab186b0c4548018a7e3a2b28656d2d03eb5f7b59349e39db2b8bb47ba6d226ac92c517a8cace3cd9e82310fe6ceeb744db68930927271375eca5572b6fd803f066705c9cbe5053e1f38fb90dfaf840ca3b281a2d7f84add7fc1efd3508be31a6c93b5b53cf927a883d25d37a7958180d20664cbf53fd9a68ea4af268d842583aafe113c0b4430683ea38bcde5950ded4e4464ef16d52f235942d1bd170b858a1ff886cdd904d1a13f0d6ed30fa7b761b7bf0297d801766925388a94d989794558940cb119f614475011c3e5b652c8555511ff96d52f9c8af871c1f264b1eb249722ba90d828f57d3a410771958a7150df025ac3b28f4938cd027c0d167b83b96efbb1993f2390f22ede6c181db1ce21f55f2ce42d47789278db055aa6697ff3a0c40ebe14efd64a2020874cee062eb87dde5923675ea0600799a6c0e68e53534af75f5f1f4a7c202c387c3bdfb26c1337d6432ba25a7492c3894bcc459ef989db10b33a661f914cd4f2eb41e4d6c6a052115a8111ca03ffff7270cde5c4a12143789bf99823aa8f1808aa81c2ade94280be77b380f14325d28875842ab72c587ef74dad8ad04691f0145e1d31f1d6359764ee17fecfe2243fbdd7f708eb0826beeed0924fa0103f4901408581d5b1b9ddad5e7d714fbf22d2ed0a5403f97d3fed884d4cdd43ad50e93141deba16465799bb9a15d0ed1da73c03c021dd0829f42f7f0f1206db8268f3ecce3288c0d86049845038fd68957ac80f590d58bbbaceca3ad8fbf059040cbc4b67517111c1dcb904356c593b01dc63f0e9e3445b6bcfa8adc392eda68054beb4eda81fdedc909692dfdb70f8d956483a8a532a928a9e225db7dd8d2dd16bbe60a133d72f66909d303ec87dd6330c38ae21c5f88cf04703388cb9da592ad9a12594572c05941883cfdc990ca9cc1d6c8f9d01c82d8bd7f4e975c2ccc2c4823addce899df296f031f5b52e2ab5280b991702f75c154eda4589ede4405f3a25794c73d9fb2cbc77d17379e50d48957b86feace71b277d63ed76b55a4816a6ebf0334e2447293fb5364de9f36b044dab0dbbd36264a9d6cd6741e2737364d56ad2f4207f0d57cfaecfa1e7b1fed18b59a8978c6786e7f81fbc97cb2302d2d4ac6ab23bee2671300bc3e27adf37bea244830dcec8ccb2d64bcac38d9fce5bf61f9e3ad06917cd49b5bdb642440924f428ddf11d138a0e7c59106761ac5f1f53b24c00c175a85d67fd9d64ee93234a6239508974463995ba459f43326d92f1bc917fbb80340aed1126a48dd212d7e0c430cfa440348962618f3fab2512c5e120a0b30ba20dff5219ece0b68f6e77721483c9d4f2b06d9b7f0c6c5b388a5412b1421dddb9a9ac4681af9dd2de876fc14cd795b4c206430923df7d1fa27ae9f004f4e2d34280daa31eb963e63fcd0e05416020899f16b01cd3f8b9a8985a161428b4946904e77fd573cf87771a7d7665f3ce8fd06f8b1e0922ce763e615ce3788c6d546cf0fdc0c588549f435ab1b26abddd09f3e962eea86c4185e05c8518c45c9c486a7fcb83cf3ea8b25d27df6f8bc927d2fb586649d798461664f0195c59b08e9bc26ac5c7a3deade020a5a38d7e4395d256bbdd4d317b401387f5622cfa6de9b5550842441b155f40c82f5a3c2215d859daa8d0e9e3155c430e5aa781f043379671ddb246735264180d7d3cc58846142d93d58631de15eb77260f4b295b96e5eaeb0f612b53b78e7b28a9365440e434dff1f958739464af11d670b33f40050908416de031e67fc288daa88d365c6770ea434dc239c996a729632737dc2b410ac49f9b8a2acd037dec8d3759691a7564cf2f2483aea32838a1d3a47d07f71baeea68a8fb42dd0565c58ae51eb0709ab97cf0804526feb93df2f55a77a1563e4b0f9ecef954fef44040a434fe659734869525301a4379f4431b79b45a85af7f40ae8c0be849fbc048912e8ac03dd9781746311edbfe4c572f57507adcd0184b729f51dcea960e6df8251b5a1c2a27a0f002f112db6b17c40229d8f800087ac07b8a3e75fef2741f2580b903d6333a2b9e52d12ffc596a0a9052269d8250dbb688e1aa9aa664fce989dfa8d76d07da32273936a4fa26ec88b93bff8ec66ad4c467f8e257f9cb38a0fda32b0d547a0ddcf04dafe63842fd6da1bf2f954db2808ee92d61937b50f6ca64c074b6c17f27b9e6543bb62e9a54557384aedfba2be79f8bfe4adefbe65db6d91b44f3e9c30f3df76a8613c146e662c2f72ede73cf436c2fd5c552abc781056a5ba36337bc9775302c97381829bc3f9806ea29c77a5692f2957e6b37462118ac295a6d867ff52507f747f8521953c4010f9750c594fb57ea4b72293311a4a031d3dade151dbb278dc7200dda3eccc8d4295680c7d5e987745b414b4da57862e594f7a660f6d524962472c37a85c01770f20adaa60acc6c3c9d11b9bb2d543d74b032b507c27ea010fb8ee83e05d11fc863daa1940fe8070233273ee35d3fd9ddac406ef56d3d8dc9466ab2555bb48c0c22405265388164aea20b40aeae2eb789ce3b3b9799409e15bbee779aaf72c78d30804da20fc007d6a1f75bcea284f0c80e7cebb48f3f82831f25f1c3395fa7f83f1f0f9f52c491af2b0c3e3b0d5526edc25a841875d64281121fe54bc98a9738072caf8a7414e51d2fad3ca7a5943ef3602d2d417ae489101dd075fa47f22e854fc6de2d8d1867d5ff0e67353c64a226c0da6141138ea34571baf9febec529646384aff4016a0df8c8a0a6f117138e33f4c75184b271d201424b1a16325b55830485e25c10db381684fbe239e08fc64fe828df63277ce3aeb3fc16ee39fd3f41e36504bdd4e3b01f6bae4dae744b2967d230dc576f54cc3ba39bc44a2f5902ddd7a520bf1d060a4c197a03f552dd0288ab0796bb083561fc5e3588cc23cbd808a30289e55e0c149996e55343fddbeb8fbf6bce11636c54eb964cfd09d53bddd7d76d57b49c249750ee14388d018c7032692399e032b2811e22776370f23b8e805e59ef42ced03e9867558e881b77e64a7f97324943ee50184a53f9e3faf4246dc2743bf7e7d177ed82c91d68177545ed28366ea3b8d4563a30ed3ff520abb51165ff526ee086cf5efa4a9539938475d6e391e2b6d7ef414aeba7b56633e07ae5ac7306d16de6f386cfb81b66860a21875bd254a3dcf3b187f735b96834a75015a4b8fddc3092d2a2f23e391ccb19db7c07d899ace46cc1794d5bb4af98e1537f2ed0dd21c118fe652ce1eb8dfbb807ded2ca6ae0e2baa615711caf5ba649bd88ba5559d2115271fd3c859fecd2f32cc36ff50d90205c3326038db00b7618161a6ce19da524301efbc2227a5b72203ccc7a78a8625dc5d7f04d5b7b40514fb5e1ff0d3a7b11f3b645b927e1a4abcd37e8c3cb8f57408f0bfbcd1c03bdf482383695ebe8f097b690977af9ea6bc7b35334c25e160b298a00f0223e1cb514881641311a77a26352749adc97d40b2cd739a3391a94f32519099bf3cc5655272ab8a0ce823626dba6c2d063cb5d96d7b8e89925d43d67fa36534a1a57f2624bf9fbe135fde168337f00dcac53bee6475bd4db9388a6812d596ccd2c15eb941137e17070e5d258603b11cc16c9e0c065dbe5560589f33c349c071ab957916d3467d15d413096b59323e4b0668321a991058aa8d6aab8f51d7bc20b5f0ba0c19b69f79e15d9326f1bef90605f9938dc30c31e32f6934b0a8b29b5e70d09563ff002258ac45091e995966647e56cb3328e7bd237eb9d71daa41ca971316e20679c9975a0657000f8c551c0cef59e484b31b63e0858716f7a4122c203e25147f5335a08982921c7e06707efddd81c4d7bb2943596c42cf5b36354214ab76a12dfc3ba08d8e6c9bc1ad8b49731fd1d3b96a97ef01ef75ce5aaba94630c380d3246dbe7a408976db80b85e9aba2851af3e005c206bdfe0f8bb67b994053e7b66cf6f6d25ca0435abb32e1a791f43039b6291df0ed3c41cecc0be5768e09c6bf0ec2dcebb8e2d05c589a06c48721d1d9e57418a4802700620f96f54c36862226dde1e54ba05798eba8660dbcec9527eede1bf346a35a0f00dbe179f7722be783d3f7cabb3b6c99e9d52c0b65471333d58c17aa33ef53305113d3affbb2575830a65a268d8b759be875d076fff96e7389302ace6b40c7acc02147131a52074bc3a768c8f81ffb47d54ff38d90e7cb63fec329f25070b29c51ea959374e85e8c66cca8599b7e0a5d3ee4d47d43a570c64497f16c5cebfd2816bdefa62e47f7620551b320d388b97eed141762f67b97824a50d1a3097aaae87ce503977579230fe96097a5c32b2abf06785ee0e14b44f280718373004f3f4caa0b065024290ae302477dc1e05c3041ffb80b82413d034fad52c4386d5bb57b0105484924270df7596f5982859e844775cf7c1c845b1b226d686455d24dc268a39fc8db48fec028099f7c91fd2b2064b7b266dc5fc23a1b711ee6371c9336429ddaa316039c0ef61755c1d62b28c0284b6a2e2640a642c6c3d880e1b84359c8ecf354e3a55b800dc79d062ea62e39a6d487271ce2b0c88d600d34f7016a96d119717312ef8e0aa387bb94c64cd32362373f8fc4b757e6fa628e1a26a442ec2764ec68df909689bc09ff7b462c4ed9edfe3de816adab4d20628000db08f738688c4d169750ca63b7cd812b9ccacb1c309cc847d66e275da1179b1d5083c53804ba2f1f300ee4dc99e1e5ad8613eec307d4a5cf6858ff81e3e2a155fdfc67431cfce687207b47d40555984b057735c6bf13874a69cc225ea38616b6a492624296042a86044de5d972ee31af99aa46ad3f1621c5109b4511947ba35dc775c36b8dbb668cc32fd7a5bfd96ef9c2331b6c557f9f5156b3843da978dcc0e839e06039a7582bfc7cc359f18af6e3735e4459e4c7092221944e9a2dff79f1e92ce9452fa1fcbc44fb4be2a312b01bb19d30a712581ef24fe2b7868ff2001486d8522f19dbe7654737c87046853651c5b36c44c19eb9c95b6ad154fc23d709478d7a3ce7a4bf2aad0db9323aab75169f73ccacc518894a2c349970d7b35137c110c64df641bf570c864da81fca75f7dec427071f06ae720f8b93836a5976257e6311a5a28da22fca2acc000c0b4fe534169cab3c5ae6b2c1474b227f53a92c7170d62bf41c897bbe91293a55596c6400c5ab69d3c92585721c8f329cb7d5ccb09ccfc23512f2a72ff0101ad925b22c941c7e03907fdad14750e08398663d57d386d4ae702c8c0769868fe2d7e936638cee812fe063ec6f885349045c14f43d9fbb25b2afe75d5c026f9112e3c085d9da3e517f6aef12c281dfea29f5e7bc914bb8a7b842042864dc987694fdab99017676571aa2c99f2c4a28bd14755c92820156d2f42fbcb1b5f141e6dcee941b33a8fb7c0db9e341c6182b3961754db8a6a6287d4df5187702892d049a3395be5f54f5ff15a65d28665571cf5162ba429d3e6c2eb1277b16b5e0e818f0a6158cc3d3f258cfdc0f94b3260c09109874eb1af22f439518e7f50797787a5fcce913caec0f8b5fa330f584c85e6405b4432a26f37fe04fcdef88128bb1c5421e063ff7abc374377be7c69c127ce1cd6cad267c334073845476551ec195493f391e2fab8ed2fc7e69c13610755bb80f7ba6e323b6f11adc28074f18fe594761284e1d2fcf5d0265a5eab5234b033e27a3e3e736d622771549c92b07065924a8dc7fd534161502623f72766a0ecd4e5ccf543aa84f35d721e91f711b6743ff9b94d8d6762c220a6929c9f77b8c063acf61cc311ba045fa8c5432fdc820607dc5115723e7436788c18af2a29d781cc8d505ed3d0c1d094e531881b17594288b7fa0040963e9d1becfef68d3e08cd6575a6948b48dce7a9af154be20cc751c60b7794b9b119e10d551d96d78e3348ab596862537a3f345ca832c2b7fcaf5666a9d6da6410b6551892609c2af4206307938740a6a6be783f255e59c602c59029b3025e90f61ae8d3c6890c03472f82bc47427a9986767c254d613d795b95b428fe945a7258bf84c502fe35dfe970c368dae0033dde938c1443ad4f2906153a063d277169e86e75653f7e037d1eaa5691d17beec431822b01925365084b32154e52647f4799734ae9d852be75b4d216e4be57842c7f236cd597dd7fe6c3f2909d4c558a427d4852cb7d1e367c976813afe13570159a0e0aac0903f5e0f9e075245aa8a46c80fb1090f62ebcbadad47a0f3a3234582456f5d66fcbaf555404cdf8d438e158a621c3a5b9bb5b91624654ae399aeb38c1493110c2dc47cff828fb53788cedfc14b6d1e066afce3cd41c4662659fd4807c5bb462e94fb9c6ad244772403efa035fd70bfae2449a829eb1b6bf38dbca7f3481a97c752581f6d126dbc34dbba611008e8458db4eb046ef12bc2ca78e3f1aac13006c7055169954da244ef002209b10381329fa94f00d435b1f91e677cbc6b32837488edf5203626ac427b97c91eafcc596574707215bf58a615fe1cd324ce1969368f484a0aea8097d51c77f959c604b7c33deda1a0ad949c5a55c7aacd00e8a46cfea598ec7034dd78c5a5c851066cb326f592e4c10b3279b0943d2b7cd15044e1b5f8a9908a75a423622bea03fdca7a9994ff24a74ed26129ad090b758dd6a99d6a1f46643b33f97f7dfe00835179954592f73c6f8ac1d68399a95c1028ef3546bfbcb4ca225c1803529912cd001ca64dd768f169c7c907169675b6fcc65a6b25ec84732fce65391a768b00dc4671645991d5f90bce739cc74b25befa9e0ed1c9fabd9afd62003641e5bfeb06a06b186da3c345e5896963e5c167055a024a29dc53c59b864766b5453b2ab73b5d07f1a72885fcce29bd512ca30c179b20b29512952fb4fc41c9a1f66737deb73869fe1aee3d684397a8aafa52678f51e760e0194473cf7bb3ca8f48161c4d68ec5519ecc9528aab0f92ee61930","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
