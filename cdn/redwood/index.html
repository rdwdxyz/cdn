<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"90870a659e51de779c20f2468acefee179649d59e66dd7dbd4511d571846cf0c21869ff04bda34fd9229a5da7ba1c4152b78ec26d5fea09765ebe991d63707768e6f76e8df27399269e9e530c57c449b4fa2ff41ecd9fb2709d587fceef9c773b71588e36e5c2a11385744177d81baab7b7b67774964d60a43d7659f2d7a6f2c5ab01f3d417b07aba3cf2c018f26f5d557263c6fd0da22f44b75ff121b3448a1c847d67f32e719c5c2c268b966147ea268aaba925bc6c752ae0d11448704482f35b20864fa28ce1f8c2bacd94ffa48932298cacd20c317a7cea54b01efadb273df4f8400f366162f5d70862ad5ceb59c1c42c3c0074f694d2a3a0b03bcc19f6eb4644ec04b11cfdaebac28da204f4d8a384e60a594f286f56575901ceed1e49740d710f7561d22f9fa1150bc822c4550e1427d78635c07ef28c6e21aca975a509828285aacf4e2e444443a7ed44b23bc7fe9b1d9ff98f6ca913988b64852eb6b44be1ff2198e240ad133c36b98562bb9a386e80788dd331b7a78dacf37fb320c975af94a9fc466fe4240bddad87203967d8ca1a18c1c4c7c2bfac4ad411d198f4530afb6cf0652b28851651e21cb45e67918045e3a7243a6733ec536ccd21bcbe816081cfb2e0b6b0c764073cd7c51b5b9b446b1f303ca4f783f8d744e53bb7839fde3b6531ca629f90f70715d4b64b8729a136e1ab67ee3e0e50825ec551935055f60e4569ec93d2c0f83347db6e1ea69521426fa058a8a3d79cecd566a019f0a47422479deb18faf79401321c2a607e03934d6263172cd43616274705650856e99257f8f9f59827ef7a59d31e7e54abde4ab64f1e6eb90622e0335788e420142de61e89352d8d23c514b9b6e6dfea9888d8b1876d69ce7ec8e5f853fe9beb3aa1daf6dc2d2c2adf63ccd9aeb5675499f7e66b3a60f129129b0b5c6b31c7e91070f061c3f344dc97b2bc21f5b9eede3708537dbfcb4108d0ea965564223a38ceb609784905cd5c5419f4e3a2ecd8f6e1545a2030b4987d8b80c6749446120ad65cf7ec18eab6dbc1be1ca43518a30fec50d0958b4cbbe30db77e11d7a336754d50183df6698f3e69f4a29c98e1c7d91a925ae3ed654cc94ddb16eb663c8bf38a8a46ec8c7d7aca26b01871fb59297453e6f85a00248f21e770ba921f120ffbb0a6cd90589f66270e4be8910e1a8f6499b78ac45d3fe85e6899eb52dd1541be97679b4f54ac84c6ae00788fa527a0c3f0fbd4ea2f2403b67f7fdc140fe7d19987218b2357ff3b6d1ab669b8ad560e1a5d7a5102d543a0c6a5d823e6b12c0c4589e70296d34b9957be025863b3142ed6705367eb48d58ea6e0a7056237c2f53c6f3cea3b7a9c285a0aef2c6e5c1338ead38e343b44a2e2c521e82b862f565d5313831a17b69bb1893efebc2b4f302bb0a0df3697f0ce9d0776c99b0e75399f1810ac5430860843536bee0d4c7db1c64e89f447265be7dc800b3570b8c97a2626aba4557be24ce573d84d924951d9871a82dfb4d7511345f15866ef31c26771270bb877b0693b256f177d16381e4b4fcfcee01791f24d71f516719a52580a34879ba4dcd55f58ff7d774963b5edc3f3cf0642e3c2cadb7a950472f504c5c05cbfca4bf3e2b7ca5b04b167253c043078885795dc973eccc6dd4d8e23680eb5766513da0f3a4dd2327d0b6284e8f0e980fee16a90c695b9bc5e70260a6d05a59b1957b7ba2aaa44f07ec3ca467f21b5a4d00c2eb635d59f8ee47cfef7fec86987c6b5930d3c336d2a1d6b3f01ded7c19e274ca18b9676b67728ddeef7d00494146139e83ab50c623626f6c45e4f39b5daf66c07e3fd72974d192b05b3045034410fd77d91432ef915087b7b1b7b599f27ecb828a73cdd5372a308abd36469eb85c43f85e3ba92d3b1eafa4f134cbfe756b1a15bef762e9edf400af458cf2e87848254507260de7da1a76c37cb2d09e9550aeb8fc7d72c51afba96d20197493ca6b33f94c8ce67e7d36b4c809bdff985f2d8229da2f181c1365aa2dcb72754be00e5752d2afbff302d475907ba25d6dc2dec3f1490b28b4c6486f3ffb0dc0d4ccc34707d568ff546500ad6705ba63962bfdead8e1a77441ad3c91b3cc570a8f9ab11a456ae7c05744e888f97fd3dfcad481cc2a437234996fc6a662649a4d101c497f0e9335bf77b4f346d4e0d0c1fb3ba9956656ad63fc2e8ab10a40d7cb5f2f8f70f6ce6f46407f4bb992f5799d1b253d467fe286cd1630ec17692508a9c4e32fd7020a989f1a11afe85310fa2c784d83efe0e75813cfd372c4bf067b22087934b82f5e54920f27653a223ecc656472e295e3753a0610eea70e9c14a6f07cd9ae35b458f761b904c151f1e303356fabef826bd5f2fb21f8e35ba1d0da8744c80bf4cfa9f5c63db52eb2d1177be6543fafcfa6f27268b109890833e80fa92bee1de1bf9fce5b131b58854bb7cf8a393e80dd1278ee69ca6f89ccc6df4cd07629da0bd06568d60c3c352b4e2e70ce26852cee333944f9cbaf6eee13fed3a53b100595d1d83292bc14dabb33056b0b3716e662b674b9346adfbc4276f0f431016657e112e0c3f47293f942f68384d9e7dc7ce1fea7ac83078926cd7b67e72b88e55dba1b02343d4c048125f146a9f72003ad197d96b62a357c89aeb0387bbe111500315998043a6713cc5a0c56ef30dd32c4a49613a98ac26e305652a133fb23ce5052eeb7be0acb482e362ce7e93140054c41ad52c2c92509e32b070e81c9d70a8fe15515aa1446dd3252de52077f6d1dcc8aae59687596cb4af64461923fdeb9ddd8a1088fbd9ce6654572d04925209847ab7793a7235dc95548b86d3e484c19cc369e1e2b7118d1977aecf759645e6591571d4b55bfe50d6e8724daa0a44fad83cd9adbddbe790d181fff4e83eaa521107b98bf1060d073cfc4ce4044e506a5fecf1eaaa5feb4460e6246cfef43f457021b7fc2834b7c9ae0ee49fdb7cdd144bf4a836fbbf618f12e8fa5f53d78148108b93347c97c2e16362a49451164bff2252fe84f718db0b79fef6ceb34d829df3cf9dc2e2a49b9a225e38c9407c3db7e29367f4b00dc3fff20b90f963f07999f48dff69d319a0b5f745eca245f1551dea5aa45511f128d22f2c14c76b9e2647314cb27bd80c07b184f6adfe83be2bc1430854783e4110fe745a5389d3c330bf84ac212aeb78c6bcbaa43c3b9b0dc86fb413edd8b3db3eb59f2cf91f2d3dc3ec1e232a6a88301d4ccf8802572a9fc7713eebfefb679b7a9c179469fd9955d94c0322dd2b9c4238d37fecb9003f06e5b28e54603170e7c654654cc5cbba4f048a0e9c38e2f578b53abbc2bd8d5113aaee563f096f28937eee0ac041b8337c716923f952c2cefcd0e96ff9fcf3ed97f13134a76bbf531ffb8b05306a86d524a915d117a767c53dce140041164174c0b34498f5a8de0bfc6756e7cc7b4513ee36d01e14d17f44903a5efd1b167f285b50f0e7966930b9184a71e89ff6acc93d5c2d3f0e9b1a9b18c792f7bcee86c22b532d6acee753620b8ffbdd73bd7a3a06567baf61a9798bb0cfb3ea7bf1bad70c59e9c036fca2f9aa0a96a0acd557d8184c86bf7bd5a6d5f6fded4abb4dd4d4e122dfb92a3828b1000eb0d38cbdcb4bc1552553feeb3dd8b2a898f5153377d3595838374ea72e74939bac261af8919a5cdf9940cd93a4339b608ee9eca488ea619ada20c6cd7dfbf06da718da451b0bedfafab6fd06ded4eb8e4c3e9128d4fe3e9d3b7c459dc13e8a2a3180ef96c988604dfc31fb7c1fa81558173888f8750acd92832d0c83c81ea40a62c6cd9c94d26dc49139d715b90ce2fe6a69b730257f7be5de702ea0954c96b5939626512bd6fbe3a1642f78183503c45423a9c0bbefe04620864164b1a4836a49a9ecb31ec5fa468c2c6780f91fd3feeda89c0a46643e55a83eaf98e7d73eb821aabaac93a0ffaff0691ecf5637fbf663febcb460cbf7fc1b09c246b0f3831355d1600c3313676bc775f5898f12bbc8e66c5d4bd9f664ca284bfb9463e05233ae59fdd72bcdd8e93d8ee50a9d739bcd3032e4d6f47eadc9e27804d50444510d068fe17c1a59764e6f7c72f3620f35fb0e09c9911727513a903db51ea5751ddfddec9b13dec600dcb91995fb54a4454345f8564c0064a5f6113c8298ed0bec110157afbcbab4281500b430a8728f7f625afdce759a8fa01c3067950e07570555c5d815fdb2090ef531f88b4b2638f27a005061e8d369197176db1d997e57141be7de8f7ee9ad93009ca7d636d3d5a7ebe043a7d8d2bd2a29141ac67f7b7d4f6e09483b32ead2fa9ee36771783cedec3f59ce94ba3a780e10fa2d3aa4395b21d970835b4c68b00f77c28d37a3a7b5227d217e2e4b0809e1e2b5cfddec628737f2377a26f9b8d594d5edf0425ba7642decef1e2cbad26a74174fdd4c1a66fb553a8d525f501048dc17ee6239d2037908822c753cfe89bdaec5ebc0c1e55d383fa3aeea4cde538acf8c3febdbbfc0c693bb35618a0f6cdc3acb936d32bae6411c29460a84f4acaf64c1a7ee7a7dbd951e986d55bc0abedceb97798feeb12aab6617193cb35b9cf6bbae37aded994131298fd4653de3abac911f6915b71f372802879ff44a7175be8800a5013cac260adc98eea493965a0bb7fd4045ffbe825e5b169de3e9067ae2256d607ef0e82f26b389170d8db90b5a7140ff80e6d0c847f6c737d45748e0e36f6a8c5d228757df45d532009b9b32dffd9d1be8cc9eef7f457250fbed38724c920c4d8e447672ed0bced0e005b4f98430ff89bfe65063aea16c64472fa4bea05c6de93630e802c27a2616519065a4c1432880941e48207d63ae9df9b89f8ff7627b234fb3eec304c4368800b0d661e4b4a3a51fac630260aba898edef6fc1645d9b2c309b9d9f01e2a26e6f132770c5c2dd403173e604b57207e16d42f0d9e989a47c59bf21da76bf03a55d0fd2a08d1f794822aa5b9520d6009dfa0b0c12d2e39a7659abcfa7f0f2a69f2eb507edce2eedf13c4334f0ee471b68805a8c23bade3d662cd91de444cc0187c8a0ea95ee58919dae60d6711d66f90137d0c351db3864cc5dba701678dffb5f0652dd2de0b43d450135ac7de17a512821f6d45f0b858aa9be3d23b0d246728fa596334b50b81083fda0b053542fb4d90fca1a9951932d9169fdd9ac8015d0f2311773454cfe26c53f24432e80387d5b26c566492ff73aa78751f717efa841a3519cee7aba6bdc329dcc2361017a56ee26b5bc1d9db5e3d7849357244869cc31d1060ea509c3ee4d9bd8c0e4c1ab19ddee94f668094b1f09d3a9c0d2155c5e3a9ce5566e0233e8720dce740db806831b174f91eb4157857521f2868b61f4c4ec7bd1a29b05f4e18b93a21c946550f15bd2b6814741738eca13f9e6f56f08dd49487f1de26e8da8e0ceb9914ba1b4c8e5146a99ba584f955e6d372ccbb82046fb3b7c250676e6cf63b130b6db26cd58ef53c990beb14f95ef47ba4a9e15f51c9260c510c1404145f9248c21f2405045a265e59067a42b17c06cd4b842beb4330e0710b709c3e3801c26c6fd99c37b9eb2b4fe8e0b5439de05af378c5b4c34adb4eb245c4e1ba4091be5a9c043b7808dc3516c8a9423558b6b9e67510158808066b8715a478330cfbd90a93fa02ec25667e33c7a1ec5c633a78a5fa1ed8141cee2eb31d78f7913896d12a77ef40106be51aa94c043d2237e992e52ceba7002ecfc733cdb39c665fb47bedd96e4265cfe58d634bc4e817102b89a74b93cecc145ba9e102a2aa5b68657fd49b3d1a9113484d7bb29fa2b9323bff98c8fda664b891bb1be3045e1b59afb5a07b5ab9b9b839de43c5a7c2cc13171715b035807ca9472e2b1267d3d685d817ead9897aa82ee397507bc30fb0d29bc070217ebe2a516b8f65e2310abcb8a99e8bcee8675eac45c9b6bc7900fefb22c600b504c8501a80f9a056f76a3a57f0c8850a1091f8219d9ffaffaddd8e10f4f79d24049369db0c8abdfa156b70366844e9682ff39d142764f4240168c670f1ec4bb789f1c9acc3909f0d2adbdde4eb3f863a4c6d4215decfe7fb4eeffaf9a130a0b63e5ca8fd38e241d3df44bbee41dec9d27fc15e28001ca6778d4917937b31333409ff2348caacb3893d5cb4e95bff38c4d8a1dd880a488f88b14ac0b6850c7bff72b31d7a8e7e25cfc4a25db981bb745553d4c1a75f930c5da4cc83c41a3a419f6f9accf953d52303d244e04660541795aa177b8f0a5837103044d21c6ea45c780dbe35f3eca9d387e4e97325972d50d0b50708dfd7646b145c6d4496442afb164c0f60a8d5c8b5f2a243a3716e4abc35007dfb70c534c801c7945062e019c43184ab7bfe6e7169695d2667cbd4485037284b3af413b439881bb3a108ef8ade26148b351d10d58da6d9fdc5aaefc65f6d2d8b7c9a8f4486480af651ae0a1b0bb30d17797d03f76d3e525263e584e3b1538a32260378097f876e43ad8db2261dea3c278c51a76056a3339487a0359498749104dff6139876a7ac710a94c7ad075be8285d50d1cb88af2887fc5a1d03803e68dfd8c5559d4ca58d6567cd851c4088aabc5a5fd60708e571bd766d7c5a57b6d629c6ef02e45e1a449a8beaefc1b43fc67309c1943f1cdc864e807f42f725dc6635dba2b6d9bc0e34f5cd078c6b98bf1f53152c360c2de9580374380e360bb89ce56d1e51b9e959f7b6e4cfb0c503fae5e93dc6823870a6e81eed7641a26b6b7412fa84860c475bb2d13c1bd8823ceb6dc3b188d194c8bf879546d921fa5f37b5ebb86f48d559647d7d78d5ced6c432bd23925d28bf20a6d1a02c7ab801fa2d88cb1f0d65e2e42d388a1775f7c58a859d91cd42435530d8a9c9dcff8781af8c72072247548862eddba4c8f370f8232ba46fcbb953614d01e56b47346dbae2b011d59a0fb8920c0261de6f83e59040586a7341bdf317ba484d63a1a4465a5106fca1cc01e63f8721f442884769e6bdfd548fcd5f3ab562a7523487d5746ec553bcb54cc152989a2a781772c74b110a542cc8947df51d5c817ac892a5e241393b20b8599467996817aef5b82f3b2d78e9539ec05204907e1bd5147c88c35b081461dedb566c79954085404250e7d7dfe014b6a72d7bb9d41c3b02ca5723669e3e4cf83dc38e12a782c4b1b44297d4a72b61f1a20460d48f75fe6dba7d280691b47dd7ddb8ff289c49796bcfe1cd7d9076c8e78498a8a7d21b2892d3e34bcdf5cf8a3d7b24b68fac47853126839060aaff53312955f3ee56cdb4ef1253aacee1457ec550c2873c2a14713005b1307d239883a27098676865d9904202c87be673879e5bd726a42dbb28aecc3e6eaa1f5cb13f736987ef6aeafff6c51fd4377d0be430560a249e2879421cf3f2938d42d0e7500fca82ad3bd98b5b37b8771abab6ca9b6d97c697dbfd857d4dceaba94cf8963f6e244e9d88de8db4769441a9d4845a5b6e869f43eaf0224211624bbbbb4a359c32013ab979275819f9a41e541304f31737277c6761d09f4a79f90cbf2b37bfbd6842c3b6d38d9f345609f4dde8c174e26086e1ff828e0aa04b496a2a6b642d18182cc0ba6ca882adf984ce08a21c55a40ac1ef4a600b66044dff6082296a5f4f954313c0ed5f65cd7aeacd817c2d1e7f89cad4af65eda4643ad4cfbd4b4be81e24c62edf708c02500dd4bb22c988e4b825d4130c2bcf7f37160d24323a0dfdd93870368b49c2c83eb1dc406e0e267fa8ea814161e1ee2b49a40904f6ddb707d5ee9963b3838f11a0261f0f0d8aa56f2d67449e763c4d4815cdade0612d88a3c814a83a132944c8382d5b0b0e9a9188bb7ddd19b2c0c107e9a0f36348f262cfbad67ef1ad86024e2bec7d32717591e0af46b4bbfc1afa1ee7a55744d77f41ae7dadb83aed6b61733c6da765c330a59cd09763e6d35efb251d44707329e2cb8f4b8f83cc8caba0c45ae65352167ae3054f7dcd490ffd0ad51f4852f78bbac98b29f5c654ee42df8429d3a13bade6a8844cdf0b58344c955225b73b2cfb7ca45507ff5d3dc914a10253ef57aeb063cce30b6de409c3c3f48059f6ce066f6a088bc3c62b3cb07f5137f8525fe323be97fcf7f795b91e21c155692a7dc20c95b16bc25ed8b6ddb78640349570b0ab10b450bf9a6bf0c1bcfa353dbf50357539b36fecc927f28b161843108f304db259a44fa4a9b1262482470655d10833fb5e6e662c20d353b2ada3f9a808a8a6fc53dbf9376af313625e9e3b2e75cda52803dd8004d54bf4b97f5230d7b5cd097128b7dd87d003756be11752810290db80f51f704c86e708511653230f5e00acafd3a66f050452102137089e02dcc6f9f36147769f4cbc6c7fc571925b9d9639785f73139c85c644c4d9349f092cc8f0de9c938813f4b3be451603cd0b9bae1f6686f8bd41972dd231931c75464283e3d48aab7a5165fde857d0b75a1ec78ea1d43b9824b1d2ed3a4ed5f094f7afdb868df9ce1d3846c2fe404e52ded9f1fb858a136497aecf011129fe20470f689188b61a0fed651f99b4d7070dab8e85ac13d55eb32f902e9062f7dfa72d57dc126dd52b2db453d31fc5da47225175f0eddb21530058404607a01c9fc28761b6392a2062d98e9bb31cca1a24a1b6f800fb308326c367691606fa623f98dc93d61cd2e6fdc13c03d59428f9f175426336c61a806157b56501f6da1ce5e3bd6093e91e3f9d6eadb5ea5b6aa57ceebc469c2fac3c9b9768e0aa24496f57c9e3414585634d1e43088efeb658eab8e37e6d533091b5869d891fe617af94c428fbca239b21ecf12dfd0293e62ba5d32563abf3db95bf481da52b67c6fdc44a64191a0fb093c345ad69c08905eb3e21ffedb33e65846b0793d6f36a82bd49f974487acba6742a5eae728d17308658a51b6ffb70884109fc7b357a8eef2d337abe88bc3bffb16d523ed2a4715659fe0845e8fc0fa7bf3a1d64fa6ae7b9a1f8903259060ea36f294033089c03a6872af9a62265d044811640a8cf91c39ef759d06b93c2d73dcd7b976d96cfd94f631ac619fc24d574464042ffdd7ec39bc83674a34ccc7244772ba70a028a150c5fe011e449fb5465e2908b31a507f817795140089b483ef8aaf4cff055e7f99b137d9e27d06bd7e179e9b6d655378b298ada660e34003473ee78dd9ae320ef2116d7b0c0d95f848db567e558559c31c24914d1222277dc39a1f31ca11e5b8675cb5560b99dc4bbc72bf45c7de33847ff731452696370a6666108c7f921f9644a150d17fcf6e338883ea58b3644713c0a693154a90ad34d2f3aa1f54a88b47254655173e9f9572941e758d9963d0a11c85e1cb9818e8b68f60c0f57329decd6b4f1b61120d84745287b67ef27c9e9a553b5b2fc159b44d165f1c48adec9e6aa22dc08b6875b998d0fffe5724274067dee46eac5fb5238e05e92024bf2c82fd9919ec34167b15f603d75a7d7fa7a6d5c4d29fbade7b2e850abc9a4c08611e96a256176a8e115769ef3ffb6b5cb344f8a5b6263df2923f5633968d1266b7ac5316b559d74a42e2034a67962de9b555e93b012642ea14cfb5b16a96dadcf8b083bb31dd43161b28ce1dfdf9cb2cd2462522dd1453abf80888759d26e354268bc9b0bd72d601087722c644f9f3d1ae58ba6defad228fa7fa16902f1ba73d7340f1cbcac75b2da5c59345772368dcc119c53ceed3aa590fe53bba02f6dc101c7f09679f28cbb969a74199be54d4d21963d68c5821bc69f5592e36b35d497db2cac8095a342f1656828be8e5f3fa7d8c0c4f5c2191acfdd07c35d919a24d368f18a150a6b243d639566251c6e342896fd33e4fcda3e94273c856dcf4d71ec11a58d26eb3cef5e059bddcd9b4c83a5ffc589f067a4993580cf9e0455cbc0abd5ecaf00e36f2a42cfa85fffab883810a32f833b32c47fa9635a550f62715f99a85dbf99627f7737c3d6504069caf815fba7be9a13dcae13595a27b040bf5b01dd4bc9a36be47eb5d9293a1e82615842ec5b294dbe931110989184e949e599b83252d5ad11c0869355e51fccae7bc4841f319410f996a24d1568b1159f4fe71abd086044b85654b2d17fa1c4931cc6e9735dc8d871e2debf976642b44d32c7a24750ff3728b5fbe330c87359fd2a2e188398884729e4d50c96b224daf168ee44428b656efbbc526069a409e1f3730c23350a4ce10bcd9dd40f1d6bca0b562ef4bc87774dcff20430ddb78d46768e9967a3cb75535617044df910147c673afa4329deb1372a48c25749e5e1772c00ed6e6fc9e32f775c9ed13edb7319ef4ec32ebc561d3bb44423aea6347996ecf5476ea2e70f1b98ae225bc960b7258e05738debc303c56df0bee4e12be4e99d8c065ec0c3da519128ba257e86f1fcd2dd92893916ab95d2c6ccf2e85e12a3fc40c259ef53c45def41bb9270856a18090fbd2f5500729f25724215039b3b1bc0864ac5bccd5c1a0fe3e3f23146b739d653c8695fbf12efe3fc6cbd38888ded6abe4a204c66c57b820cd70196714f9cd32766cf49cbdf253297406c84561ef1b9485bb7ec24d3985f29143f2b417efb2db67bd681a8b6400b797065b0f7642ad3e6f8b6afafbde7763d1425274aa8760453de4a2b6474739f7cd2bcfd4af94d33539a70d44815729d994dfbfe8f28be2492d675220beb02f3ba316b6eedb60af23d50e9273f8150ddc6c3d8f9d4e8f98d112aebea3b64dff7aa2628981d93ff66b0820dcb87cd7d3e7d1c0758fa8695d932e709ac6ddf6b763dec608717a6d244b99afa6c9ceb94f59fd5a90cb172fdf040af447b6a205d0721d63c29da5fd67eedf627a858b16a8849e0e5798f86a72c8124264a243365183ba44eb5ce126d445188a618609addbe73b6ae45698695335e4db32524f236a943da6d5a20d11b50ab43bf8d83a7af3d76f72c8b2715563afdf05c387bfb928b848519308de0048d06dbd48fa8c25951154ca10311300e189c571c52dc8f53d6850ecaaeb26fb34da40fe7182ce513433b31d18202b5425659ac1f2af7be5de6e2cdfb642d03a55892981912e540f52760a4d43496cc69ce9cd2e54c84d200b6c5514be03e906c0288773f7896317b4a881b53d80e82fc3d89f0b3dc1f4cef0c58b4b9c051a65047f3c30411d6fce08b95c86b0065b6cb26408b942635d0682e02876a99eb2ff97f66479ca688445713cb8873141f093fc1ade9a624ecf3ac05f0ca71a4ae510184612e722a0aa6d0d6c58a2ff5bbc6b5c423da7ca8e7287f88bfac75137f01d18b6e1f91064f9e787b770158a9399110421b5800571400ba619b2ca463096a5ba1b69dcdb3954748a53ca308e93ff969b7202e10dd8960aaad174a98dd73ed84896febcdf46357678ddae5708f9d10e65ef09d7d864c849559d33e1f2f013d5ceb7bf733ab3cde33279b6fc9f3b0d69efc7869232e6b71d3a749fce6e7ec3012f472f25159cc10dabf917a5e42b7c2ffb762567b686989389ad3edebc1289d4423eed439194b8dbf410b71396710bd3f4a33d6aaa61b435cea6a8f53a4494fc501fbf23ca3bf36cfc762b2d1d5cf1b4c1102415b2ad8e86e84eb58faf8d07b57bdbbefb5e2bc98da7c73df7c34929031286658858775f64c9eed0a4b477b3a7447739722becc19b4c0619a772db51100450c49d6736e5ca10d4999328df107c1db4246d14727c8f5a4b1be20c52a6385e0e2ea021835f1a0b00bc662c974ef708f47cc226013e29ee3dce6420703dde230d7f2f2e099ac7f08757e1dfe451f9abd5d4c32ed273e04baf422abdad863e61bfb0fb1a8ad7727bfd759df0da1cf59a9274f49b939cd5ce89cbf8a5ad7db222c92394d62018d2e3b9e7d3cf85fd94791030179b04f93ab1597d03c3ccef3ef27f31762d55eb969a5bd418e671c15bed494c8b9603667585379f22c12b90aa78eac92e762c4ba79bdb36ffc5216aeb3287697aed45cfe57ffc337070ccfcd46930e84bdbb9b0decb49a97f1c1fd826d06b16f1c4ed8f9cafb6837128bdcbcf4a272159fae08f4b5c32369a320ed134b54b21de1568122d8215ab0df4b096431b06ec2f9ce507bffed9d15356d1852175ffda055130fb99a839797f8b67c180a01a5d098a8b41fd3c2750b98a340c5d8fbee563860bbdc6de797c515a27ddcdc5d70b7077464c47e0649f34b7325c57db31bc05bc7830221e0f5b479522de44e84daa3d94c16a32ccf98a23459320a563209507ee6bdbacf9fc592afcd608583e7c8be54efec841b9ae6aee2424f5e51c909a3dc94667d3c9048a737ab97700c592164a4de0cfe336a16c4a6f8377fb2648999de1e62a679e9e3c4d732f9ad702c265b2e4823807cb556dccd7487db11033f70c3c47c0485ea4c06a29bd1af3101764c18cd65f5aed64845b774868c31a0e29a7c092b4bfbaf19791a966fb1a6fea4b15f7e386a6cfb51d45ff52960bbe0b55853eac4c6ba860fb89703e7add64f181bfcb10b492579b430c9c23f29ca49ea8042a5e41f15c66faeb1a6d61b71ef934abdda856e5fafa8193b9a45d1cb162f50ee2eb8c8749739aaffa8b28a9b165ad16574f42ebc18c16ebfb7198cca2c37293d295a325f361347617516f8471610d16d27c1c062eefef4761e80822f65af6febc0f4076f22c604c9c7d89b47cf5d174f117d2dd64d6d0683c790aaccbdc9e658b64af63ad6a772758037f93051fefff34d6df8503fb0f668f5327d2a7e181bd318fb4d628b9e6af5945d88f458f4c019d3e4ae9635bce10e899d597610a52bb1a8ab520a014652b1350fcd853365b08be24e672945111cb1fbaa6b93b0c5f1b4fa7bdb17ad6849f2aa8997848752b288c5619ad8ce99ec92fa04f077137694ffed7ee83690f6fff5bffc524b723982e27e5d76d9d14131cae078e096e707a05a567e6deabac0af70e90137d5d8df0f98eed3d327458fa807da72f31becfa44c0875f78f55a03fef9c2afbe78be5efe6ea621a76eea61027967e4ab94b10322db7621bd3052e4ea6446f302a92ce1b0b5bd994cb98c1ae9a5d0fd573995828491e4505db6043e093f5d1fafe03be0027fdb8806b6bfe3036d7a67405bbc6cc38a77729c8f58fe4ab007f80443b8ec9a13e46d521f86b2555832136faada138331c9f3a4dbc098380de74a6da0b3c1d0de53331d92d6c575947d030cb3c737aedf90561fafca2dd944d093d7c11b69331f420729ab40c62929d7a05cfd7a9a480e272d56b1171d726c6d02740b54bc8a140b53bde3b1264483996129b3f79facd75852a6cecdccc1bda0ddf6ca6a2d8caa396914d743d1c91db1551c852bbf1301f36422731994a96023c6e3f8433676d005c266ef26accaa516ad184380a8ac27971f054a4d9e2590316facd813c32116e88e0cb1578cdb5a66226c5716ee5c4114e29373ce818e2b5c3bc6f04ee7d89f170280fb689f09772b5f4c6d0bbf195202e3da2d1ce6b2c0bdadb612b1bea449575256a8ed76646b0cac6db7201f2faeb5a78ebfb3ad9b9afa7f82a50ef9cb936a48a187c2874806d7baaceb2b86af825e314c3f7ad3bc6f5d9f7d2ca9b6308ece24f795148b3535868d6307c79db39f3a514b8e46c073cc9d80b10f55efebcc11752e22818b563ecbe3a940cf0cb17eda9a528ecf4696f97e32f6a9e80c7a7e45b1aca0d718e46f491d9d503f08dfa868b24571f647ea715ac59ebf35434ca819e5b8a3bca64c13fffbb3d7f31debb9a6419acd30cd8e64a7e44bca3e20a28f0c0d10f48da13928bc3019409f77b11525442da391ba4f0a62818a7a3909d4193442dee4f993bec4c9a8ecb9d8135685a293d3b8088895d91856b6964a7d2ecb7ce9350c3718aef4e72ad154a4fbc30e9f5f14ca0c2e94c9b24b902d7e5c6a64fd2054ff38ae95de5abcefe6574aa3db310dee95c4e05fe4a87099a25f662ea26a6588657ccd71912b01b5d3fcb5e4738d3b5576956d1922817c93193e86cc1a4537bb3d44bc44ff44c5859bbe7a59092543eb2bdc950a3559cabdbb9c0da34f6fec52be45a396f5aaf86c8b03f9b4db6917b30055caab66bf4277a924407cf2d65027bcb478c0f2a166c63145868b48581b2c233b214c59505aa3330b8886323f8040c68acafb6aa54c6de3b48d6e2f9e1e7f2a0408e99d7ab120cac37cc89c8521defa2158af2b9fd4c85ddc816ce834e2d7994787294577f7abb07ba1c56ec8726ec3b7eaab0586f73b701fdf3dd07f433a90b3ebf4b62f2e63097b4361b918b86fb237e90b1f31936a7b745cf426488b0e112ae15050f903cbe2e30628b8a325a81338f0c421fbfcced4c6befb6a397126bb21f3a81431d9c49f899b275ed48c91f5f6467f4473ed1d749e6beae442438b30a4e760987e99b00b71d9c597e8f72e2b8402a1f8986560bd1f60c3ccac7bfead8336f6367cbffd38ea45385d918cb0aaabbfe5d33c5deb2588ab9d4366b10e40530b295503671075625d1942c65b022932436bc2af27295ede9e53f10aabae5908a82923a835bf11df5c8161a82c74893c78910fb6bd2b4d9b22a27be778437fa64e54a9bd4fee35f81053ad4ad2a0107964476e6605b66ecbccc96f692bc381a3d1681c51c4195d5681761a81f96e9d206ceed84d24c293b31b9c18e761492e120d6379c6faf85a7622667f4495dd6aa3645fa706fcd91b2bf45163b0cfd3501fed2af83b96ece2bd323a8b1a0bdfc087c0fd2d096d94493c6c55c66a413eef8e130012e1807e6b9c5f03cd96748862dbb32992320575a7dd730895644aa074ef81e8aef46535165e1def8493a37eba34a5be186efd63f2cd0611be16e34cb468265b50f69dbdc838d60c3bac82e13cd5297d1fff750817015e7ebb6b69f79daf5d570bd7d8ff5b99badb125758c20cc490c1e0c9dcdbaa5f794662a89e23182d9af71d5935c6e453c3ef1b4842505b5a213ec2b524afa673335d18215465c5ad45f6808aa00bca76aa3d236ac454b7e5786cbae60bb049d63c584169461b00c17663667c39bc638a00c8b796b2cd13fff3b37f00ec386b9885385a5111e0ca47de46b6719153c164d4c8f2773434654ac532cb2fc7c3b3bd89715e1b71d23a3ac66c021ab056131243a1bc22aed7f2318acfaaca72d34c2c7bc3cf6ad5862b2ae26e47b22ca489408d291ea8addd5bb37202e7d21a97e1c5d416517886cf83fdde5f5397c99bdfd3d42516ac72a9f7e8974709639a1f8a7cc0ea404de07b70c77f11d112110c1295268122204813ba87b54dc51828e6e29df1c007483672866b067078fcc7e5af9c7b71521e6b90b034a88d4e3df0db557584ed6aed1dd46eca01c32f483727ed6d66bd2761a468fe3b6e805a265a6d4a55728ff228f8232e36aeb7d8c7bec1ea274558fe8d8adef93e9afa231a64ee11eac89dd4c73de8872d5f1de789cbfe7da02b505ac7fe3513e510b4029bc491f8be1d307a38afbdd7835e4e03a7dc22258a7134b55c519146803a1baa6a10f37fc49efbe24a0d5894d2e2188577d74ad52ea01da46a0e1b31d394e80135ee6f954f6e7170850b185691d7868880d72c57162c304b7c9ec6586ebbd1e55393bdb6f87fb238791428b3636b42ecfb6210bdc8317caa98f782c7fab6ce31fb0c8b83850b2ac32ec5a37b9958cd7f74ef98ed61a69860a37c9ac9502ff5d33561fb267a1e09d750b41343170dcd8f54e4bc57227c00b3a771da098b6ecd97a770f652d66197f2c038556c8fc18a985a037325eee1ea1ce466c26ec59b2c9a81c58a76820780d34c4e04a4807c048b5072233cd4d88be0dc077a220b7d97e78bf30b8e54ad0e9e9869dc308bbad665346b00f6c09f1604e253a98a2aedccfd879a167772fb8a3f1fabba3bf89ab9220ea2d510495c364885ea798fefffd7f62c118f7777cfcbe29bb937ba8d3e06e06631cc1b1efab37605891eb9e07dc6dd101d49221f1e2e6ca0a4bceb6292b2ad6f6bae5523bf0d75f7f2bf914fe9136e115be77a584dee55e12b91aa849c80426e392a8aad31feac686008b53df2841660db5b543fb62125476071dc1864ceebbeeed04e1bb9887bd8db0dd70126df801377dcb601e53ffe41f74f444b280512cbd65409c0cdffe8838542fc49f2de158140174d37ed37f1d7d0761b513fc12674226c6dac24d8a9d157f098bbb42b196735bf40a2819c20623aed81ad52ed94899a01879a6a6e6e9fd751e5711d7e46ae7ac7742b09982c7c31b4de1c21a09d0174db84133954ceecb0e49ecf36eb5fb89b5799da1b0c9ec08f66cee4a542fafb381fba8750e53ae805db7b8789ddde64b031c34d8163b1de82eb784c9d09760deac8584ccf7e841d571d4e01a2c15854f020c1a3ce4ef60860ebb7621de1b04f118410e1206442750d827861b7f3e6416f7f8bcdc4bfb68dd0e10a02d01ac74f612d96673539a9b808164d5c70285980fd141af811335ea2253a9711f87791ec618771c1fc439d1e6ffcec102c4b714ffa39c8bcbeb80dd03239a101a19158ebb966e42016ef52f6d65725f6fdfee05d74f384f6b0a6f13807f219377883f44428383c117100aa3226b2996f2c90a74c6bfe5e2f8cc9f9abb365db22d9987d4b597098e3c9b0d7a2924ba0d365b42f790623c7029862dd90f458ec5d7e3d6a5f86a011ae7d59d9781d8f23f509c8e8dd5e8b7f1bebf80a02f25f6f87cecdfca6579a6d1daaa6b90da15049936885e4baaeb5612a2936ba71ad695efda99b1a9e7bdb506fdcc6f9f7069edb4a8b882eb140dc78f2c93d3149d5cd52fd1a9b2da8eaec43b9534d609b919bc6bc323b43ba22a7f4aa65a1e68e030dc81be39027ef467fdb11bd30e52f3490688d5ec41fd98fe23666836e2ea82983fd239307faec09984f5cf831b0ac16ad2f6b9aef44c2ca8e892a15ec07d4599360b404e0f0bf4bc5a9bdecb545e49a80bbbd20b70753557ebd625094d1712392df70424a5887ae234eb78bd119672ca00b664d19f9e9f803f5778a40017af83ffccf3021139c49564613306749c979a91e160b0a2a016ab9f12866fb26c93511d86c939029ea9a4959be86b3f8fd54da98d67ab3a5c0e773ef5000f8b5fffdee23fef1b353bb75529cc5c80e74a2d35f537e2eee46254c30e7f8a8b42229dd91bac17b1a8bd6042d8cc5a80edbb6622180976060373e7c7cc1cbaab736299920c55a71f0d7cffafe1750637d88b66a33411518671907aa00c3fa9e901ed2c99f047816676279a949d50ab6562a026cf14829ab3fe3f888c3812ff9980dc5f56950ed2ecc6c49b04f07b9b0cbca61effe96c72aec28bbfd771199bd185e3a78ef90c3facd02d4d1dec345f12e6a14fbea2af3d9a6e83ba882b34e27c5f161c221940d7a8da8ee467509fd3166b0b1b3b57527616c685bc31ef5f07a0f27fd3051d7e148d4ce5f0d3310dbc7eb06545d9502a7c65b4be9a8e03ed56fd592458a4ccead7639c6fe4947722bbcb7b57787dfc2ed2713718b837242956252311ba957a50aba11ed2e56b4f4da6e4f34ef39d1fcf4dd65ae132a0e8273d80ba474c2d089e2ac3094d5de3308fb334c08c361b47472ab51468c1ea9a60674faf7a7b5b4efa66a83187a2755547e53c76919cc75c3f7a6772e5de9e06232f8dd7b1867037d6ddb15851caebe09ae370cce443076a1bc2d1a5f7661307c0b02aa9451cecb0c6ce17c26468f3029ff590d6096a86af303075f74c04ad9f8ddaecd4bfabbbae8d07825ee9cec527203d05ca32d8d2d499086e3f679166227619ff05976556926cec399b80f458bddb4d8e7fed85641e16ee2cdb94a47dbb2acfc0daeb311ca4c0d4f48a6873b0eeb298412165d2be4fba06beb0f1be36a4bb61f3dfeb6b1afd26bb4ded6ee929dca1d21fdaa1efb680cb1bd1f177439d24d71719a471e26a3777a023ae7ac68ad318514780393ab30bcd85bc7aa70b2bf0282bd2ea102e5109910eb1896b9d58d1dda5a26865b56ac3513b962f5bf1943e01194dc8d9c08e0ded7a02810e4987503f308cead4ed12555c61321eedcb0fb7520a2e5626237","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
