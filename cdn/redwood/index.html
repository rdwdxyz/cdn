<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d92a721841131c701386739cb12872ed4c929f8a81b33cfde9e2eec6a7f254d876e2c8caccee833ebe12db144fb2b0774e2a0855bf09a11a7cf6aa794f4b9d54d32ee0ee579e9249cfc4de38d8a19a20a0e7d4d1104a8cbac8821965c01c06537de1379a6f4d4e644591dd5299de429f97fb1c0a8dbe716a7c5d07d73d424b9f4eca502c06ccda8c5ace061fe02096b27019a53ec195b36a386d016bc3c19ab9865ba93c7e6d104465a1a7dff48312869f2a6133dd50e22b72247523dbd757389a3f71c440fb9afc697b9b5ed66ebcfc1853706354882116daaf7b5bfced5d62c666529458178c07eec365507d4efa85c7f14c846182ab874ef31c1297fa28c2938dbe253b309371ff012838e9b3f56e5b72f250c3ae45f3f1eca3284d3fb6408a577a6336773d70084731d81617d49c2bcc910d752d33dd5e1e2fcd906866accb2e1031162ca6b380aeaac21ec78d14616e1311a68300f9b904ee6b73c19bfaa76a889c2da0c3588f33eb2055cd21b6e0bf357a8badfc672a47f9a45c0acaaaea7351ce4e743887dd73505485680b682f631fbd63d84dd7091a28f8b2a9318406f0ea10fae5aa3a61b8d099e5a149b4730dc3d42b40712365efdfd73d7f0911f7c42bc1859114497dfef790a0472f201c527f5266c54321eccd66e473403ed9db80e500718ec211e58de61be72fe7fa5e8bef96b6fded11f973056872640c366199b195409be1ba83099da39261975d50d8b25f3e09e42f92554e95f37e874293977700cf941cc2716f365e04f61cf4c599785cccc6bf1b9f688bd1bf6e1bd165d53cb02bb7f35d13e02461c136931cf82869cd188b67aa9402ac13b584dc5fad98d59a82da9327ce0632c4b9d4b7b0aef37dcf9126789e2eb75488db73e34690dcab46e8d65fa03d3b73886f26721f5655c5093d10054b9b321900f2d2ef2c3f48e2d67392574b0e60b5e07e606cb099a4066eb872946fe5dfe2299a029f5e615fa0d64777adae0a78bf1364d0cdf90a695734544c0c7c98856cc764c62a1b377c4e810b3e68a0f398745fbc8a2a29afb68a66961ed8fca87fd1a9a910074a1e9714012eb14a7d450c71f990869319d09113aa21b999d7ca8675ebafc7269af737d90251a23f99a4898ed1522a3a354ebc01cf6d0b1d7704802799ef436870d490160a98350b0c99dcbab9efbf41ea601ea186a02f46ae7f1dacee98116139bbe611f6da2c8ff10ce0044573577acc0be4562c518c6f4a83d5af49d75e1af6db92b38237e310d8fbc3b8fc4340e02e51bd645049d135127c767442e696a93ef32f3b2b9f5115361d1222a0eb37b7d5cf5bd18f6f09007b3b7ff529f0efdd2eab4d53da71ccbbafdbd4ff14f4072148e2bded221fa250eb084566ed7fdcd87de4047be18330e3f69a9879c5019115374cc33ec5c7c2a648d882e05ba76ffbbb65979575e2a19d5724082d2fde6644ceb4407b2ac64d31cbd10f84d74fb3b2c8eda25f881da6231db3b4427e08db6d7b16696c7902045022cdb34aca6149b2d026cf42bc2545fbfba5179f8c7c58959130beb062e89a831ebb94deca402f5f24bd1c398e0b63e5b738f54930b83adb8a497bf77de8c963df789e3836d33e1ec5fa199a84cfa184e307146e8e178c2d9290a32afc1a8bcbf9c7240258ca91e11d0dc7347e37856053c58befff26f86262160753b48228358c3153a2626d12f3db29b5d7517b832663f36a7ecf7aed589e9af35a8a0d9520f399370792e0687b94e59b3df69c48a1dc771c12ab1feb13dd4bdbe26b9e495bb1e50eea4846be686a0b946d9d9486865c34a948620b8277ef349686363af770013a1f99d2adea627d3847eb766dc9fdcfcafcb07bbb6ac13eb7bbeb1facf7c7258b675732e3789810b78a2fe98dcfabbfbd1ae6d77c2411859d8b7fdc866b5b2b7865bfddc6cb3ac11956125d07675ef307da9cda7ac225febc5ee0e42425cb1f3389c71634ec3a3b9e8f8a2b70c62bf8411d9124e053bb367762860beb816321b08c1a6651cd35200b73ce619f074aa30b35e17274b088001c7ff8725d61b26dbb4a537c67d56a73c63f767ee05f4315ae821141d196b80b8be989fce12c4ff4efac66a5de5c6cf882b057a9d4dd418c27bb1e76acae7147c0ce0ee6fa9bedd532469ca17e5928c6b8274b5cb7a4527445a5d5b4773b2ab06beb6981494002e8b32b083428a17272fece6e89efc87e998f14e0ccf73881f08159a1103d1fcd5c51a50353953900175eef4b86446cf4e01fdabd0ca8a1c4dc29a82c6d7cb76b4bb5cbd72139a327c5177704fd5103f712b1b5a236a61facdcc8dbdc75b7d62cdca507ea72ea9b4af9dead5bc903d1a8bcf553caddc46329404102ccc87e176800937dc09a4c7236678552c98a3d01a0d0908d31a466e315d74cbecca3200bdd3c4773488cfe3a2b02937d1f45dc6e73ddf9a3fcac6feeb5b0836354006040e674fbdd01d6d7164b977f96f0d96d9aa71d0c1a140a7d6f583d0993d5e2d0640f4bcead56a3914dbeecf5e14949f024bcea0d2f67afecdbf0d1b2b5176791626130423bb4eeccac9f1a004463a6ab3f84af616c9c158d90a09b4b1507335a0c0a5de6dd254b47a0d1a48564282a0d7784e41c0a9c7e361871c05f99641cff67ab41ffc70b4ec756bb423da93475ff3e29c321587b6b73cf6acce89c8768b7649f72481668f88bbd07def7421fd27ea9758d9cea0bf2a883ddc6f5a760a61f5d3b723d3ce67aa424a1a7b19489517b7eb35adeaa7eb597b477ee0a23f14cf4557d6a6ddee0e6dbe2d797e05b0a8e2839d2df2a00961d7e1d6562b1b11374dc1a4087432c0f4ea6bf34bbcaac23f8998b47eabdbf1ce0811bd2db2ed06a49be846f425dd98a3ccda1c72a246a77716d66b903f1ea8f56834fcc65c791123399355d70b2733fc08eeb5d170dd15da2e02b4759f41c37d47c5e540949030aca3b3ac199aac76336428a799786429e80b39358ace6c0a392e4a265322f4a6f43aba169d7ed3cd094b9c6154d9843cfa4a05ec72153e890af87eaf1693d60e39d31e378a2e9f0b7e69fc5c008dd005fcedefba06ab36cdf82e50a3e2a09707fe32af60030530f43f597ab87287e9edbc9efcffc08e2dae885a0b683152e692217def575ee1a5a792b0b7d222cd73507833f968ddfdfff3c2156972c68ec384901f929fcb6adb5fe85a05867ae13a1afb92d535af765dbdadf2374a61016d37f1265886e2205d722484243eaf1313b2a7258ad333c9676b537a7d8d4093d20ba545f22f0756e191ba37d4d3f5a8fc88c51fa0b16673068a35b61ab408c2127f2914c8110b6c650c067754a708c3ffd29eb98d98ec346a2e00104c9015e9f66b80721dde209513df0ef4cab3700a74339a2491ee6466e080fa4f264e660ee730c0adf2e7854e7a3d5c563847ecffee9787ada7543cad1f8fb809be5584a5af140b34afc6fffc806e533d240ff629ea97b4b4ed83623919b9f733496253790660f6e48f21d66351d2341565c5bca5af9d4340abe571b5ee8a13bd763826dc1356cf3e5a168e73a7b088790cb38af2d81deb99f9f7db61ab7babe2326b38fe2ac4e77f3c4f154b69d60c8cf2bfb9b5237c3a7d43e74a871ec842a76a1e8439c2a156d6badc95348f4f0be2c0f15f7de5749550b6858bc8aa42b939f4e11f2e0be14327d95fb6dbc3b45cd48bf14435fd1eefa514984bf4b940ca6abf9af1b31a1d82c9681e181e866ef931097d58e1a661f7ae9a167a291a415b835bef35a871bed06c29e42b9e7ea87c42a16929317bef29c915b6fa8a6ec258aea3810c495df6500e4266ce0d54156cdb9d1c8a8d9ef64e3e72cff7c264ea15e141ece68bec1e1d4e71d53a863f93ef3fd12d826c6155a3bf358bd8b4216caaf420bd3d564736e537c5245551ad5ed6df7fb7b00c360f0512d3efcee4c963397ed4b312ed1440dddee070635bb820ff7cef46d73e3c47ab56a9803ed80756c11084ffc597ac1667eff359c2d258c8184a27f62484897fef38ab176b92af373af3e1a4b97c062612b368240c16ea9ec32e0db0febb206dfda4ed158d2557ae5564d73be2df77ce46bb3aaea25747445fdb2be8ccdf3636dd5afc2cdc1c45bfb3674e6c58858c7a51de160fcabe53b8d02bf844df93cd331af089580369f75d2036928ed9b006e5e25b24a9821ac8e80a251551c68701be6081f1bff519d3fdca75c8075a2438d32f148e0548e8ab6d864e21ff792079303437eadf65fb24152acc4c8564f7bd16bccf41786d14748a5b0512a15e2ae756ee9a27458df22bbad6d35ac6696c3512f430eb6a33153fd97c3fd7d1d232e0d415814626f8e804ef16120828132595a7027efa7eaf9a9a5f49bfb3d9e6b76046b1d4ffb636d4988df2958dc7ff009a2c45380b65a6b3b145128693df0719dad2f050b3b765a2ca42be0bee9e5aa5ccba2b634245ee7dfb4ef8ed1adcd622b45370fcc476bd758b48fdd35c0ff16ef8825824fb310cd0785f84a08707a61ca9a2325f2839d13b015ccfa535f2d0e67971536b7941cf8ec95725748021c1a07dffbfa50a17ec1b3d1c90b0da92b08381c2ad7dd7706cfb051c2be5c1f2bef7b3f3afe484323892ffa634ceaf75fb8bbc5fb91221fc16ce50dc30698b7adea40cd119528b8668a335deb4f252e9dc90cb17647865ff243668d07b47e3f6b761b274e7e94d165b6de121c07326752b999c332c5637104ce566e1d962a5872683d1cabe1d1d226b978b9806e8a1e84a8a254d7d76faf22760bf103703b2313193f21c27783e0c3b6c0447892c2330a2e69622e39dda48627fa3dc4786c7cc2000cd069f0a08df8efab7f43ad7df2e2e824b3cdd8f4fa5626c866f6d7a9ab9cd946c8e478e3c68c1c557e9d31023fd141419bb1847362f189567d97d154f2719290da6937cf75a95177829f8d6e1df347c79e568f0afe0f7588564d3476d15b21f6002f7d94c8ef99462ba5423e8c1688a4493b882b01d98503d1ab6a8d04c1961e05687a4de7771dbd53a74c7d946cfcf8b4f36e17cfdb0b69d31d9b035e733ffe6db149704823f6886e44ca2353a9e4657696b1ac4b22d2a39d6b80e90356384a068d14b1ac5d6f15735a5b4b98d9729f687f3d4ec4a84308eef17b9cabeea6ee84cf2ada5ff05bdc00d09b3491b01c1202a1b403625abeaac90ba89cab99e8bc0a6e31ea5d3816da24d7b76aaf2d56bad419012ab4c7a8794b85a3dc9f23c2bcf03cc327f6c40568d8e8a1e3bcd35ff867719bec28f7e3fba9283e3b1f5d12a8d2c6697092ee0dfcd6242e799b4f420e38c98d8dd298800b1fdb050818e2906ab2e5463d99b6241b3be8e1cac70fbd00302227b12772db1a30138bc359d28f8adcf75a39eb0c66a4a1b4965e6513fbd7253cdac26b31eff03ebec582e7d7fe8431fe413e8efcc656aee632331c8c41730020eaf04429c6a93be68ff510c9a23c4138c63e04bc2a71bb4ec3b0acf683181cbe5636c4dbe4b65c1d60b31581a769d5fe61d7adb70dcedf227de5acfa0e25600f85196e0e119924e7e5c556dbe44e9d688af6a20e17b9122a08a9698d21d3f95de16ea60928b04d2744f5f93a2d5f0db6ba9ee1abc99c566343d9c877abc500da2f9ea03f2af106b472311c4bdb6f01928b8f96dc2514cc288f002f93b8f4cfbc692c779d3dd130253f8776764520a47bc9bc4d865184618ef57c0778f9723950e99668fe8a8bbcf94e2631aaf9aa563d3d77d095ca1d2b49cf30ee53a6bfb949dd3aefe07dc78bd2842f07779aefd3020629d9301d57dcc8bbdaeae08dce1b455fedbec0114485c03a53b5f2c1f2c16c9567da149a3dbd8abf6d9b577265bc025e227e698e3c1f3b5781b570db717bfb5ba24e2961cd60d1139a7beaa692bbb954b07f27b3ab241b867bf65d79661bf28dc1e0b99fb0d31136bea0deab8274970cca3aa44f66464c67446a3b8ae9a73c45403c853de83325b89c281b57851fbe26ed6c3b4aec28d614b45507a8e4d57c9a291b7a8882738837c2f5f5b96c43f1fe089efede764e74fd6b726ba20860447cc80fdcda4f165d285b67984221d717a7395cb201c9361a5b2fce825dbac75e9968e9978353c8141eabf583935650c5ef0f2d48a6ef76cb5f52d47e516cf533318f4328384069d60f7e276859a9f5c1623998238648fd0f5f9de90b00d7ce8e0c490db303906173b89e87c892184cf38feadc53b9b9d2bf33013ebff080d583d49f01e9a8cf37ddd3d9eaf3ee12e7e2d2c49e1c1a2d371c79ec72ca27f6aed250c05743d46696b875ff2fe49370434139d703e951f9efb46181e6f1e91e62b51c3912d705df50f13b7e289edf0c5bc8a58994217be5f35dc4e8d2ddd4c135f77b4965712cf6064987e87f01edb26dcc3d01434db26b5705ade8af102b13f98dd8210b94a3966c9527429a4149bf3fae3d6afa0605a9eff22ef797d094a3470260a1100c3dda0aafe3bc298970ae57745198fb229d4f53a7e28b9c0e48273302580e691569c24dc0d15b6e83cb5d25f1ecfb64c52498daba8369754a46ad6ee2841dd89b64139063f8d637d28ac7ba3e5c343c2b7f4d498e35febb13910e9b41d565ab431890fd4f46ee3dcbb80ffb94ba70d3947efde2195f26be768162a0375a388c60c741e6ebb02b647175eca6df262b75b45ba89bb9450fd85eee09746956b7e9b89ded438c9464b10d2f11dcfe7bd3fc63678c5a0ed1c3e9d86b6a39753e6845effc2a98f57bd8255b2b9b7e03fd33d372394877a332929b880d35beef16691cb72862609e218f47a0f1137688015597100db7451aa3e7da1a3b8952944f22a0b6dc446b6f3067a0a782bf63fc8f667cf5b54e6e3c665d00ea10fe49349b2521ad5c8751285ac28b197d4f2e3163708dcd2f1daa5f1eded591396836ed143c66a40f0edab9755d58e9c62ed522194b865636ac47992ba22e4de396c7374e6c9f63ebbf4dff2ade7a243b59ae37a7b4ef6ee402a8f39742e6b64d58f3612afa353c535bd3a4e90fdb27339851c5141b74cf0df486799cbbe0da24acab29dcb4f79b4d32468721d3181bd34fc5a1015b98196dd1e350e9b07bc07a6b490cd8722f83f285291b51811dc4728ce4ba9c1c8e34d864132bdf713e8fea53f944103ca30e217a782b154071c524853eb1037bf8619c2601b39c8696d992048f28df41c998cfeaddeb9588c764a4fb219e9112c3d6e036dc0aa35c3e71f16f5a9c4b53230edd666b62e564bff177016e7fcd59dec40a8b6a94a188b701b8432abbc569d3d7f028913d02376b0ec756c13fba5509fe6dc227da8b3adadcccd441c9c84ad690de6e927a4846be7594eafd007bffc995e1a30bb6f57822757bbb48e346d11ffa990a1bf7f80297ffacf1e90381a17f6dbfbb6b51fc01f8127c016ebd93816a24f3940f53d26cc9bf2a6d5b93ffef058e675c465281fd5f622010fc48588a02aab80251606c4d9f2ed936c66e46b4cb507832f2b1df5637d9b000db4b8b8afe500556226f1969631f9d1c00517a112412f6443f1d140bf88aed301e96a1df86c5d3563adec3116210ca185c679dff06c6228e9a41dbc7978bbeff59b41be71f6522b0b0c6366d3c5947fecb124303b213b161acc0dcbc5e6b75546ffdfb9401d4d43284e8430e140c6aca51b7eeaa6d2856aaec01cdbe9963b8a8a68858a687c52bbed32622a24c62902a7b00240f13caa426ec7884599eb1c6beff9082d8656cbf83c0ab9e537322e22231077d47d3ecfb047f55a280e098eff4441d59cb9e33f9f0e75e8958eeea19f108cf5e1b78cea2b98b541cfbd67f42bbb3f8dc461905a49fb0f8c7e288e58820ace29e8de2cdb28e34d4296e04be7cfbfd2a8f9006600a4b4f22bd69d794e12af300dc2876c8603eb470d5509934caa60a3435dae59b3b222ded32900e836e0275878b5ab3544ad515a7ff8761804b7156c1c160ff8c3e5e33649f7550b7e2646113ccf25ec8c9b58fcc453cbe1c3a96e522edba463aa432da1732b9765053359d279bc461b975cdf3bc3c2f246e6467123f65bb52691491013fb63fdb78484912ca525f197ef148a2f9295ab709f317e007720319aaefda73e95c6aedb4a5eeb7b6109664e45620d887f13039745c91d11b9c6d95188ff119d8f60f55541720cb7bfe98f7623f0cd7ed67c25a73aca5a449ea670464a228ef5909659f70b63927eb1f28aff2d4c13e0ede6bd96590202987e474d246312ddbb7d5e178894186e5a14995cbe514f1640635b34a508c297160c74d71beebe0cf9d5b23a687365097c767e2de7a4e3846ee440aa245e61b4febaa3a1a5a11648e05cf8c50a193354b36d8e20c447e5bcc616e073ebf6fff368cf19fda201cbd7033cf4dfe796ea899cb9cf2321dd3a3161e29af95aaafd546c9f70070eb2fbecb873af1d025ad1bd4a3fc08754d5ade9a0c068b0c9b96dc904d5a98a8852d6c6a85f80dc6ac409e3469b9a12f3ffb3137906fe4e10e0198bb7be2dc7f62c0f945e2c7d9a2a9a0f041943c30d3d387054cc7ecbc80591017fdc846e2d504b7acbe8f5aea9d850ecf53e066ca8ba930fc05cf3d79da2e840a528cb905084570e6f401dee324e23cb859e2e416806312040f6d2c94e931a895c59e473910091425adb5333c8d2d518bbd691b0abb4b056c3a5deead3cb5cdc3884a2d6042e916d088abd8c66fe2670347b0714127829bd23efe5a6ffa55c69b38835d9a6f2058602732d66b95f8013c8428fc685de122a3a1d9371240fb4d92c0a606677805e9066f4fd931c26e66734cf40f85b2ef5db87a4fe0f06d24046c0e6d3b523642bdbb233d6fbea4584b6ee7c7a04109ddbdd2cf121d6402f17bbdc34f67d8006934b40bf4ffd1b6a4580c090d2236074c09d8b5c2fd44f994eb48afccba7bc62d6cf7794b24828029a215cb2608b6ffa2187ad310d587e33f2553636865da2210a6f0be7e8b9e660e522c60a6de4020bc0de21ff6a771ad5bd4031f6f8676c5674752191e2e443eaacf58f51da081008abcb65ca61c9d8c33482a0ebf9b98220146c560ebf989c17088e1ee909d9e6b0b59285c0bf5d49186a169cf75abfc52b59bd029412e99e9ff94f0e67b6eac63a23059d06e6167ce7e72aae3c92bf8ec4e52d9144056e16cfac8d6f0c823c1bd56684fcb121205cf39b0eb832bbb716b75efb2231823de1ce170c85d2a4935bed440b94a9b47d35b8a0c2d8d7d9c6158c1c4ae3e69ca2a0d460c2f178e4961de0840242598e7409f13e225cb9e67dc872c5ad95b5d9e5b8b2d1dae6f064fbe9ff3a431655182100b9a0ae5a58fbb66702886a7c2be0f29308dcdfe5fe4e7949693c7c369cbb3268c8828f66ab7a1c66a3aa2ac53770c6c350e5361dc367f68d72b3107211420635ab4fe2797bfd364418d5e2a94e1b5183483dea1981042a39286657a165079d23962c96c4a56cf849cf0d6d8ec61932d396b9bea49f904dba1ad8b05fd0cafd6970418b5fff33c85cd55dc2e744d28dc87890a7f40570337e1d96bba76a8e9cdac083838bc35310491bb6dd9be92291c6a7bd4c094f517ae42b07d9bbcb78da2a27357181baa4e2d79c2376148e3ab989be1ec187978483a786d5f700858581924c2b7357a3bb76722723e6a3aa1b592fe1d40eb9900872fe84e6642d4999508a3bc4deb7b6e78b924badfcaf819367901382af8beef051fab75725706660ad13f50a0f9a1879746e188b3ed33208b2f4d92dd84a6e8db050ec08194228a71a6d3395c28d4b97b22edae97214add9023e9da6ffc762c268ab7e7e86568779880f90c8d9b73811976e4b14b9b9b488d63ab097703f423e7d89a13d9ea635daacf6162e996d7190306b1879dc76135a74299fa9aad5a0d7eb1f7bcba592b95232563a736a4d01bb5e29dad9d130ca2b329f9703e7f9e35798a6a01654ab104a3c61905e8e0e28c27b3fea5837b0087ac4d72662aeb5e8a1d0e0e73346732266f2d33cceb96f03a2cb9a88eb726cea86859dda79a746fd895a80fb62c4f3b802dce13f7c6ef1d63da78ab8af38e5bb5f8da6057beb3404c18bbe797f04e4d0618d39c95733fd8351d9de310785ce39403b11d6c8805de39474d61284cfacc42f041234b0d05affd5f48afc525b51238553a133242dd54571f3c2eda42c0200ca69dfd1f7b8bbe9860627753a373443f2f5aeda0252448d4ea1760719a6a52e1d1f9062d7c34079a4647b7d06ac8183208268638e2c64dd6ba225a20e0d339c2543028fb94ffa12fc01fc05401e9e6a98c1993f2a2c4ebb5fd91e17f3c082a3a0de72b89b6b42e601130b90566e140e8a9eb9f11587f0b15d1f55a6ecab4bd373d5ede3ece9776033ffa1af0b90115e5b77327a5734398b3b8973af42b9877749b08823714ab9f651d30a32f4928d39e077a088fe3e4d7b86505a9474b8b734041cd9c5cc0049ac1f0f77fa8039b8a88bfeea9bb52bd1f10cfc6570bcb89032e0b8f2bd22948be2c72e64263cb576c3f78537088f62ca8de2e0176483b69357e1aca7e776b92fb4b1614a29942c5655eda7aee0d37d4eb8b1dcc03a285d44b95194506efd8b0a18de5fab9e92ce1d7d16c88240cff7a7e09187809cda9f0167d482e4c6b32759814dd2c69d026d32926f393a550ab93189bf001feb9ccecf210f0bcabf01a8da12cdfb4f2712bc7c9f0034609798628aeb12b476393464aa188fcca59f7ac190f35cfae8e6843604eb2441eb82b858636d174c345e65d54105a804060622091224d2cf870348f895e33c72c88dfe92f5e4f6ae77bae52113ba836f20dd3221fbc221e238d62ae7d3da106f0b0ebbd9cdb279045aca08c8e97c47569722de3d2735f5cc7766d8efeaa6b3894bacf4df764b48b359723328566b6d83bc8799d3763b39717559d3c86195fb13157265c65dad1b2159567df6516865938fa68c725e81b25bb07ed404b324862b478de6aaf16acb81b12133204b154889f0eef5eac652a17386cf8434e25df0268859a45f3c1129fd2e0a6f9b54b267376c1b2291e059f65fbb97c045f51ce98272fb4b2fbab2976c7e138ee78049e14eb5677521613038cf6e7066a678f4669564a067b4a34536981d2f8b126213aa1c4b4abc1060968e152b45a87e59191b6c021ebfb39f826538cbd5294180277549c747fc2f657c8ed6632f59e99c0020e297b2888f3ab94111b12e1491d2bb7198e0c33d9fb8fd5b4205896f1389d2337f7f19cfd14d38b3e6df442bcb38697eb19583aea87ac028fd54ea168af6f22b4e2831019ca2327f96510b75e2c6ec1693ecf493537954d62f9619bdebd478e5a4925586c6b1013abb26c42b2a3fd103b56593bcd9ef08de7c068924e4f3e1fd603c2886e343a2982e083c95d312922c77c324483ca9728ca5a907c911a221ad5e96e7224fcb3fc1359f44d5ebefd0bf676e7aba8b1db84337b204ef8b16087e1ce3c6be2491bd0513a7ffcd19d922fb319d1a018e80d805eaf7eff5cccc94ebc4267e8a07e7ca73acdbdd5a79ccbf995c39d5f8871b41f7265d7374418da9ce739d29341168993d54ad67e2552fe4d9a1f13cff0d57e7dd36f8bf8b5bfac4605e6425e65b3f24d35ae2041c8ee463f3f81e786fe3055201fc9e13dc289b438cbe83ee506c17f5f1496c768526a32b5966e9ad509624ced894bb3a0e959bb3b9643d40a78e2a8e5e500661d8dcee9128cbcfd6dd9f5095e4822e6209da704fcbb9379628c3f579e7c136133a81f4bc259f1c38b72bc2aa5e945ffc68532c473481ab9d82b0fdc87b539c3c7c953b1c24a4430e3c0f9a8abe6bc258d01828aad17f09fa70a24ecda91f55b9379c0bc85bc62464a21c01e8cb51f5d1bd4452eeee7209a885d460c0ce78d086d9f3b8081ba7be1c520a6faa5dfbd9303221ba940af1181257c94c71a5158f8270a108783fabfbe8a0b82b61b5ef7f72ba3174ebd2e601c0e042a0960479e79798c0ff4bfab402d0ad02076805922bf0293b61883eedf66923ec234ed30efe25ad61cd6efc63b9b2a94a318ea0b83b29629e598e49d2466eb9dc8dfd6e3d1958810aedad52bf71715f4b8df3fdc8eea0d093e99159ddeaf571b0ea3aba4a3dd6fe27f96d81e1a121ad67db13cdc36bce4c5d4edbfbde435317143c15129cb89dc57bff1d8a2fb58c8187805172dfc91c4ba0048dc3559e04cdff5326edc655b4229b2a6e153de72c26a27597e9eba7b7834a05e952b7ed7c2e7a4f44c551f4a48365b3661e738cb56f8fe6cc10158e5fe5002a8848baaf124228a6043303100aa525ba5d1616d7b902e38476a36926c01d77bc27449e3f0c85c60929a05a36aff782628cbc6aefb893842c83c63ba862f470dd926cf7327e3df52c36a8cd5f43224db4b7ee03152930c8eb22d36572257f6c63ad44215ebbbfb054cb703e2abef50ac6d58dcd09e4b4194a0b86058297e65f7e35d47482f534afe16d08f1c1e4907e9d692139c8e71914a8acd607c0bdba2256b04c44d421fc20bad9d398812a8c721f87c434419bdc271c0876e9690123c04ad5fa4e3e53529d70465757efa70180aaea2531f454646757c1b806e8225354229a4803ffb2ced3ea1bdee17e4025251e5d6d10c929fd4db0eabe9d8d1b76c3f757fb7c5cdd726ad42404bcc46375064b638c821f742f5057dd29a3dd66bb3559d1a132f07f05ced6c4e7b1969fceedc41ddceaa3f5a37d094afb351c983cbd3f175f3d7b2194b5ae5a1eb7f33e189cb12827d0961f6ebf3c08f71e64921f5b930ec9ebbe6672096da786e35334c99d93686b712a4d786f19ede576b0297121ac95ab9ba4bd4bf1bf62d904d70b293d515fac6c64f3889f88ecff15560019bd6a859c597e698cd996e572709a4e74bb144f7af7fb3f874914b3c9efbd890f20999da9520d1d6ea2b5c0ca83f3e490a311e755ffdf34fc79ec7f2fc9220504f12050b3d7f7214d7220d334c83ac9681e945d0607b92e8c881d0d4b5ff47f6444aedeb313c81361e0dd0dddb68d34b780c006a483121b7951e54a5d61281ebcf2403a54351ce5be36c48ff072b5710fdd318a5ab93eb1ead243cd11ccd1b336efb29e18c16a3a0bf93142a07276efeaa9f202d4f77bb9a42e182db92abc9405f001d21d37f750cdd2992fd707afa671c4e82139ce856ea65341b8b4c353cb9e4fbf5f74e0e866d9edbe4112b46fde6bd3adf1b65cf4e6dbaea40f57f4a47e2da7b9441659b63852e5a3ed35125a3c23acad9458713c8b70d95e4b3b610548f920e76653cc65e0ab820bfdacbee29eb827ef93b93f3fb90dbda7f0011c8e10083c7e57721f3b1a7cdd75cac9dd5c4074e43028c3ef00314cfb535c816c4cc8de4963c2cbf2b49f38853cbf7b68f3eb6ec1a72bfc676ef333d02efb75c5395328a8a90d0f0850b81078d032563acb094d79132280db347e32eabe7b6ce932fa255cd819d5a6e6ec22e2a8a652298359bb1db80532e5b28d3099d2a335bfd18dfe9d892551fb9c78ba18c098766a20d60472214598731e53011b2e77b42b8ec4a5c007ade935f57906c5ee5123ba469b141c372e8da13dd49dff23f92baa3c0aa558fb9c3df0f47c0681b35527891b8a580a583dc3ed9dce9e303943ec8dba256c3bebb55335c70a789eca9d1b3768c2876827681e2947b1f5e6969b64c5b62811cbd28c8124e5270568699ff21dd20774e77d32b1a48f2b8f50e3a9920d745599f96a4629cdc17b61818613be5b2e658002cb258d9d8cec72c18846ed1f061318ef9029ee8147a714b965bd51d980750196ae6e359f705b72b24a6c32755797cfbd2e7baa89cca49eaf6c31b9db4e05c58e59ca3b7a60a6079de8e4b4ed6cb504bd40ec912029d69a4b3c885d7247191700bc2bded7ef9e00f9109b6f4111a264221d6aaf05bbef11ba8d12edcf70050039b97a4f0b8c3f85d39b57c92da888e0c11d65879a5c24ae364a974845c4463c558f25e19fb11cbf67167ecc439aff3a055a14491ed817366e81d04987fb0815196c4f0ca1af98aaa371b5497299c261c3de19a0ccd566211b2342468a7147d1f476eaeb32ccf9897c9959ced3e746d0b3c5a768e6f866fb1ca93b8d329bc14af897d35f5304aa3aabf20ce1dff3f8c6eb4d8c370f5155e36de61a96ab948ea0d8d3c505b847c6640d72f2afebaa344bce14ce5cc67371630ed4c0f9026a07ca9191714366c4a7af47f88ed1734d8a52943fe4b49116840cfa8b08a9cbe0516b201428b1eea19db5d293b8f9ae1607527fe3e5f98b98957b0d69d2284c7741d9e6f0154fc2e7dcc6a73a361ba2a6beb0d9aa4032bcf50f67f0a436f7163af35b750de957f514fb3468c9300317c407e4e6a1c722999dbcbeee72aa3d47c41bddc6bd3f0418f590d3b4f7795e22e31d7da4e6a18b2e6c295e17990c8c4427cfd38e4c31bdbf70bb7944a0739c09ebff2d847288e0387d08db7a778a3555631cf96701db856727a79675ccab7985278e805213319af8e80a74778e6afc83ddb97701298234216ea5811f1db37878a37174dc3b5c9eec4fcd950ad93ba9a246f4c6fa2883fa223b004e07646929051e91d9d696b32549f2640c0ddaf8751ba273ff8b12e2811e93b5daa4c1e28fe7d55dfc4610c6963080d5b2813de411bfc5207710ffe44671a56de061b87f96917203edb4cf1f22087012642da1e2c2329ce6b73a07aa35b886c2491468e84526839ed3852ae0527ed806b5260626a1fca701d5928204be91f39f082dddc3e23112228e0317e18ba64ee9da4fed9b413b54244ddb02c166f1d4ab27fb74c159c73c11c6e25ade26366d3b1853fd3c4cda5685a8488a82fc404e3eeca47be8bbfbc7650417013dfea3c32680e4624011ece05faa20da4debf77d9416812c8f7bde7b563cdfb5d58dc9044c399ad7b537893662369e9ee14fd0be3f2180a6bff705a0b71c5f0e09c9280ff5c0f9e210ef8b5367aed3ffe2902a10317b42f632f3890b55b4874fea69d5e0f5918fdce0c8d9628288009455b55ca7aa1ae96ade252d3017a0ff0eff9c3376d247c8d1b2436d4ff62b6666e666be68fbee1c570d01c0af475d64e1711bfdb081a00fbfa4edc16687d06cf5f24473d7ce30671609d88cd76fa5770a45739800ecbf3c857fc15999bcd1b9179a8e18f5c511305962ca8171551648248a6379de153006314a8bd26755a7fb5f9690fce3dee7a35d6bf7c60be2bb34082e00216056758b7ab0fc3f904072cfa74f2a45187ce7a884b542bf716a603145a9b94d1e497eabbf78859e10c32409e3c96132cb53e088015a7cc46b8c5808320af6810f8beec577a919f2ab46c9bddbfbac451529442fa98eeafef308947d083a9bebd7702be68e2e837423623f80ffd289e805337bb263fdf5218457c77ab9d2575850bd7109a386d0d1c99f84ab0e3ea5a84c184ce27ea233c08d055030b5563298676c116e43e4f3107efba0c1925a65840e8bae01d9ab40c81732a1295fc42f5f9d746b363bc06fef11d9b637c6048b6c431c87203e569c33d5f2ac82e55b3ee1d03136a7841a17fc33158c6ce252f1662616b4f6db1d5ec2c5bfba7c02f1f6ff5a435ea6574289a9effc03196021fdf5328bc27b924f17b764830b3cfb0e5ad955d74e36e3abca2745463157ed3f0fc03e81082ed39b1cf5bb08caca11c8f1bef0d3b9b4ca49ee34e728c5dd73d0da707411975d748bc41c919b537e29835b3b3a563e8c3b7a49ae307e034613bc49df2758b62c853b9728f32b491642cb2fb2295c78894aaab3c3038ae1b8ad36a70cd89ded4341a5e1274b4e89ab4a68499fdb86389c96bc24a95abda3f4f0a60965022227a01aea1b6f067bdbc1f636a029470a264d523fb8d3a740f275c6e488b86d5fd7bcaa1b6307c76c229a5134157551f1c30e2f7e6e0088ed3a3ea3614b13460b5e857e17e69d9ee73f264dd390ae0b16ddd8f65871de8611a881cb2ddca37f8e0fe923d6dabd33b96aba29217d220b27aa3e5b77a766dde4409d67fd92f3327cfbc5009cab529b2f779e6fe75f8ef82de67e462d5c48ed790964b77b525c8d50d2219af0bfb052f39d6cac66943ea3e08529d39f694ebaf014af900992cb0f4f5b657799ee5f5ccf2418bddba253739813b061114866b498b1752d1fbd23c5c35de51c9805777db6d1d14df22619f3c051509aad4af6216e36ed99e122d9f726634dd418583f1643b175de0634f60edc9ed318dfadc2ee21b392372a7663d4e5d4f62f0c56b8e55e57ebdb240ed14c6059b46636506ba38320b537bbf14bcaa154f2a5fbcfa9a9fa2f38e7e67b6b4a92023f81f5db5d0683561e8588fd14f3adf3a3036caf7badb737e48ff7a759a45e33ec59d84ead232994f49e93a7094fcc746d923a9ca95c0e689895f897ac4421b9614f28b8f2b257b3aeb0ab2943675972d155657cbbd331ced131bdaba1af92d96da3490f2173b85d55d5e000afb8457f6e98875b4e486d3ad2ab4937b99f36fcb469650e28497f6cbca341a16adbb55d076a0f8751ea230a290fa5914533dac2b915330f76801d3b5b6afa01d5aa7c7851d9e93d858b7f0a867f334d0010f9fa9c0e5015d28cc65bebe5c276460799e4514d434df50fcfb8ff50138a27d91de656d29b2b4229086cb83315a7d202087dfe499c128c655c2da511346208ce31d5a309dab67bab259823d67f8172085ecd49cb486299d81b624b412829372967b972a7d8b0932dfc3acf48d20ac8ea8aa380aa2dcf1f00e0c248073695748ea4aea8e5693c4a667c8018ee2a2cbd82198e98c8b45c46a3d417424421f681d75cbc65c3a62256593bfb883c312bc830773386a5cfc18693deef3b58c81d56547eca2c36b3693b56b823301b2831c6377e0bfe6e63eb1e7834a22634d4d61e1120fb68e4d1db4ae73e50eaaea2d1e2df7b6da8a4ff837dc0ab1c475b8d4e86171a807765ee15c38fe3fb28881356b8a0e5137d1732aec70aad13627959d8c7c9cf878a4be507030f58ed772e2cb813f6b3ebd138d1e6116ec319f72e91cb1593200d670d6d46905fdc0ea81b98ee4fecd5d4de95f6076cd15ba45627296fece7ebb68fe38ca5ed1c2a3abc9e30d5549d0f5aecdc9b1f4a04ea3eb720a92563a29cc696ab0c525efe8abf588f8d125cef93c7f58ae8da05ab111fa90d4864bb88b4da99eb3619f4cb6018409de9f0cbbc5370b6591056f4d17df449089e06769cfb95676c28bc7a8f4c3164ef169249733d0380343b0af2958d65d18dd71ac57b323035912588effc46b9ec317b2f6124f865162d5e8f3d57b981fcb4aa6a74cf2b4a34603ee503e14c44f839284aa5784d7451b523acd935ee4e373ae5aa46ce05197d83413abbb18ce568fc59a0482d5fd166da7399c8d9a9d3a3c3fac951969a1c566c5ffbbe5b4cc71bd7ff975a15f7653b7b36596f9efe45d0d87326585dcff089ad223df39e52c18ac6019f0ded44f8a00fbe5b5d7ae8968e3f3b0addb046eaa9eed7e367414f756a9871092f979b079c1de34b32e7ed9ffad47791e9ae18fec0b0cff45e5e1fed27fceadb747c38dceb7d423fa766d7b594cc60a771a2fcfa54cc608a40ee3de9d6ed610403cc587b2b29312d03e781bd7ec9be3d514d04ddd9e1b7c5ed391707f373e6136e6ab407ac59b8042ec91b452471ec0a1e3300352c57fa8d4905a6463999a4a21d9f17438393d846e947e37b3dee99855769ecaf7c986ea8ac592a64dafc070f848e9f809342514191b691878d694d9ee735cb9bf66e487a5852cbb96d73c763ffda10910dbedc47cf5328d181eb5ac6f523f4de2b3169b38ff40fb4ab732ceb159ca7458523363d9d6fb63c46eeb1cf29ff457c024cb4f88c049835b341de1a0576890c382b87220745f90c0b360fa0344a6d4f044c13793dd0c9bcb23117b9061a9f4c2a1b33ddb708d692e719c64d16436b28e1ea5fed84a2da67d90343bba74248d6892aa5569be4a73c320fa58d3907bf6b9805f434160cd0fe0535e06ac8038d041","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
