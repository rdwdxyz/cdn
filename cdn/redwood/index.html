<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"11c47fa3ca7573eb0d9b9d9682ddffa806caef1643ea8cbdc726f70b0e2585ef3fc60631ac0cfc81c395b12c419d8c90a2b816278d10124f486df5d5cff37e2aa50c6cba98805bd057bf17ab0b8ce4050d1df65b0b03c5fb0b59b0614eca72b1be76cd8c5d2fba3516ff1a8c832b89809dfb91f0e662e135963c3bdbc46c3798e987159eee7033f27e2971b08277cf67fff96ed0ac2459ac5c12f52642836e87694eacaca55b095bfb7e90d6a5bb541551940169259f37f6040bf9f9f4532a415fe971c13fdba8802444c13aae91d0c930a986ea9230a257c6cc4423aa9a92e3677bbe7faa724c1184e3dec3d9ddbf1a0fe6ea592a2305f5f84fefe0649486a2de9891a7a0d2d296fbb8258908e97a4010be27c86c0b4ad4eb6c8dca90210462cbaa5e4fc107700d314c9169a6727c024ce7e6ba7523cf4331ffe44aae98e7028751d66d19d96c5ddabb40bb23a2a610482a3984f6419d69efed6a3676d43d6158911a2247463055506251cc5cc1469ec30b5bf247de86b325787e49161d81c0980509b9da042c5a365461a5c516b995b6f6f3dab42cc2ba7e23a2ce1ff99cc540bafed00854abc8654f263d6fca9f395a66e36e39e613305c40c57cdb6b0547e8d94144c569f7418738e399b0738d17bdc49dc0db19a48dd96d12ae979afafeae49896b4528cc8a1dfd03c7b2acf00a1d86198cd95e1d50135c4cde1d6f1efd93970a7de0c2693ee31cb6219094ac4965e086096d4eeeacc1d6dc07d393b6710800be40faa1f2b6228a56d1b6ebb9896e27b2a94716f04802ffc44e20190b8750781fed74df01cf0c75f578035a3af44327caaa0c35c95da42d5cf44b94ca11397818f4fb4f7b45c076354934b9f3468ed1d9c61cab773230a195d18cfac7b413c7955baf4f6ec39fe47fad9068fa44b51b9cfd978cd73c81482e693f980e5285a69224ab8b4967dbdf64f56066fea2f97a154e5f85751ce5fad70175fbfe58972224b5ffb6648ed5db048ce342af8ed928b328bd228245353963059580ddbb40b8b7cdf2f0e437e4330e4d67d8ef5b409cef12287cde31df953c5d5bb3eeae48ae9ccdbac735f4bfaf404325ebae135fa596ab4758637cdca2bf7ae3061c81598960eb53b22e42c8f774d4057007706240ba9f63dc881489d3bc2d5b652b8ab842e17db91360e4783dbe03cc7fc3f3f5cb6db5a418b62eadc46abef7b3f72efd680768915cd3323bcb94c736843a452c6b2a0e9c903edd13a5d7e282ebd9612bfd8a014af94fe22263123e2120a1bcd887a91ea8b74375c5cbc51ccbd32fbab6fe469e600bba6f603360b0b3c15ad43067fe1256ad8916a1a684f167292877f08199a98f23e995afca74f533a26c79b039d1c0ca996e4244b9a0592d2ee5a5bc5b1c41d19eb7d61ee156b1b4afaaf78a9309635aeb158533f0398584227db4fafc8f6f594b4232a515ac87ccff098ed01cb47fd734aa8a2f69cea4c8bd05386698a55baf56b52d2c65c3cde40449ba568cdc3871b616bbdcaff718628eed13cf085d3ba476754579053602ad93cae4a943d6bf6518e39ced6e50e9f4c986917493826b3faf100352de8a6ff933f0c49a15060b9274e9bfeb140bbf61440fbf456d158c2c9da9e3f07bae5298884c79ba670d7a7e74d2d385eedd6e7eefdc64ba82d7d600f4ab053d0f2f5e6ecc1774cc6c6f377fdcbeba998ccc4a1c1413ac013b415e44bd8d89df254118a1263b138c489ec7a6dfddb10a37c11905eb0762529f945a01d5a3bf3e002cb74ef863b055b5c6e0d79ec20864fca50dd1fafdd3ecbdb1490d23d3860d0200fb97912c8ce4ba1f19253cca05156c24f450dcc8cd6a7fe6068de6c9c330b3e5290cab00c1ecbe41686ebe3445c5e387ef6628cb7b6c94a53944161aee7bfb11113e5e6555afcd3444ae6ddd14b6f6a914e8724783301856f6299341d1ea49d25aac4e96e186c7e54089eca6b28b0e9ae109abddc5a5e84b8137faddef29af25553fd3dbd5ae1308da2d735f22377fe12fb28b7ee4e1bdd9c33399291322dcc481c0cc3eef0e2c4aff85b3aa4bd15ccb78cdf9851063ffb734d684428c8ee200d221afb167fcbe7d9a2b883626c5422c6338d81db941a5f45421fdad051ac2d781cd221522bc313ba8d3c521fd7aee6efea86dc5e63d110490d57488e0c70b3d50f94ab208dc8dcbacd1cd57a8f439459e8256caca9d87227dfc029c914721c4052b2d0f70ecb3df815f57cd9213e99ddd7bfa2359a58ff881fb12580f22925d0d84b9f507dd3c6e692b883543af7afee49bef7bf5cf49f2e7d46f790760bb8357952b43dbe46434384c7006e739b53020fb072b4b46c42e71a59549c4cdd100ec5d3d9a412bb83ccd098a90871bc3e0b0db8026ec001f2bf7278167e3f8a6974c2ef1f68bf08cf4b6787e24f94e37d1a2e0cfbaee3939ff056022ffeaa31a6886597c8cf2f70b7a2651ff4bdcc474eafe1da08cf1b9b6c55946a3b8b06264645dbcbdb709f779c9fdc5dd387b488c212b4bd67b28c8f24fb61c349ca5ee8f1915cd897fcc6f4088331426e47e451ba447533434ae0f737fba91585cf49e83365e2ef5600bb0a58c122eefd93080449420641d8f4e9d808f2c7465be353c2c1653e669c39ed58e80a781cd5c2e5d688b09a3bc08162784dad3ff8296a3aaa148012cc7fe385d88e1175d6becdd98a250c02a979d251a77bb700e10bed2381c80b4dfec40b2c032a89434b84195e25cfaaa3cee79b5c3143a8fcf1c8f1b48c6a1684cb9a9797d6f90fe00dcf1b3c10c7f8c5e412d47a155686611e19b26ea22652729e81d268f3afda736c325e97221584bd025d48c6aa599fca57847a89e4b396386d3794f52eda531c89a392ce4b470a0175e6f968a08edbb74273157ea8435e9c466a935de850f42b0642ad8d801c500b7dd91d11bc2c87216b605d22a13583778df77f0c7572ed2b99d63aed8c5b4a82b73cd74670265cb0148d4ef76df2808a2b0a55df69ce4c2109e1dcb37de08d53345a8a6cb42a7a8aa9029145037f25a276e6a415baebe232b17c8c11a26f42ef3133752848e0ae0ab0efe88e7041d9525cf329a63b6756993a9e7e8b36c2c10165ae02ad83a34dc90ce6ff69c3fc22c5525517a6f19a6aa3a2d077948d6362499ddb573f1c8a6eaaa9611be0841e90c5bdcb23d9487053fe17c44ac0e5bad080b8f67074a5de76e7840b417a2916590bdc9ead6df4bb1a1fa3d6d3ba1856d527a4268edd0a99409070804a43cc05883df4eaa5ef6f69a4ce90cf6712b5e9aff94306a6e018a13f33fa7ad814ee991e917194532abd773c69aae75b3abf48c3f10a6f925594856f8aea253d714fadf1f56afd3370b4659f3f47323f5a9b6252cf18693d5a9e31ebdef0774f069e16797715fe83b9c5dc641cd97d255f69b6c7bd4e88295c25919605bb8fd6759aeaf4a987b5be33cdb28c02e6004069992045a0af38f91425d564158f04e3ece829e4cb9ff9ed1ac36d2905d228c5702a5c7948e838bf3e34fb50f3969f149fb2bc744de14809965d6a6493e21916b354331caf81e85ebefee638e25ae5ae8d891a63ed30aeb159559b78e402cef0c159cf3fbbca60b06cc66f750fef051ceb67091a5167e26b99906dae0e73bc344d4d1237b2c1fa785cef7e07f556117be755e74ebd92b600a9b7fa7fc2c553d05dae7db2ce0a509dd4a3590a44515806aad9c231280d2902d00056a2673bbacd9fddc27833c4408915d4284660127e589a9008d9fe462eb07ad4a3778b06172e5c231d12fe993586cf716a90209e1ed3530c57205dc664419758edc426f2e60bf5932624cc7430b44d24ac84eaf7009f11488c9ee9bcdb4712ac7e47b874552da3fde5ccd086730f37958be31d747c1cdfe1f02656fd0d88e54d9ae6969541e4a11df109f0cf9ed1e481551d5d6b21c542a6d40aaf6ed47145a9ef18b405fe0966aa70a047381e2deb8cfbc88fe0551dd563a1e6a5ce2bdd4885832e6526965b28eaaa7a454ac2accf74c3ea11926da680b2b66658805cb3da746ad43fa3a8f7efbcaafca598122dc698cb19261abcecd9ffca09602ca49ac1e39b671ffca8d3552094f5cf8285556245ea4e767fce4d3182c94399648b630e3fcf320660fe91b047aae37282ae92e25d3215bb847fdb674cff24ccad7a9dbaffe078db437d332c0c3224f180f459b8c732b33db711ca93d6495f9e52d7f9f32b86bc4ad0ede327a5c70bcf4fc66587ab9b37d33ec5bdd5e67313778f9b9c098be9052b0413288309453c20684e21afe4d7c5a00321c6925c0154d78528315b6a54ad9f08985f2804da449e317e8394af2dc250113e5864b3178297481bee78d1a0368d44b2be7c28d8bebef7d4aaf667354d8f8bb48fa339a6936347162cc0b54fa81061c834792e50028a7709387a41ce9d6ee841ec65411ae50442c49555c0ad02f2596678c503f389851a7de7d7fafc486fe9f11883120cffa045f4d913adfefc0404b2066f8d87c7979e82f7a40f7b35e453e0c473cb69c66c50fbcbb7c9c2604221a36c905456036420580b9e7e31e0e987475b2a03c931c913bfe0eb85e3faa5f8453abbf6eacec41f3b57ae7fd709b5b0c1d0dd312622aacbe593cc849bffd87a3eeb922a4f2df0429dc5e1a357aa9c21d6156081857f3eaa904edd53f17106d0f28a9333cb1c97cc2a59928d733e156af8660c27e71dc5e1f0dda8a170401861e35225eb48e41dc334d45069730045abebb1623d7ac2e65f555914173f9c6bb9b6f77855309ae4d00e79d2b2022a9af14a200d2824fa566e5b2ce9e74f157549161f1076cd985f11754d11881c263fdea379c92ec7108640ba8e2320c84ff13fd8115722713345df1d6c054a2fd310a4ba7194850e2c7a9bbc600adf2d38dfcaea10cbfe79d53440e66094d99c3db60b66259b4c94b066655ac4f2f13d130eb566f1dce59b080689fe57b2ccc183795de40c99f64588dc9320d048ee9d95facfa87327624bbc1c295f0c6a348012a5e87048edd329763e0d4eebb74b2bcd3c3a841bc95d4679476b1fc116e275c095fc17a5dadbb84dc92ce24910f68c953e18ee4510d0f0a19d380c93bb7cc49a43cdadf45adb657fe5a09b04264d44ba5ed5dc793763f79df57f24603027e9667cc9673a41607735c7b8048abb9c2793db87ee16550a1b31cfa45125fa02ad70e9eb2bdd8a977c30b4cff4361721f3c80c5652e271c270d2cf148fa730b4681cc65c25a95594e8dd0f572fec761949bd543431811f6e1844ffb189112ff9c450bd5b937365f44c98595321bff111b3dd44cc126f35eb973a570b59bf2bbe53002becca1cc6b7138ee777ca190056dc98c5e3e13539bc92322be5cb5b6e2416ee333d442f0cc5531d2b6ee0240b2f60032546cc419b4dd00edc6f28d33f74e461d1c0f6d5526653e9b02986b2cbc0487526cb60e2450c72315168a8d73bbc4235bd146d5c664905ceaee44b940a5ad3287584aea6f16ed7f0f0173ff8f5e49f80518e7f11b7738a742c07a18df8644c1d3278fe8984739b0eed32e296ec120b90f0cd6f0d5725b6f87060000398cc8566e68ec41323c04de5247bd0e6634122550e264c00022344adee72bcef20a4be8cd9af7c41aa4420c4b3f2408c50d03315e365ee5f64cac87949b5dc4b3a821e9f17039b1e5abd7af5f00d7f2fd6bb6c47628c76a3c787380a578cd8af1f7251a1284b691b4461da08347d32154c260f792bd6a1ad9659d060fb450aef868d8fe8994ab39f76c33e63045154fb59b2b90f7a096f858a030656ce62b881a54493291bd5ed13da5ec993d0f0e0d11eb3f5a1966001bdd0aaafee0bf436b051d682c086317ed4d5bd1e651149f62ea925f114f377258c4a95e77f165f41af566aff26f68b27b226da3eb7a51f40601c9818e8fbb473ff3fe578d4e597ec0d651c3a8ae3cf6caea6d116dc07e4b86c7094050647d5d6248bca43fbacb5820fbd57b0241bcdc0e6703a1f0632c1245f86209467ce27f23954f53afd96b3ab7857682de6dbbe131aaa0e6c12d82cb8d5983ceb5bc73851cd3981ac07be78bbde71434a3b1724ba364f817983adad4d4bb3c5be222c3e9e9e1d2332ad966f6a2033598f2918da2b7419052760f87121a66a2211c40919ce450670a4f0cfe6ed39af231ed744f15dcfb31c648e0a01a15de37234797eb621c91435e2992e694d603d7c4f02aedd4ad07152077c44fe69ae44c913153b27f28f45d2d658ac0449f31f5a5327df234d47ec419d8f6570034e11ba395a6cc5d3c81db55b11437ad373b90977af744faaaa5efa7ea8c7c834952847785610446c61ef77504a77b8069fae3676411e020d4baa672b2297433bc3beae15fe74092e407e8cdb91a5337c58facbe7fda37beb68fcf34c3f31c26b7c45dee989ce0faf4a710b57d7a834956139c54bc7f9751a377da501571c03e0f74d3af2396e265041d434cee78c70778349e0dba2a0e41f46d7e08b928f4b954b92b9f4e4119406c0833f8049c249df43bef709aec85fc94db8f689a2bee81fb7800c3aedd965a140dcd0914762b91b6f71fedebc3930c6011d0eeb964325de77eab1617ace6a4f247353967527c09d6d22c8ed08c8a8001c5c5a79e39c37535ae3f0e7923c5ecdbed9619b095d6f9b0882e465ca468504f758d4a1cbd53408918aeec8be643552680adc294bc4e2bee6e154a02df856c80ae8d517240b4aed6e6cea1914b17afcaae4706e6a8cd89bcb47e11da1390e8174012d70a0a14f0d0023b3a292f8bdc69764decc577e33776802dae647c4b892627ccfc125e047c35f38acda7ae1be066071e477b09f1af969db879a1c1104caea7c668992b51338037af62f193700303d8e0a7ebc47f6330b3f0b620de25e8b706a7cbb325338e3e9adce43771480ca677dea16e525689a45528becab24ec581427338848705e3cdf5b92774482fff765cc598837e8e66e03d7b11d9a562486240f8670507877c1a1f60dfb173f214c0d4c63d9c2c63f2c634f3fca9e7842295c186869a04c7c17a6fc826c5d18e47090bad17941018046631fafc27c1f81541877e2c55da91a1f0dba52b4662db51864428af1ebf6d1605df02a8f212f4f6afdcc5daa71572fff8de274037ee08d0669bd32fa79b06456c7b68c050aad6cc2f668783f6d9a07682d35b6e83320cfcf75c82eb6df60c5797e2696be6f825a80e9303b1dd351d29e1a2ae90f305cb588f947a6ba04b13df9f8a577a23c912a50909e31ff6c93d3dabe37759b97b84c0894caf56460ec56c1bde2887535fb4d9a1a0b5047d1ccbfddb360da3ba2e5f88c64e332809b583803834450cfaeaf467a46d79b4fc60940c31f2d892f7cc3b68197da44e2f56f30ed1db2e45f783fabbbafca0103583d31589a24da2bf71cec77f6b60a7e276d8d04e5657fabd204f5d4d0894cba9c070f52050ddab4cfcc8f26daafbb328ece392df01557caffc63144b64d66deb2e949535a3da2f386a47182590f44fb7ec4cb0dbc4b658ac7a65662bfaaf7bad77b7d909c5f7afa19e67d883d854133db87ea5cc375218a6951d37341b2020815eaa2bf15a71d5942d4e6737706eb46b027c819ab3374fcd75e26c07829b5eab6e5b9e4a45f7e7e886bdd7c381a8d8ba7398e2cb5b0017385a0e420aa39a451b49859e152e9426f188017a5d930e71bee39aec0b9a0410413800c1f3b0b2a3181ba24d23c9d873951519c1bc147c09d814f52e28b06815e652a671aa6484a3a32d73aee098cc70a23207f9f403cb5a6ab1f587a91ece15cd80cd80596be96580408b8b2b1277b1cf87b58abc577b5adb69aef33bb64f3c8ac5977bc4289ae0f2a0516a17ad579e6115617fc3abf0e759c1ec5da153a160c3dd13596aec6609c5552196e3250630eb87520dca0689e18ba604e30b3699852b03224a4ef14b98776a5ff900058ca5c065a41ee86a1015e55727e534ab7a513cf4d0b8fa7f2e0688de926f00bea221b5fdd8201b6b844e48a3469c1634f233fb9c354a548bfdcdce3d85e7fbc50e6656cbcb272d1d966fdf4b37f7a901aa1096db082d39000d86506901920bb79a6603965cc34bfe7d27ce7e30ac7c18ec276ca14c1a1d0d3ff0405e7e0a5c313758744f70b0d94e6e99e21700ebf62a22ce06fe71b155be5ddd3980f52b0b307fdbc6af1b6fda52a706374da76aa33f6aea2e25dd06fb0164147da445b69f4d5368dd62150caf2371b8a3555dce7dd31cab4c037463199ab22f823e6af90435c9afdfd075d3eeaf73b00fb461f06c88a0a4cbc270e4e779de524b1e7f81a61153a60c23341093dfd1637269f1e98120ce8f6978f0d704214e67d9f180ae90977e0e3b96a4277280b50e4e079688f723546a45f0c3db7c0b75c5c346cf4353f4069c8cb3a64d60e504a3ae33b9562551b2d7d2e5c5540e6092ad0568b40a428a6f5129bf17951723f11c7d204d88e35dceb89bccaf61e128f7ee722fe8fdd12f12da02c86a2d9d869ae5efa0c0403c9ae02ee492a62a4fe2d59c60127ecf5229304d7752fe5a81d034aa58ef77b27257c36d24442d01238e4bff2f41abe7e56d9aa205349567bdfe940a49620a1e52227ad6feff47cfd46c06483bbda3cf53994536cd22425a41e9fec73a269698619d073ee98a8f36ddac73e04062ffd6f2a5eff23ede126328c2dbe98b399dfe1e5d52b4e39cc0e78f8230b67d5316dee22e8bd3b44d16f9010efe52077064898f8abe42a3a428b6146d09b57abd079c2f2ad1cba0550676f5ad0b5f7cd2d0aa517f803013d53f1796cd5b77d2297266a3dde2d50fe46f6058c628c6e25ad6bd2022ebbd1a619a35a091bc1f85bcf032a5c8bb503093839b6bfd48e0d5f7c0d4d0b36aadb220e136be4971c17dc0b5519085ccf338530de8fe25d2de144477b7fdaf6739d0b01fff28fbf5508f9c54ce09663a358df6c0d3e2e2af2cd5bdf1eff334857c47aa503581fba2957fdb7aff7905c6f1b906e3fa6986ee342e6b70ef415bd98bcbb913d3ca55fe73651ab37895f104b4598b77abd9b43e5f943816bfa8e6fd24a0b268713c06ec72d4827884f17aa39272ebc27506f294ce5b8ff16a31d83ddc9141f86ea073d88b92d61348dd1f66ea4f86abe04996542db24a0c5a92dc0cee7205c6c26b97f6ae318534523b8da17522fcb42e5e7606d5eb1da36d84e5c2b2b0521faba9195872049d36c3a4a9d2799db57348b05783a7805129b1e38680e5d57bfdd2fef5f0167cba74fd05ba35d1e3270dc97e3efd1b2df39c01acd845efb3383d07b25adccc28056de4c5e508e65e701c1ec16cb7c1a97562220665514ada0243ece9049c978488b7ce2e5d27f736ace217a4c409944dcecd3a30c212c87d4238bd2ce97a3bd8ccf770c6da79578b778b6378c275961bdb505a69837224eb30930f3c24cdbbbdea60aa26c4eea4704e1a88f1e8a6124f1b3ca1f0ac8c31cc4d5d9c65a2979d112fc6a1cb318a64718fa2a33c6ab34ea99d8d7d6b0fcb7232681e118b2e743c350b51584b4d381ab4d0dc52a18c01be2ac7f1af5deb32b25d09211eac67a6f5452b4c1cc4b5f3590086ba04d6d546044daa91c257e4fb776b1458a83b3daee28fad440f010c1d4c7a85d0a02e96b7bf731055ffce6781793ca31d0e495f1c7bb61e2e9bf236de297531e4bddf396da31082c710e021c3b5d6e7ab31394ef114065e0262a95d9f84ca53db96f1ab6aef9cbede8ae2b3498f260a10a3981d81f43fb07e2c7470e17455bb230f37c87a623dbe4560304e4b6e5c843faf62742e9993606db5fc693f3d21b03e8f764198fb6357e7af75c0a0665534910cba4cb6a3b962cb50e4bb71a536e2f664566691b6da171a7fd2d5fb1ed5338cdda5edfa3f4efdba0aea15b11435f1a3f43436e47d81f0449ce774e1f85ce03583d5714a1086b17688688f820bf0aaf86d95599afff992d9943ea0f21014c64fb19a2762764911cf70467b1f5677d26c4855bdae848bcfb19e3f0b391ef8dd0a2c599941e8f7ee55e05266de55316ced2afa7016fbbef2594055328de7e19ea2c1a60897bdb3f53534c2a52c04808708f4646b7ea25ef6b7a219f95d9ca56bb642226075bd0213a59424fa7671e5c79e173fde6a7e48ce9d2a3621fd14555f5eb11f7609c840bc8a0eb29e7c5e5ba053f8ab252733486e54fb56431357fd1beab79ab4980e9aea401f1019bf62767e95f1afdb13c0cae951f6f80f72699d436c1de9e2f7fc9a6e2702073d063657c7a012b9f056a0b1930b12556d95daa87a32c21decbfd98c06112a8937f67d47654b5bf6a6e3c235d00cac3b255f0240c4e5c65334fcab6ae00af0341ffd5525c54101adde77ef9cd4715b58fa0408b3d877f1d70091fbb95a48b3e8268c38d86b2a16a5755e23228f4b1fa6f2d6fffbf97dcd11e3891b65dc9eb9b7e5bb0bf97f3cdfeb867b63fba0d18d5d091954803a2d4c18aa5c91155c13da0416387a9f1a8f8931cf9061cf996bcafbe7c2e82cc842aeca5beaac384eee3b4d13099b313018030be43389a8a133f9a4d520a01aede67f760dae8b213c3eaeff3761bb73b3af3ea8de469a59cd84f9b38852d07b56c72898c8f82ea35221aca3450159ef78b8c012510759a499d9427c6d1297e1a85bb71a36f8f3222d26bf57b1251c385e6c203d1a917d3d17ca4d74d6312454fb75c61e791ee64ed0cc194b04a8c73f7be1205dd2af11d0ce245cb36adf11acaced34e3ccd8eb9085331a27d90595791ec10e26680f4ccfd0536ccaf3d61a5380bc3e23735ef60264fe10e45d35d71736ea7be802822bdcf094551272d459fa95e742ffd95911f791f73a01e278f0ea9492b4e3c88dc31173febcd845753d406f8af637ac32133edccb711566382966df700a8cd50686c6e7bce0562670e36a6238178f799cf31ec197a67b4811725d5d50484d3f5075dffd02d7ac8e1e3027d9d1f392c81b2282f9b45c312a01aa97a8c2509f5329fff07a75d40587597634cead2e41b04b939346b27e824dbab0821e2f9ef395379c3b2ccbe2f97b05af83ef2108b41bfe5e2889038960b16e2b3772bac99299e3d228aae2cc67689dc2ad7223a2560bc88d1d260162fdc5ea361b8d9a89ab36bbf170a5b9b5c8369682bd6730ab24f6a365b41ed91e85e02d03012f78bacbbbb09063fac4d0a58a8e17e28dd834d0a752db7e3d6ad8728adaa3fc6dd7278d1448a57aeebd1ac002210753348a5d6f56b53e4fafb92eab5a7b61714ccad467e671036376f6ea0648a5fc1d7f82d92b0c73219737f0685cc152ecf469a1bdec46b89c8cd457e353732719db8e9ba6e43c5dc84685baefb913d50ab4cebe6b0c5a9f1062bfb11d829e99ed14174ec40bfead86cb3eb6647202de9503a829f9bb2162dd679848e7c476f7dfce15bafb9961844daca81825714ac676025618c7d56f7e2d41aa810fdcc842325dba9ec6806aea7a80bf261265234a00e113d7087a8aed62c44a63137673284051bb9cea8caced524e1b2c15adc78c6c4834fa00e980288fdce1c178fa7b1d2920c23a1d25c44887af9b97f6b63bc0522ad07890ab909f960a9121b7283ca4c2ba03a2f6ed570b7eab1ebce0dd4f5a8c9826599ee86361dd443753564711fee486da3f1b9bc412a4efba1e4cdc3940d42224f5fbd5814b60efb89b8e877393a8b2dceee333c32c1648f263294e3d4d721a496e91d63f3fef3699d67a4c54c5c168056155872cdd78d9cba763b3fa1f08095ca81ac4f79f3b2f852e66562f35621343037ea42e762ce9b885adc22fb2606831c3991ffcd5e331d238dab35f27dd9f8d4cae90b7e2e229b50c0f8c1a1fe978da3bda2af3846056db789b49c9a9d18e3424f643d6d36394930a2b50feefd059639a8430a77e939ab0471b464b7238b4e402c3971e15f389389dfd291558ff25911654e2bcbf6a3878b11103bc59fe9d3cd15f5e5babfa0d6be02693536e9febd08b470a1b37e8ebd602aa15f5c0e4f11cb1a3566162ab3ece1394b78b9ba95d27326bec2ce51c544ff910b9f6c4d7a4ad2ee2ffbfa61768ce4792ac73e2e3b315209b82e18c889b2f37e7e073a9fddded83fe0ad17c1b773bce1a48501b96f63d6f0b7f60b8eae09e53bfa7b67c78ac3d0ca2ff3321efac9776bd0de506f3abc58f337df03ef28e5e6da6e9fe8744733a326b609d2de9f6e58a89acbb9e6360b3765861186fad78f01d7bdc3e7d90835b8296da18dca91d8ce7b1b170c788a78dfa7c0cf726e0d08d3680cbf1c1be7ab096f661899ddd6258cf8643df731b8ea1ba0df322925200e9d6c87218c656dcc0c3119795f43aa2d2c47bd388717eeeff4bea1d1485eec82fcd7662e88f54f5e4f5eaa93ba581c44b7d8419bb740065959129d45a884b27468a662594b4a6fb0ff81a63f7be80efea5bcaf63d1f3c7ba5514dde954c9f946c1dd4318b8b86aea2910292425294a9e6b14464542e43dc8275f847500d6e780ab12051adb0cac6318cd241e6e6ebbcd896f88063833c555fc7447cb0e27be32ec1954c3ebf25c0b1198c1ed6299ac9a571cf4dde0baaa64c465964c0db2e58564bbd7e4c15dc730907c95eacdeb215dd5fba8e533d9725870b02eb77bde491e0b92f4534755cec41e011a99e868c3bdad457940917f845c994e8948be8ee4792b7d0128fe225a198a2b49089f8985e17bfa70171ca6fa6ef9e994224d2b73cf9f2c0d722773be3a42cfa49ec600894d72519a8bd549ceb29ba6b13e1a19e4463ada22be173b4ad2d767fcb08ce0c198140ca175cb42e8da6c6bc87bfa2bf099823d74b6089377b9513037ff74573564ce7b2241f32034c32e6483f910a5cae45f39a024d8832dd6a9aa19ff3d6f60eea2cbb6f76971f18f400781399475565a19a2df88d10ed378ffd7b1d0dc67efb7b84981392b9c07c63e087e625cf7ef672919f3e82c743df33bad053be1944d542e9bf0438468d218e8e5d3beb6fb1b2ef5371fe4008d75299f08185f2ebe1feb428c691e46bf0c2571431b9a3202db516e71f85408b770a766a8b8b8a09c883a54454dcec9bd09a0bfd2582a7e8454d31ef705ba05dc74f64334774edc6c4d66c96a9c73c21d9348786f855e703b23f024dd6f39183f245e9fe3c44e0aec1402f357ece49d41515b167cbeb80df2b7b24c9679de2a61ea5c10854304b1f5973acbbd6a8c2ca3010fce76beac62a26f785b68f39803ded09a9a16094d252dea2cbd0c6ea15d21edff6a15e1f01ac547cde32f15ac357aaa4328bfb71fef160cddb4c3fbba27c7296837abedbb29afef736cbb3a17636a761dad7e3a7fe9c96dc9e65233a0d9963a0add4a0073b558a45781625c30cd9a7fce16d424da561d0288342a7f9582a222b9e9fad4e40e7017f10af9c652ebc25698df961b48f1d2565a64716813451614ed3281fe7961d3282d7719a2a849c04af9e69c85318deb99359cac51cdb2b6e3ad1d6a853486527caf3050aaaba1ef4fff8f900fa0d95f063f93e05ffb250a2034b5f101e0c60e946cecba7aaec0aeb7e427e5e61e2cea8d6ef2d989a0e0e843ab57ad57c4b94096ccc08aee7b9de785910bfabff1f401949513e60cd7d21982009f4f3f1663ca01684cf70dbb0dd49461e5254466426c5ed91e16162e41edb50b4c8e6546984ae242b0d22f156a519997be6a6ac99aa01e866002aff0e995e2cba455187c587d8c112b77792fb2bcb972c4cf3d115bc8f1c0aadfb09b95c8ef8c2cbddf0b9a8672394f7ff8966dd7196e8b5707f7db17c48c06670ad13a1cfa1684881308703e004c748fc39608a3a7499ea1674cf2afc3044c0e14955882726f307c2d67f0730cbcb94d0b4856cd401f2e56e2d56b22e93cd3a752d4239d5ccbedd9ae65ac99750af1845d86271ea9596f3aa0028e4c3a40485766b389cb4fc826eaae2bd8f0056d5b41622b6f2bdd8fb8e40ef14383f7148197cc47b349a2b365703e15fc1824c4e56ce60bd1c7ed7998c3a1a7265d57668c8608541e9bebcc7dde2c07f2a62f3c7f7a5c26328ce82e56be7c99c38cfaf82b6765dcc974e1b33b42b17fa3b1bb93acd832cdc0fb8fd58b03ec0d50e2b39238b54e492018e43799e5a72d3714951dbba895e9759c9d5d814b02420e61462919e92ef5c3b63b8b95f20a670e86cda26e3a0facdc93c056327f5cc56e957307591229cb69dc93bf21cd718bd3df491da259dbdd8043b5550bbaf8797fc374d0059bdc9cb32e7d72b367166ab88c170e72ef07b8f311f0ac5a8b991a968259d04597a7954a296e20fe52ae66959bc47d506e64f06d8089dd4d5c8b4cd8e9981021bbd774c3f65dc7f4d12379cf0b745c2a99e31366b04886d17e50c3b1d59e59945f44dbac7fbf4be47db81cce4cc4e2992238e7cb52b97ae0f12e479079561cdc94df85fdb24ed25b8b12862ad15abe4991c9e74f95308eb5a19fcd392f3a188f1bdd8e1202b815b81efd9038f012f2fdae52fea91bb10eb822886df8d6b47e767623ce0f59637d981b88be4b09d54349cc147a29752b6e1dff757e3179ec467e39451e6393801829478a5f9cbd204db87a7795ac56c8b8947738ed8d5d23d451413b92824859f2d26e9b2e4157ae74ecc5403741c96558eb1a5d6cf5bcb30d1f6c637d881854919d41b1364aba72831fea93cba1ab24a159a58ec148ec8efdf2d5e1cdc79c3d4fe44f18392b525bbb6deb0f46c7ed8236581410c2732d32650d97a98b91b8e1d0b4ca05bbc697b42b952a90367324524c093ca350ee624c03e8f4519f388b8c9c3ade5642cbd91c643c05171e91b95515b316e6205060f1f97c6b34bbdb6482a0ae656fc18fabc83953707803e44b2e27fc5dd6e4a5856d820572b46b6a925ec25e3a26c6be4711716bf6706156af795462c248c1db3c2eda45e474b6dfb0b6499dc5a17632e23f5b842626bf1ac5839028fae9c1470f8103df2245c489e61aaf8b25c6a2c8f7b798f620dbbb9fe497681bf364aa48dc12beadc3a287ccd7d5e094dfe94144ab500219f35c9f0045eb9533f2b58aeb59761421a0f46d981ef69a694e14c8beedeb906ecf88516","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
