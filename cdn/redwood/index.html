<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"592ca84c3f321b7d22cde0dbe0de4b092a48184b0585b189a760fd3d2b3bc2f24ce96453056907573cf1cd97b5c8d3bc41f8bf8ba3ccd5eae3c897963f9a57fa57a695843c54a9ddc74a71ace1dbddbd66dae0ca3e9d771d745bc33e713522a6fd17ab2ed209f0766741bbe6b142ef95ab7abe96114d987daa93783a618244d075d8cc6c2ebbc04f9d405719f3be76e5e601d98848d3b22dffec4ae493ae8a1d13f5353b99f8c9316650366b064ad25371122f962e38012d71a94d7fc5668ebcc48e710f6ddaab76a13663f3d224fad765b072b850f4dca6e5618b9fb3399ab99f0317b7aba1eed2045b2f66de4529ead1214e25dffdb8d69dda2416c6494504bd0b64ba766c692a2d5d374a2e62a68a834d119f79f6199f53a1fc47f95fc814bc03d1ede76e20b9e9213bc347b5a427999d69210ab0ce47f0c3252f1606a455de6b58de49df7459852e77d1c2d2e4b930101320fe33f87f7765d4d5df76d3c811a04ee9caca3c745bbda150f2de53aee9eded6aea6f4d5e3d129415978587e4851ecdcad15119da192e26eebdadd7e3bed028748db634f8322be36d1e482e0921a4c463060cbe01f8ed6f4bd20d90be81ab409b44134da1bff2b0741fee14b887ae5cf19af0422e9c2f81db1a5bea2a224f83a1608947c007412ed4ac206aa27879fd112ae4ea7fbfee8c36a37df3852bfadf2ee0a228200e3bcc3361a3386cd06c527604020134b451607f58dcd52fc3eedf795a1ed2906abd801f326c6e269fc44869962ceff7bd3da38ff9d24958ceb05675204800a6f37daa8eccb41d121f663773bbca9f9e989e87bc9dabe903dd922d50d14cf93152d93afd1113a14e32e4cdc9357faa10ae0633393524551480d8e50540dc54cc14c7bb7b340f6e8f0ae4a56ff65fb3e0695caa25560b8ff6a37872ca60a67674c49375fc37f29a36570645496275fe150da10091496208138f2cc24e0b2ecf1d68c3370c5b07e109224becd501ff110db6eca0819c9250cd7a1cb8b96ff769944959ed71a7d2e06d5831247f25e4d7234b49659c6658a371181e3f9fc51646f0ca06eabf5bd478fd3535eec43d6aba7c94cc42f17773356fc434fdcb355c9d51d956e606f9ff22f7d2731e521c0fd96fc168ca47b8fc8ec40ac33c267c4d74c9f57a3a68453aee97643b547b3d0b83de968debdac64f722c774e3d0f1db92d38e19fe18da0dc65d096c593d63e9eae7a3e3256cf7bf3e9dbfe13556003c996dd2644b8fee608101d33c8cd0d492767ab0c803810c697309ae28ed392553135c119eb61392ef1bdb20044db6f0a3ab4962c24370bbb9882c427ebeaf3436a3e911ca95a15fe1549f1dfb91d194ca5d34bbcbe6bdf67cad02422e3abb3d74494a597536a0e852fda07b9a6ec05104265407fbba09fe8456326f02b2a8c1b9fc2d6dfef9cff1cc50520ef590e436798191662afc893b1f19226789348da6a3a4ffab61a3fe985ee0c11e4706a964ef1eb667a7dc4d11b80a76d9aa52ea9c80d99a01a88b8de0026ce4f4614428bb4a696aaaaf2fc0ac616b42dbf87e6f97b34c9b5f93a8f87842be798bd242216fcea30fafb7d0b31cc8e89b685ffd1d4eb20a90f9e311ff677d694527732d372510d578b490cc341448b427d8c5adbe3bae7ff3dd4a9b1501ca1a921c07c3dabd9e7eeee9be5a2f3e471a941e8d0b7564bf484b1fbe1c89c6eed92ef41a59c12b4b1792860aa0448f1556951b7e3851bb60ffa3d40f3599531f0717158c6a11f61d6e97d5c946a0b41cc303209e95e9886d6c4084623970bf51a0656709c2d1d0a1d1548ce6e91a8121d30195904d29cdb5b071adb6c7603dceaba512307017c06b2b516292336ce44e1a36b00f12dc6e6ee2e2b7b83a4a8d1794466afcbb82e15aaab8c32fac823eb27adf2238f214faa7b14fbe7861336028bcc1eb99e23fb336bb84f116833493c5d2f7ac1145b65b58e0a53ba74396a853ea0c29e4d77a962eacc424ec6be455b49f64f4ba0fdb14bf23a74fb96b71c7469ebceca3d59c9ae5942c243b748705af77c67d605ac6c096265a1246d6ba3b70b5e7ca370a544330872efcb3dfb34b3e4e1d83232fd69df145f73210bd80f7104a8bdb1b3eb852fa3b218772e2702de733f82d609b182d92f689e3b44f9f45a7f0342599134e449ef2bfa9b7e932ff1e708b36a57bb492bbe020b10a57d3d69d37b4654e9778f62179f889f52341c1fd84ddc3510d814952155c5c04402bed1d3dd5cd8775acf77d165d11f70358e67d46c0282ea1664de525885f115bb5cba7842b45bfea5fe11aaaae2a3cc23f7947a5b4327c8443e27bf044a318763635add838f7c821ad7b33e3b197fbe9928a8f9fa513c9a9e944b94dae22218d08e34feadfaddfef6409cb67415b7ef4f2e4e9e005d18918544ce0f84222d15416b8fc0e803dee86bc0a2c11c41bc19cb8bc6fe20a51dee16a38ab28a430c9562e6184e0290506072d4008c388b47b51fb7b1309c6e0e5fada94f46cb66bc368ff6ce3f083cc0a86eb698acae9222dfbcf9951902b8514fb000d8b16310b497f4c82beeabe5c3b9cc014e8ac3c58765d931e39719279a087f1b7c38669759c702d4b827b71618afdfa9894190ab3cbaf7d636f11f220809e9cdbbbff9c74347276b25aabd3f6cb5aa4b68e99c48586347e485e42e8ff9fe6e4b357f3c7b57c4e76b3dc8dc4ea1d0cefbe378a40df6cf04b2299b9d2dca8982211d63367c2d358d9762c6c05e3154eea36474db8e9eee3a705daf4619fcb5df053a8d828830659b230ce11eea54584a3cdd6462b1214467ea0f067b48021efe9ebc94bf258302fa1c5abbf049e9c86b61996c0ab63d035769b1e9af3e4b54caf0b85fc5c5a056966d5a00af668ac6add79dfa3d53196c27aeb8f15a0ba4bee86aea605259cff76d0cd19a7a8cc5d8cc721e154002c6c442ad85110be26d79d21c94cdfaa4b6a2982b5f403dd74eef2b9da678f789fa2868b3bc5e5fbadb287b1709ff05946e4c76026439ef7b2a64a861272498be2978456b16e698bb2efabb08fb8a2648997d8c91a43c5aea035248916e2575069ca330c24e2609883fc4d41273707c40a6eba67d33ccf1e3ed7c059341c06b53be4b63025b10f3b8fd36524cffe73c7b3530d994713cdc4720d3bb20d5c0a2c52afd7008855b564c752e13c9045f054a827bcafbf5964157f658b9acba72046ca408829c60debebf41e74722464d948c0ba425426b7a69ae845d1efdfbd687506aad92194f04edcb0b91197f123f42753338bf1159e28bcf73dfb050ba67bdde7b39a1e9ce2e584cb3aed8fb1b3a521ec65d1b11c0a8c757378206c9f8a3eca2d7da72e3f9c810e5f4183a1b09659ca146aa7d36e0adac6f53b1549909ab5c95f3ab36739a7924bffe4bc649ed0d3b07c897fffe847fafd0c81e8d067d264b914857187b9329b48304dc41648cabbb338cc94691fbdd291ac84cfabba2b7cc22c71f2c3da30502144f895ad47a9b0cf01381649b36409d850e8f472ddab488939f01715f80d8a207c1c869340f293c2e9fda74da54c368669d154a7f01cbba9bf1f6886563e4b7f493facaa30b8dcd4c26b143ccaa9f7446a8f603e02e3be449c7cef93025967b9279a251d0286deb909ae883a4c0b83ed0a2e07c8d16f2538bd537db0aaf28eca268c854cae7c46684b28bcbb719047d1771378160cee91e6dbfb1ce3f9462edc4dff0dae83a57928113722a9afcaec077ea8dbbe91421b4bb5e2fceb62bab95ce5f5110fe1bafc4bd5da5d95c293a549f4b97d455b095a697b03285e2a1647bb708468958f040860a959eaba3a07e1a1f243c0dacfec3acaa34d741aa186c09cfdfdaba62fb8b7b9e36534385e7ec03c93c20fc8f40e5e927653596a72e9c2faedef3f28aa2678419bade8f32b1df073b94a85e9d7df178532a39ef858c863314b7017f6415a5c0f3db55c5f313b6fdfa1b5b94706f79861e8ceaeb1a8c4105782349be65c929f899535e914db77b5832a05dae01f57921051bc4506498d2ea24ec69f2a462ed5edd67d6d326ba90f5f6cb50151abb26c53d2d2789876b89751be478ac7771690c8df6222e7527e95dfd9b62971a893576fedb19b6e8a1b7d9231955c27455e1b1ad74f718eac8fad591fdc9d665edbb588ecc4710a05c38582c1bfea33fa0b1e6616cab70f250f3c4a733d7c5137d9a698353875cef611c512cefaf77ddbb28dd4f204432ee17dfd679e3e6a9cc38e002fd0a32dc532ae615c1a6f5374f7f1a3a5172ee6e37a82fcdece66f1edb6c2ce4a753831725263fed284d0b3009b596876fdf9816d70028e2a195b8ef85fad2640534924b79a7fd8feef2fe18a39bcb986a266ed29c9ff009a6a7e553ec9734bad69a74e4c8119a41c1943f8877b40183a9c1a5b472c5c0a3b4faf400bf62562698eaa0f9db324205a8930f75ef3c4001bccf17eff65a9a149f7159291be85192de243f34a10e92fbfc7beea2b8154167924ba8f844ac068e13e45edb3107316be095aa61bc9f2f98712af7718e35691201504cd37c2c86de2806ee872c9af8a0d0b18aba223490cfc3b1714545f2523ccb759f58532294ee370e3b84bdcf57f47ee99ddfab7a5c16100c6f713481b8947fd1dfefec204d46aae83e4af7fa3ea656ccb97d1c24f023289a9c53d68b89eb5b3d4b2f655de36dae91ed20141a624f40b57dc70b62cac6a4da69d91a83db350e33739365129bd993d99984f88fcc3afb2e65fa10e6db38f55b2a104765787fcd0e42e24a27620a90829c9f8b4fc1d4c2a470dac99fde9354e19a8590ab4bddb2c92f88cb4ed5eca2a456d3c4ba4ef878fc4a5c7a7486a96109fe12432812058cc301ebc1b14a64301c203b54522f394943f8977bbb99ed0b559b39023c3edb77f5a64ad4d1ac20cec793641deecb8a5307fb4b06ab3cad6034b7bb98c0fac8df670f5b0d5c587335e1ad98fdbbd453d3768035bb584c0a6a4256c840552ae73643bfe9765b97207a33cb6125bef85c6c8130c1f4cf8f806b9da3ce48cd07f785779c24d27c7c269b1fc0382a3adedccf8f1022753f7a1a8ce03c79be21e657e1469cd0c5f49b5fd5a9c4b1cc347bbdf1956f59d4e518b70bbb7b073d39286422e0ae5af5e372652d9553244ce3823f905ebd973056972b8d92fbf23b1e93abbd6aaf25e75e3079bfaeffa2f94809f40b030bde4d68d8493db612d4f37f26c0903d8edb3312e1b85500dcf0323893722058b4a39019a07a2e1439899104c14d43b94d3c3625cb6e017c7fd30d0280ca6d451cb253467e720611c4e79ded78daabd3ead8075eeaae153c58c99a66c4cadf5198c269d3f0a6ac4746d74b8a0ca63d949087e6f4a32e58ad087275e7215a0255c758d545d686c1e3c1a8d94dcf17465bbb8ba9505c319d820636e218a0876aa6ef38830d3e3f2d4b6154826c15c89f95ec94ae21b3b11c01ce87d3ed307e6ddbe0744b50b30d5455be14296833481f187a0a61f252566fe14378332d9daddb239b7ca7f67507bb3bcf70b0a97f4963b3475a9038d075b68f540fe453907057eceead75e2115ff36694c6ed6cea24f93930c10846c290b23330abef16cae3f690b044d4c2718096d62f13452484d540e778dc74b92ae8c19350e62c5a5200d942f8b9af33f8cfe66d136ab66c7e0e97967567136984193597c434fda9237868f970b2811cbb41e1c283412aea5a6ffd564894157e47633699ff77f524cd1f822b13475bbd5ab091b15ae66c7892d4cd9e49d48347e69b3f0da31b6802a3c15970c49ce6ea4fd35fb8d3fa5cb8da3c018372f1d6bb9ad4a48f64159e0e8fa0ab718bcee4aea283bad1450f3806c37c7d4b4f703f804c3e4c5a462539102afbc5e0219fdd487dcea6dcae4741f5a26d79e2bfb0adb4786c5142a73a0185ff8808a56a19c461e0ff4ab09e7935ca18a1efaf32d48b3d233af7f1583ae85a699d085a39d9df699407a06ea05dc28ff54a2989fb947af1de51b00be81471ac2cde81210d005746bfed78db2be5dad8ffa46a0dbd82dead6c17ecbc3e39466815f8f0abf9532d40dfc66dd506e0258ddf48ac48bc0f5e8bd0b3330ac9b24c71bae247d9ed66cbb3d013207d0317349970244f959f6e8e4cd572d610544730e2b0bb5e0f55dacf6a7779985f3f575f500539fc823a9e46388a816e5773e1f9e77b8c0d4ec47bb1d2bafde623187e6a6dcbefcc802342e288d5514776e5f8737351af5de3f62ac362c479a18ed035ad77d238062ab8dc05617d70c2f92256a00534cff7d3f29f32abbd927df575bf8025bb244cdcde0a7cea00dfbd9c2a93d982a2bd7e2d922bfeec2b8a86c8871f6d6bd115729777d4fd725c55dc0d7306a726583d925cd367e9fa514304f98bde88ad118ad46227fb7b13db7c8dacf4d6588848e6de911f9dc7339bfe8cd01726827357738c0e84aca060a6ee278a31e93f875d5cbc55ce24664646c68cd270059687bc4adfb4f1d26912e54ffe912574b4a38b16d249e5eefe1408b9200039815ff59a5b4058f84c9e60e32a3c9b9bb30b2c85ef101ec390ffffd41c7b96b1a87e3cb274d379285060949a016e948f66cf718aa2be69e46bda2fa51ad31e5aa0db2681a1cb42b4b494ed7336158549ed30ff1ead63732279b4e76903e566eeac0ece4436e0b5cba7e9fb42a9586758f4c21c1945610c3836ca050c1d272f4ae00344282424aa720d25185b432eb9755841b175b0143bc8a21427757dfd118f90478e82f2f73af4dab935f98dd9756e33c579e8e52d23a976efaca3e0c6901dd04046b313828e5aa8a010bfa9ad581c1878c48f8d2048def2c0657691cb6310518e53aa9bcb56f24279e58f6fded58f36fa18857ac5567ca04e0ee194d5e5bc2e4362a98b84f7c2678e4f15a6a911f2d7f1f7f6dfeb9b41da83ef13d750c40923e0f3e7d9e5e0942ef503f56a77b7d6398e613ff3d022b8b8fa6c595063998e97655504257001721c95b5df91e662a33856c25a80028fc84a968ec98bb923f1ee2b2dd1eb666f2dad64da69ec58fb013ae1c3d4bc0360f45becf05dca75cb29e477066d6e869629d034af5e731e103a6990d1deea21e274b71ffe9973f9ad141db27083a15b1dfa4d3383fc8c01f911feeabe21e8c39d7b09bbec372569b6c143637b7ed47afcfce92d56643ce1246fb3928fec35b1db238f5823b781899686b1fe463891494e72c746d206abcc6905d6bc042e1502b711e6f70dfde04c7c836b7dcdbc01508634e3fea8243849563eb8fa91b739c30f1f0da6004c256a6622af0b64c4f536f15709fe380ec4e8d138b9085f75a1a5a098e69754b4e9d8f8c5abd04177b2d634d9c4bc60643f40a12486a413a686ecb180062caad8f2b43eb77150fa2f56e7d7b9769d1ace89568227d54ce3f7a07e9c3d85ee79820b9974c20e3b77c793fa05dfe0d05eeec20628d2b4be61d1e6fba9b2ca7caef59ce89e0c38f588df14155c66cd123a1a31f47c4caa7d7add8ae29ba120949c35d452fcf30d36dfd52a4f4e6d775d13d71675c9bb538f3aee19b548e05b7a192ef15c44148786069f2a3e5f66f73f05d5da803588db9b5a657c52540b938e0dfded686cbcc5d69222f2bfc18cba457d3fd651632cf719e51b96c83747c24c8b00646847282b46487e1dbbec28f0b7076795a5a6308ddf6ebd4b47fd3f0a5bf4a78d554bc962a58a819e960985a9193596da54143c418088668ad426387515a1a59be227e5291972cff92158e973fc6e9c01c04328f808d7af45cfed471636c73598d6c8ae638a64b8cbdc57cfec0b0b4d5e33322706608844213b74722ae993212b1640bc7473c496ddb37621ddcbb820c19bd189155639bd9d4d4a834b16af2310fadb9fd307b5507b8f8ec9458b670d48069636107fade3bd621ed01bb56909990822fa313b4c0901722193fd99f13425c2760bac5aa65a662c545732e25ccd4422ffcf84fdf6e07777347e299e56ac3023fca1f9d05c029a15b9e83abcfbba9f337c27505d5814eb6afa4f5d4c9ed2f9be4398e51ec44f34bf8fc1086fb33b76f2d074e95cc706c8cec08ec55acdd69bf166fa6644c5c3ba79dcdb274848ba7914884a49a6922c31437468dd70efd19c2ef88f431df75834fa2763e718c040cf713fffa2e55a3a98a3ff1fa69ecde4a34c477316afc5e41f0541ad131b48f567719e62b045b19c426b4f402dd2ff6bc3bf90c7e4ea3072187466f7ff77a12d735e1c8fe24126f81b4e72f3e9e7b358b9f0be552fa9aeb0dce49dcb8cc34c09e70ae4c52b1220f25d5b5206754a8e403bf544bc296bf42ce78a32eeae684afcf47fcac6cddb8a016311017e4e3a9bed172133a69b0b9423292d69839c92a5d9bc39f5c83c4daa2faecec64aa5cca91f156250b15803c4059792075bfaebf54c39cb728d13b28246002cd5599ca7dd3835b6af3d74edc648ed04eac826a69141e577bf988e0f7c828a4965e8d32d35e9f7624a9e61da09f1d1c54788e8aa9e13dda9a32c4053c8a10347ea235134a703097840a267e57dfb56fc8ebe60363db69bfb396d8cd9bc476d993c30d0e09a18c6038c9a412cfa2ffb4ca1e009d27475a414ecac71d3e006701a6e2a7d1972c5013ef91981ffe2033c695bc1b1ce47346f2fb7f16f6a09c13afe1657d479e4b966c88d73247458a87f6772c0036270ab9da20734dfc076fed2f069826926ffa0f334c65c9a1fafe8d9e1b8886dafe25e736aefc43d029b1003c5d2a0db32a163743a1ea31eab813bbd600b4439f85b4b079d7d7815dc22275ae65bdcb3e849fede7b9e3b62c64de1886aaa574b9b6c6246d223dde3aa24a6c1d7be5dd93dd74fc39a67dc37e9ef6ceed154e5647f018ed27f45cba0be16069b76d1f185fca63f3a3831096044dcdcc3a1dfba0258f8808583469ee3d08a6c809dd7c6f5fbbc75acd1e49d2c1dea381d42e75984958305cdd2627d6f07e1f146bb936c0b3d1fe328d1ab1c68eb8ddf070b5de0ca7b9e8b23101b34fe8b1debb8e11a9d5fddc7d7d3a89fd0f7631b490795240ed6b2e30a3274b1e0bc4d2eeff4aef1aa84c289eef71e2cfbcdf03aed9d01a744b6afd469ded186f8b4b009299de74925f1bd6c9968c9a7b24f6303e9965fc3234f4ec055ef15f28225c13a7fbe3c7f410a4ee516d7ed82fddfc97487768eaf825e24cabf13083fcb0d37ac1ea7796932de12442a713603c99d43f0bc136900790b79b2d6c664ebcab42f9f3a49ba67529e06b736071b1ce907e27660c6ec4f517e604e56f6676719673e79bb7a9658832f93a83220358974c44eb656b4800d942784cea9dedb566d271e4727cbe47364ba8d359acdf7cebf412d93f90fc6d50bb84c8ad8711b27ba6a37ace140d76f1a6002280869b93a542ed1059f6ad6ab09f4b18f3a7afe5b1cb2afb851768d7ea311809a0a8ae381a457ea63a633a6f7f6bad1bc07fbd57ec3a0f777331528638427a7f9d4d2fc61d7b0554a725acad2de7c268cd0cc5b890efc520363616d07e3b67833bdd967290b35413d9f09ba23f4a3e04aca6bd8948b1eb3624de26b44a73567744d51dd1824be5f93d35fb509471c3f4dd833a577df3b66b0541028219d8f1bc406ae0b42e50f6a277832ae21a2db26d725918c093f39d9b54462710f0d11f9c9b04e6dbc3d913cdc9327ed10ff16579bfe9516570f1f721913588b3ab13c584323a7f0bd39073b1aacd5f723e0d8196e6c269a1765ee80df280506057b5e843347c89e85c44a95070090acb46fbedf614cd4525f3004291dfdeac6954a821f24f211cb77fb1cce9e5bb95d1d03d36f7fe4219d61846a41c506083cbdc75ba3135bd3ee89cde35ae8ece685bab9b16acf8125dedf90d94d0ab8f8e2fbe346299a05f3d431d01b5835d6bf6b0ee64d9427980c7199ff48e480bef55ae8bdd42b467d524a4d6f41cb070804f9e5e921623db68386eb893b7a7a9620eb48822ec0939761bbb86183fab3be1851a981070bb83c0e47ec715c128ac928122376b989030ef0583d3ab819aee79fc6cc33a018564cdc5700050b169e80fbf88935b0f8aa78519315e14727335b02da299885e9ecc179a8f9b956a3ee518ef3a5bddfd665da4fa80df1ba5cbc82c354b0452f179a60c178333df838e64332536adb451e2a49a424b4e462c092193b8f97d8d620f496a6481cea9c240df2b32314e2b96fe5409f8c8ab0eec8d31781003c2b457f33ea8a32d94695d65c01d19ff9c82245d61a84b097df7b40124dad8eae7fc77888b6edf5393f6e75581e4f12a56afd3c204709b0c2a992a501bd0e39e32c194cd724d7a0045897ef49cf0c4049897e242f3405b51d0f4d69d71a919d8d2ad1332fd143c6d02761150ea66b6438017712b7af6a0430d72949f800913436909c87b726e2fa39462675f0577a3fef14d7a43540b9e5761fe5922f5c721e7a6662cd54b990c906fc6c8e5f7ecc7ad2d83e77902658bd0acdf0cc091ee32a49ed93bd877bfc4c4101e34d1c508142f41407d3edada29e94ca4ac8632a07f8171286af6060a4fc8200fcd2d2eadf42febb1e1d69c2c46c1808c691322725de478036b0e19bd8c9503ef2906c4c77501d5f729aa66128cab5d178b38f1c5dc05aa1e0b57b8827e668b3ee57583f002175dd405077598b39645d5d7ecfea4741f37df0262256e03bab5c0826cdcb3ff8876d5fa8725a1eb964984deaf3a9c2177f9460a4a6c8d3cbd880baa2b8675ba58d9ee210f698ee00624b2c72666916afe5ffdb2ecaae3dc05d099feef64156ff9d7a55ea97cbdc0344c969b55fb28d3ba0f3edcf43d1d6f8465ad0fbb74cc46ea24007ff7905d9ae9dc003bd123657c3ed48a6fd748f89abd6dfc6823b7bfbdbf475f0bf8cad1e9dc496b3a382a1da5c1819faaf4a7ca4acb4eb7b8d505b06bd27f456937c793963f58fc5394697b30010697ad1d4d4f2c5ce7213faa701a1c9c8b2edb5dd9c078f491e53a8717a30b961e89c40b7ae81a948c6838619d51d1dec2a5c257f45c22ebe56af7bd5513afd8cef4f6cfba1a5f30201c79b4ca671c4c5ad5bae55fcc98436b10979873308e725fb7e8a9dfbdb1f02d3da8ce49bf0d9b9235a96c80a3ef55c9a8d47c4aacee6a7c92a24d06480156bd7830896fbe6973effe443c16713b6091cbac7d0d8ed19dcca8ad9087e625f476116ac3adc4fb0266d24dd3761c227e26f0d9a0d5f72d577798d5d951bfd8076220a1b841254b2ca5cf0924c47b4773c025a35a108d329f4e8f1accac74283db9933446258eb298782c3f5cac28dca3c8f9ec259e6407b6be75cc6aad6b1030086857ad3c7260ba5ac474f021fd431df13246486eafd54206802ba195bce894e159beb191581a8ca9a97a9619a94117d2dd5b338a56e65a5483384be2f139790de7d206b9f5194c6875e80039025474729f7782627ebfc1a6e2cb0ba29414d2ab45245dab0434f882ef0e9e9cf199d0bd09bc373f24e76ec79b58e76294115e62f90b39f52df8e1caf24074123f8275287184fe318f3b941f3c2025221f76ffe02fc93bd532cff49874dfdd04662a994f0c5c558ae22f3fc73de7d33718cf7a75c062db468aff6afa93a2c77537db294abfef492eeb11af1854a3721c048bb4f6851d96f02d3ea8adf85a4a31f9430fd9ac0c60976239b7ac4742c208861c2b8b45ec3777b32517088446acc49001278d1ac691f14fca3ee92171c16da5e7827b5781e298a53758684d79c67cf825e551dffd364afc7dcd0e3730914365e5650bf42fea711d3b1eaf5ea1ce3df9503d8403f8c49fbd3c99a50d3e3e70744e6ee6384d20b7498e28047f0cca5aca279ef3e1372b14a552c038f536d0c89ab3ab4dd146d5ccd0850bdeabbc8cc07e532434a60c5c54e1dc9f85d439ae6ecd0baac84522174f3d925e5378a12eb7b2cba27c57c1dbf54a0b7deede6064e0f97bada0bd84cc80cad89582d3c21bbde7f278494ff0fe9cb17eafcceccf3dc37ed6608b104ad390bb0dbb2535be9b02058b9018c2c92a52b56f5801475a2117252e1de38a3fc92cb51f33cccf225c2148123e04b7f312d4884693e2a3775161caeb094f4fff248548def0d2ee04a0e37f83b312fa2f7e2248fff7ba50e70ce4e0feca082b78fff1a4932bd0df56722cfb47d44a87c69120783206eba2b9ca4926a4d2bce0d7188e93df8a74b1a6b7f08b14e039cb278f815a0ed789a5cb21ee8923015fcbff9d5b651c4256627122658bc2896a0bbae2a2a2f378469c1b38a434136e3c81634979cceaa922bde3cc425ec3dc119064ee1dc11ce3c59f70fa18e378c291dc27e8820a68c5f0b0003b1fdac53f8ef3502fbbd0ce35f33fab122f0c5bc431616067cf4eccd04ae5ae188f98c6ed2447e567adb019b276fb2cff9f8c34b5ccde4d3fbb7993d298b5aad8435ad1bb640e12ed851fba387af953b2bde9790dc5111b58d303a0970612ee60c1845b80c3d64b619f77c7544b308428d5d74de1aa8982dd8ff5a9842aab707eea1000d2ac7dfd569f4dd72d3559574aa6fa9f03627bddff02d5db6a019849d2df4fdff2928eb77f4b783b868f37fbf819e0a8eb52edae9dad1b44d2a5f5e61c155423d4be0e73b13a40ceb3b4190df670ff2e05d65e063c40b999f5fedf1518af01456b051090c6f3c6afd88c22b97dd01143db90bf4d280a5b3ce193e3d5b7d152959ca6100208ff6928d3b969b7a5eed71baf8050a664ac79194d63f5a0d40c42c9f7d9b17c3e15e946cc0baa895e90cd85c5cdcb1f1c0d20898fdb9a833a7444195675ef6464624517c8152cd13406bc5dd20c84807c00471f1b2cbb24200181c04097eb4404a57ad5f5b8b9b85305ec07949528fe7dd3ffbe13f19fa6dc724ab5186bf4f49ad8252f690632cebf14fccd3ee0aaa47e33e0266b28bb13a4c0bb867df94acbcfe83ac4391c959627f61e31fef8319c1d0e1cf34daf2bcdc4d322b232cbd7355a48e93778109cffc5bc55299aa3ca3be4b40d545dddaea34188840f4bf6b90aece62ffc632b5b1d51989a289f743841a4c467e6decc3ae65cdeea142d1b0e3b19f0e12b08234ebbc80b68a23feb6d5fc290dacf646f0695938e0a850febdfcc446ecbee57b9b0ec7284cbb28aa790b8af672087bb4c383c41fd6a7b7494e681ef48330b8c27fec72efcb68a938d7c68f8d89f82ac41ea64c3535575415d04a0f62ea4d7c2a477ee6ea3e01af148e65d05364646178026d447d81f2287602296c190211e09b7f6412c49ff27092b26645a34ca8df8a1583e9bbc3bfdfcf4814a8ed3d1cd200188a6d1890911c3fbd5ab267c6890beed431e35f68cb2173d82d0802f1bcab9eb1b50ca36db79b566c533874b7b3882af187a9acd194512e486e739299f33c7c692f948d0500dcaa755ff8947ee777b540d31738ef21a8ed25759f943f08c27cbb96c31fdee34affeb8d0d7acc400f0c19256f25696b9e3032c1ebd4f350a809335833a1385c8fce4ef2805fb36a20a96c3321b20d32e31c1d4bec733422466dab138323668185739cb7cdbef35ab29facd9c6f0ca4bb887fe783032c2b677fad44b0ce46ee02498e9f992cb861f0e9adf4a3c7fe51e16e9338d30e3d7cefae5ccea8327ba5af4b8b04fd61f090499825bfce62b2fa2e315f2d040ab80d370bae1762d7d5fd2d800cb6f69de9ef412928a3704b66c1f5eecb4b4e5c40f5ad53fa5b36684c013a3516c910a63dc345f4ea39c889ca9eb5c73771e584502c84aa74c9e5cf9d230d98ae7666c59988000294a22ad916b74705f4158d1cd21d7170abee491774230604cb2dfd9541abf7ac7adb8fce2c301ec728189481f54614ca811ff321a9f3362062cc658b743aed96487109644504b2905f815fe03eec2f40ee62620e6edb6ac22f9266bc7eba722cda9919e0d55dc942b9f92ab2b71b205e69bc793c1214392cd939a29b51d2837c5184e14a1a69f727992665fac0c89651cfd1a19fe39e4087441ab946a91832acc32c959dc141ccc3af1289ba03d69d839a3a5ab9bedebcee680d4c98705f8015a6ba88c88fc1aadaea96bef1d62f7a0f8a288111366e9aae60cb611a39efd470774098b899822d165741bd7be8ccd6caf0800f27b647460a4a88f86ec5cd05a167234df12ec9cfdc1b704a2a943b393b11022e0ef0bb9cee6ce1cfaf4c60b2e4677827e96aa612165bec5de19dcead7e0f7a02a97c820d4fef663e8f3445148e4f2e8ba3e712912be1a3d7ef2e4f665a89624312d18187771343e6a2dff848e36a2e890521ad7aa4ef1ae6ab00b6d980d56e2dfd5b46c3c25a55c292339f78b6182671bd64321cdeb1d46727e5d921eb4e4ffccd48aa3f37ab89fae978c3ff57a6424bc260e389271946bef9032386c2457d8de06b05f2ccdf6f9443f51d829b243f91c3a317c8cc66dbe34ccffd1d1b989dd304dc55c97e91ec35f3f0771a2467be077f75fea7d29cb7a61d794bbe549d4b77bc04427d464ec6b1276ea3294bca6943dbab1560808f4fb7d20759de32592ff018cd1d0bac71a48aa872ecea7305e085dbd3670f0a674981ab7e5ed9eb70ed68e371101ec660f69c42220e96c3b9c1778cc71f6d4f585bad5f3b50100ba090eef3cc6336d56733f015f8947b44abcffdb1e55adec6351c4a939650a566aa6f028a0b3bf9b4781473c679b78a6979e6287feef36f86292bf0826c84dff04a204f6ab230e3c7c444034daff25a66bcd1fa41a8f894ad219519480376054c8bc5e5f80a54a8c951d8e713a342393552bdb5eb76857e8717153a078789c1256a53fedd120ea3f8311d0f259b74796e19be59f0cb450cc4a7279f48390abde172f5acc0f5ec089dbcb46bee4b3567e25a02ef6c7981e375726243866436844e75758773be41d438f00c1bbf8699a09f5df83d952b58e92b25b974ab878354514242d9d40fe21c7bee020e0c8bc611728e9a4a29ab7b6028e97e127aaf28bb4fee15bded0dab686a55342de1b15e9f1e90a15e4bdcc42de47d52fb466e7d87db175b52de69d90a5a7ba521ff67cdc6a70f48ce99a55749f1d7b10095189bf32e129ff0ac50d3726a3e8b3b0683b30570620b48096c928d517e8d091c83a2eac37ba6fc3ce8fb7f617782e15e147af5ce31fc2c4f2cc73cea9bd39a3daf4c6a8891bb40deb99a858e8681eb9c1b0a5280da81e52d1251c1b75d0b97d50b50e94834f339e10f6a6d5999ce1f1a402879ce2649b9cb5c1bdc1fb331bdaacb92343f9ac5ca637e6b098cd2cb19abdf0d3788bf4665a5bd23ebe982f79cca5852aae0fb350733e52fb18f9f1b20442216e87397475bb277fe5fa0d427b533dbcb6eacb504ef1a1939ab076d0a687fa016812da338d4880c93f7ab9a1d0aa0b68d6e41f1d9f3d831ede363cea889dc0462a69b21b95edf51cc4c70585c0a58328e92950adcf8c36f788d6f0df0f6585764de3471b18fb43c453134da2aefb4c675cd8b4493badb1c43de87706ec3fa52005167480beda52fb7d64b2927a2b7581ce9c4bfa7733690314e387938cf31f943417fca60cea072e30d0f4bf44f02a70aad22508e1c73b5bdaf2d676daf55ae9197d6679aed8cfda9020b3c0af1087a3bc2203b693d147a20bf0ec484f981840166731c904b4f2ebddae279607623eebf4cb2b0125e50f6bb1de891f4912467028476bd858e5c079101a8279f212483b58fdc5ad4a520f9a3b56ffd1c16fdf57a5a54da827140536e06bf61b928697e26de513d23ed3bd0213547f0bd60b652b3d421030f96f7ded4e3d13ebbf5869089414e8c1d56aa001dd1bc6e730190f73aac6181972d6247f5677aac2200feec2427fc900daa08b231fca0f3f91d7be4933dcead06a0477988326e12815766db3928ae7ac75e3c3c1b3770c9a9f183801b9382c0bea51c8fab6254bef086eb9735adc43e73719d6c6a94e70ec43290e0b0a4ba7c1d29f9f6de178a0ad2f5dfb8cca8f43035746f68f3b36728b0adfebc7690b9e1375d86d58f57eb3b4493b4aaae9e353f8acedf89d2262d223339dd631acc8e08aa5b03c43d7d76e62dc36d57b8883f87b499f268dc0d3a0ade89f6f48fb111109e94514d128f4c5735891da3ca754b84ac7ab373c23d8753cbb42b709ef586a7191ec5dbe7799416c6dd6fc6347e36d95c4bb45c874419bc08d64107f006fbaaa750806be57206dfc9d4fc4ae12b606851dc6e472035dda81b657819b0840a7798babd3d59383da65636e92088421ca7d5d482eb6ebbd9624cc70a7b6393093ff4e3b2fd255c81dd3ad027a0627f29ba7e9086592b58121a2f1d5362f96356c9343aeeb7401bd8ebd0a5f8292c13c42aafb6f265aaae90175456a558ed385cca07c96b4ef8ed6de0669661dc2f4a732adccf062669954093220d7f7daf6d3142a0177d0d443af9cd42f3c7c4ece451eab32b80f0086e41d5de69d4806eff98aa08f79e2117e30168d8a89861d74bcfa984edfc0b9c40e45336ca49d743bffe0bbabcf95dfdf11c4ef1f33235f01e1e31788dc4223008d8f42dc7dd0393c07f54ad77101d8131b26a6e0d92295844dae3d42f40885bc83411298cd5ed6baf62ae64638be1e25cb238d379046d1992d5fb147718c993e02081150a9bb30ccd7dc1caa45a79b7ab016ad30f59456c8ace009a625bff9a3c23d76bed6965c1935acc967d8bd636deb626fb7ce0d54ec43afcf3fc36e26367b204c6e4a3f97e2a62335f1c1a27e15c66a9ac43664203c485571a005e8e6362c25c5507a6a9bcf2e2858fb039cc2035707fdfde9b48ab0154496eae41896b6124d3abf14df9c30f11087b1a90a2fb99a55a2f7a47aa41cd1ee486da7c67e48c584524ff5ef550ab93d74d4a1a1061db0fca239ac988f71daca4238803427db890567b9cb6999d30b901e46ddb038fc5aac2b0e3cb192c00497af88e582befa224ab6e5a713dc014c736a5f4f840344007b9a86c7a685a94811d5ab6bdbdd9d5f5dc4bc243646a76340ef82a1c178de6115e913c23ab8473046f5f2f3344d5ebf2807be8c3b78151cb891bcd74ef00c3e0daec2dcb26b0436c1e5c5a29fe61271f09efeebb331e0f3e89e0968e47f9c2a6a2492913250d25fc5ade5bb82b087871912839cd7867b080811815c07c36b2bbbfe7cb9238a921bf8e37bd46fcbca1f458d1ae6f28918640f0fbe9d14cd97e285093bfea638deb640ef28febb888d469751aad5daa9b6e9d2dc6f3e5513bb9bce16f07fddfe6a0fa91d5e0ab86dca6438ae79825a0d309741aad6f7b31e185271499476bf0fbf03672d3470cde73ba5cdcdb4433d6119e6eea560182d772d724f353df0e65606bc2d022a70750fc832fc44ebe0cdcbd0a2d04d070b9398dabcb0d6eff692ad082fce19c14e871a499e5c3e4dd33957958d0469bc8f98a66096712721f9f29c6263dd5c5a0efe819499703b22218cfaa74f60e96cfc9789ba29b5f7b9aaf3181e178e3357b53873813bf259329b7219d6652d48b6acf29479c5ca80b1cbc01ab609d63b3f2abf7de7713a28d11e1724e42377497261eac3d1f2ddc9c3a3070c0f4df506cca79d0f95727e6b817e6b2f157f8980fd0449a9d2d2cd78146ca25578b4efc22fa762571d89188468bf1791c008fb22b2ddb3921e06af8ec825972e1af9533fe3e40c33e4ff6bea7a733a4dd9308d49f1f1b3d330313bc898da414e31b5055c822acc6d559f02b2321e8982d94026711338b4d6d10c2083ff02a60dbf7eb34f469c44fcd9f07a1e9044b888ed6df00602a4ed29a440ef8549bdcf6d5c1b08e79c4c0dd7430e6ac0cede5fb05f6d9b348d0918f8b3a4e5ab253f425beba0045f43f2aa240336629e3ea7981a3ec14c9151cc528a87d2380f1b54db92b46c7fe552dae5cb3da2aec33e3663f53a2eefd6066cf41e659803aca16430df658d21a01c2a8261408102281b893a12f354507cf6f5e24d3c01d067156c74c43a121e180ed6a4f86d243fa5526672220bd192f381877015e37b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
