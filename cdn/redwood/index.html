<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"431ac50bed86716e05bc33e62cd0ddea353f647ad4e6e43b74a93f0fc1e2de7bd338f17934008f4afb81360f275d19191ad9bfb0992950ed3580fce32a8a221fdaa42a551a6fd7c58e5f984152b71860d3a8c94610ef34088bbaa93afd847fb2c276194c5513171f2a6b4e9e24f41d44865eaec8b2fe91c3d7433930e95cdab48d3467f0c18c8b32e93be9ff2b38e8df909e682a4bca75b944f76b44c4a15c7266a208224b3ded7b58abb428cdbb1503d0c4f20efc505a10d415278593d72226f2beee62857d3ce1da6b1f7bedf43bd5058fcf0bc340ca441f9c0b586faeaecbe5543200d559606b502a5ed7082591a4ffdbb41c1a83e6cd6ddd2e5c09cf52a26f7b35b6fd2071c61750623fc1cfb1e14ef417b61bc0c9be1e374ebd8803a7d98918adc9e563419e93848b31a2d1edbdee2a317a89e3d32ae990c66f3799c782a67b4e55fa025927f7c83da769c98bd6b0759810f1bc1d932187daf6701bec3df51c856ca24bc93696a00d10a76a1a7a510d8db5fd682b8450bcbc7ca53dbcaa7dc1ce8ca7b7901554d71c4f54a1337468f0349586550e7e0cefc74dd1a5950926f85bfd55f2dce949c971bdbb2a5321a4ed160c5987b376529634647cba300c9bf7025b8b5f1d3ecf58f2a3dc5c62af55ac3ea4c6a9abf911f7941b70fb51aacb3a65152d5fe25a1147b7d65a6e1b5b4d8bd83ab3a58843f75ca5c4dbecbedd30f890641eaf44303e2ac03184e40cde71ab78ed34c55917e94b1d814ff468b97b5bb74af9b3dbd48585fd39a33e084a06069344f6e1e1beb39fa9980aa1180d91f0042836f4ad049e8c5df19ab5d573b2f02b728817329ceb60a6bc2cd7d164698aa6c2bab5afbc2994474bcf6af7171a4d3c24ac0fe6463100e0575f30feeba162121fea6d2e3684ed6814e4cf8898ccf3a1ea8a82233e21db67349ee38cb23f60896d7ddb09d6bb5c15bf79fe4b71914ff1a5ca118b1c75e27d08aa8c18c9c7a3412f9fb41c959efe46518d88fd8d7e84ebfed83aec1ef639a45e2af26ffdd51ed6978621ffcde6bb37491ef5ff3d88cfb85e4aeb3115f8a61a629ce4b8a673e654963e9d6df70cc104b9c846a070cd9d67033d2ca955f02a05226b090b56d30d15fe062c56bf5c498df21a7736756fc9ef5a2342f5870ffb82cba0b2a9e19acace217640b00d6b17bd06e2657d68c1c9041c083d44f12a48f58434fa3b1987827ec89cabf634938901d7ea04bc3413958400016b7ae3b516dd773cadea826af2141f11c34231d4f26a15549d46dc8d65c439727e1b7cd384b539b56bddd99a0831c312008cf2df75333f4e1048c1ccbabcf60926e65a94d4e504f83b17d7e2ad5d11cbccb86ca77a67c9434a99f831f4276819ad1941a7f99337c5d0a1fb6d2be3f48fe21909749d4420642d2ddd5c8dca33f3d81bc8a2d3085e20e8d509ba6bb47baab6f6925c59bdbd6f0b2614fe7174d67905ad9bc17a5438064cea324d240a99d05942414ca933f6949ef8fdc10dfd39fddb4ac3bde751e2673be6394d321a38effbcb377042c1228959d0fe82df3c1bfc3d23e7f8997cf4ce988cb9324157fd6f37b700cf7c5f069b2c68acddc6b684d9ebd9064b35e20255f64aa3ef3403b0d936fb7a9a0040b92a2d6286f384d8fc12d1b063020caf2c3e7fdfe1b92a67b42807336e2b601d49778d2adbcef3322fab04f169f25658a6351aa2c4d707c85654799250634d14c438bd13b1b2b78220481b54d75cd0e6bcdf4d0e4b7d15060643695cf0613ba5fbe1f61f0ee3c9e955880465c3053ef918d3b655e32cb864e537bf52e9a9c3be8bd1952c6a83687a019f2eaa8d5496cd652cea68202db152ee39590f43e1d0ec18cc252d55cb95e745d0862baf3f2db9a32979248f560b26c066f66f07109e7fe431941cda46a8fe00ce3673e4b08336a613b8e25ea06595703918117d6ed00521774d0a452e9ede66239ff01d0889ee3e44d852de5f76d899bf1d49dabe64d3c52fdc9263077c8d03288248f8569809dd1902a06b055603cc67d7d0e6168ddc24dfca7abf3127e4b0c3d5a3c047c69741d82ea981745b1dd8ba4c4e6f56030b39da441f9fb7e5995dc9fe3875fd6b2837104c639dc4bfb98810660f166ba3a2d82b22717ac07d8b4e963b7fb44a52099b2714f099260e5d36cc6c22bc634b6cc06adf5425a0a4863de4c780d83b1da7f69b5a4b3f7ab17a1fcedf6bc8c5ecea1f048ff68bd885ec6bbcc1b01ada36535fffe0a1613fbf01061fed7ff80ca4315250cf9dc4583ac4f769561dd8c8836d663ba1a708a4a245b3be6b2dac3ed17addeb91ced76bf0a9541d651a30b38ac40df3d48ff8ff444a7604c37a821fd918c00aa8f068cd8a5a25a14308f5482439c788d57c6f8e68de8a560b7e37b591a64fde4191c438be661ee0eb044ff4aa129f123523a93cc758df824bd9cedbf6892e7c017ad76db335444099c73fe28de10089b86645b386dcd31400e218f53cc72007da1717345c58efb5ca829d092a6904b6ebb1fcce2ef9876d3db2a27319df598c50877138bcb6cea6c222a275840c79c3fb582de37ef6da36bddce089dc42e646ee781396b2f97413eaf4dbad4ea12cfb6497c37d5c7d4bb3bb473591c75e81abda7e25e89502f3451422d7b21166d4d66b38eb1a1015d688e3e8198d26ad5598d55d5e8d6d28fdfc7a744dc38a9a1bbf7a6a430db0f98be18171a79a5a0ce555f082e647528a98cc4a0823194bbc08efc0a80202691f8cef52267fce4896623a8fa87d4497ef4b3eff6b58a708c4cf81f71054de8bddecd9c79c03104fb87294ed99f4662048abc4bee80229fe9a67e4cad3f15c17df1ae2bfc5cc65e4297ca37c927c7df89501b3eb63e928de378c78a3d33ed62cc81cc2ecef0af088ede9b3403ce8a8a61a13e38892e4208b7158aaa465019fd2b2df468a712f9a4b3bc3f910598f197acbebc8d5730136495e7e6d663f370d3ffe96da005b7cc4c5f40450e7af9002f57631c275c2a58d78c4d1f3f7d95a102a2c25f0faa408406c5c0a378612113d99bf0d15c6e421d8e8a6255640b87faa13e7e2b4335806539e161f24f45033ea40d6afaac04e6741d9061414c6efbea7cc9f5896848e6ea64207a79abd6518c2f28082d24361d5078d3937c0e72e7f8cfbd2dedbbae65565831cc85c208810cc7d0786e4429b829878aa27f4949819e1063feacd2efdb4d9c01c16a14904a1bf8822593890274056dfdbdc331db0086fa74c09350a01e299f7dc7a318eec81a4d34d19acb5233d52d5452cc7f72ebb678a43cd30798f69196307a7dfe028057b5388f8ec1e2ca04bd8c48fd488f7b9d2074cfa27ffe5de2b064367a50777879392008d54459f21de0f80d349f9724b57554a76eae5d104eb1cc6ab5a38ee35bb312d56d3a7e266083d59fbac28b1be5055d6ea8bfef9ed31b154e871c7e99f142b17f4d8c1ea7799cf52e44528b435594c3f84b5ebb69da7a43626b7bd849c95e121e403dddcc71c6b577a5de3c612dc1065cf6a0c6175946171d157f0e4cee4681dd4d993cffff192068c9ba54bd3c22cba47810a16724fef90ec7ab5406336a03ca819ce90e63d4743f7409d5c23b2f233dd6bb0b89e1f36ff2baa22c56ca208391ed98f510ba9071f1e57ecd964d55d9a07f11ee6ed4981f00444a7a74aaf6d777555cdcae3971cb24be876e492374dc42ea8722bf62bccb6dadc287962da857209269ccd235056aa93a77f8c2afd028df57cae1c056d004425e972ccfddc79aea9808bc45789ccb33d2a177a651a2a94758688bdb20734d0aa7402500f8215d0380f76f93040bebd5f4a874ea214a9467a9558689538711cdd6a17f428df488b2959eda102bce6b44590f84f4307d222b4c080e64cb7427727231de88a16ed27f3786e3b08817ad0f125343e3df680f670c53e485163806aad3ce1f2273327027c439944dfda728de80d1b84bc7524e8f0eec58352c60dd7983bcfa82f603a32ca3ff33a2f269f0f87e079e72b5140e0252b7ae51145fea8eeea809f9ddf6f5c8abfab9239652425a6a684a863ebef7d30ef1f246f5cbb96a41e03981db288ceb9651a788fdeed6bd175b794499eb5f2fde97e884af6f13b572391836c6623529e1080b991d207e55ec71ba97722ac16e8715d8e1dd3af3cf22f5e4989c0df9cc88a2ec5a5803c53aa761e969493f5a138c01065cd6ccb646f9da587228977e45382da0c0f3b2494bbf00924e4bc34b47f7439fcbcc6a6d25b108da52dc163d69461d74032218c4a6dd31d4c479545d4e713d1f97aa8c939fad1f7b480600c6fd93505dbbda79cceea3f9e229af107a724895d35d131117db4f9486893edc27252715649694135361a5e076ef094ced76a993a25b537e23e15ae308fd07e35d0098ce2c033c2882f497810ffe226f5277e250e20a15cd5a47aa5aa6040e3050cd4c5905009d9c4f3a71cc2de6b26c4972ed8d6d1fbe5398798e4312dc63b82c7261b9f50a6714114508329a2a09bbfd5a2ec18e07904a5a67cee0cd43887f764605f74cc7b46f71bac701a43daa59d2f8d71ac6b604725236e5900181dfbe0937dd2508917fc96f7148349bb6b1155fa142ddf34c075a5d326eb1770624533e2b67b0ab363a04a34cbcb48910899d9d9890af25086217e8b1e5f783e3d0e27cff3fa73b6d630c65491461bf0f4b1e3fe3568f4daea63fbee3eb21634389840df407564eba643bf894d097d0b2d2ac146da7ed6d71bcd200b3329cd453e8c8218ee9d0cb360d035607e07cd07c31f0c5a803edf4212451ffac2714d3a343c77f8954d07baedbafdad12fee0ed291295711157f02f6d87b30b68f7847c5410bd1d0ae918caa22bd73798ec63d34c9cc4e85de81f7ece15e47b98bf738595babcdb6a39b4346ce85804f0fe3932e7451509897abfab05073e60b23c3154dcb824c963d3cdb0b76bbe91aa968064074a05c578eb57c8eee0a771c1fb77b006937e44fde99be510e10f36e4410d0357b34b97e3e6b885f7c74a7c19ff3b0093314612c782a54722c42db3246ea1aa1a25b55aaa4a5930b50db6758448fe96bea5d803b86ad2c1df06f0cb17e36207b7a1ed3a7f186c87167cf0bc20e413f0f6349ba34c2b5d272fd648218b8e5dbe3c65909e97d3ae5f4bfec05be62ba5142972e5661e64320502a61227ccb5a49cd54ddf793ed17ef53b1e942148f5ee0237f28375274835b0b50a64ddd84f7239db4a6a6b4a3f8eb6db4d22223873ab8525d627a1a6d82d73b629239954adc4cae1597688b3a7858c5fccb0bb1720a1d8a7d4826b5cad65559d297f1a08bbfe44f501d8f951b7806d9035eea9f89449f71ebf1f3a29316bdae5f98d796464ead62a98e2bfc74376a642a770eed35da84f026127f1124a0ea6911a6956926bbc8782f7f970481876048820147074dfd8e51f29b4b65a3ff9a8a7066d207eddcd567b40a7f38057fc414204623867096120f0df38b083ff25a875a85d6587909c87d0239c5f816c59aa60672e0cdcdbd9a9b847d3d1b02d3f923bd781b5a0bd85b1664aea6e1f2c3a2ec888e7100394aa55e18268b521210a2157776b66891c4669777b0ee7a9ae9725e121df317e0d1f0f9d75dc8d2b08bf713567bef723edbc9f2856347e34223f31ea3dbac50f00965e170310a18092a88a69a95226e90da31b49c8e1fa0be785046b88274e95b54d8df12b35a19705d9e65fa9c6dc65e9a07e169368332d989e664b105734b421cc955d6364f5fcaaf0e1f7d9856fc984dcc6b8074ba0cc80b5da3b78c24002e46242eb01dbd65a81cb593d52b489c9c88bc546579b8e0e5657624f372ac0f139c68d173e1ac06f7fdcf823e5ac12111772c4892bd7238f3f3a7c5abdcc4e6ec449c1c16674ad72b6a16f8b735c3a6dddc1a7b048c0136330aa0c8ce8298cec84ce3dfb7ce3a650b8befbc774088bdc7ae781f57916f3814b7113c4f842fa026c6f4e9a1ffe24e5220edba28a74d256fa32161cf09bafb351ce2a1328adccb0fa8ab9dd513cfd48283d23a5046bbc51d135404fc7d4d9105f24cc6ba5577806180d8f6118142e75401ef9cecef15a8a013918bfc38ce6ead60d0b92ee8311a1705c9949f052abee5db0043cb85f03a9e7276e2dade8195cb812393111b888e62b212a17f845e9cbdd6c48d968fed0b3e760b277c65f5a2fc69f945fa65a2fe80c15182cca00ed31a95e9d9af3ea0c6d78d1d6e5cf94a5abf7ad84bfbe23198cd6563d127c191d1fb07486e8d3575cb81b1f68f6f98e94ca83ea46f3358e0afec098f0898f51e6cd1abf53a5b4f5a4a4c39b6f3759afe7849cfe2e1012b77d63bfc50c05929ee5f620a92d4e257eec82b5df70f0641eeb769c6ea81064c05a434243d666038c9f03fa6a5e880e17b50143f92e0731602952153467e42dc3e041d911ac25178a5e6f0e141f415fb14d061838a601fe1f6fc86f1d72e189bceddf88a635c135719c68aa3dc629a824bc118197dd2f02637fa6508845fee6ad89017ad9d0abb98944d14c6f6f6dcd0f0fe6536eb9751e8cbf4ee82d622e4c546a8ecafb8502759a1a6df0fe51a3e7254be5bc63c154d647cf013461416dea942d7ffe1bd5d5eba1ea5e32f437e2a2039d4e9ed6f9212717097d1ae2727ae2ba19d0bbdbd86e7321156ce63219efca68f4a3dd11c6cab192d18582a39b2cef6cbb2705f0694b4a5b42664f2d8f41681aff12cb18ca8996bd5cf50d8cf2bd24d01c1cfe4688bc6030e2d3493cca2e4ab9d7578e068b889f6f3c1f511d614e0d2b27754b01752b187e367ccf99496d6f5845b6a258d77d8323f2714124941b9fa1825b590e96bfdfdc27fad56cb4ffa33c74aeefda97809d76f1f84a1c42248e3de36eb5e063bb5befc2e6ebbf35a067da74943d7067a49cd665346740ac0dc328bfa549ffacd9abe6443b4cde09bf9b6c9970a0660336c00d75efee2a710d3cc6e991b608fa2116c4eeba1ac8528eef01b8be0b504964b14dbf0ee3699836c8ad06a11c1a559b116f1f6697f2cb148584640b73e680759fb458079feb941ec5b27c05f0c578fe836ce81d820be1800855472073d65746d85500d533d3eec2d21f542169317cfdaa7a9808c7068db0eb0c1a90210f47c1b197f3beda50610c9cbf9b0cce377bbd9a6f9cefc760007816fa75185f99f16edcfb3e7a540b009d84511ad5a34296d1400256c18f73034c2eb8d597558f1f7537410289fe3020423b04f672f84dd53232400b39bed0f118a44605d12687219b09a7e2e66f41d2e135a0244050835914956c2381e5240f562565647d8a4777b25a951a65659fadd82019ec228052195ad7fe435f0033d62cd7cae983b7c7a32c1464d63b1769f8f7dab12bf227cb99918a03e524d5e85a5a4c06cc484820024181b79a5c5ea8d6b7329ea40d46bff49344e8f5d42ef01139f0cb3dc0e1532a8cee8fa3d0fc23214607aa4a072a846aa1b548d47ea534cc05e93c206d61d7b61eff1df8707b445682ffb47bdd2f8770195546444c9aa7d8472371020b0ac8713020a83225cbed3323f628e97f695630e971b3e92c6c00579e4117d6af93cff767cd52dde6eb547def70a95c2193e40142599742b538f0f422dbbb130382eddca9dc9882117b9b05d1cabd18216b2f3d7eadaa390b47331e7368dee6f8ec0aef8a8986955b00c965102c48d5c54055e499c9cd4786fd8fbe626a37c7dc9cf9f577f11dd0a5c4591df74a4bec5e537f7b16a6daffe0c14313104f90fd36e495379dd4cfcd984f7aac80798355b0dbd1d7059862d9f5afc6dd3d19d52be34d6ae7dbe2eda5baa39756faf229f0088713aa4389876491021b8b9ef6d7a77239ea98ccb76d1c42a07b6b0008e2c6ab399d5e5dd6b08cf2879b722f36e23acd9591d7767add5497985c274c4d522e3c2446ca72094dd3c9ea24115e001d1e7dcb2f82791d066afa6d5ba5e9f72f07700009f745922aee65613ba007ec1b1ff03799eca3cbadf705c5c90857474f119bdeed01fba410251ac304be76205246c0b72823670c1791facbfa5bae686575b240fbc8b39318e17beb99fe11e87e980cca962f8d64de81a8f4e512e1f3d7989dafc4eafa06064bd5c10b0e3107a671a2d7eb08ae74a80c759ea12dcd3b364d88aecfe7d03786c6517eaffafb4e1fc1e1683b4cc8691bb2be692a6475976435e3754cb6d4cd1936b977e38673c1be3e74dae7468345f46802ce1c4b9359f56ee05c05143cc57cccc82b252e0d495915617e673861092df7138fad63f1f2c06664fa656e75bf11e6790eaf115cbf826b33819ee882e3009a39896a9ba50d78b2aba86088275a9ddb54e6b67580e8925e3f5234aa0def263effcde331435c8e9088cde6efba6310f06c96aadc165e00da09f08db6e1ca03c4d1bc9e88e3b78514f5c669dc783f968ee94bbb737327ff955687407d0bf9d75609ef399dc406145f4a47df46d5dc426558b376a5af7f712313bde175655f17b06ded65be395424865b2ace7dd4aa4ce35217704fc2af6489a96d3465d91ee51c184b4ebd7fcea6d110c701c6bab9bf585fca92bdfef0377c5567d42573ffc5fa0cad6a0fc986d689e18d00c50f42f88abdd777318c64d0715516b082123f202f0d38c8a5a8ceccd09d8dcd20ab2dd056a936d0ec290d4b7ca553644f716ee0805e674888a934d6307bbfca923373694d9d55c8310028762ea8692bcae5f8f1d72980efd638a09fc29f86aa3e068d4c3173e2d3161ecc7bf32a041d3bafc3e1c00f8a8bec7999caefdcc8153c525189505b3bdfac123caced6e3496333f5ad909c8442e078a7e954b164c43f4a518c8baa8745adb07e82c49cd605a5d69227e3c6a9b47cd2e53307d232688cf56a51ad5f350c767b7e02790060981690f98e10ba010d699f2e89a6187ac8884af337a98569ac19bafdbf47d20990ca66d01b7515b240e7b0d5a3623312e3cebb8f3650100f956748135a25aa6ddf3b8d648021870ab43cf8db3a5e9fc2aed2f21f6c4baae20215187a5a7956f46adf00acc800610e0a10f50bc48726859ffc74c9a2c5b76f0a851366783fe564e3bb8135d9469f97a1e3b9dbe54fa8bd109ab0758de139e3f36aae23dfdf443b92f96b06eff0a630b12ef8cd68f5b6773267c9369cd11857fc3f0cbbb61ea0edc0e149b2f368caca37e1451162dc53e238c40dbc04e1780d3bdb578642d500fa722f55f9f27e409c93959e429139f8d18b340145c57834b7b297b41bd0eea05c38eb0d79fed7bc517ad3eae8deeb7bfc5bd407ff9b11a91dc44bfa7984fec456cddd30dc5ba75d35672df0ca857130ed214a4ac87530f0ab2509c16c19e4d0d14089365e41be7b1a543f66878e8a734b6c86fcfd3680147b89957af007c4cd48496a239a3d82738d93e5a96823b810c5c5089ab39870e6df1f573d9b5d14aa741113f04952a5c01d6a36b0db2374e6e931aa33f1f894f9f813236365a497373e3f0a3141e952021062f3eba81dce3fde08f066b2e720a6b3cd6dad5301967efa421a188f6441139a8fcf792ea4b26f2856c1b5ec84947b3039d38914d11580e5d7c9487d67c6d09f9c9b9d8ea2463ead355573da0643d9709131fbccb1cf61d9101a1dc93363294e24655a86833689c8e396c0b36336e41aceeb78312a8ffc07ea8c841f0044686040cd25ca4967781f0b316979143dfa5d23ac24b67285390b39a62d4826bcdb124555d79d135d6b56fdac32ad378424148ae72ac2176a5d60ab2ba61c4e4456e736973471ad7cbf41acb00cb074821ee10566497e273ee32a18119585c99b487313a1f8a818e97ef9b629779195af70509b2ad78e034fd46d8350e8128f07048574b5afe22237f7f46aeb05337648c27ffa5c66f3636d75378bbf083ec249a53d910cc3cc2f92e91452aa88fdc8549e6b11345232524c30e5a246fb6b19366d118b71707afd28b053e04b546a06b1fa230b0c9d613c7cb33832742c63b24f4fbf4f8e18fcd6337d71ff3e1c6b7dcb48a107c9821634d35ea4ca1b9366bf7d6a95e992f627ec512e8a367e1d157e04d94e447e09de41f02b4d8364cd17dd7804665ce6a64363e058486e1b2b73730d19f4b9748694fe0b4536f76369e47a7815ad7a6c7d7067bde5823fbad74433a380215b621f52b3edaf7542bd55009289d5369d59bcff3e10a0e3283290d6c17b90d70e718232ed416dfcc84b17b3d7507f4c81e0dad43b202eb118e2074dda0e12c01da37e9aa387c23a4ab033bdaae541266bbe838a32ba3e57264ed70f46b30613bba683b6bbbe0ea978e9137f2dcc9af8f293dd110dadc518b4b371971ed7f98bd8d60580e818d4f99e2a927f60cc45d884a122e781cb479deedbaa0fc93b98436330a7979351dec72914f1d83998fd2dfac696c7da696320d596e7f6894a7b3d58efe596173e7a94962e4a2dda6aedf42428b79c1f495f7dc3582568d01b434b7d5067fc64464235010f9dc3f1925fba0349beb3f59d90b26bf3b0febf47cf875c201689b701e3d41216e5d1d1e53f55cdb0f59320b42647caadb5ce77bab6ebbee047b941fcf5aa7fb4d9383e37f8e3c3cbe6b7574face96b6ab120ff7aa0a491a356bf0a7d7410ca9cd0b15ef4ab4c29b822ad263c17847ec392cb9ba702d61d407cdb1a21ed3fae1a3500c7e9a4aa3e8b9d23532bcec43294726f66e9f73cf29ee1aaa5582e2d63b9d71b08bc32cb2af5dad887b6dea42ccf056fdf4f4709cbc86bb159f75fd52d2fc3d2d3f069a2e18437aee9df75bddea1430aee5c3e38938ee2927c280153fe29f68a59ea406776d2e63fac043a0efded69fd24e8647747aa0174e0feece91a2bf7a2b91d4cb543aa9341ec1a1de6d69683765c165e5213cb976e1df3506dfe92e354b354addfb33c105592d188d4e35a4c6bb6c8217cae9f80c7ae4e8543b5577dea8f2156728747f9a1d33ed02f3150ef552cde6ea2fa6c6f20cef2651a9e5b5dd670913b569ce25d37d53a6008852cee10be4329ca053204879a39ee795d6dbe68ddc32fc97ea3e5deaa6c22d171a8bdddac1bed1015761eb60567f30e8a12e7ba876a6b40454421b845adb15bf3ad8982e6801160535f5cdcf23d651e711f2118d88160cfde33633486d59ba9a708015130b6254a8a50b7fff92ae2ddc52d43201471208ddc74a6f9edb27848a2ed325241a7e0756dfb9f8dfbb7a52ee98a8af9dc9488f5790147bdc7b2f61d9992ca9a3299e5bfe1d5ef0e4e4d94de2dc24d21e421469095c33c73db02f3507320e9476c4b56e2a6b9c9e8aa118f85e92c2251d2fac850eabf697dfa943c42c454569cf301a746414c704bcdfe3a1a9e005f63ed35d7bbfb1bdad893bce0f94f2a2614ef97445cdfaaee61f3a1e32b0b725b842c1c56831362737d1013a90e0e3ccbc5b1f55a8ab7b61ee67aec16fbc4582509c98da66c84b02bb031400c924bdbc875686f3baba2e88b386984334d8a0a228c54afaa41ae7c461daa7210d1e543746e65616ed8c54a55f18f81e5d955aa9292c80a8724f27a177208507c447dfdedb7c3f6642ac347203b5c9164b34c1586fd1705954607185e6963a3146f91ea1ec0a24f0be5904c39dd493219962ae3ed09a6ffb0db27040b6a350b5ea43360912678cb4dffbe828ed51fb1baf8313ed03ac4a75662a43b7bb56d117e7503b25600d351aa813da64a9c3ca782b64c2a63b13fd90ec4c3dfe8de0545048cd68c9e31a5ebc9845139265685c8e66757a251a09b590c574c5464fe4f3bf3e26742cb092d954015b0682216ddb3791032623eb88c0a277421d37089724c45604aca6e8cfd6d29920259dcabc67e442ba54056f79dec5c4603ac533fd9c29bbb6e52cbce87f94e2752ee4e9dd525b8ccfc808048312bfb104f52bcaae7d70151f0b0b9091085ae29aceb4d20129c59173506cf2fa4d995a277d49e5079aba246e2f1e0f7d4538b49db9e8a657de7e8851fa66e9f260519154042dc06f48e5dee1a635baa6839daabfd3649f45b4bd9f8e3aaf07c289e90512214ba3967798c3dc211af967cbe68994d9a583983e0063838b1aba77106d7683d1715386924841e3db7c2adf7ce0a46370cb46732766ceb440781a56d59e15bfa271b802daf41e07b7c9276a761dc6b7909fdb61f7ed98719e2f1594d9438ea2110eea544c1c3fc1e43c8e1d24a359bca2e15f114f380e0fee3e91e08c49b625299a23fbcbb7d1efc88f8c732956766c1189dc29f3325a084bf9517402cfde292a59530affde666888ae0593d2378812f2efb57d8ed0deb154c7590248e8faa098f24dcee13e52619c8c648194efc1734964bd85e89c43c89d7032547d560f8ddfa206375b545ed1dc86a8c7132b4e9b573e889a5642ecfb17e3d21aad641a824029d741d14fde242e1723d3a6a45b06a7897604622d0d99dc2e877a94f692ade90111b3c50be5d9758ba4e1fb144d6eab53c12519d28e28e59a1c9f4cf173bc4367df5520fd31c1acda22210aac81275eda3ab8b9a2eef758149069c550df140c0f906601c6489b43d4ee8cf387f21be601e2a205a29a7c2ec4bd6d478406347caadd9e090f1f47108730fab1ce10ee86d096ffe96558955be03077eefce440342ba9e830cee1dd04fc7f8ff9d0a044803fb63bb37db241f350115b42611a717e8ec74d2025203a519dfc921aa8a9dd41f5eca679ff582eda68d1467e9091d7c6293d5a620bff1e962e75f440e083607b6c0080486b1266bc861f67981b2be51f2984ff38975beb03d6c76204a9f2cea93879f0edb3da63c20ac74fa4f3bf9fb3f0647d2fe2ef6eb35802fd884b9cf396dbbf2fb52b0fdbdb906890ecc6a26270bad38da0b40f1c0f159f5efefde133bae17fd2df45fdcca157604b90dbf0d52d281f3c2ee0bb4fb650c5003aaf917d7a368536880a9f8335ae22f52222edc0cdeebbfc76fa6d75ed20c8563d0ae46b660e16dbac27f91b74033256c8856f849617361e04aa6581b05576c4246209ca6fbfc4e1b0d0f553cab1d2a93725d744a37d08cc0c5ccbfc75cbb0f3ceafd671da07952e181be0d632d7de247157c30c42ab6124a59bda5e6e3325fc1e09e3109eebb8491a68fe11ec00846969623b8325b880f48a343099f628fc872f38fffee419c95effbc8aa04a318bbcb7ff4d0d0e2999754d56391b09d18a6a9351442a8728955d85c35b7f58202a71a75483c7c704de91d3e441b684ffb169869c3fb65222124475aa39d9f375ccfe5699dc9900c58163ae46e92b0585e016b627087bd2e41df3f7189a4517b65804ec12b5d677adee828e2968d60ec4e9340e2f19a48a2afaa87d63454310c62abbcf6a65370ed5e22434884ebc9ea35d7f4ac0ca4f6634da8ff8a6afde311c63a452c93dce2df71870f32507fa02198102928722e63ef92afcbd43c17ab40a96a0e3c38309d9b9291508be205c1b55c28b07f4d81c140676d60143bc8b4cd3240e4876533cdd0f6767a8b790a677ec04d1fadff4079611888cee0dfa1dab8b6914d9176304f43c0359966989f08d70d06becbf9b4e4ef1a51602ae37dffbe06294d326faaf7b14761c7ccb13a45abcf634eb2cc6de2db457f1ba9fe5e098a5e7f111de771535de90ef662cf52fb000eba0525d92f31d6f477f128b45e2188f11ac0c9a3a0c49e34dcc04609d30794ab9791ba8f69b940423f940a8358253096a8f84f056f0dff24e1b080f9e02ef73bcb4158d8e742ed18bfd4d8c07d527ecb75c736cf32a2b5087924a5f3599da4720874e73634082787b581a87252f7f3a1e6ff81dc41a5bfe4d191d58b087510d91bd0217a37cf4df86e008430dc9033aa0cb32189a206788a0dc5285b49f61a8519579d178f8edd61863de676d7e9618da5fecdc3c8f38d743f6a6db262e0ab15b802aa4016f62e946985267e62611e6ce6a5a8aab863bab79a8c857a825fa7ff7d26c2d1f49008b7c5c061d21e974d6b2dbe0ca4ed5ebaff41c03b68024ade9135df2377fe950449430f812f5f7fb79377f88e94023187fa3ef2cba231916880097e59cbeeedb3f7740e3fcadbd02e675ab63d65f8e24bec514ef43efd3035f83023ed1296b2a8db214bb7928e4c188b5517040cc594eabf59c4b68d4761ca63077c836db6bc5766a18c7e99cff9c0cb03c779afcf5ecc34cbc727dc489c37fcd50432db3daf19b14abc7d6cbae073b35c0018a34b304676a8db29ec3b0742d8462bae638d6c094440db70899f58d63225ec8a545ac4e73b61d693d83882079c56af355c04a1126ce2357eeff77797d4286ec23d47f8432e93a4d5b2644eaa1a4e2032d8f09a458de9579ab6b54620c42bc4b0090a4e11ff83d8fd07d8a28f6044263aa63a939bbe5141a1445ff28975e4fd0c0f5abcb7bdc400ca0313d4b45c34c9456ee1c36fa98cb1dec3b4374c521a658bcdc039b9b2d12fbb7e60a44c9085af31faa5c65122d01fdfad8e2f8a8fd5134c8eee0ca7440e843dc2ce6dcdef452a3980cce7336a1de201e7ab4be40a7f8a4a11da4a0c48532c4e0dfed9866405f4086cea933bbe9aa0f3c5f40b57cb66c57d8aa8595158cddd567afa557b7cffa35cf527961e11cad466fa8131aec198aac2772a465286ef273c8967784d7acd5e0ec290aab8865697a4e2b58819bf81a6eaf101f6158063b7c390ec3b6de35987e9045a86fc7c0b36fdd514a7818f96cc9d38a2ad3709cd1592ac5075ff310471c13d0eb829fe7573983f7b42d58f0fca5fc1009056ca8c65a0d54c853f45707273bd9ab10054c62e8a8b3d4e2ddf383864b8bddab9f44af362ea4703097072d660997bbe842229fd6bb5423adf13c6463ca876999337b622ff6acdf3c5365dce17d94f618e3907fdc344a98c82f42bb05459b91f43192d1fc052e3dc46631f240b425a4819755d91ef030fc2a312e20b210f634272afa2efe6bb07079259ec24b3fdc90c8b4182f0c8436dc12884b423bc8660cdc65304852ccd1dab2bddfacbf46782448177f455bf1c767b6712dd1bb87501693cb47fa3960742ceff903852746481df6a8f68b36aa3b38bb6f6c1f085b2f711d6e6501b51c4d7ee3dfa82197e3e4455333363dca87d600a086a3ee1fc88d4fe4ba9d7a04b88f550b3d73da20d0ce04657aff2d37be5045b0e5469d25f4469424146e7df6d8be9a52cdef17338f7d54b8d6869ec13ec01adf1a372a7b31fc840acb174d124bff8baac6279d06db99cfa1c543995a5e5998e43b405d7d97b4aa47c7af747b9dcbd56158c57ec56ecb18ed8ee2d09d2c72411285e5ba21aeb1200afdfdba282a93407e1855411fe50a9887340011f220cd17ecee5987db71a961cb5111a5d29aa28aa5c99300fd4a31a534c8fceb99861a559c874e6ee8e1569b7d0893070c788bbe7eb8982b97b7ce9302ac92e669bfe65da241041ffe7c527384402bb38ec6429f66bf97e52706aa6a347bfe5f344400ac336b9d371a3b7da784386444eb4bbe1f8633a15a0510225b5779d9f6912184a6cbf43f952377ac64127b144dd459dcd9ab584d05e66cd6d56d1e416ceb1b28a000f5b71e50080a957e7ac695e78eaacb96c73b200f778f202f7a52bdb6e1636477582904baf6696ef8a7da793b45827af185cb5aa3d4b12673a1b73809ab0042c30a604fc68fc336b535f1120f8b4e932497df28093b7de99213b215b9f16a3ebb133ee132b5153fe7f71daca8890cd9edfdd335188ca5c6c55d850041db8a8d9a34729800296afd66a1b702196dcb5e70e8d47d6ccf60224fb6e6ba9f478cfb45d83f597f9576acb6247799a8504c7ecb277fea8ce1f5dca12f6a242ab9998a799c07ca11062e678c1235bbadf3eb5f9b8c7717977ae44e85cbd3ff9f699682d8f1d3c765e86eb003cca880391a1665b4a457364298f51ef92e3ae390e0c9cfd05978966a4c6c32adfafdad41089e252ddbac64b2b9adea6cd1a3e5a17ce04cae88401b42387fcc5b407a70522d14cd940825d2474706afe34bce8982d4ca869863682f9755aa73a63b0597865748cecabd851d916ee6d0df992e633d68576846b2eb373659b2495127b5c80387c67d073f3f127a56e5094ba8b279cdd252ff5dd4b7a8f38b8eef46bbbcc4993e54df30bb94a6471f6f7e4d5b05247b7a4e697eb6e0e4036eb8d2aaa7bb068591103a175142b7b0b680104e8720f2ef9fa2aa3659474575eda13d705b3313775eac5c3c0d737cf4a0ce7464e2aa03438100cd5c9a5eeaf0766246acfb9559caf2475769f032f7dd94a0847db7c53db468ad92773dd82933b94eb9aa5fc3a940a817e6193dc4066ef502f4fbdfbb3841b9a93f3d6a303009976dd6d8b1e6970f9c679411b15da257e5731e0469fcd2623e6188196df9aa1af007d2f3205db6c930c74e240343ea93f53989e18933b415333841d6537d662dde878dc5824231645b932b4cede50c5ff502b0f0e6a3167f22d11ef69b45f763e60eacf0c482829a5aa1a4e939328b82f36f5670c963e42f5de77ccc5616730649d9e252702d48e53ec71b0a7a315644b150caa7036428a92639c97e81d95df9d25cc1e24d9d4b0d431973adb157b6261b7da5d20901205dbf2c6df760bb4dd7d33054d096ce592dfaa8c942957064e9616e6debc132dd3a9e17fd32c6c34853f1ecd75e055a01b0b3559209696979757b81dc50a7829d91baab2adf4dad28cf733d2fbc472ba1726ff0bddef415dca6ed96898e4fc48043b9db90d7219901785107e5518ba40b14a85d663dcc2febef7077c18bfec753c5aa733ecbf8582e965f77ead860d14e5f276ffcfbaccf85072ff6ca5b8b2fd567a333d65b8192065466734c5c3a99905ab19ca012d44f60fab3fd65e097b8e6b76e0f77a63e83691b97c7e002b90d1641d7161303f666be2cf6e2e565ae3f11126e660a64b1187bd90abd40b36afe6e516efc989a4834896ec9d8cd40fdac5970ecb032c252131dd9d24b90e6b11c321b32e563deeff765a280de2f091313d6248c38afae2b6326fd80841bf7babaa4511aa593dc851afd892a3287af02685e34f3127a88ea1126cac2fc2636479463090c553a909b1b2f55fda83f2cfb5327c225476462dfc58456b53fa75e97d59d5bec83016d0aed3cc0c4c49bec6e48adf3f3f3da494bb3242571fe59532da0748e7fc2398096021707c53e32f88fda159af31962024da2937a50da237b24791b0acc58c410dfcf22ecc096472d3b50e484d192740f5eabe6cfd399fe51a75da82e38c6323a3bd7974c8625d2bbe0daf59abe0a5c656a3a0bd43215f328fdcd991e9467ed9fc1d2e14ce0a92028610436f73d1fb79f29ff40fb27a508db67dfa5bf65adea0d25f132f1c10abdfe70aaaa809aaf08b61a05b061e090b640dbc4b52480265674fcfe87cdd0b972ae37b428c5ff1ef4f9edc0bac6340a0bef05262ad5f3cad3907e56fff8609a1197e36955182cc31201759cf5785624e2f20f6a3f79c5440f8d23e240915cf8962ac1c7af6bedb207f73d96d576701240f38606cf1cce6d60a07ad81f530c9d6437bd6dfac4b15791286e2abdfe4c40a564963688f21e440ff401736ebca68392df52053381387c28a5f7a659d3ef506633964167d77f8d052e91a05a4d8b7508debda3fb7d23e1284882c0feb22489814fb37dedbbc4adc6f121704f776cd05225f25f4290eb3963affe90d951ee1bf36ecf32e79605bd9c6e0191ec8ca9826dd1b37b5e9c704eb1aa84982429fa2d546d889a8b735d016507bf1b74c3399ddc0673bf3b570ec75273ad5300f68ebf80af5ceb58d2cee98d2f0da8a934f33d6effc15a192d5567655c1f2353202895fccdf32232e58b3d0dd9181c28f3be440e3218512cfcf1f869ebd02b3b082d00edc072d2e242e67e06163158a7a5fb265dfb647cfd8a9661f1073f1d9e0d04edbe7649d8abe5bb67f6b495d98e1bc479b3f29c1974c19f86946c732a5d757fba99eaf8d9156dacaef3b1e592e49f62af0f0ad24abe0cd3872e92dd00","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
