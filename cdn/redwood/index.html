<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bb2ac2011093cc80315fa88ff9ead36fdeedf2757aaf2590261fb8cf63e72c0aafb9a16a3b5bcb421705e31a409a2d9b2a5935addcdc21dfb3347bf2af39841c85aa3fda2b55a4e142411b441b9ae8cb238c8984d517191b5cdff98099a97a4b61bff7f6ffc6cab188f8aed40b0336b4cfc1d776d601dcb0440b2e45def50e69dde732772ab062404300d5511eb7a2e5e49403f5a737259e831b43bca35c6ab0b452b96d35c1400532df0e458f73570ebb690118b5d61b7bb3399e7b847cc06010a1c787cf5faf27cc3507d61a4b2b53ad1e77f73ee9deb31e7fef22463f022a0b6f0d584c250c4a0bac82e6028f9d3a530102e66b5b57402cbf845078fd5d4dca191e0d2f063a1fa68994f1ad19a2f9b4f179e5c20868e22c4654763d5c2302d76efd0cd02c0cb20f8dd662832ac3d5dd33dd394e97008aaa203466253d826300325c7d4b951748f7f13e50995e5f6079551df55cc3a96737ad3ad4789e950080b6674fea4645dd85b8b94753faa1c55fca54aa372d2b9cabf3d28ff734161dd549a99c5164d10fb56e107d13f5826471f8934027403e3c0733fb909f5f4ce4343fdce2bc67b3b9ae43dedb3842305f5bd6f07e4b5b0f68b5ba69d181ee44bb98ab8a11debdd0f9c98811f6a354c67a1075ffba8745a16792fd3b961622d438700db99e1e8d63ab27540c76ff250a582ba7a6dfc338589420827cd65cd493c7051a9c17fa2214851df24a67f62b2b9ec93c43a779a244c63ee13958916cb9e6a46b1627a4e97ff79e9120f5e2791de118c5a18b7810aa781593e442d29d1a6d0bda6a9a6f13bcc19852e1282a01afc9207a82882aceba1fedb18a1cc434cc0811acfdc1c6a53bb7b1d60a9eb21746e026557e8f0c3b615c8ba5b55feb571caa70dca2cef9cc8a124d86156915939ac3a93072b29c1bd0ece41fccda21678762e34d4d4dda29fb772b3726f2032e64d17104f11eed721fc22da55a7454fd6e11ba1c7a99368d5c13342dfd4dda4cd9fcfa40656fc9dca95cf69059bc5aafd59f2584eec9265badcdbbed8120915465b72c1effd8c994642c7ac6e9320fce28eb93f2847e1635a62abde4cbd5d1ddda2a72f437d460e91bc7dd1aecd2acf01a187885a08ea9b2bf8d1bf6526db3842692d3f47ac841bf9a21edb86ce371f4e49e1d81ef4aaf0813a24859f731e8b3961d659673fbc9287cfcd95f82a28fb43e718bcc26042b909d48ec9a16c20e586efd221c6af0c34b6c0ac5791efdf356251c273d0dfd6c208ed18c01858f15df5f8e49c533394fb6fec089cf8554cfe2aa8b7e9b48c4376d2aa87fe272392a81f4529a90190a93260b85010cc5a2d42c5a9ee14ab8d9dfd9500ac2cf46d856e067880b93b29106846c900e389542c7dd2b564ad67bcc5b7208589004758194404fc547a97ac4ca4fcb5c27fd5178938191e33df9a15c4494b42625f1c92e7b3d354e9e8987d1b2da3c74f0f083ebd1d7b51313937aeb7264e95f5bff10193da6c762ac9832aa86ab234f83ceb6d067880bfd63ad9e56f17459c98c9470e151f3fb80ecda315c00e390119d0fb12968969de00579f89268f86d96626cd3ea3002adbb804313f1022ddcabd184be44539a256c4b5a0ccc9aee2ed2e57b356f7f4873fb3f50d6c6a60b32a17f3fdc007fa5e498a41cb2c6c85cc33c31d5517a8a01c9d073dcb5db638e9313a2df867b97f63d2c7a928d71ac4d4e90ce2cec8434b158c2f8e8da48e77f2c0e048b17ed2b11c0e6355452ac8a84a48ef5780c0c940a1613ac73a598e0d2803a374ca36004def10b84139a2990b2ca2c19bda797c448b368f894dc0850e5b8d29d4b907203985429f2d35e0036943038c0a62536d84b56fe80936f3df840c715644df82140bcc00211cebb9c2298a83efc0d83a2e2da7765a85b78f7eacbf15b9a5b8c76b7e8a8ff2bea9cbebb69390c403b9ab2efebc205e1b4871782e22626af1e72debed3f53604c5ed799eb61ca6578f23773efbd8ff112126371a40c40ed9626331f04a681c821125d2e7cf56c6b512aac89f62d27879dc06581e3c3a2b448b401e416104c1d0bb14c2a8b3fdb129c78d91e3c48f9d529ed0a6bbe0b4243f719e5b87f5d0b217d4fac030bf8800b3be74991fd5fa8ad1fe1ebaa5762c8bc679c47c4068ae60eaa082d9be3b3e78c8238347e57e796cdb1d85df801e6c93cbf1342b398fba9d5b2937074cb2eff80c98a0485e099b489af90a75d53ab548f08f4258eafc0d5c054509b7393ca94d97a049d41526fc6f597d979b17d1fed1741fb878b76dc0e698ac6f392f8db20cbe9501a252547f970bfdd78773eb0d3efebe2b884081a316d05810958c2570d1ae360b05a8d23c007862ae1438182dbe0acf2f718b41c19bd09dc5d1743527afaf9467cd5e496b0577bbd6930548a425e5111a88f369060607557a00ab83d983611b6b00b9fe2ebb0a9789aaca4da4c5b04830229335c762d127d80b9f84ff3813604ec98493c891114bda60d3970b2ed5c6b1bd476fcaf5e2a5a541e7fccc48889464e960dc31c07527db7a224660b02dfd28b6ace6059a6d179928d5e1c69ba1fa5bf3be18ac27f3d4f2a15f8bdde0b3dea6d712593ca24f55bbde44ec0db2e8d89396e569a54a388a15c6e7380d3c2f0c84254f25d2dd2fe13e568f5dcf389b9540ae81db5602ad53a2658039a24f6ca93b42361874c4f40490cebb7cb8cf168954e92a033d2c47d7d446aecdc540e4fdec0dcb0c5c54c1c0298f65cca73a9ec6116ed9bec00fc38d84fdec174057ce7b7a7adf2430a0d2ff5b5cedeab7d7c4bb1bf114603c4a32a86e439914078e7962799e40f820a09993a607e818ff5ef683d7ea81bdf9794368f8cfb1b5bfc79955c373ba4b89f9e9820e5e3a15a8ae972f5cd731030e2b51192d49d1e1d6de83cc53c50a456e892495114d1d03aeacdf8f6a81547e084aa259618731b69093fca9c3e2d80bd0672e82c9ac88bddfbf3479bd95595f17888b71382ce6ef98dfeff2dbfc2b8366657fd3586b8c0a5975532315c585f1d8bd3ad7ebc19359e63e499df260b6f685a54630e7968e12302c938542213c04ef8039866c7095c164ed35569f24f259a87c680cc837f6317d2e4616d7aa5320650fa41b59e3c822edd61885c4e71b0d2c6941066c50b0a7e00dd24ec958adc8e747dc85085f22b81652e97efe200ccc17e025730c70f73c0e6b4969fa8707bf88d4fc048d44caeb22fc021b2d3630774609240b0b7ab904be62a3be5fdad858dc183e658a13273705f5bc58d23a23bdb5d4f8e87c3417bca2957ebe1416f1ed8af0dbe22ce474a74a39c834108a9e27ba4dfe4389b436351c4af5373611b24146df66ffaef5011e4a7bdeec82bb659052567a7107d1a7b33b7becde9eb08f1abc59137f9c0610d62a3d1f5f2331d6c9d45dd60f034743bb4b699417e38ffe2d67e704e1929887f8f655c0231a8d83a55ec7dd1a2949f96661660d6df1fbdbb55230cba8b5c0f9bbf2076a0cb55b4331409858c1539e7de57c39e78be6c7083bbc2b872a2833d38516f41cd514d8b38793cd3e2711c9aee4d83d0f50ee1f1cbaa335d0d811423b1590970d19a5c29dbebdcdc0450c13fa789abe2cfe5a50d2c6aad3abdbc38a7926528273074fbcc26c8925ac82de0b68a7bbc0e999251af6d219415c5e3a6b4b3ace1cb49c8eb0f60d2be7f66b48df659e02654d96d2b4d2d69ee7161149387fb8cf2340d6da672fe3111ff3b2310a9c59ab287721a5854af1cfb8aee1206c2a4d0e547bf37d868e1101e5a3affa124fae8fb21a776211a23a15268f3d9aa9934712356b2cc4a5b1f170a562e389a88f998ec756b061c00dd3f34daf179ec1a30092f24a943c4da97e3f4b4851e487cbad86b4dec2d8b51abea0071bff4dbf737185ce90f438343d3aadc8afadf5f03eca9d56170ac4ba0dbf317fd0fc311871857e4ffe9806d5011bd9fa7cbb6b0063bdb497f99a8b20dcb04ecad7caa41ca4b32d7a3794befb206938c06d8eef81d533932dbe1471f456a05a5fc0e2c4ea0e69aa22a3bb765bad5812dabe6fa0fceccd87a7f500d8c4cd5da4787482933f4fe80834f8610a6390f822c1e9f6d49d8c71e4a86d41b86cbc8724b3160352136bf4251d40cae8910b4202bd23d5ad362b7bcea39ed84090782031664ebced017d648e46d3661de6ccf5ae7ce7e47646083b32ec5ac8c24b8c2e52178ca30dc224f310a1ea4ee9ac5771ea316bacda6e64a4044b5617e6432101e967e58e21ece274238414b743c9be22393b47fc7da3dcb01ef57d01f28e4f00cea38fce3ab70766f9a02d4b98ab4b84a3fc5902b52df3d5262ece07e89cf8e5d254874060dcd061cf99b92d829bddcf5934c18aec05910da455e1680569c855f854da128cae43c1a4ccefe3648d4fd50887110624c30bb62e0d5a12a871d8e60b2fab784d075a2157f61b0899efeabf07c6b7591e716ad3f3351f8eefbea455a7284dd4a58e1db234647d3c423a44ee281c23853ffa3d63bc3a2d252262043e3307c0df8772bafdaee772dde5085c0076124acc2c59aefeda94e97ce8a875548380f1e57a50b3d7537a19cf096abeae7bf2138772d61176d05358696b34d46684545b6ab72bbc90ce8aa1507b1a9263b896d02844eb05e20fc87b7c585120739ebde0f649c84c0a7d43c788dc1afa319cfca52e2d6c20073f3d7a6608c40d2689cc83ef4de9c072824df6ce95cc63d4cc56b2c5177f4ba8e28d1e24aabcc63104726af42a59622a0647c6eacafc13b567c81adc5a90503f26fe22ea63c47b126372a8b43e64d8f9e43db56665468b18d636431ae0c2913018abfa14c4be01900b5100d47e4350be38d4fa36fcf90757455514c6cd138d25943799e1c68871a96cc5fcf071fa62e5b17eeb354e2c7d02ffddf9debce28f9278d2fb2475fe27de3d384a3072edb83f1bd75a2a59895e475b55e3c9e7b936c146317a8612e5267434a545e4713dfdd76b4534e2e26d1ced35c6ab15e6a9378244194c76068d14897d5f0f8a056e54f149aaca8f9227b888d727dbc3607944841f6ffcff60c3a7f6749c0a0d76d2e35eef4bb3f032b0f7d2254cedf2315781aa73a81ca08fe22be7d840e803b83998a349cd082eb50c0e6b4ccfb2dfcbd385aeb3430d363284f5638c57b83440f0644e9aad8f47379d42f0401e3fc01e7dccab263ca33b1a20fec8a79106fc077db527552492dbae0eaad8dd872f21ebdfd1f58d5bb9597032e5112b5a149406ba9a93986da7cc8439d520a752a1fc70da8074c62f4dc6ebc41b1ff7484a1e6c7b3db830ec1127f82fb6a9ed61eebedf7fd07042cdbbfbed399ca372c42a33f0d873a4a813c6ac81ea8e351c948f3175208b8c21b359c799f872c8909cfbdebcb9042fd06ed3d6afdd5738a827822bf93a26b81a213d3bd2e57819263c21136d573cf8c2f92405d06eb8817b5c8fcd05f99de4e110a7cae427b196f58b9e52a152605fce353cc428e4b53f313a84a97a3992ed66c9005b5aa18f9cebf567699ba3f4c9bb63c0d69ef8e18b2f2298aa3d217b2a8f553fc9c44220827b4fab6a463902c28a7177335387a1440cda0ac1af58c7af6b06ab4bd4b3ad0e9569867d6ddf3d94823afcba61d30aba9390fa7b90c9588eedabeeb64fef9a36b82422c9d23c6cf531be09e1d00d06272b2b76b9ad64f7828311bdc994958fe2d523d63d927b411f72888034f03273d7d9c38b6070d815e2cf001d7e72da88f1e1caa612262e08b91c1e2cb3e163260cd9a80e6a1ef62c6e3cbd68dad09d2a707dddaa7627ae21ab8324175f97dc02d654621d91d7841c331fa707dac1af6eb6f9160ba060be9944d522d63fcda73822254504e581dd24ad480a0aad35185214b083337c2bdafebcd6bdb70748704a04ad3469e9f6a6d9332ab21ccc1417f9b963c32c1be88d84f96e7661c2bc95290691933d5e228a7ff121e6193991ea4bc0214f812fa7ab27d49bab907fb1d9f8fe4543d4fc007ed04c84e821a3055500b95090bbe127ef9a7471a1700006c865f3386aa49726310ed8510e144f73f39edce29cd715945333f429d36183c56eb730427a98b12ab1a213f1627787817a49aff70f34d058189a1b22c6f6809f5d76700851993f179dcc4e77fd1ce503095cde1b4a1c28ebb3aff81a720443dc15837beb47a393fc6d0d5b6c18782d44734baf85e2c492eaf57e3a8394eb5033d59496b5504a3e5e851f1c303b5669927b5aa8f99470605d361aea841ee4c063705a5e4628d3debc918a65c240c697107d21027261d448076e7dfea54707a78c224895285e52a59aed029feac775c1e97612e57bd8b0756c49f5c64b35672ec60ccd7721b8c7c15d75de5ca6718cb8812977d54de2e7c2f7101c068833ec7b4f1716ff22754bfba87b5deccd7ccb842d01f9761f983751aba91c0822f03ff499288658b6c73e8afac47a9e5a678c571bf02bb04f216f9808061cf5ff87fa28401bdb3168ea0a3218bfbe3a6f83600dfc1f3d15631002bd9737a73d887ae0cb19dbb369266f86a24737ab2282f90c911e0f74e34232de928dea0ced569074478ca1d5f108e829b931a3248e449dffdda20ac9e234032ed0962f30be31fe63b95ab9e78be5ab6e59126eeb8ca575bc8f3e8b63fa320fd0d2d9e4dbbd990135c6e56b0527ef946f8034a753c0f927fb8a322997281b122453aaba2c0beb780f062cdc9371eef8e7a69fa85397b1008af830664dfa953f9b69beaf58cf46f65bf574d07adb5e728ee2a2ab81fb6423703883d16fcab040f06112eca5993d8f092276b3f4915e57920795f15ef4b99c88ac64153795fcc44bf9d18a521793f6b69ab9c6ae99e7dad5a38f0f08fbcc1ae40212057c60a49b03105dc910f9a81c87dd72d0529be9cec0095a66dfd89f0ce870548c9d8b4b2f04cebb3be9b66de12ebe8a96445c546e64039298a63c693016178ae6007c8ee74cd011c637bc50e6471e31ca8b91446a0314f390934b15f215e1306c11f4051abbb92dd3bebbeeaee01b456e36422c4a288570dd40a370f8e42ef5efe787c56566104d26bd0920cab5e3c6dde648d50cd378cef328eeb2c8701e12a2986ab82b4cfe405341cfcd4a9cb1bacc4d749bcfaf36caa9ada8e67815778c34f1a08cfbb163ac50742b3ac16f854b68dd91cdf26efe9909393b5b22727fc7d6a1f5bbbd5b86a0b476f62a236c8aaf60809f208005ac320301dd11e661ac3e753cf02bd4072d1e0edcaedac279fa4ca6d393c047a8d28e98d5b4c6d8064bba6d9ca10e38ce6a39a400b2ed14d8897df1c8dfa8a8034befd73cc7177ad7d4a61e86f8c46b006b52860a12da05b0288a68aeae679798d6f998c4d153317d7e965e57cc685ec0014fae2f75009a14fd979bfe76e2e98358bcbf5b10543fb9aaef5b10521cb9576461fda3b7f365e371d7196514d5eec191f472b3235e0694b7d630dbfc413e00758e14a364a817bff580bec99e46c3066d439b42fb7ff28c0e9e87d0ac363e925b1b221455f1d2a80b075464d94bd9714ac4ce2b98409df1bfc2a80e288955ff5f104153559bbd8d471c2708721f83992ceb84ab9d587ffab1a28a6cdb58cf06f716f39dc2dcf717f8575b7cdf32ace3d3aa2d1e1232b61a743bffb42746dc86450723cb7d5c9ab3fe06f19f0fdcdcb8aab57bb720b6d4d7b8f5b9daea16e06314b7a66c79817dc54e4eee80890e5f68aa3041e7c89f5bc6cb8b02ab86f91024b1cae99c41b1043d703380bd3e9e6eb3a9b606b30c26b2f3d88ac7d8dce7a505a8eaedb37ddc725daa1072e01dd23a61e81c4324bb9e6b568e0d6543602ed9e392e970bfa4461819fc119e87671d6c235cba893fb62246b863e18efaa21b199ef29c74eecf41161364b4f3d934fc8b9afe1096363890310051173d1730e2d3d1b1488eea189b9e5cc8ecf7819c15f6e9a9a8d949d675851d9cde133bfb172fd6e56e7ff5670f3db3d95253fd13aec7b71bb8d769a182d63942524d068b2554b3e34861fab89107f1939a7bb131731e1a62bcf5c25060e924df0ed28bf0dd3362a1ac41d7c6047c70aa0009cc3fb256d4b00557a90696a564a53ebb29cc08c40f31813f229ac585677c41e0b5e3b80c883a2e92a569bf67f1e9bed10337070af3ba325bda3c6b4b767b75ae7d1b212e302ac1cb22a5562ee5729d06371abeec7b9cb6fb3a3c400d86d44fbf78f24333aa9121a5444c1a81bb4932135fa4275c1e0640ffa971e5e468a6fa54a317142c5b16e58d9162a4e0fb80f87783f8f42b80e4b2371ba8a713e6c11264a63d97d1dd53cfc0ed1ab4eaa396d01e30f69cb2962a3947f6d32baaad077529cc62efe8e3bac338bc4154a1841437d29d22715869ae412c85edb38005dfd616b7dd57e3f0adf3ae21fae8b13484cf5c4a9af3677f75419a13c43e945c83a6e4cb448b8fa5824445a5ec4c87350b0b8e3d2d26d94e9a296765a3cec76347270d851df21de89f89e4c78ef70a4a758f1d20cfabcda9ff2d17895c3ff6ddb2b507c03130c2674bc265e07b5f0ad09be8e1296fbb086613800988edc33746532c798b559df541f071872d34b2e77dafb9b19a7c981cf1743be888c997958ac89f377c91dafa7ff789201fed83e4fc9efa539e1db328f4cd833a5fed7b8e8337cd8200861e81831f5d236e5dec2684f466474587101e9a9710198db7026e738df85ec71bed7228d8aa9f2e0893144cac1b502e8c0b6bd4f412cef1da5f58a9658b12d762f094521c74bb52f3056ad085ab524035f59fa193b09e520694996fea969cf94086dda12fd4849354ad12c55923b3f99056fd6de4b7e8a522ff3e991714d3478caafa08c3c02b002dbaa59247ca26021bd9773743d563c92768104123182ffca1d42665af52341ee758d5399efd3b3b60571d369b0e96d53c5907aa58b693f155de321973718013d1a8a7f1d9766f763a7f420c746074f614a9bd0570ef67c60a9b79868ee298dfcef7c9b9993add69e00e1255c45c2e86d17b8d7f66c92471d11f169e521bb97eb88dbc59011c55c6621c1c3080e80dd3ba1b554b5dde08b6680c4f4f75f1369515c2fdfec4380f2ed39bc0aa2f0cbd4d619e3cb4653e58793bac5ce4b82048f7f68cff8e01c7b9ffb5cd036b2166bd34dc61a70675abdc79e655afbb2dbd0616b95cd918d767eca9b60ed1b7e5954cf943cab05ba7e0f3d43b659ae3019aca6d07453167173540aa26b9f0e6efc2d30d31cc6d36a1218cb843c37b5cd8ca152bc03229a768aa4921335e25619ff5a9f0a59230afb84b30b4cf7da48f61799a33a50ce4fb37a0769298e0301676479a3f6d98b407fdc1254e832de9d004a1c00e14951ff4f1be493f74afff047274cc403bdc9f9f65828de95b80d9da76b7e6e729e658415a457769f35326f33d860391c9b53ff6fd059947ad39b8b1fe4cfe243463e6f44301aaefdf8f11aff8aff220a76d7d4c3317990fd9eb7218639cec5662d0937de61362770fdd5cc47a2f5b773ebe473749c08dba1906d44a023f9ac8d7beb73cf1c240b739a075fe1e4ab8ec99f2d3683f1ca9f4cd7590a6073c23c404ee5d3d55053ed1fe597499ee60883f2a575b64643bbc07b0a05a0a522a12c60886ffb53e0cdf9d52675d09ec3bcb5a7f5714016bdf504b278c5087d6e929c3afdf065ecff2b5c71e80eb1f2600efe9fc5b1d1e61b3814631e2fd963a444141486829ecefe95d9a94b0f794a38b8d9c05d4e67f349de29ae828e15da11b35bb83a83308c6f47c1f439d865c537c2c43e05c8483ec9eb399937f80d0d16b8593911ff2edf54f2c14d9fd96c25e1bbbea5b566c633b631e2753c53840a3173e3dfe7a9bfd660f5d9c41d490d75966c93242291b711d696472869e9bc9d9e86d8df4529cb23573394fe6a4b1008e9429603050280a0d834a0af98db2a0363d66f1e4596d04cc1238f3e4645b7cd6d33e905eeafb4804d1e966fe1185b51f3f025f1cedb0fe02fa8508c2da4ccbf07de7184142b7729dd8a781e21ef98f2cf6d5a5d97dd03d75ba134fa5d34b4c9445cdd5284c2dc350cb6cee99e0bfd9679616cd8be2981d9f28acce55c6c80aa998911148e20bc14bd4847ad1af8bf98aa386833e638affcc61416ba32039be35f90ac353764cf7de02014fe76465304ceeb1bc8634c62fcf0fde265c9813be7065185517b80a3d735976936103209182c184fc6e8dec186ce97e785b9326ccd3e365b2605fe50708bb0771d3b63f3efea161e47972c3e5f44255a72b0c0dfc9af6875d8e38503eb1b0411e11ea9547f1f1afcaea7f5e3a46448e3cec34df302ad1ac9599baf7a646bdfcaae73b800fd5ba1f0ecc7ef86ecb25bbccd1fb28cdb991c4bbba728877824297025743da4cf9c771c53ef9b8e5418d3c753f3a5dd29b97828a9ef3d2f992965105324e01b40d385212352af4a4ef46a58649cb359be461812595ca102ad5bdb9c17947c0b6864c3354ad697456702a9e243c8dbbba083afc71198e709260f770ec93b4533142b1c588bbadb313cd035e302a4aee61ebeaf75459fa6a74102e2e415de3204632fc23abb508c62706405bb6b71fd4fe42a9fa6e564d971b01c91b9782ea8f4993ac769b48e29703ce634e21f257bcc499192b0926497fb953d11f3a94100fecc55a1865bb84eec91b8aef8e73b439cc2849e41a1ec3e2c5fbe8397aec335adae3468cc66d3eec02566d6d4eb2b31e8062d0e661e0af3b4fc314cb5764b6a62c8f421c16fd5a87551abf3f1ad74b44eda62cf08f4cb49ee1e46e320c36adf41a3b8fb43c451643752ea15fa900273c96f97fcf2b6887665102a97e5114395a585724c5c8d33c3b7242aac0e2a0d9d932b6721d24a2fb82a1e5fdb8dd60531337ef126e74edebebf2d020f39e276bb63bdd4414ab5e33e4ddece043b50967f78bacee1009029c81259e4cf27a4d14319cb130840890e9aa3e82ed60b4c1054773acfbe082699eedb00799a1f0bc99e04e5c89eade1b6776437d69fe28b4694f5364d8e6aadd8343a74eef2867104bb9d4a3f09515de9945ef598afaea9d556db9612a209652a81f390ea29daa1e6783715db7024f622f1d6a81dd91d55e96ec629f02bc4fa3c6d9d1fb6e79989f33fd7f0ecb3a1af7a9b73553cb973111fd540130db7700b22b75f23420d733f10fd329db9c17e47df2386c62e156ac2ce5f05d63f7af0bc1d9017a53784a5a002b70129e0678a17f8ae15a7e9f6f19a953dc76f70e69f3c0438f603f891f402992e73bfca4f2fc5d51aba81b1ae44d3c39a38bc642d42e543c17f829c7454366d82b51805ade46ca5c7fb34e041b1b1f0773f7c00933433d11ff99ae0dd6ebace1f019504319f7c52e713ab399ddbe122c4bf21d3cebf5882e9d68bd4ae4bea74633022b442c82bdb4faf3e67610c783af2a8c4881ba694b0381f8a92be56aaff4c6085c9372d039d91e20a25f3c716f333b5878edeb6e04d8ada82084355aa1c138a79d961af0da008b78bd84498a0c74d78fa19d103cab665ba8add4522545d98f899f514cb877c2c20f0707b9ea431984da4f26a7d4bc7fe48c6ee82e98f5439f674a6e8ae4865f8afe6d9c0d746b783c9837beb1a385b43c2fcdf3f27130603cacbd1b961ec19bf8518845a25b45529fc8f85290bbeff2a5a68e8b17ae30ca92149481fc91ee5f04c5dc6230ddda0ca4ac120333ab61a9427eb7274a1fca54cd15203ef145e11790d9a0c8aaa1d78731aa0265ef7765c989f272517ab02c64a20a74d85f1f91b4a8f3281983cc9b48cf93ee85a7ea02efe7156aecb900a153438a61d9996520993585bd09b41185edbc7a5d02ec822dd111c3017617151d40f642304e3596d2cd99ff17c6dee678cd4a1729887750ede0d131fe85afba9bf904969b6b34e9fdfb1b5c0c969ab74dd0b1a59a58552433fe957283154b923c2f92495d977321e7cd284dd34c908e83da0854665052f5b57c43c9ad52d157dd703f872798dbab91c9eb5530143d071cd0c06dc357eaec9df5d655502cf1f9322f8cf12d67534f627ec6d40af565014a305e625dc7ea6a15f3283d714043ebe344c651019bd735bf797a80e83ba36656d90e91ed9416d16ac53d62d2232c63f3e3cd13b67f31ec89070c029c4162166c35f6ae258db046aae375d4e46511a9cdc87341000b08824e622c9279825a3c57c48e9c00fb547756e046ed520e7fba66ae32c2d23b39c120b4677f9ff6d347377bc6046dc4f9d8a860fd290e4f9e5de17cb1e7d4fd68cedba4536537b236ab1c40fd56aace915d1d7f1e974c19dc2fcd560700dd97334674416780eddf65fcc6c9a7c381c7ecacde38a43dc4b622ad85a819b5ac32ac1e058084eb1c039cc7e48ecaf311af8e0f8df02b2ad72be0ba70004780dfb2010449429c554e726943680c2732e1106e1797c687655ddaac8aa50dd87cf84ddb57a3f0e4b6e9945c9ab7da8fcc2bedc855ee7b95ee0070eaa8add59a328318b9b4c29f6b4300afb0b8d6804ad8e5a95ac9b40fe072f4b4572d2dbe6a5c50b3a8610da00ccb07311aa0ebbbbfb6b3e4d9e5016e530cddaa50a36b3f5bd4c26f8a2f9ca1f874fd11bfaa4a43bb8dd477bf784ebff1945cdcb7bbf03318e7334a841e5bc807b21ba82bc57d983b12b9ae3ed1723f4634d092bb0bfbf9fc974eb975a9c5fb7522578f71c60869de5e95ae59d06f2d9fc48fbdacf75cd25650a4296c533702625ba06f3f20f22022b80116d8539856d1567c16494843234cb56c227a53896ceab662ce408b6036f506703370da6b6a09acc7729a523a1e44ac356d2d0cf7f8545fe50292b0ababe109ec6082b9f8c4bc498ae2c28f405b901d1b83e69b5c0bbb4753dba70338d6c456e7f16ec6f3732820c6d98939be2e4141fe62bb978ec820f2eb014ce4e6ee366cd5d3c8b0c45c8d492ba104b19efac69336b57d2e5e26576ab0ca847d5e00fea84b19007c3eea7be04f7eb6302fcd2833d11ff8dcaa76d94efb5d03c6c6197b0cbbfc1d3021347ae74380941d1174081f18adf939475f6f4d887e730016c3083df8312e1d0444dcb748702871eeda8a4a9bd22c24fdc9164108c4da5464b9dec8e09404b81f2ca36f25b186e931bb8df8f9b9b992b766946ce78b7f660b015b7008b77e8c3e8840904e2635adbc9b17f6e140bfde82296407326ee874ff39f801d861c25ece01b3109664d45dcccd79f939a716426ca473213e02e7292e4b16053bd2b3dcb8c2c166e8b89e02717db60e3bdd86370a4d977f81cf1d6599aa7569e288f7803a497ef436cec38c633a3c278809bcfd9ce8813e11b8649280211951d115dc69d18c47e3de2308131df7446e9b8ca40c674ed5448e31aac10f5533adc200b39fa744557cb20a94d9db6a0db28de8c9cb35dba7d2c90fe9d70a2545428a7c1a1898611cf6a8fc0e0a6028b985140d317eabe86cb068358ec1c5ca9b3a4d37b5d560a676736c8e4b68a90be0bdc5c7c2900b93291285654de9787d5cb21bb5572816275119ea15a5495fb6c70c61d3caa9ad945aef2f2fdee55d3026b4fea7facb9c28b746eab1f1cfc24b39041918c7648c9d2333e8f38d30f4fddd3e4eff732f9b7aef537620b41f23c80b1d33ca64d8bb81e2d7209ef8e426118beb5c8e26c027969c4233ac283b05ae4fddaccd1decf72df0196e4541fb1fe2c021d48244e255a4331f5589a652257a50b6de0c4e9936dbfa5f3c08aeb569f071bf9706ae89191e0f0805c5003c42546656e35d18ba9a11dc3473a68c2173f4457dd81be0c0844da729939a25372d334d67a4c35455c6c6c3710e47892506831de4a013cf3c16eb300db02057659ce1d2287afb5fe2d1e457ea036c8572af04ebb792ab9b796fd5784dec712a484dc6d5d1badb285725871fe1e77818312f64803778d8c74605708af908cfe9096c051d320288abf4a96bfb5edba13355cae878ba369a744da745e1a7396e92e34ef09788a70b4bdcc14b27b1c6329a22313a4dd6917278025037f0757e6a8279ff31a4443f77f70b81d9c568f255a8613ee09d2ed24f3eeaf1794da06a17dcf25bdd77bc64db13e01f7cf8e3319662ab93fd04104652c7946aac35918fff0434bf660a40884d97558addd5c5a10c7138c5498420c7adb031a13b9496df8e18695480706982f449edab63a4fa13bacf2a91891abd2a09355a9efe6178911227c21aec581f8d94dc7e5a36f3abdb0b2453532a0d45052aa4ab8860dacbd35f4b90411f67f2a2131f43c647fbdc020de775e1240f526b1de2527dd36d7b5126768f355cb95db351b3f05e26b0718fdc759e631ef520e7e5117c480094e5ec67ee339de97b1e54d6880f464485663874d26394b6db2c74217fa176a031a4693311e44743461a644f391c070eb6f2cdb0c9ed2e3c5cad72c19d9ed6e1c1a046d131d7768faa06786f14fd19d020db4677c4a481a689cf47d82350a55f4d00c08cf0a7c18446149dfe50ae19524e166795542f440bc7b4b40a258bd2c644b4c4b7d7d46f2b67ba308aea34d95df61d16bb91db4637a9ccaa2b786f162a28354477a30ab0eeea35877a5e4a1212fd6d8bdff6649ef96f2d1cc3ea7e6e9b08463fb4ac79da9dd5d61fcec30ca49a35dd245f0b6e7c8270bfd745ea3595daa86c3ff3d9bf59cbae35db4639780a4fd76bb3e4d242677d41f6abfe5f560f3b242a2293c157fa367ee80ff999623e782ea57e19d50555bbf40558704887621a88482e036ae8cfe109008140b37bb7e9c8b4aca4d52889f3426d61f36780d4ddb406f16a1cc6585c667c15d25cf0726c8924a86b9dea6f30a57ff3f712ba398fe904321b565e3b831210b85a22aba7b9c5dc06e827f76b3c4feeeac9268efaa9fcce4fe67549bc004ef2e62736cadec8062a4510ac143e6c67940f8331bc3dd963129e9bf49fb6ad6961c5b96f82bab5b1b81e70bd5991ab94a4d6dcdedf69866797b3fbfe7dd699de4258553c18f8ba6a1af3c9fc3148ffd5e4218b2c3de5f9d60ce736b13c5c90f1ba1dbaccaf2222136da9de53eca916c8d754544c5245559709e8999aa8c9048a9134b87f953d65e069381844a8e10604e0135f517ec58c9397fa00f503515c488e2194a6c5a806eabc0442ffe60c1d740fee12b0502d417ed4927db13edd3dd4c293d5ee8371e9a295d8659641213d659ab005e55825fedf6047b31c0c68e9eaf4cdd6d71b2c8bb1c7c3d27e68d866fe55a4add9456fd8f068e02d240c5742bc0030c8ab75b22b1515f571bc3d7096bd3e46a0f7f2be89dba9ec4d72631c4a536b23b6ced1c263665e2aacbd4ebf77564ad0ae91cbeb628447b71c61312a86d84d2d44e3ab9252c3500c51118df5c1ee5b17076f44b37146d5ff23b99c68e35cf63876e290a9b4f7c3fff261db1cf4fa6cbc86ae42b7ce6db36dd001320eba732f93525b6163df683d0fe7abdc428546663f710920c5772528e6cae7c71642752986ff688445e280e8c908bf304994adda8fffa4a3cfbc997ec7e11018b995767c0d3f50f24c927f36d9d611924e86f362ffc8132a9dd9e2315b1598c70093fed20d3b0db918d8d6dafb71b4f6731ce02492707c99d7d8557c86ff52f2a38c3998512884e72f0bd901fb32d0200f8d3aeb53de7b9419ada467dd2ffee21fe9fb5e044de856e2808e6b58a73a86590c5e38d0d07e0ede3d4f077c46199e7ef3503ba6a6ba0c884c5ed0f735a0623f55c50fde0179f22aea052a348e5e150eb745e321db81f30e0639e0a9015d40c2ab2dd43cf5ab0adc5a1f30023034668086dbef9b48645e45d7e5aeb119c6f5bad86804e43050a1c008ec07218b89fcb1f6b40cda401b3ef7a6a09f14078e20104663707a7e5964571796a8637c5e564d2b83dbc29f6a20ce068f13bcced6bdbe41955a272f8ac689763f7f6b6e9ba96d32299ce0c6daf106bbcaefba7d2d05d6afb297e3e03d01e9e08436fba18b0d052809eca416ffac63f6de0b05741f40ff6e48a22d6f96aae5930e0be1ee37236bf79ec9b3eb9858a852b76e504b8694373e5d7c2ee598b7fd207131ed824833df6c8468b14d920bc0bbf1487333439d5e09756c551e68bfbf80d22d4c5a91819ff634e9f6699499f7c9b2ad48f2a7d8c408fa78636c8073ea68fea5b052ab7108391500ad4f6356c08580ce8aa7955fc5630b881da2f513b5c3774ffb47b1c010f13f3ea00a14a416934530894b77cf96b8f569312ae95772a550d12681fb10e7f4fc5f90e61cfb9869fd831340c860b0de2b2fa061bee466336d3b3360a7d0b69a0a74dd4d74c3eafb6b3f78be42c5f6090b124cdf47454a6aca97ecaed5ed9685259aac99fcf76f0e72dec2ed38c0f56bd6b60d73bd93e6c0cd86b9cfed9888da6048970b9ae2d94d2d33b0bf12b6a2cdcf7243a3bb9cf9b6794b70f5c70d99a681de95617e8e47d31dda5c82e96c5e0a658af7eab1f673947fbdfb51a049bb2bbf4ddd9f6d3e8cde566a8770a71fca7cda79510b1453fa7baea96383c7a20c0fe2b6dcbbb319643a3a846190c2b8e16b3e9492e43734ca8b68f152e964d3e9374e503374f1e6e1af7aa0dd2aedb8c1e6a7902e6334ba1711983c034f4b93d6f2e1d0af73ee390a68dfbeaa404aa2c713d680e2a38d4ca5c2cd2c62927789d4f316eb11781d328e08b7fcb319c2a1d009c8dcd8d1cf007d5ab3f55b2fa3ccb298bab499e0a4e03f0e65116f12d1bafd16749738ea110a7bfcc489d1824dd3d6da3ec0687285371b2fda065721ddd43d8149ac46563385cc1f4be93288b7d02efa8f564945981feec6a9c332db3188dc6d8ca844b74d100e6eace6ac5ddb6228bc41d4312786a6181ed98abbacbcc7ec1dac2417766dcb698d48ff51225bbebd62c7122ae3a3f06a8abddab286e687fdd9ddd3c848392e05d62d28c947f392c016cdcc7cbeb71497323e1d62b9c973ddaa99e7056714e5da585fab13c3adc60470ce7257441844adfbd9f462315e9a4132ef58594b25ab6b6e245b979c4beb5f313465a15f1a4834fef571f45e755e11b5a5ddeb929be19be1c9fa97186dfb024311668037f11524c187582818b29131e8c4ae67d95da76e323270583a8858196e43480bd6008f5f4981d8995da2ac9159afe494296e550c123cb74dae15636c068c6e00ee4285ddfad3411b13aa80ee3ddf03b5b04f188e88f4266067ba2f96d4c5c2db92d6e40adf0eb04f26ae9d2bc4565d2e2346132c4202e34ab631a7e0298db88cc388519aa02c9bcae983fc7b878afb59da601b65fb56ad39f0fcc42238c96c3fb93cff12fe4011d5c57cdcf966a826b2a2eae0d9a57df281ec12b400fb9af15fa227a6827faf2a401bf61f4dae2f71193fbe484c9ee306966676877079885b9f6d1b09832891b347c36b16aca569a2cde7d962326c06e90b84c398dd5e5e838a98320a3f4d9f6546e7d7942818121fc137febfa8aac7985c2cd1ec6c45d159f0a1231a74daf847015cc9221be2120341bcd1ab3e45d19538d7aaf17fc4038f835446d6fcf01ada87d32b3b3cb064b9016888b6c8e3afeab52a141de48998e3bf025595c9cf0b7cf4a54b187e113a54701452e046c35b04f87b4b83cc9653a6e03c8f97c48ac01fd67771c242698d3207a5a03a2743d50d146bf2f8cadc9059d3fe7a3ef4fc9856cf460fc652124bb2b8df0053a000db6bea86a282a5b590c3656ad1a6f9c76fbb1a8208f1eeda2f28d8a0826274349c57e5d67c27eab8fe8a66f2d4927c445b8dfe01eed8b31b5dec978f2da86bab1a7a17a0ce326c8f799cf05ec1d9ff5f2622b440ef5af431787ebe83d515b4b509c29b1bd59b59f3de16b3b5074f79ebebb81968a2e2001bae0d54b040c37cddb0ab88e89ea352600c0683cf69097481a8336273d9866386bbd10bda3cbbb1bf7d0340360d3a0b1c1bd1c3632c4a499494920e912726070be199795bd4befda04f62b72fef3da902985b0339513dc81bf4d4081a428d021728","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
