<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c91e4d796d721e6b7c0dcf1dd2827e6c6d802e13ad6126380fcc5a99b960b5dd27d2b50e9d40199f7364e74b56fd1b2ce08a60e749c83b1cab7b17f64a6aec059ebf3cbaeb78910ab934d0b0f4f32da75508abec76975857d4a4c51b5fa23c44beb7565f4e3a5439fbee718d0eb00120f030e1d4b293fd61b8741289045f75f9b37658d19496a6621206b21c5247700b35719653215c9336ccdc82e61792feaf7dcf303d71835cdaeaac0da830323753c828b9e100c807c12866f4e2447737251b71f5c9d07f81bcd5ccc4f4f002282037760d7a100207e0270ee8acd99dba4bad65c732ac65f4e38c5e60d566d9056b1aee6e8d689c76f2dcaa3c5c74984221a31c51ea443472f4c814a8d6de2525ba0eaa15127d2361d754b5c935bf79828d246c2aaefd014078f62662c41e19f16e19613e62bbbd36b9693e29b81412e92ed4bd48fba055ea3fa6e47e4a7a2f929fc9673ce229db5493bb62a011ed88d24b3e169e8932ee1635094b184dea7a01710efa18a5f69755b0a116645b170c2180606816bb2a98435d89e93a89957a9c06467477d8f79d615853cd10dd0b9a1483b5e5e48e01598f4edc824be5e9aa9b36dbbce7fcf7bae4d0f5736ca56ab2ea25ecc3bb8ebeea95e8fe087d00be5b7f45c89937d1fc51c8f2e70b1707612c7a29f6bcc174ee074f83d1cb1d4d0c8609aa9639f7e51b2e7bf0868b1dcb3d74b17bcdc4374ab8c49b0d2e704eb0f627b3f24bd36b2ef79dcb5c8b041b63614220241160ea9d3246ff0aef828c2ec7a23265a2d7fdbfd5413af559cf54e9f03c0be9710a031e19c536debbdfc43a3e5cbdd3319e8d858841cdb8ec0496bfb61a3539faeef301ca1f108498fa40ccf32fb2b9d1a9cab36b7f932445985cfd4b7bc3b87937754e0d644a70a29fbbc937eddcd43bb6ae90907c9feca11eff29c092c4720f08376a89d816376bf8c4a213e971a1d4b74ab74bc7e405a964973dad038613937fdf6368b4c533931eb790e24f8a68f5caf05453f7b6f50e4c7875163e087dce7324902b9facb9afdbaee7ca644ee41b98f68914f46358e860e378f195804d6bec43ba215ecbbd60ccab2a46dc9fb1046c263b8404c192677dcd54b5be90e5789282080527c9a372fd182f5c4555d94c12e2221437df7320075f1e823f4fcf659acf1beecdde9c0d6554dae6ede915750545e8c3943927ce2032d552622fe7d0d394cfc9ddfaf777085197a4420db66d35e8d77a252b49412c3968ef99ded97c40e19f2a068061dbd2a571f8f74e9e756a7b64c536bc1f1d15bb3bd2beb49f91c643c4e08c1d3fb1870c89a87ec729cda449f4dd4255887d5e562d53eb0fdd8f41756c65924335d0b83c4e62fb4e262666e5eb43338801cd6a275c6a7c214cfccc8b30f38d6fe7a33555e82872c993595b7cda6820db29d2d426b20378e10763e056fd75adea56b382f9dac520ad76b336336fdab2478bebb3339e8ec7e6b209e31fe13ed2de2f235d9bb7a6bb9b0f5b163652c69709b92cdaa108dcf58cfa20130eb1deb335fdbff4d01d051a7e53dee9fea068963cc596813be230232851ee34987704c0566c358f7f6ad038c0d17ae7f868071818c045de94d51912548c0ca9233e9dc777f29be54f89cceb9b5d4ee1f9747edd14bd0c2c1f37434dd9f1360c13024b2e5d43fdd7b2a7e81222913eee4e82caac449088c5939f42f364c3045c66487b18012b7d0ce01ecb25543f9c6f0269009226acb951bdc5dc078abfbfc1a3a7f201d7144accf6a6fa7d5f873237ea4d683f36b44c2e600189032d1d5f67144f21063d58d7de4e64febbda27dbdb6e037246d39a92d24425cd3698bda1bc0a3b7aa1550a87ecba0a334e5e82edc3dba449a127ba021adfb10c375a67ef31c878fcc8a0e72ea66a98042cd3c20b25fc1d5b18409205e266b8c9fcc1211140033f32e7d5362bc73f9d877166f102d41756b9cf70702c8b7aa637d14050accb631f21a85d53ef4135ceeb72a5c73099f1ec986bdf5d3d8231c4ef6b0bb2c430831f07783418835948e9c1d12238e95b7acd84b556edeed86f4be56a7d633f2af729f6df9b80dd51219ca1a1fe258e35edc468e86a247da2ccdfe997be3479d3d8b38553b499faeb164570bfd91bfd7eba1cb3418b5632e7da70b815cc0e8f4ddf094cd9bd8775f0b6762904f14bbc716b01a70bf32c37d2b8a0aa4b83c5d48d37778efac4b8894d3a685f1b611cec908227b944888c83bee40b31facc5fc0fbfc04f345e16210233143148fc6ee07df43f2341ac7f59489dc77dc2f57b7a3268f3ff2c6e5ec8a52aa4174391b30421cdd2cf4f5c73f8d04367d751d727e92ffce314193a69d3bdb2604d47a2217777857d961e08c8a212f121f758b4c6e8648d76558cba384c8bb27b3d8e626b858b4511fa426bf7985a03bf27cc1e05e4c3c60f76de87cdf4a4225ec29198388e5ed9217c2bdbae5762a4877b9eb9026ff095c85db21473a47b9ec69587f72e37346725bb567d3f1a9a022ce42fc795c5facffc8bc9da1ce0b4214ccca1a0b69f1fcd2fbf5c414a6abf2332e62ddea5952c4d89a3db0ebed7d49cfcda0b3c72c426715fc537ea9b5d4a0f48a0037fffb8f392278c586e431fc599d76fd7ebabe2cb0fe1487fee8ab6d323d0f2c94d65fc0928a10ce7e2c7c739620e1ed10c4eacc217fb4db1459035f7b785aa69d4b9388c67f41c7a69d92bfcf0b6f685f91ef581cf5a1a4f01ae3e7b04aa68db9fa653513c50643f03e9d8bb90266121ef3f13bfa4ed16dec14690d4559a47d9fb26efec5b92780ffecf0e9596615f42479c3abc31e0ad37a5ba6adcbe818545c36f2efd334b1b538a16c260561bca9b3c0107092485a782526c12e3dc4737df21eb502c6edc1b6486ea2a34f13711c571c3bd7e1c975c4a2378f94454f206c0c46868c7231761807350f92874a1f65ce3a28610ef8144435063cc666a89687ffe8b7b6b8f1f4fed4c9f071a5c56bb2dba4f896240722930b102feabe3e68f3edd6f6909a496c1dc4d21ea39ea44c3bd1dc6415de036ff141541e7ee6d4d26e02eb54d47a840c6f2ccef4258d40c3e2877b33bc926131fb64bf8eeb0a1851c00390c6719b968b30e8e6e6cf7afeb1b7527e223be30ada01963e9788474be35407a737d56ecb074c336b6230bce5adf4d295f02058259093873b0d18b03733fdfb98ee3a9450941a5f0f5e768c2f5db5f17eeccbe43badc109c51a96fbcb751aeabb52e91cc9e0c403a06c94dd99ba5a6667c1c5c6a58a48913590aa14f7db2f270e670d7204ab2d78b33dcfa7f1e223d7f83bb786b0f706aa5b497be72cbb411b7806ced5a2db28d177078dea9495f763a6f0df80157012e7f6704c46e1e2b5354ec13502a23e31dc83b4c9aee42007e984c76486879bfa55cdcab1a182f5b4cacc6ef487edd330b73b06236d88b30c563e540561aa016099879153048ca266d0686d5e871b7c37d57fd8b6471248d4c887c97353972438ab9343e73de5428ef5c0047c130b69fff646f6878e1e7d838af60e8b4872a2bf1f70616d4f6cb11d83b479ee2a430da514383ac61a8a0a6e59e40f48ee70b7086a40fab2cd21af1421e8c3aac37497a0c62143279fd14664baf6c89604202328a0f5af03ac3d46321eb6b99c35bc7c0c52bfa68edad787e7eff24ca4fadf47838e573b897ef06d29db22491f7b09ab5269f9fb9a2bd96361afd78e35f73075188a53ad2bb04ec4a3eec370c56d178c48f23fd784d43c092e90c41830532c8f443ba18bd3874aca354f7dacf6bd4938a91589ba440d2b87fb30d56533ba4ae92c0246a2515c74b46418f588bd7ee51ebeaacbaf1f931bae088724052c4214e3cf50b1dea2047a9656e09f92f7f9953ad9aa38fe021b904f943ccfca7939a02b59c304c92a59b3920b6603219e6e2024800bc19f0622a27950882e9b8a038f9ac1b72d10a0324a5ae0c4381f5b267834ac17873f9020da06d440d54179dbfc7153375007e18b367b72f7cc7e2b4ffccd806e564a2e6b513054ca7fd350c8c4a8d2bcedc40deacad26e1af06c9987169a3e023229b48bbb5a49e13df8548c4c4dbd74fc3fca1e26c5feb0a5e28739f54a6acd0c33089e249dfb7818e02a000f19d28c858e059b31a8a542cd1cd9fcc01d70a642146e2c4ac73c1fe51b03dd957c614033161cec9e2ca1052af366f542f902a5d7151a8e0181006c4bc0f07fb71eae055604e72c29dd7523ccfb2685c1d5f88aeef3190f102db36f9db49e9b12a0a26da672271430a2ed7414c272aeef0f95d5cdff737d6bf6c81511b85ac853608f860df135e9aa21ee315c486a883c11e60b61b4bdcfe398de4ccfcbf7d76562874d469e92b65e1c5abb0a5e33e860e07a1e8da0d810d2c0b521d521b7f0b13ad4f6721443d5eb96c9499aa80f12bb15873ffed56991c5e041e048abfc10e3ad8bfde65f6a2b2e0e58789b6c8c7f447b51403bce26f81b38bb2463492e10f39875698c54069c0cefabd7814b305f0f7b9f2f1848fd6aa884ffb804f535d5b955cc7ba4f25e53382ae2e5f57381f7448de0bb482521d604a9358f76d12061d59d1aa614d31b1a7f90569495151e43e0c8c6867434d6dc175581ae08e09ff7b7db837e1dd552089f1041abeb2a80d866691d805f0b20b685322a0014d1c68c789b642965f806d730cfc54aafa86ebd3fc0864f6b348fdb121473113bd75e0235338ce93d22e30d3bd8ac8069af6c7e2f4ff0d3a3425a7d9d6739b1beb131d439da97812d8bdceae9d801ba0f82aecbecfc4f12c600d7e3af2e7458ba1ed3b4c00280eb0e4e2a9e096b7c43bca8063448806a78f1dd15f6fe34ed4647bc7ea7d6dc97098c3ba978e7cace180cfd0b6537b449186d37112b6d8343ea29658c978f0cc765f451363955e44e267c8dc6ba487138e85caa27090b433c4a38011bc22a826b7cb5fa000679cd1c15ab7f8b8b58169936cd2ebcef4ed5efd6e94fc1ab180b44b949a8d9d6ca19c0df452d15c08fa3163812abf1936d38622339bb49e9b699861c5aaa9733424f63666f9dcd7b764ea7a2808fefb0cc5e38fbc27febacbaae602c58bd857f4545f426850822d26f308dbd05eab745baa7da9656e3053ec90b7a2c141d3343db43c9baef44228f21ca6a8f70708f54df959db92b57fe9f1e0c60f7be1c42e0a08f68542d63605dc1dfc79d9cfd58f188cf9eca9584200774461876c6a90a272abdd475778c966ce2b0fa0992c1f071418bd47e8cd6c6842bc57a3abd868032e97fd6ed1e42d48d068efde55526515775de580b9e17a52d7344973698c41b70a8fbfeae5dc6741ce40672693fd8082ae09488ff3011e83df5be549c5f807af1d8f5199c9a188b6cf8b04b8d6d7693c651fc3d1c50f814ca7b509d389f9e1dbf72e0b2a03739f58698817998b86966f33355ed15681750a4b499eac16f1f38b83be411a8ac3ab3aed32e7629618f8f42945db9ca47c26bb60654e67e168e8ff2dac41fb21cfe7957b6ba6211aafcca9a5549e106556a60207ff5751ef5aeb20a110deac32a8f111d8effc36dbfbf70f1e42172abcd7f0e26f43ae71d85c76258ad8ce42b1a495a1d7ab43a8385786bc93301538caa19e00f5c7d413c49e3d4debfec6e4a2ab5b2c3e0c71442b8eb340cdc4cf633848e1d80fae344fbfae56180964cdd20c9f928d2e53a066a49af72e90521e5f8a099081ff127cba4ced355e98bb4c008a4a2ed8fee182466d803a9c6c26330498063f9fdd4f3adb766647c3cb5a58be9d32ae91de241679fbce854a8f9f198eb1fa6a72654c54eb3297a008e1c4968d69ee218bcd4279386b8ae30d0de4315af26d89abf134edfd8c40dae611839bfa795f4aa3955340df5e5a911def17e1fe5f96cc74ab8256fbd18decf99b3ea0a0193b85ff8f4f964c57b43070e8179d7d19818b7bc75d1d5c1dae8616080ffc5deaf0bb48b60ab3522582ae36eff2a4d45129ebbaacdb088b967297bdc9d41d30a304646891a88e37e17d44709033651743fee5ae4231d6bbbfa4867691d93c7bdadf51c7edeb36f82e0d3e1f57866c4adcf360fa3db17b2d86015fbfb2e4391fcd596d9a948dc929d5909403dc65d0f34e86442122bb6a9193da705ed118721e6b8069d4174910aa3c0a62c9559f89ae3aeb43b85a2b36464375feedae13c941323eea9f3721fa036c2144746af7e7c72b526bc69a6c0aed67a02d4bc1b9ee99763cce569051ba77aa27c2963837bd3c7fda9d7c93c66f30572c3bf62cd42274a3de459f8100761d2fe3b9a3801d386fca09942b9ad77ee76356079de54e782cf5f03c1e64c9cf5676ea54febe37bb022a7dde32ac9e4bc3476b561af6e772ba7fda5a90bd229c2473f02665c34a7fe8dab7d56e3200d2ebb26bce087d0b95f9f71f263c5dfc007b902772e9007ddfa639dc177d2e0f0731416427444eb5f3e6ad9d032b3d2301a13ce2cd2e59d4fab48ea823383baf846c82e9c9093fcccc978f507bfa48a0162b75ac51cffd500ac7c79b04b2db9be3d1e4b4b7afcb3cf6ec7c9a0d432bbca7ee9d79837b625328c4fac03ae9e50ad0db01e37488eb08e18540c25d44cfe311569e0c76526a30f34e23270fc1857a7671d8fceb718e397860f49215148acd98c4bbb458fd622bd5571213dc299081aac307e841e9e72c624346b33ece755885fc089a7f08ae7729a98cc9c0713adc55df3caa2740f8a861d5ecdd8708e3d207b450c771262ea4124172156a53eeb7d390883d3a8bd58bec467d7a7ab4199c704d8e50e7ab77d29965a66aae45c2c63677a78b6754080b30d225ea8ce741c671815a959333c6904c54194a1199db0185998cb52774080d2dd562fd12d69c91998c3e96a2a17d31d97d50a5bb62b9d8b6fbe0eb3201ebedea90a9a302f6d88d57a66af90a23d01df1836df47b4f14a04497775c66f5897bf6c38ce1ffd03196a254c278d38512cfd43bfb581183b0603fcc57ed71fc694f831f35f5b20f9b30631b1d663bfb74eb3d8ade9ff3604a68f2542e8bfda1c775dd02d7888c417537dcec4034841af91ce82761ea0a252ed9edde2230da567b15e5a5fdcce49aeb29abf356f0f978f45495c134f23e3ec29ac8eec51bbd7a26029c2b473f057c8df068ff42ae6c2d78c91726ddec92f395634f7ef0bba28b3146a58b3eafe6cf127df2debc54f1638e7beffd31c11973bc3f31ae216216065b99984fdcba8e38b6a44c10be1ea02c326434c0ccb340b25710b5bc519b871299dffaa47ceaba6416eb3dbe6073e05d4a87eedae1d079beaa5ac3d24f14aa0cade4722d7e8dfaeff9b71f00113c70eff0d8db7c074af0123f7594f7cf3ee878cbe2060f0f1d79531c991639e7addd691082f81a3890d0cdb34424dee0786ed38b0f33b2888b74409d1a7e3666988b4c0d0fb44678baa70d3ca146776a6bcb5573e50998180c7e27afa5f1ac981b4ac089d1a2049ebc9ecd7c2eb5738b733d781cafc36f8fd1e1a809eb06e9d8b62f002fe8743bf77c43a62336dae02c36129ea874f6e462e7c2453d9f69764b7a2550ed16b897bfa9e2a0134b4f35a2a8de62c9b66a4d2304b10b771b0231f482a26aa5cdf5cd6a8d1ce6373d28b6a842cc05152694aee0838710dfbffbdd4afd10fce4a9dd34f6e5c95d5abcce0879dfc0caae72e08a47f033abe9c159e0a579348c0817d9023b3aa3bfe615ccc211177a2fa310f393ab86dc2608879f0452805fc1cd7efc57301d3042ff1bfb56658f42bd21cf50a2f9b50ce0801e531073d4b05196d102464c78a725a3eb7b5168c13d01870b025f88f7d18c542882cd334b4809f5f374345e73ca6e2f915e827a4c06d75f3f1d4be1abfc4c4023207cb062cddf3d3182151d63e9c78e211d4aaa9c8667a93bab05a8bb871b4b6cfeb622ebe1d8191222ae34fc7a6502d3bf284001246043d52319a1bdd08a477f2eec8d51e899767190d0c96c0f3467e7efc247ecb2d1c510cfc84333e09871eba3753b94b74c57d85de19e014ed06cf044004573a98008b21d2f261e4340128d55cd9aa0e6a515b4f1c74d9ba76aed8cc05773294757da34a2c64e27c46de46f0012a3ba66e0d0bb6916dc86daf91aef82a39932917f58c49ea1c6d38273d464a610fccb9cd786e480139be10f4dd3633c3ec8c187055d522c7e29851fa62c0677e70043fa3d53d1802ce23715771f9c9efd4d28f5ba9cca75cfc82ba2c43755499e1a6aa62319f47166ea4dd838c52e9bbc3d5f36548408b25c281766c598c08ceceb9fc7208e1abfe235669bb5670cda3331296627c7b295d96ded276d0484f0f348f4a5bb1f44c2ba98744abdf4f619ac187ea60b51e5b56dbd8ac3dec62eeceecdbe7d8d218d8a4e112ae3f1824b84f1662bd163f6a3af33c1ce1ca87ef8b741beb51ba6c931e4a8924825ccda3606de599e53ff900b3ad2f7baf45d3815575702ae52f2d4d0611ebf9ea2f7dd30381e09a0fd02c452611391829c9efc5452968cf6726a4e291338c5f33b274dca964fccda7f5ef8dd00fd6bda6bdfefcc55706bd748c1fe5b048b8e30db4b54645b5e4f105ee3b843f43c2849d59232dbc4841ee540c2954d10bfff38a86ba1a4efac0b8d84165913bde09db08c9ed458549c8a793a77d8adf387310f32c602b2a6415d3f950a06e20f7717dce52e62f9eafa4f0cad574fc56c57d7534fb68cd7f518185617eee4d03de5949fa516d9d9c3a70567a9f26cb4cdb8b58cc263d107b430c13f765fdadafb54782eca750fd8fbceac572aa9b4a465302afa05bdce559d7d0312598acf43aa2a03d800b22b484ce42785f0320eca4dbe11988261cbbbc7df43e03211a8cf2966d88162b8bfa4e60dee4eca72534d1a0ab7a67cac4660583f740bda993d7f55f20a19172d9c347843814b1e3b0139accfdd327f04d25d2249802ef0d5a3d6cf6e2708a31618ebeb03e713f5a6bbc91c90de607117c593e1a56bce6b1f65f6bca58321d46d2005b794fde8d9fc5772ebefbd156fcf9a45cdf5336b3c36556c2a8f2f89eceaa06ed19533586ce6000e2544ae6c7ad8f2ecb1d7c9215e15ac7b28792ba46fed4b1543e618a8cd8793ca516e5af21bf851eb087d538797058ed8024945da3e0ff5dcc9184302e388dbb3ef52d5373fb34afd323f3fe480f3cf4a62faba660d7b218efa2c137b17eeef9548ea5c009372a66d43a81b0e2f3e7dd60ef75ddf50bd73e8fd507ecdcdd5bb294d120672abb4ccf4a80ab9a78e0c611c3b5e25baa49440c7106288d213ffc047dfd6fb18aa5ad5d6846b154ee6dfe24b6462730c3765395f71113bad45c7fd5081377b51b5c087ac41a345287b46af3eca7534d86d1990bb2bfe2cae0e6bda0afe0b922717f7cdec11e2d07ef9f51182410e88c837606bf9dacb1d17b8f63e7c7d23916a3174d3a242e9c33df771311796fe89fb9d1f71d06abca35414799ff52ea2e4f95122225494d14c9d0e50daa5a3c4c73dd9604c237710efc4dc3dfb6d1228808c920d48378aa7c93bef590d83b16b3f2b5b5912529a1accda0abcb0d8b03f75a9ecd43b0be0120a88138b33bb71ec83fb6758fff1299631500abcc9f059ea6968cd6dc8448a9cd80b516fc9008525baff9f45443c253e5af0153ce3e6a2b0a15c9672de55e190e0f123415f5a453fd47c622b75b2211dd14f51076b4b9eb36f304871fd6e996e5c9f078f694a2793f93e984e462052ff9698113a60f1e08a62b53ab183f53fab7258106c8660a42efbc2edc49f8cd2357571cd77f63b484da636950af4cf66fd3dab057802175febc213083768a85896997632c0878f3dc9df10939430e169075325e28445b4663170d071294298b4fec6bf1e6de4db887732d546439e85569f5994bde5dd704eedc403f326b5b9eb47ec1ddbcfc9e9bfa5da16829ad0bceaa7239a846474782d0e1f7673575e3ef274cea706aa8f4963136fb2bdbe6d8cf2deb45392ac6f7ef963e18e8fd7aa0ed43fab3a2a7afce1ecb44ecbf3355272c57c5c8a1cf8df6becf209a9d049e45eb7a589dd5642e67b1285e9e0a39f1a39af09bfadf858978806f09caf9b2be28e5ed7e0aaadfe6465d842f058796f5b23d7be4bcaaeecfbfb78b121d6a73c217fde39b5bba2068e728dbf4064a3714e6ddec9d9ba797765e8cc707e4ee2f725322d26ce9daba033083d816975b232ae94313f52b523747583f01706cc044f7b72d6479747f05442f451f94e56bb746aac227af21ae067ef3d5fba6499b451fd1491a9ef00d7e84fcdc80e10d3135ad21f740bd11b15d492dc19579ddd926f503918a2d86d38759fc87ce19e1c3a2af26ca6f155919c8e76ba3213a5f534d69074f68781e22f1f3ef72494619a2b4df28b15143c1c95675f67c22dca0d32f5a45494e8fe2b53b0f5d5b042d9c95c19964bde5eea89c6de5a2d161de45bb111fc682261898d9e79c24b21836adc332313d9c515ea3e855e75993459dd684ab01d0152a10618c59136266d84c4198b87b519fa4f811891e5193659090cdac8027e9812f8285ed6c0d89aed492b23b815ed279dd14b8ddd5808bb11b6105a1a872bec4b249d961a0e529025ee8b406e76de4914e05cfd46e26d284eacf23f2a3644d65b550e9ed3babaf266ca0420aecf00ca416d11a31c8e7977aec1c813bd06cd1650263ab11c37158d70729575987cc58ee979fd27f273789b33b034de487f8715968452360631f040c787dcad2ec13cb354b69d0aff3e23e716b351a01efbb47abbb06773e96c6bf053f850f0e497c0ea42faba6b414266a83dc79ea5f2bded0ffa852442c0bf9142f557543252a54069e451f47714b707fa3dd50a64dfaff7d738e61c1c849859d56eda91a0771091be176b86f1adcd2eae55d261c2ece0b1bfd142fa474bd1f205faadeab2c7fbc72d5686bd688746bd3c82acb87c3a7a9273ddf3322846cfdaa59b7c882f2a22380908b21ccc5f7fa5fce8f5f521ef81a80e62d04d95f30a41e7ec71f811fca84841b304d86cde5ab24dd8fb0b139d18fdeae79c2aa8c661a6e38aff42cfbf562c833404bc432f9d1f52b6fd0648f39834fd0c25764db0c293a7193217e06dee754ff3003de5cb1a99de04939ea2cb8e445636c1cc7d7657bb9ceefc20b263b7b2dfda3dc2029b86aa9ab75c6ea985246dda5863122533c6f9311ffa4227381a9dfd072d724a98817a93badf4c81d43a42dc2c05cb00c9dd02fad01bc0625d08da19868f65959e91e6fa7636ca7deee27abe20c7033be78c6f9fc30b1a4d161044429be3983872c839d26fe01160646c336dc011ac9fb22b71801d389876e61f89d5a3fc9b9119274b302893c838c0ffe6fd751e0a531d1cfddca44de4febd8404378a373b11aa5c4a923f3819b6bf1629d2a7d376d7fc70e2be12521bf10892d20c5866431de44baaa7f90e26f507316c0b3d494b3bf5b0f18f43e9d01b7528a4fbea8bd5c551cd4ac9be9cec157e8d818962c755a857ee8cb4caa81c942b47c4e4d10769d45512612f0102cee176668f44f36a03c60736498c6c19563e203d0e27af28e697429a3f860e286eac4fc9a682a1ed4bd02ab916ec420d668771a42338280f361b5550b330d9f297821f4701a18b2773cd1ac09d183da471824d081c1b9c8249b1d0028a57faaf276da252a58ef0d93d3665bdba5f2d7355492c4ffad666ac232d74bcd12649bb26090e8890d7d7011f8ef71007437ec78e5c1067f60bf71933cbfd3d59c237339df03f315db78100677821b2769750c8fcc496f9505e68ee88024027245517e2353e22c970c86605221c9c879c6504bc732bbbd5dd8d81bee882777b7286dd6f623138de7ea682315685120de835397e512e24c247419e1d221c2a574cfb21ace6e24d01a66fafe604b7a076ce0af2b78ebce99ac40a9fa94ccbbd00a14c8f567a55409c0426d36eab1e4a1c91dfee08618f2df2c7e2ec90059d5f059d9988e2ee243fd855aa2bbae8fc60c1ed3d9af3beb55d1bf4664a7ee7f9e5ed27c086281fcd4cda2b31f4a4269d77ae2b2053ec769c9d7fae6c1a75fe23e1da28f7f8a42053411ec886b99144623609a94e9f773aeb36bebc59c5d1534aac39986c0d327f0ec7fe2ee3a312d7917748ef07bbfdcebb12168c3661cacc1586ec559b6ed53bcdfde2a9c399ab54bd17cefb0569df3874f1041d892163cb185e2fd642f87a7bcb449fed8db1f61480473ec3485d72b3d1c58ad42c01e026cf8bc5091920b1bdb045f9db8224639a68315d4b51026215510d690d7b39ed25cf7d1b34a7a29a35db2b083fe611278ee5ea5aeadb87cd53d300e5635adf2f399af2fbc006b25801d8fc9174fd6e53fbd01d4417d7c51b98e20d1cae6c7a30c9ef01dd34ca3ad9b66e119e55dd08cf5bb4b3364b786ef0f2a4a0b9e80ad85f71be72cce81d1f8250891bc53a2b3a47694bf95374cf5e26d917ac3d63bb63d2d4b2e113cce7cb957fd0866ddf935b5e8464c25ea8be3030654e85baafa842d8e6a5560ce5fb6f96b0e2d18be9b8b24150e7755b1baaec95e116c97e6e199a9a3f81e568210129d3e3b6df7d0d864f81f3a896d4f85c10f1cc2a2bf810f5a3e121ff712fe346ff27aaaeb99b24018fcfa7b0748ac028836136786cc7a6bb07a65e84689cc699c096f53e92a746f5db07850824e1cf25f8ba009392f78ddff7a56bfc1066c8769d44245ee947fc2eba0d0e1d0b0a780cf021482cd6921af2a58810cf06dcd9a46382dd3596e6a7b6459322dea0142a907d7d057938be8e30ba990a02f7e5f2c05ee8e2e975f9852f18ab8263f18f40c1f98dd524a4cc4b13d8a0241d36b1cc6d1ab8531e029152af9ccbbde2c2a2d58f8e35cc2d8a647bd17c1443352bd3288c4cb0052e94cd8652ec3c1cc4233c342b902551f6b1897d4c1f43f10628dbfda76354fcd708eecd67a7ea97c8a0ac5d5d2a9fae2f40ee8caa87b4fad33e27e2997afdf08d475d3c7718c2458aac4a61171e499410880d7789186235484b8a83e28be09eda467fa2a91f14f83768284d5487c2deb8ce7b887814d028723d4a6e85b0a85c6e4927d25f79479b71c293170f5d238f9b706f014b011ba5d8ed137e41d002f0957fc04e2b1ba7de932ad744c73fd8fcf8aea69706e85eed8bd68bb1879748e87aa080cc42e17f7108063ab596c1ba61ac7e3b31d8518c25dae38cffda59803705b1083f1afd4ce24383d5188d1bfc86b995da66ef7d6dd4ec469f57a2af31412e744a9b40184ce4485fdecf0a35634d79f6c3e980ae5f35637105a4bf881aaf682a28fce57156baa0f96b304f907388cbe111d09a82fbba8be244e96e373bda46037f6f89e883b45d4a4def027449298b1295f1ca21daf491f4dbaf80ac394c8726cc40191dd73f57f6b8d364f79111b42ff16c5790e48695e37040d43854c6b82a23754908c4762f97c66b514d76ed4d6b96358677a1dd00df730749b6e252be9cd126d345d6190d35f77e62f53274df2000198a7108a67e3c66dbee6896b3dbdd90617d77ba4dabe473b279b505aa3f7c01030278f36bac93339699754dc5011dbef169be6e62c5f2585d2f26dc9faf53e05ceb6d571f45edd17026a7e172d95ec88401bc95194481db7ec5d40e8952abb65fe59d65b9e65d97f9fcfeb599e4caff52d7d7771f8a70a81aa8f30be8cd60c7fe1131bfbd9df78841496e94a04bfc4b0fcaf28312688bcc68819af5f5209b189708871d99a271b083e81abb771622ae2db7cc0c5e3403c73a8fa41cf4cb5a8bd945a6597892a5259ff7873d971b866c0e6042aa22adca60ccc3ce51d2418b52b4f8f5c4589c9c4d1c8fe37396fb945a63ce22e5c2e866ea2eeb9f31a3445142a2e2e4c222ff4db75579e23d31bd90dcf87f69477d7db894877047e2a6275e754751c3d9007c6d73f9cedb92a92144a9e8158ffdf2adc45afea6957c88f1b1f9eab29bd273398ec5e1fb4c2c408b87cea4f7a5a2b26e6cd2e0adc59fb60846b5be0163c2db7c18e8dea01da906f8380b0e3d370eb78f2467c8a0b0fb3bd8a81b59f00961623649995b8e6ed31588e6d51b825a297ae18803c06602fa81f23792b9514deb6afbf9f30e03be9903f558e0865f9aca0466112054d551f734c373bf8cfa3574465f702ecf5a3dc3825cfb7dccad44a79dcd89796e525c58b21f5c8591c28d123a2fdb2a3ffe6a51abe1e8112d548746e7ba081c55589895f233f5567cfe78ecfbd60feae655cff99a8d80b3e94aabdbf70be6338bd49c554ef923f239a8819a200a12136086ea2de3cb791b8e1e1bff0cb7d9c27bcf2395f4dd6b8e5029d02d1ff17fd020bcf86ebcd586beb63b1cd5b21559d56edc0dbc21bdcc42372c4b5cedbb59eceb8480fa2d1620dbf8e7ef9e84c60fc43832851ff68bc3409899ef227897b69d65ed11a950fecae9527d09e209e6078ea76377c44964f84868b5bfff3377baf726899f84a0a9f5d7be2f54255c333e8a18444dcf6d2fad766ff588aa3ecebe6217c0cbddd34281ff3460201415d303039e82440c9005663ec24157c41216f785a2e7da6d1f926ae383acfe08dac4e13e4295660a07229fa444dd22c3055235ec1a8aab504cc0f57a3f64164eca687a17940fbaa45661b55f87ecefec4c396a027d000b3e1ff03d74d9a8903724e7a1e320aca7febd077cdbec7d502b0dc880541e322ed819ad33f29aea6c9ed3a73dd299921d2eede954678e9dddb73ecd7f6d4d44d169829cfa0c431dfed4c981ca4f001eeb13630c3a077d878da300fb99a2037006316335efd6ad489980a74cc56bca33cdb5b0645d93e5f1466e050cf5c66ceda9b6e26e17c0e0809b5cd588a8ee568fb57f9cbeff5927b56ea9aba5a89ed03de1cefef5967dbfcc449e2ebfb059eda36d5ef62d5c049911faf1950b9f015d40b173fc12a7e9b9e2e9f4eee5c5c84c7f93228281a14aefd7f3fa937288b250e82add99227b7653f3f40d0b26d590e89641ad46e194fc35061f92192e249f922f0146b6bddbebc6d460c15726710c872b96e204e8001fc3689744002de6f39d98e97d2e00390c82d8a90313aee0412d237505cd23adbd5262849da867ac1d704e9ad854645cca0ca09f94ed4d5e3f60838bb817b5f23b25896710b67ba01a587f4c16a12f6de62ccd1bb1b126dd1317213f2152ff3776f59856326256901d539d5c867a990b28ed061e0b59f6a876ffbbcdff52b1c059fcdfed3dd7fc841b1f0c1909186999611e662f1c21615dc52444ac13565fa8ac320584c42747dc3a855104161a2e926e993ad4a0bf01ea34ca6c371f88dd526a3e72879e80a9f46c1efeb858cf4cc5a379d82d09c048fc26dc58b2ca9a6dd297dbf26ea3e8410f35ea449fecb83b940a9dd3f2fbae3c3983da246df225d5d9555a85f0f80c32d6b8ee6e3dcdc0184fe0ab4ed20399577240449c2de7071c60463679a2f83cacdb20b069f26cf42712ea7c76826195c7142dac08f83a296de5407e0451c78deb19e2fb2be94ff360e7d173d9ae428d3a8a2565836e603d9830a2011576419463a3d044e44ff6e3e3265d1b7bee4a88781e045338e9a5a6e6b713d734cca281c8e9e92af9fcc4ae9d48db7dee6cf3f30073fc315f75e6b332900f2e4794e50aa917123c7f0ac01a6138611f522ef1008999950a2a29dba7630041733ace084949596ec8c3f442542cbc5da32303013c290d7885f46403b525c4e409eb5159a300e3ef8bfa29b993d206480f66853a54038d8d3ebecb7b25a7eab3e73514df7437a9839bc2d4103828eb8f9b96cd2635d884533bc7474de4eb90258fe9788ed65070f43781da155b5c1f0ee6b04f0d0f5e77a83ac3f4a3fcfac83ccc4655e8a2e89a7ceb9877870b5a4c788ed92123bd67a06315d06e4f384fe2f714536211fab4b45ab7ef68d303f29aada88741febc31479d9d4a471de8d02fc9a265a84d134231c08d3d8f2b4421fdac7644b9fb768816a5c047d0028318dd37e443a7a83a81ce7e89aa755bbe9dad9e18fa6c62eaa7c61f97a732dd516899718a57e3ce524441e5c589538ee1f7adcabac8a91f3779cd365097337c3c8ac0cd061f38c25f277ea8da5d85441e9fa5b1c8e3a03de6ce8eec6934ed1137800c8b6e5f2fef390b02e22befb9dc300aa21dc3d1c8aab2ce028955f3d328434f89f8abea1b02df970a67b25bcc1bfb7332f7d78642135553790ec4951af1a9a1a1791772aa08b4b185253a5c217f2af392847fc2f04750816052187ba629cebd0fdffa21c3d486c7555289dc0d4f7dac95bb2ef944c614ea36421c7edd9e938ec2629bd72a802370a33c233b38e68643435b37fb4a02ff4301e875b10e8ecc1c4abe2da048a5f6003381da794920c5df3be19d501b4c41d8813126f0e3f88b610dfe133a19d3998c44a1b6787a2fd3e0ef18ca537bcca8bb614e6d73c1e48ddbbd05ec297ea0eeef16a365e3937338f23fcb488affb6fe54c300d8027b7d4af1d2f92b222eb276a583fcb8eea19b06e6d6cc39b5e738d4fd03e670337817aa35ecb49421fa7dd89c4adeb78399de0ff1869c322bf89eb61349b9b2af131456d63e1f22a0d32343e8bebc81f452565621dbaa6129779d2f2424e94277a5d7dfb2f6b20ee5148e3be3e473edab4dc4c61428e5094c06b9730a39b7d3ce09fc9fc6c38393da82042d86bd5780bedd96cf9fdef95cb41862e469ea9a6ce758cc4829bf66bb9fb1194ca6be19e6c9ad67ec7c818f32ac1c76b41052546938d424c5ba7e4f379aa06682aff848cbab079fade487b916b39d3501ccaf5794326c9d3aac005ef9e540e0cea0f6e61c0e5b488bba1e0e05f920bdadf11c7a76cd73cd158bbe9fed2ecb885becd4f74303372457a23615288def4bf247f330d90a21a676c45783b8d3464e8bc5757321d7b1d7bbb53bcc5be5db1b62cc0e4dda8fd9c53157bb059be95855d9e192d2b965b8e7cc1392bdaf66dd4fa91df6ee4fb23a433bbaeecae0d88efc325b9ab7a49424c232a5441a4d7675ca9eb15e490080001b0f026adc1d688dde140d667791e865eac75b4bf500a1a862f6e80ebd4b31d17e4acb9be0e3efb79209223acceef84e07f241d5a322c5a4485889c4cee0feba4e9d2c8417fc222084a1a4124bc999110b1285aba1040a8e03bc842f6d4ab6eb569d3fea0cf244931bc7df4c0ca6fc3336b66911e31a2c891bd7000c1ed101cb8986fe25ae2d0521c0c598308706213da673e31cbbe68542a2cd65e6da20fc328509e7c67efa7daa17f6483527fffb41019b843aed1bd005fe26870e9b48caec191332d89e006a3eb4f98e1f5925f1bbbedf2a036cc91f6ea90ed3fd1327a336e84ad84510fc6690efd3ca76676036aea0c9f8c1a84624b2e94bd0d50c994f03f9b9603533df9839e6439a25ea4d881157a06bec1a577c971934f17826afbe46a88b5d7297b51a2655d0246409f9a85525e0e2616cd92304b5d0b41146bd67dc6bb6a0521a5d94d57a71740f56a3009824efefcebd26d14c9425be39e8dc1c64d0fae01b2df9cd9b4a0929c39c2ca5a32ac921b4df987140a5b5de3addcfa8eafdd75036ff60e94e79d319dcae1677ee6d9992e4e37c940261b89975194b2ed8b97407cf002df5ee359e23bbe45ec0f9f40eacf314feca14a460a990a26381000f9375dd41ba24b9876097d6da4a7c40f965d66f671bc894296801788b7062d367e95b707ad74b659d419e77a57c29d0ee168073c324e0cab9772edb20e725d1ae9f389d560118badc1011220563b1ab056ab4626f24ccaae3e8df174e477a5832544a28cf9f50ba113c587b153d8eb5a87fbbe0ad063854d02426417a51c4f565890d4dca469b5a0e408c48478d800fb3eb06aaa93fde4465947197f509b535db3f063e304978743817a8c1cc1ad63eca9ac940f5b76d7eacb510b3c422513a007f7da7c73b3c7390ac588184c140a3ad33f90bfe3f6f441ea429adce71c0658f66a77a1c7ce27722acb83fb4b2119bff80d64","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
