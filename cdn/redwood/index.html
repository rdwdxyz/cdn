<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"11efe3251447dbf65e6a5a931c789bb91299e842e06ecca40cb1e2a0e0fcff126ec61561f2c92df56cb50229ad5779a23f41917af0412cf740373cb4cc63aa9d85676a95420fa5518f25fe2bac90486bee52e8c831b30143558b737b89253d942ada8c5930079e8259fc95328a245aa3c122be73a98fbb3de1676781a26d2635e989a3512db41c4d5e73e595da51730baa39557361c3e3f045e0da8245a9f66bce45c57a34a2ce0c9ac5213edcd545effd06d59230cd21fd4a961b85982b94811d86c6ad40fa850c9ee7d78c36f02aced3ab2896b26b66fea116de7649e26d23b58979c351233e4107c51d6ade33c7dfaf198ac1cb7850ca3322776e2a3104ed87f6f63e960723dec91abeaa4811be5f20f6f1fe4ad61f08364d4d31e2655a0c85d2168c2763f11a93cf7ff3caa9b4ecf022a69e1215b84b5afb6190c945cdcae792b5b97d3366feb6d2666443b2bfaa8201a1126db64d8e6a6c9503b8051734b760ca5e6d3e533d88ff40032bf55862b3918e9b038ab9a460f400cb0cf512613d9f4f4f5f7eaf3f25eb6e68e16ef6233037c294600f4dc94c51f989f1e78d62130b2088e68d6cd2839ccdb04751e15fa4950f06d76c6232b7551d250b1c1506e7743d7de6c6aaa82c0722a58924c8a77d6fc2d30235db28fb1233e33ac638b3e99a86db4e7b77bf70ec930cfce0f09847fe2987df7d19a8e619a3321153c4b55e7743ab30ace8f96db893e845e6f3025e67fa783f7d9d0f821db2dba55d256b6b626d244d929ee4b4ea4e0d51e8150e660ae9c4c11f41ae14bc2233455cd971e455800a08de9851222ba258a2151e46d3fdcd8f283de983a18d8f43222ede03d9823430212c0467d32c260cdcf4d4e96a9f0ff94dcb186563d232fd5b1a2c8573e9f3659bd0df89b089bfcbc5db1cb5091627a8b94761ff352fb5a0f08c5b1a6fa16dd0f032685e6030258c0917b670521cbd2660323eeaf3a482147e499047c6eb9a9fa29ba061b5af50713e12a4cef53d8d7e365eddf94c928f1506c9ee5304b4c94f08e10aa6d97547f3a02659305a3ddef6775880ed6ae1845460aee9926d56ab809b0a5e4fbdf1257f974486de7012dce3f87fceea7e05e579d49e73a38e2fc030f8351b5c23ee06477bf98e8a2045d73140ca3965ce9617f2cbab41d7e2b9a6a9ad3a5a5fe1dea4066148a9ef8d95a5874069da1afda9b1efa0f58dfd22f26c9e7ac92186e326d7816489183652a972e42ea6edfc1a8791f3c0153e917affac4a2551daa4e67971a0de725d84170857bd6a11ef7ab51d326d59715a73e74de484e231e310f9097bc84a2ab764c0877cdca64acc8a05ebb952193e612522eb969eb918ba882a64184bd71e6a1ff89fe3a6628ed9358a89d516489cbfc70ac90907e3f82195808d68e06569234275942231134322594a4e065cd714693ff72b8009c08b5d7f6dc8feda619c2f10ee66752f5b5cd61d1ef4c1ec0ff2e54e517f6279991443e564e17ab890f20561e911aef6e87fac03886c567af49ea301c71d1d3601631c9721b1fb629016625bdbbfd0c8278073ae3f645f69a6450ba0cd3fcc81d4d9cb11ce509d57e922e93296792b2272f931d18c88f67797b67c380402ddc16be201f17b997c212863bf75a36e45a54c58cea7f6c053a6d4b3aee9d4a8452cd4e8a9001fd4a4b9d9e6d4b0a3b175bd5324ada43f0fbb928a1327f55e76f24747bd502540a1979ea5bbc111efea03f16ba0830270346b7bc756cd63b8010398601b4af79f99a03b588183831b312834e8868a52860c3d6cdd62ba3b8309ec57dde14c99c07c891baf1a2641ef78c2b5c8f1e7839ba6fe03772adecd6af39be6f7c5c0adfbf72ee0425853a68c1599d2d06e14fbedbba1ba50daaa1b2852126686b40758908f554b800266934555f7c13a28ac2f97666d4e3e7cc7e36b9d9dd78810757593328dadfe402b771b195ecb5dd33d7e3946e7131a7d36a1f77ba7ff058c26be413bdfaf64b1b57299a418293b5bb84492103c1c3c61a4bb8fd6db369d4ca0c5a6e7edac77b30807681d4c96f5ffe559c9af8cc683118b14d16700694cdb74839e4fb3ca0e03e36ae71a88610b451ec10cd248076a95491549fc69570e5387e99448b9f267f49c315902c32ffef57ae3318d79144dc7690785ca77bd3aa0f2b89f8fd7387b09d1481d59b9c3fa8d137ecef0d428532b1da209a198befbcb81b93da6fd4d8a35150f52231f924b39a968abbfbe24b6532b4056dd4b08e8e46274d5be3780ee243d880b37cdaa0ed0c60d697b0da32cd2aab0f684e3c9618401ec5aa91ca3a00b1d6157f700e02645950e86f14965caad2073ab079ac71973f8cb79960e430acc94a191a440eba6bd4e4bf1612eff78900f771301ac6be3f290cc236f7d608bfea4266c3570ade471f2ea6ecca2ece40926500adb47b524719a4d9d37368b43805a721965d72daa1bd0c974ec1db5954cda2e8b0b0108bd94508749a8d9cca9c7796f358bf5d53b3675bff24f5f422383a845ab7acb18194f56791ed4843c7c7d6d42aa692a1eb2d0666eddf98946fcc5449e811d3aa997b0f54330d4282fa8f546dcc3dbcc3307d0379b636ad799220b770abdf557256c3c7eb948e3d3177b2b3034b15da15ea27419e7a573b9d620a4d1fe3f5b0dd2fa7835f31aa3f747a521c32e2c3ceccaf9495b8e84dd9f7efc534c58331e010544a1df1853986cbe24be5bc5d283bea1d1bd5f0b65cd0b8476c2cf9b44d990dafc1614716bb054d5292f84769f7c49ffdf995176388dd7c9ad762cf8da7c12163986fc51b13584eddf0f9fec8b39e94fff0e82b5c47c8587784442638bc5399f67967e01b450d2b194c4c9c058bbf0d37278663183692065d0f10fedc1f8d41cfa8ed7cc4271849d90501badd244330bfbc4c6b5b15fd36997057567290991926ddc31af9c9fd3811528ada11ef9f662ec3cf314d4a9be6b0a35d23018db5cff72e0673c77f13777b7ea78bdb8cdd1751f4ad9d92d12f27a71e5cc1aafdcc553b23c2ae1f37ed02598c7eea4dd12855b0c2b6884a6d99b99b8b62f0ae993bc6b4ff7d8efe5f89e9b977ce4ce8b5b660cb74a7f24d485f6c0d9982af04ae754932c59ec9b313f96fe891f509114969d30d8377585eb8c2c7f4791cd676758c407192991b3c0cee830da003ac93be3f3ae199183ee487ebc14918e632b63fa860dc189a6898be488ef20a22832fcf30a72473320905f74f75b3b8e39d948793247047415c894add091eb92e10d324194cc5b6b5e4e335a3c35b81cbba0e57907805e1d9df3db282f588243b844b1dc1673382f482caa451be7b7a703cfd9e0509904794b3e9d3bd8b35b0d0276dd4f78cb9a1ea57bdd086bee846c5b0d49596237b886f075ff225eeaef11381efcea24a2ed665e59b96f51c0a918ca22c3c8f28a69e3f96c372cebf8538034f60564c20f0530cff7c7a78c94747e5c888572ce5e9b80f9b4ba23c54ee55d3305a1be8ae31cb823423f958cf1b68064140110aae86b53d5dce8e20243da2373dcf3929a1cd8528bb8cfe4b2aaa349a91b52a3a14f42b2a2526e9644d1047a0fe4c2c677d3a74f428a4072c041a95fb2e64cb4aa7fc0e22f3e1630ce1ae18f957f050b3193d80b5f63e6894b9cbf5cae06f549485b613f2214a07b214ccfff4f41b27bd58145b1cdc03efeb1b0e1d7d1aa00c39be317cdf0061e604f7faf328acbefaa44375aefecb76c87478a63fc839f4474856d3623191787b91dbea4d0f713cd69cfa3caff6fc67ad601bf05427fdbbea0da0fb6727f558d2c771258fb7d628706786c6e84225efaf646f0a3e82e4dba45c91cd98082e7758a43e6884286be74dcf40944c5077d0435b9df8d3d36c68354c7c1b1c4fadcceecdc8910a147441904894a70d36eb9fdf8ca1e8a34bb8e89693745ebcea7f214f3135000a9941a457ffa0cd151ae1bd43f46562262a77c1e2d75c77ec70b7f261dff56cc8971f83c9ad2eea02ce19d5c98bfd94f7f935004c54acbcb6bcab9bdb24dd086a30085c71bc8f43cb809a616f60edddf90d73fe556ccbececf5ee43320f81bb8ac1cd60b32ea37fcbb756f5fea8daa66a6cf5d4e4eaa0f72eed637d403bd31a0e4772fbea4d2ae493081e901a0e4ff1c9851b811b51bae7bfce3c93b3fbe9d8ed27460bbec977021230ecf927eeafc6b6e0d8dc386da98cb30c4416330bbca5ac9740097e9cb3ddc1c7aeeb40f0269ebf960a738cc5459af75972cf26df8db35bb9428f8c600692951eff6f089a8e456d10defe570eb15dd1e33cdc0c458f332efc43c76feaf6d39bd3f8b398d4e41d49e0b26742c8a1cf1fe6354f3241848e8253a8b6e8fc7d3de268255026706c52a36a2e7445fddc6b8f1a92af194de8167b20582d191b6860e2a1a5f8b6920bb51ecb1526fc72ecdcadc84d7ca618e19043d7dc4fd90dc4a8384ac15dc8c25968f9d9bacb6dc52c7590afb201a275f8b0ee3ec0b7412a6c74780f285a433d22379b8e6d1dd1f73bbe5edab16ead569051589e0269e9801b9e87fc9c99f133d3ea0386a8324939bc4125ede22e34d1896263532bca6ae8ecf8537cd7b5e6dd7282780c39cd12bca5a1464d187f18a5d62a31df50f3eb674c1761a3d55e27fc02af5ec4ef3f917e91815f8c2bd94f46574c547586ebade897bafe528271170fd8958335f1524833709b74b055303f5e02b9aff4419ab10c9edcb12763149f4322a4716dd5c1bb86ba5ba75bd425dacb9c4bae5ca23905a4df9815f222bafb1e4e3eb49478bddad831d733aa32282f9e9febf8e6e366e40cb3bdde0558da644b3aa980cdcba90c028e6996d6b464ba3d0c4842851dd5e76d9f774684c6373e87702069fb3cfd272107f6a436b671b460c192157986c94b010449444099110d0455a143263152968220dd6c4834a326280b1b598b6a9078ad4422ecab0a7c21a0b78e80bf1e98db8c281c0af60163742c08cb2f9985480881fb0410e806ae79ca57d9229bfb92a83f09c9e9039f05b5e76236432380f6b41f96a8060fce0c5af620d3ebea66ad2418f8eeef4f1e9dc73f86fc7c311200d0cbf64f2ddfa49168c5e92526c6da7d22092bfee256b46ad8d1895b594f935be9f45bdfbe2355969496cf8120cf53223a0157ec9a23d641b37fa91cdbdf5073ce5d0190412446faf39a0cf4af90f5c19ad46b1dee10c0f4c436317b90431eec108f00925556a3215ee5b784a13b53f01c15eeb0b4e67f830ab0afc1c0d9da7f3390dada80ced8104676a53be3e6527410f2b6da83558438af00a8c38883fa6c169355981a40cb89b59a3a6189584d152d5f000fad14a1515f64da17e85e056c9fa2b0e1b3970650191490e9b8350297b34d19abddd53df72c718957461dd0cffb9d2ded1cefe454e880f3f587d4fe50b1a8f7fe9ef5bdc6f2cf84d0ba9bb8aa24f67f422eeee5a1baaa20f38fef5635be05732203ae5b8517adebfa317680b2d2261278f168169a80fbf0a5e61d53ffd8c8ff9aa3bf59cbd411d8131409d8d75fb16a89612abb3c298e90a798eacf7fd7122c00e3b7766c40cfa4e97577dbfab6a51c346ba1ca36bef8269b513094a0c18df46f417f3ade22ddd4a28a30ecab714f96562883cb3ba379bcdc050662315a727de9e2436424ecbd1a22a00fd578e4c659790ad4fdd414a026e6c2666548afbc535c213030ce1b78085774dbbcb93be5f217b9e021c94c735cee094e8f1326880b9b2beaebb759ad861ae093cddc694e0fb9218da578b54660e4f6b4ce752b2e5c784535868d59764b109b8b41222708c827cd460f73eaf918ab712bbf390eb05a601066d39cf4cc017a2833e595bbd89701c6b62e3c41970a5e6ebc1713c5f17099ae723638f7c62e94b97c45a1b49293f4824ce1cb1ac61325e7f3f1cb857e33f2dcfcce91407fbd729eeaed81535b4f965644aa92f16eb41587ca9398dae7c6d4ceba7fca3094d30983a7e6d10016abe7b8df549708c856abfe6079702fe996f04ac2d13b3d3f121a77b56a185acc8c7a8c2cd9a9b2671d4b066c88b4c8a2156ddd0152326929a0d118d80ab722196a46d7071d2e8197d32b9307be439c9dc96fa504e3c426f643c96504cf4ea476bddbf4fc90581869ab41324c4600b5bf31885b9b3d50f0f33e122c41ee26968b9d3c43dec83c55a33ef4f07940ae43a6f023cce9bf61a2b63c7ebba2e43a0025ab2ce46ae4534610866fbcf15108db4bd6f2dee1f07d4a5096a1702b7659a8b94e7e50db9a6ff9905c101eb1ce870daf985653e3cc07d0b0ec680c29165ada6c1c447a83afe6a65d46f33f8d132c75683eedf0c9a2d7323c4e70b480acfdc673007d595a8c8c8877501fa00d66935f297dfa182bf99c4da0f44258e3d748bacb15cf2868f6d3f5310da3e4572b21b3c98d4b909c1ef22b6700371cb2857fd61370f903e82c29df55b5bbaeae447f47760d26cea7779a7b675d9a4c7c86ebbd955f1c630c2442edca752eb4425dc571a96e661c7ac66d1007bdaa38d2472898caf142deb6dd7bc8c824fcda6ac984ba8c9e668c0b59aaaec13c305e34d6cc15ff84d84ae4ae7f8434154f4f4375ac3a31d2640f8a2d0d47257e72f23c8a9b373c9868c0393cd82ca61909fc15d722bfaa775231fdd1bc366e87ea3d4f598729cb56ef72789df38ce43ca316a4b090180ee50680a334c6f81d52db9ddf743e780e75653cf50b70d408581cd56445771c96007b5d30cdb019c64581a8841da06facfceb0de43d72f11d066d74401284542630af5261e9ee1414a9fa9938ee12f082ccfefcf61bf5b87496f49fccfcdb32ee3614f7250e1c59051a9a2be9836ca70028ff25005d680b4ef4c0518a4e027e76bb9854e9d31557d0c9fddf5c00fa7b495f88f1a1c4a0ed9d54f772bca53de8dfbdaae73e0340198a9025668b4b554bc6c76e416391c2c85a07d160aaee68eb61d8cb2539fa77f827f2f29f172c369f1d14b3c00c597fa69c343c9778fd81ba9486e8d82964f27c6ae0d4a3bf7b122b3d8e4cf4d0ef7471efe5fe0083593d2861e4d29fc6d815b5f5c18d47d7774dcfe53c29bc0906b1070684766875960f80666a4884f6eb2217df69df7c01ad24145733897fb71ceae6e46ae9b438f56b4e9cccfeb628d0b543682cce2751a0c8ff592e47ec1d8df693a24e8b3817a660d9e05d37489e7987187a46e685eb1c9489e221aa28baa59a2373f8f1d8ebabecef7dd53f653a18d0d9372e2bfc6578364a91456a26612f15fa18cb2f8bdce30f598e0540991ec6cfa0adb1e0877caaf3a0d6d896dde5a4a94f3045cb0076fa2bb6b447b027cb4b1f1e330a3a7d6d48739b983e6a26fb975f3097b48e196a3bd1aadceea25f31a304910c163e76084eccab4259bfb2f8b6cdbda0e81a162f066426e9faaf023200276e1eb533de43e71c66d6818b6b232bbcfc7fb7af86eda7923a084b69f390eee4d38d550cd54cf9a7024207d1a425bd80d34208609e89afcabb0ee107aaae5238584dd5bc99c887fbd256df05ac8c0eb2f05aa79266be09542594741d209e36a0986b0f904d89cbe76d47a372636ba71113cd892daa57127204371580a55b334fd7b17acfe220804fd13f097c893da348941151c3c7faf37efb085d03317aaa0da1112e480d5bf70af12a1988fc66a5acb46c7e1aedbc0a4f8d09bdb87bd4179bd048aa09044d52c6cccf2f4bb6dc7fb0f4f4235f20d14fa41b458eb888a679a192bae7ac02e1d77781c57a2efdbd113176002a119fee748aa1a81248350dc7fd2a70a03aba3cfe36707ea83d13cc2cf1ef04c4717b93c5d623151f01715385a79714dafb0527797c763dd777d0a19d56278f9ee6dbb0ef9bda5e65c03b6b2844708da5f705b8c4e3673dab5ce1390745d5bc10f79f0d727d8c8910102a3899aab1d14d5f59b52073b9b3731467672945b037aa17f874de451a468839803625cb494a61a79cd83497fe5659b6e3caa41593cd482b0b3ed111dfadfdc522e0f94c3b75612b5a649846daa1ac8fad0a91601d3bf1eb4a1fd26d4df07e5074e3c5d4bccacd2846c5444c62627236fd80e5be1c8ff8ae238b53b17cc56d7af04d7dad15ca097dfe0a9483b6d5dc2bc1f5c6f64da710f02e3f376fb2f432258bcac39c49ab77494e60a80ecde72d0f4bc26a9a64e14a1640d828aced5b36bdf32bc7748c047cfa5a3c9b49bbc6d2ba42b14529cf18d792ffcd3928dc393218df5ddf0fba9c15d373e0566919055ca1632e4de047d4ab0cd391eb466048c5ef0ea02dafca1d98b96e098f8dfa90578ca60d358f87127272ee19351295e6fe8b89b29717a9512fddc7d5bf55744a0520390f57f866db51b463ade60a69dfe67b0ed77b43dc8e8501e3fc2f1220f7c76f45d6021beb4bdf6fd4182e78d4421e0500ef37d7fef6a3102c7055cf404b098077291e25c3487285a58b00b8b4f9eccf936efa0527e96aa6789472c78864cd00eacfc00c7c73d7b7d5bf8cd507b078f23e049a9330a3056ea22a56a3ffdcf5d8977ae73b5777c78e81f7b0063294ba2ce0fb2571893192bf174fa595e04505468458b1cab290e85590bdccf3569d1942ac629a79f16ac03975d118c477fa0cd707d89608b73cadaa3cab04bfda1b45db1a83a79aaad92cadf38b0cee44b8062d9676909bf76d58ea6c36b5f9951ed6e953f07a558c61f897ae1ebfd117fdb758f0c6b7b0944a785dd004ba39b1dfe9f8cbf3f49db7ee741f666e345951202f9c514610ff078e2a66f091a5d5ccbb8047a52902ef5c49121cc94fe94cc0633c8e8a7a4e2e6201c2b6d0ac2925fc8689789636d80b3a7be6355e2b2d517f177d642f8e36938b53efb497e92427ca77a73bcb1a75ee786da72b16521fceb9e909802bd98e5750152ca5854617a0d60a44119870df8efddeff3faf4cbfea14e60865d2c3c70f02aba6db52cb215e35f383caf308f538b3b72ea554cb6c92526abea04e940dff29dbe7239f197f9e5709b824aaf402e1710e24274ddef3943350ccabd35a6b64107745ddeb87f6da4b354e495967178aace5ad2c1b5f8c9c50cb6381b117bddbb687f4a3bb8f477e4d7d97fd93112bbc77fa479dd40c629d7c446db98e0a34c61c676203d638f2465f7b37e7b2327ab0f147739b0e0618b301ff497d080cdba52ce4401f7f3bc652d45b521eeda9d460e898a251032eb7d8e2d7431e0e7720a70c8232d9fb819fb98d67a62015f176baa9551999f7f2d48206e5efff0184e9762d3220f81205680561ee4b6831ee5cf281a84b6fe439483ab437a5acd8dd99a87903eba89938b4b5698bf9cc74372be95bede647c7e57504d3a590831675d1468276f3dc44d04dee7e0f706e9834e7b32c55e70f84127ed40fefb60a70e3781a3373385f18e632f442b2e41b43664d774175924bfd3ed9b6e8d43c96b7174faa07c496a4a691d7bdbdebd1cf36c2601290e03a7cf72783166a1e1d596a2edcf6d331731dfc21e9035ba915297416b6dd0c17df7ca05420322c5965796d5e4ced407e27da4e18868fb461b2fe8be880ed4af4397671a6d7865388132f5b4cc4da084ccc6fd63cfbd0ed86e6a4193b2dc064f70c940c1013dc604e05fdbc2579607e56da0c84333e2144ddd1482ba695687caacd8eb6ec8b6fc540636f9bea8fd92f56f05a013c1a80aee29fa16ad312de59028311eec3d7e6d8b36d253ba3f866161b893167cd0c9df2133f86d35d21873cc7bcdef0853ad6dac164b3b240195c0110f9e5ffc8a0cfa94784ee309eb152871ef505d25cd2baaf78633f7ccab947fab49d168af8fa290ed2b9536bf8de95b7cb215aa5e5ea956713456e40b719cfa33844ccabc473a939329c9c39f51375e6aad7300b49ed532a082ccaebcd34b618ff142873c0e3795e05d9a12415c32c95fbf4a15b22e481e16f9b5af1228485948e02ee34e647d92de7000555a715ea7dd31e988f08f289ebad9408547195a90f06255103a0aa00f0014dbef6f64a77a306f493d49a540533e7d88a3029053ebd8b9041b6dccb52824f2deee51bb4a12ff0828bdb604326311a187f2994b0faf886406421d5b97cccd8c69bbe97b30b2ec7ae57ea5c333ce1ffcfb4afb760de751645cc93e208ecc03efce9f98d165745063d89e7e763ac8ae12c24092179a97961662a88ea67b286995d7a8bd66b2e36cb6d992400978b1545161688b3ae583f3a44c9042766eb7c2fdef355f6fb964a1bdb04f55cad583133bd038c5a70b3c851cd1ecc1582b95be89ac9745ed7b8fac3270d14a365c1e5a7ab6dfb3ee435fd6347f85c8d5df59381ea45c83ccfdaccdea25121c7aa17ff4bf4bff6b75940d1d533b9aa2fd62926361367065dc0f94ac3b07a58d78ee52c114fc9d92b4e3c85266f187120603ef6105a055d9d6ec8d2520dee608eca203c29248bca9ad815ca0a316b94f1ed1c0952f05fdf12178508e5e8588b1fd1c5846e5863195f752e785df546e213bffd4f74df1fbb5da085f4ed2ecef599485ae5b93a67669b3fd6462f63018abbbe7847622275db372e68d2106a4b63b73c0bcd9ca45275c1961c9358de4c52dd1b038b4c1212ce2e2bea28ce96ce4fc7de994d621749c9320fe93406993a97bc3d3b2d65411cc5b4e82f32fbef27705ea35484f05868c68391ec5384dd87d5993fb206579eed51d37bda7da9de77f4f3bede5dc8a29fef141544b2d4e050c76aa070f331b85ca551bd41b0198ab744def98cd37e7f24400844de8af63a54e830e9322c5d34684f2e1fd4b123dd5e192f9e77c8ee588329dd781354e48a8db9c4d08e165406cd3d6e96557cdec660d06f4a03d6c5a360a72088a0b91c18152d2deee631a8444c0e165e88d34261a9de3fc1d258d0eb9256dbb10481476fb993405f98d515bf14be3a8f4ef8d8518594e1f8beffdc8ba8ab624482d0c94600acaa4beba48dfca879e470e370d7aa02167e3ef6eece73eddb6d551b27e15421d9531be1c9f6e8b8c8123f72e6f19df7c2cbefcb00c25d66fe8d5635ec421cbe993e187c574a435ffe81588d08f76f28d1567d29fff2ce3741f39ba2898d621c0b91eadaa5ef5d5adf24ce6f75b7f7aa2b1dbe8fb4a5244507ad5cc36163c9085f075515496465ba7c60a6257608c0bcf5187d5050add4dac1b9e18b8b0172aab66b78a7c8529374e6142fa9f8e816342560ffdeb4c1a9e10fd4ce1d1c302e1989f437f2eec1c5f185782f538fb313d58cb2058cd586a5a397328d046ca0adc08bc02f0e36f2bbc4ca51866ca6117f503083553b9819e291565512eac2832109b0a4387b86145ae3fd4b3b4639dbbedd1ee058eafc9e6ddfe690b53cbdc3c91cfbe9a800baaa49ebad2fcc942ed6fade581e133605826cc0dea3107069d1f4584439a4d867468a2cf0ed7a445c819037da0c133c02af60f5e7eded22effc4480dff7c06c91a03575240dca28c0aa84774567c107ba78dd85928dc541fca93df1229eaca49e926c7488f20c809cb4f81c94829cc2a66925cd77a1edb75b1ee780a12482e5b25180f31e061cf95cd7d8e75fd4991647332ab9389e63896d268c5ad4c26cb67561a6f0a65d15e34d27839739c7d407dfc88ffc8805d696a55eed16c4f69b7f50cd7d88fbb32cbe0d68e211e25a6cd706b1c7a6126bda38a92d3b55994020973c261c829686ceb2b249280472e9c7c7db91eb4d06aca0f32c001edd5d099065a2d13c655f001f8330171226a61edb93067504113a111d82275c0ad1979f80055b9512aea30d7fa96166df57b2c672e5761113768f65f00881ea6ba9a24a185b5b55fb2c4c85ed3b1da9628b3fce9b4306b414046a46eaf6870510e8108af70e23d735b9c1a927ec99dc4c327857829021432eab3b3dda4317d01098aeb330426a758b5d5ad208a6c133c306c67c8a842a4df7aa4855988be58bba563aa12e7716a36bfae8428a6660e51bfc55fa4baf6d40d55882ce323fcb09eb4e0c5309e78af5e57cc90b50f5ad0b7f654b2c5f0b5cfc89d760fb1840f94f5fef351250fe5d4df2e457e25704fa2066774887ec50c594a73bc531d4402625e64b921b3773fb2e6220a02e7de2fef9ad13f29344335477247784580c754f5ae2e3b1d1ef05eefaa924221b4362aedb7780c741255a3c38187995a0551580c1f9281224a46de0e7c4a718e0753a03ce4f8d8eb4dad51065b23b8b3360341880b492e1b2f02c00b487d366a3a97a2d7708a3986ea191827e5968a455d4fc040ee9c32545a37bdb2310354b96c276a86a42f6b95dd58d7e79707b6117c94793fc22771228e67f7ab106a128bc5d046219f19824c545b84cc1ec42f56193544cf0f41116f45f53a3699aabd550ddbfdca9404068d9f3f0f9450a5765781755bbfddb0c3ef5d1718718e1728726963148064d4718d7232932d28133fa0600f3bb240339793ae2f63ce70a8246b6bbf43783a8eee220b4a0b6b3753bf78f09f4d9b49dedbf01c2e0ad05af0b7732b6a81f5c9859b2bf99f13a4c9a280a3b4a5c689c6a67893c701ab3475967ded1106b1c7cd8aea4ee808921f3b2a76fb6031565c9647c4b31c0032fe000e7da3282ff804746152ebc78ab9f652480807ff642acb5dbff17b9615e8fdfb069e43df7c87b97848798ea5cd9d2fb9c8470b47da2f3c68f70fd8409a3f951e7e2736a9446c671dd3b22876c08a4c3464ace505362bca79c8a417dce7e028d3cfc2a14179dfd413ed21b134c96ff3ab0f717c709f79d89b435e5c8ad53918dac37b7311010d7689e3932e80658bbb28689ccc9d47c7adda075388a56995f7b2d55ce7afa7f3087c7adbaf45c7bda4a13c9b8e17becfa61fe8af06ab6a67fb1007eeca5b69b5433b5150d0686fbde8fca737ab8c162e6376b0d8d9f9c48efa2248c613bb80c4043cd11fd61737b8c965d572a1b290f6674cc5045c6f11e310d45891eb8d83225b99c869b9e8db28be550ad727bb586d0608105a282194325714ef64721f84de1eeb7bb3152c4c87698f0b734afb75ea0fdf07229e65bc669e647a03a4ce29a4fb25538a8cce001decf64607cd5d6d2dfdce1573480e67b68ba6e55daf3ae47091786a7243c3cf0cce1158f90fc31d57bc8eada580210fccef0c22c98777ddc5b62866dadb4fc10e5fa9bc87fd679bb779e2c0de510ba08f9bf3be689e16e2cf4dce931381e2f00852cb5079b5dedd858c2e7396ec117d89617cce6fd8a48df997cb7cc6d9b2fa480c2a90bd4e60903a4150eb8bf91728bbf70319d1cacbc2eb7dfd05cdd6c1a619a24c88134cf0b56ad9b45ba84d25c8ff04fe8e7e1e21c54e0ec9f31f79a9ce8579a67269aad56f36511cae19a114a586bd3e881232750bc56eade5909e625c0ddf6dbcb270af93420ec87a1ed141fae95114cfedcd0a490c49141048b8f7cb3c29a902a9d1569631fc04bf5fa9f583f67076a8338d92a3626d7dc0eb33f78d64b94ec7864730c9c9b31dd8b3c5df2807004f82cfe45d683e647d2520bf8da0623617188f5a041b81d9cdeaf5963615739bdfce3c3d45b53f1992578893de25636e9e794ef03352cf35c9c25b4903c541a65b0fe5b4d492a30d067a4d79debe6d66969ab69d1c82ca08c5ea8c5340fc81fc6312dc4cc39e7549665432e238453cb60c2426d18f7efb545a3e464cc3751c419017c58074adb298299ac8d3881deaa42ffc2e35bb23bec0d1b0d38987f329b400377ee37b355328793a327ad101352a9bbb44696746b2a17e65237f9e2bef4947c66b1ac8a30e2395984ae980aa9972a67fa74f5b24a254a2d016d7e5573bf32f233ae6e8feba2ce136f9b5499663eff807a54c409dda4227d7015bbd81f50f0f4141e29771fa97ba7feff62ed7184f40e9407a4e105768ce0f1645788fb98257b12b1017d52a538e765401552c767f0fa43585ad757d327f778164dc849a040323b372e37a045f3ec50ae4f6d88d3108fb914923f6d23a26f5a47d41cd42fc009aab9baa6996a2c0fd470e3ee36fab591e6edb4a09659efb6a25d5b2c85ea3f4d2573d7e6a96c027f04109aadf0a13735e644fd4ca0687c36c1aa25d4bbaabfacf590b3e29c293457678c4ab5dd7b048e34e2ea75ddafeb1f4d980b4e4eaee497d9559c9847f0a7b41cd7e67aa0885f42eed161156a076f51133f696a95a9268cd8192f7df4064a2255ef9d42299549a810a952123511360c45b0a4acc6b4394a0080792aaaf22c659831c2404626830aeb087509c67eb0892bffa9e9397077c8537c585c4a341ddad2524797db5bcd492831e2cac9f643cafd7fe0778d718a802eaede5808d049585c5ee4b9d466c9befc96670f4757d000648d0f92f7f637ea69cce3992e9153b4417f2fe68cb98aa24932d43f6e865a831258fb9e0a5c825df0aa023c0df5e24207038a0e82469fbcd391ec048db521d49042d5144baa24e1867d4107531113cdfa8921456c9e96f3f7225ca4e71431eb8dbc5903bc0644afb61b9ebc227f35e64a44df569f80d7729a87ea7ada47f60660aec67276c4bd0b5d1c968faf701bd49141019635de794ae63b316b06d5a191d5abe8fc9ad878cdc56e0a963b183f682761e258da5f98f6f744c79a9682d5c2ba63cadb05ce9ec890ced4744f50dfd556d43e5135109aa4084ff644475cc935f05a9995c98df7b59dd59995ad60c6acddf10ddea4c53e75ecf70dc40484b476503e304a51628b4253e601e994baf1b15c2edffd6da24a2fdb4fb91b4178482b8d134c5ab1090c6725447551a8bffc9c9b00b6e0fef7789dec2058a5264dd8bfe2ed55c3aba7017b354dda31c7d519546bcbc95a4a31c937a6694061b57a7c243302125f31efc2f6e3bc785b08dc9d97272ad95b3dd1a3f93966b7e3c03881c96f5e5e3b0cd4e5797dbc5f44f8cd61e70712f6300af7c191f2cba71eeb222ae883f7dc6960ad049185e02f47fb9fe9c054f923d2902fd6ceb37bc91c1a991872cdb9a1e7b54dc6dff427baeb1380581c90013570d15329ce9cbb3a30a414e49bca428dcf832f929d4d482464121c0bb94dabf14f5fb866dc27441aed35e6bf60dcc7fbbe3b317416faa46fa7f03a10fc772b86edcbbfbe23ce8fd099fcfcc2ac52e4e7be219203f5ad324a63b8eadced844d32be9311aab950ba4c2aa188f4d2a2424ae137102c8eefd1e92870298163b7728420edf38675c1b2fa8907032d6b4d42a7b8c4d9fc823a806388c808f0a342f7b8171e4a9ae45eeb5519d4d0d89c4dc38e8f39b8956982e7e3f33f16d6410b7560070816f298eb278acd0861889bb0bdc98991310bf7d294cd26237cae102060937407770a64d10d14673fc480940510a779936874937e385d40a0dd81ab5e03dc48b1f52a2ce39c08a989a663cfd1d4b90a97b501294319a7d452a80733fb38bd1669a7e6e4c85b12c1c6af3c2b5d4f12279954065eb388d7889155f0b14f9cc9afbfb03cfe246ad6b5dea6de9cb19ab908f6467e2b9d2a39bda34e130b05c229322b34501caf23f07010b153d95a40995cf13615b9a6796774a21d19a43c9e8807fe8104ec385d37d231ddc35f20fc8ebead0421f5ace3cd30b8c4d68f9a8d057cefdd49eb8b25db48e7142d60c4c2f69f882ca49404705c186cff4a8046c4883505806bddfab08710d066791020324f88eabf117769a2d534471714d8e38510c82d183f65ec1bbdc0a2cc537ce8531b55aebe0fda4bf624d6360b1c271af71f8b8612450b4d9ba937bbe12430b72da34ebd54d5e9f32beeea220bcc9b153ccedaa2b0615f999e47c2456088328091aa639bf10328c2da0a6e672ab36cf231b6c5cb6e62a5fde17b445c4cf3e4f48fb49da87421ff89472b7237148ac40194328ed29afe8695b26c7d3faa0716879b7fd373e099a6d2fbcd87847ee8e199ba2b09861a147509c06cb37b68284435263fd4975057ab5535e8d82da7d48ab88e1485f524e51b4a2554e3a03ed90377175b7e866474b04f086a6b39a9d57fadc17dbe141d9bdb13611eef6023af4b20dbf5bc328049c8f55537bb48af776c1270c034393022795ce9bba5911ccd9c71d4cba6b49fd90eca9ea670571fba987f1f95c5757ad5d5f2c0f2d5e35001af7e6b8aa928227a62c7c60f185aca0daf9648f2d855fa99858c15747e2f443c01244da6226b30640dfc47cdfb77cba60d1e1297765fc28ff16f650e0f47535f40c3d5844fcb64e5dae83b9f337749ff0a2a9abfd22ed84266ca264b8f77fc0b983529dec4038382bbbb236a9d85f471affe9e34135d6a9fb406b886b152933728716f1893a8b52916c8a01dddcef6e2996ae4f1379c48994b9ec412deb7c39d6e284144aebcb0f89f6b180ef50c83dd49d8a5a084fa64d3f5b6d5799ac02263a39013c944ebe7b904255a50cf4774b20c0946a107bd3f3707b87efb9297d09c55c753dee6583fb2fb67cbe8ece862a073da261326064d908051da2fee27a1d37eac7e4ca60f8945c8a89150a42689764fb5a23037e405258e1ba6dcf4889a098bcbcab79933ca81d35c698a88f417f504dc817ce39f331fdf538153e93e3a0d3faac3e184b526e0a005d1de1ef5a015458119deb8e6d8062cf05fda7775022120e7c159c666ae2505132d0c81ab115efc96a636acb56ea2142a13f0cc55d36dab98deaeab9d9e31959c574c79f9d037820e1ebe24728abb99de5ef43c00d8237c103e2adf650de91f5ff714e12f06da18847a441382ef562b34ae30ea5918841faf8e63ce87c4a9eaca100eb736bfc4ea8edac5922321677f6cff229c068a8ffaff751157e3a7f0c0ce60b75d2e0c3b15790edac0d52116fed131c65ec3db9a14ddfa5b0245b687b669364812aa1ca4b3b5c230a2ab419b87be9668a17807f930a4b6b46133890d845e05a40089858f7619bbbc8d123c5c22eb9cf9a15d87d5ad73a957f3ee60b501f37f9e778b76ee1c38c9a0403dcc85954c755443bef3cf3b18aca868da6885410603b49b7caf3b9d02646faffeeea0040defa4ef98f77cb543fbfecbc7d4e9da1c8c86219eef84c4cae2264e341e1500a703d69b169402ba3111e48338f2775ffa53877d4105aef34adc681bb73cc3310b536947029c6152ec85d7b5b6ef1a6f1f2e30452f6c9d3acad8e66e77259da7e32b330ff972a0345fe93a89c7f8cc915ae7cdabb2580a150c4d263775f7195d4a7ec99c19c61bebc8b25b12142eaac371441b47583ef35ce782be2d3fa37d8d1bd0e0a6364bc69fbd6eb62904515755259c7b5b4e1d2ba7958c282c763c25df5dbc5054c4cca364090222457002f93cc86ab46e80a034d508daa4cbab77d2eb5a945a85f6d12357c78b08657a2d3b838ea6788fc9338f4c3b1bda94404eb3e4e8133354eaadffbbe546c9483719afcf0b66ed1a1a6ab042a02b44e5b5f45add0c423ff26d91fd62f73e2fa08a36ab069e327cf08edb577caaa1c542da9b7469d3feabcb7aa64b7d02c178ab7c02c19399e0125ba72b8446af7f4a480027dd7d8c0ea6688c7ed2fda9b5fb0a88914ebec1f777c45da1b49f3fae3f6893eeb363a37a6979d824f48ea41150915d88e27877602b0a126ba0fa4ff74c0b7f13f9b34f9f0c314e209a60eaf61aceba28f91986204358027a89873ccd42f51197a3c6517d156caa080c891653a8d0dcef450075d40a274e7bf72085a4cafbd4bda01d395c276ee1cec3604167f739ec2ac1c2e92a5079fbb7507bd8405168888f1a128f6b66adfed41f9a4057067750f1d10e53dfca9a9621d3a3558ad9591f534f13b081b28a704f8266103cd1212f772bd06b25831891399fb627436947dbe94590c484e080cc655c1611777a6cce43bbae418eec920d0be12c5f90aa3c08b6a7ca766fa17c93aeeb5a277ce25e855d9cc5e5adbe023382bc840ffeab2a08fb2e4286d9126fefbf8c90efcf16f1696f9cf2d8601ebc558f2d2a4311befdb493f00dc504dc680fb974cb7efb3c59c2e027684a3a741f99daf1f5a36377c08d9e6d6f709e6787c011090dde1d8582a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
