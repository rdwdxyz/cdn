<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2367188f675ed4649821854cb8058ee291504113b6d0016fd0aa439b2f2f1dae6cd37a56ddf07c5be7edbc301b678bc33cdcb7f59fc63887e6357f44db0d468d401752e92ada8ded65aa4074ae4bac8a011e76dfa6214a3f9fe7b1853a080440e81ff3818c200037ada234daa74aa8ea10d1cd117d68e6470be799985ae85db4c6938521faf85ac8174e161c8aa1854ac31eb2000b3a4a4621e11041ede71afd58a5a36cc165f8dfa5dd38cb6c90d8ed0ddd9e8b4e3aeb38fb5edc1f399f186ddce1a464e1539ba2553b47e04c1da74dd1924c867f0674cf41beee06d987f6245b69688363681ff50328b36710b494ec907c7891c08c797847510f5c45031fc818fb28f155eaeb5fe08de9d60fe5243ad791b53a0d807dff0ca763f48a1e9f100c76603b648ff7209e61e7441c8fa34003c6f329553262a248005ef8a9e2de45cf355ec9324e939cb67aa55687fcaecc549da3bdc7e1103590cbf890b12c3d9c8d1423d76779aee4e6f8260e18481615eafd897f072310fc78d058bb52e3d02908453490f9621a32e6bc56e541551345567ec7d4d7046d7c6ccaed9adb7b3b793609cd7c28787ed50b03c81d425a8bb1e7f023c86a3f0cf3fecd80e4c9b307767023eb9036cb3323401b7bbe7ac1e39089958859c54ddc651542b641e157633d34915468f3c6ead3b9fe4ec3c6234beb06ce70c2b59ac484117f1960a104e56b29b45ae52bcea3ba39fa6ce617a23a6f4a32ca086f2bb3a44aecf5f285109a4870d78d1cdc38af07891df8453360d4fdabaf5fe1de082eee7ac4855cfafcdb0070f11c8605eaeef21b3b2c3ff19001602f8a71a1174eb839740835fb0d369e437bddcac5acb54ec0e6e03e66e70b3094b05204e79948da1681e15e3ea4d2230e08790fd33c9e45091de5ba6791dc294b9fe3b6241dde6ec0222f1acc0e58dea790895ca6ebaf63023ab784df72617f572e7a57b8cd972f3c96be219a7a78635bd54dddfe37037ae21818d843ec52c7b43f5487fb8b699aeac1b2fb77829537eaf7774f61c2659dc2d14c421f514993dc5a6453d1321ffd9bda0133df1f62f290fa35119c6535bb7cc0f971137b184634f7a7f19b493114829474f8cdbf4b7c42e290637bc713479f2c909712637643b8ea12d33c37cfb97cc81932b61ca23a7e13e4fcdf2ecc6f9fc00ba576af4cb24ec9fc5ebe135a1023f5d379db192e9e3b42af1b99cd19612bae38d6cfe84cb0dcd0613094df938f6f814055085ee066f1e4dc0248739c03fdb2e41ea254b768846ac676b7fe1a166ebe3719dca451c91890cb89a0067c8dde8016277a8f188f8f2981348590e1e21738d2d2488f104be4a4ec1347d2d45391cd8c81cc06c736a432f941d964b2c854da51af95918afe7d9312d6a9417e106ebdb12156757fb3b9bd140baf33f8763b840079d769d1f3e7ccadfca97e897927b27c7a8e75f0c7f39cfd7f288add77f4020f6d21c36ccaea601d56edee61a5ddacf13f9d3a4804e7d9381b7b41ac0a5249feee915e85679351f5261e533703d619569f63970178c5a131d88c3b557c67cc0de9853ba63bcad4d4c3456ffbef9e08c07960286ab394582ee479bcc0f7fcfe392c435361aa22dfa538e3db05c75c033dd546e47e1dfca517578c3fc18c941dab37cce172ccbf3ede8f6d5ffaf941547efe2305cd6ba455f5842e2ffc44f645bab287e4744a539d9a518184463b7d994e88b3ff161a9cfa042648ae70632869053ff263c61f243414ead73534566804d9efc30754012fc70b2eab3f31fe6404952fa0165c7c0eef02e24452c633df244dec08edd259c73e0948bd9ac7d810510bf4d5f4ce28b6c2b0eacd3325455d78f396cdc136e7a4b3a9a3c27af4fc6f5559239e3b614fc125ed540df8ee406f6f9c744e420f57b02633e3244af1490e9086bd597c5e00b924542ff22e8d0e9786fa108bc53919a7fc6ffeb948d38998bd6fdd728364a08a2845352bc4723847bfad27e4dce620e4a5c50f9aa39f6f63a06ef8f3bf4b8e8747576346ae55d25ea67de0fa0b327bbbc1019a54bc6afaa36e9403fe9ff61b376a3e738ddb50c6d7e26c4f689859f79b39035b879e8a04f595d7a6721c29512d831598c18690dedbe3d2628879720b11881aa52231fab5718ce85f230979483f6b80e23206e1855f870349cb1cd35df65b89742e348deaaa275ef807d9c3c977ea5403c549a416af4ab01828bfa486a95f87c2a1a8212ea930aa339505428e79dec745b07819b77caec0f3346e9288dde085237c179daeec4ace4589a4b4f3097a8c2fc5b13ed528ce6cca3235b949f70c9e8961e509c2dbdb55aad50064c6e2d96d3e3243782eb513f81cb33aeee0c09299370d3af841c0f61f1566dae2da02596b91b9b907555c3d8711c525023e9f67e487f3bf22f27bf1320c255b2565986df7a3df6386b26b16c274277cf87a0bb001599382e0b1695f7899605334b3c93abb6e64fce50f9f55d9c4add34aa1ca0661262a2addafc087db5fd30f147322d49562b61a56e25039a3d7a93eb8aff6834cf39fb5111152fe81d42c7bf44695e9f45748fb9ab75b870ef4f9fa2f9005bbd71138b5e5cfaa71f3ca059cec9927b416263add54db2d744516ddd2552e25839eb091becf046c447c837ff0eb912c33cfb1b133ec6312218ea562578ccd5fb85c7405e375c20fa2e1894ba3dfbc0b329bce1767113a53dd4fdc0886e9ea5f25df4c2ba489992064e6be5e1b9b0876c5ef199ce5e5c21a9d24bfca4ee86d9bf5cd4aab43ec976fa1a8d8ee2cfb46a16a59c7fe46d2702baf358f9a6f108d813dbf0a958948f469fed51889d29fddd611061e89c21a2146814fc07ce4c51a84f702d657cf50ea145ee686585d946e373116478fd3908a3872bba4da1a6fa7c75db01a01a90fb0180a2774aa8b45d0b9a5f3e14cf9ad604f9bee03901712d414db580e8169baacb236ace5cf0da9426eb12d9c5c17abba8dad86ff8f242796c44866a3488ba8f5d9a458bc81b9e2c8b458198e59fe1038864ad29ce7a3e3f6b68427c63ae8cbf942d226c77ac787e19c8fba5cebbdc8090d02857e1a2caf588fd59beccb7b82229f1f2c870f0ed3f4f1c026e814574700ebeb8bf42cadc821e05bf0b5fb0fd19b2c3f02f7662cd24a481f911c2402e1b7d5336a24d90f547218f48c868353988cc4bed19d5926c6e220a90ed977e3d2f7a9620a620a1f580da166e78e9b6ab254446fc42e6f0178b20991adf4be1e7f8e264edefade7a45fd874712fe4f52e6932b1fdffd7d55e345959c78937ecf43f4266109fae2631b13ea21def428e266c41cbab26b5fcbdea757523c317d2a20a8452460482ffc5524a7f4372361aeb60f726c46a7d01f970b42b5ede48a4f26ee3e6b3cb72ec43a61315e85bf21929cb1f754d949245fc09f36cbab1e7d9c86e3543b22b63bedba48d6c09253160638991cb7cebfb9f491943f2da042fdbd4d03e87f6e35aebb7c8f8b156f23a5215c845d3db4a2ccd3e243b0f08bf8ff8e7b2e09eef83d878e18ebb683a0e0d6fb63e5d5486a84a8f9c446eed2fec9b027872d8a546db7b374941c2aedfbac5bfbf0b204c0f5f0c60c41e0652f762a9b053e90d37dd612a5e9ca72704498206f18dd69a38e675f7e806e32b754154d833b7bdb09b10dd984c0032a8cb97b9373cd0433be0ba237da74ab665ad85648d172c120745bdad88fa008aa37325f73d085e7f0ecad4d6fa25e60cb662d947c35def69b17abf5f723a726ab5feb5e651bcb9d1f3ab7c784698ece1bc2cba4f68b3d58b20a74f936759f2afe23d591429497f235f7d9f0f00cc3917ccb048dbe9eafec10670b9435a1da51b0897197c21204925347cb3f09843997cebcb427ba5b7b2c54d86f9fdd7cf17613d000bfaf61d0aafd3be9413ecb22cc8c32818086df0a0f0bae43676c4743c6dec3b7098c6a92cf0a3028781e85bb75244a0f8e8d70ca2048ac32bb02ef101a1191a7163968f83e17826589e6a66280ca27994b3aa54635c05fae25cfccfb98a89fe8e3b078a5767c343985086c69ad2d16901c12d1268461597961e8c498b7e2287a87cd4f8965c532d8fbca77b98fc7d5d35ca9810ff5bdd0ad54a76b475fab84686efcdbc5c5a9ec8e33c3ebc96d784527223b7ea8e139884cb58b5223889edb01778aaed17eac42caebdb7ad93a96328a31bab87a332f5f26c860ae2b9058f718219ce6a890230e488ac34262b4741f85fe10d1c53ec324942e3cea3144468a618a3a1566caca3f3df54abd736ed8cd7fa61e65e68e73a3fe491a3b90cb25d60af1e5f3cfadf4db2b96d3956a3ca73a30c8225abb46d8e408898457b755c1ea3617cab98034de327e5b26d114a0dc8224d38edc0adc62dd41ff6fda0422271c7c32805a4df818ae9868e70d9cf41e1cde1243b1d9f7d8867fdec2e4d6245b8787fc2ebc6a68bba099c06c83e2172f40f2663e6c95d03d035f140a5e6dbe04d872cd83fb01f982c2213ea6cf0b05f10b5f15f7c2c63de847be69e0f0d94f145b95c7eb824e4b02f82249a922e0aebf24199e45dc3ac7664f386034c50b7fbb55659123d9901e37f17b04f2f9812a1f5f90d83e8f8c8c59f1c941104063c42d867f06bab0c935a49c7b150f7632fac7b6e3a915b764a5fc0d2ec63cc828ac3427b78322f977a6594e3102322c826686f43276a8ad192837c3ebd2bbe151adbd4effac1136e9ae4bd16b1487dbcf9bc8eafb0999b3dcc07660857936d810494165f769d184f91373c985aaf93c867b58145e2d94e601e9a2e2f56f6ab9397c4d9390ff1d9c445463223c3565c1590934cc97847903da50edc629ee5b4f44444264eb079c316303e51e6d797edd3abcda461c98a395e098973ae7fe91ebf0ec630ba55225a6b678d3dbc0106afdf84c1303e3a35aebd494fac0d0ed23aad87cb62aae6c337a692a9dec30083423b42121b0b9b035ef496a1364f11c804c06daa3614f4f41b4183a8e13bb2c8d4a27a3dd67a005dcacade573042f27c930e8658a8af30d14a4df9cc645b2fb9954444e2358605096541b8644d68041896d35a88f9e7f87ebe445157af1d0f548f665543cb6684c4a5085ee7b8a4f84e73fa9e393c6b55a8256d47adcca6fa77f905ed769351bcf4120c32cddf9446122c6631d8095285e979aa99c5457ded78ffd9d0315a0701ae8b121ad06901805b6ab924fcd793862a53a75e15ca77c306e6320c9b754ced360deb4001f0ca9c6135e65da691fbd86955c0b5bd2d51729b7aa88d2f0b5597a0a60d85944004af82a595f2a5f445cadb88930a98945a3f90e1c369824ae21baad10f987e1c419f4c6a87ada98750b9c221afbee5edf5c271a3c7b633d95f8e868acae2ae0e428061f8dd51250d89cd7a72305c3106d058338111cf7bd831cbb1b9d3bf2eb1518ad7c10fb99c06ed2cf143e5697d5bab8c41e3576a6122fa0fb38254286a7693515c537303afebacd045f73f418392a717cc1b2fc669a03109bd401c6811281aeeef40ff5cc6251c0629a9e3abbd9357e268333a4e33230eb80f7ca3de3323b816b2b0bbcbfc9ad04bc0f678a3fbeced98dc32958102e2b84301636671310149c85fedb8ff54ec9d8f27b66a53eb11c20b2f93ab63d77d315928e0262ebc9ae84e88a55a241dcf5430bf6a4f35a4a1a79518ed1f2ef3f9b307d589580feee2674f051b1def369c15228886fc40cf6db0f00889f740fba7b0a688367e41bc2fe6b1046f05b98123c931adbeed664448a0518bd17d8d0a99a5fd3d5b7f56697ef5b1890227a3e33ac8ad373592e9c5922d3aff8b1dcdb7cece182c71339202981eef3963e12229c7300a2a8623659e56c745320c88b9a3f55fac6f5e3dac3087911243168fcd91097ad3045dda614dfe9a803f269d88688d2d50835e8320593f1e2a84cc7b9e13434cfcd39db38b0e106b51efd97782d4fa89446694ae6472d80e37a767b1aa45742303fd11261f7f9d02da17517ed008637d25df91951bf8757abdb2322ec08d7de9a33bc797b29aa02e2a7ee82ee63c19414035096db34508ce304c948525497322f3d158f345fe6f045cbcc655c3f5d941c2893e18d037ea2a68143a9c8f256610912a9ccc7cfe5f5a9eeaaad147ef1ef6b3c94cc8f0a9285a997396b07d3261a1935b172c59b9888e2d780978c2a79111cd6a6e396b2bc1d4dd6ce77484b2ed0a62024f723b27ffb4748e8462bc820b81f3e314da741938262bb8d1ed537d391b55740f7fdb82385666166b0cf51f50d49bb05901e168e47ce4c3f2547dd96722adbed35221f0bbcf24a6dd9e11dcedddcef1a70b8e6d2af0f8e5f68277e6fc4bf5d97b6f495a6fe843a2802aaa88a3edde05a2cc9fdf21b3957c9a696e9cf9ee100dacafdf7d9bda47c8e5acb51932f9df66282f936d434d606e5b1fec07267f32922216fc42b0767379de2e682823768b522c0c21a4bc4894fbd90e141440b9eb6cb07986f9b3dcdc9a41b2b874d448565a03a83ab6e98216fc770b2db1b3d268c745459635fc33a97f86fe0aefcb5d5e2d26f9b380fbaccf338d8a3f3d5940fb76909757fe4d69c5e4102904a24fec07ec1558ce465c4f71701b989a1a54e9f10be2f2205ad5330bc98a98ad8be8cf26cf3215fccd9cf24c4a8db49977e3e6cf054fc5234aec18c2194bcb771281c8216df2896c2af8520d2c5f4599acf6c781d0f58cd497b4c3fb583ed3c2c8c052c9a16574327edc02040e509a6f4cf0972221df1a62893b752569b09cf6caa97a89b8e4efc7b9b38e91f4ddbccde4d953a15bb475336c2a05db9543843b898df4fc25af62743f61ac5e911b955dab43c243083097845acb275b44daf593c285e68cc7d243263fbf11ff0a944ad7bfe61420c3ec5be49a3bb0a00a0015c925b0255b1ca83b787a8a781b1ac3bbf1b5aece07ff25d0595ef95e328a352c8ba43a7d1deff5e1d0a7c4f561ddf4d3c73eeab7898ecfe8a18b31c33993bf0d951ca2530583293ebe98d41ba1a7e577e0489f96c79c0234d7fa207f65184b032e86fbe8b2d48b9d0ee47b65549b3078b00c1a3517773d17b430fa34f190f84e1f650885727d373164920cb7bb84ba10257658a174ec14a191c673b6e02a78ab5b7db3aa68eeb834ec9b73a5c285d6160cb84da8cda7d464120957662b2dd180ecaec0065e5b34ba895b96ce45c13da0a882dd02bdc724e6afd61552368c1f44d323762eec6577d7196afd772d24ddb27a279cfd49b2a5c02792f29670642f45f4821387dac326ad486866182472f598c791796169d0a889eef96921e59465680a069edc0fb7b5b37c0c57b8ac2c737ad99a4725b5095e5d5bcee7cd5db71619abf4650746c6e36066e83b7e32c5b956061861fbe8e5c7743eea1a90df3d4655f1cb41e7eee152fc9537f9d455410b64302b8bc235f1f533bd5a0bd739b36c1677c8194bbd9e5a3f6afac833548cb3a4dca6204e4a744fc3df712a0fab8797426d536f4cfe0bb89fba0df58db418b2ed62c342a6a521d04d411274882f9732149d869c2f21d0f584bdda6692654f8f8339a57be69b394184975d90ddef07bdaa2aeab730585baad564388fd291e6befe85978688d98914455801c6a4f36f04011295d6206f32da79c8c7cbc3ca731f409e5f6e222b3ed1e5e5ac858547aec45b53469ff936210a2f0061e10f95511282009f86eabe2dd4ea59a301e5cf631f5a2b740ba4b4786696726e16d5e604ced7145e746806daccb0131c891710e17fe2615e1382f6fc6876c78917bb2266780991ba7333b8134d848c4288f408902aa5539abb0de2b34a47d625dd4e0573ee0801ab49b9bf605367b80e872cd00d4a85bfb6cbcb989d72e39da8f65adaa7d92fed72ae015809e20b13a49a5d7d769efd4c0e5965ef7e188bab5784c5545d9568d5a3e41169c688f5e949b1926427cfe4492a9239ac24785794ca49f5b2ead9d83c6b9e8a28d0ba9c43d92c97a4440cf3fe6d3c5b07b0f7ada6b48f3595e1d2a449c2010b57111f13133eddeb1ec534d2313e3025d04dd356786797948597e63fa463b33e5b283768d814a43c2bb1c9a8167502ddbbcc7942aa87161cdcf00f34fe489a71921d567994d9c2049da28c17b21ddc213fedc7c24a0f0bab4dbe24d4fb61356670195affa86b4ccf8e7cdfe1257be28752476bcb4f06b44e879e5090f886abf50f1d9b241eed9d37c951ee701e61f5d72b08ff0b61881dced3aa4583d09b1db0a392de1ff27d61accf6c1d06f7b5bdd99f5f4456bdff9fadfcad82731fad11c7b41fdc39f705ce97aa7e40b6b12678a3dcd32a35bc919b038ab515c476b8fd1f6af90575296e46244baf36919d97cdd2dc0cb71a708b810d16e0196c3bce3ebb587e51042922a69b2305780ccdbbeebc8306dca8b2f0950652b1c55e273ee159d3150a92319f0da47440d743488e47d91f59ec1894272646702a4f13b8c7053e4be0adfce0acd808f921a39467ecb254021384a88ed79563f52901c4165ad489b60da32cb12edbeb47ee713749b16103f982b6bd22cfaec2e08275ccebb3483acfae10f23c81f97a9ddb801d06e2806ec6937db403d45a8bbc28d30f583b74f3f3d7b2c087eaf876dea605b596fdab5912166ca3872c3b768a6253edb761aeec627faf35bac5b175262bc73b38382ee583b0b0655f09bf2d67ae4733570bb09415a116e58fba2bca86438d6a00d36db5206c7751605d783d3055358f356d6f2b8241757f6081cf22b67f2c930919b53d38e869a4c7147714c3af3281f85d5257247d3ae84f8b5dc970ecbd912aa56bb8cfda38681beb5c62819326cd7fedb6c797da70965217bf2114bbae4154bc373e1b00d46f7751f55eb0933dccb1e52d66bf609385308a43e24e286580a52fbd56800dfb72fd4b0cd2e876a83ba47633ddc532c8de40bb29d3edbdbf7d14f86aae1bc93b24ff175f9ddccfabe68fd7cb0aa6eb5af1ea93f3a58b51d1faed325044de7d2d9655df56a683eaf5923bc22d84a5c4aefe4b468733837e2d3627131a1a891a7ea1986db65bd409c303e30926bc296adf0ee88c14b9c09c51eec8811029a7e58c76501fee31cb94cce515a95dc96036db33156547e70a8d2590bc094c3c457bca74df7a908844eb5ca070e731194c267bd34f2cc69ba5a6ee0f44320209dc2bd9d0f173bdce1488c5a46a04feb77b12b7d6936b4116d5da99d3408dbbd1e3a92f6cd42fe973108bd4b94efd5a2e9f25da002aa2d96ee7366de9d6cb22eaea6cefce81795d827a9a408b79f9bedbc2544ad5e9b9364e03246ee4f8ee48e3ee2d70bb43b6967592874ef29b427eb71bc1f852eaa5de12f74aa34664010d7e2f814e34f7dd847e0430af53adbf4ab4c4e93dd5f5cbedd8002a3f220f7d13432a01d8b2bc7db51453ae38815dfcbf6ad53a90de70f2a789747a6d4a2c1839f673ef50d2e1d11e6a94b30692cb073aabf12986ee29bc847f4c94f15fc85501f6c619fd44f9c24bfe606f827df3b1de5a622c3559ef3603d23db54bd545077040eae0d4afbf6c490173235363a08fa284bbc9675921d1ae29ec3f94c51fc2a99dd6b07b13109fab386730d5a43b3b277980a15e8b47404e0102a2484952401e04e6b50bddafa53690f6988b5215963db0d6847ce0d0ba616b9742270b59d6c8a717be886899617a6865c31c9953b78d13c9eb150304204e5f62a0bd271203fbca917c4fe8a2c53f05cc468011abfe25e49edd812e127b4f9870a5996692a3b343d6ea4ab2882b0db9536537365e2c26815fd9f293605cf9b412c56ddd993966850ae52ebd50644914e861508703523598663fc88afc35b7527ef7b3af3e3440d054a3810cff23ad006d915d570412a8ee138eb8c59f13c8a9e41552665b594e40d98f707a527de6b402964dbb6af7df761fa0b0fa64bf329002f76186a20730947ea7b706bf863e6198e754694e397d367e11d60a9b0f81aaa1ac2e1b6fd422fd7ec72f695a99043214f9f5a94193cef53613369f0b4dc30da61c8435cc8520d9f9b22c363a711c4b0e36c51d05220d70953eb8daa1bf9cc24635eee31000f5d68a1652f92889b3bab854cb9f3de9d2eeb3ed298578be79f3b5553a58e7c22ff3fc6bf3a4647cca95817d5cf0886c26ec42b86e2087be55c4d989625e37bfa4572b6328f264de27a399b4c9f6571dba8afcec2dbe8b12c36e7b10068d297c8fbf0e8c774450cad2b856d9e56f5891445ce07e9f1a54d5778f68be7d90af221da543fc0038305145d08195247a11ab894f6f78cc79396a5365b4be893af2b3425d1dd289c9dae6241760d27c003e7f8767f8ab8783c6020a20c19e51727c222ac54602aee99d770b50b30fa842cffa3ad268959300b322e4960313db8aaecd70a55d20ebf8e70edd87decf0ecf48f44b9399582a622f72cf93ea815e67d05b4d3dd1469808afccc0a6481ed4f87543e6099e515f9d2858062cabae6b0f77d2b143fdb2db4721d8624d9be914a8e24da51af9d824d5d0d68b11e566ee25364236034e48a5e0593d324c1a37d50ce613a139418e134397d6c1b9b092857164cc47cbd5126fc2b6f9cee86aa49a784e3dcb40215d14f3aacb418950b5524cdda3a3a0a3a3fd00514d4f3d0aa3ca115891d0f2c84ccf5c1133e3fd3436b5230430b334c12f593505909536981421ab8735a66d84102831b1864c5b15503a699d1f6f5b092f55d0048e085a2a4a436dff555083929367658da0930eddd69c56c3a0b7cf5df5a6ba21e33396c6752c06a21bd25478352d385822b5166ab05af37eedb8f6170c27e54af7e5bc13cc104507630c03b6f6ed215b21bd2223ea5659f7e42b86416a53cd94bf491f3360830ca5fd8fabd94c4ffb952b63727f8e07361c3a7199d4341c12df348571bc928ca84434b76011bfdb656441d7c36604382508022720c1fd1c83ad6b530a94b6b4546b76a7f20fdf0d263409c94dc13e592b8be681373847d54e1b6808cb76f510f6efb5cd8c62d724ce3146a5f854cc3e671d07fe6ba30b37010d18041590ed7a2c2de5bd1f3075b3ec3da782831532f7e85b34342c152ca6fe85a20934e5ed355cd9e57ec020e1324162397a44fc96bc714801bd615eb09a73c2d2209157ce6f666abf85dabb168db8f09c98b28953b96df97faa91702b5e7e242ea10813df81e95519fb0731fe75aa8afde331de154762dec28c99815f893f3946d479552482b4b741d20da6bb4ca719445d3a3895953f7888bb5ce5cfd69d00075a016d453496ee75aa83c32c1097a63d301aaf97600755bf0120731c51433d918d46c0558b027d49b92bc4126d10ebde8c95fc96cb79f28309af43ee7699512b2fc3ecda1613c5ab4c5ecf1e1e6e40bc7041602f47de096e46b746a44ea948fd57492b36bcc2eac09f82b2f0ce807e172cc1a6a5b203b3fd048c1f9e60fb96aa56308c3859bdd7b3e416278a1c39283353c30e48be84b8fb23dc2dfda10a405bcddf9b793bce24e7ce41e884827a9b4bb4dc6bc592f8393fe39ca534bc1b37a9e89ad51280f9f84ea0b15bf467034b8a889ee58cdcbe3704b4928adad048ee76c8318284a844e1a7b7d79542c3828807bc726102957ed5b1d0b0aaab9ec0a803774b379364c2f8e734608891c1e3801e24ad37d761b6630cc43e97526ba7827c12e3c81f8164ad85ef07d14477395f3ffb27913d6d4169ee35149dd2de42a264d73c32b8ef695be2d222b6de9ede13ea51ed4bf5d5ee6b3d3502829db357664b75f8d3d852566942ca0960b3059cc120165be0c11767a9dae7573637d4deaecf893668d9a6851946cca9bb879abeba558b9650e70b7ceb2bcc086b6b0891707b036b218bbc254486a04c2679ef041b49ecddef9b51018864b0b1760dfe979897de2463504012bc9f4a2a72ccf7895af2357aacb55f54360dc1f1a9852e331829dc20dc2c32971b8049b645866ef1e2db20711e9c23b044fb42b534863d1342893018184930a0ebd65c06c878166989f4ba14f06d081eb5d2dc917bc885c9d1922d7a1ba6f7385e348e41f83a35043216e0e869c81f2ae5aa690833467f4280e802732fe62a599f85aebf473b9b751963b5005a3af7c489b24a064f20cc279998f609a87bc3f65a1bd86c2321be9b2e1a7a35d8e290426e4a1b38ec758348f7de45881e58bd296f069db66b856a7e575db4c986276561679d54a7dae8fed10d1a4c56ab207d4bc9dceb89034278434d4584ddefb50cb0715298d66ecac3001e77fc943074898fa9fd2c0fd014636b5335aa6bd57e58036a67d894b1dd463fe5d2b3796bb57def76c2ba72486b5d4a1e0fdb9b0106f4f34c87e78b43da583bce0dd88193a721575b4600658ca744a3cb6930aa03bfa5009ada7f0f84ab10e2580c6738082cc7eb0525d67b387e62daeecf9675c558b5c042714595f0d8bf45333ac0849b35853624b204f630f9333fb69360f6e0fe14d68897856967895338e090665073b29451cf83f70e4ecd93f82d2a595cbc2a10d6299c6527e76935834025a92cd26b12c32a0b4981b16f59fc84656cd1f1bae0f2de473f239391a7a52a364aed05af6db3aa5b9d07bb570c3ca74c667396ec0b18722898c0e78c934180592747fd77dcfd70804e530148889bd4f03d5779ebd62a6e0b3ef4c4bd33732e8f1cfc0e54467a8b9a1a43227bc93685ca2f363f6e35395eb5d1ac79257b88af8c8d59342f24176b1b651ea554c17e98cd1d753080327e5264eb680040d8a9e26c82bafd235ff69e45f01ecf7bc5e3857db6af729551f5bf4167a0827751c0dfb6012a01172aa52c12ae484f116e2398fa92baa6828f200c8c5aae44603a95284d95bdb6d725cdf519daf3421d190f428abd7bd0a2feb09cc1729dd96ea5815b4be08922b1ea3fcb0e306ff699e56b768699c2409240acc062211c3b733927431fb9bfd56bbc29a7fb32bb12c955705ed944df7014d7b90e51cd457f0c732c9691159aeef2217e387cb6f57afa5392b9186d88988c8a549a199db6e6332862f019f6427dfaeba8d7bb987ae6d8a0e09d4b8571c1356f813f436ccdcde085c9520da7a7786f5ddc7bc969347083fef25893170f763b7152286e413ebb73fc69b94ea34ed0242ff99f2a0db310a11640e44e54775ca22b18cdc2bd4d6deaf7fb85985defc157ffe1d4d447d9bee466b13843dd38340494c28c98fb4f66d99c157570eb1ccc9655379918130954398c9974154af15a9c20ee9e7d6d65c3fe1a4c61d95e064d396e43da8be851710ed6c106362536e132598fbf3f74211112f83bedac163a396f213c0746cac706839ff6e64ffc68a6c661c740f0439bb807c0d5c3232f526d67623f95561fab29e950a6e9505fee4c7dc694ee6b5020b79364309f00523fe7234b4f0750128d831197ff16e499135d4b19df203bf66dc2638d50051fd45609adedeb146ae67cec540b8c9c7d31dce159abfa0649313ef4d462e15faa6b5f4d82f0868b2dfb2010a1169847a30dcb3047b5b0bd9cedd6ff63d1b62d59d6c62a037a4837485427324b08df02448ad74ec221da33cf19b803f74efd5aa2f7a543bef5214164ba4904a2b95864a3dbf90fe231d51e8a0a2077d4d211409232319001ae90d977804b9a8e301d1e7d84c65bab46726e9cb205ba5e1bdb1625a8b9a360d86fcd735050c93c8564add13efc5ede9ffa918ce969e7ca15265f59083d6dbe212af740c44b69eac0e2766db41e6cec64133e9fb564d0a8cef93e05338a0eb9abfdee022e5133081cb58fb431de4c517bf0e1218937e32383a98bee976708dd18336e8d1222b9c336cd355fe0384d038784b41b0207d0d24fdc53f5e0e61349b924630e9c8dc459c26391ea176e94174a3cd3ee6375bb17d8a2994fe5896f44746955fa402362a5c99c3dbce1f516002333625d4072a7240198ae6b89af50835cfb4776c1adcae3ecafb22fc97e50a91f993923573f5d3e9553d5cec01fd8426434e21911b5d63dcf05c47cc48e0956b1505e32dc4ffa2e7abffe706cd872cf3a9b393e2372f6353c879f9160da5513f550e10d4794dd3cacb3eeda66d082eac22dc922cff485792df459dbe36826b31e33e4015410181973a2f1dba70a32686f7658ac9128005beb352d1e5a1f6fab2250af8f1bba536327b5829b7abd5949cd320c3391d38cb7d86173810d9d0baf0e11429b072f39bf43def0c47d253ad7a5e434ac7f312bbf297e5eb1f9643324570ac483801c3862d18585f1784e679923506925395d99cb89477e0d08e0960e8ae7194f777991f4d0d834a5fa0a919a906b4a76a8bb860dd49c32d448694150905516b6c0f2bb797a8ae047c2bcf9cdf319e214eb9fc36de183076008daee2d73eb2a8040460bc4ba297032099e4b0b8d3558f52ea366c0b4d821b726ae48fe010f8e1aedb8f6ef7491896e26a1eb2b3c8e1a6e3d5509b373bc98dc7d6575478b24dbdd5101671c7b0782166537013cd1b1f8dee942aacec3013d5fbb96b677bf5d9c9defa4271a4acbfc0964f48049dc648ea49e0614bc7dffc972eb0d99f1c9fbd8e85dc3f296e497e041e165bd950ce9591e75cbf54780b7bb742d1a7287e78606ec04c0a688c681d135c65b889de93bc282a5face4bdab7e84aaba6cd2c639201fd7fbf287615973fe97db1492d2890ff48365b041b540ebfde7ddf618119d43b6e68a8bcac2eec975af7f8d20c9b468d2f51a7c90e5cbde0008853ec15e7b514a743b6685f58f4a3bd090a1b4c174dfeed6ac0ecd989460cb2450eae454915120ef878c93ce270d3c34bed802ef5062c7c963ece1916e42d9ccfd71f80e5fde5b7f234f48cd3e960bf3414552f9a211155ff2dd52d8e9a56489fa1d0133dc7e5474ea6053eb8884c37954b8f51b8bbe2ce5ad0668084a9a421d06d42df6319970d72c732c20fdaa10d4b30e4dbf7994a20562ee47df7e0415feb6f583c8a593be949e05d63da976fe5e5bb49ff0c2eb189f5f7472e816b3f27b4d3afb3e4920123ed9a52eb62f42d7cfa37112e6f5e6cb0df637694e12167492756543d84a038fc5ca15ccf6f963c079a9167a64bc4d6fbb0b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
