<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1bdb4b69b44231166d802dc5e02c7becb7b57b623e228249807bad3fd8611b18971379d8fdbbaec420cfb557d57c59241fdabcd5a7c6f4018c9f2173e93748e21170f58e66783eaf8edd6184929604b915cf1651f6057f1d76cdbf3ff118640f3b195a7622abe2ce9e39068b597511290c4e832047b9f203a169070cbcc353e860194a65e7af451a558961f8595d09dc9eccbd67a34221128002f04a720f57568f85b42709dec4dceba089852b915a1acc4dd6a65b25a1abe548f69bb290486a65e006e82d572b74e119e3542a634980b6cff7f4f1467eefadd02c102dc46b84464b1c47a4b3f54276d51ac1188d73a7c652293996f4df9c4caf78a36710c2e5c9642fb91caf3e9b7696486380d036a7c118742f108ec6dc29500416336a92aee4322a5504cc137dca14f61c4307815d00d4bf8c2c8b28018c08289883523fa62126a106c202ac63aab40deec4dcc74f4b8016b308a0408b8bb6b0eb1205c8d7213e1d13afa88d699370da378b6702627880c0d751b68171489f7f2429a7f791e9769ccb0c672d8cd91ebf2890e09470b841d805b5644ab8d61723819a4bf891c8b92624fae03038d7854489ba4ca599baa7fdea73e220e1fdd7859168e6d094d051cbd7d6266983fa2c150908b4c801090f9f087d2326368a91e15aa614eb21bb09f65fa5ceb935b5b43198ce8be3252f1d6ae7a1e083919d67a0f5f2cf23e2f41477bf69900a5e2e5b38ffb98f95d219d6d4ec3aa81ab8c00ccbb27f94fb5cda8bff75a61390ba001c45e3f459a80d81969fbfde0209e4aa3cd2ae7a46b8c4898addd29bdf9deee7289a908c836f4feee08b41ce8f741c1c5fa411642761691fc4d93b4fe11cfbd44930126523bc35a1887436c9dc590269df8fa5c170413e5ff14c5729b6508a696097cb8929d9791a77aa686339c3caec016f06786ff56a692374b77c220d5459f358bbf1fbd1586027e004ec1b3693b9bcc7a40ca5c03d20562993ef9de9f13fa0ca98472b437f0bff4bd21ab23eb50925a0c37c09a71fd495f564e44ca8672c3d1bf5a17bd31cbde71e2b197ff6c81b021a79ad6cd6e1913a924e3b7820fd49b832439ca0a5a392f8b7431dd5d4b62969e4168ebe22be1b32f6b4594516f45b8698c9276b16cdfc6e632c91ddcdec0a62ad28eeb7e17e013c23c9824bde4d2f5d459e9bfd85a2a81f94906f68535ec425f05dc29fabdbd71727f6c2d3298cfdabe7ab7d2c2b463a8128651a447a162f6d5c118eaafed38788023f2b2d013108e53ebe4d4c2b28355dd1024a914c5f5410b7eccd9835e2fda0391c188e8a1ed6dc19606ffe8c6f1db3c1fe5fbc76adfffcca485a21bc93868f28beedfa456de3f5c06c511366bb9f305ebd1050d2fc4184935e2e8e3064a502f2fbd1a9c72a113e1d08c88df370027cd8a5a18d93a1eacdd4bfa7a5ab29498483b3f6a24ee80b8eaff53295c906da901cad81f11100dff5257f5c0c04ecad15f2fd995f3b187bde67195061f5e60d741b0eb71dcef6d72a2711a2001695bde34b3080cee5309eb723dbfb53e3dbc240320a605e7845afc7d1e16ab6b143213d50fafff011ca4f7bf37327db01ea98cbef0438d20828200e7086edc6b74124351bacf6820affd3312f94ff200622c5af012dd7a7bbcd1f5e4c7b6538680bb2d21d355e924944218659cb3eb7f6cc244d987141c40ddc10d81e2c8fdaef1c5574cba9796c0505fcbcb9c3e3450728092b6eae4743352f30fe4071f9e042bdef181b5555f18f1954915e4c6e3fc82e4cbcfa5a1bb60fd2519c60cc3c11343365c87c2f3b4a655106acf7033d4016cf6e54fa88c3aeef9f1443a588cb3b322bce66d91a1cf99f7fca2a32b2509fe7b413ec7249612d95619191bbf778e7d989cf71cccdda157b442f138df60c53d9876f0115d82be08957d746048a8b838a1c4c2ab4b9cfade0d9d513839d4ea1027aaf9fa9577f370b8dfc779c841ed7fb6a324deb82d1e9d136f46690f5f0469cbb5febd83b845c17c26256a316b8412a2450420a8a9d6da71d566c6e6d80cff2d660c8356cc1254ed81e106661a6edd2788909ba2c181802a3e9eb450e17f45f3f1aedfa0d0c740bbcf3f9c0845e6044701db08cfaf04004a9293b2b0e36e569582fc19f6db18043baea8fdf07eb721cc60ccd20b6c0635417af294efd497f192247ef286c4e4c7922dd391ac38a5fedf03f40b110ef293f8412930fe678040473a9cd0da84eba443d54b5f3e596ca244b1380b46299d5a89ac50438b0a7769c0150ac56b835a9faef08d83ad445a96e6d818829ed0dfe20f839b6cc1b861e0424434a3e53ce0fa1c5d2a4e80fb445377d6e55c91d5659a9ec9a27ceff569060a837c4a8aa2359f934c8f4928bea1a64c0bed2541d0f9415f34017d1da7dc9b7cb8f136a9683c3130824c881d498f8a6c8936e441bd18f7012e82ac78d64dd73418475d3133b60500c584a4f166748565e56c1bc3455e8559ba5e3db73140faec2189bcd460178e302f115a55bb10bf828d8a8136e3df76992266ff2c29432e0dd45687f394081367c5f63c728fb2f6ad3929a15a61a86f9daefdcb8406d2059052bf06ca33963fc0aac1f6d4cd7faa2e38a1bc479584af2b54dc139fde8b334b0039ad9dbe1e4b8f112fe147cfdcfa8865196f44871e40d8bb4d5fdc1fe32642f7cb437bcd47bc4e0bb9061b9472be6cf2c7e9f2921a910323155a160180ec9c2fe95d251c3eae1f81886dbfb10eb338277040aea4637c159b6976086ee222a78d0b9d5c8ba5c0f7dddb39ebc44d8becd5dca4075b04be581dd8d99a371d5d0a75c84f37988ffe942e25faea255a24cbe6b0ae5fc22fe2c325e43eea493ad23c1303ef67aae5e0dda4a8ffd25206dece1c39ca6d4f8e5346f20f63fae8dfc553b3f939e45f0b72641e64f7939b9402c0ea8c97907b43613e5ed431c73e1bc5e75bbd5bc178766690d57fb308519864123c976fed2029cfa881988abb3d0b866099e446d35a665594747d83f18c8d155f5091969d17154d16cd70fdf8fe0893bd1a3c37eb0b75d6b3b22b92f7a9949bac5f6240c80d584f31bcec3208accb5c6ac4ad6f4bcfdddfacf67a3dd5dc2234ebeec0b8b3c6ed1011b44a8fe24e7739129a265bfab226f6301f4cf36ebd2fe8186bff00f9233f01a31f2c8a9b7b55ebd554c61cd1147c88fc7ab082246df342f4e9fa7ba02dfee0fbaec522df3dd33cc6091579e140411f89a3595386e3fab2775a335fb073b4f3a5756698cb13aeb2fc70f8e7405f2b2feeb2421a642034ea5bd230d16c68384fa96af6e216ad890224274743cbeba2d7e0e1f319f44898a67ce88a996d4547e047c7e3e59c422f44eb0d92c6ae65a2d6f45f19d45c6fff4d4a7986b7098525d7ca7c81ea977d8ab96b464cdac1108cfb368b946276731e0877dd50f7825a6a36b525686ebe454b1b3c979adc86eec353d851fd0752beae362d36019d79cce36e9d04b520983b1e71fc175810aef171c40bef044f3a6b5d3b16b183dbfcb22698b099b0111d85ba54fc98ff50637bb3a18561657aae16bd627d5802936bbf111506102e20d9e05869fcc18e8df50ca39c2dc8594e64a1237e622268d0c5978acf460793eb9acf0d9da2b3cf42b88b5a7931ef308928fe2940b61c13e59b3f81166eecf25fd1ddb2fd56b7ace5d0c254ce4e223e67251f8a899fcbe17cd484a8e37ba27848abc05033b94d92977c6dde7255e7e44a7941a6aecd22f3e579c2097220a6446afbe1f3615410e4e13e5376ad15d2d9063114c89ab3fa24d854f224de8c95d66e1a69a8d7a9084a7f9355b2bc5b77fc4963254002d8a1137152626f13301db551e905507ec292a782cc493347ef2ac6926a1bb37510d9b1179ee0843b6b974e9809c65ad29b91622c25dcb76464a08d8af8e0bc2730569847a6002596db4798afeef51d1cea8d8f3280474e79f0ea88dab8ab878091ca63e826785219165192f2526f4f7d2d776af3afb6d952b5368fca3d2c99935bb924fe431d8af62a221e1b41b0b076e6a25a74ef1c8b961a89080eb0fba51011d7cdce489eed28e7bfea520cba8d55b3532dee6a5310f8b989c2c9c7e8e017679e14f7a259d7ef38557b92ee58e076727b56ffc23e380691271457f09b144ea6edfa20186a2848781c5f4fcdd3652269c42b47539123bfed00ff690205715f81d1f45607f03cfc8c5d1797b306e12ee25e97aa6d5b6c50a1956365ea87307daba980e0c5e6f00bf34266bee5ae3d6037479a9a0ac2dc0992f73fc3efda62691e5c70cade8b82fbbec647b74802952a4c361f6d3feff8ad953eaf3188d4086752a6670334867897b8a982bb22a5ac1343251c77a0f4996cb5f7f30fb0355302fadbed9391b73b21d0342042033ea3f67032dcdb332f011a3550008744f4b778d3a8e563e067ef6d0fea09236d028595bbdb5c28a3b59a36dac86cf7be88738b99bf4b86b7647edbfc0d73b29b4dd7f733536bae2696881f5fbcb877350e45d98d71511a420d09c78d79182b4d4aa291a21b9551764b6079933c2fcb2d1f6263fc6266c39b68f8f96a3a36e7b1f428e4e1dc0fd7717b7fba55042c3367a1621f7f95ce2577dabcb9da5818a6cac6a0ce60981c376d55b7781c79ba42ccb663ad5bb2fcbaea06ff0123912ebb3fbb4e051f1d629c3962f298702cc0c89529f357a7966665f88c6bc517c24ec097114a9f39bf4c311a4feabbeefb0140c80063e80437d19193922976cf7ab18d96c7ae29a385f09ed057a25d4fb89c7ec957bf39bf0b7864da98cb1f7b62fcf1927921d534593483874ac12703774e8618936b511466caec685593cc45db0760beac364b42e454ed4c1e785aca470a939e482736dabae5ba36f7ff7fe5697d43500c1362967a1ae1ac1f4cdbe0aa45a20f21640def84ff9c978b4dec126394c658a39775b36117162d1d138d93ff1f374060c6b8ebdc16b69a110afbb67dbdcc6cee236f6c533718288748fc9b8616f3c19373c72fd73e973ea4398bd0c9fe5fb25780f50870dde68cd5997daa6fd25f71e76bbd5d464e2322ecdd3b0d74e16483d95577ed6c988a019a2b3624ae1ed3fbb61662a7ef810362d42b7fc194f1223208906ba7fffb89c9697b65bffc9eecf6b0440fcf513746710e54e514b498177fafbbc6d4f86f2d80d7fa924572da21808660ab6dfcef5fcfbfe5f67707030838929465b513b01480388134e0d39742acb87aaf7ca407e7afef0ef40f9a05382afebb9147645aa68c41bd054d26dbe73d2b3eb0dd7b0dae0355e7c43dd06125772c91df129b34b3a4444156c4c4f268d0e1277aec6813ec252e834a69d4569e52c5b859236a4248d56aeb75cffc96c3c6225a667d5214e586e42334518ae8fba993e7dbb75ebda872fde2f89eaa86f9689fed9b1aed725e460a1d8e2bc12842169707155b816bec2621c8dff85e6b291301aecb729f0a7a09ab096944084050e3e24cd45af2cd4cf9a8f557cc6979defe3dfb04b86fc12cc2897022a44b1e51bc7a50adac8a94999c86418ac6496d53256c5baad7b073b5faed36965709413f21d4d5e2288c8091db48ac84dc47d2821966ca425522ce8b9212d39c038f1ec0b3ae3aa79fd0d2a301f7fbebaa8cce47720100cdab850f4387f020681e57ec2d26abc743a35fbecf73f8711bdb62959c00be49d95f1ae1b6ec75ce78a8c5580086d2a499e5e087d23b2d9c76073ca66d230ee8947ce7b1697402d78c3e9bb6245c606b8d2b5264efb15b767790be51a3656e8985caa886b4dca3d18e2eb964fcf5016c654dfbe147c5788cd3d997315c64a93fc59fb6dde2a63b3a08c0e75bf5c7d0b3f4e316f0e50e76ba47faa0d8f3f3b36c2591fbeb2da28e5705cfccc4162f871c6bfe7ba67cac51bde29665f1a705e1178d9834652a0eb54bad054140c800f2ddd00f04edc952d6ad208d8c1da3e9f4827601300be8d996bea47604b39a2d4a1f10e3387474a1f87cf9e73fc3ef7bec13c63bffd69381634fdf0e09820f180cb78c90f1bb148e7035ceba58041a3e8aceb69754ab706c16635aa3cdb603c6a6edf1659a73a0f1640b955b0c28bbc1f2a9d2ed3df9ee69ed6d2aaac89427c7eeef9e77b0f27adbce3a20a1925530acfd437c17a0d0fa45d45e9a469d221a1c7a75681e2b6b2602e4f6a79f82410354a41f047ae311f0bba4df7c8df0f3d6d1eaa731badf5948c61979191c5580327875eac70380467e242845596d9b2c01019e95bf65c71e101e9833fa1b5c821456f3c58dc771d4fc0a2ac5845a81a514ac4596572043e3bc7479f422d2dbb9fa45e36f39fefa5a37c056385006a60b72b627611bed205cf576cfdec8c94a8b75c898226ae589794feccfef3e37f368a4cd57f39f6cf9d88417f88849674b4ef6016b43aeece1a48ac2479ccc40be90987b562ce0240a74dd10446c06d812f30886f2d92c82ba3beba150f15c1b54d612fcb6c9e3e4377d0d36c8904f749788ab414eedca380ca30b13de99ccf185e46313afe7e272f20fa9bf34f1f478b5364643ab4887db011b702dd6fe768720209cbe6b20146dac0e591786d57224e49fee6159ccf85b0ae88a34e5e334c86deaa5cf86ab3c6a13f530f4176a0b5cabf1776d0e57fda407859ec466f130fe224a50b5e1fdb4b856c792ce416fbecc8ba99e5c99d0c278ee4695be4c1741306f8038590e46db777ae2acb57d1edf4796870f16d5720c45515c6cb2700cca3ce6dbfc469b3f17a9065e0df93b4fc8e0a02910b0b382ecc0509bc827d5f116e802e5adb9d8052bd32f7f12bfc5ffcba87387b635d0bf53ae9807971b0592a4a631bb8d0ac5c39aebdae53140bca1fb2300b19b1483bcebd071133d2402c27af6bb8967f2d6ad2929412f33f00675fb4a5166b0a27ad6be979ce47b6d4884246ddf78cbca5fafd6251e5b15130ecf98856e7125204a03cc73f45876aaa563883680c5c340d29e449ab2bf87ffa10bad9f80be232af2b2b1758ad152fa46e04193f4819ef16238da8ffd00d2ef8031e9a82272165be7c6d45c65e7332498a8372d4ae43578039f748984982f4be1b51d6080cf1ceb6969055de03a491698da4ac305d5868dc9b37fda7b34c6dc776c01beb794ee231cef1b035308ab43b351233684dfb1d1d2291f14d098c2727806bfa627fab971660869437a044db62f1ad76c258c4cf1b288218b78cccd1208bb83017ec8c51a8e1c3e6ba6b1fc0d60a8b327415d65f2e131ef1170ea5411259382ff4b7340c844dc363d606f48f2e6f57cb0131462b06d1262168f0c477c92b59f4002f422cb2c9d4746cbf7da92d1dff86f6a5047b24b6039b489684466e7790f018d48b53e82d7f18f6b38082165c813cf6f896d8d79290a2b8cde4750b57ae75cd588668fa7624f5232d40629a3e0a2157de75ef5c0253b5885633e1aba072743ea70baf6d95375f87bc93df2e9e6cf4f13f95461a875953872b088bba4804a742d1c04ba0f83c0453be8f811cab437e71aa0efb5afcec729c20b8172ae423a265e2da01b46e34fedd5cc81aac81b07d6b6450490ae51aec6587d48c42da04a590f623bf35beaab57a10d54b248f0acb81eaedf6cb296012e91979ec97a35c4bd2da0206d97a3f7419825815cf25a7b671c6743d35ea1e992584c96279de8e0efcbe630b816f6cc2cfbd0170d767396b3dece9e6b5e5e9bcb59352c50a84d246fae1b05cc916c710e7d980fb8c633b61b246db4c86b0e0359c6260b96956d9125e484755381623db348c60e350578e60c927ef1af8fcf1e357e14a5921095f9dbef9798a2cb5dab7c029f52d14d7829228547c8807a1fa8e725460c588af70edbec1ef24f946f378096a9a95a89b35a747925798205d3a1288f73141cf7ccef317ca1bd4451f62e55be43b171c298f5d2b02e1ac26205132de75fedae6c8edf42c05e08aa485068db2378684f6bb4e2cf9e4f4239d5dad41001a51e337bcbfc0a8f011018567a5a80f71e53846f1b84aa5d24447462fd3083f718ac7741a5f70e396a56e1e7af1a570bee0849aedc9ab1e34a0ba3a690933f3744c1b24ae0530cda2f63f094ba8d4355b7a7bc04eea301ade4f70d988ef2c81dac86870d309ac6f45c25d69f86ee02f097909792874469ab3a3445732546928cc169ad5bee55fbe7b154b6a95f6a32e503758ba867b673972b74743f4171882f63442d91ea61e7ea9fdf94c2b8dc819717e72e099bdf60e785a2f8d7f96aab1a6ec44bb48cbc4cdf7a984bef01d8cc03bf2bac2153c81ed7b6e7a8225fc473f0ff898cba415dab6ff6a1d907e8071537da6f969240ee2ff5ff310d95c21b69e5f8d3f73ded60994d53d344eb8293bcecb290f82269a83ce7222126e2fbf7088ee6031c4329ec67befcc397eee25838e0d67fa36a15624942a96a7ef94e6479aaac213647a7345c69a054990c2333a16835460673c8a3d9a790cc328c8025b059e0ebced6e2b1740048a151343eca8c68553cc4d97e2c4ab66282ed3d50d6d70a1f4f1f11fc559f6df27ff42691a440de7a8dd78bda1586be4f22e56f7884b189684c53661ddf483a7934ba10f957a01c1416a1837ce83860d8bba272754dd17d955fb6f384bc6b882d80f30029a1c2ef586c7dcbfb6acb1f96e5f09d24d5c5e3c0fc7981b8e3b6ee4b78651a7d7d1d4bafc56d8ea17e96b3744b8b61d2ed217f5a4472eebf5eff498b60f5d7ff333fa38b7b87d5792e9076d1ed215961ede791d4ec3269018fe9420c4678689d6926031b82e9a0c0f9b91098e496f74f0ef92e9983cc0b5038c2fe4d4350b8c02646a90d5127b77863e670c1c5655c84404b16cd9cf925f4dabed5851b16d33118cae98330e6841c29581788b7c79384aa3136ec181fe44283bf5a592ad46d7892c1dd6e4be5d1e4d0833185f79cf8e0fad3f614c88ad8886a0b427bbdf1d6f05e497db2d24cbcdc1e2ec4200e59d9417ad104498344c0903ccba74532be832e32eafdb0209e12afb8232ab0b8a8bb3c0e30209046f92539aa859fe364b7df0c1cb7bd7cf779bf8b27e193d890b79217b1fad86e288733ed2b22ee9c9e98d2461b2db314cdc4a5dce277f02f5cd05abe4fbf98f71719f76a08fbb86717eb58c09e234bfeff6c0bbe8113a93783ee504c1b10e1a688f5bcf2783854c0b7990edd7e314fe92a2964c3589dd2952907e1df2a72cb3b523009763ba61b462aadc7482ba1d2b459e82fa5980a5de36ee74769249a33940c521fea690539a1128336996f965ae004cee8005817ea33b610bd6608e367330147f706e348e5a0f61448b7db6e0c47b0a22fb589592af31f96b415adcb3eccdd349fb44d871403dc8cdc51f520a8fc30758e0f3fccf8182621c3f652766d5897f2d6ab4c205ff1100fd4436fa3148f3479088c2cefa31212d2b3572cbbecfa7fd71e5e61d6a20a83a292e81bf6e654736b9f1238e4110d2d75a71fb7080ee2180abe64110cb22d586c56851ed531352c3bce3243a40471f5910bec9ac169196a8ab6502651e65f217e5badd950077f4bde0d61d7f42797c9d289f08c09a46b132dd33ffa1efee76ba4568563229e51f88c8d65cc13d3a80e9b8de35c8fe0bec6f0775d9f4a6d8b80fbb47dfb3d2dba606715e60716044d262aba751a202be26d36fda370cad577b66e80d7e7eb2a6d190485b6c4051f852585b76c8fe19997b4cf5eede55ef0863af7d379548b701f3ba10886224453757d76b2e8a137014651238c6b015099dc94da6a67083ef51cbcdf11f9f90f7b5558ec406486c62c7028f826a59b23742f595e133db3541f8fd697e83c86c8b1c5fbe18c3a952aa0abc9b735dcb027f04ec4b1657ce9bf26e7599cf80d1a6aca7fbbf777f4bbb38206f23dfbdf65d4d910015c1dcd36e5ef8d134cbae4cb820445544580fa5665a920e5f9d96dcf30977f6e439b82aa0d227cc04c2493d041542ed18e0c1c3eb0bbbbac5859d4e889d3fc4a44b66055b67cb6cda4291c2fc840343d96004711fe5a24f8da2735551d7be9a530845ec8a0cff506402c3d760fcabd303b43ee17025b64e4fa547a77b44f36c2e3f6f6320e44a8b08723d9a4a8073e1bc539b23c480e3d6a0e423f102bd1c14df4c1da488fcf94f03d5ece8030290f71032e39b1cce287c1e9207d58a0fc4d86e89d334a98b57015a6a8ca6dd5a4970c37ef93bdfd2f3dda808db3ec34e8007d5e5d724b605ce3e78c36d9ab0b51a16d6900609ca06605d2aa84aede55aa4d4cabb718b4988ab7266ce14e62e536f03561e421e03e0d5f0f558ba1ac146dfcb5055136eaa2c0c0b1a879eac152b1f72736cda013bb00c9f5b5323ee6e314a91d75fae9f007b98d9a24f7c29286112fe3bdaa3d32237e95ed95ca093165c8a6c57022f9de754a4029f934a2c1d16ef835540abaf0d2b485c9e7491eaa79c880ea0e17381ca1ba32476b4c621a751bef406fd5e498c5ad6d5bc439f9e727b5d6ced0c1c71f2c04959ee3c24931f5d9be4dc62df686bc9944a97525225dec711cbd035396c8f56eb24762a037b46c88cc554f29a04326c06c12c4e6135c09cefc98787952a41b510146acf11e637132af5cbd9673f3fd435e77a551fbfda040dccc045df291de220623115b770f5b58d8d228bcfe14d54b3dd70590fca85c348ef80f46955a124c40245afd9deef8f63fbcdb1f745a9a66b55ce2d101ed7f202e20b7e436d40e65636aff51269f817120bdcb34bd3cfbeb9d5904b107f53fb899f9ecbdf9fb546bdab1b86e0dcbd95bd279a6170b6d87f9f4a974fa9b6f7671345532d6efc14d764251af59bf0d023279546af86dc060fd7c8111a13b24ada36c483afe2d819be6b715589fdbc288fc437727957bb0c23d5405255b949fe79e0d69e81f81986f2e96828ff80ac8436c04c4818a700e5153a29a3edf9bcdeb9787337c247e7a3916d1f24843a42bfae576be236d9f7fb7e304b8e4d787a598d1209ab50b54904c5bf277d34611cc253d6ff6c942d610bae0c3ed36f7364ee91355a05f63bd0f252f9e71fab5e5d7f0224f6a56585f35d16489de2b2a52417935253f6c1ced6472427e4c585feb03ee6e2abee3c80efadba6f06e8dfdd3442580238213fe5981d44d8ef42e69f58b3ee30d91252edca7ba124b179000e7f9788ddab3b2dbf3020bd5578f9447172e8bc9a9c9ac240cfc8ec4534821957230f053130f0aa2dc10492b0a62a55d60668b50867744efbd0adb7ea065a09b7c2201ededc463135b612034d91de4fe00729e9b7cc335173ce40b783a111216fc50b0ef3e3f9c9bfdcb64c5be8c82ecf2b4ffe2eb8818c3664353ab9ec4a8ced4668fef0db9c05ec3a1244d5186fc2ba2158f0ca10cd47434c188a0239f91c2b5d67a1f785bebc3cdb24a1d9c7fb921d0695c8142ffc3e1caa920602edab672f3f3cfaa0bdccaf4dd5fe3d7c11c35942a9560c31b95078c4550c90f9c3d286d5164af040aa31c39f629524533f935eeefc3cc62adad14e3cefdde7385bb4c90697c09b499a797684384e568db4c1415e9793ff20cfce1d9681c1ecd1c0e81be06e8ce7b35c1143968bf2f68c88c22032ebf2e0b232c654d9e9cf0c4130b6d7ccce7f96944af37ef8606e57b241d949ee07220b785ec8af7ebcaa2aa6fe4fdd87863f30d89df96ac05a8d005eba86a7e6f3edc5019dea5b242a0b119f9a6107c181a8c17c3624f7b0a79d294f0df709964f262062f3e8d3e1cc5a8df59dfe38d894bef850380f23d326508ea5e42dd2d987c8cf949e42131d6a71cf23dfde498046b45b073b9ce86c011c673d4b7618f785d1ccf7a7c1c6718ce3740b558090c165e674456c46f9e4fab5a718041005a73df3e1d411db392b2619e07afe53a4956327aa647e7328190f7149e834598b8a1db19f1026ee4b3d037096af224d9a44916431c0629d9c64610b2e29b5b37ceb2b755c1c0522ca5695f9cfcf0de9485708b3b2d6b4ea091448325e63fb7dc9927f0b9a3ed75d9881fa65bc0966de758d1d055bafce9503d58f8bb125d79f030323651c34a54ecaa0d134cf0affaeeb85ca219ec7c88e506ad4e34bf5b9931240ace3fff4242afe524aca1518a26b5f8fdfa7087b3c57209687d7e7e30c55cc5948fc33c20a10779c374f88cbeb7db7cbd711c5c3356bc2a81202510b6bc22033e60f8e21e5899c7c5a411d5743c8732b516f7dfabb6bbf4a3832339c1a19d8c7d4cede6ea3076384358526ed881a3632eda639eddff31f5b2c98a9004fdf0d5a872da717286c98d1a9c4bffbf344c72e5f86de55925262330bc2c8c31127e8ec45ad0dbb5bddf69e9be5542d98f8aa26f4e876cdc63851e4723de4dc2dcca6be616f5f80e3b2478d3ea273c800cc97380445e4899ac2da8586484701d80b0dd8ab0b91c49a66c52bbec80f1afb2faa7ab96d5082301dfd6239058cd2f80180956567ef8bd572805f5d83e1b69c966561081334c55e0566cfa6777fa0c548cb99336029cf8ca20d083ba385dd52ba4738ce8581d4b0457eae08ae46fea4e6b116e6071073f3f7988c51963d90a85c67324aad525d3de75a8bfbedb303b65fca163bd85e02739c595c929a15de32b7cb985cc37e4b5b9e58226cb275d72302e9c7036ab9f8515ee50e8125e17b1e4e0fac6ad8e7b48ad09c0fa9b468b15a8d576172bc091e5c6dd8b7ab4667886b958c8bc8b6cbed19c0d4de07a65bad93899a5a2843461c22b6b894fea4d7f1c5439fcf15b97885c487981994ca566915ec8fc9f1688840b83f5ed4c40b36c614fb70c930a41e4e67bfb7433ff0574f671cf0f215fa4df4c6caaf146948588eeec5c1ed438d694994f861c56c2ea96b15809e4a1d07a32815d092982779bf36e5620a62b10f3b8d1ca920d072cce74df296c0a7800dd7eeb154562b78a85420a7322ad25f059e8bbf8aaf526ac3e1776d7b399ed55ba16b3d124d9c284efac1eede02602f0dfa7b663f92e6a0962ff3d5ddb9a258543c58d546c7636283f47a6e417403b74b1bdb9b0c99a76c1409ce9b8aedeeb3e3787861eb257e109cf93247d232fc280be86cf6b4cb72f5f5bda9ff3d8010fcd54da39e364aee6019ac762f5d8e66f4795b53eed71a14a6e2ee23d439713e6956a8aa703d271defd633f2545779234236b6af8caa247fcbde5f55d1cfde56d569b0b3ff07eda770cec9e89d179c8f913c6ca0c2f08d62b1153029953fb36edc56f203620efd8e8ccbea22388f341e3b2ba1a79f7b5963b90da47bf9053d1051ec5fa4321a161d631b2e08aed556178bbd04765d3e254304d98b39537d608ec1025cc4f6d4df70856424d71ea03c034b98d380f73ea9135a96366b23778d76129a84d9db984fd7cabbe0ecafeae9a09e2debb21faa126279ad2e4000f310f9a26d211a90a6d55b88210fc051688ea149c7e8c27e6ff7f54e02a53e675da9ad8a350700405434ea9998d1e21a7ec185ebb846c0b8bcac1b8cdf20af971c83aa75801c7ffba421edf0cfe0d147327de5cd40eb9309ddc7a53b1df1fdb6dae2b8e6a54d71dc8b702e3cf55073926837194dc4d36a2d80d6f680853818a1bbd9b1295da63cac519ab425dc78efceee6cc0aea2ca91c6e545e4fc53f1d6ce4cf6c1a7d899d2267bae02af7e8fd9db06c4b2aaebeb26d9b2d7864499cc7414f23b2e6119dfaceb31a3f00a5f8ac28a42345fb2264ec528a60a201de1571229454d8e5e10b82ba6c32ae746feb7f44929d5016ad7b60024d87994073b4600a448eadd69052fe42767520f3f014afcb5c0e9954605c5a732216e3faeecc72d22a4e57893e597de7ac556df6e75d4a8c386ab40f6bde193089b72972c21477c92c73a4b27d67c25b63c5219d3c634c954475a2687600aad35149b994a7412c25704ac6d5abb5fb03e81b2441764d42c4b04067c69d6417a81533a6c207bf6c690b58cd363949b4f8a4c981e6b499374a9cfbb3963dd81b50d623afcdb839e14957885ce7e6863d44c86507e827083710afb1c072e54a4ff529d1a1edd6f6cbf2e810630a674e5f4636007fc01793002efb589a74902208573c1fa5b93256ae263958310978e76f654b32f5282b47319f903a13ebfb1a410f61f6ddf05fb7f87d68815c59dba520be54e61571c0741c597ddffcc676b0f33d648843ff6bac2bdce3c6b9bbe76f79af5da313b642900258922413a0138d475f8c38ebdb8161108488946b76bb7a115beda7f678fdd1ac58c6b4993cda966e3d8af2dccb9b7dbb031046353f5b499b47a8bcb288b25a559fd833d869514e300405225930a89ae5066964b125f519d8c07d2c3e064dbdfeee6c495d774a0b331e7601134ac3abbd32ba1a1ba4bb21da0ec38e8f5a3f8456c5133e6f8c05c98bca0944d564ce4caa63a28d968744018416567b78bea052beca36ec43224b2b3afaaea337d3861f8e934628d02c7c151c36b474b3bfac2c7d668fcf0cbb660b4bb472624c4c7e453fdc4d5e47d0d1299d9962f29ca5d2581772356ec9d43452ad99277509ea0d06a82b576237b24ebd978655c0f7da12e403db846ce27ca7509f973ff035b0b77820af5fd41a80670393e56790b03915045fe8d6e55463fa7991809637229f51cff689f899421bbbf38cb9480c249709dd89cc4c639839c3292ce7021ab1384cecb00979cb7a75c9522d328428672a2069d844f84e9700647ecf5ac1333dedd6b361da7ebd782446a9987e888a8e4578d8c87d6df0f3bea8cc83c5a88eb08b017f2b42e2a0f88c995b4f78590715eccfe45a1ff4d559f9d9571e45998184a48d131506f1614fb10238c95540a0b2d7f2f60b0084fbe6f402a771148b43d5f217a75e9a1614a96f0a18a0c9be79be3bb6839bf12a2b9874a21e52f37bb7d173cc4282bf998e00546c1df5ef920b0a741ebd76434c955e38b533a0ff2de9a999edc6532599f8b162979dc6fa44769d9d28b303d411a9ff00310289762812fb24f1a6f6be36a509c61c14ebc6b3b86c8b086ee4aa5762d8162a203b9ae7e836670ddf91e113b2e4e272bb75a31b87724c0cf73709549b5674f720318de122131895cf14dab788f8363a9e7e7fbbb7e30907827900b494f46e33bd5dfb39d9a93a0697e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
