<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e711bd17f30299b98ac6da8c9978d908930d921722a1580e559e02ecd5bcf01af1bfe31284b7e6674cf02720f451d979bbe7732482112bef637d32bc60be11c1b530ce8937770a2f9f4c236aa6c3901d976e1ade0eb063e59a9e3488b476aedf1f240e34318feacf18058fd177da170f3f654ca6f490c5b91d353fe6306ee6c26723a0aed90d2ad676a103ac694216af397ff662ad301d0d9c07cdc07493b4fc3f57b70ee7614d329d385b01ba75db4683b870714b7e5fb01b2e3cec5a9b1e10153766bb05dc81d7da2d07022604951ff40136a511bf41a3b4d4b465526bbabe9745f2eeb930d133426ac4c27c94984af7b8dfdee147064bb162d6b244c877b2817c2c893f01ddae4333588a76b7e7290ee34c3ed396e8c0c74cac98fc7e54e28f34015b5d23c858e1210aecb2262452e45a013159fa2cf0d7d349fce44d918eec333a6145cbbd614fe36e008b550af640615d4d1cf86f96d1d6274d74da037060a1b805434b5a564f9746ad1da7eaf3d063bac95aa2bd18948757fcadae2cb14c61c287891a83f7f203c1e05eebbc775e8e9621f212b6ac16528b48793ea3baf7f2a64beb8b99fbf013ceed7548cf372f2fc81b069130b80ffa9ca797b855465229b563b1b9c0ebf37a69e636bb1442e9456717cdd57eec790004d60f5e2f0cdca3ba395cacb73b28c006c06b01124519ad30c2b5ab4fa5ced23e55103deba6aeb755660a7d681f8018aecf16132a5520baad1991d2b1ad43c9bd1663937f1d39ee3b5fd0eb193d16440dac18e4390a6826ee7bf006f448e5a923ce0e4aca0b304baf765151c0de77e1a419f3cf5143b2a5effe37c764df8dc5e0ae78e60db13ae3570022d407913375eec8932dbd8a6b67527a4ad42549152425df85f784c523221dcd98bc48488be37e3ad8bb75b287036b113f8b99ee6dab4d45a382bf79a28b868478bbcbf1a789c94419483b1392001ac047bcb6905666e0fdda96f2ba3683d6ab70fa97e46bd1385eca008a4c51eada0e4f49f8a01e22729ad67be4cc41b3526737425effa9af7097bb06086e2bd110cd269cc70e6aa59a16abdfdcf3b66c93bae15bf530ebff1fc9557f031f5661f0c543ebb6d0c33dcc685a3155ad8886d489d604c4ec786e4765ac7d11063f6950920edae09f86ae8ad2715e9ec25460f247b63b9d2c52caed485a3a618ebc861b37da106b9de99d51b6ed615b9c5676d796f3c69c91f9eea54283ad5da975169f0cc5ff933d9e48c34f4dba8ecdfa57d0a0f6b4ac883812fbd69d60ddd3e941f28d8b947a1ce950c38a590225d540dcf32a78ab2828b1c4574aaa7d4560686fa25666e5087180066d32d86cd21bd248a56ae7284f891f044a9a4326a4bca9c4fcddb95d704d00e1168a82a07e441437e7b9b5164f97c70c62745604baafd9a6c26b6af77b3757e16c709b4569ed1d34e6cda07dd8fb55ccd9695cca69df64652138892e7d5d128bbfbf1e9daea321d6904670e3cb9944a97636156e7ab63286d03f43ad24419ea7004aa74c51706024121ccd1046d4d471d0261f55fff1208dc2a04eee9cc4729d57697284ab5e16a6bf3df2dfae6c51b89308f83ad47d69cd2df0abc4aabe2ff3f4af867005cd8f68bd3067961eed5d00d8bfd00663a44d8cf8f5640f201d37088b7379311752566e60c349ee623350d4beaeea5245608bac1998c25da74e418e00acd3174b4951a7e3506cc6b9c0cfee8c4cfb4edd46652c7fb8e06a1e93ebea17c48ebe378ca6f0d65561850ae52d9d62cbb4f0f728d7931183fc09d7e2496d3fa90af6d188b72ae94bb8b3f373f43500d33dbfdda1997b048b00b84f478ad2356f7338c9727422a12103e0216dd70ac9921b87adc3b04b9e69dff69de0a81376f7dfc4def767ce3679e0045f5f4102d9a8f757a68aa68850a0b7ed6d71df169bd887fd927fcb2d305db4ce622f7c7330c71ad2a22075d94611a6e841d9a45790d5be467173f2099eec820c3a41509590f359df9bc7bdb841187e50871c7101fb18dbeab3db31f44ba49dd17ee2ff23a968e0efd3f70011c72ccfd62e3be66bd383cd1a871fe9a4d384006339536ad5fb07bd4f4624b0ebc151cc2c3e3ff846640cadb0507ca512f89fb05f71f5e3ad9d70b64e6172e1e699f298cb0accf2c8e383951010e3e62fdd4a0c1e576164e579126ad02ccbc019de8f73aa01e42613e636079f86710f091476918744c473aefe2c6f198edd15fa0e269d8927cf04502363dd68f81764cdb2d8c2bcff5a6cf3c83f976e56981b334a18a8fffef1480060afd2aeb0cd5d3e338106b60673867ecdf17540df160286107125396c969f2b7d3a60c0fd7f9fff279a02c6f98330484b704a7301469c000a0e23f29fa80a319a18bf15d7e560b2afdaf2873297e4f5ddb1748900d03f68dba6c434b681bceb5bf113bbb1e49e15e8f56a159e35a1809101021784c85d41fc92e7b7b1b956f960a74a7c231f22b8010eb94f6357422169d4e97b708a1e27d822a0bcaf9246399bb54496311425f10ad024c76837d41e470338de4a9035647e97590459cc6a3ba8f0ee90a5ebdf86fd5db138eec5a90a0681438dfa42622412bdab98004057475c547e0408aaa03c88c2d1610607ceb110c3df079bd5d1e5a0f9395bbb48a215ed1c36323ee7dbedb1289f37a242f085e12f6869ba709313635e5063e8ea1e334694b6c3a28ecd5f849ded02cb9a3182778b065b31128958d75edefa9b2aed8fbf5d54d89b0f228b5e2d426272023f8257e39a769166ad95be3f108ac3469bd85462d1a3232ea899d6e18fa9e01337eb9b9e690d8eb8f9f70525351d57d3390df922fffa9e7d56fcaeeb63335c651308f4270c606d99ddadafcf0dde70d965125910133f0f7545f80481dd3526143dcf63964e2382fa39d230d5a11281870e390ee49504edd210d7c11c637525ad6e2e7124e750d9ddaf7ac82e9f8e9d47d4673734d09768633e2c0008e107f4b9941817001ead7c3b19815357d5692960300138d920d13610cb873e92b6a93cc01d3bd95c152f1158a9465a733c3ab6568fe2fe5976aa78ebe79e5184bbcf6156188c51c47f55c731412676c5b0df352abfbacfb025c30d1977e2f7ee185d0dd3d389cba97eecfd46ba4fe62404ecd07ab2ecca9881fdbe8713c6a5acfa606ac426eb0f1fa91d62f7da90402c2dcf28b185530a266b4b002d830f66c959cf3f3434ed0b8a3def351e236e4935f8e2e5bfb021547fa13406401f0e9984c926970e338ac7a8d166c603c560082e7593a6842c8e7f899dbc8cc207a843581be98afe813e054506aa62ff50a8ee7d37847ad42c547ff1cde151f35117de5d6d555842ddcdd97fb94b152101d2b92c20d62c0d5de3de83c0c488729149698a12a8c72aa4e27c20f224e2dfe398965324adab3d4f7e51297dcaa6c354edf4673f4c4bb68b696a8d118496478a33a36af38d255e357d7d0ec45ce8c649fd3678cb6dd61732af14a86dcd6ad06910e5c2b8e75f49b3967118913516153df3365d79a9f2aa0b30d4ed6086ade8d12c4f6f425e5b1bda58bd360fda4e6b04bfd5ecf5861170fb8b8329fa67e479ca2cc9dbd6a7cc30821289139c0028e91ab63ca103e40375c0de661b2167f3dc0a0da08e1dd0960202500d0442fbe2f0b07e2f86237542a7024b878314bcb604d41a6f102a12d4a753758a0292d684a9c47277ee01d14d1383cf126c910a5b27d37502bb232bda2115bb4f386a242288354d2f97c8dcb9fcc028f750ef406f1d65c2f48dd36de18deb73f39947e9e93303cff86b93321c3e7be1a5cbd77b5a9df10a6dec6313df6664b5dcf80907113698e3e30b02b0f3bdcdbe819a0dd647763978aa0e87d423bf0ba91a4c8b9ed5387f6166ceffcb3b3799598cf9fe2e3f6d17055c5a3cff5d1ebd1e95f62350cb1e6e2cd9a5dc9e9f82dead41e7e9107e12443367db701289a395073215005c894c24d8f8663f567d147ca3b559b65e6b5ec66b21b0c030e4861093d3b98d9dfbc37f1ff9e853c670541c2169db18a639559db0bd58779a1ecb0bad99b31efae48e7eb3ed6a32160127f454f5bf6995e26d9e33c7101261f266a8d8a4bf319a4a2444cd35c1afb60c81d9950e7cd3224bace8d2ddd1462e752f0ba80712a8b88048747192ede7293c22878740874be9d3fb2a7fc79a9a20d69a1a9e9705ee7e45c2903ac46e8ac8bb173ce239e9312a6de8f5890672b30047b7920e55131b27d46ab54c546d04db7ea8a0f600b2fecaa0807f881e5b13a48da9ba62cc5946fa37f42f9ec64ff205d56513b8cf07b035017b731da93fc249c54e0beda9179777c0439486d6b01fe9ff7dd5cf6e1a6a95bfd61a5af03b2f6f8a4aa817ec5f40b42b973baf1accfcd28c04a193e445bd331f7e4a4cff41368e411e31bfd82d90dd94dfa9bff32cd30262506fcb7ccef18db9525e1f7214fd39ac912786765be85230b172293886a4461d8e506d0ba65504b5f4342358fe2d3a41329c90fcea940fdafba7207af3f8026c551e82cec91219d38b97349bee0e07162c8476894f7c86379eec56a18e27f9e00b16ca212867c08b966c10e2bf5669333487d29a5192d1426a5d879c5d6e3469f307053842d8ea6c45d0115bf764a671aab7fa5817cea29af2cff5169cc3110c85e2b61b7ed50785c2ebda56ac5edb582de5d3614391b502b48d2d6d007841768fca3d2602764ac0dbab36b569a0d4248f5bb55b64c02c80996c4b61cae242fbb8a04af57d47db1db6a660c2bea3ed985b3289719b0555ec02851d647818917f6baa2bf0deceb25ffdece3b4fa8767251347e26f54a32e8e95165bc43059eb6c786a8082f40dc0948391facfee5fdb0c330fa9c54c2a03e665052d0d7af0201ae0ebba4195ac45e46d20996c10d6f0f4bb3f4ed40b136cbd2db6f09c8d787af9afbabb5fe1c909e89ff2968a32524acacbfcbfe84b83f9d19187e4145bef44453acc73b0bbf78bb3dd2f2d02907e27d552c26ad8511432ac525d21cd4534cd8080db016c39fbf3309b39bc453581a4205c0ef42f5df812deca71cb26f65d10db7046253c2d1e04d83e4e5d3f6c200f6f752261a34307f8b859cdb30f73122f4f02b7049f2aa519b5338eb9f74dd4343a326a6a25186d50b2086ab425aefb8ff769d73c5158e98fe5b22a81a0dbef0b914edecef27f20a9f9118239c0a8ffbc838296af3a0d6d3fcb4f5ff90a24aba2b84d414fc909319ffa7fef7b24c9c572fab79b231198b5c084f7beb7db1306c14b5459abc1df72b6bdc4534fdd8a13454d25e7c2cf9c5f97096145bbdb00fe98454b2f8afb0cb67cf71094f888019060cc4a89675a2a0cf3d76c9019b09acfa07414a7a14efe90d8b034be3ebeaf5cf0f324df65f8cfc2db470353e1dfd8234c056eb790356805461a631613f41c0bba9634b3bc3a4b9226ae2c8b9f7a902bc042fe7e689aea3ea13abe4aa52e62c2d95cd74cf879654109ea783da483ddf948a715ec7cf4f3a1fc714135f2bf65c004929fc5fbce83f62f4246620f2ec023616f37110095560c17b5e8694da72d1021a14417d3e8945e401c5b8dac997d53bc9d3a82de44e32872039c9b5f6de663e395f5634b0328d5bf32936a532c300068f68a39f2bf6be0ed030d82a0ba8743ecd45b138e695ba5510e50cb2d6d00c4c5a85b03ed3f9e3ee9a2c5df20eeb314eb8570d834017c3d942062641b620b7bb7d147717998b8277158f7a20e0c3128168c96f876b294fa7475b9d4cf14ce4ab7f34b3bea6acf0eed646d36519b5f2d304a7ee2524784d0290b121c34aca69c7059519af004b74499242fbb8d9c49c6fa3e73e91726a3f4da443f22ba78fa27d360dcb87d0cb5dca21864884c9259997df6f60f0775164658baad9dbbde1342595b4d70b063a8deb27b02fef698608ac4c90451d6266beed86f3e8e43b595d718fd14da2cf8cc96672e4b411b5d1b74eeabb5524074b4bc5c765dd7b54f73287bd80fb7d12f5e50cd0680696f82bf5b0d062313f15ca16156ccd8c930b2f3a6410e8dfcdef0f07530ce8e5f83c16d319138b7f592b793dbe32961ed3f93976325bf645a3ff4ab216e9f42ce581218688a17cb30a99a00bfee2b0fcc2ee5f0e877a712b8c0a2997295c142659201f11becb23daaad34d2371e0e1593b0292ec0e0c16342782804d6f8a7f3f7783dfc3bfef99818ef63c014edda7f3e4395ce44a477a1399c319a7d816abbd89ddca111a0472ae8d5f09c4956a7d947bab569e7270444fe248942e566dbdcab44d5bcd19b8c574dbf19000d6780178620215bc736181189b320a2ca4e60b2c0f3380b0cddf8ef86b8473d1e7eed7ffa4837e8ec9790819a8333d040142a991201e3276efc4ebe4021576e132d89554528f64b72e547dcddbd836daa01867210b784c4970f1c97d5b017ff951e73127cfdf2637f9cbbf95be2e2b38e6f99a74670e43ff2fa990d297678ab12dcff3c18b9e028056733172aa7a1aed985b3fc1d5a6eacb158c1d54a8a68e39fbdeec808eefd99adbfd01aa9030fd148354dd5898c8290f475997927ade6da0dc2904fce7023c99c963b3b9f399e2a1afac064c3b42d3b37f031ded9286bb8d52b9066817d2af4c6b8781553015b13b0067bf541eec590cb322a6d8be423de7d3b3113b2f5e9c48445e13fb7d1147fdaa566de2f06680b37ef57ad6d4b149638d5c682766ab382994b880dfc812867bc5204b843dec74a68a3a8057906c69bdcdfd4d6c996e93fdb7198a9c59883387a6ede7b3ab3dce26df30a6225e671de6044c31efb9f837f7fcc09ed276b01bb3dd23459db9b649293b70c1d0b1ca14fcf64b58240388ab330b967d72ec06e53aa388bbb376a9a9f007a0a19bd1cd0794e1a31def0e985058fc5d7f1aa42daec15ddebb3c98da7a60f22baca5e6c7a1af64a0f7b73da9ff39ad344a0d6ee68fc2344298f4bec9c3ce0c242e7740b7ff13d46e9b963d8e467b7ac8b4c029188a09c6680eed2adeaf126b3da76ea559e1de04e7dcfd3f2c844368e84058d3fd5e290e08f1d405ba46711ca1ae4ccf21762d7bbd91044fdaa1274c58529ac52d9231abef885a27e9e05c6a0fff4e9e7f13251a40a353bca3f8466e90ce5317c2950817ad81e7d5b0e1e066ea94c8cdc0fa04c956382aa12c4048ec917a5e5f8052a967ccb34cdc94b0d1feecd144a7004c90ea31e35315d64d535d19d0c5ab373189c0ccc8afcbb5b26f42534d46c2d5f3ca4f0992aa167c42121dc8f22c9f67b7341558cd99a41ee619e6a695c3ca2afda320817106a0c46c41c04c25e03c3b0487a4fa6630ba24224aab42e00edd7cddcdbe3a148b1a841b7d8d14d9cff36306420f4951eda759ea44d95048059a0b2fddae5e9ec5444937293205c0dc39ebd3105583b0258d68be5473ce7e7243950a8617667e52318122ca0b40c7906f5fecbe0321adf1fb95e1626347a9d6fdf9e8517ba01752948c358b392ef0a10411ee76d950caded5b34b3bb7a5e956daa35148947c35c52b49d2f7d06e25f6fa88ee23b94a7f534d6c1dda5552138bbb60f338a7d466a8aae719a82037719c502d1e7a79c2a129b8cae7afeae50b7afc55c59ecbd686967183d75e47e1d67e3f6a240029553118685df3ee905aff6ee92dc3c2ac4c6412b4d674432ce69aacd3d4927932e6287a87b04535d1c9b3c814e038ce386fd7feba710845844d816db8a4dbed6ad460b5349186464ff9da58eac6ec2b22774ede8ab22b4a332b4713ec759cd779d2f89eac78dc41c52f511aa453196caad28dfb50457705e60fb3f1ff2310f6d38c4a9cb4a2b96927197b41e28133214e3eec8d5d607969960bc554380885d229df0b3afb8bbfdbdeea025d7ab14c98acf289422c9a74b98c073fa44fdd996b5cc8a0e37ad3f1ed595fa2b75b12968100d06a173225d68795e773eae03c6d354be8ea974cb480e87e0c1a43f06bcc0cb4fef7534c9706abc8fda2975c1b2fd1f5d9c88074b527a32d8a8fae5938f22e96305c554cf27a2d10ee2f1dd985df3e251b012fad42e4e482ce5c39cbb5f185263424e2f89bc3bd96c90bdd9cbabc8cba6a8dc868e762e21be476b561e76bac1d0c9a5d3959d0e90eb44faf4c73c7801aaf45c0a219898fdccbee57abaa2bfe41c7cc66c0d74c9a6669c5db11006ba1fe15d132dcebc8550e50f9c88cf24a53c444da45c5c8367ca94398b8036c6e048b3fd49d71cbc7943b62eeaaf7ae5cae4c53f1577d6eb96d989fcf24732e1803428ae81b11734dfb26ba7720c3cf28e8a7e8353ac39c7344599e6d00c837c1c7024860a44759f7543f31ab28e9bb74491f052a21f5aa8598fad18324fbd0367715b153484c5a559fed0843ee4643938675a67a7aa3198dbd129c0aa1ad6b6a46259157b4d80a7682a3875443142bd03d33d81ae334edbb6f5bb7ed83746e6918c1e7f59fbc6509701f698d94b13777d413ef50b92dddd120cf38c80e4bd465c63483acb6f4a4d1b4e385636dc7799f4818edc4746136142845d61df2da6387dadc0c9297503be20569b4d61b9f3e4507a7f0e468ff1875f0a2a69ee1640bc3a60278418420b7a817c2d3ad99b764e45bb1bb283e13ec6e06959b48d62916c65363e3cd87f925b5bd926082c362d424cf01dc323d305130ba3e9fd91d0fd48949fa560002acb785ecf5df2a0d331e73ed05f44fd4c4f110613b595bab8192eb50ef214eee748fb41dc3fbd52bc2b1e0676c4f76abdb38c544ccb34e63ca2fa2ad45022728d8f63a9a377c9731b62e1d4ca96af77d8f54395d4f0c52ef464fffcdba7ca284597a92bfd9ac3eaf0401740a168419d40225d49817b7ad31422885e605750e3bed5142f67f850424071624801c6594a772e05db94ea17a6730cc84b6adbcb5b255997b17622a748ee9ea4f5fea377d5f9e4448b983d3f6cabf240b0f586dc2e97d32f51045dd8c45bd5b4242c6cf969c8cbd96e1838361147aed8aa0790bff3fc3d7f5e34a798746eef6d6a2f6977d49ffe8a39d4e87e796c58b94e6409ab329db667b787786a485a6f83270220bee87d711706b802c0958999ae097ef8da3f5e3685419e7d369d34898f7a8b09514da6eb3275912703513cfc60022f141083d80c4752bf8824a4c6ee401f4f7cdab60172a5ff001b976a53d34fcc0cbb2a9096845d7b3a5262c910dd057c455bda94453b164e83a323279484b24418a4dbd7614bd43bfb78dbae81674616d8817e40dc126d8deb74c9bd746cc6095930b122a968364f6aabda9dac1ddb717aec5dcaf7219d4cd3449d845c145d905b56389a223b60ca9a948dc58074f0d343b1af7dbfdd35ea7182e663ec0be9625d8b6903167b5aa14048a7cc56f7ecd9d1fb5ab838c74ac295da0c2b9b8cfc489504c3c7004ff026596b5237e1fc1adcb1da1ea33750a97177d5937835ff5b2c4fe0c2ccd982c101d3bccc3306cef9a47638bb198e844f528d9b8d1e1a3d51a7daf20a7bf8477c81adb3f296c71ebba594aabd1bd9fbb33b6d2c5e17b8681053441012039a61e4c0dc1a8c055738241f405b92b83a0cf4b77a7e4766fac4561c41af26b9548e5e994984a9bbd7898d2e84ecdf1f0e627253ead86a7fbc61ab5a269ede1c0150314da1a567e46d8d182f03e80bb5a2ee29cb3a8de9280f198e10cea606d746a0dd759d7097ad740f941628e1f46c50a2f1ed4fb0d048a852486ee562643e249743e36aa8a312115ef848d976028401bb48e0166c3806214e04082e9714b80e96259d332a993b021f52a22ee864617d6b8b07fd21d598f8f8156c87408177bd8ecd0ff6b2dbe2f3ec1c43e8e742e6ff68762092c9e8afccb3062fa64e25449d060115c5bd307383b8fa24efcbfa8cf9f2fdc6e7b7642d40477a88a9d17f8e7887fea103473be360c2017127eefffe1f4666c66e48f23612f05ad4079157933aa0db22d4614c3287ba76d7eb48c17117837d37a93de0ff8c6d9825a899eba609a0c6e603dd1441994a1a7676d47fb65514a2cf6c3421ceab16ed31420e32b477cdbed3d75b1c60b51a5ee0303501068b5af764e1be07bf7f12a18efa3840a2f94b22c6043df5ff6e71809a7efdec5513712f653e422c2820448fed6950afa9df9036ed4d31a7e5f666cf22524a4740fb7617472f3328ab15f463fbbff5de2e3d72da48ba8ee9ba7dae410df65a2fcc1a0916877180ed89ef78418dcc0c8cc78b93e305df5f49a6eaea0675a205f297d15dd5c374755e17b42e1a0f59306a8010c144913396d8b118f67e646bcbcd0958941b4dc404cc9a5e974e1f79c48b271a66df11ec25a1db7fb2197e041ccf780e403668529cc315c08a800d076ce3006d647f15f2e0657ac02ce107dfa0440e7183254f54702b61733cda3ff9a85a00f779d3aef8c529a26a3a88704144ea2262892e285868303f4a43d7128aacebb1998e4343f4c171035135f5d9a76913c8fbee4b8cce4accfd00187b5d7e4b31a744a4415c90da480640a68f92cab38b9781909bb6e332aa2d05d43d2f744e8b7ad99144dbd38127b5923e80dd1ba7ad8f8d38cf60a21da6a3b21b7f2c870eea585449c52b1180c716130d6f6a0d6ddc882052c8f2900f5746fa6af2480a988aa317fe8ceb1e8d8bf13d328f2deeb5d562b5dd8576b65ffae3da59fde72e1785021736321d5b4ed5d28f16aa29ebcb6210f48d45a6209f322b8337cd8e3b3961395b5cdb7f6cdb8b2193df94d9be9080299342b7001f262a97cd1034685d70fcd45b1a6eae3d2d0483872898ad04dd93fbde4a0a410287ec1f73e584c12144fe1680c74e1079a51a365341a18a0eb4d6a603c3ed6e1ff108b70c04671b089979b54b420716e42343f06343871b896fb5eaf57cff100c8e926cc406a395dff7e8368b33a989922a7f75fc73750f1cc73c4bf9f91b19f310ac690c0103af684020c2f66c73fd05905043809bfff73dbf8ace3b55fa796edf6633216ad76715aaf0fa0540562826eaaf302d417d90a0ca443254c47a5d9c8f9d7a32b51dffc9a48f55785022822ad202c7ba7fe12aabf32ce7a8b7662608b8733714d131c7b4ddc2425627f838c17be7e306e486cdc752cb1f3e0610a02408910b532515e8d45059531ce16b57d092249eebde40e182c9528a8f3b0dfd900c3984d188b733769e7c9baee19aaf66ce9e227f3ccd04bc969ef1a1d24b2d197c82b1086c0f5d1edd7363cc46a0e3db82c5a971d1c97bc5345b67a7a342868fccd1b3c648288bc8cb82d6bdd7323fdb1f4da67fd7ac2680a2009c6beaa755b8d56bad67df10eeea544eb13deef3712058846eecd7d0d1099dd1b4d0c8b228e0539aa32a5b0925de4e475b502f3cc807d3c64faeae3c61612b63a3b2bea2999bb16deacc56fc31afc955bf07e9056aedfa8dfab938ad8fe32a074554b9e271af2fb24d16d19951fd9de8504da6a4bc4288fe515e82eddcb64cf51ee5ee6ae144c12027370fe7348e1ed14ca08a6efde37c7aac82513cc1ec9f64b85d319b6179e8cdb24de3391e2aa756a38c3fae1f6eb98a8e2bd1a0074326b244cf9ee8a35649069a1ad0d51c141d315c56d8d398f05424d0656a5abe72694e1ada7b465b2036cd7ca46e4133245b04e992e370a70632b7961c69b02b017c6c2d49fabeb80a4a32070bfd9af662314619c83146c103752b4b123a5386a1909dd52e7bd101bc83132b38f894ad5b4cdaa496133b62a22c086d632b460a66c665957ac1962be51ee814e7d3f451b3ab300c3d43aca1054ff272729a77758102f6d22529825e11c89e19eb23500d801063424f591505d9a8209e779b9fd2a5e136f62c2cca4244851355bbfbfb60f54478b0c2979917300379e00190cf3c41b2ded236c598057577142760b7c127d35aa5db85df8b5547ffd61fcad7762406b8ee258e6edbe079c9c9be0d1276a05d1b76d101e1950dcf60f325a6821a5d34a0b56601b14b95c8c97d767f911e8c0b8c0fdec186ee503e7e4a52832127a9dfd046bd45b469fae316af07d0f0f05bebbbcf182937e18a0a80d381c580742a72fa01474eb9b481a99ff5c8acede860bf6f5cd0c87dd1d62b99c5f132b48ec62bf17fcf524a7f0664c51b88b3f2f6d76e26a38d5a0621e14132135c3ec2b3025be9524a49a04b89ccc47492c35a1ef5635812b2428f1b6900ee7d5d49e353287d7e639caa28f070eba1acc419adecf17ac00e5b881e41fe861dfb85d73015e0428fed9ec14d8ad5a0ef75e4cc787eed422f13b6579591bf53b4f505d9f2757d667d25caea73acfd55b5ddc3a206a583310034554b7a4e55c0262ea92541bb2bed4b5b6b35544c895076c8633c3b28afeefc7ef03cf2b335ec9c828d63817cba65d7c4ee7441d9a06d409b49ca93ac86b0f69a40fa4a6bd106d3939d6096b87be6097077386cb1d7a9ff12a5c2930cde0b6b67071e6a0d4e0cf97a096a2916ac66de27c9d1eb568d633db7cc7ec99b6e113086361e3e4b3145aa1e84edc63b988f3964792d008b40e0ffded51e016e869ea667f7155e897c95bb5cf2a558f631656b0296a559d6b39fdeea88a587968c89ee5ac144c2c477f1de47b21912604728bbd7f9f4a4db8647508f733fbcef2cf448b7f38ea46d73fbcb9183b2db774c32e2c77e0a3841430e96c1936f311a655549cda15e2be194e4dccbb448067e1c115aa50669e347b6a2c1494a5860f4cb0b1108a7ff4f52aa74d2747d0bdc5abb08eadc10d557d803901810fac21aea483d775b718d64b49c7772ab43bf7a8fa0e15e40dc29945b70ffd512c8cafe80c0587d03a765aa2fd2ea3e7d7b37716b6dac7178777601829cb8a108a29f28e5520640fa06599e8a7180dbdfe72fcfb9b0dcfb152e1ae129ff50c33bcd6034c30a812985eb03b7ae5b6da7175f9d30014595bf370b50cf601a3ddc37821251b59114aca97f4f03740bd724afc86eefd06f8243d3a0ba33b2a64e839f5a0d44f51c8254a3812cce12f199ec1325a2ddb032fee1fd547d26c17ecf38776620b512dc335fa68d010a85704422dc26c90774cabadfd72061a1637bcdf8e607704d475879bb7cc253bb33b9bb9453245995a380a25204c44a7fa6f20fcb0cca68ea757c70131fedf5669e48d1a402be9f57b8bb284e7c7e4db510ba6400143a89b07ba65b5430b9c15fda085040ec7350add68063a21fd1026d58dbae324c783bf2b7770f60f621b3dff9e08d3f99bf874365de4d4ec2c29d599b63974e3781034884279c52eba226c6e2189040beb7297173f90a65514a0ad81a7e02291d3f5ffdba034e021fe1d9f96e8f0bc9ac877fa623f361a45624336013295b3b2ca532167991e8a137837f297aa562f37f2a93cb6986e2f1e5264c67f7e2e192c30f9d29174f1adab564639f136fcdcf679178f45def2f8cde1733016d9db65d9bac2159acc970cf4eb35093e65ac801b97f1384817dc00b57527cb30cec79b0577391532dfd269a38bd94b9ffb41db23f18d04de909134431d091392b281dd30e4cb0d9b689e887944784eee6e1471ca200b00eb423059dc24befe884cf15a40d27fb9f55c2c209621c3f6316143e51d5b390c8397db1eac6e0ea770a8d27207abdb0aa62e1722af46cffc7b33f2d3cb98f93e9ea34f8491a8c010f9cb4c959bca9f0f86ac4744c42a35682cb9523b67f02c3d3d02b5ef235fae3356968e62bb32e87dbd5147622bef4ada4b6cc2d3440ed25a8e1b4a9a7d2d2f69445916eb70ebc4e25492a825ce632d0c5ae6852c88e91c5399c9231b1b131d4b1f14ca1e5e6d89b15dccdee05c5f2a56ed31d130e05bac85825f94d05cc16a63e42c3f0c3efb54e506863e7942c667c03bbeaa39677f29449a00bea38d37340ada98460e1d3139779a2b5e2eeb468d74884b6c843a92e134955e57d842e6cdd1489e062ad15c3037748493c076153b9f1cc14592b27d88315d08ba5e2e453f2da159249e15187561e274f07632bb2e9c8901cc072cd72e39340fb9ec53dc3972a1d513257fb75fe924d357885ff7f54e5914e39010063d6c23824503b219695f5665e3b07425a68de92910f1921ef3816366d22e8f41c0f4d8cf00410cf8a8d44624431df3c46914be5cc0f62d8459fa875b000e86f91acbb6c3fbcc156bf00d13b530332d9c68f4b7b1cde32c191912080f1495570df1bc48adeb19000cac194bb9fb31210936bb31f2e2e16bcbbfadb7eccdbde2b5305ca5708a431d811dec34c1e2e6fa30e9fc95b7e19fe69790fbc6d926b68353f829a57e4b8102e5e701c21ba1c6b849fb72753d08925c493ee05fa760132b6f8cc5d453121acc8d6aed615d6ff10d54d3ffe2e03f5bdc08807f1078ee0a913f694a936e9c14e4fa9aeb4b2ad40b61101e226a8edc0eb2237bb44abc25351468947561a6155767c4e4ff3515e8dcced104ebb8209e856fb485f4800fe098992408f3cb7636f22e785490a80d3193b9025124b29d64fb3c74e5ebc153322d6d98555e2ae561cdf107090a0b05e985dc3ade2a21d35def7447da4bf381b661a230a02aff082f6b7e8d31498165260df07b4e7fbe4846f4bfd2ad846af58513e896471b337df2ef38db3b4b55567778ec86747e51dde3f3eecd188d33a53b149832ea45c0a368dca1d2eb629c854775e32b6a60f4ff670f70795ea9a85fa9f0fdfe8c078a9bebcd590b27526f1ca70f87f3287ae6155c21b982ca8343218fe55004526a752217bf065b7f7d1bb79bd43956745b851aeeefbe07d93a80303311a94569262aa8108850154a9bbabae8b1f57e2b676484b572a65847c497a1520b8db46947b5ba9823371be55d79a3e3f54eacc581820190983260a0c4d19f9898aab27f3a510b34b5a22fffa40209d965ecda2a4e56263ddfb0d649867b2b879b0fe5b826f9d6c623f3b7c17c83e74634848d172ea2d79462225c02d273b70a7a11bc43318669750ab71a8282e7f01abe36b47c91c554c026f6e5e1dc1befaddef0b5a48cf77701a4fdcc0158c42755ee176e4e5c201452430aff83ed160e34feead9ffc32e6020f1eb434ea30cc9c7130b368558d92e308a0bc408bc1e7826044b239e3815741f3d3af1cdc4702913bb4b614a321701291f6688a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
