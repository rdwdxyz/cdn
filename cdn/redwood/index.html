<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f69362088a97dc94f5b0cb0709e6f386e224ae773fcc3efefbd272a2b5aa5ced0194d720b5f13d55fe9dbaf91219e8307cfac8a3297ec2c9383ee38305b17aa0a6f9a84f8135f84993ad36b934b1317eac9bd973f091a5238b8fa7887ff3b2a4bcff75b4b68040a45e61325e86e1f3c9ffb4de6f72fa686179caa1494670fb70f20bbaa3bf587eaa84d0210aad0bf97f48946d78c6c5998d25ef736888e7f54b485d0793680a193295bc21912547745c5fa9102956cdda01de64032c21e7845a7a7b1ba5f3cb0bde1edf44a6a1a1a885b9c07e84b724c7ce772907a9a7dc0209ce58a4906fb6d82b6aae36be668fcb6e0a6bb44022eea25a017fc7dcf1039f30271f204ba20beae3b4cecbbec3d14f68207b46ed14284bfcc938e97dd18b7ca37a3f599b22b95116704d1cd4ce161df1f6676e3df57a10520f0c82dfc55d82545ae7361fdf475b297157a4fa0ae8dd02b5cc2c80bef554e923de05ba282d4c552743cfef5dd715668106e4aa7bf249b29ae7e387b7e751da4920c954190cabc143edb67b12706abe2e7fc83a1e18057f116cc52eb6f233624188dd944aa1851961012abe1385e906b00de8ad1a3e23594901a215ad166238877027e65138332bbd971ffacac6266f61dfb1ff52bec11c341cf4bb5c49e07256b7e5ad8f118a11347d84bc4ca1f455baaf2e26fa90de64cf2681a2133a6093cc8df4d07882fcc5a0d09be3148b83e7a0b049824298b4be98d7408061d0f6cd20e83766d3b4020fcc2528cdeef4a0c56db957ebf33a64398fbc0b6e4840c5d0bb8aeab030068bfab1c4f11eb201fbe4a7ef443e800e46e3c6872ed5d3288dcce23cffe4b86d930280e96de58fa94175765d8c1fb916916b21db7cec8eb323a528f26bc351ecbb12944c0dd84600579cfa933e881793f82d2b61c8f548f5e03b81a1f0ea449bf6f21798f602856d15a089e1136ee365f67f4e34528a575027151b5819d972ca3de0a5e08b71335162223f9943d73d1d3fdd1578e2568698824b4cb783934a9f2a374080e0ba4fdeaabef30b41574c127c9c0ba3bb4b33733fa0623fb5b31955486f899833a839c7cf00bf3adcffdc753b82dd8939baac6830edf7e5c3a06f1577a8d77cbb8ad4acb301724633da3d190e5c818016639a3083fd0019c4a86ddf1fbd25bd6e4be8ccbbf5bae6bb41434eb81cae88e2e317b12bd2153700d555c36fa68a116d609c8309ade52abcb8c6d4f9bd2498066b09ee76bc478baa1876ce8655228ac28b307e3df05e6e6a72cb58bc3a729d4816d820a2089fa50661ed42922867b28339f08f1bb12f22cbd2fd75af7afe27212c37bbf6ec9d01ce2ffe4a578560dd38553abc4617dd8baa0a252a32343ab642a0a0c68e48e07cd294502fcc83f5baa0804dee34e9300510080ca6b9692d256d5581dffbd0e6c1508ca1931a5a280e0b862ae479feef6ed1b453539bbe1076276caeaad94b6daddb680628559e7402acce5ad3ec26b1d1e7aeb66f99771232a9bac92cff09cdaba2c329cc295ef333ad2532b997c547460965f64c2eeb416c78a0bf82910af9aa24436f0eea0831e168809f9de2622bf338eac210369a71adc4b0f8532fa1eb899dd74e83858ededffe454a4788caacb783fde3a538b9ed716666bc6e304cb4161539619e8f723333afa774d97e78617768df9131145eb21b07cf078ff2e57197e0836535a46a9b098ca7f324b7474db9d45a11a59140a5e7dd6af1d152198af0631f4281f88a11044d7b6239787ec883f0f5089e6af87886bd53680b98f259d4070a7f3b122d0836c79e68bf199f7a3c1bccb3553bde578047941c7f9822ed0bb24414f1225f0b163957d6d517f699d58339f6b99c725f75ec4f4cc59f06f5b51d21927d8be65a817f1707a84e7d609ddb609a4258c26fe87feb5873937b41860d5e66b617855e7c813ec813ff7d0d5fde9a12c6d06527518bb5de6b5c19b2895386ac35894249648a1f0bc21119571416f3350f609e9689ad75e214e2d66a72be4035b7a2bd1e7e404e30ca1c3fe6128b0e1881de0830abb46e432c36dd5c816626105df8dead2935a0dae9034ae0734ee5e5bf2c3a4674a0f88279662e182614b287ace660237afa1c480d9dc619f80c5fc26bff59ba42f22d249c020638db9273fdc7a36406f6c64e064ad5df50ad5f13d3b29bf4ce33c4f199c7361b566fd6aafe8d45788b8dddf7e18af0d7fb8318cb086ace5860061e14a7ade22903b56521373bbbaa6bf0eebe4af823b5111c00e91d57256c2a7359d7836b76745266825572f8d05181e8e66efa1428c91c06f75b99df2470c1918fb5f177a3ae5ba7b9e6918a3c8faa600d6fa2c5a5d691de0da5cceec13ec00938074c6ebc88908556505a373328fb5b38b913fd771c9b5b4dc61a87317011431892b96132ee480b0d92c2956b457a51f248907f08852b77afddf129a245fa5584fa373b779bf6512301bad57ac34ee59bca899a6f73c02f3f3d3e769c7b75b72895d084cdb72303a49c559ab47a734c8e9ac9196f42a41862d2447e84ecb26817093f46f83c888fa61cb99899096b57ec26edb75ee61cf32565e98cb1affd2f4e9f71569a14cf00a50b031fc969fa5038f7fbf16bb4c67f9f2918d5e2f7adccbbe5d08a8f2c1b8c9bea8b4d54295b8d5ef1fc9066712b21f79bbaf6cfd589bbe023b1b114781e4fbb3423b96c1f886e7116809aa251ec390d8d8cf753d03eab979bdfee1ff11e238a98de56a72cff455bcde06f676411604b36c4154af8ac9923e2a447226ac03c5319df0d539e4cfa66ac14d329f5aa897ce5294247004c7a6485dbd728a7d1c70294b6cab5efd011f9713e686f18ab30acb06cdb6d177c77ea4adc91ec8331284ffec6f816cb544bee4528fdc863353ddc90754fa5682405e26dd3e30d00bfbeb9ad9e8da6932188d1dc5c6dff891d7e928eca9b165f526124de8d000fc861870a6d766313a0a560c2d62c5821828784514d755191ef4d3f043ba5cb82f09329fee0efee85a9d8ccd8bdd2fa19edb5e0a12d917a87972cc7e3a09c3d30bdd2a463dd330aa1086a27dacd332e42906518733e7bf8c0bd5106976458bd7964520add80e486bd0ce35ebe779184be96a1ce8e296b0ad1a18ed3dfdc767e443522daf1b34c8f7e7289fc5f91335e8223738cb41ac6ca42414aa30f92bb94439e181ed704abb57436ccbd27107409c5899ed24db5ba0df0557d15cc69e0223d5bc2ad64211679b92683e09295e40d695026bccabb14593d3b37aee12fcacbe0996bdaaee628a4689a2eaaa75878a56e950c4673df6e9e856bd2a0ba0519aa2a2a733d109746b796f1165a75f43958378b0c49ba037c8e562b1da556437b4e524e6bdafd505f427715a247b0015513cc87d0d7810e72d61307b0f9c0f9fa813d2293cb1f2827beb53499a79acb547e27b252ba4b27358f8057875db0ac1daeb633af92ddce2255ad2e709762eed7db02c4a4f16a418f575cd814ba7723c3e9e1e08750bc4354beb661772e4a50549959082c522f970bfece2aa26bd7d55a5dd97f74cb11801659811b4bf81547c6b37e843eb3f8cd6d2b6ff20f97a8c917e2b67993ed44db99473319e10c0382cf1e0b4084c99fb251f66385f76513e4dc992edda924d1a82168868c4d11aa1dc167ee6b11b213d58695452411183a66cde702b6a741205c0f77984e971d292d7ff3ead4048914c9b448b1984856682bb55f2b3655fb643522ae2d300e3797bbc0251b062713cd25f6dc51ab8457185e94a6504b7cad959f5d1b77d55e2a43bf32256b92ef84c5c58916632fea34fe77b1e491ad151906cb15b5d18b35920b1653bfe6073544b5867a7174d974353d1d09a528a0ed24b9d5a699c91d46ce025dac261de734de94aa3e153c3baa85a2c327e61da85186a4b0f23c1b69b526c1d7a4c30288633dd88dfb976c636e3e14119f2c9844bc6ff316dbc5cbb1c6385d0669b56150e209cf255ecac0f2054ed1066d5a75cf2d2d84c893604a755ea5030d22db5c2e5e21f1e2331f089e3ac1ce62760dfd13ff67306d52dbe424cd0598b90bc6861e8634d51bf072b3e75c8d2ee366809b552f3f52f277fcf6f027def3cee04e2239aa9762b235c60d2bfc982938c8c5780f8ba79f7b627271da3c1dc6f700b19235e88c672c3e286d5d50bd28b1f854189612ec3bb38d618fa786567c12b03809f82b232fc98be1c0089c3791f65369f85919c25706e24db72dbce66193961664fe15abc6ffac9be0961abab5e164a549a8bffd716aa847f62823d0a8eb7aa65fd935057837e2017333bfea83842b20bcc6d915eb3c8080434e45ce8230e242a8fda15e6e386acb61df1c507d5fd96b259b181418804a31d93a2ca206c1349742f26a8b00c06ddc086f74f718a5ab065b6267598672e1c5bedd678964c60e50c2b76b96ba59eef0d31313fc24a729736db6b30bc9d857beca62c872afad5c155db0a11ad98e9be1fa87f9a924e22b2f0847e9363ef4550fd0195a362b5894f39c096ede8a2faceb299761a227b2538b0a228594c0f9ecf750f2eb42c8a2e9d9f03ed8cc0dd360396dfc43fedec4fe2f0404859df774741c1db19e7e0bc7db02dd07b0b240d48c5a87ff51fe170e74c53d56baa3b2879aa4b05cc0a5126968515a432095fa15b7498d7d32e93a56fd71c47b1b230369c07c97b5bfb6046927555a41ca09ec61ed55a65eb9e614c161711b66e0f1105c7cb989855a8dea7945132a8317c99dc24918f441c016dc86d09ca6609b12c739abdac2123adb4b2cde05891ba02e9eac46f47e8ecad3255434210e225f3b17f98e5cf5f5a3b8c692c8617b59b4404a527876dba63f2f7eb25003ca2107886bdbbcb1652aff543cc4356e51f1beafce8c74211fa924c667669d1bea38b6cd67a3179853798778e86111faa03bc4584e733425ea54bfaf997ceae91809982881e25b1e174d357efc9e3fab80e9a1ef6231d796d0abbad56e5c231b037894b0431017a6a9dd9d62b4051b06f9ac74963802da47c1cebbfda639b6a2b76ff91922a42168d458a307973729e9721f878e32cd238045bac8069aa15e8345074767e81e3f6cc472f3ef5e886afa639a47a9f8ada98bcdc72b343084db28e1b2e4a102a3837d74c4b12d01c5c20cfb3f3ec31d6e365db01f7f4ff9194e20407ae1a51c506fab28af9e21dab6a90dc793667dc38a4e55155e1e809dddd8f6d4241107c9c9d73d92db491573498b4f40c83f169551e918eca4921a028f7b2d2f2796ac29b6bbd105a5e01a4abfd8fbe01d66ea15d7d75b7839a28853f0e44fe8db4515d6ce1322cc86049e9d10f6b251fa07b04c8722272c964e67ebb99e1a00b548c0c036e80603ee618023e8a7e192b959dcba0567ceb57df78f0972724cbfbe72287069945744ae0541c868903f055d63e8b2beab314c0e018cd6cc594f41edb3066f244d505ba68324745b907aa1068f8fc20efa1bb5fefcdf5987b4f55379bdfa05e31d32481711fe1633867db4b4e11b0e3feead77f96af9da05717a74d79f8519f7a4367a8c176531500b2d90051581e75bf7f35af0224fcd74da1a8f5debc79b5562f4b3e9faf9ddc3b033dd8dd5bced49c258523ab90191af615abdd2740752e6239226aace4fa1bb3b6a60e24dcea6f7fa54fedd10edac97c54fe84fb9a9f4664cef3d656dfa5acbf0a39f7c09bec0edb4650f152823ec5091a3d4db6acc4247f19f14921cf9cd12b5b407037469121678595cb3153e64f7994b9191db7a7f082ecaacec7f2514fe813a403c591c25c8279f874250f518cb5cb513538f2403a7096b6633c64b552c3a0f1b4f1adbab281ea26e2dbf6483d4f349a82f51dbcd0fbac189fa1752549593f0620f6f6b17cd98f7fff89514cc118677e601f7f736f0195e0cf21c0c2c49e6434bce8faf1c250667de873628cbcff18c5241985bb02c4c7ac9660bb9eb1db5bb839f4e01c1ac3baec5860a471373563239a4433b58caa71a64a0b0eef950d19800a054efd34300d7fbdfd96075245ae6b04c29ba97ccf4e87cb0b4dbee888397b375468db7d0f3eef999df0479757fe76a9726c0d1a8c9ec9e5a13acaf793c6991a80454ae7f7df8a8d12b0b97fa4d43850f95c6fa2a135b5801a9ddb27031b00c01756667eceb5d73dbfdaba34080e8d1d190c8ef1f9de9174aebeac30083e5414ce5ed0491380ecf9840b386827866186f5b38fc6fd9000e105113bfc68c77c3acd1c57b957be59d7b07a738a17d67a1d8e9ef60acd42a819f6c78ad17285cc0c848e4fc30a29adb0136815dc4dbeb5f2c9afc33c91b46b13e628ba44c2523d40f8bdd7859589365bf0e2a7e43f9c39c714291a31947a683b0c9254a035a28586f4d39111c996024edafcc3e67e74590acc203c25144f305a226a3678fc284ef00136e383e3aa6918ab5747e4ad25583db75fa3126d3415991feb74f0ad05240ffffc60f0ccb9dd082be5c1c824299b42a21ec9b7e9b8fee14daa22cb6caedd8d7d5c8845d3a0ce1c63952f4c2c30fd11c7990b8eb9e8281a7ca1ebb63c52889b1feacb17bef12fabf77c034411570b1117eab68083db2957cc196c70d7f7f6a7c7170fa36748c73d6c8a310ef5b6367ff8d646e75b98470e0c42a95a95809ef3d9b79146e0e08e1d30e977571c2bac4352db2ff1a0bdd50d7544893ad761c8145614633396edbd7045260ce2e51cf85a66903d2654ee8a552ac61d2fb9890d5788297dd745e7130c7bb425c16b3bb5b45ad91c06274b32af80b3fb5010bc4dddbe0c2bdef01ef5eba403a8a0c35fc02d5ee7c2fa379682b0974582c6b1ba1526821110e649497f616ea4bb479c3380d17ba8a5075d1bd40bee4a92e06c65782829305c0e0005f253637f6f3c0eb8975caa6da6148059a12fc8981aa6abbebb3f2f40bb5a2bce9cace27b95a8bc065121a44a6360a7ad2a22038ad380e75c440a6cf29442bc09fe026c2ac60d3337c38339a2a7f1e14d30082085d9860056d3d98b399e2f8bfbe74867ab04fa57972dba3b9f87961612901e40394bd300b1e8a89c8215c5bca019ee000e3f65984cf484a6e94538a44322104dab3797c8b4333ebb6d2303248e63a254af0a3bf45b0f5f6c0ec4325e9c02a9475564019d1107e18e405bd75dac503ec2710e6fc80fe3ad225160734b1ec8c5d1cab8019b0a200ff79ea7ef9f3880f2465f5596772e49020a7493f697d386559a88e4265dc78e2728b942f7095d981f04bcab8463bc3964609ef7df6fd34bd1f4e0ee89d3c6390a86b305b2da74ac8f44e135ed0ca03347c3765522c6764790568e78f7861e4e724f765691774ec7319bd56e24a3f28e3c5b5bb761ae107c5c7ec6c0cef6d802be322b9d529ba7bd63e91d3d60de5e25f2ef8dfed8cda5f6afce71a32778491422434ac951952a2686943a90332dbd3558f3469a9f7c3e2e546d1fe3d15fdd64d0ef4b9effceeca119b83d66f688108554d91d031835ec89a958da3753d0aa541416d8975d745dd2d63ce770c13a2590fa2cfa9ebc67534256af36ab577a4e1c80a3c40785358115fb14befc7edf47ee6b03008e72f8ec2f1a51448489628f7f66a436e2b9175c16894d38f28f069e18fd0133b2c1315dcc104e37a042044d9606359bd7a50029d3285b239b6801e3f354283011488bad6aa07709bc732a0016b9e2410c297c9c4158bbd118f68de270340a33e035187bf402adc78dc8be5aed6fec6c5136fe3783f3982d4d2d0d71e0840b4cbab312c532a9a59bb665ac151f1ffae744302d3e3f8ad1587851d50173b2c3d1fdff3a7556fcf80be0eac783ba22ea354ea04637bb30cfafa69a5927ab3310f0290cdfe1066514beea916aa5ef3ee1a467903c89cb859f67e3827c299691a27d4f4eb49b39c650af3d4b8e8a179ca726293f20e6a2a93d4111a22a29582b1ef96d62f704381869334062293951269d46fe016662014fe6c316926fa1ee091a0c49a3f767dd57062c712597915e45b76941ccd5593d89a39d242f4929b1b386ae378a3d07a6429095ebf79742c44cd601c091221eb2200c381e817cea0b4629ae2173fa7812a7a6ba9e9ba99957aa54f59792e75f2a7056169ba3e304313d6f9ea841452f0509973f4b47284a8539fb58b2340b8eb2aa01ea047b957e580c36e84faba2b858ac2eed1d62886c06459257340abe0cb359318a5dfea5ca653a6063ff68ccdf141cc67bd5e10d3419553850dfbfd7447f6f477bb6c9ff8dd0b8b3d7d979fa04a753c6ccfca748827e780f9f25c7562e593c058a96b1b466ea9c9ac31825d7cf4cc09cf4e5a1f1024da250a98ffbc50981a1812305fb504d1b3818954e1a5d5dc7704c057c217c6c76f5af2da37c5029d2177f947aab2050ad9fadba936e58351a3ef1d920916477fd355dc6d819b667f02b159cfac747dd798e7d3a55e181b05437bfaeea0383c3482a57b94f0a6b3307db7bc6f025f06c0348e7e5e8000f9abbbc279283458beb12f95a741edaa1f03c82e244e3d5f5f1bdfb360d67fbe298aed1a7b8e9074146077faabb81524c561cef7076fbac3d3824257ffcc15a2b9672a84dad26613aa52dc39a1f50e33b8d21f5d3c34ac52c4d7617881a0701fe3c0e594f9585300db8df8e262b6490b881dbc8d9b03ffc20111ddc909a13c79a4a115cb92331db770ea2e3ab8212f3067662f803ebb7fdd5bb0a6e287f47970d89a7feac0e88571c11ecc681a6342535aa66b667062113a127d4283f5cd0c70ace278ef5131f2733086c975f67169051b7e094a17b3e85f68170a5f1f836296c457d64e1b73952224c7ab0019c460a133f41ee7bd7bbc4619f041db5b9ec86ff70f8c2040b2e6afd613cc1d937b25b093bc21308698fee1b62865f7a46291c8992479ff509dea97949d8f53675a589a5787845517482c6a1522de9589c9943f67aad93e1f2c93feb0c1e513b6853d1ad91089230bb92ce29cda5acebc47f92a5461205549ca24364e4b38c5db010ee94aa9ca3208e3cb2590395ee02be099789ad33ad65978ac997735c956c6d878fd9d309384d70c2348b3eaf1e42cf93cafa94491d52c3a589d00574c400c4a0e04d0061209288228370ed6f84a3cf0c32008441125d9c70a248b36cc107971f762a08e526661f0b19bb363fdb43f34ca73b9eef73c901de33b0459b80a0fe4eebc3be526baaf527373d40be7386eb6b26467cde7a87e30433a3e34a2ab43e92ddacaffbdeba47cdb332e3fb07a12a5bf9d3b6a8a3b74ef44303d3cab7436f9344157c7b4378fddc6ae44d0238345630f8f091aae0aa2eaa94225d70e76982a7592cd219d70c69a38b54a98f89e81a9e3e274e17e5a5e0165cbd75da11b06bcb917750234e8c0db8f3a953e9c03d6eafb7f93aed1153ae6971d30480a46b0d558f127f23e60db16644a7512fd40419b3f37751461f831ebd70dedda0baa27dac58d237e5fc287d5846cee325ab7cbdf86ab5df5690f01d20bb1b9709127175dd4cdee936b588849b12624c8a1de2c843840e01af50030b624c97bbe8a401d243f56ff88761acefe56d5b77480b32921b3b0db356998cf9b64c13703c6161a66a0dba290428abd52c8d23489201e3f3e20450c44b496b408b5a82add7b412e324bfb9cd82e141dcaae1c735b5e0026203cd8b0492fbba68ec154f36855ab88e794fd4f1e02fe08567d14790a69370c3af0d7b0625fd7fb320051337bc6aeb7b122e5787aa768017e8a6f94e4bb0415d220dc78c8bc5c044a866c38130135a5f5a1ef4166f21515f175ece1200484c22b0e1f7ae5a88c9fad5baa862de85907265f6100d42fbc5569a1500b1307f6d53099a5d212067f35d9395c449c8b8eb48239e570fc51dc9fd2949c3040ece43fb63f36bb6e199a89b9587c4d135b6e6ebb90e249a787d937282f6dfb74fab3330dfdeeb46a795e6526da3d3c9052d4f6f6147b69f64b247ce9f355eb030ef651cd9f73ba6b3892de6997b7f7b20cb1d2fc4e77346950d41bfeab838db96b10381333dc62e6cfcf3f1632131f2c02b9e01d9690f75894f9cfc7b5f3b2a1d98e3efd56c101058a4596633d24e7f928aefb87ade842cd478da519418ffe37afca3289d34b609593b7e0fd4f0ca53220a3d7e3f1c6dae9b53a70892f6bbc7821af9feec40e74f08894e4be4aa027040cfedfbbcbcb20ff4fd78fd08e9aa42778b9711d58fee594b62067904d6377f1c5b99a4d02b4500f633e06e211cd428b200ebe4e3780db2a7067527b7d3d9353989392619503fe69f04d2e58782b80942ad8496d281d6aa7dcf5684d75cc53ca35fcd41875505065ef1562186a7a48d1402ba58e71b98515ff30f44a1e36fa815e0797da490c3d1f240b2b788f5d85717dfe9c7ed704c93521b042f92d6f7063a57e7916b007487fe858eeb5740657c23e58f9eba711067f95f3b9162899b15cfce2878e9f5fcddfb6e2d663b454d91710733b47a0a7e743344d7d584e7a05d9a3ded9a3a5b6e543b01a9a143278c7661aaa19b17ecab2ceaf47e693b90fd3abd00ecf67f691a76222ae4cf4f387ffaef9b8d35f3d34bb96de626d55d1a93af2da7d39e29137a90b7b883ba89b490b23c80bc1c2ae0647552298fc3bb719e61390c8ee39863892bfa1e2e4d8eed9fa9e09197a04f262774dceeca373922b7ce46661cff16c05aa5a9e30170116e55e1bffb0d04fbcf05077c05d8cda9ee6c9320cbf3702c327c840434932b15a6bbe0d0e03d11bc9eda3566a239510498d74c624a35e3d0e496a4c05859f761d7737b5ee3072294016d5f82f2c4f78897a177f6b8c559b81417097f34a51644eff960907f8d2ebd469e8a88946c1aa4355ca8bc60fa68e768f93338361ffdbda6dff3bb92483bde93709c43cd23acd0c488d2a8164a61cb76d5454b532f56efd9aa001ad6ffd9c25f2af42a8aa0a2ee5a8bdb780983b952ff7fb65b5a35889ac968d2de9cf907e0a5b6a5d6250352ef9bc8626ca9ef1694fea90c5e194170937585b9192c5f568db070520023063b9dfea631597c3aa5a8bcc9f1b30b5071bdf7fc0cc9c9741339cbff7dfcd11c28df588fae7bb28487f4f13299dfd61d6a0bf86e9c9932eb91af9bcc1d5226b9c98dceed6f553c0d4656e22d67770564a8f167ea1cd571bfe00363cd97c2da30048b13147084877f2ae255208e380a32fe6e7c6c9b2ee3de1c67a7cb1483bffc7c4833eb1b53799fcba9beb4d686f81acf3cf9006c1f555d27279a0315fe22e7bf2208dfb4fc6f4405f93a12d3ea0438d6bb8e0938aab0a0cf8a4cb777c2d6ca530afe6c912c3d4ea6c34af1ef6e9703b8989066e2aadddc07caebf84043972fa9ec55da8f0611f8fa7605c7113a1b5780731c9782b80abc1e663564d9eab628dc37cae2dda9373a950bc257135bc1528f7f08aa97fd661589316d403fd3fc981c371acaa24791ac9fdb50a74aad1b3677cd6fd75a1dc0d105c307da22c886612e53749c66b453a2fe9eb7103c5e6c4054f021032da257c52a7be1614d6bd2cc21a4512bd35c0cb0e0761dcd9c4fd1104144649eb7e6a99539d651c3200d4025f03d197f8a7095ba557642d85fb77eaa9dfd7265773d32fbede51e1727853699b9e864e8cd0fcd34ff0683adf38e842b20f77094dc3e80c820b638509ab0f2eff239fcae0523d25a053ee2389af983059d14b8147106f8ab428c72ecd500a7ce9a85d9e4747def45ba5165d11352996b264839313ec0725e65b4e9d55040c4c08cc6382099e046143d5619cabb62ff4db7ee768cbf25592d5ea970253eeac07910e327b1ac3854e687601f8c169b1ea96bd9df7c255d061ed899643e09962ffcc2940a591334710e273d04bdf33096d57d7bc8a2dd3feefa2be4a585ccd493d517caad0ab75b2e3a31223e165f655cca2eb9c43f7b9d5acf53f09ea060593af38891fb20e136a034ced9078b92107eec91e0a5bceb6fe2b0ac1e29cf00ea7d1682867d38f4782b51f6eb1628d5f9a454a7486af15126ebadf83626369df66ad772f8f2e5290731cd366585017b260995d7823634ebc4f735cb2ef65fa5c71f29e6bc73d82b88ba90539029946f1b62ff49e5357c0783a5d5b332fb563c2b06b69fa46291bb19c68f6db79aa52cc73e08071870615cadd331b51b97d36d7019fd80ee612ff39606ba7d4690046313f44560ee5e1049f1cad44c534702cfdf069395c1d03681322af291abe574417a40e745f3fbf9798dc00e80f0c046a29b01b7d3093d646c539a796798f60f6d5766b22640bfbec7c983dbee9838923629076f493d555a716a22ad69939a8b63b8f21dd8df9f7b86353233ab7df51c1b902a5928af625b6809a46499c58df88638962509754a330e05b443b118e100a73fb165351e1536b334776a6720568f3ee5a2c9901b37a0c8f5b625b7908c21552a232794106c2b75503e64876e1fdb30595e9dc6bdcf9a18d7830fc12ab5c6312897c2bfed826f96185338e9ea1b537fba86f4204d48d62696b77d14778a77019714504f5ce2072aebe812c7c1da46d4d59187c3d077be584d7f810a9f9f3e5d88ec5e227816535f7a7976ea9a6a5cf9d144fef1422e62b459d134ddbd4b1e5d756eccd62f2c823e55d1e435e6d1dfee70b5eeede7dbc671e0eea4a1e1c4feca0ab02986598f4eaf437c60d3c656414b1da237ae0fce6f9047883b2dd7693edcdc900fe277cfcee40341f4fbf3833376cf483a3af936b7373ccc0c5140d64a91613a21e2b983e4cdb51aae58c89b34b2583e8ef13af31938ed6051588be77f79c4e000abf86fc43d3c31c6bfc61538127a474e0fdd9cd8c3dddf2291c57234c0502d6213d979b8cc6685fd33a64fceb024644def4ad4e5657f84f2c230636db78c41a11821b4b8416d38758eb1757d2ea6de0e854d653d312019dc090e0f993462e9ba85b5123fbb35aa63feb859a6f726e34c4e64883ba471c1cffd399284c0b2ab4f5bb43a3874c7c3f0dfdfb7f8a85b804fb5905de7c4edabe59a6a0cae81fa309330f8bb49bbb5ae7deee2c52a03800795f3750927cfcc09ef8b434c273942d7e0d4bdd677e83d394eecde7f7f51847070e0386066e96818a04590d8c26fa31425a641dec35714acec17d93fe5dfc2c97f437086bc65333827abd98d9953e0a0191d9748a38ee6c17a76a9f7f41f9a4e7caecb76fa81fa5e522bdfb0af06ab14102952a4cd86371f6cdefa01683a2eb05b9979938cadee83f7cdd306e6e91e9569aab97b55fb8abfb5a077d3362ba6165854095817f2f2208bacfad339af3e85f7e7e577cd2da513256da1e3cb3d70e440a818869d7183f121a6bff72bea679ce75773a39ab024b08ffff6c014b90cb0424d8864ffc95a67993c79246735738b5dfa5fe6270b2ea8ffc9bd46a94a57297dba808a89d22e56c30a41d06482454c8fe2d589f4a9bb648898e7272ab2cba7fa4d50a634c0ceebbac16f05ea8ef9249482dcfa57549e1d5f078cc42d05c27b439c4bac726df1583af14550a21abc66eb3d7802e414c3654c7a18df54b52ee574e4f7c558b883ea3be7ffb81c8fcfedb1e7ccd4d122b5ada2b2c474c57e1c59b71c9e385981c28157c83506eef17c5dde2bfbeaa971c0af7f06f4fe79b0fd943ceb4285a95fdb39659f2bcc4387bcde85264edb742c918c5a2eb2c5a73473fedbf953f1206db944dcc0c5df02344f45243da967716f7b235622fd64c680e95f48302e0bf2ea6c9db9782658be2cd5889c8e9e7bbdd70f3da54e4f4c2f2e47152743edac55a17a7c1c66504556c30b982369fb2bbab6f8639e5f0f5ca398979d269162ea768c2dbe13f7ad7b39717101f9c80218ea6202d1bf81cbb9f1c240e4840a8cbff2c7b1c7603c514528d17a6975db00dd156b9b6f1f37272edf79e049634ce15a7532226e85c49361ebc046f4f4ea987e02e04da43d3f17878eb2a77a91af33721ae5bd6ae5995f6831b25ad0056b41e83d8e519fb537c0ecf59b5a36a30d29bb5a72112aa12e9c38dd9ccff4c067415040e42bd60e2508a0fce235c278617bf45f2e8eb0236aa8b6cfadda531037014851c1b88ff7a130ef21d977f8250bbeb69d2a3d4e0af275b1ea77f3f524457013c12a5f49bdebaff85256d8dd3def7cca0127ba28ec5c528d36478e4a2d795eac920510b20dcc58881086e6f35b9c0b1222ce080af4364da8e19c8aee265afa39bbc86c2e400a2dd6c4b940fabcc3b96efb3ff31d4e17863d6b42e0f373c007932c23a6bf45008c8eaaa5d3e90d32c0f6d32156420c3f84f3532ebee2bca478b4923fd4ed6ca227471278d7e67f04a8321824967fd18fa1fb1beedb12ca4303621c6fcde6b97fb9650457969edc360ed247b22cedf0642b759183907e80c4f380d21b56d71cecda07e9a44f63f689762ed758c1c96e461fa2867d55b25780657c2c807b7c233039a3a864b3e8320878c46bf600af1bb011cb3e7ca723eb6cd5647769a7880f4226bd5e5699e8364508b5c0b39990d27d6ea497c158227d6fbf48112faea212198a622ca60ac95d86bacd15ae0874b441a8d0124a1d53e5ce258d16a44ad360ba5db5ce53199d9c75bf3d4f8b03a97d090fac5af4d1e91aab0e099446100c7d4cd01e88549f2998ed635265948412504f58ee325c6618c91c8ff2e6ea7b83032cf74d61bbd1e23ba5e86090e2c1be8acab43de7e6f11a5578420f7953b502cdf6a0b9522754a39a15efb94b8a2bb1c13d65815f11c4c6685cd9f8d7361559d13a7ced9a75cc3307ae31b1e5c739015ed4cc0c5b7afef034dcffbbf852a3495c0908212d9f27977567029f6b99968f9f1412353e9aedebe9f67edd01d43cd17084c5aba90bf50c2ad03a2c28a5cfa057ef8b14d139184fcf34a979f83c64d133f700be545e5039dccb265990e37cb375fe6dbf2ea0bf466e1edc38525c61538ae3688fe75fcb3eadb4a3db9d9c139a2a978ad83409e62850db69414d8edb0cb50f3b40e81814aeb4018ecb1b4059391bcea406843e1c5d48765e63e5dbda4761b79ef421ad81288b776eb676c0b3b2c0be549a83b005579ff6a995e5f781a5ae014d929a847c932de034c5058b7a929e7ecf6720f6de6e436aeeb7d894db80e15d241fea6dfaee034cc7db951db65d52016ebf898f41bc13800605d86de3902bdd570038d7df9db6dc2914ea9f28c7de658b89359d267abf730d87050407588fbc7618d860aa4f7d1d0795781ae89cdba512df62f2f5eb055b21987e6ec8f2552e40f94f3ca3bbc39af99db1378bc56741d11a90bbd1fac0a07ab9761f8f7bb004e37a3a80c9d1d68b43c98ba0c1322f17a18951313c701ef298446eff1ec78e7a5c99c020449749bdbb819466069c4875ff852a23c8fc3aa0c55f9970e605a25f23e1b263a8d8890376fbd2b2d197f8fb058ede367b64807305a09f1528eaf83bd074683735a5b4ab23d0d88d3b77d64b8c498ee2314af3c3b3fe5520c9e236081feffcd19b5657a3ca2ee94e154879eee5373b88854cfa5e280d70cf0edce6d24d639771c353115fb0d5b328c323604eeddb9e17bb972fefcf12c7b5c14903fc8dfc57b4d33f86b541a89bfc19e2903fa11a07d3152ff3e871c07a0b316fc9d4200b402de12f3fa7f9c20caa938bf6552947ae629d18e957910734cc0a754e807bf720f5a2d1e492310fb13157d23c97b0e08c5e28fe1598c64cb9d6e6a437dda9b52509d6101dd5819ab42971b73991e706e9c33a51a9e480faf50eb7c3b5c6d34f316f1117d034ccab2e37a84de2b4c018126cbdcd53d3c647b101dce829f5d0a9a20de77121b9149efce376d2bc7a83d1a24d58da76a75c4d80f82c482ad81ee46d739d6a67ae97d611ccbfbbebd398017a4d6c424b4bdcf84735f04ecf798797825d051afbb0d342d19e44e6ca6d8ea61e5d2f0a1c9f2f8b9911ce2dc268588df305a3ab6e608100c9d152cd24f364a4c9ee5aaf3be5a4f4c35eab11e7ef773b0b5710488b33f4a4944a1763b7edc8d6a04f641024723105ec596b58883f4b6ea1264e04739cb685b3cdfb53de4839e772607428a99dd46480b63520a0630f3fe21a5518a20b027eedd511137b1ab13fa11d0e23f3fb19942a3cda013830f9c8373bcdd18cc72e50484ec9258632d51b4f76cd95c50397aa1a4ea63f1f1c75a79551b9ae38af16fe9a67e5f2f4476178335989a37b0a64200932747971653bfeecba79bb52ffaffc8bb1b3f486e24289e08a9c40e9c17b13f403570ed5f60789468353eb27bdac4741913b0742887547c67ef0bf6bf01a8c53bc2dc0582b0900bbaf3e2922a92e6117be8e5547f7db9358621882dc3f8be0793d8821a02454ba445526cc02f8244d9f79dc10f5de975eec25d7b25dd815711bd4ceb79e3436c40096dad9a350b33af0cc2be9ae24428c4a4ad03d3df529aa40095d256038efb622490d59cde88fbbfc0e0901257fb56f5d72bc1d38cc2c9de82bd84cfb1f8f0aa738f58c0029c46ff2c4524eb7dc04d79ee1d35eb4dd3773d81a91d090e8d4522ded379f38faa247fd48cb31bdacd8a624c19a075132461515d737021fcd7a2f8c1789d26d0493d093cbe87fed33821f096c4cfea42408a8dec4eb5ef8441ca83ac03c7233ce9833f2b5448b09f20b743cb657920f27c7a23f3430a43ba2ed62e837e5386aa86074d8ee9e58836373d898fe92df778f5b4a71477c66d046849350c41669126019486cbbc87a8e3a80d02e2687bb0a94d481358d3cf629d9003f77d3799ac905eb86ab16a3cb13bcf1b7959a273ee62db37484cda06a4bd70480398424c1742dec3ea63bb515073d8734f3a2c1d466b402ca2a0b5532bf736d3d415017a54b1bad809baaa3a178f93c0066bd62d4a290f03cb7aa5913b9746a6243bfd7fdbe515a9e28e11d95aca5d0c1a286a6b0c2765154c1ec1d1be4bbd2871c728666ac5d144870764492c1ba61c1906c965a91c508232af4e9e0cea0461f56c18a56864408085dbdbf970fc06d960feb5b768ed8e01de8dbc27168ba0740dc80e88b632dd100c457679b322c8c4eb916113cdb38f1af6bef39dcf2f89d6a78c7ff809a8574d2a973b8352d7e1858538ab8cd6513e28635fbad08ad0ff4792e7d6f989ae6013b7cc78a03a20126764215ea733892e1556ed17bc06ce586d06cef5152cbdf01738d8a123386d12d1cc14ab150cf63c89aefc41a20523e397040ef8a6c1a1b2b0653553e4a3cb7416b033fc021926ca83368a846823ad1a2ba662dbff82db86ee3dc7cd933f6e319eeb5bf7e3f87c360538b763f22921b5af58f607f1d111baa7e4d77c29794b63e61b7f4e775a6b573fb5cc6ccdf524b44b6bcef9cec4369e5cd904d5a1b97106b0d90c4f5cbb41cce1434be82fb4c1743a1c2300fbff301d32745b190c1e53aaa96f311ecadc3dae436738f92e25e0faa25234d50565ba84331b2379f27773a453ad931afddeab7c52c6de4a9dc00be1381fc454cc380c6a87ba72994f53acd394381a242ebfa54ad1dba371ea2106759fcfb65292ec5ec73704b53263e9eb70ab8db1613adaaa65b009ee85a2e89bc75f784d9870df5f3f9dd5dd16b260c65dd94655cf3194a05c64e77b47536520910a10462db90cadc8949e529cf601d97e0a39e63cf30b31128cd197ba73d15cec5dd9179abaec39c4bbf5fc10137d357cc133a13da912e0f33c5554db56f99b483f0baebe142d9768cedfa34aa649e9873e65da66124c4e71171c015c016affd58fa3cebe3059f5d49a3384c15c26360d7e04a5ea4001aa0d88b1a5b089d63f72e963a2820c12c42af20e09456a8ca6e5f05514fac5085430d6a3667aaa6628c674151e51b0c49d734eee3fc31442fecf1a0b5fca86627c1d6940a12ece464c8780917e4c319750d9356313505359280dad909fef3be9f000a992d9117adf6b8843be08a2960d131985765990d52b43808d978e1e97ffefa5d33ea2711f1fb94d90eb2c897d65e26bbdc46db36825c21d90c099beb97","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
