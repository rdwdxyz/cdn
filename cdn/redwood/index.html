<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"63f13e14ab800abbce5d5fa6f318c21f8a43362483da84867805a242e45d50d44d949cee3b414396ee8dd58ef11fcefb5d9c55f31fcb448d122f2ea0a320c9067e2add92848f70b10dc82925f426659e8fb18213b63472d24000ec54156709359b4f4cbc24eb205be65f3c007d0db9c39eec5336ccf4b9bbfada9767b641a169f4ef38771ff234ac09396981c0df69a59fdc6b5660aa153db9ddcb5a3097de0aa9bc7bbdf2cfbeff69560be7f003abe58e86255e4d40258621882ab2f87436c25517753930ee32205298ebaafe2587165644332aee199ecbdcc7cc61a80cb5be69fba3d50acc9fa098247150f0260f4dcd8616e1830bdd699d0a98a8df35f4e6102ca0ef2a6e02fdc967915a1a52b4ba892c40b60c2b66ad5e7661ea206b4f7f16a9c6cf528a99a565c10580b1f315fa1dedfb5b193d1a750e0ede4155427886dca792ce54f4eab6b764162c6a9832443459bf37eb4e4cd41736c533c7647858e316ba7147f2dba5ff33e83e1fed16169efde0752fab97594ea980e2c95c542199e88a968c1df402ec1082449613388c3f9afbf771f2bca260a0ac6be572e170dade641b065f26f74124d82f90762b6f028fd947b21bdcfb3eebf12774f18610e8b5ccd5ff850c548d16a4812bea71b0bf3700b3c6ea952375ed92a6022f5c9aa6efe1654ace1e0216f61749e102690663e6f1b1147578738cf363fa6dc9f86e734bbb3094967e7ecca2824ac65c03d2f9d4e54b6e4912e66353cfc4e64b2d55b93b88f1efafdebf10895cdfd2cac471f0b100d3b2aa560e6d96c45ec6400ee87ae934a952fdcffc48890ee9596b629c6922cd4d50e2983c6479c8d7b8da23da01464aa83d6f7bcfce77b018c306df96a7487f5e97153b4f34c46c1af6105ab185e5c7239433bab17c8c6e415864dbb00184f90bceabd8a4cf874acb652305ed64037018631ebd738221c6917470ffb06d51263f4b65f39e27b760d681e3c25c19da8687e1049bd4b99346e4bdae9502270c166aee3e29cef797c84019976ec1a058b0ed12bdcbc58bd6d9ffddd60fe8384081591353ff90b81909a1773f6c46c424fa97fa5a9e2506f2f6a8975701650f1a90c9c43e4cdc01194b4385947f5ee846c4ac42ab72cac35656dbd5a84761dd1c74eb9f8444299ec73d517e285cc23bc7d2b01d6b1221b6693cf4b211b09cf8ca783d21030bae69e788d6c36912c38f1dc9d4f5bc721e7904fc9bc3f90dcecd0cd18cf128287f3df7682b4db55c323f692c8485ffdb3fa25a211911e73e239ca0fe34dbbc63f0eb8fa654f97cafd835b9b651960bd4e574d19d9fd2e71b9f753237b03baed3c36910a0c0dcb6dd0ce78348bca2c500ceda2f49e71f66694ff930301ad7e7b888dd478e76cc551c09638bb7400b4a5e6c6b84de81075b32d55b027cedf76396c35a8fa2aeccf83bfba2cf5250cca4930984d8fb13f372ad898644ef7d00c5696ad97868990d1f40674962944fc6c09c8d9ac6ce63e383500b947df390fc817a2220fe1a80a5cd600ee61c73fac420eaf76ca758d8dff1578b5e7696c1f6127c34b901c7528cd55afcbf4bc784c0ff015435ca99f319ebf1e8b4e45106dec533b4c897ff65cda1bd0d115009c55e2d4ba89acd132499216849b2480ce31a79ef627a7721157bd809c5b61a7756aaf26862283df81d019d3b8b72eb283941783889dfa53fa088b0c014de1c7247a9c9253dad698ee114fcf5a3d24defcc9a8e5955cce3f54d5e4ed65460bc76e6b9616051465b5dc1f32a583bca94226422c13823fcc44390dac5e775a1cb8f75b7e94a3fd594a3d90cd19f3858a728e045a3bb42fb858d1c73ea213e5439b6d6a1a95d791c8c0821c113c14460addaf83071bd36e58275f6fb3129f4c4605ab3642e5cacbe2c21d44f8f66b3da84360a1323d1b8603676c90d672b7975ca8d3b0bd0e2d087d6dfb2caba56d399322f17a9ff46095eeff1af44aef71f48b985b5776138465a8fa06794cc3bf20ed41e91e605e49025c2b598cbfd62c2636a823b15c96f7cb520824b16275f54ffc30b3869b78e43b621a09aca7a0d83d5c0ad618a435d7103eef733bf928a168b25f85f099705a88ce774065f8e54ef191d48e17874cc65a2f646e4ee099dacc6c0de1a1b8dc6198a40a4fe9b70e32b8fb114a77f5b7a4c2fab599b05a0abc6a83ce84132c8e3387162d76048e8ae70e64cfc4c29609e6b24ad2670e2b62392f3bc0e9a4c0092cdbb4e8f12cd84749a57d3bf26150df3c77a9b4f1123cf4fa3b5ddc51c80395659de39d595c79232c9fee63537b128c33983f8b85c2108dffba45cf9ea9653a7ad6e4a171b8ea545a6b439651f0cd5a56d3e382fece89bdd539ef269d3d43f329e187a0aed1095611384dd2fe56fed0c7833408884a3106392947e8ef9e33bab635ef5f623f22b143e8b0291bf8d6a8cc115a90a30303fc5eca0c1b05d16d4dd76dfb150604380e1c74e4a82a9334febe556c1a4dadb297f55d96eff7e9ee5141b9bd80bf8aa4084b72e110f50f28a585fdc8dd90e1cbe31222b8d599c1981572eb6e74bf59a54f710fa3c4e5e4c41ad78b4a0de59ac1d57694f2f7c05befd6bccf37f17428e47b1be5eddcf2580aa2a064cc4189332c2101346ebadd16afd2b3811d5d92779c4b91fea8e8e5c2054bb111cda1bc8228f90659eed4fd03b7efb52990629178ccae64062261dd81684389e0089b750395575cde6ad2d99190ed8053b1c1caeb984e12656b3603040c7ffa0232e5f5f6d11d8ba509c6a8639c6bd86da121bf66f6bc4fc21e551ae647979fe9da7de93972efd3e27b0a9e9b97f82ecf4d223bdba6c11136c148a00da75a0559b1fd7d736db647af358029aee8aadfa50c0bf0472937ea3e39caf88e736aa7683a99bd31baf1ba54e3480d84575870a217c2778fa534278f7e6b63f1cca5c362a6cdfb0421a24183ac30525883b9dea67cb93e86c8e642bf4bd622b47d2f0fea7d6405d6a7d1557d4da18628d5a75af3134e4d72a706abceb0468f4eab9728695c1ff1a2488654dd8643ec1ff32205b2bdb0488c6b3b9c5f0ab32b9ddcab34e5762be4296d117a67b3fcbb3a60e62c2aa78482374a166013f124ad496d989a2f1091777d1aa1b972b5dc64e1e14751c6b35547ce3c917814ca0f369ede8556901fe90b780d792df8c118b2c0009dd1db6984569bb976676c09d4da542d4bb4e7d0b8bad9d73e4d52d0a39d2e8171a56c85e4d3d5e5bae9e4e9a69e655d14d154afb4ed4286e4755967c676e872d079b42ac6716cbce6a4213e660b2a8e545edd1b6a00715af39d8aa7c81c4f801f4382a858a8926eea3770302654fa152e1d0ccfcb263efafe703330891a401ef18a931d363584e0076971c3a323b1107c422dab5c7c362b38ce78148dd8f8fe8e57118e98fa4dc6992f302956cab1c3b0c784778f21a68317e583a18d5dfb2665f24239bcbbae4746deda21d34b73c417bb42fc21638a82dd24a3f56fd52ec188ceaf679156ce368ee5f112b72cc1676cb2ad30ef642c158d7dee3f641325ca1d5d9b86d3636fe294a5e604f2ce25b3867fec4f841d1e32ebc70db9420b77eeb0035088aabc3dff78c1978817eda99c43af1b26d4b9e24d91c66d2e6252861735acc210cbf098688b918cf16ca851e100ed823fc8279ca9a5eea1f92eaad2829660d1d41280e93dc176cc0be7b82ddb8898065414c020358f4283a249e4d39ac2a95a778c9d6ab5bcde303e5c00d1e8c3d49d5fa2436acb0193cb3f570bc5cc5f373f7f288886183d3cc7457d3106b41163037e7a370d2c0e7a2999d691d80e8a63e98db1ce7425d6d630a280b9199b27231ddc67fe55738debf32382573c4a49965ca15d78a14618b241d53e40ee2693ec67d5fa3438f0746c8be0e9af23c5f7aa5f8350d3143dfcbd2f36855fd2afcbd1ccceeef10b8483688bef217563ecaa09e8dae655f0902a8197df22962796ec689137fa52220e55c299a9368e02075bd9e5671ea0916ddb46f0aebf47ebd2c47a9f74322759a343cdf332edb8c37bcdaa349b8c6d92698f47dfeec468e48093618dae619d9ff803ba6616f31f61b1875735d2174e24ce93c3590070e003524bcbfe70fcb0a8e4e28bc258ef22050aa31c97e31acfa65667784a6fde6fa9e3ad17be321c85a1e6ad258e99bf1a9308c4e513aa6f07253b5aca7e0f13469130323f95b0ffe88f1039bb81e8e5b989bf379f3654899f07e913d80f8c42c56edcece644fc5537b23d2e608753d9dec19f382b460d742deadf3c1fbac4964e3e8313871f74a2c54e4784c6edf5ba1ec79632a7d98811c731f65bc39878aeafddc9bcb75af02446fe0f4939631736acba2c3ddd2b3debbbedb071f388fc88de4bb87e5afd8648ddeb0a349f9d31c09519546d2176d6c1d8d420f97827a086e5b581353ac61f8fe7a4f2069ece20686b0788e80dafaa35c9f5aa3a7e1c310e2f185cbc14b797088bfb4f42c064adf4f30b17fe652636e95dd3627685c75a1bc5bbccb9d07b49492b74f4afdc92a87117c3d975b754b1ffb9c3f80cdd0e4602a72fc09cce21d1226b30f5e5c51726a7836b5f913332884e22f74524874b9319a0ee815824176aa78d4dc170a27fa17bf95291f003c0f0ff9c1a8bc580513a68269ba19b6ebb96b158442d3b7cb62c6206800f09192878421b19a8540d5718a6a9558851dfc60f1ea10259b9e45630413f822b546617f9494a73b5b6d83d0de41555bcc8c73bec2bb9bf1bdb48ba72e250ae2af6e9d63fef1e6391785167c63c85df4e224d7f5148977f07f8406e06da632acc3a3338efbaac14a52ba19f45142a8e8167b75b922c80e4f94f95159cb9eb595ed7ae68f0ef5d141f591607ba4289ed8428ec86c22730a2481b2b86435cc25985594f24804aa1bee63abf659d4a61149e7409e1d79d797aeffecba94d830ab41d7be57c65b620425714d4928f894e0d4399a4f0c9de6ad98cb99ab038f0c44915c95a48a03dec12793311c3238786ce1cb82bef9c2b2e1d7b51c649c39e589ae281b9471f7d0e153f7728088c8fcba71573984b9424af6f4b05df833c1c3ea9af5f0f71736cc1baa1af9555d2de5b9fe32c9a55ab15b8defe028f1b0b8758520ba4329c63b54f0ccca7901496e938028e1c49a7d646ab80ee184d4170c23c73c41ab314561c117bfea738ab98fdf1f6a28e16fef3e3bc76f190bc57dd5d31c0d81080a9252b4ea2760e87ce82bb05147ac24726146a093619b324f656431bc44a561d4e4cd2cc3cfa3c6fc220ae78e0d0d48cd1291c94e706787e7dccc782a25af5efa6647565d866c6bb6827f843fc42b5f6e9e82bcee49f94e5a5a67ee4b0e45758324da8b841fc6a44fe3c5bebb929804094bdb51f3972d445999bc139ca65a9a7c7631ca287dcbce8b53fc6570ab0c22ac3fec009e0c25942d083bb262237bb9e3cd085a3fc27d15595e76e88bf4f06309b519b79cc82b26fa3dd4ea5768a78b85ca0e940e12dd90c33bfdf52a855720f837852fb05a3a71b47eb09247a103d7d2359c5476a08daf0f59bf8665f7789d22d1f2ce74ad740992202f5d86f1bdecd79d383379eebd7b45ec523a5e0ceb3a09f80ac76b236a8d56485591efd85d58d9a7aa56b87440d45e6ff51791ada73472f928379aaf4e4c2a2a5cf3602c0d995b17e1c35402f7d73f3d188d1779cd7d862d419e0e8f116cdaffde2208f076152a589ad27c5c303801648d23c99be408d635ab56f5c35ba3bc941190c2872e4129aede34ef6395b01e94c725216fb53d2a27d05be318d813c9c9449ad8b1c51934934adaea5cc8d1910095a7a274636159f8d4b39a697b538ceaca9f719d238d48aafdbf4ac2157e135bdac5cb5ab55ad6b425569a1c75d6640bfcb2167f1d6b8e288acc205f7692428a0083a8aa6994b517e0d6c9db983210f9e3ff934d58bde9749e8d40bfe42badd9737e20c6e1be614caebe9b7295098d11c31a50c06ea75778690ddb349bdedcb58e5659855337f6174088b98a8dc8c1e94a94bbea834ddc79cea8bb1b3a4b65008406c223930794914e87692ff2f71adaf2f11d3acfa797310f08d191e04fd5d4f8056fb41e9e266c6ceb04497d7a7fc6ed909434158d3323e52c8018a306dd077d51f7c1447d583b61b3a77b1b2b8c0a44ed8abf9a74a7b6e887cc2ac9213a4ad631753840371d28416bcb1135575ab527c6fb82b26f7fa46b91cefac327fdb8f152be000766d21be252635fc31842a821a29732f00e62e405d9c0007c77c3b1d8ba735af6b7bf71d5ee0488ee4a26182299594f75745f8473c30fc68c5739fe4f6020f00e17f86aaa905b6dc0d099ff999f6749a783eade6511bf1a9eb8ce33ed55f5e6d186337b01bb4003e6a265f98f65c734dc126b7a5e93905cc5e64d08522b87bceec61513e33409c7e0e9ccadb74fcbfe6f76dcc9cb5b1866707855f13190d51358547862ea49bfad1acb8ec8bccfcbad22ef4d89c8e7b6f0fa4800d9ff4378e2cf8d1219782a26761e98b8d2ade4b0fe03a2aa772b73b7ce6c0f347c33cd6d8abf50771ceb1532978e1249b50a6029444ec6fd54ae000a31c6b58f4c3f942e97c1533bd776343b73ede7ff7dd2dc3608f9e4e194496cca2fea086200e6494cbdcb4c118f41f568d98772659f99d4ff5863e4c2465b8b0c75029e0029e76e37878febc695570fc2211a8050c017a7eb6b22c60c654d2a792041b7723c388c31ebb3a63ca005a4c6ba33cee64a4882198c0e0c562fc6f72cbcb8e54b50308c21d2480d8730247c30e5d21cb5563f7bc4be7b1604dd91edf662a1b2056057f1a7cb6171d61d8c463a21e014f845fdb8c26614cea2d7e1810a3891303f6618472cdb945093f535ca60fa8c0a4c2a605adf4efe08e7aaf2aa500ce550338bc91cb9efd6440ae53196fe5c6efd21d1cbb3afe4d559a68b855bed81bd98b88403844bbe551460861a3fc85a6aea61f54e8aac7cea78180163f3d9abe71abadbeeb7a1c6ef8f9ca0ee2c3e09971ce53aa4b74f54725e2df4b6a11263c5e07a56e055434a988505d39f4fc02c8a6a69b42d8df88d1afd5faef4be9a0f91b41adedb0a86a62d477ebd231ef558601bf2ed6cb8043fea865a7eb61201f018ad2a8be07df4f88ad9810abe018e1574939ad8d6ac5cbc139de4eb3a5fc960de161fa91f25b5c0a46ef89d7878889f06daed8b97bea6f937dd8f5c649d064969668d00cb3b29f5bd9f50c9dc07a4b309a672494ef0eb53afc96437ef8f361e235c390e7890ec27cf58d45786803f71fcbbd29375ad95adddb19856e61a2b051d17d8d250ba732c68fee81cf4914b68485f5b53021deb01f710f70ca2138545f6660e637ac3faff9d95fd0fab3365c9ab7f1aef99485c91ca17b7520d3181889b51b2eedaa62c23e77f77a5b360073d770ec1192ad7abe1482fbe94606778fdf1b0189244a27fda096f4523ab4653956cb7cb3480e974c06e2ad8d9e96fad65ffd50b024dd5b7f47f1bfef08e5fecc1113264fc598cc4ab05105803d24debc7e2a2ec61eefe2bdec944045252c7891c4bbcd52884c54bb94512826368f48fd1f1f15d1320d8af81a3a8039072b6441e2c5257e3d8ac67a371d9c88aa49591febcce7dced15522b6c60bbfe5751d1211f00a7460428dff26f9b44e2ba6a17629e36a89cc6cc58a444bfcfde55d59f953c0b1a11945c4d6270b444d29aa7faf11f691c3fb857aa7527abcb0bfc65dd10b59f6fe7dbe143a09e243dbb04299429ab16d316f669aad4c196bd8220df8f9262aed31dc6d8724266c3b4a97250bf1cf2a543225876ab9b290215c36db89914d1815871cff01c7c056da31b57efc0c3d15db752f0af094e108bda9139bff1d2e83735f67586f079a9811f4a29db5d7d78d99d1d8f47c8f91eba80919d3f2d28450e42d1f41ead13760a785b21d2744509f631628ca52e7a411a8151bc288e63c44c4d006f89b5f171c8cbcc03b6ce1d497ef1adca8eba1fba9563c9784fbf3b59dd4a9ac6199b42b0e30643b85ac9091acaca8a61ed42d1ca96e40177a1e600ba628617bf9d60675e8fc7b41d45b3deaa4935e7c8e5c35abfec661705abb7aa20ea345106bff5c0af949e3a784b114689250f9cf7beee5c54739e901b62506c76664cca0f05d8a034ad7bbacdf9a2817b4b0b04472d4f629faf893e0def7d3b54feb18ec34d9565c79618837ad23ac3690ca5e36183ef03e9213657da30a4378bdd33a073f6ea6e769ceca84ca5da71b196f5089708586b66af4f4a40ff89a01cd222daa71f162f187735cad255f0e98ad179961af9c493b66ca1f0af1f5873796db7eb864d4717b654b6873bd7e57487600cd7ea440ee87727c922e4c5a970f402093e10b26c69bb015fc786077a8c442f01db59173d801a12c31c0da9f0134d76a074036475a464b3cde81c66b5bdb07d2d78e5c34e60a80b5c53cb3fa6094cce16377a773aaf8cff8749bcd2240e37d2d1f92a2b7604e8ce9985b63cb8154a843c99eb422d3b1b03071cc51bb9448c12d6462db6587a0b45d3845f6e019f227d968c4f05c74714ac303f8c334f8024e486bccf8e3ddd8e3a86f2646266a87c7bb0b6d9a0731d855a388bf9238708566ea803e417b79278f979c97625e558c3f0e8eb076ca0d4c3e8822d665c5d460a239351cea2464d287007d7525fb8d46853b819520c8a7405fbc30e7557097eb2a9c691afb131d7c9d70902a16cb1be1816515390c69edfa87d56a67f7ed7e123e5166c13b74135244e2f0ce40713fe7843efacfdd15b4e7203c5bb79b0d1bc5aef817294f8a64f5838e3205b3682cabcb67f6cfc32042176a001a734509aa148d665771fbba4eb800b4d2422413c40c512f8befc2347b2787289cc6c6411fb3ce0b25cbf20d6afbfc99202e31004af584f818172106c5d382ef68b819036b55f4a79b2c85197e1e8cc737fc124f94745a886cfff873025bf7a590b0b56df8b74282777eb77e47adfd28671e3f46f300c86d586a5bd88cb4c0176bdb8f53cf7b10cbd0c4a215737a9efd3b3ce69fe11fe3931b2f66afe0fe447971ccb0e41fb5621ec2eed1f276c5a93eea3622c986a6e9860448127cf519608ef6516223872bb97c08bddf036abc5dcb3f79818ce0f7e702ebd5f4fc7dc089a6e23da411e1bcf4dbebf41f8abfe5ba8d06448f85e08eba539bc1a74b61be57a5d8793a5d38604b482511552535c667d4910560195e93d2faa0e2f2cad8b6ad7dc4061dba81fb0d37dc088d3558c1941645a22e8f829ca056f2cd1ff92628314994c95e5c601b99e5e999776f4d87a247439d2b7e5e7847dce9d9fcf913aee134df9793fe91c2b2690c8d28018e33cdf45c0db9f5f428dfbf65973bfabfe70ba21ed75c29a90095ecd12af41fc5e830f473678e7a99af15eb2ee65bbeff4ade4e22d5c66ac86f141edd4130ff9ab74e6966d914bcda1c899f85579fb53b728f84a2e0d21cbf73e5fb04c3077e1c67ddb0a7bd16c92e045a2ab4674c3bf33d0b4933360351193e512ffb9271377f3c232990b41262114b6172df42969fd7e37090cd2787dee5c4ee32284ca437bbc8fe2feea02ea587214936a3f6fbfa48298a88ff0123e0ea7f45532070d5af22f87dd03438713f56e83ff60b2986fd3e87dedcc4873d1a8b6f0bc15967fbf9b207c47c3b69e695e30c978efd9864a2cc1871fc0e2b01e95278bee6816a4b33119a4ea6ca30842c90652a699cb042451072c74690fbc5415e2d59d0892b80bc05f77c1470e4c7e21e76c680cfdca93c3ee66c9d260ce9c59e2784139e9dc3f68edfc780368380170bfa78418aeb57c30b9844a5fa09bfbefcf96741eb13051a5caae175774ace919a2aebf2ebcca1390d5f681a33c3078b23c5d80a05d79bca4ab62bc7cc9ddd1780623e1de09e37990c05681ee4c0079ea678268647860e267b22363efa91c98771eceabb66d7484fc6f7d836e2093f43ac18c46798a5a0fda1c606546e60840d53f3046aaca480cd8a272c65f43f2f1f95bef0c7406db95f4bea1c73f3d0b138621cca4254a736f75a869546e62217f797447b37dc4160a37989b35169602c36917c8a1011ab7fefe6b065135c492086625ac4195e6ddbd97a5d14985767ff0e90415c0dd8e3d7cfaf77ad034cf03a5c0f83207c0bd57e13d6defe82a120777bec646c65bb12a4ee74c08e411b91779e6fe06390c3bd9a398f25a1698f7180d21006eaecc004d2c21847da26e07eea6ccacfaaf6a095954dc17047e5f478ae388eb84a7ab1816b7380805fc6acea8a81053c9439714fae006e309b7d9677960d76bfd25648ad40bca7c4b08f8776fbc2b927ed8b1a1d138dc8cee52682825ae9ffcac9204f55ca017b47fb814c05eef063af9dd43acfa986cde06093aee12b29b67b3bac6382ddc6ecb90276ed5a84c39e4c61fb5668a30dbdfdbd793cbc73e09e9dd0418c047e1d64f6e7d74656fb5b00a0b6f78f33ec0b3adea1f399b126121ce8bcff0436ce49a43635e392b903e57151e23513bd4177c90261df5aa6e38252e29f204d70c99a66fa1086dc27d34c39f0e547150d4311564153ea0ee5b2a7a8d88ccf5c02debd3101c63c3ea75557f1b2fdb34d00cdc2798b69185bdb47220cf1161f8a82b717c063f497184a32f77f4ecaf52961d62bd548e8aa0d3b81ab2bf7a9278b1461b490a80748dcc222f1251cc8396d84ae361568773b79b19a405d30bfad075d53686fdd982ff736f6e755856298c704d070e0e77f318683c765bc4321ad4f021519df69f1088946f3907238f92cf82d384cccf76f2957cd6931a03dd56fa970d0050afc41a764bb8fe500dc94f123888db0f5b54dc5cbe4e5b64e5e76310c25366d6dc1f76d4024062e724d7eea3c521940a386c972dcf827a00d4760e5899488a17b4be4e6e0d27f6fcdf30426ec5f02eb0bf1d549c56cd5dc99ef4ed0f491688f0388d89a86b5ae10f38b13f6159c09c7cb0d24e42b105e151eb556297674a0bdcb2d503b13197db7173ebc93daa21c1efc3b29748e0bfac22bb1e81f0a1189d36df27df21672f846636f595728f789a6a8c1d9ae8c0161bfd55908f0fe081c3b1286ba18ff58678e4c998f17cb5430660cf3abf238e143e995decc8849d3314715ced553fa9b01dd239a7817d710549a188672d7bd72a46f3d6023559b39feba68f7245d7d57be51e1cc0ada1957a7ad610b6bb32385191ffeb0fe4021904aec217080f582b26f5a7d3694f15b9d3bd5626504c12703e7654790f452bd079860f74dd53bcc176c938ee86bceb07d64617096bd0552e73bc932db26f9858e078ee0666f108822eb6ac2ecbe70f41fa8ad12f72107226f98ce2bdd94eadfc80ce32478bbe4a45e612d5568f342cbddc2f85a859b3ac453edf5fb2c83ca9c4c81cd6dc913c37d7251601873da7a5deffcfba3343d86fb60ca8d0555c85e1ea4efcd712ecc75a42d928ff51d589cdad76b82f3c481858b34f913419ee9fcfda051c0e70e38637169f831661c8aded7bef24ac7590e330ae66b6ae4f22c4ddac51587e8208f74a04fb51aa493a93c74910572038af608280281e26c4db3ef60c9d30ed242f620bc213aaf64b53f307fc8acb5bdec06697d551eb44ef3699eeb823ef3900f4766e2ca6c118cb15a606ab742993ed4ee343f0a33b1515c62d879ef58ad7ada9d3c8e9b2357bf0d13eaa62f570b4ebd259d0793d72c61d02fcb7f44bb119117f4dc24369a37fce83dee1b4972eb49d436ed329e765d7267b1c65f8d89cf483a318256fd94fc2296f8b10ae15e1a9c92f1e3786e5157a1de34797c592910329a09889445fb0538a1215b0ca50f8650fb938bc8661d2d81b9bbcdcb84160c0f8458cbd45bb71d7f3438ebd1814d795ad6e254708d4ede09b33cec7ebd590d0dd7cbc93c5e6dc2aa04976c2e3d5afe3d69ec58b7e61033c7bf22a6a98b907079f6a694452d416911d4a9c29dcb3bc40134cd5f07cb11b94cddf8f491c8c99ff3ef689cd426beaf3e01d6919ef5b7a16893242b0f567f2fe3507bf1c67883948deb3a33833c13a4af1957d7c29e1710212dc324532cbdf257694e70a3791f61b8ba850211fa03667e08a025cc772542116d6b611ac096e399f9048d2076865e126da56c286303c265aac7dfd41b9d749078661a93385c8d0df667ca06377be5617719a3927ea69ff0a93cb206c7a303637f7bac5453a6629a75e847a35399051fdfd321e927050136c2c01164c66fefb88681b93a6b781868b4e6844cdc1b6b8e293a529108da6ef8da64813a1e62b8619b5b6da4aab0c2efbbce934cecd4ce8c9779fb084a0a30b3f344c9c6f215b48daa9fd3fe59dd42dab33e64d64738e799fda1c190aa2458ff1069dac95d290b8ae0091b786cbb66511a1a7d651fa2082406795515fbe050863af06ec70154d420768f7d3d4008d93f3f598444aff70ab873d8affbb8856d1775a6ea4841d2c1c855a1b948f25a6b7b8959a0a99a45949a731f818a2a848b0189c752fc3bcf8e53b0572422ca3cb373bfcbcd1bc9d4b11346e5c249dcc0d0973059c5527ce96ec4469b51200a4f180a161eb131defaf891962ee8c35b2e747d2c1b587f116d27aacd3bb054410651acec60deb10f748f2865eb9847300b1395fecbd7f2c2c1416c7daf5597e0800c4b445646be2452a18b76b0b55584044ee34963ce5134737bb284bbbde61c2f5ac4efc46154280c552d7319d315ad39b2f62d3500544b419f9ecb9a8f77945fc176e57bc8651ba4dbb8a0621393ea454e08c369963212d7f087ed7afbf33dc75fc9debb0d416a06b07cf54d38557d6fb42a803062a833e986a34d056e0f4eb4df1fa57854e6d0eb186e1bcd7af9f27c69ed4c0eef71fd4371b24b38ed93554df965f1290aee9fda6f7164b5f5f48c786ad0b1c26168c5b4cdea0c03e59540578ff27b75c531f3bc3aff6084e03dd930192727f574fd8b43525a80f2bea3a4e932cf28869aaa81e79a63d5b3d1a9687a2673bec1b7ddd039248852bb06d0cd469475ec8c541fc64d9b0d5048d1a8e2e47af3540251ae168d1b2bd1c6b0600561f8a913d9bd358d9d32910db50a3ef944b78dfa9725d2759f11a8098ab7b6e7359462ed554c8f4e49ddaef1e05d3b72c785a8be201e4c0b020c00242e21050ec1e59c55dfa1547c561ac3209fc154ee033d992a862faecec270ee1226d5bda40fff0a4924fde3991ba058a58ef728b56feefeb664dbfd5171dc52ccaad9b3f02964d0d59313385b19484d0d90fb76daa402d195f73a6a5ff2f23968c68f8ed30e8b66f38d7cefa87ee3fcf8605d5e3fd09c6b17bf73189e876c0007ad15f7544436d0b529615663852b18cea40e53a1e968cae2d04cf981c999f651f1f0df4faae9262839f59291016d4e7aa8461d17e9bbfe60fccdf9357b79610784d6ab0face3b48a8460237e15b32ef72d5e2f89d72d914e64fa47a2d96be1669263d7231444bed8f8ea6450b9b19232695b94326ed00d56b7b58239059ceac945a459f30c00aefa1f6e3b4e090015a9c5e8f2051f3c1ffbba231cc1acaa31655559807a959cd2165a580b9a80337c226d7d4f2e984e7989d1511bea8026587bcb2c8dfd922e01b59439794ead74b9f559029fea0350c2f8309b80090dc39aa326a7183d92653df3f05a67d9cfc1246a21685f0d505cb6539de315f63b8a8a1185c83a397dcb8a9fe8ec9a3fe1336fdeaa84b0564e2af43c048baddee74c4c113f0635c947b4a059c96d6fe2bf931aea563c92b2c85befe12030ddd26c8645985beed027ee4cbeac3fce95c1a4d30c69bd1a40bf2942f66e86dc7da90e80f9ca7c713dd63cf0e3196a9b8fd298c440e6ea48fc02f7ade2df21e057257dba3222b3bdc57fc65e61be64b60336a757fed9ddfd8cbf0a7501a1aaccc575201b701efb02e4a7f8316dcf2a30f7eb151e5d592040f3ce58ab7241b02a991fba4d2788ab6d8b2c56bd7458f3c91689335ecc453f901c579874898a57c6ceb82b40bcba4056cac9368c0543cf3902437606914db83f3db46d66c347d976913104f1d4b6b1563808ebe706c13dc92f676a5fdbf3690f3a3dbdbeb0e6a41816f40d0b3e11b115d47ecef140c6115e8d145999d4ca2a80812aea748da0ff01e4ec681d2d686a2286e10ce91b00abf8b4a34123c458d62077b3b204b5c8269b16812aa25edc638e5dcfc29286c5f71e3a606a1f9df2b1285048f19d4427ef128a7cd35857dd1f7f7b00dee1dd6c72b50faa2ec8b0a21b59a417327df5b95c42d9bbfead1ec2c097af518bb12376cd5b72f491d37c6c308b16a3c83e1bed816f6de37203f18f5b3024b173c99df0646824fd96ec617248a6d5e42079ed9fd0ff60618bfe8b181a1e69d675f4605345aca737ea9bcdfa039e4e8ad81aa6ac40ea1e15154267a96908efed71a2c095e979f599bedf4f0243fee0e053146c4b315691cd1ab00d282391855b11569ed7425f2b7fec58fced07a34fd48e76dc11dc7556657205b5f5c6ea4371685c548a832cd65851d080879e4d3e463ed4098e2b14f67e7a159ce648b1e5d1fbae47ff865c63b4d9a1144b45e6ad08107dcf202b4fe7ef0211a4ebc9132f7ec11977ff6fcb23feb19000eb8ec4d2d123ba63a5599b316894fbd67b8ab9a2e33c6541d01e2ef8cd671ef568f104b90224c9aa28ea1bad316d8ff05fa9f81c41b49f853f3917cd2239f330fdefc93dc682d7ea5dd6de807464ae035e9d05868523b94288bdbc23cea2b1b3025c07b0e3a82e5f222db6e0c8cbaa47199bad36037b4a54e5df51218ee408d4cb99ff57632544befda625a0e9775a36d26766ebde7d3211615a9c702d032785c84d106a4a809974b0befd9d3743766d1ad66c7d32d1e7485cd1ad5adf99ce12deb8c52c4de10f4942d47ea745bdc20a4bdf189d9917e5ce1f884a9b516686f9c5e4d8b74a41017e2e33a06f49427fe70ec9c2d0c54caf49f13437948c746b5ab53075d2ac0777c39804553f4febb6c01d1dadb50c8ef222b6de330e739bdd8a1875108a2898eda42fb2b4c5aed9dedcd0c7e38848f94a2384b17b853c12bb49230ef97605d0098a539d0e76ef3479adb7d8fbc9e233306812233f0b77666eee647e4bbe1d81a7e48b783fbbe48a1b7b1a47f29b5c728792b325830aae9f33d106b214d53a0f99e70c14fb5374edb9af980e60da1457a66b55f62a8dd2940c98504aa1839e2c8dffc2389ce75f24eb1b9f96c42883f061069f7b56b95e543c2c09756970938424635d8643bb1329a94d7f6172ffe90b503ab7846d3536b54f06e08f8ef3ca435dc2f2b5c741910d6c2799aa87123f1db0e69df6562e2455460aaf2505241d90e8db8eb8d68c134936038ddbb92e8bba6dfe6ae9d7ced4bfa82883fd7f944ddf03d6d693712449ef7d17ba5ee97db67313c3ec8457fa3f1cab877533dd6f46c8989e94e057be717360725335dabe030d6e07cd407e5476c7a5e620e09e03d335fe832976845bfb875d843c4a42b64587b70d35f205a5b663abf26251aeae630ee9f632bb620541cce7084a332cbebb6aa2224825da561571ea02539b19c12afca403816738d6ed91e1f4361ff5b1e0f269e499cf9e0dd20c794d03c38cd3b92a96d56e5d012cf57c5423b0bfae0dd20b14668335ae56043ebaf3c105f72cd3e8348601c4f68e133af07b4e78b66d8d8102b022a3c00c386ae8232f36966bf29644eab858d5f04a3a064bc4ff4542952b95892732f4377efa0ca83d34b0871a4106cf616fd812584b71958feca2d72a3456be887c82983bfe6e390f149a97f5b94aacbc7eb83a8ac7bd9106c748ed842f6d8e565f143eb9248304fe4607e7cd445b0f8bfa367b3f4f204048ccd363a20f614f5367f494f66258a5fa884acd2376b1cf61c006210ea2743ee54c69c2fc6957bcb1aa60084786320980f68b1dbc470e049a45e5faad97ade1dbb13cf20c71326267d0ad8a434f0063f38190802fb24119abbc725e82783e3554f940d64ac2a7f1699d63597987b2e4c53a038afeacbd9e194249e38c8d97f392de4c3f08625c9f7785e33880fb35185a6c62fcb72b85c6a3c2809ec2b1049fe8e3bd9bb65b093af63b085a28311de5d80377e58fa00c29f0c8288873d8a224346f75013b70fd61fd89c7ae0c48e895f356772be267cea0e7e889c0f210d6abea915802a7f718f2d2c461d6763b1745ff92fabf44ff12b9d56e78a94f1a73ebebd5bb77b236ca933306a14a866140b43775708af28da5f6e639b6afe7a4391d834561094e32e3c66b5491a5615cabea4d01cb77be811532b79aa3119b0a9cf0c902a2f5b890eddea0a878fca38b0f4262811e7de765b83c90d7f05beb280d4a9dcffadf4a970d463b0c9d04f45d9502e960ed79dce6a7b833b78822e4ead5d041c7a8adc050f014a3680ed8851805e9740da6c9e01315471839128235a79d40fb3d59c2a223132eb49dab9725cb981592f3ce62f4e765b1304c0fdfdd1627acb34aa08bc26224cb9c398254b197b8094b724645f3d402c965ac0e4b733c727bc30e92724f3a2d789adfb3a2a16608910ec6de9440fc4c3798df14a40758cd152063df2778d375183e373db5703fa68525480e13a6a4486b80d41622b04e5846d3435b2314cd8ed1f5c97faafc99f2ebce1b55bd0c0bfd95e22260e9dee7f50cbcad77c9c59b2c36f6c2cf147895b80132f2fb0c350df57c425879ae276e8dc32cfc076f4e25ace4fd1e836ff3680db17445657b6721a78d40a82c972effd010b0ace7ba79b9433a9355e807e9ef4de056b706466aaa6f12c612c4fd09e0e81b161cd108c265a79e13d81521962da93bed298e403a7f57e2f89a59fcf0e63f00ce2b8153e752e076e36b3cc94e7527241966e1e4b2b4570038ff02965210c12d6c1a3abc0acfda2dc2bf91394e157d0035f1a393ed975feae64bf17c888b2c3dc97c2ed4c0165f9fbc58f40ba24b41a7893ec53480a2d6026959c61a2af9cd3a67b89b91e81dbb6ed110b724ca3d5d32226681bdfe49fb876a0dc887e8e963580d50cf310902160ade12e21aa77363ce285ea3296e7bb9774819d1fa505774dae4d6d48d447b7dfce22524e9706a0430158e2c63398c6f48bde0f94c38b79b5afc3beadc62874faee2299e576db200ccbf33ca41c2ca0ebd221a88990b765f3691b30a8390d91c2155a83817300a01d9c5961601a5c80fdf5501cb2e0c9dbb02ed4eb81da597a83434de8409edf57680c99d5e25f7886603d62a373fd359de35d415ef8855f77ad3d9015b213fc44624d53a9475b93da92ce805dca40fe30b768c778561b20c9227c30d9afdb572ce086e7b5aa5e86aee5a8ef2854cc98fe0de02672d04fa4227baa0997814325447ccc001b1fa388a2dfb037f12dfc9e9271567affa4263912777d147a18d97a504605f1951ea91aee9c31765cfd6914f40a18cdbe580a81322342857f49657ff7e5b9105eb4feaa092969850117ba9543710ebd453cf7ddcd5b293b2b7f58cf13752dbd00eef91957eb4923a231b2f4d93692098035a8ce6796efaa63c026043a5f19feffb6fd29183a593a230af273662f8fe8b61d300e2625edf9fa615cfc342a76a2f31332c8e282c74612c3dfc9e0c6368b3a611d435ec8aa8cb2609a511448b9f4d791a507533885b6d256bb28eb4ac394c4a5a0df357892ae95fb3788490fddeea8710227aebe23bbb0dadc7e14033fa6cd0ba072f6d72a94a3f0907596095eded1820279c399806419f10dcea2e3bb9ca0e6b667a1ddf4d3cc750a05f94bfbcc149adf4e4af56b508a6e1473d91256daeb5fb2dbde2e10a7f002a5a81783a067c693bf0a0fa10847d91ed58b4539988062c9a0365a5fd3148d28fdf26d8ffd3fc34373cfff554d469c67033b6e6a9ee021fe452c239ea0c1a52e723214659cc7fca4eccaffcc30d18dcef10aa20e4db727354628a491136fa4bb2ff5dd1dc9d930e7c341de187df484355","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
