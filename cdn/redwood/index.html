<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fe8f29248320f63206baba995c16201bfec5878862d7dfdbb8a650b89ce38d1e7fde6b11c14431a8bde98081a4e58a39be9934915d872d3a9249de9fb46c8a5924d39309eb3c289aba8011a0392fad4c8a1c2d2ae9b7296b021c68229e9431f742b1b3c5815979f1f6c4894ecaf001426389f170f615b1991be436544ce272567ae61881e61aeb5a797be14708211e876f7873d0882a0a4cb3a9b6baf267fc5f9950af7824412ada55944d8a6b08287cd80edfe6717d90f7c778c068132cedb2f391358e5dd85530a385bcc4d3f99de1bf5fb98642bf04eacaab0a7272b855db667bd48c2cb39e3f6174f09ec3756e3368d090374eadcc4c045923ffa35df81d08bb29d3ed5dc05412c3eef57637bb9b86536544a9c2c0017aea225eed342f032d62d11fc4dffe491447261ef98c496d245a8b2c2a9f31e7da8745f1b7cfd51a5c77f6e82fc417d2f14f1d554d8e8e923ff92c3c35f16c03a0cfa63a93e581390c8cad451364c917c974dca478daccdf82226a53aa22fd4d30d1d941b497ca74a5d4c21c4078cb874aaa20e1ee7d29ba2741c1ea96bfecbef8f4562cbdba92ae8a596e034f6644f27242a3e91ba3060bc008700a612e5e563cc1f8429f582aad5f369e686dcaedf2f4bea2e68e52618080a91796d7af3fbafbc99056e280955a785bad15f4067857596e4ad3d3d03c1b67bbe044bc509818faec779bd9d17265b570f3596c1b3d59edc07607af5103a60ff690e803551562886b4775594f0a758232cf2e5b9bae5119961dbf0889ddf4f306436a24b393e0c68bd820d62779000cfd757005f945fd313f6b53b6049b956af0b2221009f11b9a21b4696d8d7a4d5fb5f8162c976bf86a41199790811400d87c857fd662f3cfffa05eecfa9b9a68be7452b54c3a6a1014299717896f2c57baff590c1c17a658049555d7b3b50e6c1a018287b8a9eb59d380d495cb0f8f97be3b6c803901fa6e5731e0715fd7591e90264f342a2b596308cf1b4947a25fa96cf1655c1264addfea3071fdecfc05443d205b34e033b8e770c7975924d74191d2a15b01f7cf8ec12afa6de5b6be01e43e7646f03ffbec70f99642e5296acd4fbd4d0b9fceb0cbcae9afabebcb4c0febc27bc6633fe420a1a3b6d0d3093070ff8220e528198667b85e47930959e93c33a5acae6b370010fa3a92b7545ec6702677d93f4f627159dac3f26550fee1f2c1e21f789492c507554bc79fbcfeadeaa0b9349a946b91369e5cce55fa2d873f02422995af69026e1a1386437d306591df28fce2e7f9d9a829f77a73d4a12f9b161d691ebafea1faabe00aef1dae266abd58208ec3c72fbe0ec834d2da247b9c4beabf6e697ee013a954a39ceacc3d09f8a5007c11e9ba737620457599d9a113277b1bbd9d3c8c1a8514a038872075b33a0a786b416cfe3632206951a5a05d5121641dfd986ca808d0885ff78906982aa0b66d47e1136f8424877a3d201a8c67ef93a31c0181726d4d57f2f92f87634bf9367965cb600530cb838b3606732cc8e645bfdde8b5c61cce701895e3c72c7c6f7daaef89a0d70289527c0a23f213ade3012158c571841330b8aea4701862f0a85eaa36f8d0eaa43b08411cfb7efaf2357de8727d480615b67628458d3162fdd76284479cc6b154ced056a0ff3ff1d7cb9f9e354a14bc66b5d2a130af776d1b8931c2ebf47256f85512b38c2885a6c57f978852a0aa49cba9b58d32a2de5b5cdb5068ffa863824d56688a3787cf5847ced7cffe0353aa1ef0fb4508aa96bd3364551a90f9e513a1fd201dc252e91de322006e161b4c169b955ae00c2dd9bf6bd53d23b2f524bb74f545d607e1d84fdf5777d10fce9f56d217d173901eb739a30d2daa1e1b8e938df15963128e0b2c55b7ce0848f855122242063fee44c00727cc6b4ec316c7a66df067f3e73eceea8faddac4d7be4a95966be6b6b2659dd6ed7bb150bf375464299dbb756aafd4c1023095fcee7604cfc5ca50c51f9fd963781212e2de6f84dbc840327e4bbcf3b33d1d23abd7eb3a5e72939de9684a5a54ce5792b7acb69f3ca3b1a6a4d5bea34f1608c5b983f2f67c61aebabc72ef80188e332147d604a28b45e6587727d2eea7903fd90dd73f7f8df8bbfaafb0dd2fada899c7514684d0604de3769e30b9b214c2b960028c44e26d14f2d34c1cd5c8a14d04799bd98736e4567f0fa29616bf12344d2f68ac6ab35be08e111815c9d4f52abe1547103517bd9d959d28b22345cd0c1df6bb3a8853e6e8129ae818dd9c2c0322379ccdd4a222fb7fb8234062482e7df3f29db7601ca2e1937f9d4ce0bf172754313a38332f72b116ca3612946eee23cbf9aa80de7a112ca9c954bf84d2177df643d8c2c9b82f817361d4c09c5e00cf39f1903fcb495ba8e92c651708767150d1bd78e0334a28391326519ea0e69253411a1b088467d97c2bdcf533d97586c2d875f599196b6207d8d507d17f133e554763a8627b82d93addb98bdd85cab9243c3d5f458dc6c770b45054fc77a06a6ebe01d64f0cd844aa1dedf69b019c571bf385014a27e8bc97217dd9a93749ec7007a7a30d5b3787f0e206f1aafe5a19512fa51acfd8bb6499379daf6cd635944c3569b748407959531e0b1b01cb089815a47fd43cd4922ff7e52e3ffb31e8b259dc49103f2c7ae6f6408e3858fa902cc70c7ca402d837ef12b499529fdc29b671a6c8ef95ae8c4c20be35e1bbbb1a1a0174f43fc743dddfccf7467f01e44579abaf4a0d80b49e24bc7e41c7057cac93a1c79e5d27a833ec02cfe2f0249b15194cd5fc1701afe6722bc337f05c4b55a4b374131d6a96db7e16d88a8e52a9865b2d210fa6a94fa341c6e56fb6b85cac81eee04413f3743eeef701c382e8510251b2bbade6eb80f998f744cf3b4df7413aa29f8ba186f0c56aa4af56ee4bf7f665af80fb878f65d4c0ff20088bfa9c193693323b4f78ce150837bcb9a3bdfde201aea8450cd08950e031e327ccb1ce08cb5d32690ee992c8baf743e85f4f7acbbd404f0b6fbbaed7b55623744e24628670512073e1634273603a684780eeda694d2abf974fce7e8731e4d39e35f9d53cc32f0f5f0d17d10db0020a5c5938a5b3472a2a6531de2d12e7d9bd2674d5f00a7896507a8c81436a253de502280480ffc68ffdc9a97030c535e09de1a31c18f77e079c834d5b3fa3625a28bdfec064e51848bcab141e94729ccd48f5cb4f38332ca66faddf6726edd7840e5a8eb834147d92e19627092c3b9cf7a95d1d2ef6d1b171d848d40258476903add5aff1c57baa97329b4125f0eeb1b61337ca5acd5a358814828cf81ff7cd8d0dfce6afea24e68cd6eb98211bc2bae3d3722ace28ba30558a068251399b35f5cc6d7dc92e945a68c64bf9a29922cf417824a7037e00d75918c2789020c71e12b21cce017f4db85d88666e46d14962ea33035f6509ed0ce441b6041b4ff18af1031be0e494955ee332c6f6e97e9a114f94a6d605e5e2d8a7718107e2de37efe70f4176ec1700fefa3339bdbe45f71ecff7100471512fbf7153e1d0e24527fdc2681b9f2b9aa4ef119ae0ecd70f5889ddc05bb06a829b597ca6a8c0d10a8724dcacd4c8b6fab5954e25933835de3bd7aaacb0a6c902aff4317af6b08af9156b3547353a86ccb18781f1b880ec299efcbc3bfdf5289a3b7866bfc218d2c30fcf7aec50a6a741b9d948f99adc7319c8cb64c3db45db2f96b92f65d66170763ef0442effb7b0cd9ebaa98096a640b0106afbf0fad12c3ffae381c3090c4ea1c6622724535614322a056ad0042c789d694d3c4466e56d3cf37d67b827baa1cede89d1cb4efbdd3a6c5af8fd23570afbd6ffbb26fbcd0b3e5d761c422e2170aecabcba95ea46146b32e575385c33381f8d9f560616aeae0f6ead605c1ebf1924db541ab51da3ec2aad83ec3206fb8b567de7e32642408a5eb5edeeab49beb07b01f8abf4d101ff2ed7aab69f1d80ab9cc84939f5f6a14c1823709e58bbcedfe5f3aac3cb48328002dd62d0494cf2a4ec5ad940e9f0fae35e44157354925f77b9107e00ce6d2307a4b3ac3c31dda6ddbffd5ff66c155572a5787f6bcb808f09ef6d782f5977a69cfd12fbc79ecde4082872f4d1f8c1c473b2ea3d5e1afd13d47cb133a18b0c0aaa74ab0af4be211f08ac4478a3440de44d459ee34813eb5ef057f4f8a213201235718af65130de039069fb834d5d9f28b9a13820317b3fe931f8c3133b528f9427d9d747a0a0678a41769f761c1086567fa845d00ffd9f2407472f8c11fe70837b08bd76112065f43159527b48f765347193bc22f5788d16d07e5d5260d75b4dea971de6331d8ec6c74c7778062de63748f2a26ebeee4adc98bc4d6b750dadfe36bfc2bd5a2011c2070ea865e4ec927194e329668e366183febad89697a0f41b82caf365c3266048314dfc40666657107ca414f8b7e025246bf6aff22cbcefc56f5b90b16e6022324354180e6f78618ddb88397ebd738578d2d00511db80b63d4289cada6637e4955eb521051cdb5b99d8cd5ab245897933bffb5b0881c72b005f4e57e877a2ecf0b7875ba99091cf994b57b7c0cf9a9157ae83943385effca1a556ce174dd97be43d6d5fc13e12c3f2213db72413c0577e1255cd989bf15c46952eb0c339cfa1052043eb81b75dfc1ca9f75e0eed273a9c0aa991658f97e48b02829f1636dded3ebb4a1c63b66ebcd6497ef9767b63ee60811f414588b319c667839910d8fe13fd1e175f7a5f9040b91d727f1bf445459ea17b6ef223a49930a0c54201a4dcc93ff98e0c6394b96a448d8a8a7e10c2923334ba4496d2bd4ee19e01aedf0c41db72ac51546ddc57b05dea080de81b56898eddc308ee56e0517cf4f56affaf6cb35f7c8d7e642d50b782f252c989fb66b2605cdabbd4cbd1d690577e27b4040b72cb005f522ef6ebaedec53adb17930dbaafd518b0864f11a425561fe0eda5218a23a753bead0b431ced16690c3577e9ca56be07c86e2f39a2fec1ec6e68a8b6df695f9679e7a596ce7fbaf1ba44807245134381abc814808d32cd5b55227280c0f35cb9db0e0feec418187761c2b137767f073de0bbbadf3179b1cd84ff94d2cd9f7b3a9fb873ab2243d8425a711bf44d89e7a6f96666a8eac06e207d4b0487d6a2fff65604e50263e8baaa5a82168c856c7942d0f0353bdd1233c80de6209dc1b6cd0e8cf5fa985dacfe58fd6dd4ca549951bf31362a334759a7c74e941b6201dc740d842bcb7496073ca5cb0e10b0732339c0917347355c11ba2f515060a2a4ad7e8fc0e26d145feec01fe3f1a6a6d86f57ed909ca347c29eda265caaeb3c1a5b301cddd4c20893979badc6bed1bd746e340cdc37a235a15d1e0e6eeea1cb9013247d658df8865c940ce7949905e9aa36925ad1bec4c874c324ec3aaf8edc0b188fcada7cf31ced55d5e25141bf93474e1268c49546cb792348c5bf2b224b8ee6326caf2fad62109f923e36f6a114f5423192c6ccdf68c07f1926d462d20750f1593f0f68c1946188fef206d079bf4460d0c11e8e9b0e0592849d078833d8a2de9a326bff97fe4f9a8adbc078dd46bde121d7225e38e2b382a4cd156316c001a047dec93a8952586e29260170f41ff045583db179c4846f2203addd9e92bfd07618fe46d38c0cf676b6e1280fe4352550c56ab7e6575aba493b45ae64d770cc84ac3c08c277cab3d3d365b3bdb51ecd66bdfc3b5b9bfe3d451a08dcaafd06d068fe8098c4dc281f3b8df65dc91cf64d9ed5a34e37172cf63bf69d7975596a937b0c67ceac93af7ed209a62d8310c717da8cf8cc0d7cf87641256261eb253836bdec652c665cb387f2c0990889aa20fe9defb50f453073a780db053e1b331566a6541385e0df3ef1f85ed2056692e8cc11444a1811a2c95457608b7ab52d202c1f985d57907b9bc8b93bd931df07f760a1da1bb85be9edce140b1b006676f74bad32fa4ea28524a05d0f31b9bdf57f2209eaee9cc13f78d59ee0f83666c28136728efa84b781e01d899f9471042d10897470f4c70ffbd6515f917eff10d656ca674e4e28a55081e7aa25504d1742c944cd4e1ab97aa7abfcc625c69bd2c96d65db070dd8465810c960f6c0cf60db1e544344431c6b6cd920d7f79c063c43c42b0482d26853af250d2447435f9ebb89b8fb1025186dfd055ae8547e0e84700f2782f4fa63414f4eff1fbb8fd0a777a01abe4783622eda57651dbf27a84d61d4009bb6c6f983e7012019932d4153fec8c7c4b9b37b1cf61fc0eae9e68683e5f2ca061d0f8ad387a97ebe79115e741a2d7ba2cce99b576645047ecc5391e986c6c58643a71290b733784c8f72d7a336857cb960160d90aef04064ea64163a8c0b5e15eed980e83a26e0c3a56017fe17333196f3c973e5b4a86fe97d0ed1762dc8ffaef872ba1305fce8d0f96e97de36e6a473455da262ff8bd552256a82217d698447c5bfdca9bc284f742be14ef61ca6bff1b406da0253ae48a206389090b4f22fa6b9c2139d680655d378e1ea125aae8cd1bdcb4ac74600eb8c3c5f10ddccb424a938698b04ecdb79a9c80a44f73042717b012ab56b5632164bc76e5d35d7812290a9dc035126786fa39eea11e381bad26dfa7863dbca26919a4015a53b2ac328df6e36bcc5e41cd90e5e42f57eb2b8a4d268cdab264657b33b09835a8f47292b8d18cff6f9f0c704f1066bf3b5ffd34c121f009555d3fc72aa06fd4aa99740349bb2a5cd15b0f5ce9f76b4e6d924675707b447beaeb8ebca1a365bf8dfd100a2010814750f4aa3a856c16ea5419180c48285d1273c889b71fdf9fcb35f37e9382680f0970b8cf5a1c853a59d95b501f5d8e534e868f14ca38fe7c7649626b5d3b99669fa57231023a73b8b80688d6f400c1f86e4016b0d2bd79914eb704691b11bf62dc2855c437ba5cd71237f320d7c535fb15fd5f0391714839a40eed30ed2753433cd9123d11787ffa918b0ae9ef3f766849476d7e8ca34f9e7d43b1e0c4b75a635637cb918fdec74614c0a43f26f1d81eb5e03e05b466add1c1435ffc83aa09775ddde1254ae0a92c309c0d2ca7ee719f1e895df41927072ff31f24641550e5b5635f567ad129da7ab4f0681227a8ad2bb16265252883525aaca6ed83af055b12700db8960630579195c3b2f6de8f230371c2783b9238461a0041e56e439b8ac1fd0153393d372ae433889c36c34c45d481d10cf2274e10597184e78a9a177cafaebbe11e42377c2a8d565f22a2887e01bf3bea919f0f60695028c3c22cb8281392010be17d9b78a48a7ecd9488edca16d847260249e067d8a6ba31dae82c3c405bbd0bdf90e46f2e041c3cc311f820f4c854b4807b181515b1150a0e85ecd0312f391604fa57a42031bcafeb577c43a252cdf602e6cf5c9985261302b377dd26b3d4f5f16356909fd90ccb751fab9925f593088108cfc111acec1109b349bb8d361475dd34f3956ece141dc27d90794349915ddf0a68a5da4612530606c1be32c9ef9a097eca5c2a1666b0beac898469e76104dc2bfdcf530becb146d66589d39f9b28c9788663c7a45703b999fbbf5487af03269cfb2c37d4ff1a15eb4bd2532378de8215391890516a09558a6139ecc7e14531a3192d4a7efcfc3085c3e568a378caa36f83025c91f84646bc8db91a00a940e4cb110088bc8f4cc5b64998d20c1ee5afb4f92bf0f68417003a28a3de88174fd4044819ddae20ddaefd099ea2cc53af1c4d7f46284180e06a85bee05fbb347fb95c742402128013a742dcec2b98520994bbbe4bf4ed4990b06fe10d9968a446397c52228a026ce88e1ffd1d7bc17e91bb8312d6e39cff5192fc032701fb30e7ea6002510926b2b2fdc3cd78cbf3b4b3f68abbee0332a43084152de8f3701060e32993663f78b66f9ad789640cd32118b8e872e116b9552fb65162917a99edd238866db22102b4e11cd95325931da277fd264469e8ed34b07008f56f754234d68715d1b96aa2e42bd0002a8332f1b3be4c353340f0d4621fc947a89bf09115518e00be8e9c2fe5bd16a696a8c50f8ef507b4a08bd7d961062b198a10cb945784973873900f65a23d9a173a1dd3791b2b4a873db79aff0e52e80a4a0342d31635e4e35c5e1d10fa0967931712516191e635306658a59f82216d8716e33cf74b918ffd2c603a084a54420aab116fe90437f1d9052cd7ff7f49daa33ee6f7e41ec662b50a3959820032b794276e7cfe274f83665625e2248bea369f4e6de2655803c2ae1fd26702028c2613ecf159aa0a821098f4a6219a1bdb9bb44d2a51dba101279ab6fe53ecec0bddb64a614b8902e97474e0d66ae092e6047deca0176b0641c47bb53e90f2f841376351c9d2b553e24c8d2e6d86fafe4662552ae73b2ba37364451da80862c479205b3f8e332bac2e2ba0bd15a2af161287fccf428b06c96ea3ca32cab9719547d5c2fa5838b5365f5190277c720a0604b539dda0ad33b40646ee5356730de93f75afcb4a6bddec44b695594f81de59e79a123b3768a806c93fa20ecb683b13434fb5e3345dfd7bcdca059a60c13e19aab4d6c861ac435f307a4f518fc485141a5aaa207a87de2d83a0a4f7c0d469c934cd860b32170fc9242eea01dd33fcafce06f7164c3c4e225aaa441e6dc9910dea380cce191c7e1f416804350e7b174a5478cc5c712b0fb1bd1a0c2882ad6cc4fa7d2d3aa616445b322ef1ddbf821136038d3cd4d4f6d83b6742db3e4a332678e2a30945e8a9ad0c52d422ee82b972abdcca7632948e019856629e0fc3a774714a31604b4be6cb76108ace1fa54cd22e4d559f8aa596631c0c65a328c3eb3995a8a299570807becea66e8bf112f470613f9297762bdbfa63720c03aff56eaa11292d19517a714dd8c8f5a89ec47240372c24ef8290ce26b8a3f6d2620692bd094a48919c8c73988286f2c5ad37d5750cd280a3b3681d64c42cd9d1717950c5b71230574f722452f989755c08d3671a7a35ecac4233ee0a2c49b55d8f5a8e76a4db2e6e8c6c88eb3a57234825f6dbad76bcb840ee52fc029eecaaa643d4e5e8e2b3d1e60a634a6db69dc96b124b155a6f065c6dab9d091806b80ed9d8168335449b4513e35f18c8d10a4734a0fd6c27c3dd0b378a1afaeafa5c7a89642d9a452efda3a7642828eedaa399e5dee4994930ef45f575b7804a739be3ab61bd0cd153a8909dfa5e380b3439e00e80ab62bf71950db476de1ddb0553f0a0a868012b3f6357e1bc9816b4d658add2e9ae9986b2c076c601872f5266dd163d0a00ffb9a6c75887443f8c68f47a67f66ce860abf440779b3562f5fcb859115e58365d8279c175f5fea12c4692811d8c930004c1447c2b32e2ca22066f64905386097b847c58e702de14e748aeadf0ab8c985f2eb33e9ee3a8f712c814cba992d386e1c1a78862b9dfd3cb1f6db27d40230ceb66a6841f64057b0a8dea8c02c2b949343c36b801241807dedcfd2710bf9bfcfcbc33f6556363885e3112bab5120642ba81cbab0e6c7cb5f7a94afd6bfed209ad7a91e0fb3247124ecd30566907550c7c7fe4ef4d0c89469e1fcc9e9f94d4db8106b2db42190ae79f5dd844ecd8e76d06622eafef532bb78b4ac8ef4582715c3f19a590661c568e94a4c82a20d1a8ee2ed74e34b906456d8e97e76bd885e038acf52950213c783a9deed5f1500adfc1e29c0406af6b540fbe26f20aa39486bd097191e05928544b0a0bcae6beff6a72359f594b2b5de17ace69021727a979868f1378a2b5cc8911cb0874611279f356ad5623d47107c6a7d83b61727bf929d7949174901edf29e0fa96b09a7e4e70e80c91b3ce7b3ef746e1e39ee7f0700e2e2ba138b41f0964106a6d4e1d7c2d808e0d397212c76527eb13948cf13e6e25d028091b1d8928eca8a19afc7076eaf9d0f76f3bdad1b299e64a034d6848658ae09e414416674c10053450c3bafd77286c5528673c44da9b0fea835ca7e8c5d80972a28f26eace63395826dd415aa526e1cef24f696c9afe1e2dcb6d652836bf257d3edbd5525e5296fd6cc114f0d67af83fc02afc7c015c2867608731d423f34fe5948016152eb6f08ca0e3398adf43803ca8de09e49e4d7f905766a8f3c40325616ed2974c6ad5f1cf6a714e71ed84304b16146febad52d6ae41dddd62a2b3025f5fc46797ccba1e30fa260955b29caef78e5758c078431c970a79f1dfdec4f507c6fda0b3ec08474c2b905a70ac0121facf516df9a3e1ac8521abe2a5012bd84872f7265766d1cabe3931cfabc4c34ba0c7a9a73c5a9d1d72d2d9cde3551352e3f43616a1415e1a2d4cb4d9120fc270aa1bfc3d28032fb32b5c149dad4e114ffd7d1436fb5a04cb09604bebe6a20a9d32e70d4f2365a177ebb3aff50d843b3ed4192af1625f1168a3986655ec91f2e44b8ed2515949f4c086b39924107d192d8b9b6bc7705c63d4907c7d81b917f6bfa41bb5555794e786769aba21b871354c034c7ccf0ab4f4f9a444d54d5dc8330156e30c4160f6a5b6a3f1cfa26849112aeaa8d1fbb927430fb5c2d45427d4aef797167f42f569e5404bd6e9c3a86f42e01b33ded95042d0fbaed8486e432e844ed3244521f0f737993aa58e1522496345283eb6c30948ffbf5df944284e858b2cc8203bbe0046dc3c37b749229077136b85f12fcff44597e2f35901ff3ed1aab4adaec10c4f7a586de4c1a5991f55b5e6518f2a336af4e50a65ecc4cdbe2191291858f5c958916ba44f3f1eb8cec307956d4b08c971dc1133a25a04229d6f16e9a9d0bb8998e7f01d015196d52307d011d6426f17e25d3ccae0a767db5ff66a01501538c7fbb67fb85e9048ece378fa950d67620d4578b945a0e961bae705f25d7b83c12e68f1a1b3815d324462b51a21df001d34f420acf69cfb8943cb5fbad837d8806dba3ac27f2e907d70eb87e7e175692101068570b7965d17dfa417ed9729317afcdb54d7955be264298a676da38e8ef5fabffb49412e77d136b51c083f8e71b7ebd0da25055b0a4d4551fdcbceca4e7ee260c765c7f3413625dbf74ebd64562b7843ee71b3dce97139953f243946cbd067ab3342e20021dd6b5d0e76d07d3955041539dbd5e0af23d30259b2489b5049d83287abb2a92feb25504e518f32607191da2f2998d632806c83c7b685d93dfab2cc96b6055331635aefa779d19fbfda9795fedc93e0e8995a8d9268f93cf44f385efcdf31dd07ac0f6c014967455c8f81db1176b28a58d2a39155ec970d644a941589f6264dd465c1477dd2c77fd28883b5c502e782b34ae426f0bfb40223ac86791a690e4f39c987843e4f4621a91b977302fa6d87f4b9a65eb7a1cb6dbbff58fa051bad1b4566590bdd7bf6d9a8e561d4d28cfb36fff2ad39dae96fdee61f75c07dda279969b46a7bf184a22e79d6e12e7cd6b006c63baa3b1e5b5ebd84cc5e048b456bde6791e6b22b8a5158958d9389c8039e118c149f3cb37449632f4f3a7e8a7d78e8185ad8cd97b8da8044fbccb0e783b6aa22402f286e80ac663062f9ced584ffb65a4d8248c40f2e4120f15757ea84ab67fa13afde92fb70e3b97443a0ba7de124296f0b18d1098c5b73ab58d8aca9becd0851b17608edaf061c01c1bff9c8117cb32326e8f7e7df457e919739e8039b2d89a7561e04b593e88c438458315e55a4664eb8074e66e054e995ec1cac454d0ba0314fdf5a32387e215faa91738ed19627ccc6749fbd3b595b9718d3156945974d294c4622305ccaf74473783b4ed6a80d9d223312df2ef2b1a19a3e7293ba3ced5272b60af7cf0f35a775d5ff2d36da263c48b3444f999ede149f2569f7b297d479ada5ef5376e789a0e71ec20c084e9cb13ae039497b31164e8f005ab20174d77f3d00f3ae9cc70b15eb6b280a844117c86ab77a6a2780351fc47febf30b681f0b4d09091dbe057f256aedd20a4bf4a777956f3d8d54fbbc0f4c0c6b327288c8765a022a96f24c4bb499957d1a8574546158d1f686cb855906ee6d9acb5a5464e0361ae3f99caac651f644b407d6853ca08f605acc32e6c323b65edc64407cf911b00b0d5b3f51080ea35e7bdeaeed42ddc42616a9821a283b82fa5e86083b5726dc5ee0e5b3a196301d8127b79a7b88676ab12a7220931e6b402f22e37174e6b663866feceae3c4e482f2791e94384e08b659e8fffc64bf216869738192e3f94a01ed8dc76908e2dabbc21a25b20d0c1fe2123441face5a6fde0305a232a6a32a4f964434ce1bfd9f71d98f403b1ad114eada9ed026aa20ca29e03862c3ed205397ae99aacf7ac5acd5d7a5e517ec842d761bc453b005edd27b9a53c7fa675fb1a378493dd3680b44d4843387a0c3f2ab3001afbb0578fa72b37beea763bf9fad4cfb5122c1fcd1931a0f3ae0c31e64f8dcf6a67810f5420df61f57866b6f3cd8749f2cbc132455deac7fc1334202346aa4882eab88da3995a714a80524ffa80c9fa0825378dad74ff62eada05aab4bf3eb8c59318cc8408884136005d5b612d87e2907423f4f51ab907335a91a604340a4496d9d54a9cd3e73893b0a17383905cf715a09e89bba1e8a24fa7968cc890618b9c1568f72435002efa01e6f8d9fe4359847ec2d925adaa8c0abd177e97d47e9c8eb366255607a9f239efee5c277f0b3f469cf91dfb025bdb89c56f12ea910fb67147c196b807f358eb3e55012c9ad5e2de699d03344c768770252546cab57c39a111e0bc01509a8c3c2f3d96fb477fbd2c694a7f1a37cf0c7c19513ea783e2ee565dff868156486b8eafe7f8f84418578b7e4f244565496de3e26a46b6af5b694e84b23c85e0d74f0ca66862fccf33b8bd3815e332682dd7ea64de35d13d326d8d029c0417a4ab82ddcf94e43d32d4343bc71df6bbf4ba45546e0a1610efec7041d0f5c7bfeadde247254576f61d529052e1a5b85fb6efb74a00e7a21efda4b67cda661ab9ee8897fbe273447a5ae8bd7d1842cbbcea100e87667d3d5d1b77bda8736325e2bb10ed9b23948b31f3c803e590dbcb26b93554ba7ca4f45cc6a5da1f61c70a3a9b3250fc1edccf60db6499a462a51f75eafd58c7b570f9037152c2388b37c7eb5808965fff3106bebf3c4063cac269236768e74e67e7f3bcb56a0e677c991f07d99f120663656ab982272524bd3beeb643ef8d80c5d46baf542a1a50b8f41aa6296cc669e82507cf7af9b222fab517fdda272f11e8ad02e7b51f45a9012a8f84e8bd9973437037f874cb8cd97d17edcb2f384767ca93c9aa736fb91d25271289607000e610d9890179f63ee711f23b26b37997937bc84d976d9468300ff311f62488eba24624d9156eae263cd34afcd6803f5bc424cc650035b29787cf3f1e0c729aea971dad1bb9ca27ae9a19fa60c384593bd7dc9699c77f351806817a5d1e540955a6b8d03427c99b27d791f2efc8ddf1d55b7fd1f97929fabe19d2b3b937d3e75f88742ac445e5b142df18cb5020d9d2fd729fcf2519937c9d0d757c6dacc947855e5bb379f884a6a1bae31792e36b444513a3ef6dee20b9eb5d84d90ebd031690d3d579fc867df63f7a494d590b1ac31137eaa979185189860c620b94a52a5b95641dbbde5d640f1c1b9f27117b9d1ba292e05b8db59ce81cdfbe6a1b47fbe984d72b613b97876218eb410402db695b8efa8f88c81a3669ff1ffa5e60a32f10de4890e3bc59812dd240eb4c6f2c7349ba6405f8dd60d1215fc3bdca15a69b6d8afc7e0f996691c88592630100d8fae74d7c04bac9de505c97314b6ed4509fb69d06bd4f73cd8763798f0066492205b31c7bcf7c8b5eb26707e2995f043311733a69e8980e548c72b33e87dd5b1ffc7490afd8e5210330c72d0fd6db9284fe4a2b3337628efbe9cf1083b44c3408882ff3e5b1e453b77892591c3e677eef579ae4d0359e22431b9282a6bc9d55bc371a5caafbd36516af30b7fc17897b9ece83779e9edf5d661d3de362f30dfafb843f87e4059d9195590639a60aa0b019486d1ac53f463c28d9a6d545fdac4c2f6f8fb707d41bb50c0f44b0732bd866ff81960925f3e481bf32bb9b8d6393c9e17fa16a257a4adedf2610497414db4c8dc7eb874bd422f7ea0e11c543dd98e1315a1de82c2e7f590130333e5b7bbd66d7896fca099f670e7c5e80ec5aa70ce41ceeaecd83396d62363ae778e4131d576b03f6daa89879c7937b74b8d3799449e9c97488cc98f302412438a1e999f538ad920408d21b432554b20386df47b94bb5803ca4254f3f138bcad9fa756d272e4b3ef92133e4f69d2cc86ea100f22236f8b9242ac0d404741210feeb9d5b954a969af554c03c840f673cafcd765b66e1f7cacb2f0883646d78f07834521e5559bc9c9d5879889a123c03fc36922fecf3b11fa42c1c97a78041396968f01ce66f58e34ee24afc70569c9c3a2f31b58f026fdc3a9463582455386415e0323af06907efde418aaebb946b28d6c01a02d762780dd7cafd6d4275dcb3e16d79f5655ab3ee3fb244211be021926084fbe5e57999647cd02daeaa0cea7178c41c95ad5a8c891b16f24f73044f2f109ff42b5565c2b205c65ed2474e3f3a69f94fd728e5792d8829ad92d431cdf5c553a04021bc9248633ae2de79add4fff39453e50a8a931186bafce28a3dd83bc38fff004eb91b5d4ed0a853ba5b49debb6cb7d4924a106b3382018a54399c965be73259c04315cd2600a8c6aaef25905d23cb4617f8a3b1ea26e61e5435754f1f2bd95bcbeac3068ba37d2650cae5bc7e73d8cc169c184e69fa327f17589d89f097602d897aa5f759bbc0175063e628a0c5ce4e1566cfd75bf0c0f8f3dfeb314eca4007544b619dbe8ab727a783af9330d06e103254f7b7faa7514d8bac0014b690537113d10cb6dcc0a3e1f9b473b6f6d4196efc8c653f153c091823853cb7f53f4c84403b55339fb87dcb5154fbaf4e1753a49f1bda2de1072e8c2552fc0b74e905e91e1257ac1fafa284f5eabd56c6c8d8070bbcf177d5c9d1cf8ecbae91313d30a8776c70743ccf47722fd16054acbb3403bc6074a72997ec6a86bea9dee0bba55b9cd1a22861ab8e8d2f945b47cb235e344acb0d67bd33eb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
