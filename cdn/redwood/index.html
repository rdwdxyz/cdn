<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1c1ffb914f3c5582348204ef0cbfee93f4da59673789d46de468c57d439a7186bbdd373b567ebe1122c4cbfc64481a878de4e32141cfcbd86adcb08763f2328f9786b84729748506e022c712f2980b96a0b7efcf55f9d1aee3ab8e0a05f66ee952ab489f043f89327944454d75c60e4dca12079d6e0b2a84e02a98086a557f36bc5f67a6c1584e2190690b4f8b0e2db998882d5ab9582a99c60c3463f253f544e6a90dd33622a7b7aac57e4927289ea7b3beb2ae69eacd4ef4ae9570ef99afc9516eae3a902f79141e221310a810757343d3e23a5aa19b5258585198c9534b83af1543fbe81400a000e6162aca78ae16acd831023b19c9174b9d58a55410e189a1ec381be5900add349275ae4f2366cb6416a6b2989f67ba836841a49530d240d53c85bce406fe1fca363d75bbb3b5f0d1becd53b51e68e4125eb7df906946bf629b5c6485fd0d10eac5f25cff81b8f32d8d39427a1e467b213fdef182e779489e6e137c92f65289559d9b682708337e576d4fd33cd0911967a5e101b747e8d41956133347473621c1a4003adfd3b240e96d28b72350deae3c2f0f903fbb6ab8288a262e7c60b8753dd6e97c40c4291fee83c18ca433e10f5b66d2013eb29e0b17d7e10f7a0c210ff6f5d1611b831eff18567862627bab438fcbe25acb67a4fa69966c052f9e2ab3b45f208a9a7e1a220e82d79e0ca69fdaaf27060bdb98d9f9582fd1865b08eba53d149e2af83e051394c05b15b359063f1c9d52a2aee8915f63c2c545baa618f99e64c9b3140a9d52655cdae3143da99f59e3ae81256fd4d35eca930bf6858131926e9f019a7887646d059e0c0bdcab76f4bcb2819712cb3310de7857e60342976dacbd6f2d5886e47e5d5615d1991147c3060acff9a8cecfd7e69035bae858a286e71e65f29dd60495eeed7d9c8d6575a6694e4cc380f3b49dfbb72f57a1ed3989cc34e93315fc6fcb2d161c9d1a1d1efb2ab6109150d27e45ffe050c83bf5ebdd7e310f3598b74d7f0382532dfac9630ed5a97e566a2654df32425dcc58454dcfa6ca946528762a049b7170954d9ef4d07749c1ab9b24d0d09562af035714f697ed74b0c192a35fbaa3bd280c339d332ffa860d5c803707e019a33fb6bfbe78a9772a15bed2c0346afe938cadb278e802e57d2baced2a062279ca48d504e8d04776204d5428e61c681bd4ff68d94467b00a97748a18ee1c364d63a2a933e36eb5e9d9aa983c50d2803b101bb9a7cb287c7798cbe5fe6757d140d28fd1616e0c546fc7f315bd45989c2b902cdd11dddb26a761b8ad66d4dc09711f60e0cf2fcae962602aad37812ffcf833cef34b07fd7cfcedeebeea67c6a893c3bfb63fd24e0e4f530f1793fd674d1e6f2983c30632a83c534ef2673be2ced1be2addb1689f90bf9a68adae620333fb885cd74baad5cdf9dd43d09a0b3c4bc6bf9747782916b3096e9a968208841ed8a7c5daf45950768b4b1851304d1b7fa745d8b2a73f489192e1e922753df16ee1a366ce826c4ddcbf9e04c45748224ab7d7c74515647c68ee5df3cc0dfbffb0979f03e0ac10e0f703ce38f6b40ef7ef164180a75775464b530458d50e35ddc5d5ebe2fe15405fdb33fb3613e95bd78ab74852c4075a6de09400217db34627f36072b8726b0edc8d32207cfdf0edc75c4710383145bc6940638872519ca1c39fde4666d9924bc1f60074492c3f36a298d92253d9bb32a9a197d648062bd6b2fcda584c40c1c9992c7ad529012e7e6d71f68fde5a1c15181cbbe5ec8e02942584758171271d913f3808fd74ba2c7edcc468ec60ec2fdd640bf39107cce07ccdfd7cadd3ede1d874ba21f556b6a0e4d76ba95d28308fcef5810b477bc63ca2047592466b8add0b893d2985de264cbc89f0ec34fcb75f781a51f3090e70d6c7d33f64cec338348bd55eb6a1087e6e1acfc910e42159d96c40d139a821492df043fa81e4a5060bc34661f71b38894ae1df04a97ab361efad1b809547cd20bed27f6e135988433d732e2622ab6c65e26e67f7baf9069810d53f827e97ca071d5f15e1ace182ff8ac1ef0886eeae79985f5f464853cab973b138c1047a449502dac833e3ebca05d5398c621bda90a13300b92e2b7546384aa06db0790f82886eeef2fafccbe192dee54c0a274c1e98fcd993d8729b50f56e5576d9323fcee9e53aa36343f5862b87219ef6da5d28ae3db9b1e2e6241af182fe5f0ae0e9345f3f35f0b657631dc68f574b0c3077962c06626df867362a8147107762a2e5a7d1f5df36abb66a5b9767c95a40c24d466b170ca3b455269c9e3ae3140488f0338e9b8ac3781d473fd856422cc47d112212c4d739be8171660fed3ff5200ecde39a2b20925d1a0a13b9cc12095b1ebf6d1b0a1756bf20adce1582102df24197cb14bd2ed036f20fdcd76b14708125bfbcc64cbd90344ffc8d9370fd7ba90453fd1d29d126ddfaa19f1c7f53f5d4f8cdc9226b0c5fdad261fda42f6cf3908acfc18ed13a3298ae8dd2cf54f5eca9d2fca1ad491e286daf5d462ce977e9140ae95293f612696d94b5534e13c733b34855748f8bdf574fb02c04d2218bc8db813767f2aab05d2a646d424f0f48eb6d950e15de53618199fc94c3e202b7a9c3af9c9dc22e98106c30ad2dc4d7ee9746b8dfd685e1f0c3ae26133e6aee41b5faccc7794ae0dea4fc4624499f0d025d9fd6f680b8fc88e8171e2566e7e845a0d964582613fdbcaf6a626d19c80d24d61fd22d512ef2c5b3f9ddd1c15a9a58c0e323cdfa99478f9010de24f05ddaf36e20bf5d99857620d160ddc81d8933983d93239adf37243be59116ace471626aedff24962ca453a2675446ce1beeb32418ca57de20a62fde459641225f576eadda2d8e52c9830cff19ad74e05dff16dee98392dff5a52a4fec4934c1ef90b6044e4fca2cdcf232c4d271837abb017e91864786e0937d21ff2a06f9b5c99fea94e46f7a7b48252263feb6dfa53301c90b63d23f412f0d3f180056d451c7257fab5d0cfd45568bdbe8399f770fc94fd310268fa97079d71305a66f859afd7b036782e29bf2d62e7303e85828bf6b3a4839fa370949432488bc9f0dba3e87eda7ad6230b9cbe1d7e8471defb6e1d43199b76c7ba5762d502d0789640adcb4730bc7ba6a9a767b775ded785521d98ee94677a31cb99b61447b119124d16f5f9c888c5854a026a6b742aeb5c57366c8c981562a652310ff0c149f2ff1350262e49b745d7839e89f1995be189ad7aba302dada9fa0d48886798636209bc8c1b2987620623cb8109a7ab31e24822a8d6c979fdd5e1fd1816c9ea1729011674faf7a4252cfc6cdf96554f36070cb66e87bbc2c850cf854e8ba2efcd7cfbcc2883d5aee3dfafe07d970c653ed13647565a8037e2114a8c356052e2eb80c307a5c06b76557ef5c1f86727fb4d5c3013f401a5adc7601f66b4fcba82e4c2fc3be39ea4c2c2bbd4e4a8546f41eb89b32fe451a6778200bd9a8d03e7fdae71ad5db6657d3b8c489cdfe8614d90b3762e254dc271c5954a80671baefd2404b0f5852301c98730ad69e3dc328010481d155e565e95b6932820a4850694de1c1f5581c86ed05e9fb5a7ba0d5222e60bfa4a7e411ecf32c8a59ef2b0a2bc31d31f84b5df997a99ddf458a363076e182528175edbd131255623fd12cd768ed25c484b9bf60afe3be603209d6b9139cb5dbd42a5c836a0e0deccd0292b973dda2fde509b4dff7bf93f5fbd8d38817997f7af25a9350e0288446fb55e3bd789a3ebd432fb353bcab7fa202152ec83a12ba8d49aaebd97dced61f7ab6e69be409cd7c6d544496067ad2529d07a824ce7dfec1bd9e37d540483154c57a0ccbb010cc0b4e56f09d21ccf7d92586266e47d24796231d7ffebe8bd8ca399d73fda3b9dd1237c21a93c1c06db46e0c0d30f86ce8c79318d21f1331eb0c69686f56bb3d1d2c2f55a8d6e46bcc224406d1dcbe8f7d3e0c6cea9709fe453c3f72bc5f9c69cd3764078957672fb1174468ebc32a5abe67080e5e72b870a9e1a802b6cff4eff2f300633abb35c88aad562824ac5d3e176a6a87b293361db03985bc759d6dabcb0010357610f77cbf3ba3c02929193555041d65670ca1108a89a8ff9abb2d552dc427f79dcc663c62c49d6723c7218578afad7c46bfb1521ec052bd622b62e30937883699da685e397a50657ff523ce4638898fefed759e8b2098ce4303439797707ad92993bb64de4b5b71cc0d4f245e13e485eef594384100f934f6ee5eb5b96189be150d1f4445a98c99c34635c0a826f0c2db19f04a25b02f71a4f2ee73c5d3decc2ae1f139235823900baec9c92a7a16eeb0aa2470678543ee9de2d4eaec3dcbb8723837c4d60e630941a5942b6409ae6aa060fba19a6a4f70407a37a501d9d01c29a20f06909943d42aff48b7c0701fdb67df113d0542277f9aecdd8d992ca274689ce7086391e28bb5d9193c81625a1ffd461bfe24afb391078df76a655da949038a4265f157fc93498470dd38a47efd2c9678b3b099cd2054b85bbdc68d50f548266ac7113b64ed36f0c24d0e4a96d43a2a21b9c65a35df8eb247d230c1cfb7a1e5d3d8fc71f5866dd0df87782e41468cbee638aa1a2485b51bb083627cf5c247f9a1191ee9d1abff6c8360e69049ead00ee45e42995ff5923c5a8226ef62b0b2ec8e7766f0b6402cc250398b0a67f4b93ddb076679cea497051368d5eb65dc9085d91712ed624e6bd09301e46f471cd7e10dff167cd21759399821eb92b70d5f630c0ba89f86cb38a6a03530ce9b979ef60f474b758f81865f357c93ab95608e6c4be6981e6d9506321ecc6b5cb4bbd5b6a2b9fe3f0b01245641a0075961bf171ad882578a21d18ed5311b515ba2d80270a7e3cee8f0a9e39bc9024059ea9b8a3e969dbd52315f0146727d17cccc7a3dfb73b2294ccec71247568fded8d1a86f83538a6adbfa91777cf1ae45be56f2aa7b66032eb8db7044e853971a958fd93210fa3276e5e66878d6fb610b9a0d2c7c37b06d5e160b74ac493def3b482a06284c29941b46f6e217ace86eedff5b717ed37f9eea7035920a1e0c2ba7f65349aef8a26aac9921f050154b1d9651b926616d49d81e74262c04d8072bbc46013a3ea398de96ff9f68e816e2c837374fb2e49b49d24232114906a009b768e05d85bd4a78d411f64ea68a62e3ec629442a06680d6d3574a27974976469fa4c93e4f45b4d29032f7283445e28e1c852838940a2df38fba61770e115e1082fcbee36eaa0fcc06328b12ec5587547d7fb222c3a195649993e644076e76d28b62c76a923a5d712fa83617b3e5c044d90f73f2fd077cd67abb81030d3615bd9b6566d8d989a118e4272bda0fab8fbc68690c3e0a95b6c8e0ade28570b6f5fb824ecf438edc6e664c27393fea03c48cd0a419c3647f01366c67cf28af24206c3d034d1c4e91f6d2d955608f5aa640d9fe5ec0d9a4dffdc2a1102e53ff5bb74697b198be15d448d3a232bca9d295b53a8c016b8113f9837680e73a1ba8cdbb40d7ee104c6e9f72d0bd604bb1a88a9fd45ca200a8655b514f0862c23839801694492a859e97190cea79f557fe38b1c5ef197b1e92891bfba610781e72924476035441c7599c5658aa60e1c670e51a4e01b5e1661fc201ba3235b79918b57e137b1a28a7c3b25440bd0a933f1c005d6defb0182e39f518ca1313060532d31df6d37452da8965a230bc812cd87c1d759f8adbefa21e9b27935caa5b356b561b1d6719527243876fb3fce199e8bb65f3f1c10091a2762bd9c4352aa375363e502c8d9c09dd045c9f5f4df67671580032db11ddb7badcedaa804c3bf1dca11d32ab65d82976e7b1c7effc48f58e50e309bbf244a1629fb5feafa9415d932143f3e61e94acb6b36b1a5a3d60d5c9173b90f3d26983725e06b7225bd8758c5c2393cc40d0f8fc97f68358ec0d015ef0ade463b0906d76d1c0d9303f55c0953eb78cfe2d2bf91e1c2f4a26f3927f0318b09c4c9f4389b70c4f945cde1da1a63628cf5e2b572336a33ebdcad873b487122eec82c9a72aaa3acd66a56732ab29515eefecdd6423aedcf44929d45203273b3bbeb807904c8038263b5ff611dcd5f3f6046bb41f095d6f177f7953bed2ce60a6cc8fd1f50e65ee059284630c7fb1915db1d08478dbdc41441c8acbd4cc9b1900b9e35e70ea9f0be4d6de2d5de42eb4d57662eae786372c4ae49b45ba7088d32d605bf6546b76f9656c0342cebd9bf58517241da1987a74b126e755de1be60dcbbf807cafb8d6d5eccdadac40a458ce182bd11f208000e386f202d84dad320189fc8146fbc48e8b2622070d5604adfa0bdb4961e0f11ca78e5e8fd4fcfa2d986b92f540e17fd7bc1f812a45d0de7f9c26d62b78446d123d8e191b0bfd6371253fc5cc9712ba46d950d44d461ab725f1473374ed2fd84913ef36a2f8175936d680571fb03d251873f5c63995b4dc1d4bfa5053fd706b34d2798c773ddf18c78e34c96e0a1f157f81fc6d98ecf4490352ec8ff4abd27b070ea04845dea5780a1056b925bdc3c9c52ee1140dd807441fcb9d851b4b3531e4bdbd6bc5fdd7f9926c0ab0720d5db45ea38010d07cd0ec76ae4f4f00929a52858224d4c05632718b33747bd218e0baa907d8abfc2692f4991d7fdf2d4ec523733168fdc48409049c598255bbaf43a3f58b3fde4ce345171a2661a47d885b326e6bdc8cf5fd2f3e8548b398c5104189b95899db3d1efd8c7bd2ffcdb052df3ae9a9713cc02e3e2891c777e451afb8837649b9cd28de3fce2714ea2e8995ec540c9b0296b7bb78e9310e29961afe2537ed5027bdca0bcf674dcce409c8b482e21ecedf4d6ac31820c2350f29cd9310ccc15822a5dbb5227ab2a658e502bc0a843bc2ffdcfdd997327a75f20716d0116d18c2134bfadf6319274a300e346b42b90eb16ab31631ddaa3fd2afc74547e155df052bfec0aa5855e6d9c0a8ef37b96097c8bfa879ffa9a7a5d647000d8f3c7358a1d20e3425a5249f89f6cdfe635237a80c689b91a5acc7dcb1f2033f0597414f7e7bc98ea7300dbc01688480c7acf84f0bcd87990e75af724fd7ba104763f1037cb1321e693dc80e1903127d1f0a0512f68aa21adb928f9f8f5dbf0d27c0e5916387a28b7dbd9a78dec0fe67656b945be840dd347b12aa92a1d151139333e1fe3fb795c94eef34d00dc04d6f1eb494de31258b5835ca75ce520f0b1c2cccc677e9221bc555d136c891f55cb107e13c9953666752fb4adcf487e0645f90c6f2f85e5ab64e9bd28dfac064aebb7c9f64cc84b4924b5c82256451c4046c11fed3e8a8268e6aaf5206a8ac5f9861ebadf9fd04d69abbeddce8eb949d8e06b233f6c143c23b43c8e1a6186317a8671966a89eda17bccd9411b6a50b51bb73290eef53aea7ce45cf1eccf0f19224226d221199a3ab93b2ef73a6850208146d41719f6986d8fa707699a4ddf8d385944387e12d8b7e540b013f58d8a3b298685dafb16edfd99b937884f9c8eda394a008172363505825b29e10c3e1f8e58849af3c55bad81b04077da74cffcb774c10637e4d09c03882912090d12330ed92efc2283fd7981b7f8d815d32cc3093d54d7711e03ab12cf505192f780402e0b88edab582f18f6cb0058809b3b194fe7fdd2318bd78ca5528827bdeb17b3f97286f712b58ef4c95ffe17a272da50acb3423b623b9361565c2fd8783001be2be000f318c31c4bf7197a57317a9bb63e2e0ec34164ea7b01cd66951a6490f36b7bf107187bb16369ae4d395bcaa8b935d8b94cb413c836c3c009e128d203ccb52e2e9747f811fa86d36e3c12a6ff517426690badd3b7f894ffaa2d7f2729123e8d53a434f7657ac3ee85330b1592bcf6f6a036fe40e262f900eb62a9cb278f9b65362a553b57dff94d50ea819b91a171971e92188cafa76e77aa5198ca46f7954e81516c8ebbaf4031ffec6427ce40b57cf3e97eb69b7508b8705380eea08ebb32ba2d48104abb6f9b907007b371a723059471128db4ac3ca24fdf90e1925f8890e71a2de22104b4142d4b378a60d5f75a0120caa6933b4c3ef79700e2327feef0f12ffadabea31fe06a069ddb5bcc5fd72ce671503a9dabddf53e41f5ebe780df8c2e45d2e5ca9426bc5006c9b47e24e7210a078f9d6765ad1163a4dcda23e28369f356d3bbcca13521b8f44004d194ddac8489e7cccbe274dd1db4aca3b570e951d8df11f0407eeb5235fde2cc09b4d069e7c6274437e3b9e21dcf1df18349d9428ba55d758535ea004d93d71a2f777395c382912d50ad7a39b428016414f3e031a0da28ce6d1a65a07f24be06a0903eb403b2920d301a8f973f318c4cf3b642fcc55ea3dcdaffe536608ca8bca871ad1125bd5a762433cdb1b22ad03dd9f7dc6d0625344797f1a1dcc6336c125b55ddecb17e42ece91b7805d69094f8aa22b0d44812d99efb1f2aa213ec7821ab979e27842e56724a45188e1375621035e46f7ee7c6f8fd38025be28f807d57ff6d3d173cf19ecda93a121da752b680e4e1c14e4a96f55cbd5e506e75c1740e48995a00cdaa464973761f6e4b43e9df84018daa7f1aa85d217b60286062a4a9814d527c8bbeed6e079c23e55a2ad9b93fa52d432a810001852689c4d1e3ae0a91172c591b71d7d8bf79df8d6ed7f1d0a7ff24d7785cc00621b4b9d7ca172d40e105745cddee4a6160df7a5a1b9b2e3228cd4e3debafda6443b9dbcb642d5a341750e4f415f2b5cfce2ca3dd221dd4c6d94593b965b2f8256ce07e3ea4460159d973a94f300d7a77d4abbb456df5d4ac269b9a25261bbd567e59712ae64296858116cac357c3798870f9ab45e83053bdbbf57a6833571421ac3d515773fad9bdd3406fbe95f2b0324e64d5d49b58aeae36795e81ef027194ad159284a8c7ae82bb95b6aa298e4104dc47d0a7a80d1164d3e9f5a9f0dddb597142cdec4db59ea0c5567c80a3f1edbfabf52a252c72df28c68cb957b858ecac22a2cec8218a8b029f173b98786f612a0386d2a6b8e89184bc837e7efd1bc5a09a7b4e875a952b13aed809af0c515ecc25c961bbb158995d1b9d97e9fa80058d4c72da4343049b87d871eef4bb8ff552b76390260c4de10458e581fc4826700d05bd6deb717e1e0f82d8934d6c68d50046d761066ee64efd395f001a5f62ff5e8d051ceb5cebd47571f1075f7cc8a27e9566496074c187b19ed6db217cdf835ad24cd4ebdbaccbfcd75d4867fa469f7dde619a06331fb474621dad14f5f7cbb8146fbbc205b47c7a2e9b7606d161632ced305144305539117f35df084d42085b53ee94234807ec2c1a6f7e99d3f217a41c1bf28debf1c9449dfca2cd42d8faf95dbd39e6c4db7b4e5b09f4efeaea84ef2bf1632586ccbee2f5a96735438e1bfc01532fa9cee77010ee7f65853b2301988f1567abceca461ceffe57cd5883af319af84192d0ef41d26a272d60d66117c6b82f03a508f9ebe28caa4c30bd502de6f6acc727e2afeed08889e8d737171fad375d57c0b56a7288ecc66d0207224adfd3fcc201c12f9cd9bc52874085550150771fc4a259e1251bdb7501fd9cbc53c72be964bc1b4c6d4e57d7f86e8a81f48abcc4302bbd6ed27a7d970bd5c6d261699372b3371f3841b12094d9ea014b2e61ab60d472b6cd6174a6276aa5e6127038d79b1d0dbcdf45cef312eeb97ebe2831604eeea7b27292d2a6d788acaefca071321b81d7d7f62c9505d6f9682e5f72558a5d0be52a8e78bfc84c9483d24435844d188198e9d15ef97326a5fbcc9fcf324bce0862780a613602f11ae373355f5efa1dd4fa10f29de358adb4736642b4fda655b32801fd2ce7dc23cec5d7962ae17e20b16c1910d23e13a023006d03613826dcc85f698ee57a889f22e5d80f3af6ed1587dc143713b6999646b664500573c1b7a9e9bb8924f6ecaba8fdf719924dee436bca3bf66d5c75b49cbb9819add018b3efd4c4c112607fd3d3e0c02197d72de0fe3580d99add38dd5b2b977a60e26b51dfa64191d9a401fb172abd5de5456fabef5dfff3656e64ffa51917ae79a99b28f6928f1c9ce54a2a5a0505e7ecae1a1eedb037b9642e5b2f25f3a9334baa9414360c315f7b2f817199b2431754099dc8f4f14ff716fbf3f24ef3c2b5417b65443a10b7260f4184b0cb2bd78ca57dabeaff85a8d5ec3c12132d02585c3497146d37a0142d5a08f141d70d481edccadf3f8fb5e80b71158e1261dae96a0023b48e3cca73381c582542fd2a750f5058648503ecf04a04e5b249986b17681d065befeed3323f0ee29b29ed2f6e10d6da456896599f9be623380ce23eca741ba77e39a65f1198bd6c902314380437d5e0e49a57dc3e19f1e2ca19071bea85c14bf94690b4ed9aa53a7f4eedc4b889549b45f95e036ffc7f2e3e1c9674c4e9bbef811cbdb214b857e3d3a6e9d5f086b3c301ad884addc3acce5212c7ac8037ff990cf28944aa349edeea8743320801fbb2579ac7187c08a8f428aa77568221b6a6258f930ee3fa50fb114d81fe34f60ec187add4d6057ba2eec5d900d56f2375f628a289b557dc20c7c9c5c327c5893036f752e6514156c3652fe6971617f2bedf7531de12dda26752ff9fdbc30eb44a0491f02afc625338390d80ce997d50244f5edcefb82dd631e295b57531b7acd1ac2c22f356b136fb1ea441c7184e7d51b5d3b1c17e1249dd34559dfd3ca172437a94472777f7cd25ddf21363c6a348a416c6d975d51e660e15a82d1f8789dda6164b52f81e1e8e5b16dfb56c83564fa26915c58595411f56fb1ad25aaf26540c8d30172778e5a8052ceeb14f1dd2d8917e15520af71e95156d68e7893ea71e7d1ab3c867d72427acdfa5bc9e0e83b12d37cb1ac9cd6ea3244c1dee43db1f819233e750592e59cd43e9d45a3f97eb0fb18b444b2446b656545ca4068076ed87e611d92a5ac6fe02d0d519aa736d06e6567a6e9e59003a996a6d2f842fcadc1e85b12dad132a96c217e34c33bf94ced4b358073ac11541af209c8f29a36291d3e029d44a82fbf6ef895b75497f4ac38b0b2758e4a2cb2b6b0694b24b0214bff5130a84d4db4bf94283a424bf8d1fa18b354ea5fab5e093ca675431e4bc6d5c9bfa2ef43ba6cb0cdab964b8d4150f3719d70f4f166aa4d8018ec1d4b6e637a770d9aa691a7164640a26ef0f16fd12b161b04c7b8c5f91517451c42bbdfafc82a534419fabe854696cae6a5beedef3625c784476bae75e50cccda96d0da0c834a939ae69bd43c1225711a8770bc340e2250afa7708ed79bc0e3eaec9a1c8b4c08cc6d2357595575a3b9cc88cd80965c67fd0f6566119d71cbdbc52ef79448a0190824a504b0a19f5d5f093920f476e1c2e6d5de75c8bd31dfaf358c76f2780804df63a95da2b28600d7026c0ae9b5d2027236760208ece3ef3a17736abe2218d17972530176c3dc8635be519627cce831d4d5e0aebf95067d1b1c8907b21fefed33dd5172488e6cf4cc1476a87fc87937a89dd10547ca0b3eab79c5f9da97bf47dfc89de99abb077fa9954bdee53a70bf1875dbef4a740a52fab370e675ae54eb760a885420ede4ef50847926509703476797da498b4e6437d4af526a236bed9cd8cd8b48f55beb5546c4e129c065630bb988606f1a0adae440bf0775ca3dac8679e1225155bf5f7a4160975205adb246851340037a43a27c365ef051d829b30fe1bc70639014de0fb1de5db9afa3923b18893ad5eafac5b10597391bff8463ba3f1605035bb81af726cc51451716186d1c3b3da12d9a2568bee779e94a5e8ba3fbbaf55d9fdc115481fa32ff1f3540ca5327809cf0ec6752d022ee599c15e8b8311c06d29758611d165e003dc5546dfc31a03fd834133aed4a8b64f57672d65f8036189871d1b75253104628a2fe2593882d60e11860fba92678f6357a8bdb608c5b123c071ea7d8e3916f50071fa068cf7e2090cef934f3321085c5b7aaf36a6e0152695df102e26ab623836593c97dec0489b782940cf988a2212882b3fb7519a6e292b086952f19fe4fb2773559debfddb6b43dad4d318d7b7a44680e4b317f8f00ea95a33b72b5bdc5b0b1bbabbd947f6f99cd09248dd1628ec7ad29f10babd75b8620a5e3df8a34d9d3bd3962d12d6f1d6b3e981f2de5b5aae2457de36010155e16cab50ba04389dcfc8c7cc56293669d7b1b1dd60651a9e4799c3417f67ac49d48c7661c42791b3ae0dc8e206120edbaeb187a9f75da66b13f4bd8a388843de80ede87cc6c262009ca009c75792609e9d3ae895839d57e6c30eda3bb253011323756fed1b832d5f5ec3085f6012bc840dcbcecdbb6895f460af85194266be2773614e680208b657d8feca799d23165c5a1cb3685007e172eed8e8d21e0ba0add8e19e170dc9ba9545fd2db56b8ee357e518b0b6942d6fecc78162558c1712c1ee2b5d3a4586ef125a49a29dcc57fa2180f28217c13812cdd4aba09891d006d3ad10840b76b1be1df7b28eba25d9fe0f3d430521b32c4a1b8aa3d681904877be0ab5d4f3aec99109f4ef2329c26895a0c4c53100835f76b5d74f9539f9b5cab6005543af9afcd603525ff4ca67bfb4b3615eeaa65cae654de42d69b6aa5d8c09234926d7849fbd853acce10ac3e82359192852eba22d3c71023fc77c9934f2cdab241552b3723626fa8ddc761367188eedfaa64a8f81cc387ee3afebed5e6b062da0b9b1051819d781acefedcd8e841819a86338a9ab2eb17cb350d2e49b321ce836da1d9b305d3817d4e7f7f77d3a203b1c36f8ec79806e0530f16417b171a0a5276a451d9445af02738eca2805a57703aced276e7bfaaa32f9ee06dac65b08a0572f227cb5fefd48256095091410c1885683b73d60ebc52dc208f700c82bf0047368e5b71180683732d2071b5ee8b5033cc8a3fb8e197b14e05b5afa038d1d01df1b24c5f1524d79f563ba3633350f40d44892f5b9b8028086d3fa1a1e0ce079c9334217c7e7c410ad9dcdbc4fe4f56f397c01124f2612723ae703ac3bcb8977cbce1598ab5da4f5d7a65dad507714255438ba400b6ffe4f5fb2ef9b28a5620b4f28d3e6d153b13291b9d9ba78aa524febc46852cc0fc3bb4b2a944d15de9679e84eca6ae8f7bfd6e8bbbc88d883d7c0d5ff699f0fe2f2fd8d28580e7ccb3816e2abd7fc0c6437b128a5063ce11a2561a83faac1b94c183d39baa9d3a7fbcc7e5eadf352064b6a112b313218035a0c2f20ee7b0e8195ca38727b46b9dce1118f184efec42031837014353007c5f9fd93dbc2cbe37dca36f9cfb6cdff3d99b47095d74bf6af421377acdb5a4e8c79b61bf447c4bc4d5792a887c56adda9910a1a3813eb49077d8c906397746504912163b83d3ccd751cc90e5894c910b5da8a991985b9ceb402fdd3a70aef4f7263802ae80e812e5db9ce231dfcbd178ff5855bf3fd0e1db5ebabb8f21391cdbe7b0b9fde06e9d4cbe1836e42f7414e866077c4dcb376cfb4953ca6916beb2197b3487677501ff5b07b2e880d234caa7cba7567275f7cc2dc5a7c902eb7547c1801a5b179211504c97a14fbcad23e1490ee43dc4215641c4940a46f76e299bff74ab357f30303f1e42aa486a45c504fe107d1c258fb4525905837186c4d81ddf2fd314c997b98e74a50e547c47f10cbb5cbfd9e24f0e63099aa60dae626f2a20cf29875fd55033eb5cb7b486ce5642321909d85e4edc6329cc1e16146bdaacdcd4f5e2910d1f951e89649b06cf345eb138b81d9842aa868d96fe74582500ee9dfaa8e3945cbf480a199a694d215b00543d6f1f7a07a1bd8557e466a836246e3fcf4b8c6accf04fdf8dfc1bf9b422f079adbd8d83b451c98a80866dab071346de77727556c30dc67433c832f4608b7e818914987e75e57b21225b1ba58708df7b3acb0cfaaef396f6036b9cbb0886f09128715f896dfd529cbde78df40ed21ff5bcd27188939297c6225ac9163046e174a53d3365fa166790d46cb57a70728801f3efe0c15aeaae0c28f7858e0ce9a1a37591457fb7551d4e44302a4fa761548c98db30ec7e93ef1e69a3c57d23375f8a07b60ef7555638b9a9b6b93fb5bfa3afdeb4f78ba471c208fce27e5f1415cc651ec88f98c0ab648c7b56584aa0cc4659854552f9f38568c53922995b67694a6a2250b1e8f5614aa6b2068013ad900094fa6ec3065694d0a4604b88233dce540e8dfef49f4c7a1c00a4394c5caddf755366561b546aabe28e7eb3aa47742506cf3d2a563223b71c42f02d3e096db39b58947fe745a9a241d4cf84bf001f27649d23cfc74f5e8f3ee926d70cc2e834f7c4c64d813bfbb5eb7becbee35679a825a15a6c0cc3a2ce20fb559c3616a15e3e353d15298c9ef83793c684173c5e839b3aa54350f362e69821f3e60ad08c803eca3400f9f3f81b900328e38640cfb5ff936936c53b9d01a1e946dab4be4abca8da63411d0795d5a5de5f09981eca8bcf3e474a59fe2bd93dc03f1a44924bf8fd2032173551f10df635fe84800bae6a4f9d4a1e326078a6d72f7a60e434b672750edea5a4d04c1b5fa2d6cd89157af2acd0d07884adadaae7e96caf77a28a580bd134ea29388fe31217487bf315944f07921fda8363fd142e122a1480cbec6fb96eb99d67e25318a177f35cdea3df61294858e3d9645e491fd4bd8724544cdfcd31d04fc45b866198bc18b59c48d8e2d7b9a71dbf024e4ebf956ed0394a1266512247cdc1e5070f9ae3b8376779f5fafdbb261cf11ee5bf11687823687281c9a1967783ee8008413a5fff7274e5fec6d165f276fa5e23cb95bbf34be62b675ccc61b45373fa52f92e4064b6013d9fea7287a95f4837ea7b3594e0797a038124a87a8f1f11c70ec40197bcb049a6227cd62e284eed0e8d2d4e6ac8d686646ced432d8f9a9402b1a7458d7953bcdc24e48fcc34cd4ed8603f55279af2a42a584d682e5a6ba779e781628cbfc11377762cd074dec5837c8472a5213cb5187e2b22b77fd6f3eb612a571cccdf3d76862e50bbbee7d4d00eea12a0289f4816a2ac46db0ff535a5ff0b103f035e18e56918bbb24006fa5dfcaf1281abaddac3891c316cfaa799a443","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
