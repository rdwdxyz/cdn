<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ffac16b1296aaf0d23313bbbe7c3a02d11001438983f7a676da661912e8079545e7da7f3358707dfa40778f10c11f63510dd8fb741a4a7802289b7c30ee75bbdabe55a603f455b135b0126846ceac07fd8b4538d59460eaaefef292c138d4826465e6b4316dd8e961beeb8ca1932008376b7ce626dbff4a2ce127883ace33c81e11a6fe139e488ee42581197c4e7cbfbc9ca4cf18f9593392a6dbc79326eb729df67cdb5cd0f4f202486af53cbd7b826407dc861942a14f9f7ba5ef572e5594973e0b1f51ff473cb7a49acdd252e38d21ce7c17f5d5f7474dddb97dd5253a6c9f12bb8cf87dde9b885c2ecdf3617fb5fe3ce73e813cd6120d6df37014aafeeb2c9153229d880cb94342fc602ebd9a8255377625c5a9d8eab769e453f46698dab41087f86a66e42839d37a63713f6c0771dd901d31a86e7b95ebc4ad9e959e1baea962316a00dbbeab803c6be3d5cb585b9c16444a619aa2a74827054f838c2cfb7a07692733b7075fe31347c602d83f5681a51dfbc8dcc4be2b0b2472c67a4a142ea720112dcfd794fc769dd0c07e2e6d7270a55a31f6007fd2975d50e74d93dfc11a311c6ea5e44f4908d6c32a7129dbb12a5eb49988a26e99166ed26a128b2fced29332c5c66859753781af7cbbd86f699105b00bfdf62b31b288b76c75f698df8a00ce184a42ee1b5ce8cd6f04100d3961d869e7711ad66a254b6a0e6d1f58c1c02c51710f6a121a83571b9e13346081d2e1b0f864e2640ba980e58cae16d2834770d5fc3f33a31138740d5cfe4c11291aca8e5494827120ee25a0a2465cccf350d2711b25ad5c2ac7133e656683c2ca84a1c44ffb0a8b5a637d563b5ab11cf948641302a79fbeda1cbf0661736990d19a1f432ed75e407110bba7a4a651834f2acbcfa8d9dcc801068d74798ee798b299af1bb0486be5f56c57ffcbfbf04c4f935f4e556b6768b49ec30fe5f5b0b986d8d26b795ab86bdacfa09abe14398dd2c42684a5a54b245267e46b407d665795133626851b4b3a92105ce4e74bcbe75af54586bba326dfbc8de57285422e0693bda509210ca5ff46247388db1e1bf91dd1453077c2fb07570a9f96450c4d597ec96300f890bef010aa0cb39cc3a619fd592a04a5c3132d5244fc8aca36a4d1e73b0d555753c05eee0af44d57ee13139f4198551b265577e05d751c55a317b293844334f539dceea477e9a5cd8c03e478d2d74b8fc0424a65efd7686f2a792a979be855b571542b81b6765a405a687ef2739ef9409d6256cd4626356ec8d91728902ff8e0a420f162bc856f3110ab0c2d6d048cfb01df255fe8141ff2e6fa518c5d9f2dd6dae8914cd634833f46c9da1a6bf2baf1b58f9ad53ea4166382194ced1c3360d5f7bbb100aebaa820671f06641c3d75dc1e5dfe2fd277166ae28d13661adfd9a21a93422fb41d782ac59b18023276100ad1afff18c4ca87e8ca8bb3fe84e42dc1bc431017fa9dbc4012457500af29f4d1b43fcfe58347349e231eef56a006110f4f067a7b4162095531ed77f1ca3b76c6d5a3db9ae769c213395c9909ba7f80dbe82c59aaaabe7e70611874cca599ff040477a7264a54a7247d7e898b027ae3556b7758f2513c78840d3ecb7c558f91a85b3e238fa9ed748ef5d569498c0a9ca129f41bfd385d4dfa494443d87c3ea33b11a29f6e20ea44d5e5974e39fdd261f492424cfb91f5552f898e0412730d6cc889b420e66d1c9790da0924ab81c4529f7cd67a52027c312fcc5fb17cf621ceec6b26936bdc94978c2f94e713741c8574542fda92b552e5487331fc6c2faae5f932ed6275d918d17570b3494a6fb7c1b48edaa6897533cdce646afda25a55d273f6be5331c03bc14996f3e20864cf246cc6875655ef179057907ac0d9335a79bb0fcefbb28ff4050e4e2201d3f6cd7921d05ad116922454734aba79f87eb6434e792aa4d2b191e12b63180078a3eb1bf14164db888152f439d196e3c77f206d5d31f8f125c662857751667ada6d4f85e5863f56bf596b2e8e1b6288a2ec1c94c7402b91f1cab71285b4dce30587af9ae9747fe482f61d2325dfb337fae67517b8da4b6704bd03c0ab2beabd367f5e611c34a87318d71a68c2db36ea591afad0fde8ec7fd48fee566fd93cdcf0ed9380ab3e4a7b88bc533abfb3f87203f139a033bcdd90659018b49059b5b84c53d71e4e7b9c9cdb095fd49c57a9df67b955978ea05ee5dc90025b8e82469f82f8ca93359f176f2af87e9f64ddf8af7f998de8f27f6168e3b5ca95ece2358ae1a1de0cdbda6d8c47f4f1f94bdba49286f44506725a9323c1c19d137a7bea97b0a6fec7224c73bd33b72c854f4df577f15a69dd777c825828ec3e6916b1ce876370eb3ed3b5ee5c1815211f714a318541a954633dcf4e583761409c88bdddb6b56a9f3965773343d79125a6a64b2fcdb290c23e556a96fccf9c883763bb1a853b65a763ac7f6efa93332dfa9fcba253c54c2d5ab14fd723f7b039610c874707e5663b1136c9475ae2aac31b51b6b42c8c846450f9356ada71fe9deb6fe21b502f2e75286413d6bdf14fd55c3b7da28c11d90a096dafde8c1910e37fc4eb6f840d15da75400d7da02c7f8ea7f1d85a8bce55daeb72721a6168cf898bb1e61dee7e385e18d071d048e17167ff7636000cf84cda182b26e40453298702eb040309713b47c11b131dea744a85f8cdf0ad019e8f6415524de14465a676ec6a8885190741808687706cb499553fdc83f6d5ecc770760dd8a2e360155372d291269d02b48809a959a313304bec132bc7dc505b26aefe45dcd6dcebb3ebb9ba98c90f485a462fec5ba313269c5fe425547d6ac757295607a6f6c55756879651d47aa55b226ff5c069cc1418cf85164d0ca796174daf8202dca0f5a753fae722ce79442e889f861799d0ac41e470f3347b81c3bf843c61a358b7de9835162b01c95a831ffb27dbe6a3e085458d9a40cbcc1c036ae0a45b9f6771610d411e564719ed4dc0d45806a710ba170a63ba37ab3f9edff922233ccb668b190942bc438b1ae37f8f66787f6ee7d274aa9730562a73d82bf485cfe9671e26b6e5964f0957bc70c1ac5b0aec180a64e61f3b93f8a663200de5ffa84ce40788874cee448345514027800452833811c6a0610093ab120de2958dff67e411c0319d3c01ce0fba76c2b67aedf51301032540e9c806dede02a7d3aec51d12df8d09762ca5ee2edf8bd4c00ef7f9e7d96a1aa7c9b0f90c918cf63e5d26d3351038e40f823c5894e4a2f6c3352e67b34ea111a94e07019c634edf2dbeedb167b07d59324faa88258477fc507963960a11793663b568637f153ce21add76cf40278a97c23ea131405f464f0de1269e14a49328a07eb1c1efe9ad63125dcdc7381678c8bbb17e3ca9f9b6439f6ab21b813b996c5eb15e495183e2a354dd0db2c52e66c0acdef81aa66b9af232441bd96845f8a80a3731baffef95c2741c920b6338c6b98ac74fa322efb672dd0d90f5d6e23d272ba8a5b49b640e799423e5c78a97e11d7a8a37b77896418e7b2c27752cba8b0bdd526dd9063f91cfcc78d9eea37e91ceadae52537ee9beb9d7a25a4fbe96d15faf9310773ecd3cca8d0ebc9066a89587103bed375ffa82da5fe5df4814a08f3ad1324bd9436130a5a492488040f14b7774ad618e0efa2c395a95f0011e81561e8afb536fc44508f5f4ae1dbf608f0de753d2b403ba90dd2c69129082ceda6e819e9f9da7152b5fccaecf8fd5afbd4843aa54411e46e891382ef1e0060d84b161ffe6e8b8d380f3307bd59bd1fdbe8baee44a3a7b79639931fa724b6ccdd08ea9faeacb2f863177efd68f69bf8fee77acc3917462613f52d33176a2717f858108effdf8ff35a7f92ea52ab458d5fa405f09b555eab8a7df10b696c115d2e9aca6e199f23c469f1a1b8a666ceb6bc339a8d6d23765187a131f92f95fa94a081d46bfe7de4325264b317420f03a3f811d8ffea51e085bba754c3f5d6a9ce9d0d343a00d4b53e678b96292ff55ba150dfc52b35c1d5ce00ca4746d9650e29554820c1bd5e244273064efcc02a6abf12f25a0aefb4dba6158d377521e3b10891258397c0c2b26970aaf1025b9dcf8648a957596660623ee107a24b853a276ffc9e59def0a939805d5cdf698461e89cd2a5347a12af146d58112d5e3e8f001e7ba5565ea3a27d33beaad57daee8b4c8bf258ccd3a8f84c827df0fd82ea9fd3f9ebc35fc691586f5fcdee93ee7cf97919d3601314fd06ef0c0d719be7f378fb314c552a57de0b847096744f7be48fcf543fca413c46455c1bca6efc4e1ca321e76a93311a02255a78f7e07d5cdb1a09e86db45bb363752b7adb3bf9407b118ff254cb62b88c7f94c6d5dd2a04485ae92fc40acc4f86e8d1da1ecb9cd5944072667f71220c26bba4e57f4128338fb4506bd8ca3884ee8b3399721eae29c5d3edbd0aebd333a9b3ff6e88776e6d73ec46c098cc2c1564255402d21482ee67ffe040ec4c6bf4e8409fb6df14bab51fa599adb856d32fb1e1c7298a981d21b2d2f49ed0bf3e63aae8397171ce3e2eed54ee76de4e420cb9cccbc724360b27bc7682be852f63bbae2a41931d68cfd2726e3d0b2bb8333db3fecf6ec9ad29d846395b0a2fb3b780cc147c761cd5d82a186c4146dcfa9eb6803765a5a21313126a9e15099d2ec3c9c8e4ea53952c514329f9e6e68f3f08525fbfe84bce66ae39308e5ff00892baecdf9fb31eb33a73e13d5c7908f64053d64f2f0b5d8438710af615fb4f1e11d5b65cdc0dd51790d7742741203be01fcd34afda5ab1ddad4e346f30892cc21359ab3f1daed003e4050c935fe143588a4a268252d3c6213327efde6e43d00edb29cb613fb85db6986f19c071261e45d236df6b7a41b6b8b44be465eae5b177b99277bd1bda8fbf3c25f6a2d04b5858bb820a86c3d6ebf3778c0b724750c2c2c45b168545a50c432f5046ea61ed9dfd2a744d64020cb23e540acaca13e485905649b48bca0f48688627cb4173792c91c13395b9ba26e91c12e511759f9fdeb5ce42ac9981d35008bc4d3ccf0f595e7229dec6a723e35adc6fa1ca0eef2b2832376c303b6bf9924ca3924a5016cfa064e4ff4f6a90043035faa4f80528517a7a24fc7dd09cb8be0886abd4ab306457782b2f85acfd3a7df86da2444e19f2e02b991e24d6cff5aff0077ef4cd3679ec8af52342dfce1eb387801dbcb89bb952e9c92933d799fd7d2fda50c1a121143c48fa086b07634d066708da6e9cde8f651a43c0539baaa164cf2d089027a24fa5c4fb7b52bedc08587b512f83b19acc810ee8656f154807c4b04aabfbe29ab469253e5711311c2a519401f3e7cc80945d6fa036c3cf97e2114ed4a9b4c1335461a0a106442a92a2860581e15fdd906068587be74c82400a16072d97cc35c1537f1e6f0f8947d397b33c3f276748f8e6e5785305e90bad7bcb32f6640480cb33a43ec85a1ce93542d9fdc4f54cfb8597ce0b59b26c92a667f5ccb9e8106b2369b6d7ef15796e70a3ce3a1ba348773144ba9aac300bf7bc6271dec34bb200ae0845342496a81650cf655c23381ff72c2c7e7f720b152cd7cb4a72ca169760651efae0923499e2ae346789c65c0666281776b697bc8f3004bcd8cdfc2ed20f64eb4fc412135823ce33ea8e45ea40dd1fea66f258771df6e3a38bf33f33d8332b3764c5a7708ceb617d870392fc54d74098647c1b6d53ef2f74fb12e6e4e8dd1bc8cf10a4887c0336fc935360c120e8995eb6f992c79ce196d27da88a7bdb2acdfbf7a704b18b7a6f2307209d56b6d3b058a2e54ecfa0a8c721947d443ff3662a096032592e97fe15fcd07d88ed582b947522b2f001399226ca4aeebf37c4f9089594360b836551f0cedc4f85d4a7c2018858ebe34d64cc4d2376cab0128f376e1e9595b87831564b2d975f439f60ea108d8cd5c89aae691a4361f34b60a2b88e29e7f7c9427bb980332d0d90b0843cec097b5d77222624da13159fe0eb47b4244e5e471214bb355cbd8713775edbe28dac6faafef06c7aedb4c0703fb2a47a01f6e64e0cdf01a762bd7497327a7627c7955334a970369144586a0c9ebad96c01b26f7d7f67db1896d3eefd062018cbcafbabbcfea968a2163dfcd62340f157135fb1febe3703d0f3f365208e81fdfb8c6d598839f749f27c3413b178f642a5d0a311497d9b42f39444ef3c804e88912c6eb1a50288a6f15c5bb7cddbd5c6f70813508dc374cbb2e39371ac08fb0cdc49e0913c99ce27a8d12a9b305bf67d0f9d6b729c8f6518f61eecba6ce9581b8e125e1d62942e0b90ebaaafdea35c7cf6ed04a04d4e7b19db02a75d997e132eb460519ad28e2afac3c421efb3e5c1e2f142d6ac8ae7d9559e97ee296cdb7d2509564e81ffa099350b7d6b123ee8cea9311a199b8159e92f77e5938d51d87f67f4fdc7c8ef2c1704acefec487036be26f1575f3fc747290fcefb165d0fed2aacb88621788fcd890695812ea294d0fbff157d1379a191194b4040f4228246e6f820fabb2e202c0b8ed9ed79d7f6af349ddc97fea09df68db3c2b9cc06d8fe9dd5ae9425fd5743542e985eb8bae6419b716f8fd7e1dbe0a1fd1c2a02d3673bb12e6c494a4082f63ab2936fc0f676f97e45f3ccfa7d2504e87918c0783c61d0159de04cf831b0fb9ecf29201c043dbb020fe48f753c7fe63e31522146ecf3526715c70e5bec7f317ff70a3ef51ba519af280026567e7d50a641a8b74645de306d3e8f7e02962d8ae3c05bb20741d28de9393e5dc02bf840037e6901facacc708708cb290318baa10f446f9df4d18757c720986e790068129b1c1d48eb20292260f7f5d8edf788683239324768f7bc24dfcde6fbd6d28426c9d8b4f597c7908d65c795f2698f6ec72c25aa831359fc3014241c46c06ddfeb84590a7a63061de5d1e95ce907ffe8c35bfb6e9aae1f8e9c8165a52785d603367e4d0d2e174888bfa79bb4e60b2f7a53d8cd8dda60e80cb8c53c3c30ffb7441a0576d489b3ce726045f66c162f3df0bfe252bac0a1029f9db3c6abdde7b949ea187630ee90e9832b30842fed2b994d46dd3efa80ba55221e16eb0555d8dbcbe69e71c6bb2acecf53cc3f6bb3e7c1e567a6e1ed762ba951307c7a4f94a956309478054e556f0932145d0e758cb9877583cbbbfedd6f9be814a7affe987a4b3f33b716bbdd41fc1df319919ae0e20f4a3400bfb1f6c595dba84fdf2bfc081986d87a44114c934f2b0957b96b71c562ad7c1cd4426a6fc95b407dd21c9939f920ab2feeb386e00a467c0964ff2a40e20fd965a8b6b6bbf4b944f3feb8a60ede5449af6ab7538707ddf3137460b82660550527a5d5a7dfc5a8e8c262f3fffb9139717499f7a7b4a8fc87742dc737a0f69a636efb17ff37670a0adb4bf7b8fb4091ca484892288797c460a00e3cb4caba4a2713cccc771af97c735f5511dbe0143029ed67ced873694233593908ba298ea01ce7115ab82f599d3a6edb57efd3fec7a08245b7d7ea94fc6ede0875fcae5826128a6b944ace7abf902481dd9e3a5f8c05caebcf7b99beeed718cb56bb520531fe17b0c4f55c061baa09582c3250441f0d80e19f274c27c1ebfb2b94a90b3e44a7b278bfd4fd3c098995a8689a99e7358a45872e393bb3286315bc3ff9a91f9f7165fb12da522c0e85cbf33600d1d3d5c4df197e37a7f59002ff09df553ea3bc5a143e123eb2b5b9c0b968b1f12316966fb937e7b53ae3e00445463f2e443372a352e055ba2bf21be5c0e1a4e0862c58a18524acaae7dd9d04712ffa3588c68ebab9df5167d0804fa8136823508569338b3a143ca78096a08ba36a1c074cef827083813e3624ce816a6c026f8d6af120f2975f61a7cfaa1ad995271fe468999844943895db7a30698840bd7c4c7521364fb2a69ed63a6219cc2608c60779388a1945ad21562b67690927f42ae4ea54586b1cfb3c821b7ca9860b5885838ff7dd75462897bbd3cec095454d8c0305b0c050eb7f1508c16cd955a4311483ec273d8850321fb17d84233195d232d6d4249d0dd4011c70461b2f71f533a63eb0590bdabf8d69fe789ad71907509060c2477481c60104ec68a9d4795b6ceb4dbc3d99044d3525d9c583b1b087df86d753f49a06a081bd8f0c706b4c8c109a4c8d07cf414f482c109a9a3b55fd22ff4b5b78ed9ebbed65c6d5f1aeb635995f5205997eba7bf9a52a16d5a3507be3d9ffa5c442331f74b2f6a30c7d1840bde517ab753a8487a9ad6b87a342852f729f1e16d49ba0dd76ab2a4e965ab11b8604b513dceada53fd83464f19d3a99cf5059e6943ba4c0945a1243f7ab13d5a13759552fa0c48d2b0e931773e37c1ad885d52c524239bf7df3f201baff3fa165c889d7c5b5f3bf6ac9d82293c6d9860f81e6649da74dbdcdb63f898f99c0f0ddcf69dc2a479cfb38fedce0a382d710c47a7b37e875ccedff89c428e6f7872491c7fb4338feabeca10ad4eadee08d3f3bd30649a1534fc5fc8926ca5c275b74e62d1fd29841507ae45b59785e9e94cb334c824ec4498a0f56b5e8b0525a71143cd8d8d39a12d789b22421a914cd0c943ea706c66b4478d8024c95d2a01df51008ea88561521ee9858fd6f71029f868681beab8e71004a724f5663f5d7b04b3cd6b23bc6a81158f77167d983969fbbd1c2246a2fb95627f077eda24958b63b099cb7a4d72bac9522fc349d318427b01c76c6cd1daddae8406b3b72a1043911eb784e2204e5addaeb118c025a0b8cf949d28cfdd994fd655ecacbd14a9e1cc603ed6eaa7fdc0d4012ab2a2dd20900fed524a3b8c9e588dcc10b0266a9b77f52a8bb1ad769304e157264f80b4cb688756dfc92c7f89d97537e275d05f1baa14e030aa8e264c4505999ef369e46eb8d35642661b27644f518c83701ffda35438f9c5dd83b3b69673ab365bc89a2861492e256dfdd09cd7ec31a09fa9951629b69d82624ddd118ee9d7ce221fbba15bf819ad3dff30cbe5bbfe096c42128feb4a624097b739c5a22f89695cfb7f4fdcd97242dc47cb2f1ab3df2864423fca16ef80475ca9a311025de27c8b1772b26aa8f2b5ea78c44d79770ce88adbb361c164f197d6080662abad836ca7908f4b680b085a4410a6238edd8fb8086833e326e69a57125e14ed4e37994926eae46f41679fd9d3ce3a0bf9d392be58df997f4a62c0f027dbac35985a0f9ba133fb59344db267d7ea0466d279a276f4ed6328de355895ac6ba191d9eaa01c70827d49a47a5eb4ef26d4670edca78c9aa7bf23464ed68ad0d5a5e8b0bd262cb07df17236dd30c84d29a5216f8bf950a6594c2cad30d0b2bca9434738ddc34af99a08f46470bfc17d49e216fd34ee9519929c9812bd433825a23577e5e2a2f1c579fb9dd9a1d318e999c1b5f29a0f8dd01bb70f0f3c10e6741661620c595d3281c64c749896f562a0be172979adbe1b067d51fe3754d12da5975091341ee9db7fb9be9e4487fd6dbee769da9798c36726de749b2283e813a54e727a31aae5c5b40506b0ff0dde101187e8591b97fe0ef43724a8e6510aac4ff42e6159a82360a77aa81c3ede795c177132b98ea7cefeee78377b39fb477b706021ee4faf3646456037b8d3fbfb0c7b2ecca769898b6ac00120c31113888d6c84ca04ee74731e487506f8021c254ef3768541be6997d08f8d50e3ae24630a69e4e71ec5e34a53a9cb8f28ee4941963916589dbdd51e02576137eddee42bc5f227c664ca35d7c0d460aa7696a25c23940e5c99ab8b606cdeb778d97b151d128dfffb9d6cbeee176b81e4768f30b6818d330114af2f45612fdc88b5e3ff127f0d9293e3d1417a9b10a0ba75b9f754a41c87f5b49c557840567161ecc815bc9694b1b03faecb85bea09f742471f25b942c1bab9ad4faf51120249cfa89b7d111071c700c0a42e52de42e0e870eb699cb5610b28cf2f944e62c95bbecf527d96e6fce224cff7ed8a34981ab6c7e6c1326f1bbe503fb44c7a92c526423068df8fdaaac2d9acfaa262f835b2e139b18f36dd9d320fbb48e9053e961e71ba59b0fbb8945cc51baef4809594fe7be83244d626246611dde4c35146a18492a1e6a8fc959029513364b3b8454fcd339ce583e3be5b82c11108f3f047c70f0414e38429e635cd72c384a6069984352eab3bee258eedd8062446a0646ad672dd86ad6b9dcae209552385cc6b2f788fb70c8294e9223519e082ca715ab88b8cad325c17d18ce4199ace385382113a58b909a1052ff875769d979b57a22ac9c84bc7e385cc2ddf01c7c00e559cce8172aec0b90b990bdb926aa9e647b790c50278d53f43fc135455e36ec28a6c45d09a1162947931c2bee31548613e22a99770a47e42984a7cde42998ebf799f352fc61547a430e39b9b3c491e80da374a1519a7a83354dba442e98712c75f620f9108ad6b8ca271dca51e97fc2f9d6047be743c462ba45b018cc081e12c3c290ed70398de0a4203b396e5fc0cfcd3ce3329c4f37c579b57d3f95c6546e940d79f719f25f15b11691908afbbc8df41ce83174036e31e89d850261b8ce8ecccfeb811395da836244440b0800cad548455a692493189f8d488dea81caceb4631d8e6d67cd850e24286d6765a3b330f49bb6aeba8b52a5ca789ae54a91b877222378c61918e3e2cd4e7234309142c2b3fd556ba456c390f704ac3216c79a5735a97a1723bc2a6b2397e0b5afb380996b1dcc6590ef15479c39bdc437072968df40899eff503e01ae52082181e7bdeb67b98678f3e7fb286e28b8cdbfc7ce823d76bd0d396c9fbeb701e528e6b98c172cd2ac5316d46715fb4583c74d01840b73c85e30129c81b43dc759fbbed1dea5876596b70e68fa989f905ad3025a5244de8899c7cd329c3f603a9e2cd92b9ee9240db95aa74ec02cf235d74f39333e0905f4b6137fc2b3855e333dc91b411eb5bce3f0c421bbc32b3669d7d24417d08d99a4d6a422b77f3a8e12dd11c47413d4511fdd97c5b17d8e540c2bef9c0e983d182212ee51889d818134dd00c752d1bd6b4c35093c36f7ee0538e0a80842cbf772c33d9123184aa0d695d5d3015779cfa5c4e1dcb85e6cbe127ae0c33895ea0b8f461ff44f3c3cbeb63de1a295c121a6830453fc3742e89087550490d99ebb961d9cffe054ec66baa3f9f076439caaa4b630a1fed089d1020ba6cde673895a39b73ababd242b80a05a49db0deb5b974a194dfaf07210ea7465d8ec595c92500ff4012011a191d0705fec7a4a2855ebcc86a89f21a94eca1f7a401beca443817df2a15e037de555206d44b1ce7609384f5f4f05d1fa797fa589ff6a8b56128aa23cb6d72c51ab69cf52809b2eeb7c8fe0780c3480a95601ee6b80bc544d7f9f2aba22ea1c6dc887e90ecddfd5301a7d01eb811a9ee23a914a739e6b601987be6acb6a9e6ac5594f22f85d605e6d658db4c6ab31c6d0cfe6e734bace15a7e0326dea86c7cb3333e0a328eb321b48fae1a433488e80733429a528e24041d4105b8c91a94830d7d8c2596ffbae85ffd3635d50fa01177b7ab5f499ee5ba39c67d4fe4ffc6b185e8b44528e37b344a8eba6ea79fca5cb4b65e8bca7fcca20a76c3692940e139fdec583a4a47b7e8592aab01f14b08d04a724b2582d12bf57aa95d0894a56ea1d98987ea98de013b85147f0bd81a9996f12999cf78a428a1d3aec7405322b055ad21bc5f14a1c052506d70eed630284a86c6888b5a2ca8133d2be9aebafa59c6f2280360e06b9b66c203b05db7aff3a666a64d22f53720ae17d89c5fd0ad17490b6b1e4d82b0b83c6c467be4152c03ee03438cb332a3ad2cf970059726b9e3818eee6ee6ffd3e5bc3e665c532879ce3b6b3a6228028b6205f76eba4f5d7b3281f5b02f19917d6cb6950c00e799d7e682b6fa3720c7831cd68d953614b61c63f1f24554f9d41b62c9c622c01b6534cc47661ce41069380ec8af3221f1ef0cc896f9dbe7fe00ea6ecdeaa4f49f63b7c5f0bfad8bd948ff2f8daa4076436bee0c2afd61fc240c853bc1ae700090b4cd5b87448fd7e9818dfe239f18f0e622969d6aef4c647e0aab2de1e965ea3c2b69146becd6061c1e8c24216867f041757ed5ff4e428a187e47e4d006bc0d002c50c1ade9550aa60af83b3deee0afc405afdbdc1c11d016aee799190d0465ce754284ab0d0d828fea7312767ac92ef9f016e13444d2518dc606f5f131e8b15e4fc67009c34c515c73a234a1f565ede3abcc0a43889dd968310cd2ea1ccf4a1d1e05f4c8adc319faf3334a4c76155b731722d866f79933a19d0c816c7f6466de1e6dcb454a1e195397c7df8adcdb5c726b1a8229383c542caa40d06de0631138df73a61f3f623e1ca4d753d7debc5f6733142b0bb58522137b9de31e7420fdd72f1ed63b8efb8ab4600262bc137ba55d81d943301765b36925d41579db6197d51ae7bfbd73bc4653c1d0b1879ab93585d5891a635973c9cc6418e113e61d8f0b7cce7b868faecd82844f164a0e400fa1be7d456f53d71c1b7c5156db1002b362bfd8205d16bd8ae3f725c0c65d75793188ee62ff680aab9a177272d7ee776034dfe1e226f4f60050953a3bc03d7d381d34bf2a5baa783af8a0780487e0383d17b692baec037c6b96a7c1ac3b22b27a903da866aa6f4a59ad16c7f46bf7d19eaec6716d2356aba5896c8f10b1c7a99b19573cb69720cf92c829925dd594fcd4f4d5c7b57db3f52c495af7d21233fdb7d995cf3bf9e376d36368ebb20b8df1fec24423ac038f1d6a6e4593d721521fce6dddf34b8e8db1ac72d569ef549424e8e2305751f31fd41df3fc9eb4fde74e567f7254849773ee51bf61fefa962df58ba4461f16a189bf604396b728a8daf0f09327b9d80245b7705b661cf3758863eeda7df174d1c2aec15892c79af07b03c6f67ca8590a6ecf71343194c48d5563c85aaa76a0b544b9482d996e7d4a8b783a502e74fee3df0c6e53b8647f4d062f964d10214de24370e768a63e01b561b8aa9d5e7c7f6122005461effb7e8afc0ae9e052f3e26d14b5c6442f4bd32f3f5282b0243ade63b1ead92cfe2620b04793a8297b9f859da65d688f71c21c37631a71aa0c3ddf4e288b910c19496d2680313ec8b9fa50658baad2afdf839924568e66975a810238c3757827d944d153bd16af4f1fd09842895d17abf82487455ee35eb493a6d0eadffdccb6342635c83065f51e0df5636bd751f4cbcb55479c8ce332de2c128248c134ad3b8bcd1eb47649d2f6993d3151f0c619492a6282773f5f709a57b90bc83ce5f7bc8bb95592f8c19bf6a054019ddda444cb7fcfeb045f99d647b64d050381896f312ac536e3263eb37d1521fbb0b1b1ed0f9aa45644795739ad7abd523d098ec12971324e746148e22890b5b14927befcd45b21e752a2be10e4d7b058c1f54246054482243bbf19870d82a9b14f764b103c1697b9097b1b43644e1e106fea7a2de26f3a4dcb07aa159d70556bdbded551c59f95a0f3384e29a416b73ec82e4f50d7929bb5f120cb68c998f2c46a43b93327e024d3e77ec1ffec20001f68fe2d4a04d976434fb2a90f05b333a4bfba2c5e8ef63fc33631b9a8023896db9036a6cd3b4b4055616248f190abcd2ac5eecff43bad6f4c42de85e795a98ad8b601b21a365782eb4c01c7ca0ee1cdca3b35fba42e685de1a6bbfdb5dde834441059418c241801a45364aa371508d588ebc9bcf8adf9d5edfac87b216b45ae38b36176392488a470f2e88c4ccd7211c6f88d3cbc1fe94db8518d9b923fa227a1f97301e24fc891d9b6237670189402d1bf8151c0d9533aa20c6f034e016758558a2b20a15bcd6c309dc4108914f52181acecbab77d0e268b65f401a29aff0dbc6f1cb9d93db7c0fe238c699b46347af5d7c116d5f56da74bb3e8c01e4479d9976ba19b0a96e8834cd38c518dd1752a0eba346c8d7da3efa356792503c54506fdd81518e91972e7f2c59cde804ab1c57df1fc98a2d8789ec6d5d060e67af02e27b3249236014b61fd69ff3033f58191b1130e03a1fd98ec052f044701a8b7358d7f8769bf354d5abd73ddbf99c6f351fac3ab9bc76990352059980094592610859a4ffc04b6220c52e6197041d3c041f7097e3be5207ceed8fe6c6bfdd7a9f91b53a151c18838c03504aa6565af5e4aa3569556d5d70b4b5f284cc1fe2ea1e6468d4c8c904be1800be83b34249b2c4c5da3f27279350ba2c5caedfa321a909da713c901d71f87c20b8e99781f578793928ef90f19cf3474757f1237d3f59c86bede6963b9776529766e70fc1fcf52930377ba3545282d4dae2de31f30032d8c9e145474b39dcf56fe7d47bf5183111c5d86a1c09e37c7cd5340ed213c0ee272b2d12ed9bb833494ef4d5c44700a39503224ec90a3119bc74fef9508c4a4d1063786f225d5a407221b992d8d4a1b8469e1fe3b57bb741bafb4e4450a4148e07d9d8353afaa77ae45c86357540c1eb94c9931540639500c306f8cda0a1bed1ed5e42b57c07462e0ce020a445c8766548d67baad13f58f86774df605a851faf832adefc06ea71cc72fbcf7d0ba66f55e2632459f5f6b6c069e07f93c88841aefaaa2f0b6e7f978891df4af0a5914dc83d0babce67aa0d464e6439e4c4d9d68ea9cd29ad9e29baa57d373ce2ae48a93d4ed045e9803b67642838af20e0515c3250db19713128897b1a87fac3e0cc36df7ee415c261a2c8441928225ad2124bd6ea78ef40934c2132d8d4a53c92384b8ad20a795708fdab29d44e952af2f5ba66c6b5349b33b552cbe3c69c9093ae16485663c3d47df052b3b6ecd6894715fc049846789da354d8c4bf63a362041cfa8ef8d037b9206c1408ad0d91580b1f11e803d362a12e7b3fcae67b1634bf298b39ab9c1fb05664e09f4347c7f4443439f02e05e5fee34282d9d8b130d2178ebf46aff7250e206d1ec0d11a40e8471105ad5303f67221ce9014d9dd5d4df0e9b2f59e4b4a0b610622ad25282e94a3d94eeb2906a21e9687ee7e97f5602c1773c422c85a965b892b2d9a6ead1bca4e465b167702815a841a6e31a718a96c884aa3e8d77a016276ea0889fc175095d147fc8997cdd3ea29f6689d799ed78f995d063e8da1910a4fe38877e5789ce731533e56efc7f42763474f8c9463d3cb407ccc964fcb64fb54abaf31ecc7ebc8da5ab915da116b03babf62a1b9b5cf6d844377e751645087600513c8350502af48556df4138d257413b9b333f9309e05cb6ac39e0de023d574b36474b960d862bcf27ec38ba4692cbe57f17f657b55ac0ed5e9331c4e9abaa191cac9d38b5859fdaccc7a8de961a7729c5cb29c79968ec15ed1c82910c0bbb8215a4e8a2614c915323fcf7aa1d6a988ce3771990133932f49c59d51b4f80bebff9ed32dcaf1775454e949c1624f99701f76468e98db66f803208cfa5222cf53f5ccf2148c574c040c27708dc1977d62a6eec49854a353e700cf1a91693d480808cd533d528ca1eee61ef1aa8bd67e96252b0eb07edb0df3d8931bbb7e9d8b2a3ad0185f6fa85ee1d262c0fd3ca7f4837d517945540d56e0b48ecad5bca74312b03888723783e6c64a2ba21174c264dcbd2b95e2cc002a08df62b19812fb67041db4e5171d5d59418c6a0331bb0961c1e8551fd22eeee5221db0c4260a0903b41d3a21080566b992e5e974a9df4999ba76fe36c699b5894fceb3a7426af175ae79ff8bf967876fbfc63ddc3069aef51efb183a4f8c0fb3cf45fd79bab37789fefcd16cfe9a1d97119e0ca6349fb6b53a496fd98b67ce09b7730a816e604bbc18199f1321e0e3715a6c562e7ecc9f9f2c348fbf50675f71c87b442cfacdb694aec2414fc38caf8a3ab05fdc06764ed35eeb4409eb3e4978729380aa5a0f85cd595ae88fc9b983c6cca5e48ab6821d789383c358f513986befdeabecbdfc1fc244f18ca834f2e663f85708886dcb0456b1e7d27a760bdb0ab5ae80acd05d68395be2f6d49704795e054ccf7d3aa95ab1c469ae4eae2b0c4c27bb350c44975c9c04ee4c15fffb7b05cd6342db71081f25085917278da5ff147efed726b1423de6d1b4914443366af9414839b3d58a84cf29668d261ca0a16b33156e87f39d398ef817ad48f32d1240d7a28407ebcdbdd26052cc2ec495fc53f86cf992818c3b7efffcac0485821d4006cda29e0dcb8a7a6620235fc336a1b9a6655768f5b67cafe074c1b15800170bf5c4e845827c9169879643965df389f5e538fd2318efd906ebd4ebe078c63108f4b12a20657ae40770320039755176aca34844a18ea1b57076ab0c1e716cb2ea24a55064c982c0e443ce2a485c2fb41ee0d0c75d0521894b8229e15e1e2b404a55b2cb5eae52a49cc309ef4bcee31629f8c7bad5bfd1a4ee2076396f8604cae6267a9ad4098a29df29e2efd12fe65bd470b6c80a6bfbf48121a60df00cfefbde0e475badc583a9531a149528e01936f8cb6bfacdf3675117bf665f8ba8cb60b5ecd5920c5f470eeb4176e9ca014b871a165b36c70cc5529e0f8711903be9738e24d0ae9dfff91af15b5072614bea43c1db5008c0e1592e476f21556aa2137ee9cafbea9dd2f59f52211d06f066259101b64b60a18d6e49b276c63b382515ad62e1b390f7ba003565a777f523881dd6e811270678c33b210ceb5eda6dec7c22dbb396b56ea468eed7862d83e9a7d1da2d808d8130be3be967004bfc6d8f25328852dbf5ebef45987840772ce06716a57a6e8a77c136c6fdaedfe73b1543ba994019dfb488657b0b45327c87ab9a3fefc6a344788bff93d420042dfb8d21ec05aaa4a2d48b43de1247f8e1fa820f13dccdb995c522bca5252deaf8ec8ab44ca99575a0ee6d027147dfea7a0d16ffa9585ba98b8abcca306245acaaa0a3fbaa297c240aaff73d46cf33fada8b6578f8e75cb5ae25e7a1c19593e5a65193cd3c10eb242441d48440164b3ff81ba05b7ee852d3e17da16f805d7b28d03790322c76b7793e1f88333b2203f6c6aab882bb9ec67ef8599654ef5457e97f898ed1310835410515bf28c48091ef5761e280b344d1b70e35e29161e296f32c54e803d9e74030d36bfddce6288a9d501f8680e7b5fa3fd769b10932b390a62c832354bf77a171d237bd33761e5bb3d2c814576fed660f7b7863313f66aa72be6abcf13df660c444376fb43bbff84912383b770cee1c8f3268219ec6ced9cd609ce7a24783e3c6ba105b1660462bb8130ea4573f1495a541bc944af87a2660a506e5537282cb05c454673ab1cabb90cfd339d98dc17a1d028c6327f321155a8beb7dda4f38867c3d56aa8c5d57341d3e34dffb78ee27476626d053db74692c5cc31850555f3edf0be38ab621f5aca860ac012fb5310c702490f50b07bde964218461b927fa80e2b2235535ec70e8a6bb435be807495889de86c3597e191cd5da5daa5dafae82f7cdb0b8d72124d4f47ccd24e7a26c061533336a97b1f9c2bcfec80d8b5d458614419530c5dc7ecc0c837d8db1e8190c5f97897fcc81bc0d29a9ea1802c1f9ceeb121e56b1cdead98c1277477aa7233dcf69f7550bb0fb742eaf49b60c21272a383b8ec41741d37bad507dc98e7d3abbfecf3e1b8660890334780d22046324a907591f44322d222cee762087ff2b848189b1acc6b8cb5b632f4ef99173629a9fc1334f0451467232310f33926aacd65f51fff509b4159603ae334d94887d53e79d0a49371aa9a7f723f66e57f55ee6f319765efb1228d01a992dd4288e5cc9ca0e57024bed70093241c54568a4809ea80b38163cc71328b69ab893f0683594cc6fc83b6b27820701b546c70a6019f23f48f057763212ac6d5c1a1be4ee2c054b5fe79e9ddd047228ce7941af2d00526e777c1238ea763f32c271981d9c712f12718b4e25eb0e68eac8a9ff551cbcca222a2a52dd07afb895a3bb08e9e71d0150623dd1c662e9dd516a7fc4eb76ab07a3f965003b1a5590e62f0702afef0ee4b29a28f4f7b3c0633321021eb027a78ccfa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
