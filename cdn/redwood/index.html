<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4ee27c82ffc4b8f3dbb105c277fc1b6671a9fba3feea4c5d13fc1d7dc1b900d20a5dd28e7a64e453128f33e3df13c013f3d30324df76dbaea26106cb7dd3cdfe25fca4f25516a9a832d4ce62917b1273e701374dd8f0d80afd2c83726a1b37cb98094c1c94bd6437ffbf5b6c1cdb09407991d5b18e10c6730666307b760f0b226d67e0a625b37a33bd499a6fbea42d1ca6bd05cd8011e08823f2fabd59d9426b3c30609e4b61f32d8d5091908eeb8cdbb7f925a350c5e7815eb7028275b8bcbe53d028946ed6595230b83a2bb651911929d672c8e776972aa5122e9164bf37865221de7a85c11e44a55dbeabf4b87b486ed0d7c67788cc7ac0726d23d511ca98a34924c425cf16e0557b112cfc97d5a6b187cdebf338ea9f141fc17fe5ee81af875961a7e7421d1187bc540afc0617601ac078ae9a7fa9849282ab235f5c47904b6a8685e8ced51e145dadb2ed06520ada8c6170097cab5d734a730c922d66172f6fadd79c06334ada5044037e74e2d506c186acc0febe8fc8c039924579227fc9938644e2f18ee97583c7f1f8d1ed7298eac8db92e2d5e002f9c0d96a44e23ad08141018e0539f72637e3784bd8ea49ade760661bc903b0eeb3d469c6115c87455a77cc69520d206f45549c60996a7ab363374a2fc23feb9f57c9215b1cfea058c1dc5648cc6f18c28f437e0e21f0ac9bb7b6432595a7c40f3628f34ce79219dfe86c298f6d6ee76e35c0f9f9c3083407123aa1175a3b791e96cb4e9ccc2a447a8b47aea4ea02ffa94d3cf8636eeb4c2b6fbe8a989cff9f59cf7b015e6a8913742f90d29feeecf1fb95299814f428cee078d141b3b35a88d4c4c447d04c308295dbe1003bd99c5a7b46d35af2dec6dc6e5ffd9696a6ea222c451acb98743141266ee61554be03a5237c8abf6f31162bdbf56a782967ea7b0fed37a56296d0cf4dced9bd9aed4b92874d7d657e118d24b181c865eb36c126cd38c2f45dd5cb8d94bc5cbbdd25d2e60102587eb038f4838c2b21aea74653035a353035b06457c2ebc25165022801e4a0b595f9085b016bfffb9445085f12d71dbd110d0af842e3ce9ac08bab18d8d329ac246d27a179a6681dbe1b631aa76b3b438c55cbc0fd21c2e8420181a8f7438b470e8d53f321b128f165ead71dcdabafe8ac8d22c8f9ccb3688fc165c1ae732e6f686cf560c582d5f42d2165df3ee8d152bd1b5ed75325121d5570a978f30b54cb2afff3f400f5f173d0fd6638ae8601edbca54634719c5bc97fc493409c345d0e3643b43da778358ec0657ceb8e8af52d802a55285ee4bee8799fa39f0db43acc8ed7d4ef3d493706c353a9916332d6f3df2543ed715b056f16cf06aef51fc0307652398574a97c610c1bd211f13ca9b4a6ec1d2b4cb659eb500c6e4070c5a634fb799e74aaa4637c066fce52cefce2ab64258ccfd385a264c66ada48358438c87639a7232522aadf7f3025b4505de660c8c5ea27706fa1478c8edbf7d4f4b83d6dcdf0003e24334ac4999b824305c5eb97dd3c33e4d5521b210fd31939c47a5559fe9e3623b0335167b49f1418420ad621cc54feb146903c9c358fd3bccb8279a32998a875c5c524e4516509dafd6af989d2c9c90e783234618c8d38622ba2b6fcc074ff527234090cd193b9e29bc4567e5bbe975f683b9991abe99df7046e9e1f430fe6d1e9b0ce035513770474017257d2f523128647695a9adca8a81c0f9e073656fb1efd0371e189a3817f49a9e0aacfc67a97fab78d3e22ea6162c9dddf9ed013ed7aff1089b29d328ffc07d30809975ed32227a284478b2e49b395827e3a0ada2fca7d7b667670335df04deb156efe6ef94415191ba86ba8572a0f47431fedf533bad4f07cf164ba26bc66ed5529a7b734c49085f356069b68de6aa6c0d786afa475e607e51a41d495861e5cb5c98692b33309bb6bf6215e40fc10f85ab9326cac1a76c61ed47ec62eb4cffe7a389b6e95acaa9da1ae2fd6871595c1137302bb35bd5168f2f2734e119f75ea852a9a2aa7844230132d00cadcdcad0f7a8db307a4124465cec3da07cf063dca5cb1640ba6d651b8a22860c09624738e324678521d7172993d7bc2d5610efd7c692d7c147c45663d743b6763e7bd7f8d37b1d434c2f6e488499173f86e9f1d129efe320491cc70f6ad2911a97c45a4defb7fbd115f028029e8ad5e3286fc09420abd615ab69e50600c79b25a3017fce7cc3aaf7d2f0212e2f92a4e7beb5834f59bcd367905e8d09fd5f6ae9ab10bcef6f70a7813d0c214798dff0cee7aab165548faaf1dabd6bda84bfa75ecfe0a63d15597b6dfefb13eab83abae6268302fbf03051325415b37b03638e59b96a2b504a191cbcd38429f7e17d70a1fa143b2284adfc273efdf6c4e6d575dcfb0915d47c512f3ba8a27e718459a5103a8796dda1722a4685e90801e99727b7e7135020622f9e1a5caa15139aa9153f9dbe444a586bf211610267b6c4a796d24af9a1bf40e274c49152ff720b49019f95744b171af8fa87e6967b3fc7e4562c71c2b188d564f0f6ae99824a24635b23b839585110483ffdb81eee6e43fe595c932cda190cc22a2ad7726761bd47c0920b14cac30b7547c2161ef377e25ce917a49549cee3c7ea95c66bbd6b83a14aaaf458a7e891b1ba6c848c0ff264b9d018dfb411e22fd52f34fcc0e0c74f5bc0f0f6836343ea65421ce41a17287b9aae4d9e8e16017b5d6c426141c2ddf8228408365f42117d69d70ff8a6ae3f3ff93897c8010215031cd2d4bed1d1759e1e4de0d79addb351f72b3ac871ba151cdcc121ad14dbbf0ba7c3ce85820b629ef9407283248d26c966703714e50ffdc5d85577801bbcd1affa2489ce6fd7bda593d2d91581c7b324011fb57a9967346c5ce99f48018be4721d197a642f6f499186ae451c2343722656bd6045f284075627be87f4b004dc27d0d6ca0619898986b22bc475465a52212b4da907e014ab60703bd15e71d3bca7f6d93d8731b656d2ab9b2a6f7456b6130deb0932d52b238b8994a11c0e445d22f7760c086703d4d48716aae9a5d30bb7daa69559c006f90544998fd3c7b491e01b623ae35d6e015ec25835af7eef38066f6aa00b18a62171d4540271c2f1a6bf346d32a880f3f54a72c74dc5c6b59548ecc5665595a479c6256421e6c200a376ff7545dd81be68942d68996c2cfa20fc048ad55752af6a166bedc8638cb6650419312c77c8523dd4b1a96dfad8b58627a9588d5bb0ef28e22d6699583f49e436df294a627c3ad4dd31ca95dce7cceb6e2bc262ccd06031587b737244efb2ac3cc2a872322f77f5cc4ec4609be27653bfa7e0a37866ce30f4f74af00f9a369315f8783760825afddb3d164638d6a18017f3bc3a124c5361e628ede23316e025724031f33ed0652ae177c767c08d33ac9053d04d4c0701ac287f9aa10c25bfd2844b98162134d45f163f063934976be81c14c9ba20a75564de360c4ad058fd7f79ac2fe7e2d3940bfe54d7ef196d5c6332b3973c197a43d61811360d351c04587a8d5641230583a8eaec1a050b68e384d6eeb7bc5073e0c2374d14702a3cfa7bcd8e595877b76836899011b1bc39123a260e9c295ad30600910269f096b924caaa9de50488172f52cb7c7f09bcd32d86d17197e8206f011f53e01aae0cf074cc8db226d3d74485791ddf3a8c418dccdcdcae96be090f200ce92bb1dd76758165bf4faf50af4ee8bc3bf384d7a9d4627746d0649e625bbbc3fd9aa745cdd712293596f47ff258ff05e417bbad6099d288e7e4e8367ad0e5cd6a5333494a39bdadc144d21d47abe2075a9353fd18b96da09b962e4b49ec07452d4e93c0e763e92ebbbb5a1384266af386d412c36961681e03a2083b0f791f91e3c14706974fdf80fe684655033ea247805b3e89be1613d6b889edae11e1b9006574f27d5073a056065457afe9b7d6148c51d7c832095b93081ea6f37ae27a380c7e508fa42881dec253673e59313ecf45fee13b91033d15d14a17fa1dac655993ee87f71ac3cbe7aed03eb8d28a97211e88e1686fe22cc55e417d195be2294c8465418f83f13355da382aa9e35c3d8148f8612e7179a100d6256fae174ed943f88079658c4456bc3cc24d2b806032a389b8563a4d83a44ddde825781c6ba596035febf448298ff40d2e12a053814cb28ae4de2e13dd228ac9a169cfbe6eaa989b490dc5808a6bbc34eed206f9a5efab1ea2aeba2765c5bcbf96484d064df717c0d3f216a04b76d38fb13badfc60171b15c28be476715efa8895ac3a5815628b5c04d48cf13199552a77270bbadbf65c0f4683b70af2e7683d2b42dfb6abd0c8e02778891ca3e26f8e3c59854f8106ffcd7dc3691082125ba567f78458787cbf4445dc40d8fb609073a17995dec69bef5ae2335ae602d1e202b5c0289d1f22b21b501acf78dbdd3f948c0c22466e1aaf0e6104a02765d429a83a0ef80c2a9d6188542964acbfb2ab34b392de0b4d442a402ac59a2d5d4c28a12157a3abe18b44ce7d217dd95f1efe1171908628a86c013e88c935c6eec00c2ea57234a04d7f48be24d4703b325e4726f8e4dd891cc4be841dad1487e6e96dae0c554769fb634f3867e5ca1e28d46bb58ae71000dddcdf1efd9f9f9e851a7edb31ba9fd743e5f1daef944786139f8ac8883a9d7c746e927a581f4d98befd79eaaaa6c678ad73d167827b793a08e6c660fee101b9fabc2b874d905ee5a6b2ef1c086719087c6c77a32b21bb55e8cc555237ad393c9a91613611ad6f9e28f1f8edd1cffec84a5cbcf6b5253bf971d2ef27d3edf4bc72d94e1dda8e7a3300b12ced1f0cd125a56d4c61f016a361173102e0063712f0102bf420c00027eb2ea8051c168bfa970ad56dfae122aa826b750a916c05c49f43d7cd9cc2c6159ded5b92e48150a0e1c1a3c3c085c6410b06cf90c52eeed8dcaa97e6b8b5d1381b32c0a91087f065f7f286cf095632f0485cb5c7bec0f2caf5fdb966f1cef2b2a8838cc810d3a3e4bb96169603835bee39cf0ad7ef1299e236d2643a1bd3308db68742d2d4e35640fffe198e329918e999652734614439c9e07f0fca500b1c8358ede390f8b792a53e86559125354571d782b7f56f4e70728bdfe1b3f294c024bcad2dba7e23608ffe6b9060a0b4cd43566c0b1f9d09521e18a05a61604c6a83a8486e62604b3663f1edb6e7bc8d3c835d288284cec10d726e1e49bacb07b305f6ce5a2fed6eb24cd77ae75ed9246d783184f0882eac112c60cb8556437a594fdb89a25b6e47991a5dcebd5e915c7de49e09c68b300528ee2089d918cce72440ecd70720121e781ddf1fb4e3a2e83d8ce05268bb82dcef81a7fda75bb64c9b2e130483daa7637261fc29d420efb8d166d1d54b152ea8315aae94e2bbf3278f5de3ff6647e3cd60050815fa1216284e76cab944d9623b1a5b4f11199bae6e86a2c595208f2993f0efa1fc8f6e0a2d8f1ef9a7a7e65288c5d450281de102fb92a2df2207ec723e05ff8e0f1d92df69b65bcac11d2c7d3e86068a084ef25cf37618d83a400d0f248f3370ad0923f72811b72089b8487dc996373b614a6e626667fe08b70fa3b6162c60c100ef7b63b38d879d91de2f9ad6c73ed52a066b39405d5c0887c6acca933118ca0a3e9befbd9dc851f28aeb5693d39a2c2f68cc7a7663610d92b05d7bd336a7841ccea46f6fff9b9fd4c8e54dce8ea68b760603af58e6d6bc0f90629ac803d3f3afc8e7f68f7c8fe48d1edd470a3a05c57fc9d4fdbd1d8ae8ec6259544f60b842c1e6f8aef7728fa69e3ada32c2087f165e06ef3081691f751c7987a0ace3d37bf6b4f084ce505e3795e70453bf53ade32360580609b556029d7d303e6248ca350113c41afa9e7ffba8f552db6ac3c0b9ab5e4ceb2c481a5315b8944afbe517060dc69799445cef6ba7ae11a2bba3ec0dc1012ffb55c4452c6c489b86f7175f38a200dadf5b161e1f7d488cb88fc6f65f724d5a6b386992bd97759f951f6321551cfa7efa04e277259c14fbb2dbab7b413a311fabca22cf242ab62782a9b0fe3ac0d8f296631c99d0df59fd8c41e5fa142cf67a2ab7bf4449af4023acbaf6c27a7e881864f0dfabcb09f30b739e6ce0f257fad345c0b3e335d776762795be767ba7ff2a5db44c66e8bea5f55fea61f18e08f69418e2b1ae59099fdc329f46ba172cb272c12d7451979a7279df68ec64dbc40670e27c1d9e40c5e55d9748edfb125176743583e56e3cf122ffc6cace6ca2aa55789725f27604a0900ed4e7c62f1189f1ac62ad41724656b9c713044eb520ba124b50374022ff0dd3fcce5e15545241ad33082c79571f1f4934fa8882e793f390ca799ab0a781055e23798201aa79e74344a54e83ac179635b1106e1477448fd4e5dcc7740a647cbb2caee3c7fd55c57a3c474a8c03f325e161589357c2611639638992960e3df2e3370e216fbcdc8fc68e85eeecfa8795a59f1d1ddec22872a71db410fe541f18e5016e3f55c2841b3823a810c251d6266a5081e8e829b501cc14884eaf664b02c058da349587b05b5f8790a2b1c5a265013e4a91e53aa8ac14dc34f08e17799f87f9c1cb150fa214e2a71ce047eb284305a6e9f077fcc7ddc1d73d0808db679393e55871adea27ee454be76a73cf7d44e26203d422b4446162f9a1d18bc71b8ea64d81adea3cc84dc4b4efbffa1d8d2e8f622dc78cf2ffb3318864dc6589d9b5594ca6e45ec84b8540b5046427400405f972fa194c8e85869226cd12b4a27f904c93e9df86597c0521a8bd9601f6cc643ab5d2b504e2f4bf20f855929e7a8bdcf0382f0c323bd0d57191410d20216044683f38e7148e7035e9b459173436e63084c40bf87ef66da0b1c9122f9e2dfaa691c11294f766b4c887ef6c842dbbcaa8b4784fce5e18e8c26ab94308bc5c0c0ccb071b036ce525cab7f0a225de56db29c93a36515bcbfe45db4837c3903fdc049c4fba32dde8d3b803a00452621dffbc5f5b796dac85ddb74eb50102264d59cca319b9d12b0acb0c55ab86f8f2cbaed871b251ef9eb6c439676a0b740eb048bc6901be26089aea3ce8a5153f301f16957909f8ed2f828227b25e615dbb1d53e005f24c03583fa035c3883a713642bc1d1eccc8167cc6111c5b88545e22b4d7328591fe05703d6225a809338ca83812937985b6ad542e62fef7c585c36ca07aeb2923bfcb587c6d1555f63d0fd47912b5781b9b4fc7284bc4780f3c4090a8f2be677d9d52494091191a92347eff06420fb2ce1fa9855484c989881c34299cc701000664c847aa62b8057f62bf34aca15a3f0c172625575d2bc2552a1a4b86bbb68f68c21d8225b742b1835eca8bec1468664201a6f40c506eac2a09d81e08cee740be662eaaf01e635116de75706723e8bd78ead354c5494b4dccef5f6f722a5c801cf59a292df70caf7e7cb21287cbb73aaf7cbde12284c96a826079513800ccd9f4afa6d8d2d0267aa51d6027620c1d70c075c310e6aa0b51eb1133f97d320f2ea4ad21808cc06cd338690635ebd1b83d3fada8942b0c0c631ebbd77f82e9f283336a0ab58e90caab2728e14e5cd793c400cdac81ea6337eeaf4dc9f54fda51bda7b6744b1fe55dad2b13fd091fd0b2262363d96b6c4c462561aecf9d208345e1be8db1975e0f2858e9769bd5351608dc656de4e18b9892d8b8aefe125a23721f869420c913c287a31a375518c92cfb08b13a3177b8bfffc604c1ac733dac675e95ba0cbbba2555bad1aa6d6babd1d72f1d1e58633a20c00aece4639a2ae54851e782abab00a59fa586ac74ac290161a1e5e7aa7b4f806dae0802bb7a0b027d27c45f55d5d1078984c9e35f94431b61ae4b342a9698ccb590cdf2bdc6add8b6c6fabc0420b4ecb6f1ce22f05ffc104a2a295e5a3e950ee4cce318524bc0e6c3c0b112587e251ac68021c61fb9406a62ef777470931f7d28eeb76e51a996ea9657fdaad3dd5e90f9da8bc931744fdafffd87fb3cc93f8d462ba56ab968895aa98781b3bdc5d14461660c2ae0748fc4750068e39e4c32469b2ee117c05d1812c41c94a6fdb6d00c0ecc18b6404b7cefcfb7166222a1e492f6e3b01af7a613276fcbde0da4471e2183d2d971124c0f43ecaf7836b2528bc30a07df0f3f6801b2276c15ac0d9b85eb6c64d6581301bf2664d9ea6d1fe3f5137b4120fd312f841bcb600cd0ecfb592ca15c249ba8fd35d0695d8c7f115ce7acdb33c80046af3564753ecbcacd5cd619f3c6f1f67c3cf492a7b25ec46326939498d046149564528d4fb415a925e8b7aed243ef73b384409de4cf461afef907063d1173c52ce02fbe7f7f64c896eb3b86b3312f89c46193ac50069963231dfff8964c904958774ffbe1d9c7cddf1540e9f5bab16824e4954697dc2956ab59dcb85b1297a7a650e6a1f137aa0cee21215fcf4ad8f2b4f8127eecafa732b44b60650d8ddf77decdb0d87bdc11d27e94e3727ea6026a5cbf741c54dc5cf94f5ddb107db9c4cdee4f6a30e0935a346df8f934b3d53caefc84b4de80ed20ac2c66ed02e634b6e2d94bd44b9a85daf72de54189b944236b67f1eac5e33c4ecd6df3a30a1d9ded26bf04b408cc6f53118f42cb831ebf662cf737eb5232c21d446e69db6d61de3dcfe249fe0160abd1256a4969fc434e5111b6f4182af8b21e3bd24e319c3d92b64684ea1d9c152f48f67ba4157f0aa1878b4dded35801c4094be9d7f574af2ce06f45a7470bc9a1e8a5061988c81a67a19809db58f52009d4e3d28cf7c608122a4a46877c1f0fe64af4feb6a52bc1395c3364efa0185dd60f48797d058a3077e7148f8cb65b7e93ff44b9670b9c46c5c85ff269048c673f2f61a2b3dc341c52efc202890b70e652896f76ad3b2102cc1375e19f9671fc7a72a708bfb2007d8f97d2423c5f94604e60d55022f1851b77e6c8146a0aca5ae0091ead2af841e04dd259fa24403aa45de9ba38e10477d609b3bb991935fa2bb1bbd5a62f93aea9fbc9726214196c2a02c44a0dbfe81663037a6712636cc9ba72d7d5192a5e34aa96fb0a766842abbe89cb0a26b4f1f68966072515c6c4a44dd29045bfd6785975f16eede27176709ceb6d7ffa4650fad34c655bc2c17f5c45eb9c429eab3724a7ef58296fd993a09a770d25dfc70f020a97aeb530b38c3ccf6c2563f16e8467abf6b4e443775f309268cd5700792bf2e205f468fbc338c1382ac5dbd4d9eff1bf1006a02ac9bd16e26d984bb47cb4438ed52978500da83f26d020ad0b17ff51a2aece8a918a212b65d4f51dc77c624d48f25705da66304408d2813f1b37cf7d3022543627883af57359bf9a76ef625beffe9ec515121ca0e8e8a598719196c2633ffa79d0622d9106cc4392e793165ae3e1d86555be099b235220b766c7045b0f1a73bdd10b1fe2b7cf9f11798f7abcc20480515be211a401dd925efb99cf1dcd0bb1572c9ae2b250840b6703071dbc233fc22ded5dd8a89ffc0f9571f754a7ce53a3137b82999e4e9c53f52996b56f662cf956e69c6aad3fdc18c200aebdd82e9ec87fe2038ee0e7f28c1e493a3a455367e9a9d09a4e466258ed42f19df2217b347deb0187fd9563b458018d7bda0c8bbfd957e6987a39cdf1a6a937f1241bb52ef548348088806aac0e13d515d6806fc02a16f724ff1b18bb9e1b50c43d8bc3216e19676113b5398d8e5708d6d73f16786366f6faa141a50d21c792bc671f3ce3f2c354666658c5e12e77134fb8b4f9d0ae17f66b025cb5d60156e2724803033ac95ad3095c65519e17168025ccdc761b716f519b26280bce0ec94969f9328c6ce6719f6a5e3d0670f11d93ed4f5d788d82f5784a0e766d625a3c8f336028e8d26009afcaab2e3dd51df7a91a9c8d6a225c91fe7fcdbb3d2102f328fc5ab9fa06f751a2441362a3f7a37760c3942401cda30fb901cb2c83b869566f6cc7f6078755b188c79046c31da68a070b8132c580f763fb689f2c80f40c6718ecdc9f764fac29432796f60fee5156bf7ed0c3e3be392f342c0098609b6e139739c932f9c3d3117813f5f9acec43c616c7b3a24b4feb3324fb1dac72962955295333c721b0c4097961e668b708f5b37281e0cc115e053a65fcfe0bfd047fd5243ccb804519baa0583509fa677924ba8b3100a95f4a000e416e836e927dedcf13fa328cc8a7534af8e64940939215d06e266b82e138e784c6e06a41934d6f7364a174b5fe9aa7d284222e3785337cc71d90db46ee3be471bcec3f83cdb3c1ff2315c5f84632d4199e2a10167ca5df29ab68a0d237e95d56464834ce9633c01e248674db1297e4cb32b5a0169711dd259dcb4a443aba2b7c5a12c723d04b621d765caa05d1f85bd091f7294b7d8a0f9b8a151b740ad329f81c98f763932012db33074456d9fe7ae5f568a0d012df6673809a0c9726995f9106ae315cd6ee59965ee23bafda83e66544343771cd49ea22b18a1e7e00b368c0323cefdec03bb385b854fdf39b4632489886c2b990607be08fbbead296106240c608bdbf1a5efd80f759740d75090d9516a90127a93051417d20c0c403b3a12e864b4b8792d689d6b439130747ec520908a3eb4e321e77a0e163c1dffd70260da14f7bb4e66d3d39eabf2464756b0a393f243103c4887140b212e3df239e8d8f9fb07379dcc58031c45caf2afde55f00c798e7ce0c10a6ea1334ee715905e68231d7b4e47e62c1aeacc5018371926306c570bc67cf73d7d6d31104659b884be0b03b06bde499d1da0f940e6efdad1b8764d9bc1bad2a324761e249a9040f3776394dfd1df8790da1a92a639c89935b2c4cf1d5c8840b9f9488d7fab0654570d8b3dfcd68e012ae189b8f7da6f9b27944ce7fe5006225b529d21dd48e3a3202062bc42f5b60c5f38d10e761555ebf36b2a945452163761fe749f7406d2ca4b0e3fa1d294140d295665d037924caf9df7fe6b46e267571a97f02b6618a78385a95c06b66bfdb8826982d0fa09321ac2a0ae7cf41a39694702b118ca2645325a7da215009f586196a41c3771783ad5a3c4e87337cb2041235f72e73d9873e606d7de90d45a38ae1a0154fff3d275b5789f9b7709d6ed9d402473e759de202d962d7120594caeec5ae1c0d1a356ce71302236c4fae27471ed2562ec2e92796badda4d0b1df656c5b83929bebf10e0feef6984fa31b85c760bd95c544f1d51e532f4462a59f1fd54a85a6cedf3693c9d025226dbd800c10c1d10f42fc89255c9933b8cb5d43190195a07fb56e4a0d2d38a34bc33e2ec496f3df27e5d69e907749c81fd00e5e8c912335ae202675588bd796ef68f67dcf2e82d3488ce8996d0f1dbe656cf7b012e01d1afb4e000998b58d2811f31c0d9f280a778b5bfc893297fa9954348e53209bbedadfb43a3281576505ae5049ec43c25f9fcdd6038fac299876dbd280f4acf84fed8afb57512ecf7378a0ae87d5165e6b99619a2060199ebbdeb52473467e8de81537e7f3b2ee6533acdc4bfaf2422e3d9fc0533325e57cedfedab343fcf008cfcd9550f98af06a97f43f61e2a0ba52857b4c4deedd91b1998910197bd94caa450f2c4f3cc87d69a10ff2de69542147e4089b07c31beccba7acb009b9b39a64b05725e4bfea4c7a58f96ecf9a9061f300f68270b5235345278a76d03990e32d3077e44a7a0cc256d819fed1d5da2d63b729bbcb33aaff7c13b568d56dad3017c3c3cbc87b4dd9a576b8e7ceda7614d41c529d79cb435873a21f545605f80f0e240a4ca5d6494d26db13504bbc2fd1489f1bd370455f78984adf22a04c63e8dee997c5992692ce4dadc08b7afd7f137dd8617b61a54e4f9b82847ff0c26d7d89479197b6eceb3eb56092f4c8fc3d4cde4d08619ceac7ce79cf8afc0d96fff23e47d7f3ec35e65e2debab2fc89636cec2eea40c65a0aceb964fa950b0d1b8dd181efe6163372166afcac472116815bdae1cdd0512c90a5a2ad43d376145882d13a14dd644ebdcd5aaca4588b8e05c4900d42b95eb609b3f8106a2366340d29701ceb017503342f9376b379157d634867eab27ee75aca1111c4bd6210497e7ff1ae0004b913be937b5b44e1d5bc39a716fe281089f33ad6aca5e6fbf85189feb741a88a25871755a0a23b354f2c9dc7d8acb0d39f522d0a3481e1eb8a610732d07b992220e0c88a10ae048880a1cf3fac1dc6f805b1fa69de1477aa06986cb6fa25e510dce89a9593fc0de4969e6d1b2ac97971c1fa9974e378bfd14f09f9e5831cc91d63572e3480f524ce959504c583bf77c8dea9698e8ed2db8e016a189fb090a95b2db674270784efeced175d478a8a52c59b618fb9dfb9f67f8603f78264a7d4cc1a7f90d48f73abef00b038dd26434f30b3cf7185688e05205b530551d48abb3ef6fdae2a510d6e4b0cb77b219094ee447425024271b29d103fa3bd1f6ec85fa75fa62aab9c755ed92e1b006c795c29cde5d22875ab18c80b068fe7c80499e120788987b3b6f6975dc47b17ec991f89f47170ac8e44ce116b1694795cf7ad8da139d2eb9f8e09c836b5a903019a189082d8253f5fa87b5014e3c47fc589cdd7360b4720d5dd79d3b7683a572e2ccd330690d32068b849cb35b4ad305c943dab309250336f0b374d3867a27dfd192c68e6e926d3a25a16175db488519b55671cf261063153c8da615dec9623ef62c843880e441041413daa60d85873c1d123b5663ab754ceb2fa5dfb436596f49814f8e5b130b011d85e15ab258aa2dffdafd49ece01bcd914af164cbed3f7d1f6eff545bb528b5ae5ec943e60ee30f0cbccd2406e0e960000161d0b307337a1f5acaddfc68f4ad0521e51facd59c81c23943c1c5044c0d195cff963e945e5f063369855b0edc7b6d6e1adb76c0b72eac606b884f03df2a3f6f0cf78b90995b23b27719ae5cb91d56673e5da4825e4bf3416d2344706e7d3ccd239a2c98f9833b2db038243c13cdcc316c164a9dd8201ede6f635ad439504a0ff74b97258d7750bd09c25fef69abcc984524080d6f64d0d2f800b69b03b88df0ea26456680bf154ece6e12da26b8b52616fe94f1711e2e60b3adc8aaec236a3e99ba6584abb531a0bb0de347e4f32e7787a2e64a2b364b334ddce88fd72b4dbef252d701d9f66cc19d598840caa8194e379c2a6f92e4a355258885d1444a4cc78d6d5aa246d7e03b204f72af242df3e70c408719a4b94ec718a2cf6697f8f6ceaae2825ec854ce213006c268e1f317ce4598ccf412403838e0563e42747708fc2514dad827c2167fd0255104f640db0bad6251848401eb8db408d6fb88cd1fe76d1ed14b623f6e3e86dc6a4b2833b8ea62f8dc84b66b0e363a85b8002a8669e5569f87eca394728764bbeafa4a8221f363bd794d318f5e2371664ac097ec71a19aaf57ae1242fd8bbd450098c5632978cdff2cd39258420bb81511ee039fa134ff3960306750b7df2484b71b5734a1eb93d094b3079dd9f338778bff8aa7de7d6968770be4d45051b7b6a0fe5ed1dddab7f98778bc45628ae3fe704adc2b5bc8112f358e2c8257b3f3db734d38db43874bfd4e21481f4a343b6bebd751f11e79241f481d7915c831dd5de1a40ac76eeb6c06a1252f0e6f7cb9fa77b5fe6d09807a8c65be353f0d597b8ce6fc9859a0125619ca38bea8f57c299716aeeaccf48f6e3e8fd39f35b8c1a75cc4148087b3ce443ff9ac412318dbbff6da39be305bd01c70f1aed675b122562859117f98dc29c9ee6022fc622b7e91630559249decc560d2361bb99eb9107a3b5443a387b6014ab1ba52876f55447d6c2bb8b0098e8aadf697d6cca21296bd7eadfb097bd03e6ed695b6fa395d6888297506754903f1abc2b4875f3b99bb1b9de6d2f1f5bb844705f4e03f322ba563221166ce0a70c4722fface352ac65b28572fb3ee75c66b7fa4014d78c8fc5a65e32b1dfdc229ae6e94da425434773a264ba2177ee5b7ea5ec79d1affbe3f4d0adb50120cb6a7910b7b92613fc45e26d0113b750b16ec26acee1d0a847b4d23aed3bf92cb25f3512562d15650d375dcb1e3481f7b7ee95c4936e6dded6998401a5c29bf996abeb00d37426798f71b390bbb4b856616c05496e989369259f639d275323737d082517cf2ac06f5d2d5b49d9ff321a5b3475c3bfbaad721453fb603006796a849464ab405ea93eafcf1928b4c6b6d470db8bef5a78de849158729f242fca5355280f9244ad9ff68ee58475ed1de47062223b2bed5da967001ad8505476576c6f1d704a9e70df7ca64c326ef940650ba709420980d0d58bc45690309e4286be341aacbbfad10b276ce8a89c673e206f30e168ae39de3e907a44eb6b0cdbc8e5fd3afba29060be9a434ccc2f3c78c1958aef461cd63c711affec7060c431b30869fcfad888bda670175323cffd23bd1ddeed45ab16d779fdb9527f3592f30174337fbd298854f1f052c4db85c83baac0e6a7c7c54151df89d26d51cda02c2c522a03b4947e0435e67254a9e543e828247b74dcdb19b672b50659c92365f290c98afa0decead4c70f069aed27c9055ec18efd3bab2f47c45d1de560390acc1327bcf908129ff2f9b5ede8ff3e908bfc02d3b7c0db88e339b154024e587c5b71d041bcd89bda61f45e4b82946ae29cf2c3f14a7eb8edc7547c139f35a6001c92f73a608e32f3bce84abfbe68f9fa60c1cfe8b1bfd4be2a40bc99e4f844f5c1ea8576199e746f7e172ca5e018e5e973f9dd77c8765d3f6e83d514a4c8d8bc6290908a4af90089b5cf1c2678a430fd6af844b1502fc610e37498b1d9c5571f2624f5092183692c80f8801b5547c392ff22edc2a6d230b6fc66d52a0de63ca0538a56791879fcbf3ff2c0254e5551f3f869b4b3c0cfd360825594992e0380318b9a6777c84aeb218f32fa9cdb2c5bb29d9a722a681822f6150979528a445f6a3a3bbffea8189e2c9d3b0705f8344c1fab4089c1e516e3488909ef0590ad5b640e3bd14b27483fd6ccb633473c762e9da17ccafe3ff5a2d8d99b49611bd1b9bda92a690e4d02dd61bb52cf07571eed997c762f1a6d718c10fecbd7a19a1ee211e6cbaf3173596f6900ece038fd43130dfcad9058b27f75b465bfb3f977d1267eb70e333af921ad3579ea3edd49b9f805e8cb40b1e13a5817ba5e49f1b1975b862677b6f4522c760c7a48a0405d2c58291432714ad9fb25bda0c7ff9a700009d8f0e0c30b480b4e61dfb397db0c51a453c96bcd83ad1ae04344970154c547113bd78ab157fee430c03274c32f60c2f7b456aa33a803e630368d9687848edc648fbdc1d9e31685f8174864abfcc6c371759e4e3a945f52d6cef258ff7dd3d2f143fd669cb0326ce818e82605bed1d998de3d68bea30693fcde98007fc45c6e4fc100369f52a03207be8f97d3a430f1caffb2a2f4dd263e04096494a2a1d38246aadddcfa754138b7fb2627c83c7eae3da834ce4fb085ffbc8358be8f71a3a3b2353a1964bbc28e3475620f0ce35d511f8764a0b7efcc44d2cc3db63f221a4b90b974d97456bfa706ee580d1657c88986f3f5785c13f812de34c15a54e9028631abdf9c4acb27330d41546e38ff7064324a55ebb209de23a632e8bf282b5bde2c0d032865573b311e4ce0853f3a2ec93665a703925fa5ee137ad8b2bc88ddce6aa91e8b5e5a5deef278f9b5cfd88bfd021928154bfc8151ca1282cb12dbd26ed9754e7cf1848e68d47db194ac824a66a6aa33b5938273ebb1897a73d8e9fa4d4c455d36a82a4e1a7d13ac7a7dfe754777eb25f22be6e0f7882c46f1c628a0b48706fe98e68cc04e1f4fd860d8ecf54fbc767b8a5b8380c8cace8d1a6495ecdf87d043fc94d06f9b4164ff53e9bad61de25077e17aff85f233242b3c7f153a9c3fec326260302613726149b727d73f47dceb89da63a1b869b624ceea9c4c1e9d8501343641da7a1f98c755f59f8f995fbabb64ec65d11322c17125fa1c55ce2e5696d94a137c9bf04a7ce3250f2a2975bb5136c6cd15d202a2e888df9773973112c6259966dd2cf7a77fbf5035c27e4c5a3995c84355bd97ff280947de8837e3f0577f35d6f7507f983e562ebe112fc2fb80a8227ca0205cf69fcb007a5e19a9ad9d616c1798a37f10810dd7edad99eca88b676ecb2fba0ebb0438fa9da15c797b67778eea0cea801d8488a30b746eb1507c70c0695b4f0b472e099880f8723c1b8e77c156d5a4aa65d6ae8275e90fb4dbb5ebdb5b35834d74e1bbd99ad234ebd6fc434dbde956db340081f505b4102d2a6d978ce9386a98de606034b48ea3ed2f15d5196a6053e7c934d265dd6b72c49f308e9559c0e7b22c86d553dd75ee07a5d1f57d48dab70fca26b800e00c3f21aebe91926d7c04541dab2c1a6ed982011e286f6382659bee0b421fed53fb7f441999b0da6511b89358b4a9143a2413195048e2ab36fec39f1e54e13e96e242dff60d3d8ab7b8531fd16f49f4e78eb2d221a90bd72e97feac68c564aee5e17d2244116ca28070c942fdce5bcb91170042af77df7a534919162e7cb9b768e0aa116018214657b3d98b1da2ccc13d0066f4fa4c9606e4b0d01b694ff1b296117cc81825e951d9b89d820759fa8cab9601ca4be5304ad3401d36097ed631b0d27568eb96508f3971ba570353b0f67c4117e737a56b3b652a337dfb23e49d28355ab2bee8e4da6eba402b5bb1b94f191cfeff63b46ef5f5475954ac9bbd39fe6c3f0b0a6d01728f0677b22b99a4ff056dfb4af581aaf9bee87296730354d8a8928e6a187fcdf611fbb57a635b65557e7b43e5c17668d634976a77ab3dffb62cef6c469b9d98a1042dbc25d63438a573e2976499ea34be11b668aff0c49eee3cfe533aa8487dccfaf550798100894bac080cb2b0a478930aa914b069a20517037945bf601466e6cd4f4d878dcf4531ffa19bb840086324c1e7d76ac7703a1aa5a38b91331dc064409d335355a2bbc436800fdda370d2bca39b430f0065e6487fb1056c870947e038f182788dc9a21e712d5a5222bacbbfd4a7fd394707775e937ff70b8aeeb6e84ac880483d87f1cb299374e375c47ee1ba64045a7c5dc1393d94f12323201a47bdafbe84c2bb61fb15818215fa64effb8ea9d4b1a32e9962f8a01f8414d192584e1b4ddcb8613e5d698c1929452af20404c5ee2e998dd301b8350c56bea2b80c5d54ce7e376490f0e0cc4f4a0d0a47ecc611289825e6746385b81631907b04272479fbfb6399fb198c29e3d45269156d933135dcdfb25cfa2b9ff37f53c16c7de7da369f7eeef0b1990316cbc86d4f600116391b76b46527cb8fc5ba30f422ab81f4588760bb9ea399a4aa5356666e7c8582aead194121d4c27b36ab5b556d98b00f0ecfba2527f8ed942bf624db0a371162962f3f26f17d8c6f3d00597fb557867c52bb909ecdee6cbbf6ba96f0f3f6c6495fa993735f697415a67456cbeecd3d48948b887bfd1957edae949791efe928302628bdea0afdbea6590c1034ab489a0da2426364eeb593ba66a458baea8f526dc221496b02132125ea657b6e8fa44aa89c172247bfd5697c7dd667536e1726fe9e91f1e20d9ed13d73d7c27af0ea4a370e4aa19642417cf415abdf3775f1f13ab12e4560edd0fc17571e6899c6d7275821fd9025cc86f04a39c13cf282a55fb3c4c03818b680215f78a2e8b751565ae9075f9413fee7b9ba6a5ed206d5a0ea0c46e3ef10d8f705dbcace09f78fe7c53020371bd3756269392b5179a8d9f2f31170539fc92e221e1e8fb94bcaedb3d82f8e0377fce48fb27af93ffa7415a2a1cb525f970f4c9dc6d4b143e4b64cce31e0a3827a53ba81bb8521abfd4454f8e199d49e4d1eb1ab57ba6fcb06c411ee2efdcc85ba2828b95d555f8463b5261729cab0d0580184972e89abe649520e5ae858bfa92f903194fd4578acbfb53d99ad58c411d31e7bd92b96a3551f73a3577629f5d6c3aa236e4f1b502652b793d5e505e3c3c951332ea5446fa90f5c96dbe5171071cc7332053471300f2872fe051cea197a073c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
