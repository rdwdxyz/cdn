<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5ff64a078006b00c19355e54dc8a3214f537bc1b63866fb282c0a5000c1dd45c47e4da387d285294b97c65b7231419c1a464c789954a979c22673b17cdd8f7974ea29e338930f025fb92b9469eeadca89d043e7e0175028583616b660dc727dc17af0e6cb8fb947039d475d5940d17fdf9c55b6f1bdcf637ccbb112c7cfa560147c93fa7c8bf0a3ad828211f0dd677d0d7ceb432e7cb08facc60274e0cdf86761083dd4df701147c032032bc18d14b90ce20dc506dcd78e05d229fbbed501b22a855c4a41dd40eb08e426d70ad6bc817caab5c16feab3b16044fa5aeb1a898b5abe908144b1fb3452406d8469170ae2e0ea6d423bcf246a7067a0580b56d24e9e5faad6e6dc536e499f6422c3a17ca2ce7327571f6c937282fd82892199705b78f3f280846da39034425c29fe1982cf46f88aec6c7f2ef5a8e7d8e7a0592625d3eafec352c6fd202ef01ede810b1004581ecf0cbd2873a8eb2d7e73ac8c0567ebbeecfa94c15f20c7ddebad9466e8f501a8d2d21262789ed68e71cbb80d15f537163e673c936af24e1ffc02ccdfd1351cfeb5d117248a207cfccc72117b5183844f82a30fa502dd719d0b0f28c062799caed7d98cb99d7d2f59511be867a03093b6d45be0577e3191cf2c9d2ed1e15d60246e6ff837aebf5c2f450c05df8611bf625f4576be8a026bdf9976addc69bbb2ed81be9936ac985f8b25d85b4a331dcf408129613648c449b3049f0a143bc7aa18b47bd2ce731abdc9a7f1346fe43760fba9c75fb3901a34545fae59823c81a43e96eab5a34e2e911953697ca16eb4081b2fce40d6383749e0c7b5efaf58359ad9274c81b2f542c2d82c11b536f0febb2ac04316240eb6809dd17929a09bce41a0288ee1ce30e0dc5a03536f2733ed0ab74a51853912bd1f3f48f6304a07f25376c29cf769a9f7b1db8502fa3de7e2687e16aef78f04a54347a9bd6a0e9b0749f210481548420c1d8bdb009e53815374c77f951f97419dc8b8cf134b725d91518ab01d0d2bc7214a5835c8853fd9528fa77f4e0dac658c08768bfd88f1d2f83a71d7ca074fe22d80c887db123ee377ca83c7cbc4236db0e4c0167136616a813d99d0a07e5cb9c0b71135e9f8d1426c0215a82230bf80515929d3fc14c151a1fbed07f51e892ed5a9a38f63ae9b20a5f1a595f7b4076a0ee8d2877c2b4580136cb82485f6b538319ab45d88d379f7b256f30fdcd1442a8bd77d93b448ae6c1946659bedf292afd8689d25b9e341218b0a24ff8b34b4fac53424d58262a33dad99a3d209549c2fcce1fbeeb541cf7e2d85762326a47fd7cbb330d318b110f3832775405d027f475ffee7362de4f800cfdb2d6ad03c57015e87eb578df2c39dc2a546ba9853d2ca9759444614082f1675656d4560a0b62a23326e5bada66cca5bf74577fb8e4341239832c7a92db96ac9de00eee9da5d310b50278b3581036fc46972b8b2dd59b59799d8a35bdab3a3563f5eea418620135912ccac3b1a82f4696d2dac90f3da7c65ab5976355ef765489457c0ed4f77ff1cd648ec6912bc8e95138479752b4ded73046e8c8d1844f925c44fbbf2f3789c5fcde9aff93e8a8a816d08964881c838f2036a0853f70e793a5a3904186d2db994d918dc75ac34efbed84040b3c4532489febd193760b8f8e34eeb571d179b6feb1db554c5bdb32ad7fa17ec7b99d94e98172f9c60e497f2d453fe13d4461a25b765bad2443663e36263979f96f8247b026b183a6f319c5fb66719ffebbf47da20eadf6598b5a2fd3292d17af38765b76a07e00c9bd4da7420b6e699ab90f6cad8f33874e1fcad2e22d6bec27d982e25d664b96ab2dbb9f36e5214c0c9b4c5f915222044c9157abb669ac5c581670eefdab925ec2ace501e56caf7281c93891a9fd4b5bca2996f6c341bfc86335e73f72a8a4b4937f69a6d74ff88ea7f107db2dcaf44800f917203dc3039d183c2b761a3f3e8fb07961a263df2dfcd0cb79f00e521a9b65432716709e731bd23f54f7da50973bb7f413159518739dd4e5b0752da0e67b9fb75344924ee0ef5239135ecd97f61332995b39c7b707f752313b97736141eb565bdf39fb4f8cde1250d274ba8f4446fa13f192e7332d60cd4b854a7deeaad88f54596ffed2e293d0a8a973005b33fc97c1411d0778d78302d45ef6052feb2054c7fcd50760e85e52763afd40d84447b687c689eb4782533dfdbd9c2717c8f62d0250d2979e310b39492d44d27653a99d096fd7a596866842c3b6eba4d2ded72e73a32001f8a46528d9f7d25d43decadba3eb2dfbaf2e57b59744e15b1d44471bc41873ce99e41b2e46c326e6b62aa1ea859246a23e63f96db2042634c6e52ecf6d3cb3d86c5eb08028e5d3ad5cd98b40cecbb26dd990229bfc83d7d1339ebcdef131f61d1b85ae3680929fc64db95c9cb275d6fe2ba167f296edc677b15dde28fc8634d7478133fdd43de3018e65af7657d09f287feaa29ca0a7c3c49eddfcf1d46513c46db9b0cecfb51c4d04e926b7ad6f916d45c8d3e833050193a11ab3fffb8e57ea0126d16be04f084ee52016c2c8f3eceea9182aa0f495632a2dee17b46b62f6af76a928a42e61a3add814183ef92340877417f10409cb8afe98640dc72c1fa01cba1eb4096f2924ed2b4da387d769fba927aca5c98438120933ebf150e9e4e02bbb3d27fca99260a34671c3ece8114a80c5a9a69d2cd8e6e580c61023d0d7566ccc6c7dc0dde05a1062b5bcc8f7bbdcd38332099a4962cb412e5b79d744f06ceef89d52d389b47aa5d2ad73096c018aaec2d9549b06accd854710813cebb90c9d6ef9fc025b2bf49fe2c66a205ff834beb36ba523413c73b87aa280645839ec419c507b7012c0faee156b5ba14d9c53601d07b4c13b4a50119b7becc03e6e7555208098aed84fca223460ea0d6a2a2c675a8fce192920355330e162c0663fbf0efd6f1fff1c0c78e809e995980f2aef4344c88f6d521265a33c90e02b1e637412c84e02834216148edefd4e825c35881a1f39cf731054098dabacc1c461c711a441cee9f81130e13a440ee613df907e92122d6f840689aa283b7028fc0236b442da325b1f13b1ad5b5bcb8967084210277dbc6f87997e0dd84f009bc5f2e01fa91868dda1e1c8a45f241b78f02fc151e9762a2ff75a5f38dc9b0963b97ab89e11e7575441e2e62920fc55700da1be7a6df7fe50ff5fdbfb9aa8b15be0ecbef56e5659b20a12b1214c9a6611e81283ef2d852cb10a35983ac29a0dbf27f83e0e69747ac49963b81e4772dce5b655e01dfcbda1c47389d91ee9801da6c84f6329eb4e602d9c07ea8f741ea04cd26648312a76f194c7f30be9610bd0853f14f186198efddb432831e819248ef9ae6965a96d5c9db095f11503abf03a2ad9d26629a474810678a227118d4e74f69e12aaf610908ad2d6f255e30663dd0c7edb7ea7d49f7a9b89e66f4930adb5944e3743171a5552e7c3e23caa8800d543077de87f692a2e35312919af67dd3d82e0de120f2bcb16a9a7863daa7312fd040fe82c92e715a3fd097b73599fa28ffa8158cb463e602418388b98f7fa48d462e721d17650d11897cdf7306ef79df19e7f77200d06fa044e60f62ba3b7d58ce858de8c824917f814d0a20141d86bbc3d8d408b0ee9923ae3a6909e3c64b9432a3a619265263fd8f25e84220b8fb7ee4f77291d70c9dc323fac0f28e75f69b5b6dd4113926ff276169bb40ef816b7dc595d255f4aece7b338a27090796bd4cc23d7ae2cca2dd1b91d68886930832400d4eba7a450b63d4c3df7a2b66eb1c2818d370ea1881020a499d033e117cdc1ceed09af04109de26fb674be1d281dd876dd42c48169bdb123262dc8550b7145dcad177a92a84d817e11cefbb3e47aa6df20aaf43833a91d4855cdb5aa5a3f9fbab6a0ad7668a182d5a2d9c5b0c2e10d8b0e3e929fad19bb9e63c61062566dd03adceb96cd1e1cc3a38a7f9cc4a4518aa45849a81f1c9c283734190d5e0af08a2cf2410a6b1001933faa2322d13d65101bd26eb88f89444eba0d3a1f32f623d8be9eef20031134c1256301d221d7bd7eaa5849a14e2aae378b216608e691b13e306c1a34164ee345f2ab4e362d4b216385aa04dee2877a0f07f8b3ccd909cc27716100d4edc07387bb1691669f8127b3a70e154d97d89e5d5f15348900be88c744aa8ec4f1446e93641f38cd60ca433982eabd2668e3e2e45101c9b39a05bd210a32240dfc2f506d891f6d0105b7889dc01e1ff6fa9500ae8eccddec54f16300eb6d80632af05111c5d04b6da303d8c2474ecd8004db8f5cbcc9eeefd1df0b05746be441721e416654260822db74dab742ed6e6e51352e4834da0e861972c40718b239651eea862d78c57239d564e107c40d496fe2e6e435c5dfe19198ca33605a72d925d57ad277764f7c58b0e2a581ebebc41eb87efde7e0ce7fd4d729d5776e37f3220019f08bb666e992873abf6a99bbdccf2df1cd339aa6a9532881b382cc40fc8e8ad4d5ae496c01b6972f653ae0cf59126f884ee27717d630ccc7e00518d5b138e9d90c4666b28d8745def46f448882341d25c07e5927b8a5f75f111e8fbbc933a26bfb3fefb6fc52c4f423626189ec429b400ccea5ec582569bc6f9d1ac38577075b34862b987a9e61acff6a747203cd958360113259bd847aa18d305b83130e6d896d70ba56c2472fc2579c21fd9efef36d6c6e7adcd787331f4b06907ea904d6d08475174abc985f47506ceca311b1aa480a8fbcd3ccfd29a679e512473dcdbc7e383ddec5a51c4348de6afe5b8b75e0d0fc66403b184075c5c7bc583cea3418f8755cfc239ef7e0ee282fb6c3ace8550084555f6fc64b01bc464833113121e88e5e2455061b157ad8f7a454d872c055d1d84a08724677ecc18055e773021c0c134650cbe0ab1781d3521bc359707030c00ba4fe983ff482cf0035bd3ccea5a4609de2ef989edc5b17dc9e4da3ac71c1e7415e1f0f32363924a5a32d6ef986f8d2147ffab320f1fd1699b6bf3245b7010de546e32e303d967ffaf720b665004448c73ed8c4439656adfa7827aec56b541d1100c1429dc1912123a700be11b6a51b3dee83e59177fcfcba446d2e5d3befe4414539e4a66bfe9bf5868cda7a65794292fd6a9236bb70494e497bfeb1daf66ceea43c854ee796b11ba074e90b4929c64e466d311969e09e61dd232d0da31875ae285be96b515c910c5e6888749742bf2d58c4ebbab8da0ed63477d0515bee58e1830901a69e9d0b41e0caf6f30105bfd5ab2872c64ea2d211eef4f992e704c289a073ecd4f31400e4ca33523f0b69bbb0c69c8600c97f5ce7c9cff751b958468a574747cf6be3ac08fdf4fea8efaf36ba439b4c67d4dd187b9edeb4a74a8953f0499a8a8d8488f66bd2d05249809a39c663300f1605ddd9f8afb52753483ecb7b6f42adc01fe3a6a31f1294dd7db70936ec8a21eee9566113d33081b45d349c0d5d8c21f58385016649a925a997c217c24924018858203de764e9e8300bef97f8d8150e35ec1516f53eb031d9b458ee3255574a91b1e83a09dff914313301b0a22caa3bd25f28ce107d72750b2cc4d870fa2568d27fc0fd80081d3935603f91a6f3e96df9d72502fd61d2a9c6ac489151ff8de765478dac6fcd345a8f9a3e9ab18f0fb19253191be21f730ff9cfd93cbf3ca7121c2fa8fc4a6f2e1ee970b9c98df24d468eba85b86cee4f05cf4814be9274d86f1d4215e90e4537d2eb241209bfd462f46778e5ef60bb2d5bff2dc0f1f8c26660222088e12e6dc181503307b6399cace102abf598fc05ebd730dd6aa077efb7149f2ca3100af0f7610f13cda05cb46cb771565da35328d9887ba6e10c96664bf113ceb31dc91dba7488438af80cfdc40ff595aac656ea8c3b71bb9a9e653ae6c2d173b7527885218ae1ce3626470d3685a67968f41577514311de197df1962f1d7db107f077ba1bb1dd99dcc9dc54e49652642f2a414c1a5a1a1a161a558b520bf3c77c9f9fe294de5a04979876704246b67ee60bcacf889bc7c0f27d5febdd83d82146fccd8e1bc39faed9e406bb35fa3346bd1d7cca042925755e0cda51f16c9176ddaa83c475888ebfd7578be7affca1a608238b7717003f756cbd19366f6de0cd42bea42897e4dd8234c4caf644b16efdcc8d71e188ea27c9ccbf44f3780802c3a154a5f746d8da38e013487f82a3fef432b003846386b050a09a4a13eb52667b4181b3756d85561ae73a543efe10220e33e504285c545576e7abd905643207c2d1a02a5da00805162b520d92052b09044db4a835449f95754e0f0647936d2d0d27fbf206dc3c606e1f736c8c8ddbbeee8c199c0c5273ebde1686c1559a55ba35d396ff872597b561d998f9dd5e3c05f23d9fc046038529141fb5672a8e8c2eada4a18801008a73a461d348dd10f2b2b1636a99d7c410c729c23eae5c20ebaff70ea511671b3341bb5f465848d62558a5db0b3663c4e98d2d9d230b4b1b482e928daeed8370a2685d48dc0023774788b28cd471fa579bb158e59448de1ad6593e0a4800c60c56beca6499de17569ada872cca84f54381fbc1c138778f694430e7d0bf9c730df06a59ff258f1020ba0955b060fb2db6890be22d8f2c23e36f839d58506cc006cae9263c9f2a600fca60d8cd6f16b9a29dceadf333ba682aa31927d51d5089f90420ff71f5da33f010ec20fd2b385aae8a690fcd6e792a70faf442e82d735fc3afd92e22a19bc1c3250374a4a21541ca31d05c9bee971286fb884422b2186c02225290c71369469e9667c8c947d380317034fdd8c11dd60d7dc9e0ce49a8dfbb423f5430ddf98beea243b379c72a1cc7ec885e8b4b15ee36762cc7f39b280367a23f03618f82bc622d1fdab2b4d63472eb40b64838c156760ee5fd7a0d5085f0400697e37ea4e4a616cbf22498c417af66f35aeb97373d88e0b5ea0e274e5a9a310ff5bf5ab2a8c3d1c40ce957c5f4b2ec17edf6ecdd7ad2f36afd1ca40f657881d43c360dcd249363118afe41d5d6dc0aa34f94eb84a1b6a28a5ef483be488eb2eabd6346090b4d2041d1a6ad61e312e07fdc65f01d4e1249b4d76e749954a40f38b0f42fd605ae8e4fa69ddffd93bb74ac8aa37eaeb3abf9f7bb8b81c1dc37783d64bb87ef0267ce358f792795da0d891dd143c721f052fda3018005c5084e1459b7e9335a7ac16575793e360aa06da39d6c8ee656a2fc66dc20473850f3e03a2a2c9aae3ca32295715d81027e98845eb3f5aff2c798938d943859fb0f6b6b601b4a6c5462a554054ea8de3761cbd0a4bc3d988d2435dadf9dd726e5514352e2c35d2f90ab852e83672c6563694eb3746ccd852948a007670f3770b53d7e321690871ae8cfdfd7649b030fecd913fdb4983c7879b3c4fb02d34c655aa6ac7f7f153f29d35c425151e664ad49f8ef63d5b3dc8f108956a0c4d644d824444218f3fac1f6e81f8c100abba1020379b88dddbcf70aa6613caa3b66408059f2ca9f36e616d17e570efcf1ef97c57d2bd1aeca689f4d44ba666c02b744cfd98ddd62e5546b473263f10bf5a3f7e06d5a33b7bbf83e23b0e0b4db741020f2dc456c83c7954215547c1b0b9404a22a4cc0ac5cb95c31141ac489ec1a44a8e36c955be198228ae5da69e5157ac10c7c3691beaeba6ec7ef00612581ce4983f3fcb231e77f160ae888fb6a8156c8dd35617e7875c6ee739d0762f945f0598d9a192334dc7698822e2f7902f8076e74385cbb416202240fb56c300c68c76006533ca2af01a5c6d49228a0d70d411746bbf01341a4d9993ee999cf1a92232ee41dd42d75e22e4b650cede3029b519301e26207878f2ca7f6da5c877999accd50e093022e2c9e08810798b1ad5422bc3f25103436747ee6b4419dbe0b1a2f95a36ae40f91798b0ed05805fdf6641a9a91f5d4dc77153a52df443a9a748d7bb8f549c933952e79c60957807dc6cc5360ef6cbd731a34e2d1e83c981f55b0ddac121835ea15736946fe8dd2f94a751451182a7bbd8a93df939344e92ac0b93622382e4dfa65a84a9962eb5839ab0b40549220368fca281720f2979ed971c382f03fae62070e789c9ebe48acdcd5ca4dbfa2dc0c849bda906705de513efa7a6078fc5d393202045f5fea6ce8f6e20d8e2eda7eb9de5db19d2e0e7ea67f9fed148b54f939fa0ed991cacce9441b9b016f56f0043008afe58cbcd97729b9144825fe19daf4cbcb46c99987c9fec3c6ec246ea5b4fb66f5437dff5452ebded963c7aa481fc171d545b705b7cd6c4ac6653fab86c70d434f94211c378baebb49c33e24b2313b4734786cbb880b48fd231ffc9d8d8fc47d36869fef01b3819dcc1e1dc7881a233ca492630e170aaad290fc643b8b2bf8ae60d843b6d5301003c366be7cdb2e5ec09e5ccb6ff81c49d084552ddbd606cf7c44be5054c7922f45f589e76264a3e555118b7600549a5db1b904141cbd4594c5c9642e69b2762884a879ac67a2a57ee7a9413a73cb9fd46b739016c5d4776e0171ab5fb3f73ba354a078682b644e441457253c5206c2e4ee4ba6334b64ff136cf146dc56697c12966071993bd2d985ca83e270f2be14cb083cc5a6170fd8d0a32376b3498a45d8cdc0f9d47657e3dbb166f7a398080af00d97d4636433f291aa2850d2383f456b35baa3d4e45490b04213f2c5310d584c107a983e0bea39655c8ecab3405dc5d0a69f580fd51abf979922a6f13b3d02440d4f7fea00327b2116dec96bf8d6e94e2af7d285b44d68ff26630d08e16163e0116113b09a8eab792a532c9f98bf5640fc1e2bb16d34b8beec1e9510ca7932f9f7af789b6785fb3143af6620f0bf26d424785e9ffb06844d8fca2f1c5473d3bc07e0e2765897021e0e84acdecaca871bbc84dfd26a83067dca21830cdb0ddde16201898af5a1be301fca3f870740772fb1f428dd1f9e7b6ff5038a24cf427153889fcfd4858a3a31e7b65cf34405159583484fc77d71d7ad496f35c9d5792c99bb8bbc996c08e76ad7dafa75d5febffc63bbbb2f736c2942b7c50183c4f47a8c59e490dd8d5b97226ec6659df67c7183ef3fa1e22aacce09cab2bc2fea13924f94577206d2ab99373227b758ed69caef1d3ea4f381650b9672297b354936d5f0a311a290afe58540f61ecb9f0b638e0c689b42903187ad853719233a15552bd0ead0214cfa9f108850e9cef6ebaab104e4593ec3c2663c53c17f35b6d6d53ea488719210db8b1b5425fca69c2ecef7757d0525f6ec53b147c88ca041f99c6cd2d06d18bd6f50bb62ab4c5b151d3c0cfab355b7a0a59a8d99542b4ae1bcbb754bfecc0e4ae5d690d1d8f56fa12598d0f3f87df80fb14350ea7b39f72d989a67db7e37ba498104ffc00e494114b99c7c8656930f5320c9fb33425112a1515d0824254f7916712af908bd9ad091739e4db323a6201ca5d82582718a3edcba094c97d1602e4213a78c71795f22f822543782acd50ac468c72d2a777e3b418cca910e89ba762f3f4badc0cf5b40261d264056cc72730f556aa2f848170d9f4419f83f6caec6cd6f158b8f5bebc4edb5bd11f17515b50556efbafb4fe2efc76e9c55472c186a37d3ab7f79604693e64c4ef977d5d12af1b30e65bcf9db39da1f129a10be237a5f36d7ecff1ef372cb5d45b9b02a333518bd73bfd4c9fea2e15dbde720011c26a92e32ccf3843c49ea7333b6995591f541aeb09672ed198cf8b87e29429975f33606d65b5769289cf179ffad968f6c6e582ed0b4b71793e966f75b6fa8dc6a668c36cb86b5a759d4abd0898977bf547e4529f14c8af149209f747c34786bc9e596f12bfbe24b3ddcb904447ec5b5487e6413624ac26c1b7ddcea0aeaef86c99983a6795ebec99a89d1816ab046ebcf1660cd0576695f2b45f8b6ae23ac32844d7f2e2db44fb16503c3352d6b738cb5c8f3fa9396b18010ebad4bec35e77138eb6e7a1253a7ecc858a9afd472fe9b2a831954bf8ca00a7fbaabaf5d3003192960a449918cb07ecd1e3ef5cf819e4d888d351cc582a34a85a3a058716bc637087a7ad01faeeaae056a564ea928d8d0c79375c8cfb73c899dc39ce6b2018b45f47ce215318cbabe790baa834659fe08b76b86b8cd2ba24c4a0ecc5bd6cae08b4880fbd6bc935038daceaed3e748eeb63cdad69536161f76737261ae40c36725f50b1555de0d1c14aaeecc16b6ed01b0f6a0ef59c69c630c3f62e14e074d6ca29b5e16f31b238ed13c42b94747cde310b9f57a08b32980219522eb333382a49873d44388179653468a47a76d2a67537ea96029d18e861acad2fc5cf2e89210a6dafab51693218e22449edb973d07aa41f2c0516d02564a46a0091f146e7a2e329b8486848c400af31286dfa8dfd101254d2a69655135a2af1371b267acc0f6f46a9d49aa011b7a8be52d7cad560f35adebd6577a4f46f4ad1488c0c51135edaed18170e45f609451546fb38d715dd25209ef2a713b41895350f5a5e3b5bca53394fa88070fe07238c6e88456516b410b412b25f83aca6a961a89ee5219f44ac0464a55c5cce59b34c362bb4871bb8a26d1860fb69c24f13163e0dc714fba998373e8d1761ae13398213fb5210de66db0497722c976ac0e4fbe57b0d552c510024c20892e2c7ffca0a039a98bd106376cc808dfcd66a2ffcbc097730840bdadfd8ce475370b1b1c4a999a8b4df20718b39ac4090049c47945ece3bc8d6cb912ee8032fa28d72f4b5cc95a276b267a3ebddf18910d2991b27207bf1f1bc0f3e989858036d9190dd9a985f3d01eea5c5eae9d3edb8fed418a069f3cf534cb11190ed5318c00f4d0b9c474c47c80f12402d9a7779dffa144d1683c5c1ad434be3b2061c7d5b1dd4fe757098a059e4a17e3778d6f79d5589083501e31fcb1e03e503a836f93c9a2c2407d39ab19a99335a2cb74538375e870d1e85fca529a6397d58e46a548c79ea5def3cf3dc88a59aff54e43f51cbe315663d73be93f66457e860def481b4862dd4c4034e628023c72f5c3467d45e6da42658121a4c9f2a5af2934f80189db0bc8454cd0ba3bf12b65e9ffb303ca3f800a8d66669fbdbce97b95846ab3db9d776f02d100f25db97241e41261761e89c43996d16011786eb40897718b5b76fa3e2927ee7892dbeb2ed107478f6915f1bba2ac9774ec89014e02402b8dde2b0becfdc05f9a97c0868b4a98fa19926f3123c536428d426a670c6aa6f52d36d79dca8000cd3e818c9192a196054191befe6fe543e7b6e28e5139c913ecdef25bf07298ed350ed2621bb327c0e438ee9b0cbbd1ff1301a86d3039ec3afa5b9f414889f356ccb1aa310a863c25f93fb5203d798bc47f97da53c3808f49eaf2ca59b04cf74185472477cf25dc6c5801e4c3d446ce04eb509e3c5a0053f5d80c2c39211f15d34e7c769bb0f04c03e49dc9ba74eb5877e928e69c9f33d4c04693fec9c8400e055e26558ec2a90211c518b039c40767a01fa6c9b7d8639bab47345b5b2abceca1dc8488cdbfb50c23e69ce97ca2ae6814d2255353554fea3a5e9ed72be41c17c356f3284dfbd026c6841337147b139851450f7a0c444d3ca7a7dc3f945cbe14ad8da4d18aa1080c9f38718bb235d1e13a072ea56ee9711bc6806961e674c73a3d9da49ef7a0cd7183406d623ae7f8151078c1dcfb36c323a29296fd3af8ec43bd9ccea52ad556220064d079521c70b25d9a7e5ae1e1435ab5592f357e0697b13dc32877f009c517ec8733c3474cbb6df3b32b8d62753217b6c54538256bed9656caa26214b145594fcd27369c44080cc8a46c56b30acb1bbec17be30674b89a97f5f1bf697ab9c98801dfde5446e2809c4c615185b9115bd0d0285da586fd7793f9d20dc5e70fdd7aa9e17798812e694f5edf3a1bd8232e4adf5f149434438e34f5eca8550b4af85e9213dcd60d15167c7b44d06fd1278ba99f312fe9dc9a2c0caa30e834817532262b9fead441def80d8702b59ab501a79622903aa3a944372b21d560e84a01aa845a6d6ee66fa06589cb69633575bce264cf8d7b4a80bbac5cc881aa25189e0057a55bd35d9f133c2ca989eea9cd11045fe07ba6aa12fb4be5f720c5ee11ef3091372b14ca447552353fa1333308219d1286a8c64f631745a3e0205c409ac049768f03965e0849512ce9ae8ef964445dcccb8d1318b5f783dffa6e23469ec9a582f551ff8ef381a0ba3b352d3f74447766cac8605bb486ad278f16dbdfa826c16ffff4f820084529325800ab19bc68569d84cfd0dbfaa13a136f6e49f58426f5695e8178af9a733b89dbf4c4af1328dc2ef2f69f1c6e58d62a464c20fca660de31705a80a84154066619e8805c5c45720ab2ae7a259ebc00985b0f859e1bb19b30ac2e20e135a40bb5b30a65b473f5ab2035c7a6c3304e0796a233dfccf723e312404815797f8e57e29de4b77fdee1ef39920b7fda7ebebf72d15bd51a770bec42df28baf8f5bf8432846e4888e3b2dfe03a3c8216bebc583ac6f23a327fb40b29120c125eb642063099c422a7f63b6098a57c8ac3e2d580f06542564aa4f50fbf15dea6aa9abc2f9dfed6818cefe4c45aa15ee0aca10479c5d5d7ea2a1107ff859d518ec3fdcfa1e6673a524192c66de8634100f15b1b644b153a1b7da121d9af226c3e2d41c15a93c3de59659a4fdd765146e7848352a4452a0bc31eac762cc8404d833eeba1855f046b946620261b7a04478735e572fff7934872e884559358b97c155b61db75654e6b1620687deb4365c9def5da4b951ed26df7431dc2870cb51e1a45405531cfed6ef98949c683eb900de788e7f13d15d980ff5c8ee65410c14f054c783d8fda3681dca850cfd769d605f03eb81ebf2bc07daaadf3be941f1441b54065ea3d021113c03fa916b96cfcc27c212afe1bd86aa7e7fb2fa7ee27f628cb81138d43aad8a45442f18391627b234bd4b32f184a8c39569499ab3965dc95ccf5550c5ba5d79350f61cf68f587e599e20c77d90b8ef17af939a2cc648ba19f63d9958d2beb3e0f39f8b628da35e51e770970207895881e216334ae81370093a841437b61c7774ccf880346adc8a6a81879d58655823f1705e1358ddf3b560b0e154e7abc402d450961ff61a0edd91042cc7aad4b25b22a5ac50220d0a983f4020ebf0a08289042e0c8768024f750c78c82b78beeb3a81f2b801965200e0da03404158f466fb1fbdfbd8c5e3a726bd7c10ec82256c7ee74fb919de1f9d01ac0785a6beffe736d744f1d24cb140e6c59027db1c4386d8857a27d6873cd91b1f5d6b0f89fe84ea0748cfa0d4a4c5cf4c2803cc99087dd21977b236d64f1a62edcd6ce60808bed6c1fe1d76183e486781d75061fc3fa1549b51498606ca5c38b7b17d802e75003873bb97f5be79eabf226c5f5fb8048e7cd574e69a93ded69c45438abbc3a685ee40765cc690bc9fc2e574eea9da08d643dcd88924c43e085c8d61798474f3edfa8c44d29319f315369dbf57b1caa434b9ac8e4fcf0f151c458018bf8c9a76708553be36236a9afb18807005c91e9d61a7e9906f11e11921496cd24b1b00315e85f92e67c2685fcf76f68b77a25876fde0a061561315f6fc1e8aee43b158eb8af4b5a446a88dd088a56ecb4ee52c6c9666d8278d8649842a12895cb27464fe5034807fe77cbb9be5b299694f84c22539c91d666504fb2c517321db353a070b85dafdeef1a9668a8b340de777c7ac8a1f04bb862a2e121490436563fc0fd0b7304d4bf3bfd4cd137175491f9286b48361bf1857904ddb17982e3cb4397276122e65f27df97eed1b50a3c36e75d67352036768e5f16fce6925939640ba85edf100b461c69558c9caec78ead35ea4c7007d12a0632053dd21530ce39ba7847f0cae5816dd164160fba8669f897aba1ee24d5ad18d766c311c943f73ba5f27447ffe7aefadbb34f2512ccec921bcc1cb21bc36eb947282c395931584b4df71a090514f7a33811fc6e64fc6c1b35d63639c44099e958d65bd26813200fd0ad98bebb0ab3cdc1bf479976fa16ee6c88b7ecb3afe39ce5262cab8dcb22bca5ae13c8093902fa951437a42b78df4f8098c34ded40dfb70029b4c28808fbe297b2c39fc2602a156d0e25f5f10edca1b4acb93cd7e96082d8338fec07b791c515cdc3c8de23a729f161c671a3891f698e18223576682b2d0067b905e67ec06f09b8b254da8e753fd948f8a28bbb8f14c28eccf1bb33c26382721b5fe9596339d87d6aaead3cd9f85c7e3aa89573ec8ab3c14c3db697b6e3a0aef3ce2ed7e5d8e6e68aa75f9054fb5fcb59a5b8a82aeb07ad18bf36d1fc2ebf14457b9861bd536e86430bd8f6c130742d2bcc2bdf6e54b46dea2d7debe601eb0ddea416af61563fb14390cc3e4b75295f547037b86a3bb3cc1608fd9a315ace193261e0771903bd3d12f5829859b0eec5203da572ef26e7a2da8474048dcea87921f424b4577eaa859557598af2c6e7867fdce5077ecb537c0a2fd629303d1ee88f7b70816fe31d269fc64d9c2bbb957a7b9ab42930e58d728e34eccfe2d33a63736bf0420c095d4c87b14962468701441ed9bcb484d0c571d855fb183ae11c576a703e9fadaa8515875fbfae03d87d6f2092d4f2b41119a825ec3fc0c918989019c9e159b44d76db5b91431d92b720b925e668ee66adc35eec3416933dd4f3720789585c99f686a2c4ab70df75df6b1d08fe237718868d6eb36bff5d8ca79eb00ce276c1aca70bea8a889d5b1734b46a931769e573e5ab78168d7f97e1cacde1ea61e533e9886224004cea9f8942df2812b28f3e3cf9cf4ffb529f80ac6b5c295511a5b4ca7de2932640e73397bf551d32d796f92f4a0f679dbbce67898b6550790d1f74e5b3d11df116a1f5e14b4764e7cbf5e20bc53c2131b025e9096ffc2e2c1438dd679859b66a520068a4333b5e74666715426e4e27225dc64e3d98bc8740cde0b68edb39ca7dd67ba1cab8fe0f55566c409c3f6d34faac6bbc69cdcd6f558faa24e857b01c5de69d1b0200832653ef5524749295d9ad81129c76d66a2d8876a9128fd2abbb2ff567bf45549e90c1d087d5426353b87dd768f394911ec9614ed1e280c035d875a140f64b36c8bfb22f743998562c61f57b2b9ba5f1b7947c9701e5db29098c58305a624a22be62a79023bca5e123a087e2b574333aa19d29446d4779595e54ed81fcd01a2928003478cb70ef19d13edb078b3592935d4e942785a34e13966793679b9809edad55dd2af085813183fb907a58e404d01e9117c7e753a4747ed9c957b56f3eacd8eb5a4aa0b084b95665a1beae59120f09f18a2bffb6b6773bda020d81d43cf1ea1822748fc2c8ba526f283ffb75a9899913eccd7f2c72eecc7f4f49cbed96d3434c1375d906be6851103ef37741cca5ae81096f2888c5372264f1230dbc07e6ecb4bb228dcab3863a240d73a95a194e40a2b88b084d2c6e350e4d8ea89dd22d14119d5611a9332977d72d4d9d030e06d8fc02336c7392d09698a64ae1dfe128dc2fc6222b1164cb916905f2a97828e29b5b2663a770a7a28286eadf4d12a777be596b931c8ffcf738ba54e71d56ad398bc727d902023a26e61f93fa0013c7453afb2cc65b27c8fbcd93e3622953e1c7c72dddc42d352fa08be972a7fbd5d25069ad0c8ca07e12084d714efaefe1b6e481391a5b293041dc8597bb15540832c4aa3cdd4a57f3a5983339acdb04c9d5c48b16a196442956d40061192c5c6ae1e266f6c40f6cbdbe374de8247316adeaf1d2800df6a59ff63d5c48daf486db077ca9ee9c20fdbcf84209d4134cdda454ad2b7e603ecba9715fb4f9397751dafed48bff1b2f6808c87d5dfb46a63c96841fad5ddc671ba166cfe874aed5c2e59678bb9f45cdd2f4cd9c929863d1f35dfa55a68bfe4ab5012fd7b213910faa6dd89f3bddb786922fd4c6fcaac330e6184c91916d866b7445c7ef6fd5370d5cac3eacd64045faa68437592976c4cf52faef9faccb4cfbe7994e6d8a6e70b31a03c8eec102e666ab9dc120c1897e2521bf16854e9a7bbf1cac2a85663efab55c1976569cd90d23f1a762539c2610fade61fb7e9cb7011c3e04eff3f08b0a9d342a583cd92dcbf9bb1e32c847ff4344946217677e572e6720cd5cfa2f61dc93359bfcee12c74c0196f0ce44a2f73f7985e56cc3f3fb5e701cb2bdba1791d09789dab3b18bb8c639cb9f1ea3ecc8403ce685c74d9da37dd57781dcea21674cd48b242925c2a456eebd30a21509ef59d5bab3710e55212baad05c11e74b56b0ad756b160380979fa47768ef70e1102b1e5b2ae8db44c89f0db711199ba5b0d973cdcee3b2f841c3ca0f1a6415c4b69f80f2de54c6359cdf28eaacd8ae50e43564584286aa7dc0d94fdaa284f5b81330b54f104c03f71990ff444e625882f95fb3f4d454d0be9adf3588c0e44b8533fa5df952c92153fe3719464f7ee56941d69c00b24dd989462b04fa34681e4605c2daaff16799ea428d821b7e4bc6ee76ebabe85e6804d2884db50e3062cddf2423af771ec7ed05b40a00c32f2cb485c7311f9e9c3914e1969788bdfe3d6606b81b398383c937471849d89d9419506fcfa0ba0aa2777623ee175f463e39a8a3da194f56264b597d659588bde62ed65b88456fa70f58eeb7ef52c5f701c7f27e1f5af9a7fd4b64bbf054772c21a4779b85f3177c0839ae265f44023f6f33de622643e9ee0d1f89185b49c635131997fdfa80c31b633b5fd4effbffdd704f07b5d1b8d7ff351aa11fda763317bf85833c74ae18841ad0bc548acbbc28a0f80a868d24df3231420b7ca812e08d5cf75fcfd0076e17b6542cd56c381a8a190fd4b424b95b317a03916f3f6323e7a467a6523cf79a8f903d329007e8518fe8a99519cddb1516d655ed6e7318414f2081b3f8bacd1da5f33c97592ba6394c91ef68710e127a11d575cf51466d1eb6531ad8c066acaa6afa768250550ae9e6ee31ecc60a414b1a6e96d343acc34ca29eaedee3d005c1a418852ed7541c81c8308b99e35ebbe1f36f09f1ab75850c667a24d015fac0198029ecb63b06290722e14a9ae8203749a197bf5d289961e1c78d7fd323d943e55372f95d050cc414d6c845a495cf9a911184a80a738c8b1b56fcdda8977066c83bcb485a040e45c988335b702df74ecc5357b69f68c8c09846fa539343a066fd1ce45d0ef9e427bc027db7e0bfdca6843e1990a77c4a1c04a97f2f51369de5a55670c8f18e906409d42b6e82bfdd625c698a70bc8e6540ef908bb7e18fdd22c2fdbd8d2576149a87c63132d90509a76f00c399fd5939caf2edcce3eb31bd3bb5238d8f9383deb6300c63405fe90a614d9ffb5558d37f77d3b81d3837621c6246c0de00c1f3228ea611fcaec999db6b471456ca35cbbc8d32cca0fe587cc27c55dad738adc427c86e0c279921b1d7b62c383872cf486815bdf55474da6d64d5c68dc45967e28597169b676c7960e5b5960435fccd583ce2545533ae446fe179afc3de8976d84253013915ab36bf897a325d338060ca9ac9406940b8ae17f3f549b14bc9071ecdfca0fe2e61d53d384b94a45b4e78df88c96cde6c6302c246775dd9d905f8118a6dabc236b19636d0b86b5ed56ca5656288850b4fcc447200686edd4eddf4ec0f6e345c94834047b6014d828d24d213557e5137d3d3d1d97156cb059667950deeeba7d5f24eafd87b5744a643398b4e35311923a03e6af6510eda6449dc22a6253e96c40822a2c9686711be7de32a9b663062f3b17b962b83a436fb6d192a7745e5a3e87cb5d49933e8d2e4c2bc65b8033db8646778c58d1abbe96f32953f428c1c9cccd5d2a789af4f9443415e8cfe4274f3ab64b73acdaecd25026b04cba3036e08fc20b0ee2f4c59c3dd6d89b2235d776c8266c96fd7e7bc31684981b72af1207e96dab4195dec7d9adeed5bd5d51aabcd4d3cc7a2df24e76af7dd4238e4fd62df641c9007a602a3ddb097116c64606bbdbcf3e93","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
