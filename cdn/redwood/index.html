<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5ea679a067918b7d99753310c2efb4048a5798eebd9240396b18091af7d9dcfd58813dc80d401b609c8f618d8014298392bbb595edd96cf96971dfe709fb2395a04fa821bcee96c045fa895f457d6e95d3ef29df9da4f439b1c47420523dc705ae664e65d14d67fa896f0bab6b4e1ca119f2b083874702268ddaafec9019b0cba4a88281198b51521ca3a80d7b44d83bafcaabfce4f155d5c3c710dd8d073899c7534e89e4307fc8b385f6b9ab59c8fd72aae06d49682f3008525a6bcdb571b702c39185209b6c93c84a1b293f1fd0a20ebd73e49ffbdd72f791e5150f4cf4ec0136a75257a6ecf85927ff3c5e830541aad70050abf1187e5a5c8653a8dc3a4ff0aa1af326458506d5c9b5b888be0abc66b712ca40ba79a827fdac94bc286158535390606289915096133ddf8fed77bff9d1d54810474e4548469d925a7892beb1de2f426e790634636ea7ca620b4fda78b4bff525e6505f6b4777247de8bf8ce29ca4e086d230e111b84bacbb806d269dde9e4afeee7572636d98f2543769e6e42bcd47033d4fce019a8c5a9f0750fd4fe78859d7445b0f78208cc8593d32a435d9a88afbdb503ef9c13f2ffa0b4e65616486f9177f6af09c6293437704b8c76e9978f2f5c0c3a297042b1c77b8b43df2ae54f37e982379ff385349d5ad544e612693eaea0eb518e6b914137d3ea3c236e9b777a899782106ff23b1e38b79d584c12b494bd221af8e666c367f6de3c4f1410247bb7badc637d2aa17a40acf4a2c747b5e9f573bd589e8e02f12016074ef7ea79de57979ced3de15dc8417ee84c2d4ca9b165ca73cf99cdf5bca5d5672b8fe73573bc83165ecd85943e20cab1c961886f426c1571e7c369e49ef814da5ffca04bc50d56188eafd808ce2ab0d6c0df0e696ea595ebf12416375005a5584146b544cef41d81f9115f6b6c39db53c90e6ed23e67647c7d1aafb6813041853c4290788dc329244955f7cc6423f0510788f5cf9bf086552b1a0ae0da93ed46a0ffa6b15e6fe1f12dbf134debd1358d808e454b8256296c9726839a5f808c8b1a9a46a662db49cde99ef0bc34b25d8c77a9c019299938a1f6f77425a3982d29aad89c8d9a9544cd444833e112d75f04e22ea81488b0bf80ec0b8e2b00f09bb4c210060cb3141bddff9854a1ee10635130d3fb43a05b43e9cbcde2e07cbed720b64a7d84294817fc0e8f4f3cc91b03ff55bd87320b0efc38a6a05e9fc83a4b05569657df90c600df30aef5fa7043e9d321f66eab8f2ef050c291994635948e06daa936cd1a7a2546539bcd6842c8ede02eff7f2e0450ef63cf75e27cdcf79983b8e535f1e53606b1691133a9878879dea7c358bca544f2453f9cb733bde93295baf841ce7bb548e26e8d18347b4c4f625ba49ec12736e693d44bf810d62fdec54dee45a1622edb5577cbbd9bc803a09294a600aee18bfa96e5c4f0c5bced185603f568285956cd5d96c8ee1462236c557f6a95c0caf49da0ca8d218682ee338b5ad171a796d5f2515ccd6302a1858195ae7433ea9051f64cbe36c4281dcf39f625dcc696416b1bb4abf58d12e9ca746adf27d940794b293c2f379550f3c67cc27f0276857fefed83c1e21608f3272cfb166e62a7fa1d5b806bc8ce17c913937ca42a8a9270fed11f14ff4ac85c4d3ee5816804055fa3027295ff89b3b630b43555645ffd1b4cfdd4f393313bcf8021fd16068bfae9f60f33cf99b881465f1ced8374f2abe81de11848bb98b7b82152641531a76b956d414fbf602210e7a1eeef4f76d116561d2396f7d3ab9e567336ab8240a5b537b3c11b1241b745c6b622084db3fb5197a7fb2267716ea1e2389e734df3bc9ca0d5df2d10ffef627eff8c7fe9b17ad6d562f7027bc2cfbacbddc4f2ce2e9151f912b09af5bcd0e779240f340d429b9ce6ae31165f71dbd361a7e30ec38e39f983ab44e2e29f6944e4b5cf6f64cb42a3ba1fa4b2325597eb200b5e4832c3db07ec91bca0d04a3a487ccd71f0636c884a3bcc8442e8208510f9d2911d7eaf5995def9ee5b54b3f84e014dfed97a49136e53426d5ade40da2cbfb40facadfd9e3917661e4bf250342a075e756795dd3aacff066e298a3b846ef9bbfb4a6077274935aee5784a318a733ddebf1394e72a88c4e8bba0a542130ef1eacfde56d02e1c108892afd5806d5e4539e65d9536ca2f47fea3a322a727d329c5d7b4d737c12165546065c3c7f1df9d54d1a783d8c1e00744b0c5a450604ff7be1c548a0e6a55e39188204f54812a06c1a1c1c9982dcd8bf4a0f9d4032584640d3267a7933aae6243986c0bbd7ad573f9015796f42eb9c8742fd2f0c909cf5479bec1bd60473abca0391907749c033e1e938567cf8d4a2c1e32d91e435c5ee7cf5653c9ec701c3de4e5579cfa058e1f49973d68398ba4b6d2a7e6a9d0a74d9f224dcff33ddd5f0fa3a83905c1058674ad0b0fabf15ecf585debd32fb3e837c5edade2f8ddf3d3bf0aaf3e05b2ef228b027b4fdeab93b67692525361cf9046e6707cdcbabb2bab42f6af746dbf15f844faa3dc0130ef892c6299098ff2d7af9895a33dfd8d10df29182ea41267257fa8b9d0f60185b18596aa700913e2259fa4277696f381f111ac3f657b4e5ebb322bc5aeb1c4e8296390ed9ec7db6f59a0f3a0b5778f67ab704e7476b1542114eebc16a19daaae5c7283beae37ce1cf7ee30f6c9dec82382b794ee8190a0363bd512274fe4630ff866544a823e625526ab2a64a3e649fe39fd97eaf57106b8ab3d0d261e35750f1e10d443db38e34eef5e257928fa66e7fec77a9d15e9f06b87240fc5eeeaf6e8291e2ce91b1eabe142b72fce15fc0496a9c7ffae51e2cba9ffca1c16e50b80cb268cd13c5a70b01a54e0e6ba2cfbd01003ee161eb9cd8acc4fbd25559de5790d5f1d18d4e596954d4015370918246facd4dffdaa1da6cd80479204673abb894d74a268b8665db51b728a52d298d385b571018b1956d9eb4a41b4cc7b8ad2852376b586a90ee5144d47a3dee1f2a1651c00be804402f0caceb1d26dd96e127cde0706493823e4aa046f50da80cb35f45953bd50122b6c53d513c44c37295a752b37ed075b1ace7d721869c2d26b2335be14a8752a098b9fda516245adbfa64c2e7cd396b15d6b4ef72d09a9e81e4effb4c2d55bdbf79fd40774edecff920fdfefd177009f24e24f5afa19ddfbc10ef0591b15578e0e6aeeb3f8d376ea56e6d233f2d561a994796ad73848ba46caa89442e0cbfefe057ca88fd0ff1dad644f994e0a8008b4d09e2e35364e0358014e5d547671eef4a3cf14544c58b697842f740df0470a6b9f295a88d632b9e380d4c733e1e66b8652eac0e544335e898cc8b642484c3b909c484ea119a9fe77ef8b31f9d407d3e783fdb9e4b96c22c17c7307dc8062af8937e27edd7562ecf27b61d88138d127bcd75a25470f68a67a10cd227829a81bccca989840cf2be10862987ca97553f9a4723c69a63b182a1af982d5be14e89241ec05fb5e82f15fd6f0d51cc2dc4a05306763d4aeab534417bd6679d2eeb82eca1549d5448f11b83b26a1098900f6c4c103b11b867917382f3f83c617958f1ff7da65e91c80ee044c817bcd7ca3a911d9b2cb7156a2aebad9bca717cc0cc9e0fb947f7d98b2db0a18a51712dc10198b2419e05b8f97604b7267c128ab06ff83d606dc5cecdba16799bb40af6c6016a18deaa46ea2d6f4376101807be9ab4d1e7b819cad10eb7b6bbedeba1c79f1a4c2e6f1e52b793073a873119eccb37c46f098b643171bcef9775f86bb7fc0e41090ccd1f70710d22a77e190ac88bb3018becfeaab94eec3d6d33e6e1c038e216797d66d301b464f23c4bebd1a35decce16b7e98563494900eb59242b0a7c5ca31e288bb8277829bd9636b2d73169642ab541a57c5c75814e2a1f891e50d2f55ff1357525f6d03f6214f296136aa4cded8650359d81fc57cb43b2848cd202ed3070ac9663e474a5b614da61f430ad503e8cd9c5d97e410654c2b88e7849be5301311eab9aa02a91bc84e5a118f8fcf28a9644c4284d651957945b05639992ff3e35d2762137d31a7d28111d486bcb6b03d80f4c7062150ea07ccef40a15fce247d9d49a1b5f12d06dfce4bde81183c5dd7794b10f41ed04fa48a72e771c7f561231c12aacdf9dd122a837a83ab174503f21c505296e615bfb5a09be6e592f8536fb0cda82a24fbb38517995c2cc071ec42bdd8b02c1ecc6a02e2d8f1086768161d153ee6f0ceadcfc199f948b61bb333b52d7d22625ec3a4a3e259088346fec6966aed602868e6169045f85c3cbf9b436605825b5f7fffa0717a90d4d23592ac7df9d3006aede730b84dc0f49684150302418c9adf125160321cf05e768e211bcf56815b25c42c0377a42ca79d1e2122044028fb3b1df1f76fadcd351bdc67602242938f4e5835a85c5625cbbd4146f47b4bae480b1f301076ff3f4ac21849ba4fd92b92a73baa58987d520323f866f7af5aa80ec63dbbe14774f562f8a886d9526478ec29bc757d0a388d6eb4139c893a0695993b9e1085c772d905d9023692980640614fab0b2302128aba0b5513c773e3a96af0d88a3c4ed5d2beca7fd4c28890453435d10fbf69b01a96c35e1a5a9fc74c95260d3df382c39d5feefae64d68d3e8ffbcd0da501f0f94707945084a36d3c77aed5c60697872e5d0a6fa094516364efb5acf29a5d8419bf32cff90dca3c1e3374d16db2f9e2ce1816f2f1c9ad4e47467ec439eff500b73a7254a4ab87bb9f81722f0aaa212d222a7952b083d70f1fc9b759452390ae5cd23b3119ca4b917f7e0090b508e90adaf276f50908025a2fa7be17683148e1bf3f8051af0d7b1c7ffa1eab500a91aab359b97db8cff502d2e14020541b993e5a8161fb03d59b457e4305e0a09e9839c4d49b6a92258444fccc45715dc478887ad7293d45b5470d9fa833a285d2ff78e26f690f02f556f1bb36c7ad96e7850a34d664593e9b01ffec1709e209a97b6692da67085410820126c2680e20cf3e563121263d759203431df168118e674639b3957bd0e5bd7e92e3b3772e805ddabc42523b96c0481290292b398de62bb5670191969993f34ce4da32de31fa9558a0c30b506b6ddb99508ec064e60d70b6ae603221141786c4e00f9da019e2a701f7e67806727def4482c016b18b8c95ea1af01b009d0ea1286344b8c4c49eea1542efc19d6bbe6b45c32d421a9c812b33ae49297b35ccccf77d9e31fe16ba256391a5c5bacf5aecc3b8a712bd304e54ad502a06190ce0020ff68d944967e51edca4c2dcfc4e3507b59397bff21b8f82255c58338dce651bbe58b9331a67b39b5138b9dc2b195660d1d1474b65f942be8780ccd602f1e4eac1c254889e192df6496720ba03a8980f4c1480bcd87027aa54c9745292a4d86e84ca8a8764d72244492006b49a618911f415cd4dc05d93f61c3efa6aa2e2bc665b81b51965db9cbd561b1c2fd6fd35274688e638d603f1440cbdff4b413b6098ab17a2d225aaeb0f36e21686ece1997d6922e8af61c411bb3a1ab4722bc08b01e60c8506c386a76c8c3ee8a512312a5741db95365463d51cf660d0b1c3615c5d4d3505e2b6627a60e9650de058f6dd64121c885a5ca231eaaf2ded7ebba0582490449c6e98fdbb0fc0a9c0a5b439149a8285b9f800127296f5756a95f5cbbc5a54dad1b20f2567430a9073774e1b096b2de57f50648ede8d6c220902e8661377b3039f1fc9bcf1530b780f7f2024b50b21367b2c30e840234bc961e7012df4a5e8f72aa995eb0a281dd5feefc7bad3713128fb812c4d3bb4d73b152a7b2f91dc9623c1a92665056da28942b61bbb9ecafdf1432a46f63cadf6ef40292de7292d8fea2cb087909d46d22c448ed6dbb7dc2b2b5d2bd97e59a46414878618998ba954b56ad2d39d5c037c29ffa672770e3816554f7996bf7155adb063e201daac190e2ce43e7ce5cf24e05a3a080ddf8b72ef7e3b010a5c9217f985589424fecdfaf8aced9ca30c410736d333172e471705bd612e1457b6ee59d31e6c572aff58908e7b5bcf915249d107372ee07693ba1a761915e0f169d3f7e48756a624272baa4b12bba7fe9f7973fd3707cc48549bc7d9173cfa629f7575b503f3ed162b3609ee28ac0f13258a85d9842623eec02b8713338ec60df45fb6afb43656e4c85ecc7174251ef3ae09b04c5de0ec9d9af867db929525eff3d158c6af188d7c1ba8bb3b5df9b1e7ca6bfe028ca6897e86dd2ddc645a674cad0004cf2258bd1835b5322137aa7ee763726d752cc38a558f11bf0cc9679a3db737db48a59b5be721a4223d89658e602cf7b09487e696706607a2b89ef139fb9bbadec3ffd11b98d738692ab19cd23b04b7217615fcb92813a0cca4a81ada1a647a12e8327412d99adfc16ab809e65434a1310ef894c7dc025ac2dddc9f9444c72098eae64389a06dccfce707389e03a94caff970ef7db150cfa65e9d7128ccc13b9669734dbd48b2df868ccc61c6857b6760397b0f7a81204b531360c8aab872f2119bd09f7704ab440503fca9f80fddf54efe5dab885f3e64ed35470cdbdb4ff24363dd7e2c3da8337b6dfc9e85a30158a045fdce75d29627c1855859e6c95aa631f6b0f1ed9d70f38873c61efe0f39b1a2f59f28a5d5b892e995f6ad98379f75b03a15317f4dfa5d4eddeb8ab703d65fe8b6bc8681dda6cc262dbf1c43dc7a2227ebf564141bd8dd8e22dcb569bb0a329f68c526fa76a685d52d26d90644dfc83a072a51a83c98e170bec938bac830ce252ab80d6258d497cf5d5a036e18c7bdc96cbec60ed8067c7feaa2b21d6bb739a36f6a7aa3241dd74bda261b29bc0577e5e681a161c36e1f826cf3f81702a7dbb58767fa7c1d5497c891ffba0da53be4fcec280d1d6dd8aef394028c2b08c34b434af848e8a90ddc94ee522b9c352b25e04f2f39ae43468691b1df4f15ff1a4702d60be3648b83a6121c3387dc42a4608a4e0d92cc9aa5b36776427449e013632d26f43b99344c5ca8a02c5d591e0ed3ffe599db46d25ff0c0b087959d2e328550e2a5464261efb1165608d676cbd48a3154c6288eea50226f8d10d3bc96a8558ac90643e33a89a598f9a019deb4af74e7a0d6d05609675e73d4b330ab1b56e8202362e7ca8700202297e7812d9daacea7f1b1312714a7a73639eee2da8ce1abbc7917a37df18fe2e601bc2919c93dbe184d0eaf5b2c56714f024cb3519e7ca0c1b5c0596db46284eb79d9888beed4c96f011a07440bf7e0defb2c21ad72eebd4024aa9e5057aa0f8bb1c6695a243519f60b47f31222844380c58db4034ca6379ffec995a6edb56f740c3a321988a28a559f5274b5da747ef8c6b338ccb7cc23ebdbcfb937f3edea6dbd9e77aafe63a9b40aeaeda5479590cd87438873f3c55b445b014780b4885ad66e9d77cb13309cb182be804e614c6353c823c4da4ce10486ce8099ca47194b99c6b555a1a9717ef28bfc9199120b67b5b2fb70a8a62263203a82c6f80b697efdfb89ad66394eed2299382f4d87d8153ad5a3e5705cb9364abba6cf161136778316af9175668085bde266b2a59012bbb174c49d1d40a1b963e6f9b646707ca4c0cd7379a94f7c3849d86474f77f3c40880ff6aa31e3c8e45de87f5106cf533a720fb8d140b81a09fb28631e100c0470290458af91a095276361ad4502cd3c91dd5c263427d3113fa3528fa653d672a0050a8713d213c71a070d08996fa5c292a7aebeafd59aa188a519055b132e8dcf90e89940b9eee6ae3a786c29a1e9fc897b48172fd233d055a410a502beda1c2f51a3b2df5ff4b2b8be429987816b50cbf4f3b08bb8b566c22ce915b249eea8b9796446e19a8f372632d7548f1c4b5445514338f0d1607f5f196ed7808e4d7fbea0818b701ef3437b467a5e510dbde6d82b6b810275173e38fb534a968aa3eeb36ab76594a91c60bd8500909984a7c38283c64dce9099d105bdbe4a998e19cfac36df1874677bc5339fcd6d1677e1f6704c5bd310d60c0d4a33fabe056417c34e04ea5940b3c538e71625a223c4be2c1030b758b358d4fa39be4d3e0a55e4479b3921ff0885814375c61e9187d672ede657d2fae7d58244bc1c2a6bce3fd931a720dbffd0982504ba430149e32b568db03c955924e4432d4fa22238af7e84b9d71553455c2dc7270f32a4c02d233c8eb8e57c8dd9407e64834b5748a0e25b747f5262639a9395b9ff7795e33e82876ab9f9f3c403d58a81b14760d7d659a52a78df69862704a6c17958fcb4d39d09892103ede32d15ca31daff995885b786e606d781f88a685cdace27eed91053230fecc9403a5514417f357431adc3bc12ba5314e695b0d5e22c231ff44bdc85ed5f84a6ead9f9847fa3fe8268c986c49d2d41b4aa1652527936bde32d36e9545266e253603e0acbcd5594abf03f080d69f256d64055d941fefde03fa96aa42cce04c4f5c3b9a3b9a89ef9bf6914a50f3875510ecbb6b009684294a344e1a3f8e9faa55e970fb9a9e2b02a7a7d327e78560e46a7f5fa77f2ecee23a1569e63a7781a3b0da7f130f9717bc160f3bcba575a8f37cc3879a2b4fecca73500bf7514b452501b78200515d0ac1533627f76ea69c85ae462334b36888852077025e4d74a0781ddbb8afd657471717a2c86387ef37058ff93175ca60af17af060cbc475b2214aa5e245a7c87a1b2e835ed95383a8712d27f91bdf018d07588c363e11652cdc4c240fa9c8d982c142fd960dc22c44b0beea269fd8b729805752ae3eec97cc6d17bc0d672748a938124e75e1c200b9fa99a033ecb5d50ac787a69d5c59cf581f333d545bcaa07b1bd6152228f8825b45cbe3ade9e78d2ab6236838d518fbc60286d1dd3c4e5d2b813fc50360afd55b96aa5c447f43c802a0360857c2e325c94c85364ec605a87811d2f28fc97b7ca58cd408dc2da5aac053ea97e34ddc28ac9d4ad29beae4364caadc174754b623fe0986a4d9018bdbf9dac112d61023e6be508710da8aab7080a7abab8915863333de88b8a1d7ad4e15a27c145fbf87551d124a1765295541c0992551b9463bc60e579c3272b1dd03e71600536e289e27625ee1d5a7b6bf214917e0e7f665b465d72e11d0957302d1f9f3c877c8484f9bf8380bb3cf5bd547df5bfaf3bd4171366a3fa1007ec6ce3163e0ae404633a935e8df115b4b1b197016b21a298468c7adf1fa00f9079bd865754dfc2f15e418966d3f930bec17cfd1934d62ea9a69478cdf91ecca5d816cef42380da591df1aa8ca8e4815cdf546bd08a07e07440da202fa62f5c5a1cb7fef60adc4146a4aa1f00f4f87d2381d4d6b73b51089ab023bf098a0716875fd7df3ee9a170109cb3c42aaf5ba999b2dd5f2f421818c0d7c5940d950984bbc962bf3bfb257ce3deba34f2a18a7c5ac00401e59b58d5c8fbec4f146bb4016885e70c3db894e0f7371a8afdd2b51682e42a769d6a1e1f6fbe012d43af663d6182df3800e2d7a1c29789aa323330ca60915943c882cd6902320fdadb8f5b6448609b3dd531768e092eb1f1d6f6ee7853b7371ab4d04ec06983cfec641287d9fdba9ebed1a8a3ac3b89220f1f39724f6de6a2e3a9f9d0ec18ee29a2b197acd4a53c917d2654f9a155d92732a284156bfd0e6a90d11b030b653efb0dc99925fe7b329e608e0629871bf0779a161d6ee8cf96cfeba3ce213d12cc1384d82db711339aa87d1053d28dc9ada652156d7471136c2e4fee1596b0ff77d081c221675c729d3f97a9ac743f1d4f0692fb6438e22b1b5b73e48d3daf9669de8de5fdb15f86fe7670355b1c3f5ac62c2642bcb37eb3eff9e4eaad3c9543e0cad3da713cb78675f9c8e659c1b346940b98ddabcbd6b4771230e53c8c76e2b7873f250be81d614d09553c002a193de7f3fffad6c09acfd83de37c4ace230a77ed3406eeea31a47b77e314a725f71898a4e537c56e652dd186e199ae4eab7a004d6b8b707ab38d42527c5023e378245cd11c8b79fbf6f6763cbfa1101faa23755406b6b0e49fa98497b773abad7117790033d1c032fe4d4702d1783205ba93727e878aa244fb888c3cd7a7b6ab59fbfebaa4272b303bab3adbd397764e2f6ee9d92ae33e60b004c91f06ef6687f3589977538ff82267fa7f66929302e526625d30475e0e02088cef65379cb432b75d148aace1126b589672164f84ff4b9089e1521623747e6c4073546b837c296c8cc96bee3670c54bb357170a5c55c4a431e998a7afd14bac8cb2d0c4e5b51efed9cad25dab53092b2d9ef6e7ab34c84cb3b2fe6148734e8488577164e15fafca43cc9ac64ebd7ea14fea7c3788afc46c5f2009f9abdc7df54e58b7fb38a6de95b413c09e272c951f999fd2bceb4e3d6453ea1911e1236d3b69b948f8246adf51c99e3b8f8b1128068e04a4699cbd89062c0f76e69b15d47ab523067ebb083b2f5ee74efb5426cfe132072a14d61399904f43b48d6756a51f32ccb74b154187bb6297cc5da7dd1827033edddb38b826806182b0c72d5e1323b27537a2c736f644127181885a7978deef5a913ba210fe53e3fc671459d2a310136593fdf94d1e5012faed7db3bb15cf199b0e3f63e8d0be168cc828aa2fa9958bfe7af263e3b8b38e10f566441d2ddf81401d404418ce6ab1e97e306346e7bcb9145222ec12389982afa07e464aeadd02bb253c202453614cd2fb577592324f871f609536fe73b1cfdc65c0ad7734c96b4fda2b9766d103a8c5e387ccea5512a92c3ecf43077ad18dfa4129731542e3c3e36fdc31919724b5268e4492df3d82f13e2b785c130df3d8756adb1a3243de1db909383019fd84d4e0af634280bb16493d94fa3b4f73e22200f0a7b5eb4e60970a48120bc6781568decbb2c1d4165952b896f0bf33721f3393f5fe7248a04ae2c52614e9f5bac933597acf016efdc23555ca0e8773236b35d6486d3af60dc163dcf219985982f3f3d6073ab44db7d5f82d48c3e40dc8ab4f91227c08251e75f72ab8c985879dd8985cdca2fd136a9ecd4fdb422c2f121166018054a9fdea230269aff9309773b88312538be732860dc669b647b6729cef2553f3056aecc5ff3c68840a27b4efaae60f408d33e3fe1f1fbcc57254e751b5f3a6a85b6132b7bff571d55662159442c8b59e38a3860f5509f26482fb7afaccf1e1f6c7c5d31c54f95897754c9b9693ac7ce439fa1a179b9cb90add1598c1c776ab47426fa4fec8cec630c4e82dd3a49636936126e7f5297a2f33998ba3b27933d01fd938fc167251e6709f49cb9415ce6e68ef420df9fb90d01e661cf3be45b7c1a173612a68848d9864d4e2e9bdb73a343395edc61ff287a03a1ef8db41132d9b61b06dfca79c269465f964eccfe4818c9359e46caa6ff65522ede5864768e1dbeedbe546e982bea113bfcac0676ea2f5e657fd9e6bbfad065be18a1befdd8b61781ac5a26e97643fb770a264790142cec92da0e96e8bc12dc9226162a7cf1b18cce8f9bf4ab309fa7841e5ac5d0ed734ed7808149481c2e2f9afe5001cb0fddcd27afe0994886d67763423ff3a31677ade6cdac84c65acef08e13b66c68668e2858c89f74fa70a1891a38d930277a6b7bb518f05a95b40403e3fda1ac3ff4d9e919f079b8655f2e45dc0c62b0a3219a9c56398c23a63dd1499e7f9b5cbaf05726b4d80c67bedc3898f24ffd0294da4f630fe94923fc614a53466853cf64378d9539fdbb02b1b439c1e6d20cba815e689602b3c5b836bf70f76a003dec26518f06ab820fefcae5eb4ece8e3c5b2a14720adfd5ddcc809dbfe552bd531bcf9a1ef250780ea9a32da843fc133a836992564944c1dea18293db350a17afdf1fb1469b8b0c1bb79504b12fad863274d0a74009e65f4b0f568ba445a816a5d4170836d963dccfd63fa6f2f22956d5d269f9c437e122d7d4f574f80fbec3ead0b64ac7e76bfd4e18dfb138f830d1e3a62895a2dc5389f1444e1bb1d482ceb4674c1d01ef64a83190a647e3b33fc17b73668eeb3800c2a6912bcc2f0ffe5a86e59f4ffc9813c476ebac983ee59e66407db8d77d264ce7696d8e1a0744eb2e4918355bf89afc0e712ee42120de9e0a5cbe5ab6a1405375cf721cdf5195d7dabe3feee09a89f8a36cc3a8c0177a01d3dec9264c50927a4e05d98b101c2dc0d6fbdf27883181c1a4eee61b1e3061657b4e9b666a82f60d456e309e2ef8b43f6edca909fc1c04ae5bec03d9f369f166f28e27fce27b8bc7e2d33043dfd365ee7bfab8113bd6fff6912a3baad61fcfcfcf8bc0e3c497cca88587ccd26b13d498d356c683ff45c4891f84c3f8da323bd98a4dce9acf93ebc17745b675b3e8bdbd07e3491bac70a9f3d83f1fb64902c87a800b978ede146d8d7240df2ebe4a6eac0ceb2a2d83ba87bb0db6f654fb34985cd341fe94bd106426a74169c73356b603d654d64c9e1b138f8d4323795b96de90a33684295a1beee72c36f36692965ad6ad989d9cc30d51cf9af2e5468bf546d2ca41f395b2593f39b8583fb38707a5a022b46fbfe59c3607c03d007d4534d6313c3d37fc22f3fff6def3866f381973bf9fc74bc03d8bb7ae54a219d5f1aadd47bb5f4da76a0a7d302f600490ae15766bfc50be0dd32cbc1568fb958238c8f850a8d35e6276fc95e13c73203fe92d9bfc153a2a5f6911b32e8b3964473293c65fd35177e6babd2c1e48158a81b9793893b01700884af4870de2e2bf4b027f892b738f8bfaace8e4503a8c7462c84ddc097057d8042f0052cbb96b3679836860223d1ad08c3a2f3891ab2fb3eae693f152fcffd218715ff3c96df73c6c41a2a4f89e9e434e590805a155207356bf67e6d9e79b492af83ec5eac76918866876964ed8ea882204bb9a88a7a614f5db0a315b29b714e8f5d48820731973f96057d8cbb78ec4ab87aa985cabcdd8b02c7fcd4465ff22df3f95558e87d15db86d26685cc4f98d56b8bc070817944aca22206454db16e3211757aac80eccbf60d03aa979535fe5e220d84b050f7677f241fe8ea12394a94302f054d598889c8fb77b9d0fe025c83925056c485971131a0dd12e5e4e8f293be20606dc2ec06588fda43834aa2294b4e61c0fe3f6a638490ee3d1238d777173bf33f502bcb3329e4aeea779dbb793465958b7856045fad236ca36287faf8d9cfe3944ce41e4bdc67ebc048b0ae75ddbf6fbf04548c20b9a77a1f3860062b3ece6e6e48f2d747c11880d483c3118a76847e83672cf8672aaf2d0bb3ca81f376ed54d7177abcd7aac7bc8abc3cd5e36c0bafd6405e2d666af04d7721432fc1c8b168de226206e5e834e53341043605b0abf0eef187e4c2c5d25ffaa7df677b655ebb0e04a36fdbccc03c791a389c88b20a8b00462a8c6f05d7ad90c508080c0f176b317fa86e561f85ed3f430b3fbdec1a18dd190db8b3449ee4da56f8c47d1b4e992e000a069e0687b2437e2766f4e7d22fc7fdf4c74010e961f16835925457ba480a46452ae664631fb10b1c6cf1de62258c5b781bbf4163aa2048cbe7b81913f45336216b4f9b5fdb3173212f022f3e11fe994c62684305539fd767eba887f57e3c511d62f49803cdc6ec7d915cec59e15746e3b67893aaac0ca9a45a025f1380fe0f000c45f71fb7613fb002522d9b6e7a5ddc049e1de87eb1725eacf4d33a43d7c29a26ef339627107176a9b242d76868b73930206f951256623816155182606d7dd89206ff6b3d8c94b1513eb06cbf73de78b02f5eb5bf5256ca17245f4572e7d0b9dcae2b53d58eb5c5c4e7f9933508c047134126f85eb0586eab1c5d263a781a77ea8d10ae63335d8e2139ab4893fd89c5d14662a649edaef5cc1d5f94ef17c6035b40d781bc054737d3ffcd771c239be1f1e5f29e45a29b1af6669c5a0b15bb20f675c09c891eee71440381dea93941dc9b78c7f800c8ef1d22ed9f3fa90d132a0a4624f1591169029532ee7a692ff6ed5ae36e12453d8ad23d920190bd18a7a60dbe09e3136f6699257526d2feab680e5fb8bc8d980e9b50ace8d43abcc639a0eb01d9d6448e96867963507a35ce0f97e31cb1442da755791e8b7707c87a5b962f26eab5a6a037bbfc3782e3557ef6c7d1446f29dbaebf2d2e2704d57302c78d3ad6f656b080d70964a7e43263b23f1e9892b434ae3bfa3bcca23f60287520b5d6f571705e13feab295877b943f670cc04d052adeb960fcc53aaa87de84873a7d69f92a1c4af9c27c945bcaa6b34941900547d3851a7b0cb1848b839497dd3ef385cde739b54cf62d1ef33efbe814a192ef0cec13f163654e34682d93123bbe684bf881b3b9f380817743c2cc6027512662974a1c38df8a611cbdad5f11625832a151c7f363fd4344ac56587dd908f07830568b963f3a32c4a190ddb8c36f7afddd5e040dd2d14c854899ebee0d73fe8748f4ea28e141a7360fc54e0acc9ba1a71ae30d8e72fc15bbad455e809553a5f429e00bca17b5d61a4b75ec873c6f5ab54ef644773e627feba2fa0c269d5389995d69db6a981aff88b9387a644b9efb726ddd14dbd240152fddd5f7b2de5c04f2838a850ce7c1c1eec8079d1dc398dabe41493839635ac2b5e66d965fba2ca4b1c75251cc9f5196170b079060ead99e2712e252c5339c0e4be02d1d32fae7a502cddae066a37185afdfae273fc088844e0d480669876710fcf1307d80efd8beb5de8ea305ac6e75602a18b0fb9f35ed1b3a1b55f29f6f633b76a117a993b2f2a4ed36156dd4855075110177567dbc2bb12ebf8462361cf8f8271735e8c8fe442ba1a3d69b6958978f509ad6d6c3c46d0dd7412092e3fe928b6d1c3f1f6a8389753bcafd50d7aece7d18c3808943cb68c2f599c284da81d77244820d1181b3177e77ae9578842783e75ae44acfaf2e75589ae341f6dd8ba8efb6e316f95857b391be4ca43609a0b697714a4e7aa13ebcb517e24617056e702dada83967203fd8f60ca0034989f7d32e09411490dfff8ac5582ec1d41782eeee94a907fdd3c2f49bf5a77fd11a91177c2b70290bcd15f740959969a819d3c965f093aa61adc3fae86c6545fa82ae5b51bebb3ab3dadad8728694b616db491341969f0966019826f744a80b4993567a6210b704774149ff3f3907e23ce9eff39291cfffadf2bb508e8b34ed2da94545b9847a54c10571b53771a429c02b9c156ad27965b0ee38db4ca7eac624526e1e3ddd41f9fe0f71bf6f13ec04a1d19e0f2ec8b9122aef50723dc87a107dc6258a2c49921970cd45aa11663e788173b7ea209c67a4bd619ea25f153b321c1a0d13a3bdbbf5e0cc763e26e68e4ceffd6d33abfa43ea1f9e12abcd622964ed252d4543a0e10c820a884ca079d86290ce5e2f82e0016761f75a82f7af2067685a8481e595561cd85e1f00ca0d8a00473d633d72f6d38c69ef2ffa1d554a52fcfc69dc3e1c3d1a2f13a6fb4419ee12ece0c05c9db4d841ead769a6d1d6331b1757b7139ad092528790fab5b7b765ed0d5133e83634b8ee35a55bd749033a6ab3ec4cbf76b354ac95c0919564b5868c6e0344111fc3d41a395955af2890c0eb96985f0aa2802bd2a0c896aa135e50d221f1666d99a5de1046b811df9758b264b98fd639343865a37ed3c1f9594013b989b13f755905f4fde3567cdb4a9cd13c03ee6741d0a9f8b7e34e9fc341d103b3aeac55f0c5c4f24e7b03b8688fdeb01d5bb5dacc6e6cb68da48d2c39201714bdfc675a9240469d47f20dd6c315f770d618569eccd1c0df68de16021af9644689d34e476cbfc19942b99e5b7fa1004ea97e0d1da6fbc2fba2715f434a68ed6565b99c76eb181d6ec10682a26f757781e8994bacbd468cd4160804207c5b6a11c398a9dce4833b3f051d138fed049809f59e726c851e56d818f68f05dbe1b4a0830edb8c33c69add0c7125765f6031d32916ddcb39d959d68541b70315eb157772e451b35534e0909e6b31f9b0a4d61224a4e4884e92f25a140d1567a395c2e131b2b78d3e1c93da3552dd00526313f8740cdcad45010ba0fcea8c1aec57c7272904b80955e9c44354b6c78d770ac5d33ea5a905f95130794bc83434e45b8a945167fa7027730cfcf077c01956f5a23ef038c2edc582b153254356c8e19b785168819a6e5ad43e3daa593beb1b425402aa3af30b7d8d988ba90cd164d90c55e254552e0a17000619e1c3cb7e800a6db6d37267a945ba45d7df263e9b43f03286525a34f4e131157e72611151e7bb15b89e57a3b8dad6a1cfaec1b5a285db222ae8506f46d12341e1d8776262e7fff1f0b5b22a84e911ec930d60dbfe2f067c839708f4993a415f27dd0413cdbb7ba77df88bdff5b305fd2b51588d25a17fe26c059a93adb25099b87e03bd05911157e592c72b0a4bcfe0e66340a7343d5c77289a75bae1aac720916458c20c7e6e69ee3b26d86ad709e0684ad8d66906b00b1e1c25e2e4a1cab861a00cba74f2ba4bfc2a63b19ed7a4ee2a9a6257fab807efc10d5a4daee68f822489b87b405ee198d4a913dd74b2c641cfd2b1b686bf87994a298064c518ab966873f432682230db8cb6acae363ed37606c69d8cc052da52580c8b6b9f832458d3c9b10f4916f03be28ea9eb62d03dcbbb051fdfbf42e6e3fd524d99a1446178aa4bbbe98c05f31bc5dfe04da2bc58f0b1b150bde51ac33302076141b94b8815f3410e40486d1a229eda552b6b6a950b6c8512ba4c3fa1426b5dbe92edaf11b101efeb8c2037cb848d0c246b66f8a02dd93a039d369de723d6d33cd8da8ec9eaef71cfd3cebd9b50bfc639962848d329a1ce27b5c756e4ba7c82fa7eea6afe99c93414564c388d569098372e2b512754080836ae1c8713a618f9b027218e5c0abb61c54a608c09b5cb3bb60aa1a5f005e96c0da01bf3abc5abdcffb949f75b4299faa870d70808101c6d4ae8417589387cafcd6f1c093140459933a067e0a8bed8f64196b121c4c5b93a16abfcaac442d6186b708483d42edd27b8c1c6ab220dd64be72da1da9c48131016b3f467d2e66b83922fb2c7c716c3d854f02fd2e0233bdffe500fa4a66c6d9d09098f9b000a5a483462e9cb82dee99ac05291fd217819eb27824c4b0f21c94d3a614424eda239ba6e37211ba338c74495a982ec5f4151e19f62fff5bb5760361435e49b2801d7ff6153d285f473e92c3fc9fe9375973816b0c8be852f5d0352959353d882696d5efd42a32971955df7b5fb34f9692bc1325c7286a7a4135375ea6041206926b7e7c65e972c791f6378a9c52d47d36185a725f530b67d2fc35557ae27d278856008a3de232899b119ef55bae71d168773638b828158c450f65399ad68cc92491be4f4281bc42b3a964837b578d0600c9c68fc884966cd5cb6383011c9e20974786e7011baef4f6fb7f4002b454fd26d5c8ee08239acbbe327387208d9cd3508b80ee79fdf0a25754085830878b75b82af7c1931c4e0920fd824ecdc56a3518b76799aaf65ce875d04c129ca9437708c7690a686af3a9b4e97b72172a2dc94f97fab76d121a20356b6f59294221beca52a204c4b4c594b6481eada62d6819f399562d988d38b211c28f1b9ce0524f883d171bdce725fb4c2e45ca981d3bcced0fc3e78870ecfbece14e53c762c02db65d06700c98a71443914d23d318c79945c5f224dedc48a44c098c1c6bc3e374b165fa2e064ef0090fe38eafaa583b90f27f0e4c6c9dd02963740a98ec43824eb0d38e12a340e6bbd19ba8ca99d2b7128cd2240cf96057fd474f28e0e152b77cd674eee84630ff2b317676adab9ca410f6dea0e6ccab5804932a174146aefb692441ad72511a29ff69d0b57794c444c9d62873fbb2ad9117499b03e3da3b513d24ac6c08066517ae77ee5f12261df7621ade999b3def0c8cc2bef44d620c788e7c87157a1222912f1bbee447fb645863e4fd4f8031bcba2f2bf8870d3ee3135098def398169ae31c866d177e090b5f81a81bcd5c1a5396d70390f36832ae211ca60295d768d2fe66070ce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
