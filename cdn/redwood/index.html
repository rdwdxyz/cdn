<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"76aec4807150afd85dc73c6593b89c4494bfadf5eeeaa33399a221367870bc8c91f8c0fd3222de25c39a113111e73e344b770533813bb88a25f050906f00c754dec36b069aa3991c5bbca6fef0b3de0a9cb75813c71605dad087563c6fbc7d8d16ffa465fa1d18208034ce8794dff5083b91a7d7602a1b593c0f8197c7520f0ef2ed8091ddf1c1bdce5c2e17f2ea68b34f30c04dc802028fd56a214921c41effd7f68d3fa01570274cbd0ccff26a766dcf20b9df18425c9d4d642b564de4bd823ee3f9f18c46163f4fef4de1590162a66ed613780a04881332b6bc4db70cf9800942fbc631b8368369db4a15ce924f3fc409c617d27ac5b4fe543c219f026da5e857eaaaa66eedc3516be7282ab8e1e94ec7d8d4c28ba71605baaaa26edef95f7b4b52e3a4d33215a6d4cc315c45ab68b03c2681f261c939b21241206d85ea4744cb2a9238560c6c7056dcda95f7f7de487495906b714b2be6714863d73331e8c41315d2691882cf5a926474613e77bd2cdc4ccd4e77bda96b09364c088759c473397974a3f26d7e780e4cd9d360e477c7e75ee906c46481626345484828485e95f375dad006634f0aa747bde2dc45bada8a4154f8d6edfee4b2ecba10e3aaa92aad98760e95dc39d80033903396338acadfa7ac669beb10e47937b6886cb9e5ec38aa4b568f5d24dffe77665577715dd99b2e96c5553cab1ddd741cd0d23b3b4278f19f8e98d150d21696cb12b53ee120ef8640066cd4518eb18ca10b0f4569fe1c8a1208a4be376cb90d56171c0e451b5e064839a4aa4900a7e2c9da468f01c2f4773f721e2aad8d7013a31d647ee2ccb4d832e346fba0ff344ae19a00ae48a451249e04a9a158e9da1bda3ad99bedcd4d212d0c04f6dbf4ebf43d0a7c19e8245ed0cc086964ddf610df001c6380200f2a0f74f21d588ca7da0cf2681f36138fd42ed4c26f5ca8f5244fd360d9624dc97ec1a358155806fd327d01bca6448ba28d77a6d60825be629c46c1d07c64f6e0c49a87dac9bf92286fa5d7c33a29a45712b5e7c80f9b54277f45e6edb65f8ba65618f8959616edacebe8f65247f82b04a3cc27fd1ffe01309e3bcfd903c32a1d839998e6582d2b1f1540b93efbd3aa74973fe431170adb80a06e28884be4b928ef7b8f8941c6cafb2a9831492ab46987e6f70a881c02ede8e8d83e8c33e4cfd77404d36a4bb17603a933579cbd93fc196513fa9ac3346edb6f417c9ceaece90372be5d1db27aa0cf0538a44c1e3d440f6a5e27e6104c05d30e51346e88f38eb115bd0dca9dda9cfe4a9f8bcf866a38eb6afe73ef8212fd86b84dfd66e2ae13240e20e83ddaec4b80c64a9423282c031b897939d8339b34f29daf72078f771418b2f712ab570e18dcbc81c1b28d74306acaaa817382bb3d5d690a0b5ee702cedef6d4b1296eafdf375fbfc06aa9a05d3dbf21e718f1db1b2a5cc5679cdd73536b0ff42ce2ccf5a2316d28f4e05590750dffaedbb094c8761021b6d6f59170872c905755ab08776344340dc95def44ae14a76505f599cbb3424ddef1eaf949b6687e17c18af2480489d9cfbdb68edf83a5bfa60f48f52405926bd7e87e7a9f0c2c6df76fe24ced001559f2a9abfcca659a764b4a0759303185bcdb9acf36c48d4b33fb4df8147bae60dbf9300d82a188efd14c61334d2cb245d0515b7fb76530437e59b1bfd7dd1e57214bb95481901992cc9d54365aedca12bfa5d26221012bdde79ad128c8437655c56049107be575f9cf150196e2579094a1685cc22ed322e366e8b2c65b6476e3e07891f8f15fb078cd8e2727f049a438fbf1a5bd89436dd2ef81b538dcd30b5880353b35d33b0efb8201f5ad1dd998a1a49155860f3156e47c961684f6ba8b60ae3f5313c9268666bb680d2927c5fd7e804b62da5a88f4368c21e129fc59b5b165e0db5603947822dd2c2bbaa29a66d5ee2119631b3c11ae59039b0c9b22ca3eaecb9219e964d17d2bccd5ff4f0faeed267f736e9115fceeeaf9564a786f52113fef707c49dc730dab4f4a52c301ecb0301943d32ff574d219289ba8683a02f3ecebd09d31af8327453cdcf9397c8c9578d1e4201b20e1beb9d88aea5bbe754b0aa517512ca839ca072b58d94172f05d0f1505a81a31f6c96584701053512d7e0a7cbbcaab9696a19af4e82431123823629b0bcc0689eeac88254c5b81be86d7d97fb74adea46c05048a1d45fa1bd4984ac4f445831a94b1e788e98ee9aae8e032c5ad40d9a8094468c81d81aad508a1b720f2acf966ae6524a6309c3d09cd04be11c312d68553e06eb6a69faa67491cfd0e02c52b532a2605efde92a353d48b7479f244f2426fbbd4d2df0564037d1552e5ab9693f0d2c7e69bcf61843773718abe681b5747288c88cd8c07941c33bbbcee43e612d319c94d3305212fe9978b2303ecc202a270f79892cf0adec219cb51639193392e4a854b6cbf1f93129a54bf0ad0d9f307dece1dc6557bdfbbb42da05fdc44ed354d21da589434b5226e6aa3d2c99a2847cfd4042d5a418cda479c8ae902477b3a4051debc038aced74f5aa15beea730b4e320617f027a193afd77838b127815d64a95dd3de34044e1d08bbdf9648efc92d87fe0db20e00ae4518a7b480b51c34d634856ff67b91820015e70925673b13a4b1d2b5639c010cce348a241761beee8c528d461752f47dadbdcfdd08ce9559960ffdfef4f911406ecb6aa5bbcbeba8c5b51af8a8dd92820cd4c31326df9ca733bd574a408cb429869a69a657d700141a753cede7ccc5e726b0b7a91493ae9c0d6e312bf2f961cfe637566d95dd5235a922b50334bc456f692079040d5c87b8ba9d39f446eb07503450ce3216b5802ef328f5bca0f1e3ed5531b6eadecb5c3ab6f09ef693e4f0067310e539eb32fd508d54d5722badc061a5f69b0ec3fab2446c9b657df73798f875c86716f9d0497985ab9afe68f78dd24fbf83ad046a6cc01863c0eb2fa93f24ddfce1b959a9e45f0e1efd8b9e61f9d02388b256f3c0e84fad3410ec613d60c20fa44de7a01806b4790e1e830774ff4312be49f08240e4421033ce43b61f486c3b564f22dd2973603fca7f98bccd986307502726ba8039aff6eb18074a1c2bd3baa6b08ad2a750afdf0eba9a7a7c5e34eec4bbd5e81ceddb28fb5a38ef5ead999483b551968a82bbd5c391202b7454b050542c894e331a13f22822cb06d4ad188f9a347073f34d9a31cb729ce6eb55a5b98ebe88eeae04d17abb2593f285f0f02211ad5f4fbd70e01b64c2cd24881bbdecb8b7c5338808529818883e2cdaa08658e0c0bad04e94c598e571fa8e1025c0747ebeefc1543ff7c95c073448f4b9bac0811b557c268c439c842d330cd22265bfe9c635dd38796aedc05b54b8bb767374a5a7f7a2a3203d458ffed902c899b5b4f8325cac41c61988c9cde24aa217492dc449956dbc15834d643e94d8e892202ac87b988429bb9199359881aa8a5dddbb6bc4c6a92f1b987b2a6313a25701fdec77ba4831f07cf7b20faa1bd21a0e4a2a8b48f512e09c602fad071fdf0757cfede501d553d921591d5f106c8b7d410c911441a32fa004f11749e94cf72a18ddd24d3c078cf774a27782d2d297585bf402ed12f07406d71787228e5ba8ca608364bbab1c6b25950b930cd9ab2f7ab5cdf600a354bfebc683eb09a6ad62ea6bc57358b8f741e8070e3dcd02c411d614b9fc935d167ac6a5222a8c02370452c1c61aa05f8c60f73fee6b645c9b0c405a277b601d63957497b0790c7f1809fbf0b38f66c743a95e34a57afc804bd69f2f18d04ecd9161d2f3d5d4988a001668fa30aab3a9c5fdfa087335c6dc6ddfad40500cf2fc2bfd03d1f4f4fc2ff99f5494364d3ff6c27ab5471f198abdef01f0afb7999194c173f4ae355df214acf8d36413454c6294fac454b0ae7ae7c5f6f297c59d5468446d6b88ca4e6b35f828cd62d27df17cf526d5d7b10c944ffa8eb4dabc89aa15f66c5f68b0a3020925eff7420192f249cd305fe9dcebfcd2900f8111bd8d104bcd764f08a7d8e4c3c6c6cb0507395b5be7c8d1116f30df7bb182a4c23d530e24109346f7b87d38966a02437d3bbdba3adf15f323ad52f93fcfdd9a1bc27a147a068b47bf67652f51dbbefc680a6e982fd0220ab39e30d79f58cbb52565b9fa772cb24cefd16db2dd0f8d448259d7fefb24a313f8e270cf4868a46ba339403db007d8bede36344f54d312f298e391178030e79c7d28991f42550aaa17b3613be9433f3dd217f5549db2de3f45d8fe58415531588fa5b63e04d68e3d8eb98f8878422bbadf98d53633aea6dee9de8cae04f0cceb2153964543ecf27ad9e8be06bc0d4fdcce6be70b43b1d1fcc99cff605c3eb7c163a0857d8e2f1abf62c5f372430a4861a0ceac0ddba8e35b0ee80c4d232db0022f440d7c46b55c5f802d7e5fdbae2184593bedaf2696ddbd7b4e9e4984f55ad794dd22d79f550d3eccddeecc3b7a26e9bb735d801bf7433a046c9d981436ae4783765a7fae8e86bce1d34b96c1f89417c078ed18fa38947f19cf4f3afb5acb09d0fcf33fc29d05aa0eaa06562faa324bd3be2530e65adfb755859f23d4c321e8708dccfc0192481f4a15ee0508d2917f6be29415072331ad013809f56ad09682dc4773b94f71664a7d2af5a8d817111b291055d361878a468f9cdb6342802f7d89261ffb8249b767344d4abdf1bd76b67056f4a7dc537560024a74fa35d8347caf438a7da5e21f738b643450b5b9901b04bc05563de7977efc4e54d604137b6199d3c0a030f2ef2b1d6fc34ac3e89b895a8c0dd79f25aedab5fc5d1fb8d613cda762e9e14d0601d2467fc51d14a33094251086153f3949e29554f6e697d0a1e81e68afe335db259cbbd9038bd9df4ff16426694ec07b650faf21d1e7c5122fc3883c523661b04395c4309064d9bed6f8d3a4514c63e8f33d6adeefb1ff660e10453bfe7cea6cf1aa6f218dbf21de79344a635b78ad716096a0807f9f7e48bb1a00b4600e50438aa3fc054f91139f36eed13999cff843cb99ad2032c73636eb3717cd64c753ad0120b6c4f1dc0c16d96acb66dc54684269d285438e88dcc7e2296cf9b62b80a977ae62c2e9f1640de727b3183ff5af82c1e7df4a666f2dbf39b84ddb9736fde632fa5eddccaba9fbbc8286c9470b50d6cc2857eb38f793399131bdc84245fd693988991482588e7c8a186d479fc5f1dcf8aeca9b542bf3b02c332eac79df84a2455d2642458e705ccecd80f815f575de57e3f05aa860b31109c1f2b1545b293004b4e13aada3140661a840c103b0b806ff562b1f01af0cc078040e8e61801aac01f51ddbcdec4a5ea6740a9ceb0d875117abe5a65e3966e49ff5c4dafc01d8f6eef33a256ca793743db3b92230ea43212d43b9406104de7d860462c629d4d9ff213de33cea0fffcea067d2d73328eda58ecf2186a7f90fc88b799bb305376e7e71d74017d6d245c0aa6d5e8d87b0fbeea54c58bda4687ce24410002b7c6407340fbc19601b5f3e341b583a11357954edab584271bb6786bc415877c64bb4e3ff648a4ddf3c53a281e30eafc42f722e3b3b5debb7b03a35745a6078494da354c30adec9b46dd518d04ae08166626947ce1736dc26b1ffb35cc344ef89f16994a720ce11245c92311717280f7686485996a5a7e2821e24a27c730429c200cc59539f8317636df059e0ccdfe89d390b667051f46a605ca480b692104ae23fc1fda708e2c3daf4581eececd16ac9c18189bd35be8108da93df822a380c9c59e3b42bb7ed664130eb80bb0ed8c52114e21ab426304a654c5c43e8d0d59076978f12edd7e738bccbbf854b08d6e8c4c349298cb1ebc9224e87d9865630a5fc5368eb56c0d2d190e4abb678c289ebfa4230b74329617a8ce8d960e09699debd1ce03aadb13f99fe4c157f15a7cf7c62b0596a838e44612228369edd93e0360b7a8f60981bc2f6feac6f597daafe68685b9ffea945931fbecb1ea89b35af92780a0104e6ebed6ae8dfb00b171050dc86fbf3439c71ab61f311187b061da06dcb81c794b2dfede91f9f7608bc38b714e710011403e842286c0557e38c3a770f8eba959f7151612bfbdfa5b6e3e700f4785122e39fda41ccf37ca2af3a069d3357ef969d90c7d0009fad8f8b08a93891a613860e027f686abd6397c147db61abb442d989fd84ce63b7d699ec0481ab598c73bd1df7bf3a9c044b3926e9552f1d1cb5a0abfe519dfeba16eba61bd81635de600fcc766892948ad5db79bc8b8612d862d927200a161086a349bcb514ebf611df4b87b6718094c67c01fb10c7a5bfec6d519a7636edfbd5314ee13f99801186bcf94ed21ad6d471f77728f1523b926928c8ecd37f2a5426c28508f57295324f8ee0d028b556e71c38fd73f6d3024b1ccfe1cd5e6c22835e922a34bd3443c3476524a95ea04ed3cbd851d8397e6a046506f578f545734215058045af2d545cff9520b348b0376be71af699daca64e14f65ce69f579d6a337632736511c081cd7e464f63c429e161008f3c0caad429b3374f9f7f94a9bd75d1e4abf5266f19636cf45916bd3f0e1e1c3ee3f2a6e81e9c4cbe387741f45ef52dc2eefab1116084037b136189ff8648d503e49981e8aab70abd6f7cac2e5aa1276f7803abf94420fd0e1ad65bc138b66e9a74e0ebce038c4d9d93ec1081c69fa3dfff9131166a2cb2bddb616e4641b94d1817b1f82defeef2715cb213ad15fad90bd0fe12d3d910f0850858dd4329d32115efa612aa8470ffdf1b25df33dbce3892c8a0cefc4d32fd25ca2982311284981696dd6e8ec9364bd9d49397267867eb7f3fe661a5a68ae4e43e5aa01e3c65b693259ac089b795a362b54e9d1ba24bdba6317970ef05187dee8bae1a076588e405f498598a14371892b447552179379786302979e4904577e456ebdee14f805b7c7e61043ef9ef22a74923077f244157a39ae7ca2040915119a1a478babf002862c10865b809dbd856239a21e8d5ff5c5725d5477f7c256b2bc6f2d04beb030d4f33a87c5e9c81efe58c37e840d63dbda02b968210ff754a996f10028b4638584f8fd7b8d7a071c9626f59223d8fdccd03aa940ab7d5fd940ec683aa827bbc8e8be69e132b1b2620e859bb0d53b80db6d9ac02a4b49a1a4971e02a9accf367afe082026d4fbcb8e5f3f06e074b57edaa986f455a882f92b965ecba9284506c371b08eb4aaafa4d112566b606a11171452243079d680931fd191eef417053c63d7ce3a7f411655af6b42754e45c68b5088ac71036a0cfe13640fc7aaacc56693d6c46abeade345023f651fac1098dfbd2e575ddcf95a524aec794522b247f592f67e8afac1bc8b9c805a8ec0bc28573eed77d8835eafb4df7be0c68ed37b592100b629d9a3e17c376a2ae123d6bd75877410a32fb7b17283697e9bea5fc0075806c7462bffee0a433bd6c2efa5a5387f18f726d3c7ec7d024932fd8054cea3a0dd328d26c050f545fc88553879c7a9907b2e4e75a8750594576748daf3a9da6f0959da96952cd7fd272745ad870b0c4fc40ef77ab740e2b5db0ac180c96e8ee2210c24ceb9e1bef2b8a9fc6c27db56331b2a05b8a8e953ea1b90ab476f6820b06d09372032eebd9c0ea4a6810c9d11a311bd32dc4fcf6501dbdf17407571ea35649b4287c2125496afddc5a3da8106c3d77bba2f1816bcc028cdfb24aa175c5a4cb31582dcfbd8a45543a26156bfb4c5fbef2a0410e283a9cbf16a47bbaaa9ea8a96c6b2fa4dbd7167ebc740055610c5ac5b0abf60d6f601a6e0427149ae5908355904387ae302f658d466f764789cf5439981b687212c05a39fa346e893ff16add4873dcb7e41d8d1d20580aeda1ce2ce538c443df06c02628d6ef9b56bf89920cb57371d509f09bb4d4fb4ab2d2571d9fe40c966d8cceaac19f663d384962669be318f232bd440f4e03940f842cf5658e8c79f2464ae0a5fc776f4032ecbfb82910a9cc370da2faaf4740d90b49dd481e3c6d00bf09f4714637b6ef129821c770d0f918498a61fdc57b26307e6a1d833205346418f6c9ebb1d7eb0a52eb39043c1e639dd8234454da8c6d68630551b5b3a611543f8f2e6f703abad1817a00144c0f627b61def859831e5a89c84b9666dd1e65e1a39374a447973521abf1ec66de8b77c88f2296e9b7e02c8c85678a114ce1a322cd814b4ef4f78d07d217326818345acc8645785c316fb86c6977d89ebd2269c2d698a22a661265bac55a7a58f5964bb054446f47c33abe7bedf427c7ce56d315e1054c30cc6267f49e2238affaa10026f2f561a9147a0ce46be64ff010d8866bab2bb252a9013969aa648d676cbf6207cdf1f31236d8d1fc73c4a87a162e6e87885deccf90203725841a6dfde87478e768c6ae36313f4c61bc41fb1e37c6564d6d279f17f3d9033a4f49e87ccfd670258b42176d329046f9bf413eeee793609ea573cc50fd8e53d76e0f23dad136a6812e9daed3194ce694384d11246ab4088e4e5cdf7e6dc85a736749cce73185184db4c6216d45f397ae6bca7ab29e7e9ce4e6f8c509553d832408408d6586c8b017ba92d2b0bed9c6487dcce40265b5db6940a7ae96d7ed58aaac47e460748b9fede35e65d173d6eb628107c84f98cd27b08d86546b1c4fd558c39ec55492408b2e9cb2dcbd869c13358e958a5c89d6ea4efca845405c637b15f8a616557bffba9c5252310be1adb668ff548dd9323f333922d2b0254c7db10a14de2636c379ffcdf5106aeff0b731fd14742c89fbe50768836e099587e253b3a8d3fddd2425a230f8703fd77c5974e083ef14726f5f9f1e35ee8815b781b176dea97ba9dd964e1bd153cdba86186ef3f1d67df03a09956d106587174b9a4b2ee44d803776e7094335698fd826542e247372640dba8171e5a8f52357fb890f3d86ec6a3fe6b9cd26e66d3c7eaeffa658c8ebc4af807eb76d451b8ee9363aed6216d21ced9e17dee611e1e77a897230f466125727e1f7b912be52570ceb6ab1693d3a3a9321e43a2acd6dfd7b96efe61e8c53337961d3183e8ed5495559192d791e0a98e031836ca34015255a01a5f8165466e6858791839e9b5be35822e96889432f5223b09b21228dc6091fec603f6f3f09800fd142d1bc59f0c0368bec8b30ab7f1d0634d5260b0066274342d1449492dc0798ef17be1487facad7584ce9db40c5f25b209712f54337c7f818de38df80ca22cf63a39a7617bfe31739cff9ca192908d761e34109110855e4d29d7977481e70148a0f4a06b6f5a3b48989bc39715d26b588203f78cfeec52b359cfa12d2b7524c8dba71bbef39003ae9ec681ab1db32361654024d034be53c0e6520c4bcca50db2cbadef1643214c2225ae4d59c1866c78468391f923b4f7bcd13708736cb4fa622f4de955c1a08e162e63731687388a7efc51eff2c81f665e5f5e786bb1b3aeb80636ac0c11dd4fa6c3b968873b56f35baff428d0ac872675b94e3a300293727604352c85440af4bcf3eb009e4b48cc8270a53784588a651d11cc0e8641dd82ac7da7fc928c4b63792a6497607884dc2b4abbd71a3e50dd818e6bd846fab3f6676fa63afd0476df4c68de002c73f134e74e43ad69bfec5a2559b16985aa3e51340b7561cc23060303e525d324507bc8732bf1c87652650e2963d846a1a94dcb9958a041adf37c9386ffef23a9914038a62e4c34f4caacc7a762cc5e259772b24971b3857968f43caf9830afbd9a9578a1e92df894d02d9dc975edb971889facda04958d490fe43520b89e3bf645ceb0084266ad7baa1c954c261adb1313fd9b18604332487a83b49f917f2c7ada72471e55e45bf42da1576b40513f23ef0cca74db1316068e2804a45f21e3d9bc25d750cab4e0b71987200f5f5613b4cead15c8b33e2c3607c06dda09ad34106558b73c02b141bacd7970fcc619cf471f9465d858773e8a65cec437c9fccefec3afcd1ca84ba1f328e0df8d8bce2421a5e1a58cb06b75758a56674824e431ad9289de427b8a1ad12c2b234caea3cc98d4267d91c211d9ec8dd9ad5481b74ff113fe7ac589c1cbd37a391f3b37c54601dbf78e0e768e6f75f776715556d2daf8ff575daa7e522b55ce261c8bb29a59caec60ff1cf98f0f03f13cab9505d9a39da9e29acb62c055d93d8bd03b1792a88e33595164c2b8ad24bb6ae95c6cede445f9a21cf5032686743215b3f940c3422003fde7b1c0acad8406d1b0204f9f6e69fc03db983a22a1e10399b1923941af8e128abf379c499bd09109eff4840f90d48c3b954848f8142b4ba915838b1be70556afb1907ae28136328c547ea0b6967b1bd521ded818111faf48ea162084cc2a55ba6884d1ae4079aba01a1d5c54424bfb23a771fd7d34ca8da84d2283868983dc0ef51f717256efdb3d1d545bed18b1bc2842b4eaf79a3120bb009c5e8a999b4652f05db02d4a8127c4580ffd18ba5cef1b8204f75a0fd71f9d87a0f35511e07aae3b66232bb8add3c550373f6a577c993181d35efe32736139a7febe57eec4dd46a45557adf0d44b3df79a41127760ef9fa4ed29758f786747ea925a07e0c988a56c0a2be2c81767a72f1de836a04b3b52b16816391d4eed32ad8b5ab6f09a050747324d224ec94217de757b54a45af67b568e9f2dc467e9839243da531a10eec36789fc4b6fd148485a9e671391c53840a13b5b7bf0e4e1b1b455eb572074c5ecb4d50561dbb46f2853991ea21bf402ef5acbd05ad65c2ff61d019f4445ab0dab1ab25833ccb2bfd83eb2042b45ffcab3e2b0f2116dc7cbe7a459096a9f9762aec2db9d371f564d262693a286d39f1d325281fd39d0e3002e22d3e6808906beb2489ac2f2c75b981593f7157caa66cf056a19255fd77c573b1d01789f083a2fe7712a2c10568886b2232f2b07b755d3ad3352c8cbdf88f911db0ddf01bda2c750921b2593c401914b8e1b9c4ecb122defc7a823534fd74989c0c0f89e81e7bb08fc4a64bc3223689ff44861a360066275fccfa30ef016545220276da42371ba2936453d04aea1f0363e70066fffb224ff3a58b5c2095b7ce4cb2a33da3234361592c3076a6eba6beb80d863b863d033b458c754c88591024171c337b67b64bb3480a2f73f9fbdcf7ad28ad74b2c318641ab8a0aff61c7c02e8053146a75590eb802aca8e4aaf7f5175f51a4180d52f2d90bbd92c50dfd44578c4f2e4a4c8fbe7ae38bf6ed87133ad1b357694bc5764858253102758b5c40db5fe3caff8bc46be932e8de159a98a57ae8f6f27212cad8871d951d7931882bc9415e266833edd818a7632738ddf78415bffa718ea85e00fa36416f54e33dbe49dc2ef825940c63c1100f09219d79cf2039bf0a7877ab7e0df7af818d1c2123a817cf5a8a02ff71a2b20a5421bdc11a7dba145d50e0ea8d3c587bf7f7eebe09d77a03b23d3710a049e1a41013cb95b28e3ff028da83497cccb5434a8f4cfaec55adf11baf5fb937425acf6b1892c74be167b3793a9b8dcf4b05e637f4990c238b0668dc24a16071082b4c1525cf9f8f59c597047a7c3426efd20bffb32df6d1a911fb5a10cd7eef2849e1088017f6b5ece9c0d9fb78204db77a89652ec8ffc2d295a685f25cf64219da9460106cabf5d9296cddeaf5b628f57f78eebbb6343712689f59da2c1d01f6f2a8592c4ca05c580d52044492df9b2ac3e80a6160ea8cbcc6c12ad1f325f8a7f6e08e63af70ca4f8f220cd59973821ae7ad61d20f4de7cfec1e769c2868f00f9292124d07c0ac75f774c5893404183c68fe19a481a04d02f227ad22ac8a9edebf77a9696fa036bd5ce669b0375bc7e18470ab8a7846b24269eb09b11de9ef78486f20f77595c16bd7d871f2a697e06a50c53a0f525f3be933f4826326af3ab6cd3e2128f38dceddc693b31d17b9fc307b3230d2607f24da4a3771a34483aeea27f1689a40598f2fb957ad7ba47a0e128125501d3732cdacb8e34cab277376077f3c5be1830bfb1686cab209be49228241d49bbf3fcaab78247efed5f3f5504e92a865317c837866a0e6a0fcd9f72b9c8ba2c4ce1da1a863c4632c8af102e8b5a08d845436df9255b0cbadc51dab137770146cac5c6be36eab87cadc1fc22fbe8746182ed0e0055e712b558865db7a73cbc4994b8ad151f95957d66c329da4d6ea5b4f9fce6ae3184d53c1cb313519e7489db65b7e507cf46ea9cb277e5f2acdbcfd056d8b12dbf2b9bd487de263b5ccc7580d4f33f3e37b5d34ddc686d0e00e0e8885f35dbbc9f624364355fc8ec258b35a1bede7a3b911b3d37be64ce823f990a785836631e6c9b4d20580df8768894034cad5fde2fd117b81eb7aff70324b38454df8a1a94b881444f2359d74c3067da550894729dfe5f7670a4157812d3fa136ecb4a199b23a2e9c11371d5181fafae3348cf0ca34e95118e9efa47dbc8b2cb633e6160d1efcae8ec6bef9052deb5d8d5f05735cc379303e8b067eb88f5be80a3e34f36d419f0a6ff059c62e30bd18475c71318b148e158670db3de3c04c62dfa2b28dba9fe418110d3b25272141414f6c6c755094e6f599070e74733113a2b2d8b3653104769aca66ead5c9ba058853a04a95bb19741494eac5933900ccf66cdbda84897e18e34b65599e1d98e6635be444be99d24a3044be77431a8084cac1a296853a8fa9a3d9f360e76a66740736a78ac7d7585314937267e88e7273e93e7438ac9988de6f8dce3cfca03dd3beddc3fb94b5343470685fe9d7dbccbeb756fcabf3cd02f2ae4b99b15a8983f78b83a0d46d348d03a7a6071ec3b1476c84c0dd83689d6b9bec56a8788a9119c081d0042130a86f95efe05f9a9a746d3efdbb8971318fa4bebd769864a5c5d61077b1bae6d7327cd99534e9c88033cd8b501764072e14cc14e0ef421f954132ec312ee0e030ccdf7cd6cda9188ffd515d640728411161f8c08ce481e58f96b68a73a4fcd6da4b55a9ee630b9203ccf4d0c8238d056864193829ac9c7c14770a83de29f65d81e7911328e4eab90df45b7aab469d21cbecb5856c02a8daaa33bc36ead530de74969b9799bad78dfe7e177bd86b48cd86f55786079d00731ec1c4db37ff6f24f448d04bdd843d7d0393a0ae8f200e08f8a586fa98921f6adc89b1075242fd0826aa672ca510acfe66a4d4153eba2bb4212c549d4e00b1c6755cd0a9e37d12dc5f8629e72cded14238d679f6170a68d856c9390aa7c5699c2956c91cc1b170d69a7496832f09a414098d8e406bd0277097fad4ae1fd85d399884d32bf52859a492a24f3cb721ed56080f72f81929bb5ba4f120c51cd655372c58ed9b15cd6b693cb7bace304bb1e9e511f82fdf6edefbe4941a0406da538f40a8b0f344f8c939532177dd0f8518b7298a4ef9b21de58aad4391c12c4dd03b19e0eb450c4524e379e0703d7c42b7c769dbeeabd236f956fdfb22c7647e59895cca1da1190c71e8c96aa9522cd57d1bd33654f5fc111a25f014f78ac917212933917eefa4f3f584402eaa673f6f41f5ba26eb693972e1e058d4aa01f5d06286a0082b57f5bbcb35e446bc30090a787327c54a5e6a6959ffe89a312a80a25283d01efadf42391bb9c0c25b2d4eba00d8628c53fdba23d537787c11ab94045db3d3247d27467cd9a9c4e00915b36a2e4a9f4c8d2bbdb0444bf0a470ca012ba4376f325909db6a18dd6705db9316f3000eaad10d38b1d004ec4c921f71f1d6aebe86a2cac3c6770fe52c1a9cefc7970f598b14dcdbdb0c52962990a09174804d4723e5aa44421a9e9f4c9eb1d9ab769cae4b48460e5a8c293b091bd9231259df49fb87a53b2687ce13ddb77be35bf47ce8af21fdce6827a8456b0bbbcaf21280d4b91020f5f7afb5ab76285a228568670b8abd6740ff1c8fba990f8490da3b7bf4ea2c1df6714aa2b3d29e864520e0ae84dce3c38ca59c21b22726f781f8e9f9cd142cb31928d35bbe3d21512f9ac4ef07e80f9c03f12b500d81aebcd38a0a73800d3838da492d6cb92344b2627c2a5e6521b1f131fe5cdfa3b15305be0b95000e01dc88ab64334d6193a26c7aaa636a5774d17334502e203a074a399001d6994116f26bf1c83bfbf8bfec83c83c3b4b31aa1bd4199ec19e07bf3256723f749b51458814c2a86ec930372504012af5787a9df96e1df16fd7115e1378b45d773c54ea0af0a9dfbe233ca7f647d1ccb27258cb902e45da1366a2044cc5020c76c360a43a6dab0e664f3591d92a0a2d4a4af7622965c874f22b419cc5650ac53fc17ea1354403129d2cba5fc55bdbea1354ac4eab15a7baf0ca8c6c8b7bbd0b247903963e83c6cf4dc5ef227333d0ae27b0d790afd7e1ccb4f67ace83526505c026d2527eba8200ef35e9395cc8ce95b18e9e99ee01e38cf74edf4b19411fa939837b1134e9e804529cd8e47e61a03926ab6e81d11b1b66b65f11f6a0f5bdcf069a979876b1fdbb7794a641265ad34c57ebd4a3957d25f1fc81ff7ad75717b0163f388fd3c9c86518201e087e29781a2bc82a22bf8c76eb027051d8d227ae570c562e935f8c35393e79fa3ce1252ae7a6dff69d437e4d3f4d5f9cf51652134f8874c8379e7a5542b540553645ebadef59a5558a44d472aeb0dc9d5f65ce997225a6be86028b542db1d460378a7245ec3e99ca724fd920a8e40f2057dd0ce471b19b4b52107b276c45bf436ce7df9bf0959369ab2305e37e91962ed59245840b72bd3cdb9a267286546bb0cf76c58cc7392c23be62416f064f0142201e1dccd43f13b2255db777abb393aa15c42ab083ee902575f3579745da1d76ef4cc22b1e3d9ee9c419afa5836bcba471727d2ee06dff70ae6f7e4ef3e719630183d1bfada2462debd69118997d1e7bbaa815a276a941531f409e88ee7d95d6b91cab20c7f773b935d0c6ecc9ba3499f34fd14a54c28bfbc773b090e0b9171fefb66fd19963a3a55cc609ce376a4204c430c5096738570cf65148f07d7c07e42c794e088bdc5d91bc25e85be8cae300bb6c3884450cbabb045490740189c0686c160ab11f9af01f96804beb60cfbb84619f5d11ced491260c47323318b9f614b97e08de0e59ad910b3dd86156f1dd093bc466491e87d5974d58af91fff083a21453e0d4387e7178af44550fe31f6328ab5c34f733e614feee78ed4834f862fa0f59366dd40c01aa5867b4b4d121edf7a6cc1c131208c2492f77301c106f4579e47a433a2f8beff149164386ee1dca8dc74a41bdd82cbe6120509c05d7ca7447768ff9c8c785a46b8a4acc45244a19fd74cd0378cb42bb054d6f328d3cf8cf15488f20164b3b72a13337e6b61206f59b7fd6222d96a079e06e8a78e1fa00eec955acea567e7988c8cb3c2a8e30d0d703bebcaac7bc5c7b377327af5bef3cff79ab45a4c3f6c811aae7d77aa5ca4bf5e90de0f0070376c3520102647fbfba7c92bb636ed64bf7f801a2df8448b4008fbf69c7e712ee5c535382fea8e78ca37557e7aa814c31f58327cc5b596fb8161f31c74cbfbd0a378317676c786f947cc3b6bdfbbfc17a56a5ba4b3da51e7e5722e770ca21a7ebe99dd145af2ece6ee82f6afbac3f7323dde5bcf4cfab59982b8189f1c3ed65797e36d8615a3226923a5fe04ccf15db7793c97b9f881f8d93c5ca7e36ff1551f0657d5ee150835be7a318a5d435813ecdb310ebe6f76f701d4b0dc678295f59776bef0897e75fdc0d34422269756a2d791a26d29b46e9319e9047d50fc15d56ee2dd53e270d5d14423630878914b3c6112551dfdea4b7d388a143ccd9c91bc21ec12bf418d8f3eefb4c47114824c12107378916b3d61380e7257ff3864c76c6a45458b2f88a6e21531cb3f3b6fae68db084393cd87e810b652898a20f6f234084ac08f285946d2a0d25bb25254905e1280c5f16ea04429c0f5063452b1d89fab84d1d8f461fbfc77d018dc85bc3baa7d68ed952865e76ab691dd9652ddd7d2d4e02063c2b63558e35cdee4d7b7b8823dc8e6dccc3f1ff5af7f4b2bc174797572e4dfd38a734811cc185185f4e50bd10c6513f0936e8e547a57dc08251c00a05d99a56bcc0dbaf0202af9dafd8f18e38b231a1bf5be4e7ceb3c4bdd22894b542d6e04ac55e91bb7c5228ea1dba28d2169642a0ca6ae2ae204a16f13390c0b943eb5b66dcb1e17141c4b91715af286eaaaa8764865e9c5f61bcb7ad5b376b6415f732c27910b7c499aa2969b335c0872aba9061a5906772ec37fb64ccd03f0359c8ffcd684b862b098493bc20f7aa62be8c83c5a330c51bb8d86ad7c9c3af7509ce25de47a3def358c27554d1d220187c2fd7434dd79d7a83da3b2ce8debce9a799892318b887d55bcb105350d4b8d94362b86457369d9d1e475a283344fb53fa395f67bebe6c7869dedce36ae4088ed16fa696596613f7f54e0c95f5d275c6207c361379d9573a75f19eb0d0114e0f93fe9a8b96ef00cebee2db7070aa8ff0849354bbef222deb2830ef0b73783e783bb4010c293436fbdc2e5de00bed42be00327f2cf2b13f6dcb867ad18c451517301b80534ed8b40ffa86bfa648b30d3148bb977ca2058ca33bea4cfad9a3d6f59db0ae3b81c1b664bd51f3ad919f5864ff52eadbdbda91a034047419e083496fdd54f3dc45756b493c96106d6d2790b360285afe22e0b752daacc68cc64c2be78dfabcfed3f2e488e4cc51953f4e48603b86bc75edda3e82217bfa1038c403f39b77b3e859affbb454ded602706790103674c43d4f67c54172e9549cd25a6f5dab29f253642e51ed8d5ee7aa03c6202caa00e0471107ce2dcaab4ee874b4b9114cad7c2d0f70b7502e1d8e928abb659e6943d0caa66cd158b358aa74d37b152edd253218390e646d4519204e9ef04430c0a40216b894701c0e0f9fb5304affa63758b84ae8c6003ad346dde330b4c537d6c5d40bc831c043eec89a22fd5ab49a8ecb20b1b8ccecf7f8e3777955a581cc283e4486693ad69e0af304ea0394b5dfcdef4eace43e2f96794b23bc586e1751658ae08c472b164f4a7c8cde688608ddec22a76917f76fb747f64bceb02476b0d9f0887e06e2c0864cd75e156230a4c0a26a1651aabf0bb20abbfd8ef1607353a2e4d3844967af917c01274e2003080027db56f52f798cc05323bed760b47c983bab76feaf47e5519ea462b63ad3d4221281b6a7f4dcf713e6c050885074ddb4c687efba69fed38d1966e2b981039b247cbc171e2abe30ed6625fd9e3b12756c5481a76eab78a277f8a22ad3e1e787a1ba88b22b6e1ce12336f7db509d1d0fa22804aaa151342542cf4dd40b95c5d434202416d1610b8450e27074f78fc337ebbfc4fcd8677773b345cb5abcd6b73e8abf0f8330c2d4141eca67e818d7d367b33ac958b530dbbcd7c20f700b6c94214efc960257a4d08cf2d2bc987572c7c9185cf607e8a4d9bed6ad6918e5b92d7bc6cabf165d9755ee17f3f2b4dd1a679de2554c410bc27620e813cabe614c82b5ae5f1a61a119e9128dbb3b44147837812cfff5f034a2f2c38a97424500617fd3068f79e9223b4ab0de247a20d949fbc7cd9fb71bf1aad5179e20e7be37a848a918cac58fe466cdfbd8f4c2be7692ef078348ab6caa6305b2f21e688f82e1b5afb7dcba6231040734e8097f945dc6030b2d3ce0535ccdbabac5a7296c5cbb8e395830113b105892d285de4ecffc282d70b2d58481aa904cbcc4beb65ce89aad9d9d83e8213afc3e1acee73925b3dc80a7b10aced0f508ab1d668a67c234e45485e967bce6ffb5d25c8261be89f61d3e68f9d7b0eed4710f819d808fbc9762e30645ed9b3b54cbdd76ac85c8754ecc7815bd6186230c1ffb583a108ee3ed02c5f5c12c498694a56e34df9f0dd270dc00374cc89f07284981b212d272de7e9d30d401b811740792ce72de916f77bf1b4abe0c00cb43adb085a9a64adb55334bf1bb102f87e6b7c3e5bf067f25c3efc5bd4ab9b77703d4798945e0ada99f5cc132258182c8b9c99e778d217acdd5ac29f8e83e02eac5d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
