<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bfceeded0ca44d1b2457c4377639230af111c6b3636078f6cdaf67a8752e465ff85de48416d3913e66077f3838a58f9b37b510de605595330221a659629de09d567c716fa2a6f51d25e39c324f051a0de7db798eb25e3a3ea28d1a31f2ba5be700f5b3a25338784f83df3620eae6b3adaa6b393430390eec8f77def76fcacaea2a979d1cc7d6ba110fb39a693bf5c2e4b4931cd10cdedee42326039680a870990e7e791c77fbf736ccfeef261a176ad9413ac25648ab951e05a4ca9d8a96d77965494f4e3c153aefe6c1cac24bca4193d4183703eaf70bbe84e6727d5ffb18a42ad3fd1440c023305f535ff9bda3efb5b7c19682112ceeff91c8c2d2c18de6150264bb0f374ae05fa91486e8d0940256c7a9ec10c358b207717c40164d0e289c11126c785448a99a77010e6d4783e1f3b56d04f7e989bd1b325c1a2481368a036ba64ef88f7a360c6a3ec29dedbbeebc67e4ffbd38adabbffaf89e60ccdcbb7b923ee220b3ffa6110b020e11b63aae5f526189feb461c2746abcbcf5423bf49d54214e3c2735add8abd36c13ae157ad0b05f285069ec4affc02bfeb7b65813b1157302b67820b9b6490850a89a4201b936d6afb4435601ead636424b1ae5512f74840ec9256a91e52370b6b155d20644261eb50e734413982c733f784344021d545a1d74dc9b930eb7e5252210cfa25278ebeb95683641f50b384fd54cc4f278d1b1b5158d7760cbb5e690a3023a3c1a8c92410a0a2e7636f1eccf2b756dc70cd48000790223aff98f20b2f8667c327eb605d2b7ea2049f85768b8233e38c9cde3641fee7fdf95fde3bd0bff8be54ff86f5f4e4368c87e5aa12d793626c9a7ed9747728153b95e10234d827425129fc06d6d616c81c855cb1bd9f801b1029cb6c8a2395cf83695a378eff93c5ac022a19514ad35e10420e21136661c862f739a55fd03c5c7ef46412a1263646d2600a3dcf652681f32d5f029c2f3d814a384ead142628626d1a97d2547d1842958ab53e71f5b4cf2fca7aa598d4edd0fc84fef2eceffc71f0bcae17c2009221689e909c05784109ec479887b338629be1803a7ba82132b479de1133c4d60bf37e19edd3a540d20a7dc8370b6a6505ab783fcdaeef2c413953e4441690638a16ec52dfb8a52721d5f9d30ec826af04b5685983ee10784d4537385f00d369f06d3344f9d08e525cdaba6bb84921dc9f64bf27ea63174d02de8e502541cf6d1add2abaf9597e2b86dc077c506db38221b6e555f77964f48946944197f6e242af7faf31587c0e938c0abf487a7828f47b16f536a880ca0c04b5f8d063f9afdde1ffb1aa1e089db78c31fcc8d744ee099f07530603f4b141140cc0eac8b8d93dec3f7cf478edcc00f2ac2bbb6b5071b3581e2f2b1f47fa16eff637eb956fbcc6568319a6df8d1c3e0c8f2a5c90896bda89d34ea80acb2498a54d66d5e1d4f45088606b28a50abf7015966320c7694ce0d8ce557a0182c778e8c120244f6e71ee9e8d3163558ee7c684b0a857be8dec75700c09ca2bc3f519856bf3ec30e9f0be0dc28d53596caf39f7c36cceb2a9ead0ba4de7cee4d355b212cc9a05e708cf7a96f4ab29dbdad9f6128ad20d7a977d35812f869739423509011a1c978438558a68ec375beb758bcade066d024933f8c812f2b62ee2df6d937c1558b51a740b7e319f6b5bc28d76033e38fab3a1a32e34e610907c1f3a06e445c220f6fc05c226f901aa9f9c6c1c0452f862e48a7452b41c4ef3d0994cfda0621adbcb83d7b4fc6bf4988c01888085469ea70a81026279c1e41d5d13959e71eb02e4c7e95a00d9b1264b427806b6f813a6c53a163a7621ef448cabad959558f7f7f301354468572afacb81096a666857b65de1a4deae06d200624c18aa91aac7ecdd5a9a0fc7c6abc524ccfeeea51a710b17c3251ae88f96eb5bd10bbc16915dbf8a2fc16437b2bee583e25d6caaaa2759ef36b0cf7a091426096ed7e691d4a2cda2b57470e6aae5942ece7cf3f943a5453ef17f63f1ebe7a312ce29414fcc3db8cc43997c47941d5347115ffe06a9a7bd7d092752414a9a272ee7eb7dd6d00d5665ef65f8a136a1f972b3a8fdeff103d9280533ef82e0146f5837a7c7dca4b7711519b157f4b3f4efef8205e819afb737dec53cbee27cf3489dad822324552b10b969a4dfefff6e6fb60b23603c5dcbaeb5a3e8f296baa89edd178cfc1a46e0061dc6c36d1f1b96b95bd9a95bb59ad2b5f29e3a2521f6eb143ae17003291a9ba81a2e0f3c8e5aca76ac39065a490d14c23526617684aa68f4f4316a93d30e2c4775f87230488dda1ddb69cf2450410b236d277faba8980d496ccfeb1d17d9d25c6631a99b91db072fdd92e22a1d25c0eb115f866c0b13e2b7bf52e48464b06439f9e1eaba20e6581c323aff6b1a1ad932bcfd1a5b2454e80d16fcf578dd9fae9a4d8c6bd3cea92b223f5d081288f269670de188d29d30a58622d7aa0dc0c679e90741db24ae3359abbe699b0c6484fd3d202e0b9d65e09bea7014f6d395079e8928441451f7e028ce295b27fe3a0edd3eaad27e384b3deb0497810b2e2e9458e26b9a86b0ef00cf6800eb399967e5cb2a1b6358e01658e16ca56c08dda7ee769e3ab784046dde7077ba621f31e8e4ec6ca2d2501bd674bcb834c5c0ce221b039f0b37c0963b0f8a50e70b70bfaf63ec1b16b42d7b1ab3c03e924ed5aca61d8310beb6c4ee73db4e62181a5db010ed3c8ebbad2cd9f3294e659ee9a730ada385d80b2f6575cf459ce3d45bc7ccba723d17b96acab4ca98b68b001a706fbdf9f508acf8b5cee74484a91d62f2d2a3b27fe7934db250ee55b024ee68859114db3fb94c51dbddc9201ce234d1253caa53098fe046c59e933992c13781386b07b9b210e7ed4f8b4dbb679fc03203ce91fcf2a1aaebadf3b281b5cd50d3c66f884d0f26c50c2a31c74d373b303d0e7a83f110c40a0a05ab2c490ebe577cde88c78ee1d05775deed06ee2263e611a2e6851c51e77cc9b2a57687471c3949e46c04c56a4f1ec4dfaa1017b34b947d6028ddcde203c0c72234c631bda0cdf97c01494f8c95bc31d0f4d5adcfd8ada2b444ca89d8b742af44f3655742ea51e5b8fcc72c474792db8b1cc705222961771673599181284b00e645c7da35ed99e2def9aefb9ccf56230772dfa9cf6cf71225a74bf3a7b87605c94bb2a6da331adeeb7c96ed10b9467fbc9dc84028c4b58b699fba07cd2c21277c5919017a28d8a87abafb194e4d17981d8d16d29daf178a4a4ab7593b86f552e4e7b315b4fcd307b3cc4eed2fce10976a6abce89beb3cd8688dc1cc53a6e2d50ad35107104334cc8ac44f0ea117ef62287d106d0c04e34f3b5769726ae0fde9a4d158818708b7b2ed851f3f3bb2c172719ee890a69216f4c4922f168f390d2f781d641ffca854c260cc14e18357aca01a5c3b6043b50abe3c4ff462238d99a3cdfd3000ee25bfdf37a173d88544c2c04a7cb59bd61928c7e32c7ebefbd7b9956356fc2431eb2a04652a4d01a12162aad777b794183d6aecfb54ff7618dd10daa58ab42fcc508422b1f4d72ed699fd0363446296224c1a0f4c02e1b45dd86e13cf1ca82b452c3157434a5def60f0381d05274db5bb4e6c8a67fbae880e0264c816f8682ff37214793e12ad4646427abe19d9e172a98dd87e83e4edf2b3c2ddafb774d475428441762a2b022742567baae09d5a0635c892f9a0dc97b837503cc921576cc4f0782bfde98395c848818b636c4e132fccd22d21bc624de334079d426e3013166b74d9743336d73e9d490def0d570f6b10ed462253fad2cb5364d0cd7b34387678f64e3ed9d342ee12046e2d9e62bced857f99ec4dfb3e08faa89dfa14d02f15f9f81b29f47f020a42b0dabc9ff4aa086e0c6b1046f04bc30f1337fe6454bf39c1be4b64d78119eb892461d8363df9320243f943c492ed80b6044becfb878c56c07f100c01cce587cbee67720eb8fbf2affae77568f48b83f1bb2a122910705ee48f05d73fec1f5d17e45d4a5b9b7f26d915447b5ad72f41ae561940d8a1c883c7f811324c4d85725352c7a86719adbf9c696c23c3d1ae227aeb160c8f8b091dcca6689d80cf916eb46faebcaad4a60cd20351294134d1dd63ff92caf37ef0ccba86237d7ca712fb6264f786c095ba83e42d30791b06743b6f206ddc5060496466260aa7286ae794fa4b7ff5603e8caaa1a4db05598585b7482616e4cf075cd7e794bae8765c0befc87030429673c83a3d1339f67963de2fa672b30507b6a43390a36ed8b1b53b1efddadc5f745ee709d11398fb1534167c5a829db05f2c431389f716fa11d03b8f258e2b132c9ccf141968ff69f69d7af47e856fc0d4f7c2faa97270a968902d3dc993762783eb19467a89f372f55deba320435b6cd6b9b9abe4e842e590fc697dea01fecf3f565fd7879225bfa8d6a5b5bfd4a0138eb21ceb81c1c3afa9a384037ee0222785fb0a1f0a172a4962cf26c134e250ed17f0fa3296d5eede4e6397b382a7e0f05b1595533424ad2b016cdbc7f9f595d6105810abbaa09f77e9b7bd1cf0f1d4b554b73542e7e87cf97f1c1506331b723350185c1382687693f0be5cf4ae8118e2db42d648d30a02ae84d610252657e1dbd70b7e7b2196c653ee9beeb9e7bbb93608bb23abb5c7056e0529ea943118337dea3bc51c6159ffa46a0c11901f35649b59eb78a0b0233db3e33731df43d4248a30df9af1825184e02850daa440a11ffdac8c5e35f240282549f443d36cbe3a9942ef83419f75e8e2c649f035637fedc967ae8c517f052ee4339505d1a4d5fd925f3de59c7bec9c4f536a20bdd83c7807f6249271523b87458d8a60786a2dc46bc028e0d8cdaa31b8dd0015ee92ce2157f729a7c9eac0b77ca9d83abb40d9ee3be465cc478b6cc510bdb55eff6c9fe30ca36c3161c9f41f96928a7d491653d1d248ce04a894ad7b4aec28cc7f4d27ea676823c5bf9bfd53b011c4cc75e7e87544f259dc1827ff29a295066f87b9069c914c648674da8db075738ad2c76a647113945ee609f2d08a37c9e51586091a3ab8cfad9e907c25bc91f0539dcce775233f4971e46791018530cfc35192426974a924b975425ef9efe7e7958c526b56dd2583ec129063657627ec3f45a808ca9f2a9e34ee8eba74ab2207efe8dd6adad60c7751506f339142a45f969b051ae6024dfb12f3df56dcfd82ca3eb22674aa3db92242a0169fb5d77620957c58c8f5e32578ff0319dd685d8c03944770d128ac5fb808a79f3b2a081cef945e7627697d03e0af8d552e5e0cbf397608e11a6eaf475124a2ea049086e1767be41d2281cf7603f36bf57243c8318974706b0823a84674c820347c0ad77ea512b34ff034c13300434214f263e2f36466b599cfd55c14a5b1367d96b263dd067ef0d533a117607afe3e9c8d8c56b83b8cd965ab4febe0cdc3aafd4f2ea614e5e0b29640e29185c7c4c6b981018936f8ac44043d724ea60a0396dd6ac51506a4bad9eaed9264639946381fde6089c4dc5535f7cf7b165af9d58dcb420f1e457ca1af2464bccdf351c1921449f80c4b209cd6a1ec2e75103646e9e9e74ec916fa8ccc36404cd9074c9e313685da80ece496a36e99e7eb73fd71851350ad3d78d372b6645e34f3564c08cfb899154a3373575638994427df530e517c3cb85c59f57a6b03d03e213af8adc579c8c263e9eb5a30e2c674fda43655f6c4b41a4743a2742eeb59b0f236777e8c14b112f66a08f8c8b1e63f4481ed3c7ab9d1097b912fad9e3b05653f578dd26441a72baabd33f0076827c8d64f5714c0fa7e30f4da3b2acefd5ca686418fec46ea4b4813446367e6b86e6659a6952009d0af6b69f99d09a64f450440d005495fd9c59cf80bd58ae48b0b5d05725c7582079d79d3544ebf383acdf86ecbc957c78c785234322a01ac940244391e11e1cc8b55b5727d644a78371220125a7fd77fab1794fe02268658075b4308c640443061211f696c56b4f57d4a6491d34b564a3f0de6677aa0291ce407a7bc92cb633248de8d83bc678a0bacd429f4dc71713bdf328467a81740e24ab3d7cf8bad134b5bd6ec39224d2d5b5f93be5bd070eb2a53b8c41a2e24b5c393bc4ac9bba76e9380d4508e840df91b2284210e9f36e10b89fade10917730427cef0c736647b645e2964a3771a1ad76749704b4dfa1d104cccd5d9650c7c4d64ed41d908f1ea305c93584ceca8d6649a39a30eddd6ef594603fd127f5b3f432eb2fdf12d375b9b4665333a0f45b7dedd2c0316bddada38f8e67b447d1343f63db69b42e720d794464a46bbbad381ba42fac73436dca610fa3fbfe286ed02ea4b70ba8880d312369b15b741438dd6762643316871349915488014d781f6810a81cb590a6c0030bfa0b6d8fe3bddc994d8419dcbf85f00ede3715a893dd69e6ecc3b2e8f974396d5c25dc7d7e6a83d2f90786c6214df53ada28a1cab5b48f1343fa7961cbc22313cb5d1845f9df6db148a82f94831e8c26c8e9f7fac8d94be1c3f9391e631425bebb1e13ad409aae53b2a6aab61122012dba8afb67837eb0d2df1b8618e038963bf2bfa7cb99f2d5731f3140dc6e4aef44cd92e5827420386681fcb9ab9e30a6942dffa486ba0339b30c99e780d0722ef5f3be3cc9d9ae9a41e22b994b68a2df09574065a13bf81172198d9c13524c0e39946d0879476d130ffaffa230d39a3e1de1564563bcb977641da6a5aa1c9482c340eed4e3dcc13ec8d83c27a0d3f0dd10d1d92fe89cbcb1f20b7a8af17145b5610f260ff047bb2bf0de1557fe3256e86b89b9934454efc6956a8cdde7e1956922b51895a66ba82bc6001a83c8d1aabd4046e87b4db5310a88481024378f70f009cbd70662606f1c375f5126fdbc3c5a78276339caf280c493046c3a5948127ccd698e0e737edb9731207be655c9fa60125ac86085e29a5d8d82ef0e5c67069735b26f1717b33f5b25d9feeb538995d93abbfe87c16ca98dec33ae9a790e75862717957cbc981ee7d189fd1edd4e2964b03f6b9d98fdd114ab6fbdf57707451a4326c983ee09bfc302693406d300054c106afedae31ea1cc1a3dbe86bb1a8710d35572833e301682dd9ba380f97381296c4a39f48e85c87bfe534389f9f493c685c2ad5d0dd6c97b85e3675792d5bc5751962c18755271ca7abc3b1b9f23d8d13fdbf9c66489b3fc37babb1ca779c34a37857cec8be41bff19644036e4e64fa7714c58d3187c6ea8dc78596331c8d76a7bc286be07f313f341d3883de48944452132875b6340405f0bb0a09ec57d4cf87b6e626419d562f05b2d9e6104b953314d579bbf546038354b84db3aac7fdc0b425d5ae01efde87259ee0c460951abcce29bc30b33a033d7dc6b95a7e66985ef64d342c345502865efab4eb831d9e88f5f525c3661eecf2a90316e065fcd351d874256c18e49384108761033d45882b5a7bb21b557e832980ce015cb940eb80887b602e73827332cf2cfae4b86f2c118c2c3038c4c7f438b64dcb1d7476aff85f2c45aff06e009d4ab7def14d8ad877c563872ccc35ff508b530f25f6acf46647f0a50bc9d2961376287d1f5e5472b3a6a1a19b786ffadfdea5dcb69cff071fa60af6aab9b2222c5ec0ed0c008f6cec996b6d5735cca2eb0c021e7add411837907b820f3778223c5cd80948dbac1b3be2e409b9745549a4c2b5c7817cb27947f5e7777707a3e2da79653b36a02c602ccdac33248a5387ccbca037a801fb82968d42d0b0971f6217c6a057a75d8a991ede58b8922a14b763972e489203b317a83558666b2ecb02b45ac2b20135d184ce490813156f5c83bab7d0a34fd9d83fddd8bf078a00279164c647f4a4d8b7f8ffd6f23c3fabb41292efd1cfe4925b00cb209b2a1def3f96ecbb24f69dcbfacdf8a4f2531e379b782d8b6656e06dded35df255da7445c673bf6766458bdf510ef13c774e7fc4b4ae9714515aa9e096f931b63360ae7819a64bb027ed9dc5936e6bdbf61809deaef148203deb833c8951ab46035e703a2083bd56fa52dc03f93bc85ae5b22d671e68118f6b95f82e0d841ef5db2b9b063549e47346a655e8f978dff943d181eda5d0d71855a5dcfae9dfb7b39c373ae448f33f2142d7e0d4854a2d50ee422368f35fa1c41f36cef53d8605c7fe9d1879d52af3e7cf9a246db593d87b3f19e3f6eab45eea1b6f411bf917c1910f36284d6979020fbcb63777d2b6c11440cf88a44a883803bc5301121e1019b8da44a7d18ee3fc06507b03d58a9eda7a8b54282f8572134274ee2446b76b877e85e8d9eade775a72ff3ec6840d20c3c55d5deb5ea8661e0eb5fde1ee2f5864e4f7f52a739edca74ea29f2d858376af2f2a36c6e1a44d5a7e92677a954ac47d6e0c1bda7dcab2ea84fc9935382d1683bc8ac366c3d4d79c3b62636bd71e4ededdfb9614120fbd1b991545ca6ef0cd9db768c3fadce2dbf728071aa6af55e6f24de26a102600726cf1b29022314a8e94b390b5f4c30e9981ef66a7f446f2b00a0ab799da5321540b01c297cc012ef1dfdeb4f81652932c46adc3db55c7251fc25e60a88fcb5985701e506758adfb6b9248cc26c7e980062c57ac0e19562dd83632a7b953833d8530386ca3240b1c5dc78e4038b10323d28380cf7db98d25780d643496c2f8f09910225a344e8f854f8bb8f1b6baf94a7b1dfe35feed08f2c0804199ebfa3291f1abbf92ddccfd05061cc65e682358a4be790436c28dc4ebd4815e0c1ed6457412e39398112ff7f1a86590c326f8e65bc60d648ca35308211fe658872023f0eb5734c9e173fb8d8796373a9051ceafa88f622b568f871637e9d28b35c03a291217d71bc5e27aff30da726bd3eaab32282846d3f1af0c7a8404681b4d9968708709131a620e2b51cee6553b475f9f90eec26e2d05788b8618ea0bac340c54379882a2a1589ad88fbf1bb03eb1e72c6943e1e8e7dac54955902b2f3b35250e242d4440d6a04f6018fd0ed20543c6cf7570699dd7fb291f5f175712213f574ed29907c1cc4eb8863f831601da95857996bfed5bc24fe98a75a67c96641631e44ee9d8919e747b80997aae7621ee4e2fcb939b618da35df4649e546af14c127d5a5182bde3d79d09d4f2858f22364e1a7d5a08e0e62236dc8b160b30d6d10d650f20c2137ddb47629d70237f0323097ee32b18995907c14a03ef7151ed3218f3ca1c6859129d8adf27d0cba2ddaba2241b7bbb7bf2f9a9418628baba275f81aa5fd73c6e53a657f77541dfe88e294b3e751773e08968f7ccb7332f628f33369235a85a420f41634a22c968b6a81ef2eed90580a21866a45ea86a20a9be4789dd67d53a0f87aec68352fdffa7c1eb6450f7205aa9952373aab2c05480a7744f8ce626740015b5611fa3f28b9866015c031725dba80c17c046178d45e8f50574ef0391fe8a047ebdcdc5c6b9606bca496067a7f6227bf0507a86161027c70a247c5abc258e180d0302a82b3edbfa4bd86ed22f1ead5ab38756f03a4bd4997550128115669985dc8aa0e5e76c15cfdfa380032e955186ca91c45bd72f4a33aa0ba708e0bc82d3e3134ce29d0bcc504dd39826ab239d295efbceb36dca1685063f20cae29dbe824da6ef3ce7e4263cf309aba20389b760231c7dbea676c752b5ae1c7edeaa73e26871a121c7f9fed658e4a2fbf8d71a4093d06e3199d0d81d26f56dd7624c379032e86779af77f6963376a211bcc705c2593a263ddd261f2977d4df2c81b39d6f96ce23d0076d5df2ec18d139b2382fa072873781a2bd6ec5104ad91b7fc0440f16a51ef3f5f4799c5307655a57f82c9f5899882a2b59136d5f79eb44c66611a2cb529253359be1ab0f6603f816c77635c3ba1d0da034da1c1e3ed725bfe139749bf18c98211216dcf921a12f67e6fe22426faf16547bb840eab3f11f99de936965793645071c2716c69003efe9c9b5c8c9fe564e32c11a2027cf779c261bd97557639d84011b962c463825fc6db1d932af34e36d5f800371cf485396aa1272e17955c76faf71f6724d61ede35e23091c92838250d843386c8214999fc5b19ffd451ed7382c13d8bb6752416c4abb6909918da38d5afdbbd3ea9b3a71e22898778c37bfd6aee983caa8b999ab5c38c16dc8670379bb1ef4ec912c56d83614d89035aafb54abc16f497d4a33807cc34ab39111945afa91b6169875660ccace3f21d922b9bbc14a3422ee0b6f212047df05ce11e441988df5eff0b250e2cccad69cb1a8e994c8bac441fc889cb42d3938ea69adadaaf5a106a592f508b9f4ed308ffb5cb27348f6245e3f861f9c358f9bffc51d3dd5967310ff1f9ab0753c324a37c28d6be76e48edcff390132fe5966cfc050efa34f1b11adad1a8ae23528188d81997853f48573c48a9eca872a880ed79bb311c5330ce2f8b5bc6f619321e555e621e50c475bf38052cf1971308cfd9d09b0de38926a85922a14750bf84a0fcbca7b3977f1f6dfdcad0380dbf2bdb80923e2820d357a3c02983fb6b62f23d8fd6c3e4a98b41b968d5acd746c4ea69fb060430dc3f706f29a213f54dfad41cb2138e25b1b0c10355a61484cd90ffbb38ef873c3c869f3a4653ce8a61dc49570a4f0174cb1b3bb77cc101e992e71637e2945d57dbca1636347261f13426373c6ebee28a792890c8c0bd418271fdf5b9c07e44a1f17489318f402d54c19b909f829e8b208bdab62f8b0e7f3d852965402a61ec226fd4605317b6e99f0c7d94990db7d5ed725bed1a09827243f58d32ce57e1b0d50401a4d3c7f1c2d49a8ef113ea1ca03a11b34ce87fc55cfccaa1b930603eaaf7358f28f9b1949a048e903992a0ec1daf34dad26f6b5dd4201f6bfa45b8b7dc4767ab689bdb155f0278c79a938596b63cf5fe6848ae14c4f296fa19219cc86216a6662f94da5cfc67968eb1a0b0d7a45e2ddf24e0cc7b71cb937f84686875645247eba5a51b585438bb658800613ffd6546f8fd7486b0bd662a75e02bf3ed39b71ee66d3b77c8dd8db55ece7c0f7691fc2cb182aa8fc4bf4093b1159af3593d96e10ff4f7473b3aae0dcb6c3b45da36d9aa5416e72203e642a4b01cd269214c7f80c6adca55b2a4ad7e460e6de75c1b28a5cb79aaa22c7d99646be94332f0265e2d258593a54c23d8fb980fe85613b0bc7fcf22b96031ad4980f209b5f2370d17ffa499541029a1b1c2fc3156a768e33106774d50a66c1bf71bf2d1d1ad71f35f0533210e2af585665f88effcb16857e4f72054ca4008ae6297a0063e191cce7ec7e6b5dad22fbbef37985cde96130d1f385bac54b48abf50154cad5db9de7e4035f03c40f4ec5a4dfe85713577532c34c7aaca2751db0e52a995b8a71ea163117390cceda2108bd1898fd12bef6c6ba3ec2513563a4c4849447702b6666a74e36a5d6c2d77c49f75f940f78c81a2243375f29363cbe1703e762a5074e06aa600b2ac381223e4baf893dcd503795d779b4c2ac778d42ae9e05a8b9f7ad34a940aa06476240d37ca33a675fd45de4b9d2dcd331eb059b025e785a3ea4227a2e2681f12741831d6fd48d09254eda61c472b28accd87fb113415d9056c60fa1505304e36c89ba5f3b7d0b031b20b646e15d16ce73da77ac00ab6b441ea89dc049f0f4243fa2e1e4cf6d75c6bf3d771d82558a7ce85443378fa6922065129a05f084672ab2251958fbe3391169ee4c218adb5fa374faf0bd27fd3ceed13741806ea086ee2187270597c44c74da7229df7be13c0cbcdf94772c6b789b020c6da7690c7b619ee9c285d98c1452929a8b466f962179cd11b23e452feb3679d8baba1a00e7d0c0e11b095864ece8692547222bb389e6eef9e84173fc8bff0f661a722b89fb6b232f0f96bf6736fa42a6b62bfa4c9f8aa2058e2f23cc4a502747e66ddff2d6e66d2285f1021832579519866616fd0f06dbff46eb6a0804ac5249ba995e23544bd0c488bf36840dbc750c82b4cd9fb413e7c67204d5c39abbf1be65549d71e0c915a462e36f3ca933feabf9360cfec609b8abe30f95a8f7bd4ca7393f25ffaaac66d3ef066ce79de23faf1cbced17b51008df8495d55c2505de135d91566f6c2163e7458fc7fdb4a64066a976a9950d8e7fa5a9472ed81a3874a9aec6fd4ecc3dc319583277a07b5efccbabec6cb732e838d31c92f1612b870b160526c668062f6f1b81458fe89f72959be9c3c4e761eaadca945251a1bef14a5dc07ec7587aaa5b64f413ca9c61943e72fc108ea5265c6fcee787248c3291dfa5df3be33fdeee1e184c19cfc31a1ee41f0ad8a16029a4b2d188efb838b72e6ecf8fae3034239e6cdd4b48b4e2ade9d27e09ae6a3a6ba84452209665ca18abea0a49df0b3dae24ef3d63d3385b34162de57aa606d711f200964b2e5384327e1c94741e69813b74df3e1289b200eeeb8f3184d32708e4f4efe09314bc298ef2548264157dab75138ae846eb0adf71d1ec6d4450495ba316f38ec43b9edf6d95d3fd024a5e15ab317674c8e09239e4dc4768a6b10cd6876b4a36857d5b881ca1a885a382b499c5f316fbb5509adf45a740419e0b866c4e3f824c284520a3525ee97f1984f7d432f7e37e690712738004df302b3caed5118c8e6838a82b25d94fc0d8c8e72ac2bdf20c87270c7287177af40713e79e7ec252d97aec81f9728a27a79d808e4f94bcec16f9509133df4d0ede074f3d6c7d1fd51e7ca4996886f714e39c8919630322c5f55aecc34123a11c6bd1daab6dcc1a543c09491a4562e84746886399e19a71aec00e4f34f17b99ce1cf19c5845cc69ef8e3f6458c473491c917b6b595beabfd5f660909b8a900f2099757367460cb1e5c608745ae88e8421f594d97908b9f8397bed2c8176953f03e55102dbf190f10949bd6cce30b90dd8449f2b544a3f8bc42939b3dfa4fa3ec865b86f5ac72dedf763cfb14d79dddeeea79a465415c57e92c2f572345a96dd4c604fcbd1222163c3e3f6f7bc42a3ac10d2293f712d4879b97f8aa8808b4ef6ef4a18fee713c5427f87e3c9e7b8b0971c5bcd09e1ce0654353e29da18071e375bcf1bb5dc2ba49911808ec865e057efb28e179f7046d18ae348a006bf048465eb0f66ca102fa6900cd6be82a7acd6d07e4a064b461c6d077e68a62cc584918e887b0ad314043a9dda677428692fb02b1013f8a3205076ec50b256feecb6f7a3259bb808b6399c9a5500610a1b3ac150d0a3194a375f0fb4e01a3e332677b2f8acd3c22478ea03e76b44216630f09b65a4ca66ae681fa7390edf2c3ed98592ad0a2e87e9c3bcc8c978504741bf55ee572b058d7c6b3643ac0ca8da0efe078783d4383896b7d18fb0dcb8ceaf15c4b9431d9022124651f1febbf2542067af525336046188e2520d83bbf18f01485e7774f3809d9e83b4a4004e81c463d867391f5964256f17225d0f659aad938a20b0442eb18650fe508cf11e3b9e861bd0f5af4e81381d2b7963a86b4d49f23e9744935a17e987ccde088ed885ee670dc257c514759ae2995a4746286ef3a85deefc6b8798a43cfd009b35d5fc25d4b6d76c00788342fb7c40e4aea83f0bdadf139fc9f75d9b9b67f00e26417e49d563608b49478ca2994ad6588c62e921d1d28eca931421ee359f30623e7f83f449daa99b2ac2fa38d3fc3732b125742828341459392c37e38c12014916955c9e6d643189b509a3ece3cbc30268ec8a00504e7b620440c1cde4501a8df383371a2131e8bcbc973221809a0476d4d7be1dccc216e10f176acb2f4fdb2f70121e04a7d53edacd741dbe4cea339a8e48393fbf8ec82f5dc70ef7fddf370200a28f1afb6a342630ea2e4022631da03dab4d21ae8739e2d32829b3e0a47498fa772983d6a3bb4e9d601c2fcc2d5a183727019f71cd3ef6a9f2c07e77bc7fb584a71164bc82ab39777498209c79b330fb8d517e23c56debe2702851f73cfb69d92af2a04ffbb3a38d14ac6e3dee306913af50bcf6fccfa14258bf50ae5daa126b6e7740796a9811488d4ba61924b300a79fff667ffc511040a5f28296629d0c28d8dbf0fa36efbd43cd3436464e4f74983570a14524569f0e74f811a17ec67d6ca9b3bc6b15b75e9b020f734c25ffea5b97fffcbbf7479b0575fbce28578c068253a0625a79ea1bce8a3ad84b073eb2983374f7d98554808acc370eba0b57bce98a1a47b650d2f50c9d60ecd6d4d1efd05f0b2615b1b217201af9df13f517578d1483bc70ce215f0a187d0c95dd64e40d690a9f4ec02691df4716dbef775f2a14dc36933bb5a0582e62d4b5b1f425f2820f2e805900231fdd9c8fe97ce16585e64504b1b902179070b69e1fd8abbe96948cdccd0e3e1dc05a3c419a08f6a5512a56658cc3af922ff8b85a5179d57d26dd754138a0d197e038395ed02ee557aa8546d1965bde151360e0291dd63f866a23a67496faccfc8dfcecfd80ad95ed67019c96c3979bdd3ce1cc0f1a8f427c8491f1fc12cfcb24c460dad2e128511dbcda16bc9626f02083a40e1ee141bdab4a2db2c93eead87db0ad25bc63991cf336aa9d26e2c12ae30d04fc5839f0736b6bed7dbcef4f2e3b85759eaf6c9e96a819cf3951f834680e8fce05bf844482be803c1a0b5ece8cc87de1f5eef12d43566da67e8af4639c24b2bbc2d251ec20768eb756d3dd19246b950c808fe9107396198b3914989a3460a10938c9c9d05029f25da61515d19a40db17169edab303015227a23c3bd0762aa77eb7b02e7d6eb2f3a72d5dbc305faeab282b06a9a642575bfc7babab2c1bdae369821efc5cfe8782f83d8e2be77856d1f6c7f451d7842cd2ca3d7d127e99b8afa9e68c325dff35c73fdc5b2ec527b6a59923a5fb8235cc1b6180bcfd3a0707f62ad26ef889a51b29467b76d510b16388540b670a24fd34b2f3d25e69b31f0a28fc9f2c2e59b7f5b0aea2db65d2b05e1dbec9d45cd253adae3934918db5595d1f5e921a01bb6f557a102bb5f8c5e0c596fd8aba61c9eb2b7ce63b0bd9598cfd16a9a35f9a969fc76e6d46185215b6284d92ad1c8000814b3f00838139732a8153bf15d6c4f16169317bed4e9e26c56d180fe80a66e83aa3bf20f90172c0727f35d7a05616f318331b1979eca9604c35db63501f318495ae6edcde16819e24c0143cb9aac2c1a0bbf0bc5c8a84cb460051186f0c8db35c573b9bf463bd8e36b3112a46ff552d0e0833189514812f0fd8fe2c5368784f066997ae1652d02861cfc049ea6804ae41b68fbf1d4d20f70904655295324f489b9f5fe0bf8b9de40043c91dd3903cec92148f38e564c3d934887338e619ba5335ccbc0b85cc43e42968d09130579150aa6a324ada917e543c27a5f72ba823c27e45e691cdb26ba691f329859d19cd1014d35532c49b48028f58a5cc86916a18f82f72a77ecf137bc297cf489ae7fca472513898325686a6bd0ebbb754e3472011af4c7ab03f5b5f029ee85da0123c4f79a4c0e8d20342732dc2e18fdab6eebe5ca36d70ecae36168215a6c383ddd2ba86820ffae5de4dbb008081a4456560b3a3d2bfeb176db77eef1fe99460ee9aad28fe26cd38f84ba14e409bcf9401fe32fc5a21c8a95294688297f664f9f2863089033d42284b11d301ad821041e87a318fed8e5d99bc2d86684e5454aa8df90b307b7357cc75381c5264f7b045f06787df6389b5cd6a9d923aea8fbbf92bf74460a29175960ef0b57dc9d22799d5f64a8b80da9632aa97365182033c9bfa2835abba8baead026095ea3217d97d79def948f735e516a9039341f5ba2b9f4946ea0f445574c27b57fbd6548320f915367a43b7627b2f5de1fd5b5ce8af320750db34f3d370cc8791a4a97957b8d75fa2d935c3fbebd95113f1237601842fcd2a40d94edc918410248b30ac7a41c7b80bc45114064fcbd57fb07c8a82af4ae687c324bfc5ae5e5a21c8a250e1a6b74bd7b401d7cefa383e048751d46cd8ab1cf58a9d898b270cd9b55941432f4d07f71b681785f2feef650a5a7a6b37418a1493ad9f9624f83e1830d06042cecb3c5f73ade14071be8af1fa77ec452e232ec6981eae75bcde7b29e41c982cf42529b5cbd444861474ff89dc408c73521d17034c819ac723f2d651b3f305c342c01310719fd1d22323c520c66d5652607031e3d4df79082f458248e24969af03914f909579e37d90c92f27fe288453e6bb2601c422950532ee9a55554702db0abda38a317835f4ab91552f0756c8b3d78c0cb7afa65a9a0dcd23ea06ee60764509415b83c58a9ea48c95947f86858715837cc30b33be9b847a6a34a559f29dde495100afb04722613293454d09c5e36ff6bd312abb55c045a9960050eb0003e002f2ed3c3a2ae8267b85fd3d111a1a842647f64b0149b73681f178d18bf541a530d958846cff909709f07448fc96fc08b4d559ca82644f8c0d8ffede78a5863eacac196aaed0b541ad3dbe5daed90f982b8a39faef6768e2c742fad887b1da87434061b23db6f17049fd4dd7b7e5048185cfad8527f1803053d04ce43a586d7c18aacc20d03f40a7f8d22d6293ea001d1ddc9221a61f1cd258a5483d9a81c02046071596fab39dc775ffc2cc47bbfb0b0f48e762473c13035a16832beb3cfce2fca6cb75346a9c19647c3fc6fd5ed62b7c1e183746a7b580650651d366b940d3e1a4e9a9749d45c2faec706e58fb11bbdcabd9ca4d538e1db0e80f2d906d8dc2f448b166b07838b0a5d0e9c9294698accc55f58103ac8dba3d223d1b6f6637db473e6826ee50be3cd7c5d9f52823b98b500779f73d16569c86b14f867c21f3066bc44f5ff6d25061079cb3d6314a986593ec22b89b67a6803823dc747330eea83520fb5adbf80f2e43a9bd2d5ba9d6f17bfafecfceb60a22e408b306e3eaa10479ee5cb556eb4c37cfee2b55333d4d732546e65791fee036b1c329aee3b30b21111b223406de760fb8fea6664c7458d0b416d852b792ac2d7055a9d1af4a48ede3f6a46d246c17aa1373809c37a3bf3128ebfd6bd6052afcb3fc21b59e9ba24bf13f2a68b87a02deeb7406e8b289c160445810d47620741b4648f733c824b248e17ba93f86bce114c3d98cc435d0d1f24f468174653a5e00a3f844b7e04d504dca02fe8099f6547d707c917dfaa730caa663211b377ed2d6a855b1af23f998b507c4c2ee18dde4ad9c80f06cc0725c208d060b3bfe1a2820c9ef4153d4a0068ca381a82b10e6f7d3b1d9c744503d9a31de9ba7c637c37ecf4bf753e7a53b395e28928446d504d6f32ec1147171eae0ba84f91a93ea45011089410db3ef11a2fab3e784ba148505b0ea78e9e162edc623c21def95f4d6cc248eac91d520feb8e9160d1d32aa7c9f1393bc14a14a45838e6215e75e2c9889954fce8d4997316f04202daa88c1299e7ecf95c4fb8d44adcb5ab029f89071196567c8f1a3fa1d0e949cd7152f3e4e667c7c71b7cbc31706e169819cdb89acfca4a870f2048f569f02a500bc2d58c2f475761b72634db100b308371ec64c45d1c7eed284b384d434d14fce40e2c9356cf99fa9f9749c4b6d251595e952788f4eb6da6189e475ffcaf6a860b99e5b6cdd24393a8336792e14f4bea4d3d624431d27495dd1da615d4663e05ef66a36858fa887d41000463570fb223b0e1a72f439b6e33873c8a21d6afaf0da4dfbdb5f404d75fd848cc22a5be344e529d6a04da604730bf806be34530d746cc4f28876631e6cc11d898b50e36b34d1a4099245778fdb22bf6ce1b19f331e767e6f8bc0439a2d9d454dd5ba0f32b564d5b4a79da488a32a45815bbea73f553674d7a352784c462837d720b2e6b9ea5b4e1fa5feeedf3976524dbaa0ddb85aabaa83c141a6b1f34c9e0b9d814a6825ad5ecf35899c42bc75d933982d454ec73e2ea8de726c43cd0981e03ee790eead7e0338a05fe9ecae87ef1e5877ef016f1246ac9acdff80ae886b33be66e8d5dc915b1b3981ced54cd758829c5fb9fa6e443ff921de6bf0fec9fd0e60e20757fbe0ea6530b30","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
