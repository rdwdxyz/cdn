<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fb32450b9893e0ef777b1177b4764e43977a90e397dcfcdf6c6c14846c99c92a0613db89e66832c7e29da5cd86c1355f29f685d61fb11174d9d326624d7bb5520ba8dc26233226e166eac5a91d809f8b7fa3a23a0073c446d5807bd78bf77a95fec3e0542ac6e9fea5fb8afdff82d73cb9e47e654610f7240ab17a940f62675c59e7fe03fbd7ea8304364aa12a0554457b1ccda1237ddcdbb7a217e3d59ebcf39b7e4f6da12ece4397e89fb846d8371f72e07c5830f9af0d397ebbe06572fdb3f4a44da1e780f730eeafe14c93b932b3ff0aab7f329825f153e600bde2777cc37a7021deeca2d5bb5852360f4def17ae55de333d6ce1f59bfa25f10126d9cd27255512087ea18191bc751545299fceb5c231ba1b28f2442e108a6bcec01bb70ff0b41e631b7f28557b85dbf9032b8ca6a8aab00aa786be3a7e871a13621c0c7bb1fcce9e72c68a2e90c98df1278c4be905a630b5474100f5c939d86afa5454480d7d7fa13223c9272c5ef98c35ba96e41fb49f58c024ac92ae48ec3f5f41a49eed133966687edc5782cc46db00398dad3d87a2d8c7805e76beb3ae35250a4dcdfdd52df0bf48d459ddabd9a077c3958ff582454a029d66c1f572505584a220004a997334d3c637032741a15c05c534b9a498fabead6d02733abf4b97fb51edb1c667d25f3e374b3f3f18bf8de1f4453b44beb3b034578d8c9bc054b6e24f94bcf96ffcb36005383b9f4c2801278a0f9d85850e02c30b90bf55501dca5daec9b1d17c289f89d429eaee78d35981de2e5df159f1dd59cc142b710135365d09047224bfb9b23ca466e6e8ca404e7f92efc45d6d9aee85404a3bbc8f8d05ebd87bedc639b160e41eae6606639676ce3ac55a4ef73a82c9e3d3b0e31e01323ee1068a14dc6d61a4b0410f16919fa5a13c778fdaf940c0912f8fdd107a7aad007e003db3e02ff41cbf96dd34178afd2cf92108fb27f55b2140a21dab620cf1ea76f3d650f2a0aa2ecd7d09779a9c3f9be7eaf779a4bd9e4ff3de453626b693b85f87b10bdb3549f2ec8e158a0a5b868ec5b6e39c04c7fd1e95c2507626169853dfab6ea743c732691dee3a6f780db4ce409d17b1db515217aaabc03963cc89a64a3a19d57553e8710e5fa277dae90548eba2f8afb41c6236a5643a44903a80e4613e9250f0b95c15b955ddee11424c15c9330f9f2f98cb8547854fad2e8661463904a70ca9250232da33f7b8e868326d941b8b9e4c78d64b77ef0431b22166f3cabd5c2ffe040e67815745af2ce6396e01e353ea70025fa65d06d99f4003101d6f8adfe670d2f62636d0e540cf925c69f65bd812566ba1ce0deb4d4f8573d886e7d3327b07c148a3c05a4c607a8f421ba09508e9b0c05052f6921cbbb6ed8a46f5315419c42cec1e3822c7c6db2a9a34d454743072f67966cc02c6a9bac2bc5b42186f47697ab404f6b62173da638836d80d71c342aa606aa50857612365a1a6c9f5222a56f063a259b9379bdc9d909da31ccb3e167c0731466fc2bc9f04e945090518d13bb4326fc8017c58896440b5d4ec788017ad513d380f34a1f4184b839ac224f80b39f638e6b0175273c50b51475714575665b5203f453af06624f330b3bab05ad2e6747b2d31b39cfb2be86ebc4f30402d8e17ec49fcc0f291f884aa48a27d9b5d59c2a0f05178f4167dc152f58f04930b3efbc5a70849e16e42434a1c4cc33ae6deb63bd1b6c2aedab927982d1c52b2d78d58c3c44954b5ac635443ad6089d6556d9df4f1b43ac32b6373796a5a2b4649b225ba28fae716ab70cbdcbdeb27c67e2bb9b951f76194beb649bf2da93e5226df5213b655170cb2caa293c8400be334e49fc9d30486155e34195ffcba38a1967bb770a9232a6bf968cd1d95b8a7f15a4c42e6ce87b3834eb448fe81f81d9a87dc59ec72ab4d8986e705db2a072d92ca5c618cf6389de0020f41d61c7408e46d6739e0d98b7c5420bc267ec67241aeb7e3acbea1052f25ea83e34548c7ecbf37658059722c7ff2a35eda9f72131c466fcef196083a3f494392a282470f9c395cbeee4763d6e9973f30e21fb64f22ac19d268dabd9df83ffb3be875fc2478ad66cb69b053d0fafb4fc039b106844caa51045e16f0b0cf7922459574a1d91aa15e02d90d8d0337a6779d58bc55c0f998c91f1188885e8f5145bccb128d5ae27c5f6bcb12cd553b58f1ed737ddda8866e764939e97842f7defd08424d1d2b482ce592ee769799092ad24b2107ddb4cd066c226359e59c0db818693d680f63df2965c0a8f1edf54e06db89dbcb226352624ee05f61d46a224f3cff6fc776c8e09e849880628263340ea502a791ca065bb695c027e825a15b9d1f333f2a7879d633dc9a2dc66568b5b261e229afc854c5d141fc5d8a68be1f69d37f700e10a8083dc5ad32125a3304f41a127287cd92f3b7d5daf3437392b05605a599a82cfb9e06ccc35670f6eaf01268559a56524662b1ba9c3532733356819c43af6caf7c988ba6226a380ccd2cdc64f44876c946b4609ae0e8f3302b0ce7dc565df79ce2f4ebc4c986c30ce69e4a4951743e28a50c228e506b7096173bcff797070f589a8faad3b21d351f356f09b7997d1beaffc9ef95564ee45856e70b021f0057b163e61b0da38162a08142bbdff349a2da76c8a0a2cb28fdbcfcd20153d25606b3413410d48bef6080882fa7f16ebdb7b6d948071f39f40dbcb2d2669d133e277723ce412cf547b137e57732735a47503fa1e8d454974ec35bc3b0d64f4a2391cf6e7dd2948183293e8b96e9ba4932671d6691802f2d2268c142a144acb0d480fd73b3d84d0b727d6c74a98ef888814dac9843dde0372b752737026f1e4f596ea102983cec1c1f069f3055f35fd996bba4cd8980e3dceb341758d90d0c3bcdf266def36ae6e18f5aa7c9a95dcebb08f03f832023a0f779584ba6d63b9c26329d7491020f3926a782a2e9c029b02c95d0d627bb263ac059920c948722c012e966db43acef0c41360b1bcb1db6aa6d05379137e83bebad040bcb7b12ff82993cbf213eb52085b3c02a5204ba555e7ec9fea158b776a439f9c599786860f2240aca603287d99b50e709605cbd44a3615fc33f929372fa07571082f0e984acab56d99bd9cd34b2056f79d0ce8bbc282a60d3e06c53790189749ed10ac3acc9ced1a4c3e10f694cf0a5a54ca1cab01a1a9fea1c85fa92d47a6f0b2990a3ad58e66ffef0fc50400728ce7518820e772b43be4bb8072526d29bfc2b410ce9c96d8ee928b65bbd3946bb84d3cab41f96eb1c232e2bcc0fcbeb8677848b5b88163c481192a60e801dec9b59dca2b9413ad2d65d21106aaaa550358ccbadafd80d6913393aadfd88d2bbd7bd08228c09feeaedd8a24949aea9814afe9a1e6a54ec90318cb18ef54143fc7a1b50542b17c20617f5cb8434a97b4a97974116781f0d2d3d7e2166f10571425ac4eea3bb342d36730be2c0e9013d9c7a42fca8859f2a822ae64b3668a298f788eb54b33d564ce95a103eb6a29ad4bd8fcf81a98a4d3ca6f7b0bda06d75491f1806a7361384f26277ef4e5bf485355e46768ab69177754d95f16b54b3cb235ccabf978fdb482702e5b4866e9719793b0e6918dfe3a42ffbe15d48160b6f2316c1bbc9acf173544504fda5ade2e0a7afad4b3f98c421eefce1cc0f3c2a1101fea69c41b41527a0b7873eaa70443ebeeeb6e0f9cf27cbbe4950801f59ca3ecf0c1cdd0621875e36071380389b061dd38f1c61888427a6cfa74447a5d84c7f911eb13afd95b348edb32e16cd65b4a5861bcbb349a143c48e265ba56ef187daedae23e645add1dfdc7771de43e7f5923aecf9e1d07a38328c0eb30cc1536ec8dc07ef5cc02001029c7142b7f6d1407c0af86601d0b8d06ce1db86d3518979379ef3372b392d0d94f580e9005e811fe8e92169475b8649c5a72891c3edb5c574aba10c0e79da9de5a00c0b04256ced371c686d36c3cb389a28f453d7d3fa5f769c9c9f57534ae5abe2c5ab7b673ec2a8beb3c3fc182fb2567773aeced7cdd9396c07da7c3c5759edbaf82b84256d7e5bb071a8ef26a94ada693e172858409b3092f15a029bc885d5bd29714993b0d21ea006b9c311fb0b97021e43a20ed78ee738ef655eb9884b9cceb377fc79ff911de44a0208cfaccf4055939a05d7c647056ae0bece0afeb44f15617691bef69e83c5426bd4ab2cee9e464a43cb928390830c71a78e4fffe71f4aa84f33764e8b30bb325fd630be405fe3f54daa253fa6b30e4f76d7bea4e587dc536dde9bf50aec91df8516594511d8b9d2ac1e55aa431c167b06aa74d28c8dfc4beb1a1082a27591bc652baf407918e3fc6d5e12c124620c0c44070197f067ee0725e6d16e4ed252d37b5f2d4a977afdbf04a266dfcce177956162e124e3c68ddc5aa403d0f7ccdf3743eac4f694fecb25e2e36675f025b328a5781aeb163da1fcd410486f102ac0388c3284800415b0d7038c7534218ca8802114a3e08d1f32051ff508065a5f73635c27d72f825807cfbd0ab268d985bcafa632fd6da747b445b026465d2c74bb3bbc6d63c6d88f463c31c4d13c5f5fcb4993850505392e83c92ed92362bead4524e48d99ce1126cc58fad78c703ce9534935085305a77a785b426579e1b1cfef5a120cecad05eee844133a75d5ef957faf7e9d4a48d8e7220e15a832193807b0424c6e5ebd2f6331d3d814a120f5ec89070eb045925c914d7c405dc6d19c793e5e5261c9bee03c7ea2666ced26ecd6e08734b341866f9c462c67ded39f8621e7d627cefe3fdf30d443cd4ec4fbc4b8de561d1b0db5cc142666c3478b23eeb96fec2a0f9d24db67077aa4b80572554eb8c88634c72ee0307d708adc2a38d8990203160da20f877de6785b947e6a30e4d306e5ee30ad1af2ca5c08a194ac63b881b3069bb37a87ed90b14efd75c99d1c6199c1b3acfb782c14e6af1b11953ce379328aa6b4213df47c50b487554fd9868689ed50bc1a77bfad368b3c78df42659ad1b3f425c7fdfeba2f0657ca7d0538b6987260bb1319afbeaf5de43f04213d91cdadbdca4697942f8db700875435acf173b926c186f6bcc378dff73eda635dcf29cab990630d2c897ed896706255f4648d33f0f1d8f8793de46f32b582bc5c17c3e17a7686c80795d284d66800ca436989110e45dd133e91749ddaf7bdd77a8353720183474fbc2814db403929a16698d56061b3e41d8fda1674a7ec867b21cfc766256ba8cf683040d6fc678d836c22cc871d0524e1a46a817088df4b2e3ba0bca538d2bed54c3e50c0b88cd2bb0b72a142a52321c75549dfddf66b85147a54101a939dc857a48bb7356f59d2917ede1e941a0e15bffb2a1ab1a4f8445f75177ba65d472b410a75e4c630812a1fa6cac9faf021183b716de194acd7bafd6cf9440b50cf6166171ac1d13ca9efe3f57730341b021bd58403d11d9bf41b23623a10e3a92b59bd31a089e4b87bcf8ca83b61069fa65ec95b197b97380040b6daace99c1c4863d0a8033c567976a56848a7d0399e874fde4a595146b102acbb2d94d2ac2af910c98ad2615c56fa52efdbc08d73ce85940f386eaed2b895de3084e6c842dc6755cb312073792560fa8c23d8bb576b36ac253558863b7ff646b6f3289b86981087d84a8624df0897bebbf9ea50f6d2bc96c08d52f4b3bdd254d28c3e62284a501defac2b5eabef9dc6c3ec845c85c8c9d356f103a6a6832ef10aa614e27a87bd404552dd9819183da733cae3986f8ee946a6b53b4b71db940f5d513e88c94d932f645375a8179d1c51b411c568712bbbeba23dcbd15cbae8aa3c49ce1a362debd7885a1e3809a811fc1c3435d879f0f45eaed66117596b85b69be54f1c8babff9fb3965fe70296d238d68c719327749a89f0aaeb84f93537f2e1a80e0df6a35723d8f9aca3e740b7adfcd15efed49314f141168fc5e8c77736e96ace15b33b1f40f62a0e09dd49885fd66b6d968fbe0393ff08d0e5b578d1f777b5407cfc816a326e3f5997cb5dae29ffa2a86a02667bf05cf19c599b1a83a4fc50ed0efeba636c5060b993f49cc5f3306830d1093a73766f7e7a05bed5dcd3c6274a00ede70b28fed48ba7dcadc6c26e258351f10938ff88b0dbce352d0a2276a8597c3e9814080e62bfdf4192d2d7a493b136d40b27859788681cbed2e32caa99aaaaa74f4126992f7afb4525b3214aad7498f771ab5c628a8af218e507458350f5dc6514aa73e3bd3cc02ed23ca1b40a794ba55ff765b3137f73c28063c50f3390df694665a51944080080a888f117da011073bbe0851f06c3e386fcd4961176df16744de36605f3780e97bb56f8f94663e9cc83cb6e5f7ce3e4a4b9c45bc3608e214e7e5b91b92e87e027b4f1494e79a9cf88512bb580ef42a87202a3300745541836b123dc5fce096aa431ec3e813d2ddd42708d6401e79b7119c2af237bce8e172c7d77f012a1ca78925f0b9c0cc5ecb482aac8312f29a239b8c4bdfe941ef68ec5ac9897e4cd0e1cedbe982146da6a0042810218ddca423f4bb2efcf0116d5798d95b9bae518f4a662f5924299fe6e334b8035c7f34dd34b9eb4543487ca8f791b82e68b1d47e8a8cfe671b8ea5583ca9cbb32d539512fee1bf42a5ae3cff14f99bfd2caca004388d758d408a8d82e4c1ad6be5266727391bbccd8539e43f8fff0e3857151ca0f9bd2b216476e627bf01fcf87134cc413f8eedd848de64fb1962e3997de9108aeb0dd03fbb40077ad03514e9298567ea7e7f3937a8a3b1a60f8dc94a3a90c39b0ea212249d27f435c964b7227c598d419525b353c0e365330e7495c63c2aa64facd30cab65af774021746ba0256f8af0ea5a3c5dfd1de1a6ef4aa3fd221e1fd1027c14df57c5d51e9c8bbe31eb2d98b4b07ad8e4566c9539ca575c2bc85cf5335fb4a9420e49818066f2acbd4b70c385d7187cdada1a8b4e72d0660890fc15be501135abb084981caba702f5bf5288e44730771291bcb877cfbd1618f79805c4586bc4bacc86c3cf978a34315b5737e998214bac3cb73c78d413cd20716be063eda45d4037181415e213686e05bdea7edb50e219aaa2cadd7ad6f6b26a75d0d262db6829b9b64ba7e3506626b8115fa3c815fba6f68d937ee21cf73d2ad570861945277494901700afee53092cae263cc0df99f533c5cb7ffef2edac53e84247f9ecc0be6088f671d38e642c75fde0d6a2d9ada967de0f4d60a584352ec1543b6e04ac39263c7bd15d1894ad832c388a1c761028fd3bbab12932ea7df94446926a1145b7db66ae6bd7303f3f34803dd8a653e7586e94eea3be99d29b3d442680b17ce9ac8f2c3d343fc26aeeb46aad612f09c0ff218fbab38bf585058d923705f496457cbf2a8e264104783aa8a8cf398b28a70f9a5217f44f2624e264b08c11d4ec0b4002067c7623330ad739d1e8eabd659f1690373043d16a2da356ff00209ba1ea3a5be1b07be2862d4e1522d69cb51ac35ce5c2bbb1c2abb33e217937ad0461c3f7fe4c1619d1a5ccf2fce8e3b42433928679fdecf313d1212c6c1f0f5680d6919db88ba28eb6d80ccf7d8d055db5fcbc25201859c92a2fbdae3412fa3dd49d004a93b5ff0778c8dafa820a4e9c7e5a7a1d92828a7111c74ae7f3a8911d407ddd102671526a20d449f81d78ca2a67ecf98aa2a17a6157e5646b2c086d3bf1d27599bde1d40756725e46e90891b24f74ccd3eac1d29b4e0613f89355cb71dcf45bfdbd1541132011e424ce118dc5e1eaad98a5b8b48b6df7a19768eb9cca543fc782fbdb45f865bd8cf8754ba4ffa25fd3d99b3acf270a7c0739fe27d07b32ef55b690a0c935afd729da9e6c2e5681cd0cd8b67c6810638f4d8c2f3520c65e1e038ebbee73e3a71210d4c12723aa636490453629613d7b59cf4cefdfef7c30dbe7d779ddfa4074cc7b880a52f807e79ac4d3cf51ad37f92136f70b0af0a678004b0211dd3a7e86cee3fe228cfac0724518a0ca1df733c8e44b661176cd241c67e64af053ba1914fbfad2af2e9099d8ee996fd485810281dd988f30a749b0c5831ab98b72ad29a2259067c01ea8aa3166a81b17b0de728255f95498db60c3e33ba02f6247b7d8937467fff139ffabe13fd2654273f9a3d65c70be9e9427c705979b5bf23cfc6680f33fc46a6713677c29839064730911da342603b2858cf61c71aac7982eb1402cd1cd0c2bdfb77b020c8c9dd8f36c5212d9557c200b15e4210b89cc02d49aa9890b6d694dc6f748162eeff303c5da0227c297ab0aa7950b1f4c969c7f398ac0e523585109d4a1c37d6fdb14e209ace5c92397490df900a0e42442df5e165727d742d63ef763d1080a2c8586946aec5e465bbe36defd2d7bcfc7b3974128c0c517503e879d021074f67fd8c43f5e0370ca4c50fe54bc35b508c41e787029e22ddac0d8b6eb8e63a0c75798bd4754f6ddd81e870b199c283faf9ba1a8c0d678b0e8173b55c106bc420fa709f1c3deaff5ba928e8c846e226bf441d5ca2c15281697700cce1536014b62572464727f89b4240012449d0ff0098a3dc9ca5207c3b9f09cfdddd159f85b520758a8b70af9fd66544f5f33add378b5ce0fcdc18173607b6bbb4e23e22a823e192aca15004a36632b57fba4a2ccd2ffa4d4e14e180d66039793d3f682e770aefa8165f6ed1ecbb0da8fc2f9fada38eb1ad8d01c8836614413947212d0358783e70c2b8e603f3b0f0ae4982a70f9a5c4d76804bd11c4fd68047f7acd3ac8f302e04972a71218d9aa7ee5cb579014403e3cf6a4c2522b4ac420db413a643a554bf93edd680ed35ebfc4fb071e9500aaec55e37ef0e7965f601aa915d534226587f94efae437edf378130a81d37e858d0e1ca890e2ad605a0c6df2bfc88e88804dacaef065921178dd29a6d84f4ac3ae023ba67ca192dd48cca22dbbfe27ec51dc0a77e6c0a31b901c558aafb231551fd082dd53f3efd44eb1395449e53288ce0785e50579e01fc421a714e304338008f13ea3825a4c7f6d56dfd241f1d7900a849d19b0491b9f7787fdbed1ee326934c2d91a4516d67924a65c6e7f7a1d3c7974098d253189e9538a04ef1a790bf4856d7e24116378a4e3fb823ce9a5fdb4d7257a73738798667d7a6bc042d2cade878f152817c32f3a432eed800c573a27c54347d77d0926ec6def73edd36769521f7e253421469c17d6e2501b9d1d2f8d544e5eda70103ccfa565659451a6f4fc1e0a0a330b91d05da64c4c613be92e85b8d7e5b51dd8c6e4e0e38541f7d0fa0900cbd1c753c4e12c6a405dddc71fde28050d11af5077ae59fe5661e43121a6ab749a261c73cd2f06373752e7971e4a0503c415431d3eefa0e6f2b3b6e5b38a3ec28c69ddcdd2bd6e46adb9943e7c1777c7e51ece7dc063ba212cadc58623e889ab6ea16af085336e1a2e3bea48e74a9e5645b6b9768bc8eedd6d99f0ef0d8b1cb10606f6eaf342a5068a20e47a23b4f386474c0fe0918e486d4e2dafda722c6d93ae571b33aa5aa0be45bc70dd5bd36173f4c489fa070be4a77cc4c7094c1290cc803422cd3c24eaa8ebcfb7343af39f60b18013142e9a737ee39db4412bde04b9b06bc52f14661ea41b4ab16706ac3c501f7ee493453b4eb1eb719791d2a6922cd3bb2ef27988ada18ed6fe354e05869ffa42e46363e45acc426f6bd155de124f983e0b1a61a4f07ebe2ae3c5296dea274541da73765b321ce328a99e47156b7382d86d6bac1e7cccfc7ebaa2b12b6aba41a60a2585f13cb8cf07bde5942b49d27727c5bf79224494d07f301a909d5744f7676438077f5f816c3a542c3a3761c8a5f6a9080a4e95e9805d61816890d5a85dd526319b1e52ddfbe6ef001ade53d93d2b18a13f5a5839e8858d9484384132a7d7d00b21449df22b1323a91e3359a5747db276f790fa8fb26e5cb928daf37448d682c180743e0ea4e3142f710695e69e7c51fe9e76336a5ab804aba40d8a24493909f3eeda1e6ae25b52ebee8dd18a158fbafd8adb3200989d18b41f56b44b524a13f0792a43d71d89fd161577bcf01dfa61cbe72417366873bb68543b6c73bbcc69f86970214af2d76dd111015b9b2061881c051d7cf8f09e767a9ac67a0c65b77448ce0f492cb4aafc8cf8b39606ee2365173b01e02b0853c9472037ed54a81fafd6252bfca6759f049673c6086a52f042d40020404ee90dc6611f3293ae073458f6578ca819c810567ac9674d3f07366a7b8e44408b96f2e5c3fa4a765199462d087c0f9cc7e0f7c9848814cc3431c81ac4b8c7eb88b9dc946428c61dc2191ddb15dbc76023ae878d90c16934cbe6821748bb4410bd323bd3af9c74cfb69b6701f53f2b29f696debda5d7fc7a729251ce3057ea804f9eec85b06b7ded125384829006057078b1f7cf110c76b192c089d49657215a3ec8b257549f4a138deb1750ea81ffc7b4e3babbec9d2969569dd82568bb0e3194e71f54b8b16b85cdc0761b36d31e490f32de2c70972e18d6bff6247cd5d4e582ae63249a5a3f5563d398339f9e6ca7a5b139b21f0713f54c5737dd6d7b15544a61512b91ca0b7ab7ba284b371e490840b6868a26787b5ef12b3e64040d82a0430df12348f6d93d6c6670af85dbab206eedd862dad7ceb652ecc227337e8b8cabfbcbe0ab814de56646df4260f5c0a1f2638cfb41d59928d9c8a583b2b802f29a97b5e7e7b6c8499dbf2b653a1745f59a2ec8c3ba6085bab3276202538fc467029b5c4540af25d9cf4391871dc4449d49b25ae199e91759326ba7af812cf9565a7a901234823e050bea3ad5f3530f590a1ec1e1cfebac7620763c77581439be837dc37b4332fc0615e420303d9bae98cb8c88835d5f4918c6da3f5897c2828167d00e7e3bf438928db223398d3d5c544939383861c78effe724b42a4c98b73016fccce6450221428c8f135f592ffa1fae0b870fe8e1dbdce5b2596c10487e9425242db77ada37ad298fef733eeded1588ba0cec3e4085c40d2a26a6e9df6c78286777c98e8960d3dc75c95e081ad1e9733f6f84bcdc260a92f26c82199c6e9fd9fc20f0ac75e3065b5a25b0e921bd3d98bd610bd6b36f946817cd4846237995f596356468122c0bb1de70f78b92514211f6e43754bcbd95adc66a0ccef2f181379f0751ba4f83f34213e881934cd5297658334b25d8e09d245e358a7b2cf39a35ad4524fdb95a1b38bb7461505727f12b7c1d3d56c746edb2e059c4723d3aef2cdc2028958e8b453066afcc14f717c6e7fea074998f3f25ea8ef3a19258b4734fc5d519b7f489145c4bc08e1be614a84878b552148eaa971703e1409644928e813fab3f7ee96cd0a9e26fb4868be14699066f1efa6e169a1e09ccc6735600c6a9d212360d74f7090be1aaaec15945e007358fd51a682293ed5d0fdec47c9c42f60dd1c4837571c8d19a594f4786263bd87f54c1f4b80337925f17d86516308ecef61e8bbbf08dada1f2b8e23150f827a78c33dfc8d9d764e16a930f58179cc47bab47e321bb6444227c51243fd1ea34aef139f277a65b3bb5a13fe7368cd4c6f13b75654544c6e0e9e92730d08baea439144e86a8dcf7c206c1e008f893268e46b91ad582c8362eccfdf67b286897f4d12a15f5e36bef5f14c21363e28ae13fec7ad15337f3b20236f252f29858dcd84990d43f235f4c24f6fe31b0b279464e8d51714cfa901aeadf1fe1bc2fc54bfd58abd4a45f1f4c3398433c5b9c41ce35bffd927651ade4edcb8b9743e2f11f759bf1c0e3562f0886d04020397bb78ed9d33ac01b366d9b0640809baf35e22fec4f9711569d267c3decfc73b560e37e00e01fc52f63ef609b15ad5e9b8a230cb136791283602c101e84a76aab56f42135ca38029f676eef48e2dece3696b48528a7a34e41817ebb1a94c1ca79f1b919ed9da906fe968f1bad7c3daa519aef5f2a8b03a9a9c0cef99b220befee13bd18d1bfb2761f0031ac46227141ea41e5b5c2b63382ba08c1f10d4b16a5a761771fe763fd2cd17d3d5c81539fc4d57edbd48d11b54edb485536b9a46e3129b66b75d98261254692e2bcaf2c4e36cf5ecc8cb887c9b57b08429b0e09c98369462f374ba63dfee08a3171945b61adb17439fe6564141cb8b57378f730db958124a8921d5b8480ea7ac96ee682cf7f7fd8a1e8a7d24e7729e2d7c80f5e8a2595fdd0bb704af80f36546106007839affd852a74a6ff39084c8ebf1eeeb5be7f5f404e5102f39dfd995955b80dd35946bbbcf91f762e8f7ab32ab193a6bfa6fbe38507b5cc42f5904ecf91bf89e2cff7a884523913321d75ff8a148b06d06d2176bf46f19c30dc3a84ac530c76cbe61df3b5be57b094a66c774767de5828ef4cd4c2dab79ec168c8d63b4ee178ddded695b130b8f33cbb211b27283d92b4cb572ac10b1945d5d9a642e40ee4bb40fb505a93ed4c880fc397380d863627c40b46108fcff5c895a19b72be8182ac120ea597ba2825ec022ff53f30c0dc5c82b5a2bfa5477fe82177b1f4404153675bcee7e0fed00d2493af1145ea0275e32640f4ab0127863d695df9cb2e23b4750f7a73a1c664e88e0461d0971939dfcb9b6bf8442ef6e73ad41944ba64c1d5710012c21631253bc51595636ab5b2fef8e3588d9aa9f346093ff9b0acd01beec259848b42e3d2e0a7aae32a20a22be8d84c67c6da0bd7ef01310b8e39c6b3f76e72682d8aa352d0e42b7c67ac1ae7e8cd111cdcd663af04eaea81cb5fc713a5dffb3aed0a6d8ca1f36d4de5ce479053e9c837f6be372a8e63209b8ef4bf910e8fc383f08b6bf108b9df7511e3188d4b79797267f2dd3732fdf06ea173d0b5d18f93ce410966c1683d5b372bac6e2e11533d3436ae46fe8841abb5894e23ed25ee5298beaad6c4a80efb021e1826680ef075756391af082ff8818dc5a44770d63b8f8202cbb29474dce236b19d70b4ba33ef07285b92063390a9eaba2eba2e09c5e1a3f5e718df6fbfd31cba24494518a5c2a97aa3789278e8a7978b16a6d6816ffa4d8aa77a837b4533b77616a7602c8172b1743a54a2b6cebfa123284a6edcb5db2fa36551b7c6d279a77afcbf7437f3ffbbb1c608efbc24c447ca4d9234e851a8cadd1986b4cab7647ece176d4f2eb5d8f3ec8f89dd2529d6f850b925bd3d098d7d70413ae207c37cfde72aefde5f26229fb63b83bc341468e330f4aa2299b3d8d6fc589438f953a8a480633dc0dc92ae42b42f00a7357940f71aa233f88d2a66f136f0020b34309696755c3884d0c88a6322507e81005bf11a7cee7f94a1736559d5a6ec72877da77941c326e4749c4c474948f3031c91437df8cfc5593677fb0fcc99620ac75939e37c5fe1aa56c184bf85e2c8ae37f867e169af396e2048d3910732fde31de5092b342c8c2973b237d355bb044f481fd1225ce7dc2136f7a21b0c61fc2929007a52b8dd658b4f57ec95ee10d23abbff11e90c17301a3c32a39f6777296aec0cc8959592efb0d258533ed73ef6064be82fc518b023e7ca2fe119a76848e3d68287a738f37c1332d9430e98ef77280b0f1ac209b813ea5b8cdc0d320dad04a9f40cb8f0936af84e6fa1d6b0a1b57986f3d6e6eb3deafc2dde93ff9a07ce3c004ae260dd57280c911bdf899215d37681d3d5aca0db01718f64d7a8ad6621668bc86b48aa29db996b09df878a3d80b57cf1cb84fa9ee756ba09c3aca2f930e91e9f0f24832e3496e664a3c47841248764280d976d6183219fe463a7cbd5b973a1064c56b9d24558fcba52956cdcd9f209355b51c80f1ccf278c2df5e5c3afb53947f4a15b8782f3e8e9f3519519bb73a4c023a6dd1cba66be4804e31347d1d3c7ac618bf22e46ce63d631670fb7ced0b1dcc4737b223c1c6811566c1da8b89140292fea0c9c618557093b0c40382ac1a6832eee956a36658e28d018413003a987f8db2e956447b013188757cc9ea90ed617a40f47fea50032867b98d4e37cc899d9e50b32906366c3ebd5212fc93e66cd6fa4f0a9566886e059b51c4affebacb4388778dc7b8d0e4eb548e679debb914b94a30e2137ecbdbad860a2693eb5fb52e921fa6e4a11439c670d266d14bcee9b692d9f3f114d1caaf2823c468de0b4ab12000c216915ec96a2283c110f7bac92c8b0d29c00de8acb3a150b448aa0122e74af87d8b9cda05a58d4650a0f2e83ecbc3b2cbdbf001418474b5f0e361a4fbed9651894d5c164991a8ac3a7d6b8958af78341981f2d340f9caad8d65585207f44bc46073a35da70fd3db43f33a37731e9e0aa608cad3791c54a88f24f824b9e40920f9f0b872102a8beca292a5021f1143d05355e8e3532ccdae5f48757ea695c3cfc9bcfa2b3c827f3a476eea19570849bbe86f86a8feaf554334265bba1d23353beda97bb496d81b3aa2a664df3258f686272243183d457d54471f0f2f4a25b3dfe306bbb2c56abc57aaa77ba8fcc121063ccb5d01fd2669b184538744629186ee23c0d11ad49ede231fac323db28e3f4c1e9cb333881653a39546a13db548e29b7d2b21652b814000797ee31bf288a9adaf8f67100006acae2e0ad9c0f399ea50dd4064a8215a69b6254fdb20adc5e3df03317f52d52e7d6656e89badd76dd02f34784879501c0bce0a77e469b08a55293689fe834f8487adcd2380d8cc4e342b8f92e165b981111b269ea7b3b911f2eb5879def51302724879584a90e94f11246b4007c1989655b2a8bd77cb9932b13dca9c7c40850f8264e9d323d33a7b5bceece71586851bebf5b63cf2fb77ab9cde5109d40d5f7881bd29c37526416fd2ea5225944989cd4e2844437e3c47e6cd26011ab77760e329abaa1fcecc3a4756243257f4d818039ed6d3289a93d41912cfd499cdffee3b34adede5213fabefba0bde49d4f0ffdc72723095a18b9c9950ed6798d6fd1bfed0eb478ab1d247b5d28c002cbe9fe165fbf06750c404a62414ee67be84167363e7de36c4900e4aa414a1a9878dee2c6daf76351f32364564d956b950d3f1469ceb39c122033625ea95c9e57ade65ba16ebf655842c5eabc40f863de1ba0e093d6c6bb789a4069291692ebd6080a3ef6d26df82f3fda948322e920fa1b4db3288d23b98e87328cbd928d9d63e6d3c2086e8fd215980c72d1f150298fe0d965583342499064108fb851f1e147e6b759addf9adb0f94aceb5d9ad03606c018a4601c93d58820a7f75e5b6433053663d60cb1e4b47c681fa921ce035cc61aae67a184ec6c20bcfd1aa6cf3c8785eff4044ecf71801e5f1bdbb8e470b2e9f53b1b04a7b11a7ffd2e73db6997769670fe79696b623b072c6f3bb06910b1385692d7ce73f5686dadbf00ae20b527ad2f2f5763f792c10962c13f0b6b1cd272db9004554fd844a759997ce195be19144d0fa5f70b6facfce6a4d0ed2779843745991502637920d07598426c2729abe3797b4a786a9a992a388476cc3ae3f0393e981fb9297ff8cdc24e3b0b4d22269c2bd325d8571a06a976fe28a5f7d169b16cbca0b4815401fec7be85ef68d0eea45ff40e929574f8e251d79c0e33b324cefd82838c0dee665dc86b46c833577057845b6e8562bfa9a96b56b8531b4de884011055964c40424416ece716a13485182677c834f32f074eb735cdda820d3d56017f889a4e3cb208a85c6cc2b47f147c880eb7b1aee59162cb280a0dd39d79ddf279dda1142abeddbb7b5fb8a50f813eb7a6eaf4dc9050a33fe7403e2f43f122df602885a6b45f8d5837bae45196a83e3178f79552a1bd399dfd7e4aeb6cab4a2a16656d4a9dd2ea451dff6b1c6d30df94c8d265af5f5cf823ec7b7b33f20e3ae640f7fb7b4c88938490d14477d0ca9584d7c3482170cd6f4e2ea2d031c109bf5ab9a68af25628dad1ad4ca820b096e6995873d2fc348141237b6f8c18d8a07a40ef41d386e2fab14fac7e0cf8c04f0ac7653422f47dde985c0a3cee0aff8a89278e648945e008c9404d4209702b7f134c52ad8f5cd34c867c566649eb3bb4717cfdf8e6541b7e1ada8de852fa105e4b148d07f15e92ff7b93d35c3125822e934906d96b54f91ec2c8ee3ce29087b8f3e98eaa5ccd3585f1d54966c972e9c7512cb53228f1acd379004a683fd62cc5a52f55b8337b50a7c1dfb68811c1d50d13bad91cd93e873c6b12229c5ccaf3837f580191550fa1e7ba8772c82eb6ee8d9f2ceaf79e651501c3e37417dd3aa5573902f9762dcede4fb7be0a6239e5bfd1ca86a0bbab68af7326c5f1f2526dcac74688abd144a0da138fc40797511fa38e4e644d3692bd61afdc2faea9d65a7e64482a6f63df975175e4fcbda427f538d74e849896f710326ce3cf54a4774f5a929ce53103b99f206061e51788091541472f5c527e6f26f244687405125fedf4422d77a745d528fbf20cf68bf5478b49e44201194998e7d0a9d73c02e53689b5efb22ccaba23d40046bd7633f1223a27533534c67960a9621b5d66ee9bddeef82693397823c8e60a718a7aa0ea76cdbb08cbf01646572bae5826b23ee69b94d77c12fb338dc40a3afd0ae6460bce3f2197b4f098811d6de4c62a2997a9c63da215cb788b7e4cd1858df7804d8ffe5491c888f639355d223a756721568fa34883aecbe1b7731d03d5724958086e2c24934c283e2c0aa7feaded78ea0872491b6532efdb2e496d143853120fb160b3b7c53f0b1d3c755d9e7d35dae27033989cc493469d34031ce3decda377afd35ac2386e041c7703f86795730c540ba43c963266d29dab3e259c0dcd56c06c8bf7bfe332ebfffed8ef3e5eebd29a7815d1a4f6807d7cd1c3816ad68cc51deaa763d95b53c05295989cdbc09937368c843b4cd143289d8d55224498cde0a76e1404a604587b82f4bfbd9b9a59a3aed376d15930838e2ef89644b3617884c6717bede1d2d601e8e79de5f88699d05a06ac377e538927cb108e1f9d1e77218c2527a459666390d44cb3c084585f19a0d146b4535e425c50273bb30b4ce250eb47230935fc907ad0c2d7921811545200d2abfed7d1725ebb7c105d9fbd7090f8d87825f16efc2ae04eca8cadfdcb0b0494fa69cbe98da3e2c9f6d4576b905b72db5223ee8fad284bffad2c4585f20d3f52b3e0037468a51f0731d729e41d184847c1c6680251437410226ce03df5c5a5b5faa07bc75d8c0f9cc3d0e12069c967b829a5b1a10dda386b952b041d589aa8e6f2afb652c002372e37c53543618ea8466506f0eeea20511d4d0cdd6e3d87e78a222c43c5effb0870115ce893a39652af71ef3a40446af4e775d05994b07cd465e16a59cbedda57b7e4d6d8466c6097fcf7d2293b3be16af127f5c8630b3e3ff25d19218b48d5893632c400a0785c2963be6c1c9bfb6185791ebef04c6f8d42f49e72a8866f1c2c9ecb597af68c06a0a8d8591a3ca4c442d8e5d1ee920a0ac916657e4c3b14d807ddf3ec86aeaabc24bdf40c67f573e3cad8d2350f32f814d625c7d038aecb59e448cf4acbaaa22d1e588e39f102cbb39ddb89159c2efbe2575b20ee89a7ec356c6d3697d59fe87195747325c126384e2debb98b50d481ba4b3ca1d51e543b37c3c4af1f3b9823353ab35bfb7d7933e033b4544a75f9d980080b7112687e4f78e253157c3aa4d70004dd39f86e4b330ae46c49d0a9b9d73be41b649b56266a7ad3ce99810d1a2f154137e8efde4900191c503d2b72274d86e793e87f6cc79de7dd8375eb47a02ec2a39772748e93f108ad0ecaf4f1debbc62cb9121c3d417b53d7967fe8dc5a3322fb3060345fb161073ccc58cd71dcaeaf893e40919166be954ff3e17ef99df2d10f26c8b648396d3e1964d1260173cb3cea5b386ead0d65b47ec7641372a89ac8de5127043224602f1ea95bc680bdfc14071836b7f0a5999ca57f5e46ffacf153b1968c3ae9a2708694b556270230550603f9bd44abda25fe7f4e7f2aac355c6bc3e10ae968e32f0688651e16ae7928e8857c7ead921dfab9b1846eac8e1450867fef2debd61fab2eef4d66a2540290c996b573124f4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
