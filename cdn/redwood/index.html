<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d31551b9fa6ae4f735b880dd1d306bd19de448cd3946073540f9031e883a9497fa89218311d33516eedb8ac99fd56fe074f831b46bbaf48ecef56f369e8d2ffede139bb230dafbfe8bc9dd98e2a8a4e85c83a9c4f4fcf3a7b58a077d9dca2eb3f19f0febba5f9944b3dc19b37f9a4446bf50dfd60e2cf4cd0f11f72447dd5709e424f0e14c1c6c6119e8b18a5918a43952778f444ed581e79f2806ac2e2ed301682d50a4842c12b24e3f82d746596fcf2d5f0ff41e5fd9382267e6ec5a5c806ebd170b7d52b5bebc46e8ed1ff3795f1a12e0c68f7f8a77c6f35e164c244225076c43def9d8cdaba17bd253cf40d9e7220547c18875c1c7f7fb7d7bc490c13962e64d577e2ed73e79e1f7ed1e2d8fda21fe096c424a6c606b2a3e35183e43f2d730b10b28bedef4a6a2d0b768736dc3ae606c456983842bc0fe2f22d7ab6ea3f17b4a1b808fdfc97cb8121cd0cd3e68028c000b434073a9aa0cbbc9d79470d8385bf20d6f65b30a78b905f38bdd7410d0853efaac776892e27a67fbcd34d71fac79ad592f7acfb163e569f3c13af4059135d9edd21bf809eb68d2993598946797b8acf31ba162b14316bb1658d0c7f51dc445c12d90e41867b6db08dad8a9b3d09cd3c29e9d3678e08d717824dfddef7487af2254c1cd2c3285d08a47c1a2508c72a80a4ed0815de9ea9870d9d7c29c859aa5859d0e8467fe4f39cf3740d669bf1b1efea30a44daabb03733e36b4c6bb86c8709150d5e0f1611d9b4f646a35005aa79d26a9126bdb635203483b820fa90bb76430e008ca4ab840ceb17a9fbe55185b7c3f97dac961fc9998dbcb25a040dde17ad04bfc05a55dec29cd8e1d54d9a4db669443f81fe7e4cd2819ee93df614c1e45d1b824a73c5441d897da1fcd99d01b2db79ea299c1260947ff5044e94a8d9ad2053bda3abed94b0c9f8a4bb8d04ac070da9adea381e40ec9b98bb62e2b6cdde7bc3de643ea4777065ee9e498f494e95bbbdcfcee3cfb57992b00cf317e183c33c9aafb5f5520a3046d66b5b85f4ca0dbfa30027b6f425c4c27840307e64cc4679735dc0b3d806016e0002d19245338aefb5d1444bef5de87f4556e474f1186b02d43a0650329bb533ef9ba978526f92259ab60e6b27df7acd6e08f07e7388092f1072e32c38186a4ea1e38e6d4d705e8581badb942e1c15da1dbe20bc54df972c0b8549bbf03193d52063e75c8cd276a82a6347ee3f334e1ccacf392635ede7266857fbc7e00a4cae95aac07b13e1cffefc8c552cbb6080b0765897878b13504d9b0eb921eefb3ad39358ad9ca4bab0e5fa6ac597a2d9cd9cb4ade2c5d97b0d5d45afd68a017dd81e5343604790145587d645163759db72aeb17bf1c90f04996959ec53602d59189ebd1db867e9f2ea2df3a526e3d2cb779aa23b80a55fb5cda68f37bab7a96e50a172879e0e8e8f92ddb10ed46c22a4ba5b556b2ce1aceec24ce1374db47323457bb61400686e44b0fe70df26dc923708cf01b586ab2d1df1e02ab8333f4adb8fd228ac98ee37c2d1fc597d7312837c3f1ffa5932d406cea9fbeea1a797e1b8c1473631d1e5c8a826c7a412c195207af2a9719005832dfa4d1b90d6b9356e38c3125055fead6784927cd5d5be809a26d107f21cd7920ee0f74cbe8bf54a17438c660c535cc0e38c2bdb5583b3d9acd187482fde4c4c01b9699606a69f466bc7b6a9caf2ada9ed9e62c2e4f70c977110ac9cbf622ffbf2bbab92ccc3eff612a91fe6aed00ac028d29784bcd1200d4c448a1eed737c3cde3e349b153a85d7632121a0a81de92d8c8e88d33a796d50be21276c64d9b05a2f65b782636715372318302467c04cb6450a9c612a8dc1fa38f0299713071e621eedeac63128a1baf2df9468b9221705694d9effe484b5d3e302ef4e95db29907e96d4e6ffba0405ca5ca6b7ce94c69d95fe5c94a4f8bf803567f78e1534d24184eb68c66ad2a53f42cb30a1e93987fafa07357d3cb9f03a71d7be76803ad574e084617031377f18881617b217723433ac81ebd7267fa6fe5f8c9896caab6da7b5f4fb25ae04308863d668551b31d54c709bd39736e5581fc3752db0f3345848f7f167a25e91678e39fb3d80467596d28794e8629c355363594de112bf286c6989d9c5343302d76c80602a61f73196ba23def6dcba421471dea82887f06bc4b07ed31d0f7f660e0a31b49b14271be5dc25c6f0bad6ce2a8e92325b9725fec1453f0d8d670647c45dad5fc884a57177da42eabe9d07d7816a9360e8d2ff413eefd5e8979af8effa20b57af415446028e6cfa37d0abc5ac88b567f0926d4570f67d8b9a855efc1b6495b7c3484563b56e6be23013d95442a3dca160c798614da252ecd8fd954a3dae1b24966c2eb1a98a8a2b5e28ba970ccebbbe182ac09439f546857c8039d0350a85d21271151f70c0379402018f4ae630868b76ddb43923105416422107cea471ae27c0760cb17041e949fb1cc78b1a47354473bb0259338964d79e8d31fd75677e63e5bf5fdad6fb2aeb599a894860a81d6e600dd4b6db55fb70a5bccb7e2ea14a8cfc15aa6896b27bab2a9139842a8c214ed1c87fb83b3276a0d379a89daac7a939363273dd5092fa308b6128cace60a82edd0db2e29bdc9772a90e001cd1cc3f11467bb92fe3c3d2c132fbd84c33f1288c6bbb2c2affb7dc5647117f3eebcbe7fad8de83588bb59026bd39901bc19cd55dab5915dc372009d5f340af07b5525c60adf849d70698036a9f08f9f6a8479750d169c8ff828bc4e2aa861174f3feeb0e9deb6cdce1ddf0712a03f57beca18dbf68e670c3c896436b2df706cd3cae6446da54f6427f08ea177a95e78c8b6518a4f7d717d0d107b6813d67f4927da3a338dc141fc3bd7e79a91e39f3eb2a5c2034962c74fb7e3d3c091d0e5428d1af2f680732c6d786f4420645f99a3221e5b8c6c264ba343c4edaf0b5831630ca9e222dd583fdb9dcac04eca231c8c8f045396a4ada4a12958d45207e3e612c416d1f4e880b47df2b4dadf9097fdf666c3ff4441b15aec80819847e8ed9e878db0d5e23eb79571ade0c8abc3e0a78a5d90dd718188cdebec5bdb3da5f6df043e7990dada9e5c44f711dc3d74296c0db3ea292272bb0d0c970c55fc7d133b60723ef86b6e4c3f3be74aee83e67ecad966842ac13683642dbab12b47ce892a1772a161d8644ad8cd78c04b92a2006e50bd3107b2caeded2dcb0ad2091579e69ccd08115b2c4dc9f634fac1c4a2f6bb7152decb48143486c0347032581c34e2f2f7863d484e271b0c8f712a7472c6d4b0a20e68df55487f396dae41c008e92c6a80b41e45ff56b342eee2b43be339dcdf707f8b47c8b19a67368cc1291ec12632a6d441fe61d75c751a1bf95d7f08506a23b43b0bca96004977b3c0634c99970bb0200214fc59097e09624b7aed584b87fdc4ef6343846f3762760ad7fdb5d270d66ecee5c4ba8ae8c20c794fc3204f498a2199ed157f65f5e021eda045c5fbcecd8acac4e90289c7e0a6c95009727ec92d8ae2deaf618fe9632b6682f315fbac785e9aae1d4296f366b5f18a41342d297d2f96468d134102a4c224a8addbdef52e124631d6a08cfa6d46b1483d93fb24524079f7b835978e11f92f3407f1846c51af194817325517ae3c6ebb468fefe78225c8f1da02d97a7b398bb3cfeee654759ab6f4e87ca2fd7ec833de5b42d2fda73b25835320efe43a04c6603d45f4c3d30a3b4305e69bec6c254b5d448ebe44d4413154fa5cb44a68e8e2645e815e61da3b49adeead53855c1e4654db353712a99f217761a985200f7b0ae3671c174a9968da5d377e3720af42bf3249b5f81f5ad762e316d10a2498b6392d1583d019cc68c71550a1bc8751d51c97cc484ac284a0fb7c4f1eb9860ac1f08d74e5c51c6c859fd416499570595b4632aea9dd1f005c04dcf0458c80b0da2a0bd9d25f3178e724769de21cbf1f14af13c0f58aeac38927b63f4e91e9a890390aa81acfbd68ded875f2cb9056ea9f759d364a449b63d7bb95accf776e833bb24dab2ae82d46b88c8011a4d9f12bed6665c6d311c619e04abef5b05d111f4af08849647b7b77662ab20eb1c3cf15f3ad232e003acb2b1ffd5ecbac1b7f9bc42d0992dbfc5f2970ff2d95212a0babd83953d320e29aa014f0628dc1debf158513fa47967f5f45f27fad8885fac215d71d45562afd9cfc225ffc2bb7c656e0623180a8648f10e17461937d005e06cebe49c8ca339b96529b53f2931b4ebbcf9f2ab2579b29ffca341cebe249042f8597eed34573aebc7f45b493c7372f9bc7d2168b7a8f8d87e469104c3debd54b9400a5a4fdd58cbcd2a5fb4beefa20fe72961de3832ff08f6caaec69164703f2b6710f6d1f87511c9b1900452feb0c88e28c25319ead2c98203067869be1f822c8f6217f895a563970b5a185b8ae74837a34644fd3a74fcf484d2d7e31d42c7f2d3d999d6908c1454381f0744f87861bc2aa8dddf0eda4ddef3bc3feced6f3c3d06ac66f3087d3f242cbe1d660858d6db2a97f30d53813047760b4ad58e7cc5fdf93fad64329029efaaa7c9dcbcfab496ae7fbb66b0315d4e18421d74ecab6b2e960a4f679731841bb83f92bd5daeeb135e011c7671f27db47ccf21b3578756f31f710052f5ceb2059eb66612960facff18150f12c663ad5d1bdeb27a4d9d3b4301a0596a422b4077edac1e5fc3938a2aa6170f7cd3cf361dc81f64b35dc5fea6baf1aa855c7bdb481e6a2173e6d6fb124f8c9e2b860f4c8fe5bcf4e238e36f7cc8bdddd5fc52bebad00639b41b4dca3c5e264b91fb341b021781558d1c18c41c3835e042e190ab9757699263696ace3b6c772ec7ef48c37238b3a71036066b05147cd06ee3bfa1dd5884623dba5ee040f0e7fade44638dbeed37734a456f6cfa242763dad37d2a561995843e97f1031e8da81768a39e3b4ebdde1b986438793c301a18fcfb1fbbbd0202c1db9bf2774c6914adf933d2a1240a0e8af0af1d84bf49f70184bd5a7ea2f6b282cc3355f280b486e66168bc5766475f98a76e5bb5371bb6d2854c01e8be824094d4892851e96399f878c76731481653eeea4c0140b29c44649c68e1e0f7b07cec74dd813a3b5fe72955d24e79f7daac7022fdf8825ce2e5f6635b30b745a3f9630039b7ace7fc1b10fc7690210813aec9cdd2bc8f3599875549d2071fb92cdd017598ef43303dc692bb8793fe134be50f517c9a7949c74e6cccb376d783bd162756d157551b19c056fdb8f3b25fb9caeede66137ae703e73a741e799c243f35cf9bab17a96ccc120bf2fc71e0633e74090ac3bcb70025120c8f298d54da134739ba6e96149e1a4d184ebce16d3d78a0c52e758e885c9e37db4c8ee57aedc8d62917092b304de2baf61ab05897028f9b855623796153d0537faddb97f35d5ab83388c420b5c538a1b1536ae0f9f24a2f14fe5f368d817adc66dd20ac5c8b0e25c0cd6f19840192cab21cbce373d2b2836fee33fd20578377b31bfb6e9214658669b6c31a42943c18766f8af0e9ec892dc06f93a01f2ff0c1c6bdc1b0431fcb08a711ad347500fa2e1e54141228cfdf711546efa39a37ab57d61f949a1dfc8fad45596119e20a68ca31c49374aa851d23b1ee67689539f47aa5db8ab4ef5e344e22b6183d93ce7284de57ec8a373f0994d3e722fef44116aa3eaeb4896383e82f47922b041ab6ae8fda24e0302ed7dcb47aba4b29e22bbad42d58fa2caf1f82b87bd93c86e7b7523a927acd3ffa3a1aaf3278d32299e9535ac3b9622547f8312316567464f1341aecbbfe2e4dc9f079d70e5526660880209a9839723aebc7fbaa220f0ec2bd92c5f1043747acb210576e2db4e022add0e8b8fa0d69616434d596edc62bbf68f9e22ba475821e9cb5cf3a4ee4bbde4a43bd9fe36b3d1fc919c0498b1d2f2a7a843fb3879dd18146aef1675277b7e4dd92a71f431cc746a5613a8e675877520ac5644d4f328d1ab79ede814abda7ad3e428df25069b03c27cfb70d3a56bbc41bc44ccb094bb74cd3e1e5089659283513d817c240bf9372140391ae2d62663ef297bd98717b1b53fb1046561558602624e2cdbdbaa826c71862e7b2f6f4c517b1629359bcfbe5ff852d363f79e5d621bfdb21947f4f232fed1fc595966914ccd3dde5061a3e2b52256b37f301c55d20d03df9177351d3216990b2fc3b639c56de02f96694032dbeff4a41dbfbe97220bd940dbb9a30b839fd846ceae566ef1a0be03518cc718d1dae1d85825b7d3ef3d523183e370d2826f63b4c83a994e83f4305aa101616189331dc0c0dfb8538925022a87f416e98ab1fbb1359bc1f8156b0c8e5885403724bd08740f2becea65aad5156a6f362d0b03f2233ad3de2b63d543ff4a8a3c28b680039fd8ab81dbd60a902996dc954534e840cbf5ec2b75b39908579bd59239bb058dd61015f344bd709f8b80f3fbc7399ae150b760baf9b1e201d3f2917f8b3ea391071c3af5259f45b94cd1b049a63b10b586247be9f3a25fbcb4be7b219814c26c00d5a60ae89b6cad9f5bf2178ec3ab158efa0555505c73184a3f670a83763faf220541aba33b1a068f4ef332f4c6c1aea8e2e37bbad7609c5ab1223b1122e4855f697685f7d168b8541c2749b6a8545d5cad74b2008cd554833d8694571687bc63b62819738eeaabb861a3965403019c2fefd9571cfc06d1ab035e7ee9d3e09a5ed810ea2fb63c017e771a114275685eff6022132c1ad7a80db5d25a0e18a7f9209c9793173e7de85c4834c6bdc2c0e464fb521038de5264b7a1e38baab00d41459b84f1f64a8be9f3ce0702453265744ff7829effed9a1139e281e6e94e5db3dd9adfa3712791495a22439d38280b98a6950508532dc540f055a01dc1fd5a3b4cfea00af922f64018127d9bdb7916596964c30e0d031c3fdc71a9e2ebefc44ebe4254e4917aace2b63b138b157b79c30b1a294ca895daa5056d44738ce3243fdc10308ec6c4fc77baace935ee4cd978f0fbe15dbf3e52e40e911b29e6fa0d8652e18afae050367166807a16f96148f4937fb9460c11dfbf48c121c3f47928402c7c1ec9137ec1ca76d7be4f9149401beaeb810d61916de659706e055bceb7906cec391b14f06cb5e0af2812f9e6aa45cdfcda6c78e917788d6f8a4713d6a6247e170a1640da9e6c3641b5e6ff8a41a6a8a446174455b0418fc62a93499d11dfabd434fdf21203bc1c4fdcfcbdc300858724593f5d08e95e9eecda7c7f692fc46f95cd2f9e6f07625dc61aa1690a5d2a6216dc8e2367536f39154444cbaf767a800a26fe797b0e7d673927fb9db1b88662f96f1c2e3bf150a97a9d9b869797792067f354174efe9616fd90aef9ad49396f6a709a608f16e78e5889546fed1d410512a43960015a4bbfa4d2dfdfaccdd22cf98578374d3cd24066bc600743fed7790593b552b90526005ea6d754ffbba6abdb689f4ab5ee74d3c49687c5ba8b22139d0251a50ecd88696b28ebb9301c24ecb6921eabb9d6c30235750e44960068b73614a4265df01daba19f7580873a37ea2786501c829e8f78efc9b0fca55d5b937720f62d28bf676d7b721b3bf48d387dbd045caea7d117f47f85ec98dbd94d2481b950b1f4b2f0e10f67f225d62c1aaa394fd32d138b329b9a98a925c7a682235467795bd90902b66f2fb927034b0502084428d49da6fd434ea4c287511dd5d8b54fde09e3b4f2f9723f1f02e9020efac6f8b08173f37c85bba8b2355751c4b54f28a81d7180a9b71139fd3261479867e2e9afeb6f0db0a7feda3f9d5073088103392ba8beed6e4b7ef3553bb46d75fba2585ae85c481764868a8f2e0dbe4b29aab25ed15b068e5e77f32abd17f3519fd302ad0257bbc42df280c3123b387fbb3842a60306451caf97ca744e06740eb6542c5d737535e16000a0a49b9337d39c3c435918ddf44cd562f2a09720dda3162d62cf9a45fa26e88612d07401837d3b7312a2ea6ed488685717d47cd6e2ffec4bb6a1f12b17e5ecad35d045988cedd94e8e03198070a72e8e292142f5d8e15f028b0ed98b6ebe77a523bbb77aea4b4539a61ce0666e29292414b3378a33aab96a68f9ae4a4bccb7f65b9be0051cb3dc01c1ecde7dc5d0d4faa3481f1c1bc1066fb63a797defe7040480f8bb514292662c4cf71d2c535613d6e634060f88b722b089bc1363ffa9add1ba3da0399c8a8ec35dbe430bd788b4e08a5b804e12588cc8cf9cf25dadbe80b395635cea003cf5e0fdd541efbac41b1262e00a5f632310fa74fdfebc23b00ebd93bb91fd6658f79c3363f960d62b411ad34b00e72c19c5c157dae5585c0820f883997ceb12cdf66efec39cbb14e21a9d6bfefdfd75ce5715de8ea64db1195658508df31401db6a767c1dd98ce18e89f4b31625da62754044416f9730dd346e34e0c971e5db6e1a46fad32a72ee526d63c5d0dba046fc4beafcc7d985c9024450e1e866a716bec9dd399c042f273a69e8ee30701a6beae0229c5c552f95cc869768a80610bc9aa936a2dbcec61664f82509bc87bb1e39df9b430adf25d328a473b4a101ab8362b62886cd3f637d956ad2945c0511debd6b2cfc1deb1a3702dbb9d61b55fcfd4b501805077ab407874d9e964c25046877994489de1a36128760c404752ecf490c5de73ac6b9935ac2f023742bcdb825ee80b10d5bec5bf10051259c7c11311040f56dc2072a573a146281cd6cb4ecd2a8fbcb271863e3803b9005e3a9709f5e5660c77580e03fb247295edd2c3d5bbbb3096678cf2b81cbec98ad9bae86b2520dbcc5a79dc3f6e1876270764d9f4dbae95fbb990a60539bf12a73246f8c32267eefb596b9e713dddb73c89055a7df4b6e9cfaf80ad4d21b378b8336f808ed0fc5e80e1769ab754cb5b42a725447b0f620e3d1345c71f5acfd33ba62df5bd3c9a6f241e8cef0c031b6b1b09a697af92740b7905fe03a4856bac225b95b6b4d61b9c592b6b2b63a4902e870b14d781e5d77d16090b8d06630207fe5de1d0a90874c1195ddc3993bf2b9737159fd9c8a5c483f052e2a2c2cfa01b5ec9f349186b52b7df9e7a27ffa0828813ae98192c61d2e459b937f3aca0c0921be32db6233de1aea83840ca281b87a7448c4471e0ba055e395087dffe58617cdacca09400bbf3ccd4a95b7e78de6ae6292ff2d556dfa6cc4fc351f85a4d534b13852e559b10e8791544f33e5399413874d46efbc8c1181d691742879dfc4111aac7281891ef6669c9cd4ee1a793c16c612972d2ffef58b3cb22a38a394fc8232d9278cbc91b12e18c5eb4c953b0f7d1c30affcdea159b4bc84a530ddd7b21f132c334026f0f02073c66f0cd10c75009c36e2b6ba489817f05701c93985114e0b68359be6f45ed849a2162182d4a2d10d643a6328d30d60a34bb683090171e9ba2105b1f8946e2dcb7933469e25ef4ac68d70a2c8913338da679e22b9ae6e54fda577a4534d3da529b4184344831b297639a605c4b1812b475aa9b1be5f379568ed864d7a5042153653604484536045cbd9604a70031bb702ddd332d59545990dfd2f8ab3ed433153ac32a76f9cef0d84b2758c6ddac49abdbd2c64a87ec510f41b2a694efdc8003b1b748215e70e5d9f56344902de1894fd708fd3d1b3749d4688e879cdaed1606c6c5d76c82f5089610073bc93461d15f4516cb0fe0a0006e7920e7866bf72177d884235a923199b6bff7e4466b567df9bec92ebab310ad9718e7d8bd6343eae6e7a1f2e8efa41edda90e6f4883131fb33979668addba3f8c1605d806cfadc48f61ba9843347b5bfd477e933861bbb1176223793802562629397632b3980240879c6e07e7b2052ca874f03f8cc58ca9333f542b74fccd4d1d195c81aaa4793ecef186e63604365a3497779fc7fbf93f9fc89dae839aa2fb1931333dd39bb7a71743e6de29dac215459c403c626df11f01689c9040838f012dda15e732fdcffb1eec7e1073d20dd81b7de9e5728c3ccbeb4e63bf59af3939e054e189dcb127d389862c1fbed63786e33f61ba6f80f10ba65322e542cf00e3493d79853a321e4f9b7a5593af40da7d108be0986517e838480ac715085a356e104815513c6d69c96780f92dd52a6da857f03cbc99d5e5fc3ba5ea072afc4ab7efe311be08fe8725f5fa0f81dfcb55b36c4b8602a3290de921184391f65a2a6a3ce9aaaec2e5bef262d82acb2e6cc9472404ee2c4853c95c7740d8d8d6396991e9a8cd9d73b817cf68c4bf1c7cb5cf77e6b7723ed92fe61a879d08e772d0e33cc11c4aad4744c29fc24a7aacf64b346d14be1ecf5dcde915704673df8bbdb78abe47ab11cdb3840d6fe93f2de0312efd9b3cd46ce9109f5ae3d65f9c4cadf4e27f7f2f1730e508405925bfa6eed0dc0586a2658c039c91c2ff43fcf01cb93afb5b932cdd40274ed2f4d4bccf45cbb0015cad5d67cb1a6e7d7e282724c4d3323c80e653aaac6e7d8c474eaf7386d4d86449ba1c6c566f0c788059fba511df70389e804151c8ad6c3f2240223b76bef109343b681b3947abee0a79f69b892ddaa07e486a39f5bf3b584d04ca9242cf85c860e9fb01e6a7f9cd3ad9ca84ab14c3fee2dbbaad80f8890f653d7303a2b28c5c7bc405b68ff8ea8191ea99e4932326d2ab8e199ae6070e0d437488c19f6944003e37779e29b0df9a34c40af2b502fb48d193451da37085379908d1a429d771545ad5b0e8d598b8126bac47c50c0204841d7759d64f24f30a3194672aab39193eddada378a11afa61b27afe68b3ada12fabbc4a10cbcf368861f4a7e39e31064d109e54b52aed0db10e45910fd4037379472aa9441d4cb7689cf3ba5c178ca44d269557a4ca016802e53c36b399a814e8ef900e87cd4b12d435ded5f077e4c87952852b61b3fe72dcef8bbd512ccd28d30a21ce62458fe8351fb90d60f86731812dea2e2d4c6f81c9e560111be6039d48083dee39b8bdc474188a987b97ce9ded7d01b4011eb6e51bfa097a635a77c566fe33e4751601b18d4e932e839acebcf0f3869a9f0cc5a414e83b19ff3e00627b4db79ecbf54dac84005b2eaa0cc21c99314dffc836625dfb60f2de2254a172080d97b1dd24140e20697cd599cd4c95771d5115fa9089f26a8863809ca444dbaab3ee472845684c1cc7bbd3d9363a765a65faa64676c95bdc6a1d51cb4d22ea915368a0a0ba81c2b3e6f06ecf9801c8b017ac0ca1ee3c0bb48f5a33c50c9f0848b194b32e416932a3abdca54a6bd3516233fa6911a8da72bf407034527a3614f5cfef1387c69686b9a792d1e18975af8fbb10d86c2bb043775ef8a21a7adfa009664444ab4ec28e8f6ae4ed8d1780315e3122cbabe7a43928a330c3d75bc101b23cca8c79027970fe7a2d54ef73e41a2ba3452d4fd68c9ce3210d7a6de39de46e1f8e32d55025825f6a17e9a176dbd5e70e27d64f839e29a1b6f0d63769a69c86d9aea8021c5594e471ed2a16ba40ed55790e4204ab8e2e5ec2e84155c67a63a753e629f74f7e48d1380324221f781ce29be02ddb1b8958abbd06c4f65428b9da9f110ee4727a33b63d1bea2739b16db881154f215fd2677aa6663f4ac57079c6fe1dd8533988317f0210fedf52850d6de94a7b6c2867d565756d8abae2a56b07fe878bb21edf9787f0a105a557d67ea55e777c482b57d0807c425e7b49c7c4d09fa2ae418dd3c5cb6cddd78bb486c81017ad1c37882d2b9b5f44039b73bca4fff3c70c092f353b9df494495b09e9d915b35204c4d57451cf18fe2f92877514401aede6834a9c975a5019ce45dc5d790579d16431a0e74c12228c6d34338f5848bc51113f184920619347f696e82fecb9917dc55ea76187d32dc6e832a26992c23401878de1efd5b6726cbef2e3dc6fd0d56bd76ea2cfb754bce811888ad57928c788ea918f3bd20cbb7ee4ca99869d25d7910e8e2244b5b72d0425e38bc674ca657594e68cdb39858cc3c3c29ab70ac8a19bc41951a39d675dd2e67e6de47549157ae70e8a7fadd87cbd4bee7c7662a5cf91d3f21f8b703190a92614d2ae93be96757d44037ecb95589a34eb4c074e08cccb1b64071091d0e84d252defa1eb29c45822c336b31f6ab6ddb62048df185f2f5c86d6b0266688ab832c25ca209d5e94bf17a033c05b53426a6a5faae120918d15923cedcf8d52d87bb1044dbf5d8e9def14a233fd5d9c6b05e7372bb1d9b74517f916210fc0956d73621dd7c30a96eb97e1c1da4782da82a51e582796f4b3ab0229d740c9fc8e2819dbdf6316c7b4a0f371efc0630064c812e6f1a65057545dbb4ae2c651c0d54470acf2fa0fe7db46839a8a046daede29d485a042753f376cfd27ca6d54a6d307cd923ae9f7a1a2f9017d3ef88b3b58c2600d2279aced25ebca9268fb5b40a27de45324d2721faa22b3c7c610fac19c62fb43e13c1911e35bf6f4c6e311d1a6357536ea3022ff728e62c0d20e4bb048c30ecd6eda69a1537c0cebedd540435c55b102a360195753aee4c65f6d77f80a03bd1238f2eef2dbb2e82553cd61c98d4c742b9ea2d88e878e58da0b575e07e420576d3e50f7817dc999c415c8365a9ee9e4380cb28f8765001476637a6764b8c97f045cec82a15cf535a75995c0c9ea1eff1a5ed41d8db44e563ff22462343c00fdfcf15afa67860695d23a76d5d96ac0301bcec895530bc0461403b46b90904d3768a17e66a562ebc4f9a71787bb86b8fae71d663d43b3b136df57ef4d1d0f8fa4cbac922016a59434ecb73b041936cd274319ab238493819adfd9a02d5d01ff093e76c08196242b81f8a4a8219ca2368749d74db3d7028a4af654e73b085fccc92c3bd75a0a0b166343792e17d7d6f04e5f272164ebff884722424ea05ec6a38de9c828f1a5ac4b10bdd26f8963e44694dbd8bebd273c1c911dea79678a780c8550831d3f22535a97665cb93abfd763062c05f0fe9719430ccc49161aa0b766085ee2058943139e9c154d5c39ffa68f1b234dd22e3d4e13d8b2769e58dd4663321cb322b78ade21c6937c5dd6df71debbe7ea4d72363a355be834657827fe1577c63e1327092839fb949b87dd253bb669413215eb1d730d095899a629fd16546fc3c7fe93665a293188233fec2fd4440122fe43122c8269606968565b16c2e8a9d8489da2d7106abb2693137c3915f876b87befbdca1ecb1bf5b45fceb98ee9dd391900cba579ef68684f51aad2c3d05c8af424ad70d10ad8d8f4fcc5662b3d4a7d4eb2049d24c59e89de16c1deb6098aec8b1698a0f0feb5defd965c935d7ae1a8b9807cbaaec936d85c55eba8632fa3d8b0cb0cc73792e0dc7417925e2a6057bdee1ce1c58ff1428588a0a74e546630b472cc5909b2326693b81a7bad3d5906fffb55861b0246133432c4238d7944f63f66e103ac8f2f39d022f14eb3aafa056d5f7907fec222ad0712cbf435b9542e0726a7427ffef7b7613310ca126bb9f283315b736cb293fb4e7a710aa651ff6e9a4db364f2110a06633a7b5399a4961e6f42bf6e673d73c247f90b34dfa0589527c3df0b68795aeefb285b712a92019d78c866217fcc42668f22a3b8b86c58fc5e159a0e94743600a94506b8a33ebe132c029bae2f135b11ee56171407a213242e7e73c888603299a9cae82c9b89e09444a0bccd3deadfa8c83a95c2375119a2addc7e9d4ca790fdf878881bcc88ff22ed6955b39c44148eeb88d3b69a1212ffa9197a949d96604aa54e1a66ac5cc5476cc03a3370cd49d165e9eb99d319088a656cf3de09cda1ad5fdb55b2d619995df6d4db470d15ff3e0acf455487fda6975d730896d4cfa363012deb2e5d10b01613532f50c04646e53be75901ebc8bfba952e086e5adc4e5da572886ec3bd9a03354eba8d88c23c7ddcd244e0c9ebcdcad474935d1ff07209ce7131c27151582562361c9cd715d5de17ed5accc2ff4741eda77d0d1b839b5ebb339a003969b25db06c5d7cd0cf279a1fdc0b1e188df4a4661abcd08c486b50a1dc17ceeab6e88db8222d78a01fc31d03e62390485ee96b68d679ddecc13be54b91e219c6e2bfa354358c221672a2cb39e8c9d0ed38ab142398028b844e4fe0152f9a8f9bcfbeecb54018b5216691bca15e067ab9cb79b63bb007612f64a06e20e90bdcbcd3328827f93cdfb198f672ff4d9cd861901bf9d4be8986cc40a8662ae5c926ca6159d208d220cf89ec0a54ebcaac52f9a679854695cff4bc4512b8d80c0f91596c349b6d0957ba4d0962c007c53861a9fbfa7f82114dcab5567be531662c0625820d7564796076c5fb0963e649ac0bf62298031c326a984c5c08b41e332e058027ac6cf7feaf250a6051c4216719530d1cc8e1c067536ef4ffbc8d5eb486d81780a6b1a5e9d92c60f88139408a8b092ac4420310ae85b1ce8d0ffdb4c5a5b6262dc9893b7e9a87767ca5e33e1b95781604c1eccfcfdcf4f55639977cd84f6849b9b55a86c5e365ab777ed4c790c4efdc8f91f48b57c242c83de2fcd43112fd5c6e5fb37199254a7c81d6d494740c8c923d07fb77eda763cb2396a41cb114c96d1a0670e8cb3d4e0970d34211a72cd0093d555381f337c09148771d0e96ffa23d1ead1d07697ad768a7f67366331abc102a145ee23d983c721f564161fec176ebef90685db39193dc507ff5027dfa932cc19581905762e1d177261f974dbea40318d670316d7f70bf7a5145670805b66f288d96d2a2c3e2a6b48999d77677e3e1c7051f62137e1528d69b5de8001b326f565d15cd7ac122852ab60969514e83be7b0c704350afafe5d8e58341153da35b95e4eb48d14c1cd413c224eaa6b27ef0de79c36b05a2a3acf546d9b3f5f8d12f9296027cf005389c29c01f52f85f1b948645f8b14772ffd6de92645279f6f186fcc3ed376c65370172f2919fae07bb81d6cd37a48658ee3bf96ade8786cd4a053d03b59505213455da3fc93a3f8b2dd8a6e2176d65e41b7638c55400896382991a1c0e2335bace0655fd37fc4a683eb278d03697c9cb35f79800d34ec96ce63c650585eccdb84c2bc36f83891eed9d5206f3a57e3d7831209fc2a6ce17ecfe1260feb917eeb9889624aafec5a4a10d995c152b3044a53d383392166bca711a50c1a936e1661eacaee966d5530d2a431eaba7dd30d5b2d59ca5d2f98eef10d10176d678e27829109d454aa0be27d05f4b49f62a04eaf52102a8f064dcbdeff9ecf599578210117184592b3bd3351bb0fdcb358cf9f1cf148ff44f0f32fd4a3b8f039a2c531d6e7be06f590471378e34981c6add054008a7218db130af2f967b6bc5b3e66fd56d545bb685aa406267653f244ec0db4f5b68a831be0db26f91ee857a32dba1c1d3a2e7fa507fc2a0bb8db5bcfc1bb64e9846ac52f5fcdba9bf9871a03ee71a0aed56726bd0ee170fcfe990f3a951cd3d46ff2a4161df3cd287b84d76140c821d73b5bafcb7eda95eecea6fe8f2769449ecfcb89e1af434972c147c6f3842cdf3477bb183aeb818ff2afba3798ef5360637059d262de3bc32587b1c9302bfe7cdf88ffd60463484f26ce95ab6be8433ba3cb8674d475b60db5b3182fb397af51273c5e69310dade152772d2d05461c1be001ca15e0c55897a55787a95e2c219e3809aa73361189dd1a49689d1e2ec1ec75e699c1e87a5aa0db86b84a20e5f1fb7f03753be622629278e33e9d85c07077eec8adcaa184a4c0bd244fbe7eacfead07f05ce8fa876e3aa309cc29d143df577f1a2d0195f33beeea39ef35ba0210a4d61f94451ab4fe283b676bae9d7dae99c2ee11a4ac8259eadb4a49721e9ee8f8174a26f117631f8ed4a635242577f8c83a1b701548609b65c047affee431c7a24bc0d86183b559a59a1654e3b91a22e9ec9a5d86ee1bd28b0fc38c441ac39418ef9c98e15659209072306ecb4864178c818a8ad4b9c00f969ff0a66d420ffda8dc300e1b320da10f428638cbdaa603a83617811f7cd2c805f5c3b21ffd6aa83b0e765e4e3e31311c8d6fc8479066f89f33e4f5138dae1cb2dba2bb44cfcb4645da538ea7ab801263bb2797b399a9db2d95c1b6888edc663977f057cbed868dd0bf6e7c978316dffaff357617e6a0bb65dc0511eef1a03f008d0bff5f5524cb221e3adab19b9989b2cf4bf145259d6df7890f53457146c1d98a7cd4aadf3c4b55399da07bffc08004454a732a418b3aa8e8c1252c40b5d4854ebc5782a0bc4fd3a5f411fc580f524149b40f90dab86c9e890268c66aab8c458f36a4844c36bd6fc4183ff7556bb37eeddd706d66c708a434eeba0f87a8aae87efc9ba4e75d23e544f158642cdc11aba756a0904f0faa3d05b79428b28ebc99cb0f8e0ca077b1233cb4df2d4ba68a6392dddd926a3620d399d88fee85a1c4201999cc30065e490fa6140230847a47464e20b95d19e0dddc14d0457e214b017ed5e3c19ee08a685341c66643078a78157fe6b16175c542cf04ecf2a9726e353e02a8b6cdb0fbf555e6763394fb4b0e8579168ac10ad0d64770b70e5ba159d9af6d1075903e0805df92d2cb48ec895c509ef54c16978ae4fb86df3dc0a765e3b83b09aed5623f9ac9eb65918e846dd8e9e7f7f63332b0709ca4e60e2e5ceb7514dac28aacd1bc0d6c143fa352d9cfd669663fb0dc8c5e054a77a5c9f8ac9c01760826f1128e09404bd4f610bddaa8b86142b01676200b0a5936ae5b0252dbd2150d835202be93e469219d3f0f9413e10d403750e8ab691754aa71d40a81d6d36b95265cbcfd7fdc6e5f3a0b3a44db5dbeab07aefa8c2c07f7bb03469efdae826f195b0c131a1949b0cacee59b3f924a20591ac122a5c5f8b2842fcc0ec26faed74416043606b15657fed6f90dbcf477b2aa9e5943b31c7bb4b5d9fefc3da8a101888d052a7f5e2760895176c63dcc6220c89c3f74cde4dcecdaadb8f59a8cf2e998c481bafab88d5d1f3d5baf394ff653265f81423f391081e439172bc4364c1b6d6345da3483d32d9765fafa3e80c03e97e3c06384cbbf47cd04316f6bd88f96ad2db4d94190e3293116b12e039936eea9663656352e902cc1bcf5a6f442ac48b0ab4c2508ad2d6d0935cca9a29434e7af3fc0ba4404cefee5c8fd26bb950603146a23836d11a570dbe4c64f806be9881e6a7887608724e5937e3c1fbee4de5c35637e1916729c067b47d1f015de335ccc1fad43f012acc9b937a3d8fcfa267a24a450b0011093bcea506a07a95b6d9132cc8795c25d8ca453c84d14360bc8d475c4c3d6e7c61c226568f8aa7846e2463e20029438ae5b43e13990df46465a9e3f56de505292cb62ab7a245e02cc0b71cf794cf1ee8d665a0121b5a5e3a842d9f7e3094fff081450b7a6c4843ab2b8b104e57eedc32b0c06375627fcc1a096024a05f6269c5a6959ee9c2d5fa9917db5edd0b04d1a1205327e0a2ca4ae6e01b3b646a6fe64413c13b561249dcf9615f177e3181b72788b016e9f6672f731bccd0199ad8a2881333bd534d6ebe2c965b14a7ad12432e949afc049a61edc23547c51a577adff4d9e13508579703833e15781d74d80eedd6793b65aca15302b565fd4b3e2267e0061fa472f18591742575591e1828b4cd2307964a0e5c34f3bfe2bfdc7acc3d53e01e51dc8a3674a5a4bcb3cf5b9e56d576a166aa927bfc10f5c5792ddfe6bc14875375d1a0ee05add8cf4a7cb81661a4f912791b6228d4be451565264c200d3054f518e53ef2891aca91a982eafcd345010fc16f9a4014637ac6a209e5af521c5724c03545d86fdda2dd7e94f46832c50b85d3ea7b9d270649a7b49e36c99dc0f7320ff3069edabf44a6b894d6a9582164dff18598d77d55dd94e2cbb2020259a29d4224af9ea57ce350daa7292619f6fc6e6fb5159fd2ded9f711e1053ba4548fdd8cd9fac262b3a3b8e3f41256a80d3df9abfb483c3ef44f1f5690a4852175298210e719ef14fab8334aee69c8156eaaf6f27b0157cb7b8381e516bf7c46437efeed5970b1822ef4377591f1f8cc389919939102213aec493d626","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
