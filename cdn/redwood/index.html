<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d9aff2d32849a4f596522a9a0e8be821bb1ec0f15b0913fae53bfad9d337cae935d482fdb8c7c7981dfc2af1bf81bd5eb919f577617248459f5d5adce65ea051bfbe59ffadcb933df8590a1b0ed986d715976787c8bc6d0e40f68ecc72bffcbe0f97791820a3e8cb8c2a2cff9d08dc6ab441dc5558210407a1d05ecac608a02a065e196be81cf6eb4fee4d003af3e0cb99b2b28235e51bd7680ba22403a5ac11f8982a6459067d372bf73da513ad013f31084900e3b8c00b57646d5d61cb5ce08379c2386c0feb8aae122dbe0210fdaa38d4ebd10f860b9aaa07d37d28123f22f6d99337edf987a377a87dcac8e069af0b49fdfb86c125f0cf92c66459ca279b64fe78ffc8efec1ab8b6106eeb313c5cdec2ea677575dd1c5cd7d9f61fe6a537ae386f90595a5db9cee7c4603fd0aa186ba052bce0c971ee69bef8f66479da00d290fe29bfc4a0400ca79748b089dcdde263d7c6f685de29627f96eb4ad34ea2d21e77f143548b832b1c9ff3e5c8ae4648c8a0a2979968d8817fe51e3a51317005ceca524dc1e5b83cd27cd5b3361d744948cb55852a3a7e1192a54bf5fe0e37c313417f6e6750992e939679f58267c9e92c35cc6758f918d953690fa2cf8343dcce9d5ecd98f6955f7cbb8e6e5dab3c4805f94ba44043bf9cd656d86f8c58d73a753c18d7f931bc58da842a92df9ad569ad08672c121d0e77269b8ac4fdc43d565918b14affd1d807ca092cfea7345db2e15935997afe1340355af1c1b208007834f67336b693bc7fe3ec2abdee9e841fad6d82ce73856d86d2ffc9a631cd241ba8cbcb54c596b8426fd0d4e2830ed75bf53af6955eccf6e49970c409e2da071863cb756cf5017c6c4e734abb12e668729c184ad8be007df296218de5581465845efa54a23803fdb7af2402182bca9f472c680c5c4beb66c0c04686261c48e16b89f49daa549a5495d6b1d96fbea91bdc4a928dedbf313033484903e889e8642ed9f3e7ab1242121ff27b56630d13b9b99a681243f3f3b462dbaebcaa6aec31b7489ea1716bcd91be8d2a33bc40a7e60d42c954a8883d8689ee47604be0033311cba3ec61ca2ec0d1189ec601bb649c28a12a1e9ebba0132a2ca94144f123353187bd7eaac059da9b3dc49c708b6e7f827f3e808f8e3ce92cb67b38bf19372665c8f64452aace3672323fa701995002dfe41fbd641d52f2ff2596673c7f54043d360fd1f52d4683fd18437cf8f16f47669cbe3207d7306a6d551b356063d1a7ad0804f16b619d5ac93af2d481ca7f25aff3ecea8043b7d6226ec0e684b83bf924c7cd61165f680b79448605b6bdebc52907ba59b39b35ac4b91d098d113f70134daad0772c9228215a8cae385443d7908840c2a0119439a0e03d61a5d05ba52b8f4529612267ec569fc283b7dc8893aebd4ca5033711a6cfc8659847210a04abd29a269c1880014f3c06165826ce6c8e5fd515e6b52f85f6cb8c9d576305ffc52c9af0b40521ccad2dae9c2862682e124d375a2b7ad148a7c7266ccf85ee6398242883e201a9e1b3d92ee45ba5562a6e5a3d99a662f00c0236f2ef657846e112d90f40ca249ea0a489e4c500ae70fd305fdee02e5877e4e9465ec2e22a9881e1dafe3da99f9c7a74608d809de6973ed808bf0a86c7bffb56ed15b246546f8a15fb7dfa1cc960d43961a5d41a30a8164eabf9cfc0bfb6c4eeb2273bbbdb8c6de84acc6a470b1eb868b81175cc2497634b33ef9854878e673b77a0461aff56a8208bc997aaa9e0629ebee402703d4a574dd2cde5fddadb98f384395deecef1fbed5f47cca78b5f65b2907f4dbb8cc0587479a073d4cbde8a1614ddbeca11abc4d2b425b05584479cd8828f73520aef9b4b4379daf7663ef97efbd578c4cba555af67a07748511a82827a2acc5c5b9636735a73b7f9a40270fd8eeeec3e95811f33ad431f19d5615a8e23261014ccfbde0527bd8ac6a0ecebf2d487bdb25ba7729a89ad92838788aadbcde0da20e918fb65c81d615f7b4d71e86b0d093f1a92914752f42db7813185dfb1f740ecee2defb92c3d4f2e4a633b33962321eab5eef2adeccf717222392143fba0201ab8594ad0e9b29a03e79000e7228cbe6be20bae7f812d9f528ca1871782d8bb42bcb7ef77aa1aa6ec2df2bf35eba785ced5fdc80d61071b51d3eaaa74de7cd91a08404a9702859b68c85604f3e26294a7ffbceb177062231ef4be1ae7f6f5833f7450104aaa1eb76a3807883c51ae40001c5309092d763afdc27498be3efdeea89b48ed4a45229e3941efc5fd340535d9481c1bdea437ac7e88b9b43a3a479a5cbc80cb2864802ee6a60961224e5895829bf1b867987768c568c2eceb8e523a4808c6edf71e579497e43faaacc5b4fa6fdbd5def6476d3e5711bc2ee824d8d3a5fb22cd83fc9f94954bdb060d7c2264142ebb50b7c83381e6d8a6eaf0b69bb4e88fe43a46823b42c087f6bd52862e62ee26408f69edee1ab2e48c36466aeae8d516d94aa3c7cfd170bf2175e4fe7de94d24d20833af4df0d386f0cddd435cdbc68f0ef76c6511d758b4052a8df988e80da136487e25e5b220aa02dd01e44951177e645350b88eb270802ab5eb65f4b99e51f647bdcc2165b75cfa1eb32ae79afc3f12eef06e6bd9ae992d5e891abeb1ad3b5a17286c0d77375441d8249d0539de0de757f48dac8713b9e5517f45164dbabbceb92247f88c6111c99f9f122fd73ff5799aa7b6464a9452a3404859fb5dc1afc935748e4a6ac20f6895c6404cd35f66f5ff1c3b4bf89162f2bc2151f1a110edb645ddfaf08d0b4cb13702698687bdc99cbe106d4a5ef0f7f6c810a9a542f21c8c6cb1531dbc71aed9a838e34b5292af4725924c2cecb84e086986245a04eb51cd3f5c4c6a9d5e529eb8334d050243842287b0470014e0f55ecab852ebf25798815dcba927b5bf4ca779f19fcb42fa7b3cad23c2f728f661a3f01689e3852b38b10c378c32b59b7cc892aaecde8b792c883afe4a019be084f57aeaaa7fd25b9c71480d11d6b41951a24c42e767c76947ca01678e0a1d79af967396ff8716e7325ffbc0425d18680feab3eb3c17ff4a909f43d4a20033fd2cf150bd5007675918af1a1c72927da9c8055f9075d8c8aa078be08a407f5d8e3b0e2c37e93d7830cf55d0efc77a6ba443db0e737540bf3b9ef9b3a77a450a804962bdf6530c4f195bae8e7718000af7e527212d1959e7395eaae7cda041052b82d9fd385a0ac03b00fff1e809ac8282f08ece20f206876f024e8426e0fca5ee470de4d787b5e2e2ac6af925b949847d8313ca7bed366f2016156fd21bc75e1704bb50918c323ce151ef70f93deea68e78b5411006ba9899cabb3653253a87c75840b42feffc148ac256ffd89576a2026e602c98c3f939332a373b748d8b4893a5ddc7eda42b6c7493d2495c17b5ec5b0ce9202ed129f0b877bc525e2ce33e337b3d56608ef787bae9d7a7d036679939eb84f2de5c3ba839ad67b19933f5b4b0d4761158c225f3e14b20a448ad4b8ecd03887d91f6eb12aa0319f5fac1542db53574e484290b58686e34a71e635f2bf1aa070328cfdbfa7543117b0f0c301d8e97e2e4286930ddbe65be4e804a37f337159cd953e62100b1fd960e8782648e70e2213d03604d59020f21c9f01cb45e1a16bfa7217a89a7fc3e94b228baddbf12e16cf146d7ffbf941b219b3317d6f4707ce8264a9f9dadbb72bd32f52d6b1d0462517de92443ea942a6c9c79190428b6297e6c1c4aa9622fe0c4d688a6064ef105b226c81083fcc27c1f10f074be62d935bcf915635a91e2c457405e2e784f162f3c6a82ac60ac7b1a410276b104811bce171083bcf931ff218326c3d2801e94b6443b1ced33e860d3fdf52454995fe8728d6fd779048d387740791c8f458a8844dc881758ce54275109f0ef14be8e9238dca66fa3a4905981ec43d50d4b226728ae0ebce827aea75e4671d51d0f7820c5f78a3ddd4ae16b8c0f79ef96d555e11baba49d5ef9605a91823d0d20dd3cefe581bbcaeb033cc493acdfbd580d34df49fbccd1c0628db7f888d762cfc6ff0569617ca862ae8101da23947494fa02a6d2e143479ab48a42f7d7a56149f01f5d6c9c791d04415db77fc98e9b4a6254cb1558b35ee6211979040e4c911ff67d1cf3ab48242c293ff1551914ef63818b9804804b1de43d12ed206a9dc3a5d1f08e65bf0e8ecd8b5223e88c4eb98986e3f4edc657876dc0b1ce98a47b56af6711a6d9190f4fd2d96df9460601aefb3969f2bdeb3b79d99b729851695fc875f7bdd38458647968ea424a3a3f057912149710d98e78e5cc263b3bc91b5e3508419986813bf968bb62e4094b43bd52fbd0b2dae4a44944470c92eef30979358a0206b53f878f2bce6310f853bcbbb934cfcac309f8bde0d10bfbdd4d173bb35c34949d7d0dbf3deba75e2075642fc8f034a7b5fa26212a7461848fd3b86a7d6dc544276b30c645462fc2b5a7b2c76b6a8b3c58f7e515de7fe279a80978162616968ccd35eb7883110d8a14d42919d34983c5d6d49b0fba73307333c997f1d61fdad393837d983732120fc720f450bcbb3459bb29f1e359d6acbbdc7702b0d3fddbfb2582da1f50beedaf67bfd5655799bf7a1c1d68fd975359c11d46bd1cb52ddcc854638796b49bfa46377369ff62f4309bcd715284709847d5b9bb5f1228b7b5f714887072cbd1f2c8fe1c0ac24a0c4b89f9f3316124fd0b5ac138671bad56dba36462e3a23c62503ea4fee5d5c139d610c5311dec3990a78295640be034e1c3fc1c9cd790d44f2346efc7b66506d7a6d6e0fb822306f1162c419ea908fed893286b79a435e3107d1755a64824587b71692f8dc14ba4c0088c0b04982f09fc786c6cf3d4b50f014153ddc6f3dab027f8bbdbc21b316c447319704099692358166ca9d4827af9c4274a20f537012d7b32fd4508f04441d1a2e5d2a58fd51864e379b20335ee8895a71cdfa0ff00e1540fbf2a1dc840e1ec0edc473f6caf6e21427e7f20b66d6665d200a8c3c5696f367ba5a4a5ec5f817c234e7d3205cf3d60f6541c7f0253c0cc1377067fed7871cacb5ea58d286c1bcac9d5693950dfc73d66a057703ef0ee32a551e9598eea1de6c5881690a5e11150689b7ec4b42367c67ac4faa543e492d4318c4f22307c6fba6bc803cd2f002c9cd7131697e2973b05af9f2df778927eba4610a6765a3fe13257627f91396bf28aaabb48fa991b73c6be69914dc4c529279cf81cc9b7f7df33c02a3363c54a7c6808b64dc036fff7921245e56c992fa2ac174dfbac5439e12186fe8dc2b990011ed5949b62e18e407812152669b70287373b1bc4e93ca293b2bb690ba33ebc230674c69aaa8eb43bec2577437a9942af1831781324bdcbcf378c21dac6cfab5f39029eb606c411a9984eb21342dbd5bee2683ca040149922f17f8af9927815add7fe99f5a2d3266c14e4477c3997cd4d31ca1f4caca36c8282b5529deced8b331cecb983b3dd10bb10ce4e110304b136e706e7201e4e4b518e2e1669a18cf149c8312b4222336f6df4c6356020e693acc6e1a5a27cb33fb4bbf409ec5b35256f38c0052e5ee5261b4ea000338af6abd9fb4bc5e3cc792dc73151712af9098944f07c7bd86852f144aff2097ec0f49df0fc803368a18d16209205c56e379e2ef5f158f27975065e6eda3aabdff8ca0c76b68f6ad4761121ec2801b582d9048e024bf7417aa26c3757f4427a25368ba4aad31f4543b55029191d7ad71084c6ed42ceed9153e6abf7f596463ee67cea4bc1e0325bbcc1b6b923e22ea1b6e4f15a7fdd85002289451c600ae01bef76efe23a1ed95536a16fa73f4ea5a05a8120e8c6e4c45b5d6a594ead3fa30a8bacfa8bd7fe69d0ee573f4329b90a863ca89ebbeb42487d711eb877ffa1bd658813f113955683889886ec8046d3552733b3ef1b71d45530a97bbb531fcba09c024f55f3514564e88b133d159455014bbda6eb09fba0f893f6fe215d86de6bdd3ec2654845743837a6ea061069edeb605ed1f061b6afd4389f348fac936b880282cf02b003930a60e22a936823a2d9596bff0947e2be84ac81291a789ad16ddac4f1014d864da30db02f33ba880af040f292cad7db03fbc5d0229492680fa5a1d90953da4b2a809a653d10f1a414b87a1f4d3e974747504e0158165a293b17152dbaca3f44b744824d5d548d998ed661b4c05ca379195b4371a674274bbb2340b2d5fe86c17cc3fe7a4b5ed8b3f79ec59ebd2d0d6bac88c052ee486695f32da4d2729aae21d8ab55ac0d62723ba95009d1d8772abcd1725d139a85a5e0352e81a7092c8c7db571c28de5453981607b232d877d5a9dcf8dcce33d82efd27db4893068cc44bd4d0f0665e0478565d43c36bda15251126930f3aeb5a7feead63bb8ed8c120408d5a5157155ae8c6fd78198ed5c9a9d696b64efff996ef7c57b9e3f2e8f9fcdc6ed1aad46926faa719eebeadbe374f7cff8530efc3d6b774edca6c754c866c23efa2a0a5b59d87ef9d9c027b413fe30de2d3612dd6221f24244cf38714fcddffa2334c2ff2f2a2407914b7c05684d4bd3abfae029cd884493d49d363ea149d468518e338275bf6aee706281a78ddb486adb22f56186c45b95bede8ab3b213901735dd03e06804f9b0c01e6cb6c789eb501993125e352d3861f3cdd463590ec19c5580ffb34fddea5d00dc6a5464e38db43bff75e029d0b45858c19b98f77dc9b48348b1777d968083a3445b37b2ea6b65598c9a9551e56d93763017355729b1399618cead66da5378bf92dc37c62ccfa7afee1aee68b2cb4802414d1f60f4e55cf9974f1b49dd6e0e5b663cd49c45140577cdbfa3991cc36d35ead23e9032b4a6c937c7dad679de34699e879d72a02db67c0f052dc7a4d68e7936feaa7a2b343e1e576bb95fa8235287fc46ebb2f7b7835f1ee04399c3daa622f4dc453d37b2d94591563d5fc6666e83698d41d4fb51cb4da411b64fb18d5602fa63fd078061845c6183e15add6ca241f689a36880b1ecec89221b54d8dae88022220014feb31ce5ed7ed5a91c9d9cf1e9528bded2f3c7a99ab0b5d988f3b27be44c80560563d64602785d5cfc0aba8c81514b778216e47d5d8ddd6d6d0e03a375fb2681d0425db6c6650b4b33f202b5efdb6f1829f80efd90dedc218cdc8a9453fb800f3d981ee9fbd2188e00c1619db9da8da55ead35b41cbd82809c514c6cf05de37135bdeb234f5c82bcb5e4d1f7770e896fd35c650585defc1bcdd9b5f28e6849b7806828507a119a5115d615eec04d783e2d83b185cf25d3ecdd3ef6213c4d087149d8eac7cff1cda05309c21a411350ef076ab67657f6f497f2d92282f9c8c3ab2f77cc4cd75570a6ba2393c31dcd7e53b3fe39435d006519b3529eed3bcff5236278782b8c9ba3014133908784fbe687b787457d5bf9b988380f5e060c470f78bc71f30fac662cbed5c0b59e8ab907358d7b8e26c0953f8aad608fcd61b4d97dc2ed27710275b5a1e34f6d5cbfa94e92f173508f7283222e95727a0dfd3b061de5fb0c2d4a311acfd5dcee4e609e15f61971630e6a6ee02ecc16a6da7d4849585606ae5c173dfed476397a9b24ff6af017dddbb0fd4f5261301f3a31bfbb5cb0195feef1ce65dec897a666effe13bc5bc165837a62858d45ee0bd2fccd77ce38321d8d40a2798c402f024e462d04a4e2f19d26775d63781a967b10032b98728e713c79de566032356d0072ad89c5a09a46cf59fc0d3f36c72e933d720cc2040d62d22fff5553f3b200ce589c07c9047f6dd6fc1eecf6360dc4165536a5e9187c3e914b1e14e2c89246e212e4e918e9313861ba780690e89a8813eb7c7a8f14e28719046188026a54f36e005d6c29f4ee3831856d5a7f2afb4b3a0f069f3a447385504e5a179dc6225dd449e5304755dac3ecdf9042d401436b7e6b1306016e9bddb358a9f959acbc2b819dffdf890825bf31ddc189401d9c0875a1303f40ac4dd888f418a449fe4eb2ac9c987a09bbbc985790846c119a5579a033190983f9caa9ba4fdfba9b814e92abe9e365eaacb469b902344ee6ee4efb2bebd545c37fad368d90fc40b40832352e503eb381afe3c8966f1155777bedc50678275e23369233b4a043a64484086a5efe4f27d1e14eb2e667a571c9b13abf2add7b36474cd5b9f056f63ded3b01934247b41a80d6a35a8f81295ad84c0eab64e8167963f1ad90dcad647c34968c0438b261bd7c270bfda886eb2cf64f35476df5358e972155ce59776e0774529e6d8d26fec814a4f1d46928055cb66015656f9f0a7cc05d2df6c11a046fde122e1d059dbc1d07ea2fa3619e5657b0b1c3103fae228c19647042f4d13cca18c9580ab83c74e83700d27209c68127995d0f9ec5f66da320db165c4f3ca452e50abe2af3c642dab16a8a39cc1740d7357b4d74ad2ad2e8eaff8f63a63a5086032221532c6712948c5d749e4e2ec79c0064dba2ee5dbe3b96401abb0211778c33bb118c6cfecf4d1aa76e78c03520259ac5a0e7e8e7430ffae829e5e74de96fdafd12dca8bb0d402d31cc06f7d1ee7812a88f6aa1fb71b2ae60bd82546dfd9a7c489a2f475618b6e6c7b6afc01137e0bba962e9867396a87215652e6bd5b105269a4e4aee25896fef6a09fb7818b4e1742389d533a77acddb5df452945613d8ad5abf2dc6fdb07d72b0cc60ea6599c98a121e7424e02b147cb186e8705fc2ae4bc0847adb863af39442537c4f084d9652c667ba3572c3c14ffd5ba1dd389bc66412425642ddf65c3d23b356c032ceac491601fe294b0d1c2e10d0819f469a68813c49cd0ad21d38088f81e82ca164ac143e56df690e736987caf36ec3251c5d644cd84e239d10df9de1204c25a2cd1d8e4a1d5218f8f65a102770fbf10416a57aebc2c9c5b6bcf5c5281a2d4130dc4dcb33ce6a18182862f6f1ec8e8daeb0628e3ee629848549e1efad8600be64b36ba9490386228102209d6428ee314cd3710d84e6de4bec2b93c15d4b3aae20db6f1c7a7f0fcd0c1604c0035ab14f6e1f71da859b1f16b2aa918673f9600bbe182eeb7dcfb18fdfb696f76b5c9ba8a460b427f10d3393c1e7867cf3acd8f41cb3eda87fbec812c6fec4120a7d5d765baf28a0561b6a5a74001f97e7262de11beea1069b669d4ecedb23a62170b078c24711e93e355861c131ac380dc5bda77d3cc6124e04c9175e6a90536c10828c6630339e2dcb371ab5c5db448bdb05b364745426272943e4f2642c3b85bd8b21a43f3a9aef34cde462d2dde3b7f236e98ea2a847b5c26032bc3debc50585d50d10f1a9c627b40514c1298751cc67fc0f0bd84f88bed98a29af8116255c7fe08bf914a5bd9f27bea740a711c97c09e6bed25924931ba53bd5a86e30bfd83af108f4683bd646722c9446669680568253d9418a422f59c745e40a7e6b4c2c8f067002cf07dad57b0fca315076a1ee5b0f89dad2919be42c79809d553067c8c3580fb7fff58c20d00f422cfa109134ece38664be25ea8782c3c52c6222ddadf5fd1bff7e05f1ed13e52477cd91f8921f9c51c99ccb2a9619ef2a417418f38f984d250e479aa2b73982999e2c110274d0409326de1c8e962a2cef0b64436c8b84b639bb0bab95daace39efa53fecab2a5ef9eaaecd4fda4cfa3a18a0a7b51c363fd8a8466b2c18b62e3abebd2915ecef8ce5a08525e09d70c2572e9eb8a9d50fb739f9949eda20a02f142366f6b960d54e2277a10ce8ca92d076df4bbdade52eb6a2cb347ded72207fc85733a8ff63c107fc5e6d80fc0d73b06c73d4b0f7f40f5862eb059fa1b964cc4da1e80d859a193c16c643c75e5d154594ae751a734315765aa882fdf3a517b8ee22d93185dee514ecb1b7d15b42c03eb5dd4bde0855f7e2e52d23facdcd626a91e066afbc952d1b907e0ec95cbae793b6f5739f23632791227cd1c67233180b535e2da1d3d7f74019ef9daa28a51d02cc7ba6dcc8511a64c5f5015012f90702d8f26416f203da7da216230d327053975bdf1d892014d00e15cc3dd3d378ad614588cb26638df2cb830c1de951e8c81d37734b6a876b3ab2057b80d0f0bc4f08f8231f30796cc41610a9289639b03a390eaff3a37d12074eb3161da6293622066e9f87325394061aca5926963ee0f06dab2336a1a52aba65431fe27defd93c7f20bf4d8735d30c6522568841b092b85891afe9b29f24719a850b4513097b77b6414a90d5e2ba0e72288dcba6407c9a3421325a0efdf5c511c82b53d27a2d1f98bbf9d8e5a8721b438ebd98832be67660a52283d54a93fe5f01380f7d0e6a23e1cba4fc8ce81916acb8f7f7781238a303e0a9a66ef18aac65d867a68c766295970186314a46aa40b69fed717eaa5d545335fefc37e24638d56ef1c8b79582dcd6d67cf5ecaaa007722abdf700edd34014ef5ebcc8745558c83dbe44ff6c4958cf9d34376c3add6b5205dfe0b026ed535ce1665b2f20a29bd7cc9f42529dbad4eee0142f01d8d5d0ea687e3d3142e693d125725348393d11f6a478ebdc773c1ddc34237b33e8bd0db0b600269b4d5265d5c2ad7b908174f679a8f0cb0421ce40dc74a2cb29c65f4af94e9c7f460d58d033ef8ac23cd89135848b2e18a4d28b76605632b3b91dfdb547fa71df6d0641968ecc024c11715516d2de811e0d5a9970afa2395b237c482c147e246c4b779bd0ebb5f1282864f04a4a208b84e4404d61c1f29be228bfcc77088cf03a19bcf1234f8fbaf8ba5b45239ddaa4839d5c379551591adcbeddf16ce8f16c7401cecc58fa1a8786e6346139625a60f4f9ecd377d4e72b9d5c95819213a4bc1aac0b20c473b1789d7d248dac59c2c04f1c56e568610ddf1ee6ffa7ee609f6be05bd3c4408e876b9d5c267a8ed67d8d0898f44aab7a6f29653b4c7f90aa66a478ca46882e84abe904d1e72e13c92a79a3460b74109c81f39e47370062109538d49c367bd5d7a38330fafd774191db530a2b0c9618da038a4532e0ec8006a93df419a5edd4403bc355b9147b5682cbdf300ba0a89e9c5140558c3fb1b7af57a1ae46a4765e4b0c1f4710abdd9fdbbe80e1c7e5f2e45d401b6657a2e5341d67bae6d98d706e95629872839250eefa6e811225c1bafbc3241ed01ec7e481aa0b9c515a953b498d81f1387027fe68497d0cacfbaf5df7452b9608a5fdc89e0a1504c268dcdf7ad4d0248b997a8a20cd21258bd94651a0f8a226ef6165b71004370a2cbe09d7e691c6930f7fae2514ae3d18e3014f7641a63e1c158e2644ca1efec43ba7fec78857558a247e3d80739beaec1b7b9537806e220261068674a98a27f357854da9288bcba3088822a93dcc60f848d62087c57070ba2b0e63ce03e7482a38265b2d7f98c007ed5665ec16e71a944441ffaa99ae261721233a9f02384db036f80f8cc27631610416534195bc66696ef70695e4a81028d4d6476689f8e5bade605e649d2c89af681da1aa1092ca0f5fac26d03085e74f9354bb92c63975bd8942bfb41ffddca0026d921c6c74c6f632a7445c6d2f538e7253a6579b590919e13323841668275eff36a7bbbefdc254f25f0e77d2882bcc9d595cb8434a30e55ed17494821e780169678117031cc062f6516a6d7de8e3e6f929ae7b909b1e6a0efa99d6698abbad716edac6f3d006d760310de4c35d5ac9a9e549d1fa4c6e2ea31efdff0a2017cfd4923bc32ad455fc5fe79bfbb53ad67cd063d834afd3e10fb58587fbaa02e4f80b58b68be36a19c668f2565f6b5e6cdcb39f5ae28ae474a621b4786e54fa017d785bc8e1e2af25c258b1ae9e8491fec883855e21460d0e46335db1da159858fb7c2472e72baa56a650364143f46640b7a10263ed62465b18b544d53d6f2d8747a5b3ccb543357dc4230e8063a2394f2360fbc874d5d8beea6082082b681c509b3506bf179d4a4d1695d61aaf2e441e73e6071d9207bea584b106a345108396790b034d030683b61f84b50eaf7bcda150f695b2dad1812a712ad55d748ce88e9fa86bb7c3d993b645c6dda1f88ea5ec775fc7a8259c9cee684fddee12cde025697960369a83c40700a4eca6c3da187260324cd5c94333779bebc7118ca0161aec1eea19c0cbe553bc51b70820c6f90fbd1ad427e9d43a565927fa9459f932540028dd0b660ff0f1b751d265d7300d12e35658e90421fac39997c1d20a1f24925f5a3da372d030c950b2ba3bc553184fcb632281126dbfe1d6ea7d052b9f979c0a9c0373b7c92995624815336e5449afd00c4d892996c4c6b0bbdb8a3604f5ea54fa2f19a3f52d176621e741c334e249bfdbcf796a2eba5514ed417dddbb76ae73b3be7b4bf84fa02a7d6c95f9a6e35ba818fd8618b430225f48952ec37b2d886642ba014c610e6c59df2bb99b42117954ebcd0c77bec0b8e097f808b760e4a800ac55c2573596d7a8ec1507fc571fd5f44682d7c468678e47d806fcace19738cda8a06e57db6d3d5ae037cab0ed1db765355b39ff31e19ccf5d7ccd6478400e64f26fffd33af74d3117ddd63e009ec0e222aca0ab35a81ed6db857dd5f819ce63eb4fca75908b8ef3a403bbefe31ac4230cd367eab2ebb52f43560e0d575ec9c38cd0d090aa6d364ce1b6fbee4c8b635161944a4e79f38f4784980f307f682cf33d147cefba8ec4a57f745f41b131da3b68a93d7417c189ffc2eb966e04299109a87ffcb5857e3a31f95161eeaa57572aa8f455aaeeca3052bcf776f59ad0109cdfa408fb604096338245b314c122267e69b13e58da7064c546c20a27ed0a78c9f039d7127b9a39e92bf5137e94bfe26494abb84c5f95adc23f85a9ea3e3e6538f40c4d72ee871dbdc73526f4cc64bba8f3a2f3f267e242909be2fe48622c4d37bdbe0cbf0377fcce73ef17bcf4636ae08e8091cc7e370085fd5d5c4f59074ea2d1ed132a39dba0d0fe5064ae1b103034b09ce12d4c196451bb1c2bf885460a63d5743337ec74191b990b743607693af2b1bfcf07252fef9556c78d3b9ea814c7944a7117bbe00be12768e9a7e36b1b5fafa8c394d7582a2ab158059af7383ed29011d42ec29092192a34cae5327395892bd92cf27f58162b6e337806aa9f287a9783e0d98da6e3cec062f6a5bdbcf1ebf410a6cc915a242164a05f87584c72407be6e87354c4d8333552427cedfd6cd77d860eccb01967cd04bbc97b852f61e0356053e3dbf6f06b3c9909e1d63efe453dd7ecf0e20502a758ac18cf922eec30f9b828bb4bcf3609546ff8171393097daecdd06867c09c30d502205cab49cb2d0b4bccc7f9091d166fd893a0a4753caf516981edf28e776a14ca43fc9ffde01dc4db3a2aaf7eda3b85766a90abb78c70abf0da6d04f9a6593f92f1550d5ab77161afee3c9ab3e95251d14dc78dab5f4ce11d761c38c20dd40283becda28a86eb6e931c8984499aedf83db04100b3173f32e15500eadda8da1801c9998ab18423aed6a04a00ccebaab294ff9926e323aa77b3ec3643f298d420d9bd63b179a64534d0a62de436f7df55e32cefcfa92de9e17489b4b04e16e04cff8bf6c5db5317535eac5b8a47e25a67b33d20628e10ec0a5d4e60d600bc67f301625af4c04e63bcf6256df9b2fd5746fe73c2797fa32a5c55dc0be5bbd9b72549d1e7d15f873972526ad7519ce4510c4b10571730b1dccfaed5f069e27bf0d5bcce3da98c98d8f3e0adfb092e3e5327c251f35ba162817200b16420d0c56e8369d8f3b6ab1e9deaf0544829b861e1745dcefb009fe24b5efeaed2a72c3eb7aec4a8554afce22a0775d10b66fcbca686bf07628c856eb0992f582c5164cd2d904263b8132b6c5739b31ac0db359b2109fcaabaf7c5a7879e8b0d750aa3ba97bbf54e9705012630477471573e003de205821cd54a2d7a4dbc15f9280dd44acc2c5f963f890c5b20c097808f1a8bc7ad699c1593c85740a37fe2edf203b87d5bfc010ae1a98f8f02a6fc09b74a7caf8ab6ee295ac6d60979a0a28c9055344ea08fc133a49abf736eb8cce629ef388f76bf2586fe0808df403cdf8c4c0fbb61a7f87e8e78e7e0395dfbcb497c750829743710a039c968fdd3cf02bccb492f6058303a7fa99bd21f56a4b45385819350fc8e91a73931013f0269e1cbe674834ad1f60191425b9792004395636101632939ad894023e707e6cff658b0bdbfb667231aee1fc551590d27dcd86e1acb5e9bdafc6203c8954d0df900384273e83619414fab33fa30765bf4bc5d9d3301ccff8158a0acc953fd41a0972fd8518aceeb94201879ecca1c89362f5cb73384784c64fb8f5af719466466f9e832cb9ba82a1b83e3f09ee51a89752d30491ed8d53f40888300145a0e41e1b31698ce54913cda4af0e1a0f002dd5b73fbbf520871ce615fcaaf9ea30503e321682485aa9cdbc14238bec189a6bf09ef25d48604a77a386b5405f910babb7fe913e4a8bc0bb26ce95d0213c4832e5c65789d7bdedc686af14d86adc5048e3e5615db2e1eefedc2a5b1a21875a4c45f6c580269d8b18661260fa08d5211f2b77508a63c5369040568841a402eb4af4f67d49ca3cdd9d95a80973ec1b77765f63fd18d6a4ae762da3fcdc971d52fca023c105b5cc4d04499b37e61f26d80248fcf61f3906f26d18f8325c1d43315ddab6a0e83e7596589cb48ea318a47fb4cedd4a5d5ed13af4d52f3cd6280027496263553480159619c59bd3638cae339880e1b9991e70e0edb946a7e84cbf6439418bea416770ca1b065e6d5aa0fc6b496bf860f92fc172402a7f862db9b0f32ddf8b3fb06ee13f5dd915e6b4c1a1efa1fb35e0eb7aed9985b13c0cfae16b0194864aea45414030363d221ffe8b1dc6ca561ec4029059b8ffb87eda1b6d5dce054cae3dfe8d5e8a3cb3e7a1fb10c37724f20074efca3cc31f2a8eee02ccb024f622afb39cd72a2eb72d3ef52319af221053931d8b9b459e8e54d93e52f05c6cbf931aa2d13c44227b35bae55d0ae8ff905abd342455afe7876a6ebc92be6e8ac8b8bb92ac123ba5a43f24632bf239900c707bc5f76d3be2535b2c7632683759010bc94523853a384dc7ea22d5b076066f8cbb3304d779a08a7fff5c85d8c817910f77ec8dcf50c96e4054f5393ee0ecad60c444c12c7f73ed3254d645f240b97ef73d86e615efff6ad27a6f78634a62f6889280f9a4fa43085d486ef61edcde61847c2ca050819027f02a170257a23528ef59aa25edc4b28c085ec7ba65aa65137164f78bc55f0088d3f54fc1998be62dbb2c0b63ac36e5934166ea23201b3ee8a398d6f2be766e057f48df735d38d718e541b43e0d250367deaa93aeb944d2737b17af0223c1a3949e8e5a8d2c9746d97171f529ab18248362a07466847c2defaa0a010a290cf773d5db7f211d574f2bd898564e67afbd2ee4292bd798754549123ef47ae12d65ea6fc772e2bc24356c5be805846f47bfd3bb89406feee4fdbf041607c5ce827822f548e511ff01b03642066132360eedbf7df814e719c0b24a2b6b3809c477f819878218187772bcfa8b4b8deefd2a339666c124f230a1e91961567ebef36e6aea43b98df0f33d3ea8690da56d1c40a08ebaec26be3bdb16ebb86b30b182f674187b265dd226af4fbd330a778ac4bc3ba70991b8df30326a796c242c344e70d2ef28c70309915dff7b86e9b43fa22276f908fc237cde1df78dd844a960a7fe12c5a278824fd3fd04ad35182abe444f8e97b5ce8c575a4cfd8bc4e2e69ac50abc3b4a6bfcbccd7fa54ba4f3c2a6cfe80a779480aa9b19d6d36de508e464015dccda03a6e4b0eedb54d860e88238debc340f19ad4141ad9cce1a8dcad447272aae971f72932ce6e4226787d18ba9d9982f373e42878bb596317e6bf820c014825778d8d4e8afb07108d5a97dc7fa97dc67b1a824bd2b28ddef6a15d13a2f5f469cff8bc1d0eb9903cc128cdb98ef8af320f1c2a22fb1d2fbd8d2353b9ef926fe5cb91b2cf87dfb7d1563ad7ead85fa98d3bc8c6bc2e7b8a7f090b18f6c09bb0265c2d0fcfa41ce8081e77321f0cf2107264b13d6ba1723fae83fd50e92962db6055b5e35bb448dd306b994b0278c3d9bcfd9d12f325563e094097a50cf0c56fb8f1be780baf57ed23def0f6876ddc5a7ccabf70ae7d2401b203c032525a587fa8772ae139c3df4db3f750f1b276f275691e0c69d357184fe96e0fb4e9df1347b7a2b58405599dcc222e4f1ec0f8ad3439c040bb72f9e1b0d9f26067bc635d64d3c78b984a0226fa6fe3ad2eb0210e880943dc4dfac5f6cccdb58a7bc4e3a94c625a34efc122d81a468121bc27c66f7f77beaace1a31181de6d9026b90350f6ea7ac0132178850038d400330e5ef436b88d1b40d93af5186b063b0b7ba16d37b406bc7beab204774b4f1898e651dc81d0c3df37626a2ca6e1515df8375e876f870196f7d7857352ea8de384e16b7bafb9e82d1881281ebd3f1db757ec948bd1f3040b117059d707e8e8ef91ecea4a69088dbfc38e56fd3c9f202df1e85d0ec4b16cbae140597c0e179ff0a90d103ee4ff26cf4bea73465f522e6abea3929c63d2d9418c1f3b50aeffdc29a3aaf71acf9aba8832c4a45714be56b29f802f16871d2357c42abaabc81e3b8de45ac04fc41bdc7d9c7719a5a85c05fd084628c79b0191d16f16650143e03f468d32a4db76d8cd797c2f0290424e29aa9553ec4e949911d16a5528295f080abf345732162699c180e15161a85bd8a16c492ac63a8992aec3d1dea5ae4b0bff34d7b7e2ab1a0ce12024c358858b28cd68a4d5d01fe746bc8d80250274c7e0e23069029262ec41064326ed79329ed3f0d2c196b8e4f86c24d30d2313faeb13d6db82521b088a3a261d81e3134f7e4230dfee6e601ae4a53838e2a7b645b35b95348e8d8a107c0fc8e603c798c5ceda62129beb177843e338e81bad5837b06b36cce4b27fff719457623b489e394ebefc71e953fa9ae1e07b3110e9fba2cf74ae3b4646666ccec2577212eecb99a7e0f2ac786a8193132089a7eb48fcece9e4eb144700487e29c19f1bfa642e56a3c890de1e032a4aa6f22fa344fe1406433b80f5c24866a95870fabe0af519b0cab183e4cfd73e79d6eb456ad4269743c6bd6c06a91d560c34fd394c6755c1ca884e17bd63dd2f0f494231251041a3c04285afe1066236324449a34bdcbb431c9b1cd00da01f373b468f05c31e8d0511a34decb3cdbbb357f63bcb9029ac3cf0e976eee6f4b488c733585d2bb04b34d2f5cfbfeb6656c4c2b76a90b7ae70494f11f351a8b3f0310880355488aea8298f24795f96fb1e9447ffee8f03d947a213c82f4f3466dd42daeeea67a834dc503aedb2184c8ee8f07aa6ac3a67b324c92d1f275948d22e6cd5348eece315781231d344853f01ebfa76f30a818cfb3f0ade0bd48ff03c4ed1df463ff19233b0d28d6b71972b7c2fb01274b7381a14fb3274ba27d78acd9644e3b5188f37b00624ba4a84f3b7b59559b1913f716b3009d9762f2cb561cce3638c52388d02a6f690ddbaf448c6c655035030cd4ce05f38f346dfecec66a90c9d0cc84466509dab6d35d54325819434338486d705fc90af2c64c163e0877ead210088ec9358fa775c217f70b13f56b7014522e708bf2fd90b803f830d8077db017eaee9ac57eb36369e043fbacf70f807bc516d90a3390326971781a7598b1e9a5313a9178689c8601e9a9c51447b71241277bca9147104fcd782d977b15f5c574d3cdee0d3ac91a786e883c629c5efcabdf2cc33ee48b4edc6a99d02bd51860c93ad9f8902aba13f5828ca8d42ee42e15ceaf73ad14c0dd0c3b66b1ad46e931d43c5e46507b4fb6348810b8e4e6809fb97b0d90b848cab54eb4c069f0c386bdfd0b97a0f543c489dd14419b56389060f9800329645f196e5daa82679c41fd6210f844525151c83924e906c2321dbc04d2a6a3c826b02ad89078755fe0734184661c7d3ac6ec942bf6344cdac0e93a671a917a9fab7dc8007def86172022a7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
