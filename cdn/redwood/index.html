<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ec454f89138b9fcda879de5e11854a27516ae8c5a8d902ee0b9350a192628e89c9199da1e1c31bffee53b412ed11d9d25307ea1609b7f398b2b4e15c0c2fd5feab312392777ab288cbd4484b1337b2dd5f9e86ff9dc254d7b7e89ecc9d0745d78c85e066d13bedc22d2e07b91c3c1c2587fdfc57164dabd2124c051db793245dd4b6ce07aba0bb5425adae907fdda1f655be1cc836a46c17aea482fdce3277d4f52d299d103c88d6eabea15022de0309446a918f618c0cc075535f6576d2cda0ed2210b552032b3855cc713641d94616d86f2584244ff380f082de29ac6c3398a2cdd9570b6545f60a97771a7a3bb1eeb4f6fd423b5db600711b01faa260b592b8d7cf432fef10d3f267840d8080b63aa01279e48ea5cf6b833f881318ed070e043e2e7cd9ad2daf7e6bf3bfaa3ca66de9c6597eb10685634d286361e5a28a1be8304be76deff80c7362ea115fe6aa5f484d3855505527bf2add263decb365645d769081094d2f2e431fc1e9e54108a25df1ba6e414e8bd8ceae89352a832f0c6748a706fd03eabec8e8436808f0dcb9786a70df9a429079f0902836ecb544d23ead52a1aefa2b2fb3deed9c2b221bdde0f92201e06bcf0eb15cdde5c599f1d75b5ebc3b162f8d52eda02111634fa3219999f7467dc5300adbf11c579a8dee43e9368c859eb4deb75a605a58724d56b38504c9f327afd3f9b578fce64f7911c30c71e02c67113ba3ba7a6c38d7be31176b4171dccffa27c750701f200dbbc112e39012bf03c1cf920e9c09e78e5fd18c7d7dd3d6430be5656081edb30fad0201765f35e26fdc097309dc9f165a30254feb9086f32daf4c0339f778538288f3dd62666c41f26979634ddd39eca87780dec250c98f9e810b2660e854557f05f76972024aeff3bc6bf9f363987affa29db292fcf304bc10033e297b38bdab5fcd9a38a25bc65814dce39c7949dd2d1a6f2d5dc61df64db99954e677811c14f1e4c53ec06ff342585b88b24803a6e70ff65ef1e8a3bbe67c51be4396498eaea02ad52f6b45a8d98928ba99bff4f9cea78d7c42affa368251d565ff1e32c8c2f3d34c00b9400db35aa75e5c814d4a3f04d1da7341a06461305973a91b84d1916e115d2cee886ca86d2cd7171c13a21344613554fc9ce42de7861277469219386835c2060d6b94f121433dac302304270790c6b98683469d2cd640d4488ee5e4a94e6ace181284a7098c31401b30a6e24c235ba5b7dee7eed1403e0932c3cbc30d950c940a04f923943051f611578f0cd84d27d0ff333463da1b8d93d4b268b65f9565848ef108c2eaa1c82d432b57c7ea1b930d55293162d7e9e9b35b774b0d834265c10350dd8c8f700d66fa38ef439293f5b351be1774ec2af776597745ba35ab4486c847fa004f2e97f4c95efba0126bdaacce55ce7bcfb175ccf421458fde257862c6c57cb8a8245b59f033863112fd6766998e6b2ace7a1cc1185cf3c21054c23c9f2f60a129a6413f9f94392d10076f3a2c45e17411f2db168dc1bd5343d217b499f27599237196f19157237eeee2cfcf706db8dedd7c8bcd37cf75fb45f55ed22e56dcfbeba2c4b3250a5e029cc250f23238ad519ad09443cc5d4b2725fadef7ef96907e544f84b5db2c0fc2ea37c044b436e215d6c5becab8c0f1486b16db2a207a896b59bed27e4040c999fd2df497d221372efb3ff24bbae467079d39083c860ad7e876dcc87c5194b4a1d84b0aff5da8b427b20ffdcbf8aaf529453cfa4c5ddff24744761a86b814e8c17c1e4e2002116f50255bb31eab23bdf8b55361dd6243136ea830dc92b3269f1ec14b0f8ef9ff6c2c8115fe652c30aa633243f607ef8c4eeceb3faa3bef2d0e9ee59443ed64e5dc9f995bbf1ecd3204db780ddc3a9c2299d2a25e876f3a90d15ba2818e66aae33c711e8ec742210c31a732c5ed734d5137d6177a7424818c5440ab4880c525072a0f3ce39d66d983ebbedb0e209f87ba97765c186711c443b232bd8caa307f2465716268bd8ebfb930b208685aa8234b96fd82423916484f562563c505cc1f612ba900a385dd7012d123abc2c8b72cbf77a8f363980517d27c123839e7d26892c8c03eeef612f856d7ab422939075d104fe5c0f771afedb33b86169c22a9c138d4edde304b6719c5e5eef843e4aa8aa95f3541aaa342354afaf8419fae2ad07f30bce0a59e1c8aad06aab90c11d2f7cfdb91e1829450c0898b3db7f9f59c6f81a1b307e9017332ec463d01d05e3fd02500ddc7884add7d8e83aa4cd186a66bc1a2165a4a92e83a972be8a2d5a5b79b9ef8896262d62dcb5c577c8ff08793fba460e72b407ae77da1e7e029ab393a116bef2cafee43cde7feb8205f1c42707f60a3ca0817789790d3d09b1b86f8c18e65cc757f0d34dc8488887460e0fb71265351a1c583a732c191f117f3769a4089a4664301499a854db175fe9970b51d4f5513ab636efe20e67179b0002cec0055d0b80235e11bda64b587557a8c153e0bffa8a40f588536d906a902fdc25fa87a2bb0b74162c2427bf770e3de1db02a85bf3e0a8a71b7ad53c41254f89a04ead331232caaf9e3c80269f01c1a7f99575cc54576f1373229ae0e1cbc628ccc1ee4afad9cd61eef728a119fee3f1864209bc7a97e00303c7b29091ffe63f46222519811ca93673f8f809577fa173b1a10841ebb512d4dd6ce898f149cd337cb366f5a6f7811dc0e7335d450d0e308863b25fab069b8be795e49b5224d7475034e569e1edb8469fb4f2b7e2ab829b62b1bf51f50e1f6cd5c7fba5b99d78b03b730a9872b30a541781f96e85a864eefdf211736d2e1a44e0dca640f749783319f256980ceb2aa404a050b25716e2ba742e465573aff2f48f7d290391917e75d19550fc523307bf668dccc66ed933b0b36d0a298ca126a6fa84c95277aefeedc35d08b300751a9b663b8c33bd284953370815c6018a797eeefd50e8a85849863fbfe5033c3d8343cafaa3aa940cba3556b3eaa49d1ece86f3ad43e9f8732963e34a84b8b2fb84178c90ad99e2d9c3509375aff48d3978ff6a168e506e1c498a08d49afc66d600022861f6d0d63426b71d7338a68195e48197536e64bcd35336f18473c83f52da53eef7ba859722214a75a3853a4acffe3d2c7ef25af7665d4a170acdbf93d6b26b5d397766b3040620782310fd49f8cb85bcd672893c8c92ce8529ea3a6ee11e6f19f0ee4701f2be841870a5fbf528743f3b9dd6822beeb2c43fb033297ee5ee58a6c79e963f37653d0173763c9416928596204ee672b76df571ab100880ab14c5a551ace48b70ef42f7241a364623e3b343bab2a590743b40ded965369f6bfb385c947ed79ba3a3bb07c392df845caef50b0fe8aad6788ab42a91781a5d9aece724cc943d21ac461886a152adf7fa7bc5449ad75eecb3a085c55404154e268ebd24a4faa43d47d74fbf3a035c2298dbb74c82ddce486cdf558d93ff2a6d773b33409f0280e612638ba14c58bbf8115f5962cffb80a7caaef6dd9b1b28a17e40374cfea48c0456a601999afa25928e7da9a2edd9869bb14222d0f2bceb1e1f80d24b31188927e5809d7121e644b9b17f0a3d43ca96a60e824f746103c39f2a5e6183780b9cbf532581ea8c0e941f35554a16f35fc35bd465c727d118c755ace8ac5df3a5398aca41b1dfbf5720cace749742089505fa1060b2f51884c17c7b0892eccfc78cde1102c5ddf9795755a527adf8d4ab0c38295b786ba97ada58586c88fbac05f0aa0ba88fccfe58aaadda6aa3f5e7581534b5fa2f7979402be9d9d3539dc7acd89176e0dedf2e656eb858e54c0bf611d0a2e6df05a3214181944900a928e721096311a05047e60be96f95e170f26558407e3738561862b6fc69b6d16755156cc97be0f6503353ca3c369c07c9d157ef35b02451eeb37a144c628c6bab859d12929ca385f4f46bf29284f175c7fcc077f8e94759e628c35a74e1a34b423d74634002241700d3014ae6b08c873613998ec89356360a492f1c1025c8af026e5c3384eec8d95a404a485fe56cdc89ef92c240160d4432d958cbb9f26c9b4791c9a714afd53adeba5ab6b991b5f0accb8f7ba86bdf0bd33bee8a3a9eb07bd8727b09794bac421a02bd6a3d6c28c9529bb9af3fd033a51a1fb67e06b576d164435cabd20b4d23cfeaec582c710247b04820bc382a9d07d78e8d933dd383041735d083fd80672b2e0f9d438947c417c1ebab58a48c91d2268e863f20944c69bbd531fa98a278c78d908fa4bf3746092b55d489f42c507d2978408a5673ea3b472bf045d8452c5cc09f2c8b27a4b5618ea486ae1c65c577a240ddb245d78ca5fb7ea9cd901986530ffb89b7f71f3418818da8c80e73f589d4cca862213a28b82d0a7ad2b02e75f0726b7625b65cb20db5dbdfbf72553b24b4c525da545fccbef1ddf4798b4cbd3079f8666786ad9fa59eeaffa816b7c716dedbcc85ab9a7af6c29857823c7a0ccb6ca1f3029ddd1aae6deedc7b4a0f48dc1787d01a2fd5473e7d8c8b4bf0df20c4c1f5629eed0ae700d9af406c826995d7c905681cdf14e928ef06626fbfe4ade4865426228de6d302271b1be92ec5e2f19e9edb2d7f7755ee41265c1470ce818c2189ce9123da2b70cb630ba15ce6f39335e8deba9fe4fb3703711da0b6d97f73b76811b8468c6285bee22c5385c823ad50a92ce78be7e176229b15f922b5c588b1ad37c990ae89221c2469454a19c652171c0d0724ced9a0f3b22fcd5ccc890133b9a6ff2b709bec164510b89458c8196d50f11d14352ebeae9bdc6d98ec3f9a381e31a1c1edd427e34373231d943360620f412a832381115ea31af79f16962099cae7c4ae78c97a0d2776b59d2fc31739446541a3ca80113f731bd633f3576d579a64c798db9ce064304239a6d62648d5b10b602e4c4efef1ece1f5fd5e99f068332d448e22eb9051414018d79d21b15367e8b897703c45b329bf33602b2d5b4aa6d5cff918134261e25a094da77a8f962b8ea96c32596883ca79dea6f48a9f36416cb0dbbb323186f24e597b6a48415bb9462878eeb4c760bb99ad0798d14c265d186353e0b4ba81373572f81887a39b015dce6c6b31169556f146d375d11538ab9d731ab99be1fce94d18f829530d2995d29c87e1e9b04da012ce6c54f4ca5df882c7b5f7c7fd8995ffacb6f1e9c2b839924110e9a0827f6e66b8991224afc2ad6297d66b01f7e58aadac65ef822e0ff02c8fd9ea22b93624a1f41fdbfa267f825758de9339a0f88907c8c39c9d42ea8fabc470359b383a97cc7afecfa8883bc5dc4e06e727cf98c175d96b3bed5836d0411a74b2d646ddbcecd1a3bf3e874b4d1f3577a943c6198ca20903194cd295fc4cec69e665fa8493d361c8b17aa4cbdd0f3fc82091544cff3e0a5d47ed017918227992b9f1f7290f064aa08236d4c7af1e977ae50cebee327883416fb455c9df3de63eb6dd8ac7da15f6c5481b839ecffe6bb707b3b884f58adf127b4f3649859e8ef7f5374c8b5b18d08483502b160461c711beef5426874316cc49e6a5ce41b8053ee09bb5377e064df37b22d549a0c6b06195a4a5c35f88713d2b52557b719269ab2b409a19e75b68fc36ae33f7a69df5f424e407f384f25f07e6a1bea5cd3688a702f1d8a38878c42ac158feee2426a76a2ed3a43fb3770774b20b996bedff8bed1031c3728dac3d96fb401516697e44b3b726f0a70b5a558242ae1c009a122c2a124f9db0e080e8e503f60c8f5b217cfbc9b3cd5686320ef4482cfdcf1f774cb412d241854a342a0435dc3d24cd06e5b50b4db996e52b571b6ffa1aaae2a6cc4c6bceb15634eeb8deb6deb23fba9c5289c7d9afdb2638f27425d3cf8389c993af9c88a36574133ce90510da80238820a735fcaf1417df5a47caef6bb13f344ae331c8cb6aabbf02f35adde1e61ccba7b8693bd689e8b7293807835f2e9bd7f29d6e350be0586a5300769e2c074ad708480393236f76809f318988d24fdec9e0727468aa68d6a5adf999ffa7b904039a1d142597e3ba81b6d9c132df9a9f4bc92a4b1ddeb58ef671f0eb781fa9cf36c42a93a9781db2143555c9a662192986ac223749c46d2ecab662d04f253b26baf73df59a62ed911339461416a1ba8c5dbc1a56adfb4de3c44106bc83ca6860d81e974abe4aa0d78702a038934dbb4ffd2d5b029251bb8973a3fb5ebd83de092363f03de6b67d0697c1fa45dcd0e3c82f9a1f1d035448720e4989d7b0b2b396b5763522d9a3cf0058d3aa5a34ca32d8e06cb49f731acc2fa79787cbe526191c0c091a9906ca9dd74f77812bf7abc011509311d074bc002f1ef4ea13eb0ca1b0e61a6460e06af828b46c8d3324d21871157adb30856b3dc4d55ef8b7d474329c9d1ea6f32d8cb50227e92aef07d6423c81710f23fb3baea4729f69c13ef87ba60643ed5d8823ea49b6ff82c15ea56d8c0b4f0da6b95f95cee5be4d6ae94b19127a2e1c403802c9e8cb68e22717398dc51de3c3e085f289d4ee63b02682f2550a090a408719cfcead1a8e6fb7a172c6345867f5a002ee255d0c5721aec706c9e35344329ecd4e0d0a98e28ddad9480e78353dcbd0f513753fa259e16d4dc9e57c11b8124d6a667042a239b3744bc0f5559b6548d06ea52b37e3b15c6f5e6f04067662196446f695eee083f90d233b227a07e216155ed60e96520b2cdfb39bf03f680e3dc3391ae0d4bce2400802a6a4a0d044c86534129512203529a83046a6946d5305e3092a3aa513701c46fd712fb146a4946ececf4372a5fdacca746869891aa92fad4859c0df1a8521dca6c7a54021068aa072018ee18cb18713d154dc36f1cac11cc721b7c253a81727d65ad477c70b7c975a003272b9218121d3ef5290fe3f6027b7eccfa4ce1debac147e8456ecbc70b71856b646675206ae93b9705b3d7d83e6bafb09c1f8711948f0064fd9a2a3317670b68582187cc0a9ad357eb67ef05f4da5dfaf2a0efd5387605ea0de92a5ca80e84bfb17012f0b05ab0b05e775442ee122f700429e7e6a47ca316b5cb26c2dcec6f4b69422863d7d18b8c440edd58802255aadb9c6f850f40c4374bf7b8a115e18c5c6c7c3deaa9705374a3e56fac1385531657a61d39ddc80ccbcf5757a2c87a39017a699029896fbb1e1da6d91b7742e9d5475f690dc6ca01cac04909593fda6d9ec0c7b62db9d94eae1b37768dafa34efce4d11d4a1d92386d49222650422a0201714277a174d305f129937c3cbb6f1feb256ecc169b6e9f5135a9d6bcecf86355fc58725520ccf3a7623044d8664c2dd242c586c665b16b53a4e1be3482509a0c525a99df5979267c5ff84cf017dddda5bc425bd340f85a9736beb4b21f0c49b40e6524bfa792d9a5d56af2fbe4a2dec5c9674178370c30758c940a40d4d43395224dd74275d45158272b5749a80a2b452ec628aa39cc66e09ea3187bcdfb1732237753729af7822b6bf63b545c63eb8ca3abb509a93348bf0ac67a3d33c5d3c2e44dd48dd032b8d6bbf06b4d977f172d79128dfd7b146d17acf2a1d551f6af67159b2055e34717edc311b8fe6716e20e2b0ca0d9643796c50c78f16f9a853f2f4ccde3b77b15a218efb88c6706619cb28a4c2dc2e81d97d60dba3c0ace6d696ae7e0fc3c804fc9e7f3930c06c58a1cacf639a68064763188b9d9a97260ef0da4c3cab4357f131a197f11a50096a8d52da3796f5a901487bb89732a0a6e0066bfa8033414b0b8a728317166dddaa3e01568706197556d9d86a8239ccfa261b1d573da11cd01e556c2fad7f9cfe06275b8d3bc5dfaab610f4c9dee26bc88f8c1a32026e4ce0fb9997671402e2f1cfc6c8ce677eb23f250b4d99eba393c1104371b5aa9adb5c6f7a1892cc6dcfa57ba9af615429138c9c3e1c76bd6985c779df89ff8b0e1973e300158815fe360ce19b6dcf9cce602a076d81daca4d5d2d7725ecbd791f8a49c06dd4e023b34afcf393cf0f98dffb4e0cec91abaf72dcc07398796cc6452a13ae989d2b42a7c67738aafbd15e016b3cd201f9120b806109f62780bb65fa902d9b210ee542a154020d3a22b66571e7658e1f3fa8bdbe3487d1806ade658b90b64a8ebb12ae136aa9862acec39702e4d0138376e6b19faef4ec56b9a39079c5e442284afb671c2cf61c4f950876cbd40725bddaf52ef4484581b7ed06e327b2050429db5c44c697e8de817f19403ce971644dd7e30b95969def3eac37888e7c3699f771b1607d347bcf9d201f2c3b608aa1485c1478fd142e49eade17e1a5e7580434c9886ca4a05a7eaa78f68c005e875f645fad0df66702202bda0272a26aedd4c04d7356b75148ed52bca37f3b79d53df7690a39ea85632ac04efbd91071f63e6c7fd74c05aff1c2e1bfe559d5f68ab7d29ec070a92ade5176375b26ee497ee981b29e75f619e9c3941c79b83f582277c2de3b74aefbc7ed6b953d0ab69cb65a6a9325245375439b27fd60547534494b48fa5b4dccb8e55c9823ae34733c90157700f95f26d4fa5c1b2159dcbf2263ead5d4c3b7c7fa8a67efecef6061a0db383e3a43371fa9e20fae1c6730b48e8db4e482ad4377b96e7ebb214166a3723d3b4b692622e99a58f0025cc9bc00baf29a6bff2638a668f760b01b4e6c9addf5a305ab6ba848944bf05714b3f8c4b0483fa6c80026d5b6606fb044aa52add870bf3a7c93477467c6e6eaf3b621a1b147d8d0124318c6fd6b8cbf326b7ac39ba3c8e33ec2ca3a166eabe2c2778ac8fdad91134b17825100f5d915741bb3fa3d348d96eb81f5d04f9fde3d4fddccce01a3d9af39d93bafffba6b11f3b010a5ca4aa030e2a2d86931ae12d8a8b74b5a7b58f05735a79f4f52bd9ffa821a1764facddcfd62dfc53a82b9c1eb5ba4e82a9de30f40198b16bc5b05322076c499a6e2f11e12946bf60fb498709e50b99e84e65831c3bc778d83153cfeb19d02ed65f25a81401a1cd169cbe03b7a395f13ec3cdb256c818b51c6969d431e7047f77515452afdabe324a4dd520bc1be5b19083c021d883af1ae026051df8e183092329e5e876261fdb3836832a319a0c9b7a0742c3a543d3f6690a88993f5712e01c960ae72e6b7c47af24d368a0c99176912600a8fc8cabdef17c225dda41cb0183c1ea766d484b479ad549f813c4ef57b19273cf010b3c2f1b3c5bc30ff64d42ef871bc0f2113da14c350121ad7cb65bad5934989fedd9e6be3508b854d2fea5778cf0d60a5a5fdcec6db7752bb6938d03772cd32fafa380b48b3e85b46393294031976817f93a1707376f5bc21fd1719d97884d477cb15fa928c0802c27f9574caac31372c94237874ad0b0c01b2d92ae5b7992d92d2f81853e3344c44e82c9ac8e3305ca13953edb7682d4d9d7ee785eec75745d6424dd753f13ca09a6b32c28a649426011e429a2fc1d6f8559256a251cccec47a2d6a05fe50d0c42b4a47429799c604868965d08cc4a98d05f95cb7f1bf19e435b443c21c2885146d980c6e3a7523a7845b514373dfc3cb665d3a9b1526cdc2e2359aeade5d20f4aab35a426605bed5b58ed3e3ab22cbcc1b5d795c5ddb642711cf7575de5d263808fc03b8d6a01decc7d7b0f745a9f020e23517f5bedd7613d04eb8bf91a2c59d633c2e83f175aa3fd28db99a099c2ecda0e5766def9c0810d58f1bedb40b0e079517bb7edb4f1afbe99f9718ce17a1b8e89eb5a434236a28e03ffbb153af8427260e253517062b9c82d18021290ac3bb85e24f7e2d8cf8b9c4e898bf6da215f50cba13e0bbdf2c57d64421a152871a8854de018476e527996392bff4aab9712880822deef18b70f61a3a9dc1f72f329301dc32f4979524f450139e817946f05983ce6a0d49f76d1d6f8db19488942306b3832c0e5176552b2bf70d6a1d805f9d5d9f0aebe50e0fe57fdd15e03674175ab71c6fd977fcaa9db91a5947e12b63520b6f0196176d839476162f359c37318613d36b1a26d1ef970ae3d67407e0abb565f92719fb1631c654c746afc89bd6f173348e940278d64aec4cba93e8e1a22adf718e28893e93841a32032f825819c395a3c20611e483ab1aeafef831e1ff0f578d891abb11ad3e6af77e92a0621031ec0abe852331e78db5f9956ebf4a88f7cffec7120c7775710514cc7d60775629215bcb44f95a61efd75343943035bc15679f2059f00d14be8de1eef800d8c392d62e56ed2f6d9aeb433cf2a9c7fd28aac96433b97e40fd18c113d2a9e94d60d8835574c517a9b0df65b768244bbafd128e7ded9da2008554a1fa47954a66279c91b195d4e9958acef280a5f4add338996dd245094d4e5ab2a63cbfb342d0331f2f3928b803f3241f5729266a1d968bcae3f8c502806054c8ec932db7934c8cd0b8f288b5b63d6f5dfee776e2481386b65691358ef5a520130960c58a7315ecb78acd14e5a7f82e83955305e75a69c35653fdb1f523adb06eb80954490ce2c64c23c83c5c3734359160042a6a5753507ec3cffc03babc39b19f05e4b2a2cef4e9b74b8f374f10b591b2a5dbaa8bf4c8c808d37090a57305490c62caabce24f1851b7e0a652a645b6db7451a37ba008bb302dde9669839d38f4f1dd4b946bab8a89f0003f001b83206aa310e3df2d48e67e51e91973870461b92771a86029adbb031eda672188f48f05b1543f6ee493cb24095a7cdd49aa8cfaea807ad33eae491f8b486756e50bb75d8ce0f565642a548fef62e36acce505f03bfc159b42589d56e17fdb9a9c1844630ff32f4a0799e211936496e1cf38e386c2ac06ed25fd93db8def09ab9e848f3132475327362eeed1bcc327a48c8a47f9af0ce82429a7cfb3721ca88ea032e55cf8db2761b9d7cebb7b1645698f26cead899e656e5eff561e4a691c3526aae821c5c975d4e4749ad56003d8eba750563c1eece5ea8b0681c0138dd8f9d9f3abbb9562cf2d8ac7d85bffe98826be26f74cf64c481298a0b662aff5c733468285767e7eff3e5c85ea7ba13d96463574135b0a9d3d1a9cdeb294789010d3c7704ba5d2fba86bc32192964679db5dac94a67a453b82f711f5e2f77ab176976096bdfbba19805ab0d54cb3cf0e39fced9ce3ecf02a1666fa4b137761d28b3adc7a128162d425b18de21e63fd15b54e2a7384a0652e949e80a99755696c81ce685ae97bde2abc7c527161d51bce11ffc9d4217a1a06144dd4334444c48c95a0bef310f97f6d3723b4442afe3f84c22b4755485c029a11891e4ef71566b6e726b57f2202c956a07bb305d6eae2ee3952b1106d946463fb8b4549b2be394c8ba52a5bd5960d04c043a6e8d8c1224e853c9e2d0f110829a294636514163435d5203d0980b80fa3ba2f4a738f2e1e41dbb1d6a1dd40ab59ae3b3319eb2b515dcc5aa88fe27943088f4c2fcc276b2f832fc9486b4113cab0614506d2c7c00f13852fbe6c2f2abf6a03b85698d98f978661ef01365f583721cd2db81b27dc6c59d7dadece4a89ad4199bdb830c70ff3f7ba40a3fa51a2d3d217c350171c733b696c493a4bae95ad74a8f4de9225df52c4e6fd886d409e49b75528449b5ffd016a5de81c1bbdf1035fccfb1262e2bc7fea395a415968241b9a8681b22f2386caae4b231c9418ddd899c3115c1610595e167c371223af506356b1f571cd6f9fc08e03a515ca53f1c393dcb3c4d215c7356fdd1b00c97b79f5976f6d3aaba638bdcafc5ebdf94fd6308a9e028324caa9db4c334889efa699a8b5533126c7ed79a0ddbd3be8abfdd40727da5e241346ad0384356c3878842c725d8ab2befd6aabb79a905f75fe59fa003f843a4ee308ecde43efb5657b16517ea1a95a8dcae06c9b292e343a27d5ad710d2a2d7e74c6550ef3598da9420c9c1a70fa8872b0c406ef13ccb0e1d5ebd515588be3ba3ced5ed9926515de0553ebf6d4314ff7ba9afde9433c8132fc8ea2de4e8cf8c5bcee7a840d3bff658244ecb4aeb8531b21eb6370310a6cbf22504fd875d5ffbf8adcbc034168b3dc6ccde1d4e3ebd7ceb052d077c7553ff58e91686bd463210424a23877429e293ee095ab0af96dfed210bc646a1355dc56b06c00c32ad40e260df41014931bc5f910d7cb1804e77db60c9fd0356bdcc3389d6584b2778f2de1b0e8a62f48e081bb8e55723b5582d76cd4fae9a94a333962ee60cc1e083035968655181e8598e577414a1ef06e9db0af9172b4cc6a19c20424076be37e793957782139d46e54315956245d99a80975616c974f7e3907b0847f5acaf941752620c8cad8b67ec5a15d1b0124c0d5bf84a0de03cdb7cf89bf5dc85ea45c702493095ce9e094d133888fe2761b4c61d5a0c350a75dae5f0b06ed7ca930dc12e56f7d6980f9b29dd9fa2ae927d870b3bed3e583845b2b9d560886b4e876dfd79cdc9a104fb6173f26dd97416e179d2e8c6f14c7324126c93f383052e7a7b13d7db61d31279cf703e7de4fd53dcd77a4f3676d45742d18a32bf2bf4875dc127f76fbdd3a1732b860a6a520e7743d7ff1b29f1e6635a30c14425092bc882a22e52b7d965583a2ace519c0ddb0aa9aa5e960f02029b59632b81b92dd70f3a37400c6700c44947a0e7e16810b1f7c746bbbeb8f44ff50b473e3972d29e41729d594356fd7856e8648a7d089e8c6d282e86c3cc0357ec46bfc8b4608ab4c3e7247da0d75f16fb18e43b4914288c83fe74eac4872e433648367be00a61d5caf5dd7f6a1fd4ce64ebc016fdfbb83c93f095a9ebc49e07dc6960fe52ec6d6fe93f32cbeade74f7b9fc95adb34872e12d9997bdfa51514706d709f9259d6fea1a67e7959b3d7abc8ba5f17634403c332c6f96812e940be6bb22395d9ff185b573dc7d927d9a18bbdbfe876a90508e38433a33d912202f555fa40c35eb7cddc3c2005ff54df881e9ee8aed528be877951071821f8f5a0405e6c9144dc129bc9570d46ccbf4c931904eb0efabe7dea4744914b82dc84df4aba8ef83b520508d0427ee4b427e1c6bfd579fd577650008ebc27b7a801e65be768d2ecc71252a487343140ab2d92709e660a19eaf768965916b5977b158fee36265516271c20b965bbd36883c6d9edb080a7ab0b3fa61bd449462796ed02e6aaa0cfc12ff275389fc46f63dc502cb2b4fae5e9ede3ba825d12c50edf0683531811ce23fad0e998634aa272f2c8a84f40cdef3adb90b676f5284d93e772d2c2580ac3366a2e215c59ec13b6848eb18ad757c265300af83e3c485bba73fe87d2f60c96759c0c332214f221ddabfafccd2df8b8ebb943061e95a2cf064c9272b36970588835bcd0acb4accf83da62831c922e216fab8278e89178fbe09b0d61f9a5deb45239a5648e9e2e58d0c5839091af555ad67a4691efa0b955714d1e07c68f04f3db9d6cf5eaad174d2b900469da95ee04388ecd51c367e3c7f8c7c6544e086472a062281d1f91bf9c1f903e021dbd40e812b902ad1727ee7b52d568372182e58773fd094e9e3cf9f34f95e17f1146e64ad89b03f103e9c209636e9aa96e7bdff4f1de1b7d01c087bea7034cb21be2928e4351b9a8d392417d12b6e7aa92825cc94681ac65b07541b6825ac206bd44de5c29734fb998c7dfd9dcbe3d12b62ede40fab769b78beba2779c4e8a57f1eb74333e90fb2778f29e12037a15a3820bbd66925489608ede372ced8480e42bf895947509fdba376e75a0b69f1021edd689e845b06c9f166345c9a286e629407b02556e400c33f4d85eaf0391845f8128d5a1ebf4c891b7307327c09b8d4b7b1d1570304662ea0276a88d1aab42527621f3709b97db0b401b22c50305680a7b6ab57b41670af7720c8518e4c55e09174173caa532e5ae875521d07aab424de3e198955598a12edd68724b4d853e9d5774c1a4048be550b54ec46072d4af1852ffd70d85c808e2ddaca540f6d57b8c41f25bcc85f3497d88d21150f23f34a905441d71754935e096a1e18b9b579877f1f5d5efdf83a51840be7dd86b7e47c9fe68ea0bf2e7bae2c76b9890cc6bf364f189789a3d02665494bab265865afa35b90e83d404940e232809e7d343c343f6b472378be5d8f1a422d732b7516c52d7487534e962ebece8ac446dd007dfe57c9c0515503a403c6431a19ebcbfbb8ad88422468372c7eb13ac75d5404514956625ec320f4bcb1df09da94ab90f34a1999b307ce70a655713175d8d6d9cde0e181a97bbdc953c57c668ee21cd1dda4a03b3b8591652931b6fa7588d2aba87dd1927ab5d17abcb7741cb731e82337c4b03d7b2c22ca173d43d99b1834449c4cadc99661953abfc14b6f07dd9c7893483e3acab97c0b534626a93013c7f583e56d41da60e1e2dc32c7a12042aeca90c398e3e40a63ed1118cede205c1265e87c9faecc122c6d14d3eff168c3d21e8c2e1a24685765ec65fedbeca219eddccd811958c0b963ee0decd0d4b1a556059ef1b1c1fb0a1eef29fe440e9181aba686f40fe34ada426af4b88bcee0f5b42d190f39d2a0d5f54f81da966ee934a444539740b65c98115466ef244e8c725b81e26995a90ea793b3dce7505e64f5a57b0e49d4e3d8ee5674d506d98fe37b44e324768af9a64e650c826c893a4ed3a6f8959164cc0c51bc35a695b799a143e7a7dbb22849a9bb5f1cb8e479ff667343e71b6720d5bd43d7eda06226d83dd23ca75f158f677aafb8a7a445b08bad653cb1d4c57c052626d4d56a85cc575e4d06b3a9a7524d950c30c88b8b25b1b4ef8b8d008362db29f3b96b6412b4009df3d64b1c91e609d1c24a0a3d1e6f4a1b536289f84c802118eca0f440f240a196a413faa5a2fbca460a44963ee6fbadae9facc8d7774860b231ca83f2951a7373b6d31ac25278ccc10b907c12244d5c637bf48bea9efc85644a8104974162f04ce91180200d96b11a4a05ce60165dec2b84ad434492b0776b9eeec79e6a9f39394cf8c4a61af13cbf37df3f34ebae8390362e26e64b816edc9f495ab51a9e075375fbd1a06cc883e49e597e32177128e1c8856affa73bf66c9bb73f7597509746377f188253c44be6b457280874308544c971fc5981e58df65b96d82936dd0e2698211c8ae3a8b9e6a5bd5e14cdd1cfad8f39561a9ce14d5d43486ccb3e2eafe64067c621b7861d9a8ca05610c726b4ed48bcda5e0daddc10e1a528d4aa9afec1c5c2603dc92b710c2e92060ed49ef0864710f7cf299d8a8dea2eec76159abfbba917fe32ee1c7f124a60f5f0d70f904fc6fb0a2fffde7c54c40782e7b16231532a401f4646bfdd9375cb2d8952bd19ffe5cb720eeacd2a4e6edaf29563c5ecba8fb417cee552b06415c0008adef19d3e47f83456877d2fcfa87e0cbe909c4c5ab1a512d966de8bb9fb64f7e5366a12dc4d298656ba6b23ef552102bdcd2d48b48f89044d2579418624c63232068d45f27ebdfce7e8310f8ba375ffa7864003f8126c10454475b1af5e9bcd6575d66062ea1fc88352ae848449c73238b2eb72627a1c126736eb3c4e28cb8228995e054c74e79a433f49d0049c88aa6695502418612076b103d4fdb9c2457b07dbef7faccfb05e680656ba060584f99005374210a27dcf69c14ccd9cb2d06a948da743198dacc1b750691d9c1fa47a22e778b409754cb6e65029bc05b6e0be338399c48d97f7c55772f1970c1fb383cac36b7bc938459d064cdd6d959f058104a26e48abe0a3758dc2836eb8547a29942a636cb9e886313f462517038a2b9cbf3c6e083d66061d0fcf3d93a696bed64b3f4c3e6181db4a83ce30360bbc70e48a892d500bddd0824fe6f4b6391884bc025b59f0c7fe3b9a025bc46cddfbc2b7acf84f3391210ec29521889dad42376bf033b5537bb55952fef86b988e4480e8caba4a6dc5358d24a8b510f617657700da65f417ed983c362980bac58add4137f08ba06f67ad4ea438bcec700518a0180d60af6c75c2f1ad6dd9aaaa29e85362098b6d750a30c7199dab98f293d5215af1fdf54f8a059c8ed60662c74e1cc7da7c83f1178a30a2dab9b7404abfd7580737a46b499d8c495cfbfafe3f8d790d567a12f61b2aa0c1e9d1ab88e5c2b188f90a1a154796684e9eb780ac48ef71a829fa046cc342e0a1cd0d78dc23d2c27235355d485eee681e9b1d95c6be8e44a4cd5f17c10d2cc825a3355133f5e764eb5a67e0bf74a22338842a72403c7464a93cbdd955f42e9fc7b37c380e6dbbfd317f465e2ce1741c6146e8386369131a3411f6e30ce20c4f5a651873a11126680577dbe137c2ee66b9849a1fcdeb3f4ff3e8ebc8e48b8b7eae35664c2ea0f53d1d97cfc2bfa61c0a05def8b458f47a8040c6a0a12a8c77062eed666abbccf2f4ee4e032bf6526baed854b61de59e811172ebe021a01af99fcf22afca0f63897777f907394bdffd495bd8ecce7c0415e469e96b0ea5e78ad6130e6c42ce3b231c6e9e0802d2c0b7e0453e056ea08c17f1d4ef6d280b1ed978c740b81d252c6c44190d9a118b444880fb410fd12c67cf453fee0bb35a087064f97668fd23f2470fa0e5cee166ea4f6e8ca66b31e68141f7a0889e40bd81ce79e3053884c45b7d7826a5bad069441cf0e6fe591dea0aade9a673b083d2225aff458ae4e8cd5d40a20b464e18f57362123347c9ef9b3f8fbafea07ec37b71714439bc91b994fb613d98c3548dad74fca815557e1df13a5691c7248c45cb8ca70310aa309f18da72f00c38e78118bc4d5bafbb4f26d46e18ed1437c6dcbc293a9a8ee1519602723d8f6b440cf72f29938aa96670d409a31ff7893d1d2691c5d86ae437232d3cc4aecb480cb7ce043eaf7feb1f399296454c21b1a97c33f9ada8eca71547b62e4eb8c3747352262811993aab7dd39ad040cc493b0904c4d80228d0f04acbb91756c80c3e7655b4d0e49b7e8d1bde9f1057b07fbaca714f19cca22ad8a58ba0d50d46167047b1d565f52f91ee31bfada42c483e6fa63d5cb27676b014970a86a0559e4dcb040b8b8b412d8a462981aa8376de40971ed1f24cb7c8415a4d9f2c79521da7cd804f9f589a1b2356c4669382819a5b2f5bc8c997e26d6a953d3e745157f7dbbc4c5cb032fcbf117c586eef25d0c5c370e8b4fd2ae6e7b6d7098bb333be632c3b1783ae3da8575063630cd612ac351460fb3687da941ab4004de4c3b80c82ac9c2d30c7fa29fa0984ed729f9c0262c467cc757ae3b7dc329fc32ca2ca989ed8df4fb334626937ca736392329422bfd9742522a6ed986d6a5d469d5c4c7fe7ed634c42e5c7d08172db8f42e700c2aa1183b214d33339820d6d27fd3a949d42d5e4c8e15440453da5193dc30e9e6be57f39c27b19f1fc8762e46a43cd89ce7a338974c205771f8f618e41382ab025e828fe91892878811d2c4c482871d394011c7fd4382c2c29239bbe92d9d945afcf1b76124bfa021c38505c365334c787f3fc0fc93f4eba9ede767bcce0929f037d5385d08ac82b31933512b7d00ce1637d73a3aacb4e25766a78b6bd359f625816be11918fcc61aa872a5a2828376e54158f55bc753ba7b4f0a09f04c7ecf15ff9b0c6f5c16019ff8478adbb40068a61e29f32c34d98ff6542f9906d6b49810852084c70539442b475e837c711d32db9545e65a39ed7078dbe76b391a87a096b16ed1488cdacfab13aac11b086f2baea75c26f2d643f12483f271f7e67bb2fd76eb1582f46b87225e9f25da529d984dd6d812d828de2632fe5b684551f2858a343ac0adb3cb715b456ef0a45a690a500009c47dc9d9acf7241e5bfea6246d224b25b7ff1e338f4967b351de00a8ab0a15b693e78c762994493d3602721da3ae70793bec0ee9a60652ee5ba31d5a7fe2335cb52f7e8bcdfda4f17cfc09596a450ad1b928b52891fe2c821b40fbf59c1b6e8502e383a932a4ecc8b3d02cc2359fbe993061e5e86719d1f83bb9230fd4c9b7a71ad847feb96acd333e59e62ae9b0c3cbe470da1697e79e863da7eead4143f54f0f6a3aed963a6f90d19bc00594be2424b6b36ab515000028ff273e264439f22dee98541e29f9e5a0b913edc64f7002","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
