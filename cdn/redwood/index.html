<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d7ee778215a95e55437b4c532328bbc21ef23f970af49e3db56da13b4f14fe7de6b595eb5a5e9c82f288847ec04f0a162bdb52e9e020fbd475144e6257a2a0b080a09fe3573b9d3ffd17ed2953b4028ec106e0517f1f0fe85b351646c8ae7b2d1dbba0099b59893b1c6327a7f7042869b60369efb7f2a6231477fb14556481c00b0ca7010e43c813812c2e0e66a7567d53d811bd80d32713d43b2fd6aed12dcc1a46e4b42ca019b5dd1a6fe51386fd6689d6a90bd1b6b86164596278a37df738dbb1b15cef5e4a1e0fbd9de782f441d9f46bb3bd04239b07b4ae28744b8ed381687e09156a5ad9a980e07cfe9604ffca8a9d60aaec6cbc24cf29dc3f8f5222af61a29b667b703addcd139a84b991c5050001de2d076e8e4d786563c6b52abad38b520aa3d9c3de130b548660502783203cbd7887b0585eff817f165eb5197c0e8317d30787bb7248c7c503ac05884789641716c1643b8514dd8cd5d07ad0ed30ed18720aab10543a826b6280c2f18c564a7e000efb75041cb80595cc93e147460e0243ca4dfada589b2879606cba24eb7945ab88476958a39732883f0a893ce147b3a6b369d7c566e485d0e2646830af718a9a4fb36bd1d815af4841cebc34dc76a88569f8a0a6867a9719103e8484ecdd8cfcc43ee6e87da8c1deac8862f3694b70212ac43cbbe1392656b5234eeb82a1c13378f59a9fdb19d03d872c622eb89fc6671ff90b9bad761814832030be501281ba37942ff0b5d68a24e63eb6efcdda5c8eb9cfa6c6e003d9e1fb08366219824b49cd8493b940c90a1aa27c388ca8cac68e4cbd75b31dc18d6fef2297728ef9448c4ca795198ad6a5d5069cc6f5ec37c99f6ef4f650f42e43e0febd31722f165a4e5f11947e639a09b17b97251471db17ccb878e893a92e21109014c4f64347a0f4d96ff3f3d3973389707d008ef296dbfd70a94d3f42990d017cd2af63914b363a44a028086a083d3be8aaa68e45cb873b8c88bd01f3469d1dbaa8262a8084d1c8708e44447521f97f5463bf4bec71dee6707170ed1aa58b2571e22fccff82ffb0862ba73c5835d01dffa13f627a7edd8a047e5ce8e3b6c9e5c68232064ac1fe2cc906c32745f1868ccd1363ed3bafd67c39607541d24cbb4f8cd1e1e811dd5ed4c2a560d58e20b1f31d4404657ca6ff3cbebb6f92f788a7fa3b4a223c65d75548d7861911da2b3c60816424bf2487357855cd88df5037a1d7301151449f7af685d3c9002383f45ae1e2816e124a00e582968525815fce912fc1e3aaa714ddfa369099d78ce2e6112d9a7bc2f1fea4eedc6a5a350c97a292f8670edd236e1f327947c0fae9cae15f219d4cb22f9f37d7db4b6569343f4c09df251debadb59a2c1b02729ad476b4965344d22c9edf151453e6be6e8b57f3a7aa396354efb1c8530ac571cadb47efd4b5be02f4fdfffaf9af32c29c77936e37fa883dd3a5c3f00d8853c08f7a78775fae84edb9a9de349c5280b25b8be299af2e5d48c521e1c9b6cd45f927f24f594fea6a27867e5bbfc56da2a1831c8ffc51346eb503dc1bc704a3b9d405a4c9aeee9ee2bd835e78ff6017850dcc5462620c8d76d13ff01ede7e28b44871beb8b2763fe62fd4b275a9b131c570c375587750fc66666726a1bbd62251bb1512858402430a06965ef686a2d35519a9953ffb0af33090a41b68867e130423912ccd3464e11fd6dafccd250a5bad7da33a43949ecdfb9685628d4b43930cead72904d2bc354548c4ee57450e53bd70242eb1b0677e4e65be0c62e66f7efb54779df1302fc12fb7262901f7ed6c5b3afc7a234f1ad06d3a8bb24e82900454a694f914febb2e24597c73638f244d1432c9a161cf4bf27ced5cb795be864a1c9f91e70f0d4ce76569356a420a3a3a848b779b7e53f47f2d725b62ba64bfbcd139da616f0c2d5b00a1d173441d5ddc902c1791fdf08b38ccf29d2198abe4c4151597d34e3c505185c0309d2a88d6db6fca1771e93d58893f4ad21284a6c551976d3f6ce868afb5b5aab3f5f52ccca4081bee01761b6da7df51a0cf6443a8eba12bc2a3648fa15cc74da1a0e59b7689f5c3e6ce6de3072865b6103a4c10b144ab87d449dc6a2c13fc20bf70c3ebe326919968abc286ae56fde2059fd51e3822de69138276218bd2e3c772ae5454097541c8bfae66340bd1bbc4f5a122f5aad4537e82ed74a988dfb119982567a91244155c2be8239f2ba1792ba9da6a74e3d374c8484c94ad9955ac9b41d44bd815efab03817228d0b4831dfb7a91a4beaf4f5e3e6c45af9f99e207c18d1fbeb79b5efb342a39a8116f94fa19bd973f36f390edb7d7b1b51080fc7c2bd22a43c1c58029c34fedf677dcd371336d384b1cca21d5fee288c5cf5c826a0a21a22ca1c74e4894025b80fc11fd844fd906df4ba2bf107446b8198910c0b68a77e93b993bbd14b3597e6e35a79ea4d26a0e797a422f3fadcfe8dac24c9783cc2ea6ac082a8d34ec40ebfb06d9208dc7df512cb61ac4cdaefa7ef36358eaf87b328d086e34924f66b1af808a60375c13d81189a6baf01d04ff3143baf64e987f2f230ac13cac952ccba6b85d03a46780409c4f4e60aa813636f91217a820b608790517f5dc5ea81ae2fac6da589f0136273544ea22f3e102a733ef18289b2345d283ac710aa147a8029ccd0e2ac706e636630f1675e3f2617268cd4dafb97df1878477b93fd7d9822d754ee04a51248ba629fd809f38696a64a4fb8f5c2d4bd18598fce7c2ab866f8d9841c9c150efb3766cb8b0a2b68d11fdbca47ab065fe2cc2a60d014a137566faf116a506dadcc35dc46b03383573415c4275f279a92e64ef592b5fa2523b33d30a96399de21b6afdd4e557c161e68286298da53de297fbe4fb0211f43ca0c2187e2805c3be44f9eb04c111039ca511ea51ec8cfa37f9352521457f56350fc3a6f129deafd44a7e4132cf40895f8ef161c5cf2d294079959b1bc850debd28253160a6153f68751707c5a28f51c870e83728fe7d6c2fda70beb31443c654ce420c61f4b69fa5a33b4735537e29e94e0d1ec4a6f7134b7945f065ecfc35c1e65fb9f69b73188513a1993b5405a93ff1db5dba3164d71c508b54a2363e0b15016596ae973b9701828ac2dbb4fda5e477c455c68d06718a9a05c824e501c67ffc9cddd3136c7ebf9c8eac66384cd1814a9584ab8038e17e93eea167130fe6bfd2728f15a86fefda5cd7b0bbc5bd93167043fb3e1e1492794fcba01bf671b0bde37d6b8af14585f5bf1665136af2e10003fa7d7146e9b285b6fa8e2c5d5ffeb5bc7ca61dcc8814d127a2dd2f947a2a17e1e8955bd9d6a1840f6b1cbe68311166e9974b229bbf1cdb37a80bcf1eba5ca8250b814ed0e9922a151af183457c16bcd65486ad38ed292acaa26d5503348dd8ff98f48003af2f8d009a3728d2ef276ff59311286349f370e6f6460f74b978d55126b9d89841ef4191f3b81fbf6b0b5a53f09f82feb203e6e803cf18e8257b49b1e4d74497eb780c6f3c946d776d828eea22174fbdc06254e4ed7c135a51e78026f94ac8880a7a7f88e6e701761f68c27bf82768d6ffa13a3d9c31b7d12f7a9dd93bd8129cabd9667f3bc645d9172a0fc93a40873eb855dbdf79a2170ce425e8e94533d5c3798687fe4b66ea9892d548bfe5579865ef5ecb69a2529eb26b37be95769e766f1aefdccbbe857e41e4a5fb8bb583ab9687255cc1c6da2f9445cd52f291814bae7799117abe31adca43465d7579f61d7e2484c69ca073a03d9a814bf4fcf04491ab26241ab2428e5bce3af2f124468a35e993a45721d2eeb4cc6d6a66bbc3485aeb74bd96897ee4a79918b2fa92b88088ce9c8215df1827161bae97748abd74eccedaed0ae6c4cbf383355439a76b727835b34cec3af64f79338ace415b79dd5f5bf979ade2316ede78275f7a78d189a22274776948bbc5a4d279d8615ec2b29592d26b7149546b3f03ca9f33e5ddfa465ab4b0094779f7ebfce2e15561de2b93a5170d6ebb06f1ca2ddfe490ac9fa59528c6388d3f5b325ac05ea774d7dd5cac13408491df60eb8be2712c765e379424839a6de57863b1a15c5f6b92d2dd6e66b3010aed70cf3928ae7396f3900ae9b909390dec18768895697a6c68c5f24c8a98e021919d196c8b7de3f53bdc8c0617fa78969d1c9defc1d43bf246fe43a2eb4323360cf03dc58deaf37bb958fa193bc0fb1b250394a0a4b5316283939a2216d86ee0865d138412f1ec389b7d2e66844f76ab3c23424ef9594097d183946feea8ad78df4ec4093264751eecd5e2558ee5a867b433a1447fddc80fd4f2af5cce1b8b6eefc1f458dac7fa9c559461d71672398e53ce2e48b141b6dd99ef1d25380f1148a393558a0c9009fd7d5eb7d2126485f7541d83b640bae817a14432f57c687f1ef2ae2efe49fe2afbe4123f002870420882b5cb51586d7f30b83f31b10734eb7a3d26887f262b3b2417a645e2527eb6695e3d3082f4e4dc16422b2c700ca6cb60db4ae8adcb3ed56a40c41429122bf86a22b803f122325421574985beb1568c462fae55cd102dc91dcde6574e35c4899ceee2a666c510139be8949f50c14df18c6f1777ae89b6c05bb7ee9afc0542db7e25f65f0ecf50716460eb65ddd9474183f55bf7f309bda68adf7c4bfee1167d643de428b43bc30a850bc7a23f23ed43417a331a02daeaba880c8911452dd5184df2144285572eb7bdca1f989b03362467a2134f77d0da15bd6b70c33296a9b197807c84dd9ec71a8fff5989025c2e1a46b4788a6f8d9302cd69178813ccc5a43af38cb83c95ae8aa46fc5b724542539fe25c77c60dd7e138067d497e2100360668816665a1fcc924573dfb631890584ee3c48a1ecab670bbf465ff6689b6edf3eba04bbfb8616bbb5ba3775a0e8e53dcdd167189b807fa2b8917f5969926293a2c3651366c8d0ef45e451bb95d2e4f1491dc02a842897070a6872d4dac3e0a31685d5f7f43876ab4bb77a0b95b1d2c53527b8e5ea810f5549e74ca6105ddad8bf22480c755f85f5091a912082e301f13e716f3c126833e040105fb9204828e5af8676fa0140116e6065c4928de5653f0ce24d959e658031fbeca36ddcc0ebaf132cd60bbbf3a932f03f37d8d136ee0411441c6006e51412d9ba372bfd8b77b0df542ea7bb39907b5a57a3c1499e26397654663cb5b9223b5f8c6dd36a843072dbf060bfd1980d78b3126898b07b7531f2893b82d2e76f250f2a868dae5e612e1ed0dddb0f9c1bfb19028a14bc204c702a4511ff72dc62229f499b1c7aa97c9e444f3c2408a250acafec4a99d6ad7b6f8451122d07606041d49d586626bc1e963c4f8bfd0a6d67d47e8cb3c3a115071250cb53ccb074377c564f22221b5a88a868e8b5e178d84025de5dff8c5762f8f4ec1a72dfdd6f607047d630e85edb2a93ca710eba4c2d78263761055c6a95f9581ae9b4654f51f07fdbedd686abdd8d279b009c18fd18b7b7c3453ce4a9c9e6a7af7259fb97d2fea7e66388bfbd9c0d0a7a73d4d6615dbb239dfb938b0785880795e3b07a6acf02caf71403268429236717ceee7ce01960bbbd5e582210f04670c1759662c190e7494daefa6aaecab25ec69fcb09111549dcf24a409ede22a947e593f2d41ee53fe931e0efeefd24ecd08f39e8120b22a4645480bd89dafc8ddf58dc8b56428f0a14223b071df7e9841ebe59d538efde5fbf9f24bc530d7d10e3c010acb4ce10a3bb55219894ed4950bd7120ef37b1a003a145a6c1bfcdecb38ec0497b9adfce69d88dd24d055f22304f894f93d67601ce68235a548ece2aed75c2b6bc06c3d580315dca3ca95e1346de1d77be5363f619c1f697ee8c37bcefeb0f2e64b711375fac216c4a73021a64f029a556758ea49e26b0d1bb8a1a9b94d8f8db9b73959cf2f73f5c931ef83c72ba561933f703770d453fa3bcff5b9ca136b78e278959377edc2c278988a86573ab8686e2d4093b909c1492b4c7ffa23ef2bb770090e7057fef0560cf0d865f7a2403daa08784fcb686d5cb5cebbc301211aebb24e3fa8f23d0c2b7f096dec082342244f28876955b5207b286e91f5dd264112d777f48cda5c9a37712794987fd1a9f93c15b1a203f1fd2e74e4f1e7b2fd654b0e7c04e74c8568f142d8e49d184d10ad0706c692d6bc29b9a37c44271d3fcbd30c884ff399cf1f7a9a93998f0b3a94f55fb5dc71ec413cd80484c2c04d49d273609a0d429c9f8f327aed16dba818c8309401dd9f42c0efd89b585eed4df0d71e24a9095e5a88b408b7fc907c70a17eb41d8f8ae9f4aee7f5067bd896d24224f11350d99254727ccfb761317bff0010ab732c670f35f7392d7602fe070bb2c3674f52d5429495dc56825873821f336c754e25fddd6475e4f446070e29f78351930cebf1f627aabc2946d8eaea2bd2e924b9be6d62a1bce8703027a0e58fcf52886a647d524ba3a24a26842c901b9fb269790044477778e1721b9401195dfcdd3c1669d9ff34ddd828502fce9ba1a0147985a3118c77b39e8b91221173bd5e2e93ce75f64371f9b30d10eceb495e37e845c7aa30e66eada91d0ecb2c010182bee470cc86934b441c6b0c237d61e4d89936bea4cc54357820875a3906be02446aeecf3b8c02a6aa93d83e57b2a651ae33e84ceecdbcc10e3743b18ec91c460313bc520674854165f7ba9902fa9f5f529dc6ab7d5a4ace456237891a490377189638568c579412bcb4b99ef207eb0516a8d5318d88814c52eaedd3102e1940e4b2832ba1463d8b1510ed6e5a41b05668d40c150d6ed37a5b8fc9e2355f4efbe0d76ba643c084a4f9bc785797893dc756c27178ad90ce896ae96bd5501ebe86d85727444442bd154cc2844fefc4e227bdd966796ad3913dbc847fe3a50b4f46f0dd31bcab539858ab1b5f9ae4adf059f4b47d91286691aa5bc452a2b2355d81b5e003ddd63aa4e3b34ab9083759c687ecb5d5e80561a7582483455c3e2d2697d771f8d07e3d2ef1fc11bf1739ac60533e1f8be35cdaf1cdae690d782ae1f4bfacb9cd0697090fca7bcb78d6b1524611ca08fba449c10a38a574bf185b52a102ba94f2113edefc8e4925d5288dfaf3eb2d9ffcf1005e4e8652e94c51707840f3d1283dc4dd26ffa99bf2dd5bf6a423905f34dd512c9c02c9476354edd12959db3ff5f970c328d52fdfb1bf3520a391d09b3390c8796ebcfb968862aedb66bfa8fff8cb0325481c964552e8f93b944a9494b2918a5c4459aaa498b05cf4760d69650a7854b509f79119e9f98da2036c5e775d39615c9ed10b13f049c98ad5cc1023700bfd1dded39140857ed2ca73de2cad2f76ba3dd89ac470b0426dfd12f91b29f80dc7e7be5da6c25fde0c380c3264489595875778977eb8e5b79502d43ed14d3eef3ed50f4fa2c76c900c279b8969e28a864bfa2173ff0d50f81bd9ef950e45ac7b8042fe80fefa38f484bfbd2a9db88acdba6ed74b6a31189dc293979f30c73fe1acf23072280cb2e8a6c23d939e3fd52551e710be18791da464bd84af91ea403595e3827e6b6d446b8061ea78388af286ba6d56b052e5ead34474ceed60656c6e2712dcfbe745f20a9d90f936aff187cf60aa177a265667600ae0bfd39bd034f3ba00f7e8bde15ec8b7a14be272125c68cfea2608bd5680ae703fa95505d948204d4bf3b2b307b8cf9b2e3b61b851245cffad0a9bb57c6dc574150cd18679ea4dc13277a9a02cb91f98a96511f9b276514652589c5ee43be596a52e84fe721724d217601620c92602adcf6f172fbffd65c7aeb10e2843351bb57d8519ffbdfa78b3a75ab00c7dfbbedbd68af7fc398edef1f9c984e8c617a09fffe75f8983578bdc0a625184ca4e6f1e0210adfafef60dcd4b26ad0d3be5394e9315b4aa45168498a35da1b6a0742c6c6e9198a94401cca7940cc7c386d1865e2a7c0a56729c29162e7803505a34a8ae09c4d9ebc16cf5d018f9283cf943cbc4c8b9407390184230ffa80e97e7fbb1154b6dfc59807e2bef301d6388322a843d80141b7b8f08107f9d28a2e004b18e8c1e8b8af50fd72a6b1abc0887c6fb63b08c4d90823c0386cb54e34f236878ce6cbc71d3d94971e9ea7558c240caa40f247f13187cd8dff473f8b966543acc385b93de8198dd1f6450e0f6506794e0620527162b4935ce15a2ab657cde9fc1610c38036f74c1009a7bfc0acb91fed97bfcfe8fdc2622762dd8049e8d983be746f057887c77f82104a01f87e71e2f4182430ea9a5b8c33a115b07c0710986956a8ea53defc8ee3dc92981276ea8ccd399c1f5e32ba98ed5477946f3013345f503105e4fbc8d9e3ec99227c474d72983e76cca4e19e1927569c205981904a2d4bb1bee3c96b76fa4d13ab52d2fe1276767a645b23a739e34aad85a30dd25d465521a6f26b66d86d8e3010bf82dd756b11146f9523a6a80a4c94182b46d03207e4a2d884d43c12fda8b45e74f3178742c3f4c666c6c23c408b6af34e8a1088ab1c9b313ce5218cf236480fda3e7c951204d6c9ae5741060e1fc882e6f3792b1e78dfe458437c968eaf039e0c97b712a69816caa7532f79b2c12d1d0e44a74caeba6f313f27063d3383a6d4854a3fd37f87f18fe975f103929e9adfd80dec6cd39bf16dc0c0d63f367f8cb7e02aa82c976899e8697ae66ee466db5dd6ff75bd2d6f5133660676e7ef46230973cfea28fd8b3da30e5b42da4226f96593f15219674ca63d9ca82f7acd98b752e4fe6d340077b28983812770e5b049d8f0adfb96d894ba9ac72d074fdb3a610873fea722b28c48352e26d8e38406f5fbaf234ae8b6e8eab406f104136deff3b4df640392e63a311adbee901187b2dd11560c723f35c4f9691e8317ec592d17fad4cfe590443fce1c5d2a96315a3d18f06ee60180f6d1d858b114033f24bf2401ca7a8fd27924f892d35f607e1e81625233b059100b174b69b9fe517154e20e2e6724ece07b066fce748ebfb83135aac529b15b87223c7e60e99f2f21e55d3cefee8396fb8d96c6ca8983a92de91520a3ba9b6fa798d23839d5b2d5936942597824b62a9ef173b31faf94bee4e87314cf349dc744850fc78f00f5e0187b10e681abc9bb761839aa1d966895b21cc1386eba7ab6ad4e89c9dcc174ffd67cddd52ddd46563a94a0db0104017a7f3cc6332e9ff94beb4cc5d98b9596fa726f266d91d9ce8dc1095080e1f0a3d64d32a0bd714685d75917592453943e305ea97ae79a89dbe5ef91669bac40c4fcc7b18f2a3ac66065073a3a62b35d51a066d5b25bfa6c69a37533511028a93c39144c7b6f9aaa166ca7493f64a076dee03bc8efa0cf605c0856ce6a1316e8c48992efe7d2c62013208b260b1df2b1a8e5fcb51f90c597655e999fc0da34c258b55c0d7c7d26a03c3445c66f33055340d302f5f0500b27b82d95bb08c5a8164f428ae1bd53a4727ec029c400b7201bb26d68820b4ad84766a42d018151639134d16d7482b5d81f72c5e39668fc27ef9c61b9ba3c31039be01f8c1f573ff0d73aa5858208b23a64da103a440026a8d4924f718d38996263091a07b0782b25d43db72469789bbdd2745c6d32ece96280825a4faf6ce1502d5f20efbad7bc90978fcfdb70e247a118a53f80227138b632fa3b28de5055f05cf9d9df1ffb50bf9d113cec934ce6eb997fa432b711852127305b71ffa9ce615a901f5723b93ec565a561d4c80d45761d754e8936efd20f3fde38f8abc4d46f4c6255528f1fe5c1125ba1f15405cf29607fa492c5760b71f51af895f485e0d36aa5a508e4e93c0f082b5c49d91ab1407a348c15de5890cf24042bf47332930f908df8b2184da52afa66fe8d99d7be91dd23933bce0baff19af8fa0ccadf1b8afa4855693104c3c0a6fd84c760f1b596ab869eafa2e695454b3d2d059d81b808e1cf1a9482f7c99b6f8386cd04adfbc1435de386c727ebe94dc745df919f878c944417b572a485eb19f64b23d0ae45c67c45e3d18cfd0af173591940486aaf03de6a7e848b0b7e0bebd298f153e6300e0a9afbd972dd1e83f1712c3162be289da6a1dc99735da44852f4bf57598fc379c7812da731d226e8f2094939403862d224c8fc205a15fd9ad7ff3ab1790b8d9b278bc5ed52768909a4f53acf4248e99f7a4862425fdf7b69e9cc8e4f3ed398ded9083dc32c76e5ffe2e072e78a5f813f503262bde296b30ad21bb9de9e3cbc4d379e766aee62def794d9d9999c6fb9b98947d5dda917b6f12d7ca18edc60aeddd9f9c6418324422258d4d740943abcc206e577e43e86e3297b4f351bdf23fc897ce81c63c467675797b3ee40f8c5fb5bea2c6619eb2fcee95e785af39128f2b5c0939d9bee38f8ccbfe7d724d5b4020c08fbc377a3e63973a0ff1fbb9c5d837d3d01c217b31478a2ea0cd7956fc95e4dca07a272c6eaebf84fc3a84f629fdf3f02068ee6a958615b92d6fcd01497cf253ce9d3037f587fb1d150a3fcb348cd10e4ac5481dad931f1d1ea4ce5cce287d9ff1d7f2604784d53166ed06bf18a3e328c792de24b7f571c9c320501aef9b954b874ba534e30b80927789b449c34a114acfc06a2aa8174d39502ce7d62d739e026402e9f097bb746c79604c0e3798bbe0adb12f597f0d791125a5b729d58367c3a995dc46a2e00df76fe10615534da70a8f960a0e2579042d147f20add6a511fe6950f1b97e6b9ae4c030414113271cc2a3f0c7cac74d2800080bd2c0a8b27f97884886bc885fa6a40b3f26999b5970113303e94183f48cf179ad7bb3de6378f5022c0e55f77f47329fa0f7c919f741eb8bac68d359e07cf9228e5d1048fb0c982b8beca2e164f557b31ee226d6f74b09b8b9c4bc4d621ad59f82546452f820fe0693cf816fafdf2fe8c58994e8902a8f4231af856921a831f651dc718f306bfed68c01b071f2264112849479595c660009c6d65872231da68546f6edade3c9dd6b4ad9d79b6b8e769fa21a521cf45e8e6ce33c5df41e25cade9e598c3e97815917dcd9f9d7d7593d0f392928e43d7dc37ce2928f1ad883d36121c71c6d964e3eaf6d1f6be5117f94e835dd5bf066678f7c5ea1ccfe3a6ba1d2f586f24a9d778e460b144282b205862c84542a692df5246cff32eb6dcf2ea52b9f2c8f6961f8fdcc3c788d9df2375b98836a7630f6686baae924b318f39b7417d0298f8c01ff4f92e1f7a5015f5667343641c87a25ba765250d373f91c8d674330eb33fef99a199107d509e8bd57b8d0f96a30de3a95d433dd93d0e334f14b32f60540c910468657ff7fe7b821a9270261ea5b474f75beb8719a18d541d329f387005c80cb32425d459394d31c1e5ed199bc8cff3ba3dd917f72c67f02fcd5a08c5461c3179d492e5b11aaa7cfd60f88944ff4a8d7014210f0098989009cbd310d9d3e9effd37915fae1da8e678d1eae062105ccc25de46376ec40ac07c655bf3f694eabdb67edebd67bd02378b65c199cfd981e2dd194c2ca9544ded618762ae4dbaad4e36f2b4fef3ba065a7f1f17230418e8204dee27b9f97c3bf33c611feccaa9e154d2a5a60e229366135a659aebeef60be202830f645f0528edc63cd712f53b146da178868a6d7adf60b5452ee25862936089d7900c84fee86756e3854a61b6b57f5a8f616966d1ae35e4955472d28b6038fa1824ffd73bd34f2eb96baa9cecee013aa601705ed1d4ccbd8af2134af959b7dd81d87918dcf7ff0d9c12c44570c7a4f986438b1984a5e4762b90613424ddc0529cdda9888ef6a3bafcabb289688493a61d13806f7f8079914630e672cc5d3d6bf26601785c834df33d30e24d00a13ae544c8740b739a7518f11bf83d2c00aee124bfb85ff3376240156886c5672426d5e4236178314531cb4c884cd004f18a0dcf58f5be7af1a62ef8ba9a1a9bf20673511e3a5b84e2166925b826c582b8456fb7c8daebf5f53c3e0d2d7423bb925809ef9975381bd1ef5b5f25a34e3536a14d3ed39f3e16d590174f64433ec887e1d828ff08ea970693020be7b1c571e7e55f463519192d450098a9603eb09f79d3fdbb32e19a107b35e6f35108cc96d9a5098e2de31568f74e4d98a0c4e8aed6339f5e0f4e31f711e54f29df9869a2716ebbd8dfebcd720357ab9d9f24a651cfb216f5c833d9acc7798cb6935e5e750ec3517ede2c4de5f9d87fc0aedecf968b733929607e4d4fcca70fe19ba32459acbd2f5a737f269beed6a2b9e636f872b032be2b0c2d01a3e3672b86080e5bac8dd29c4fd0bf0a562a9c0c3d3330c4caf538f7b7f558287de50697478b81ecd0a7c24157921dea293f8b95bd6d13763651c74657e0a7a527ab9b40dcdad2f1a2e01a706b66003c0156bc7beee77bf13203b2ab81b99b6d3cdc1b305cde9f30209c4971136afe9b5725a1aca7f3b39f3aa0642a052e9c60adc68a5d32d870389ee8736b0429c3b2b1f75539a0c0a6090f681fc98fc82d6f3c9473ba96ff0ca0103bc5527a2bf8e59dba744d8b697d538eee4b1d877f0745a88a601f81d5d80cea75d9e73a47c6508b321691793ba8be7ef86a1a63e1ad6432d4404137a1a3bc948606aeaf379c49c7f5b11b327b14d76bbee59ac025e268abdf0268120a61b2d6b1fe85c3ca6bf236c0e745eb41bdd5f0c4143691f515603176c6d1cd9d48beba5dcbc82e2f1aa64083c4aa3e00e0e9f155ad82cf62c22dc269de41112b82c0ec916ed390afe965975a733547d27f0c2bf37dd5879dddf0fa29b19f5814c3beeb05d938d1a0101363f349dda3adef743b30815d01dfd4e77ed802bfc90a85415696f2b57fd564ec93db31bb9c63201d42a339cc268088072a3f588a9ffebb4b368eac6485c0e43b04a7301e060985ab822c5423d377dbac42521352f7fe4409dc005c2320a7fceb4bcf72288f7a0c184e87d8319f4070817c48ac38dca782d1c11e116336b886af9dbbad4734cf23fc739126b7a8216f1357d598074ae9d149c7734e3b4553331dc7d44717373f7376e90e23e8fe9bd5aa91f252220ec47791c4ea8352abf3373f07488b7ae8a45e215bd81c2e8c3cfedd9cbb862f32d347832b37d52a478b48273239e5e332ee789de8473ba7340ced2b75b46ec6da566adf5a1183c31946f971d4b0532dbd9a328239ee9f22c449a95c0010baa17d1c0ce66025725a4a027a3e92c9c603ce2032de49a7dc64260533ac9b09800355af442df1bf6ad4fbd416a15cb5314d4894e615cb38219d8a289c6a01e4ce9bdc14343404e6405ccf16940ff6b48202b21099550ff54b4b0747aa2666ed43584da7a290be94cba390c9ab99eae752998a8ba77bf0b93f461bb2f94068f88d1eef6fd76b66f240af89b92805d7607be8df4d83eea78f13ff819e7e3f64ca6e197f8f47f229748581f418192c5b270eb0acaf9e03f7c96c1a8b0a77f330dbd2f45ee8a3f2b316734be78f5d272dd8ca7e143cb00894695aa1b1779f3803356950371dd763be33b84b8caa07c7cf48b62d7ccf7e942a5821e08d055582019a80d05e7ff1393415ba9ec7d98fe05f2563f31bd409733d2a4bcae6c88a5f8e5946ea5cc5c59d7a47b5e12391e43db16b67f003ee37253323961619eefa69736da188c43499e8b6ce6cd6124326fcac33dbd334d8dac3ba4924c14196d9e479cc70ef58f8ec26666697fb0b77a56c4add2cb4361ffe123e984b82b88ee393befd21b0ab9c5a60b417a6760e59498847175865eb5d32f06d0a47585308a310dae8e7d01ff6df7e5d80286c671f64fbb1e27f95b7d4473786eaa5f63af9d51a1765ba987d2ba6fd0cf331a38111a4c4586ca5a68a574965c43fbfe9cc254e67f644ed1ae87e7d95d5db03d5135dd0f536ccd4e72ccd292863139a3add62c99fe4e26ed18fb6093d68d319c9e8cfbfc309d9cfc830c4f021df636a942aac75879d8a3d28136dde8f0d78b83aa167fe9c9a3ad8119c31af901685c4977d82480ce8836ef38a87e23cc2336bb54a1c79f9c8a508ee5c23c695e728cf3bf93da5c8dab809b8a205a9c4c5627e2e1d4607dd126378a68897254c50a34acbe6cff5dd77b7cbb594a049a9ff484c693da0a662186b434f051a0737963a8caf1afb459e54f2ba5e3629a1a8b1799ad435745076bae5a8c3e567bd514fefe79e38f1dfb529fb2091d4a2082d38f6bbb188295ac11bbea2d29f37cf235a3c0a58d57b3ebb9bc3b023fbf1507e42f4cf64c30c645da243c4a1ac3293c6a4fdc68460df7c1d1661ff896d4b5c40e0db5f673c8789b2a8ee58261d1cf3e2abe5d67be8ccbaeae1fed1ef68e4101880dd013f3e6fab40416484811ae89d214233a3977981a3ee7ab774c6edb2db165c566ad76fc585e3bf8fc2a1a9fd5929fdc216b5e866695fdf334f0642da0b102106c530ab4c9e5212c670e8bc9e80f30ced9edc8eb0fa17a8c9880b9551644da74fe3f15a9443ba29613236b9164a7e07f453a7633cae38df23df8369ba2ee5b5011d46d92cb33bec19ff9373e2e78fd1ef69d47698932fcbf67a68b2f750fd70e409fe8c2bf25db0643e8eb451d3e0f3d25625357648a2b637b4b5f0df14720373b53374941a60fc9c584c788c2c863b9b50db4b20670edb8a1910df9b450c6138fb86139ccb4f0f5ec2e083aa39ac6b2240167151138c68cfdba9f4c227acf4ff4d3c2f4238c2207c1f8c3b30b01df04575634a66f67b78131085607c282b8f425ea472f868ed12641b23f9f808c72bb409cc76738abf2b972cd70219c389c8018c18b7da9dba6db0b0a517216dc134dfd4b96be7f2dde85b9b9546357924ab95728e72d57f429281bc684ce9400bc8363b5fc059d523643d6b2a8a2d5616759b6bd44168b8749a7d8b48d5d0bd0fed8865f0d41e326ed39bf6c5dd18024537684d23b0cc70d9456a1a056fbfdf39f438c9edce3a273cd2d59169bcf11f52499ccce60f7d4e308be33c6a0142463daf2b2a6dc316fdb230e56775e1bf9a5522046ff6efa600633ee563554969aaf67062720df75736cae4bce3f59a5566819b772d3fad1872dcc4d30fa96d709c0a6b5fb2a2d74e4960dd2de40b77d0a5facd58c1330031916d4a2a2249a83861ecae55b566dceb7a0ef1655d18f6ef22ceb3bbb791d3d817f2333748f23206b7aef21222b9367debab7ce091c00ea38d7a7576d623bab4ea0067aeec1b7018b255f3ad82fd32e1a0662a9eccb3b5d54bcd52fc2775d6c3352562e3aacbd6e73f158a9bee9e93d9fe254d4d926197bafb1b04bf61573d057dbd8592e95c53b9b95fb65d65c836db6ad6d2ddbc91b3577c36b3cf17d7953239a572ee9bf5cb3b6a4ea00740b6a00d82656b8bf42c4125b36f94e821a9e1da7a28f839f0f4e601b4835bc06738ae461a6cd71a9e1a4f9363a7a54dbf8d025daa02f8396c7ac623dc54bf4af942cff8dedc3a6cd75b8bc8a6a73b224e461da6bd37cde7ddceb25d16c60aa35b833b2cc14fff2eeefdea9fb0c2ea9de44734e7261b32787fdfbb4b501ecb8392c9e2e1fecae6f50468b0fd8b4e7a63036d89139a60149d255b05651eda50b163bd90214f501885bec57002e6e432942c72d14510a0020fd5376be4076a240fa97a290b050dd927aaa837e1be8f5a9dc6117e175a772370368b79666ea74593aea563464dbac710e427ee8ed9bf11ceec6cab57839b1a2ec15b02bff889cf635709bf956428288d2dbb8ae5064e4163605bc433a107b9580e170f92d551261eef0c767cb857ec74b4ec6d182a7b7f327ce1e8f642dd2a7101c8a46d871ed39a55f43d2fc69fccf812331d41c234659a6ef55913b20d01d3ab59af8c62c0f9ef435f1594df8f43366501b288298252dca68f9e1bfe682675e6f7b3588461aaec329871c091a81623cb572a9da4d3e5f47c8f11f43681e797a41a37c4b817de31a801414d2c9d6e3e5e8311316d7aaf1bf56b1d676f9e6742834b832d8d2843dd3d39512a7a394d764bf92cc8f5813b2c26e037e88f5fd3efdb8fa0b43e0412759203343b924935c3923d8dfb9e4d5d4f3f971dbcb33222f4c13c8e0c4c37f4bbdda395d05f661d0890eb1d5569f057f8a369e1b5febdb4a65cd2b5d8941f249716d6b6cde249051d14d0c9cc709ff2cd5aaf8b18c6effe73b8065b8e745e324227f6e9a89d8c540b4005080ffc26c7bfd342d9f143dd658bdbf783ff4698a16baf28b9e44400507ba0aa43424e16e21ef40b16e35eb6b3cd939242b934fda449e6bceff3cfbbeefa7f944ca1394a949fe5a780a9729deb72ffb5fc2bcaef2aff7358c907beb793164581f0fa8d64b173ba25391c8d05f1fa5281b73eb949dbb43891390960d3bd8678bf2f3a4cade9464b09418f9b31eeae84dea4ab809156eac2586b2d4a3fd284ec0836d86aee201cf7d0524cbf8c67523d39f72a3cea63d15e8f4acb777c62c2a9b925fde14a5e57e487ee5609c613de568f55b30e8c30c6f75deff8fcfe0a27cfc4ed47b8d7c1903d2ba254e970f3781231a837520f7405f47d6374011193b10c1de4d64d9c2b4e97dc02c0d778d51480c5db94c6c68849f0d2be70095448e24e9baa3eb0550a1748a375885a7ba4d7fc9f50e2a59c9e49e3b54000f9821480458f568c1f38d7ff4b85790536c4dc7bf88f98e2e7d44ca484f4d464ab03b002e126674818b2592fc40be61cab3e02d4377f663847dcf5cce3f88a1c3bc6b8f08c1a7a3f3ecc181325d180b22b03f460342459e98f242e667bc287f5239c0fb1fdc4cc819d36911a87c46c203feed498a084d8234d90b3147e854788a890b3a57859b551c87d3a2c3024c95a7f8792d3cde2b80460e8ff853f890921adaba592440f2fb3c5fdb1cacc208d5a8b226ca88286693b1e27d0734763ce2a1f0a221c7baf627ba6cd63e6e86374d5b8f91ff2b2c9ff809a323fcfd0caadfa506d8eb30487c69e3a599432bd0c59926e322a49dd336d258a8bb6c33653ceb29a449e6038c5082af3dd2b7794ed02a1fbb564d2b92ba05e2d9c3e441c023f3d7c4112dde98e4f15484065adeadbae38e3ffb118b32037467d1303dea6a9c1d2b70c8c8b529a280210eb1b3e1c4fa868a3773152a9dbf6ff295744cff72741bc30aca4d676197863ccd40af5dd282c6434e67d4d29ca4afe7290fae8e474dd48ebf2343c74b6b75f5c21740baab36c32513a526f1bcf0747f74ca2e98f213924bd2a7f521ed29a45784b29b6c94c666f64b379a44fc37070707bcb4ad6d8073c105ecc4ab2281992ec66afc65bcb104bce1ea6d882a954aa89825246cce2c3762e6690b786a9fbbe30dc5a67b668a7f827c7c213b23d895522e862e5dd38a81d439aa592c47748454d6c3999d6750ad8564365af9e506e35a4699423f857dbdbd7abfb8baf1f888bd4b67b81355af28fadc052e9224c224980d630c8dcca10d59511fa761dfeced71a05595b8c58cdd2929af0d939cd8fd9b05b3a1efee7dc2b7cd7c1cc063ce1a18978522c5ce31881e2c8facf0bcae5324305ed0b71de1d8edae11ea8f07eacd13f3e707b92c4fe7ee4cbd53d1b63088d1a5bb87b3fba46632df8d3da7162acf9c2c78937337e2b4eb45ff0974c668ea91dbc907ea488bae4158525457cb367fea1e8f176ad51450ef4c0f836703cf657914f4dfb4ad8ea4a92b8c0f2a639c73263b80cc7add903df3de36112bbb3fa110615d8ec9e317370e901c0d22d05d7866a33ba44937a33383980d97cdcbdb3613d8f98d2e65119523b4fcb61df5e81cab9757fd926e2ca967144d54dcd1b2a98d9a1ae69f2d7d987d8ee4f80acb4eaa62a24286d4feabbc505b12ec3b0c2f165afdc3a773a84a9cd9db68d42606f0dd07afe790f6952c96e3c83d50d63d66f075e990b22d04903a1bb15a655fc50fcc6a998c95f27242fa379c533e4994ddaa4278057bff06e9071aaab89b7f161b589f21e6bd28d4eeeb28da3e6797d48f14984da893d2986e24be13f04387c2ad811a4a9a57ba16b43ef8969b214d396ef31152b9ca990901966b75a11b0384951341d8edc7f349b587c3365","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
