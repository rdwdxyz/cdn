<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"203c29b735b0b46f9d35c0996d4223f3ccfbc56e4b0a50e393c15860e1377dad95089e1c1660bf54cbfae2600568495541c80ffe6c557afe28a8d711b55b4ab0e141c8a6cd4a275ed9dd4b23f58575fbc8d310ba9fb743c6af9ac67ae27294257b81e224b5868f4b80b0a7b849f3f3f4aa1ec793787bc2bd2d60b23e9a42200ff08842a7757c6acc6f43b33e3a0b20e621eee88c5edf581be435c2d4972decabb72fe18c9949d2f43b63971de377a90dd274a23a0b427acb1590b7fcbaf6ffdc47e146b9c6a3977b058cab776f8d32497f1b491e092e378caeef5de286ef3e74073e5b2bf6b861847e52a0fa3314f1154f4a50b445b5ee47b7f80b264aa78619119a75daed90a64db830085444e3fa99ad6c15006419e97db8041a5717c687c1faa2340dbe16dee247df3a0d7d1a6ed136e329cb0a55de40ae9f5ec9caaa8e89bc750b9377ad9e429cd0038ea45ccf409672ef253237ceae2c8220d83a791347852747e26f3777833eddad7a1ab66d84f25f2288aeb027ea34b8896aaa4d1927ee912d869361ce66bf11f21296bfe9843d9e983902da90ac564ecd8fea1559191af4fe8ece83328689bd0f0d7e25ed6e1d41e26691e670062ce50f3f7259169230265d81c3ee1fea6febef9475693d02e2a7f8b2eec7db4f5540dadaa5799eddea946cfec65ee6097059480983df6f24037aaf37a88f614b221f7b94d6f399baf09df46226eef7c5de9f310b00c624524b82bf56ad31800639f0140c14190c4af2b4243657e6f913e40bf412440d41cbb2e6d1d80c19e967a1238db78e924089854473d26b0eb48360c83b9ae0aba594fa7af5e67f224c382d10a1c86ca8e2a39b66df5194ef5ae0667b3f708546b9d6d186932c875281187d9820c350686e4ab128bf38cbfdab00f5a7cd19ad29dfc55818a217708bee07aaefaf2d0b8298c1e0d387893a56bffa025af688a43c5725893bd0eee4eb264c5f507f24b88c4ced376235aa0c49caa1dfcee8475c84555128c7c966961bf257808615e146406589d1f683bb94044ecd8c887128d30541c3f395df6f7f2a810abe4a850e99f71e08d1544a61de3f1bb449cc5759d9ae1b3b514cef742a1ca530c3f82a568d91553692cc73f64ac87dde7e06eaeca817008096c39da0293ee5c1b54f4529a503f47e2e1005fac29321fc12da39891ab5c0bdb7f121f60b8479aa933895512ade61935058077a83bd27442d9b00269f00b619f030b579de0b7e61e42d6759f123d0575ec85d3cabd67e16a0a39e55dbe9ed69f1d370407df1c1a0cbc2bc1f5cd73e8fabb5678aa939212a592029e47b67f0f8d235ddcffb9af95ab6bcc702e4a6c679ff78145c186a9a1591a8375997cbea1f321b03ef5197b549e75fa8c58e4dc15f5e19b68547493c8febe7429d7fc2c8bcb3777f4db49bafa3f85a91b1713ad7823c2d4dfc743b5a112ddc390d4076de0a58d87f196257abe953bf0501c42de0cf2e5c1780cf3ee5c533d00d94e11e10bf500f1519fa2d820f12db09356061d56ef586391ebfe929d2b2aa637c4ce2700a245591115d36a43230d4b22d1e7dfc34d0e20d8ffa2cbd8331c995a307ca1737222775e4de33d53a4a9725b7477a403a6500cf9ab27e91b2378bedaf61b44c311e14154d6b9eb458fdf3efb226d8d40e42a3bb5789eca0c48ee4fde835c59b8af64a17f66b3298d8f2cc0088c97d9bc2f6d760b886af88b660a256e728c887d0d08799d6259152cc4f7517f01f2e65838bd6df5a720451166cc82a2d6b1710f77de3ee4d4e7bb66b5223c8ed79b520cca748fdfef546e334123016cecdeb88cb5d3d2c1f082c1028fc1340bc627114bd1f8c2681b426f95d854526d55239c71eed8328f8904583c6bca1c0ebbdc1c525696ef2277feb3ea1a1e3da0448c19ab81d5d35c44f57829194bfb2d8c6011dce09c00e85fc776c438b3ba01dd5335200c67b44506d853a4023f8bfd4e3c1caf9f6abcb582c66d334dc1f5610b9b8ddd6ccb423ab9a9ef1e8dd95eb2b50c3247959a13bc462cb94b5ff6b7976da4266b27a577bde856919d3647b4f3a0b16f450a11b50d5b589735fdcf929df9f6927bab48796db82528cab8a2efb152aa4dca5baa9056bdad7072fd78f6d7f2cc04ea2181d65b9246c8b6f7d26a4b2e2a60348a5095845f25e09d079651b46bd5a067de7835b516c178111ccdb13b35c71e97c6e87ea375caf242724b1b2185536c1de259f721c95e0201f0d78d926b6661125f0d6f2f4e66165527a84e06e8e241d606467f37100894f22277ffac32c0274db1691e203093e18f1157645651f3801c2b440c41956798ab3bed3e0c0a6c299392814a7b56552d39067d5dcdddb6ce97f63c8c11dbeba748e7d535118ec7f06e81a33130a35c4ee65f25beeb50541688c8834318c4e42e9aa7f8c634552502a2800b369c7f68c41cefb4e86c1438f0b8c93089cf8ade1354a1a54eab80fc509433fb834d64963082c8b483580bf39df5595d92cb3d0b5ebd487c017cc221b9b64a5d9ff9e45bea50d63c1cddc4457ec7c546ac1402c9c1340ece11192315a827ead28c53ae00a9877b71958480932921217d3a0c6a97e643bab6d66afdae647e28f9e416c6ac1b6380fba3cba7a1447a9f6e9291aab0e6171a042e92a3f5f26911d35412a9d2ee5cb96a42dc37b06308c6776df5016cb870ce8c67bef920054fc2e6a637254dc1992da389732f244b7f821a73eeeab5389cea1832f599a7ff44c4ac53be7337821c8a708f86f7a63672553ab1043324342db813a39196f0d01a9f2f05562881ab8583dc87d5215198cef82d99df482652cb254289b218f2fecc2dba355dff321673b321325c975ffa0d2ca344eb43cfd6931307ffd8767ec2c1d8abb04e1c9a1e50618dfeaa443cbb0b05b339d839f47e6a3b6af0263c28d8788ba8e255df382001dca889127b046638f5aae73e7c04692fc8a806b42a66088902f2b0ec6e7bfae82b19f24acdca675b4cd3fa905e034d1dccc4a33245d20dbd18322ae0c02d3f2815a46ee69173d3a2f23ec47e2dc46d5dca6393a678c6b8480614dd8b28a07570efe37a9b0de02940ae08e75ed0d51bf09cf9ac38a753f0818c543a34100dc9657443c376f4c5813941117f3098ba72c18be8ee9a639e5fa0d02016ce19e5415eb9c15fb1454950b30ff54b6f852af0e7d08d9fdb54527e3a50ecc07ad1b4ac243ed5bb979b72e5390cdcd5d6dbb41332efa60543676dafa47d476303c90c6550ff769267381d81d7e3707eae227f16d779ce7529ffed32e9e8c0598084f63d33a0bf84fa1676908edb67d8b8107d7026586c2d594f75f5782508e188b422294f198ea95dd4899600a4d7fc5cd84be51ee08c359f12c9ea94f1cfc0d90adf8f452bdd542f55c49216ba22169942e642f043a6726cf45bac5b6435f46d63625d0dc260f4e59eb0c7390ce078a1f8d5366b96796ffac7ab25fb5a915de49ee151bdf63b7657e64630a63c0c0c1b6c8cf49dd9a54eb2ad5ff8ee1d8418ee60606894211f25208e955a52e2989ff25ed26c1bab778f3da1d284c97a585aef19a662866e497f7d15e92084f2c9cfad5a6a9db5434e319e421e8ffee41d1174e60320218bf01d19e8b41ea5026f111d08598a07abcb753ea785fbe16c73e8e12743185af6b790c9d25f64ad0095390822d87525fb276ea7bfb4103f44985114ae03f4b1a31891f0547b6c963dcdd19d363c0843fab058ef8f181817b9cd09622d37bbe795001bc361c10829da0d9b712a2bb6fa04318c22a6e9cef6b143d1651818eafe4bfb3ab0eacde5ea89e7d7f47f87a7c80c69b9d55764c4cc1ae05b56ca0a5aed1bb2c6859dcaf05beddf9795c7c62b42aaa5305325c6bc0e200bdaa4aa94939e6aab95e3ea3dcaacb0d0e571512300c652bc9e546711d3635c3d79f9d039c8680d88b9f6d8bb3b3b6be55b0988cf4ecc36c809fb825e1e3a1b3610a2e8dff2e11646721ffb438ab9a086c4a12e41ab698ca5da61b256537e1f8f74bf8777ff2e59ee3868d039b325e31e927e06a936a6daad81222bf6c751ae6fa60231e7016c7be81965192e0ce763b8285d06485b815df08903f845b64d68acc5a29fa9fb549dfca386404f047be694c654ad8670c4f4620ad34db4f342f2b616643a61944e81624d093104f1924c332923b771d72c5917ce4d272df1e57721d1119a70ff5d795d89f168495ac802fad8075745feddbec552ccbe35ad16458e86ded21ce105e8a86ff2b40a1b887fb43cbb7e301fa818dba193941d2066164f8b3586940f700a410bc0e7bf5f24bae1dafc828b44f685f1d4273ccd8aed91ff7368438e551ab0de12b3315de5966a5afcdb1601cb78946b33e9e3d3e9ae6c792e540a71d63d401c2c2d941e3893654702f0d9206f631faff6e2cc0f2453e46624ddadd9b0554330a3242ff3a3ca7807e1bfe297407b8879f33911f4b85bc0e1a200fdd4224b17525d8ba7009c1aa2a23e2aeb6b68cc2e9931b979f89a7430a0a515704115e7aa95f3df7cd7b102d216188e4d01ac2c24f173d40077ea9d4fa3e5e40a59c28bee389ff40e97d17c6bb4c3c0132ff55d7d6e6e9a3aa7579af10b02891f13e79a284a1d9610cef04188ff0bf1654465b8cc264b51567223c72c2f24b476dd8ae4f0e9f1a0f93c9dd7d342bb291736f2d5d3f6f6309ade119b8c9a484986e045c9ce326cc3d5d19ccb53a66e00db77ae482170a1d5bab4a859ad782e0a3a3feccb0083d51adf83ca4ca6a9507d5ce3279d2edc857433c6df302fe4cdbe0d3035e98f3db7423dd6d7771f59caf709c5d677108ca7128eac2e15c01c8d001200889a62fd4bbdf857dff5d38d4483012189690c6dc63222331716ac762934b527085635a385a89f1832d31e3820a83b9221e54abd8821d0b197ed5ae590c87f63e2d0c486a640add19faca44fb23c3917f9087d41c770a25699850c5cf2351aeff4f0c66addb6aa19865aead894d660bd22f0586aa0edabe0175a35a73243beb5f03fd24d1da1fac32aa2068cb770e03d0dd6185cd1323f301d94264ad54d8210bba7aabdd46e4d288556aabedf519ec2705ea067e1a97b3a505881fe9f301ebcada81305b485035efb2305a8e81e3083b66d097f813867c127a736d08cb0643818c9142cf78e7b0c5a4dea26ef0296f934da4ff567d91345df14de2299da98fe5208ff2335546b042a0bc9fa8482ba6840eab5262883a837a4426be3e841e92abcfbb25c11704a75ecca874413d3ceccad0c8813fa40a3fd595b7ec8ece9dd73065ee2cf9516d34da7c0cf6f5a2e0413b106f5c91e9ee5d9a5568b41989621e99b9ae8cea09d9104e0a5849332850a5511186c21ffe12131b98529ba328f9654c263ab10a44e30bc002919bb2221cc3c458f4b3341dbb0303af955508736e7a95b26cdc8200a339ca79586b08437d7325c1df2b0b68752ec0db5f87b55d1770e6935dc35f917e3bf64c89bf0100454b67f18d0c9dbfb72e39758be8701264a4c8f9d1c199554f5bb29d79451dcb420858d936af559e9c762e4f47546ce01fc51d3aa572832dadaaffdd883b555ac7ffaf98b6bff3ca465ddbc447e8e471c1bb6021745cccb3d810b8de6f8924ff5eff953395d09de5db215a2e5f332e328f4b00a04cf11ae22735ad230c08cb53b4614d7ac8737c8b5a0cdb579e8efae685f807121930f1eec6b2063238e4e9bf36f79565ec115e22a538a5e604d94f0b5c04a74c9436a694ee33da19970d7c765019eddeefca1bd461f9f7f98ac45d199f32111512e92f616081e9b9c5c2e5101d64a817277b7a674d0a130495edf717f8a1e419a36f2aba62f6f030813c6f01a99923fc5a0e4b93db0f005aa15a659ac87a7fb3a43585940593176eb0b9108c894218b7423f7b85550acb81205b64d0c9ecc09d43b67cdd75b3e4eed83a732026fca472d43308a0a2762e24af7202bfb1decf09b54aa4c9045e3341e1e3d3205a2aee96c7540630beb607f7a6dff550a0daea2520585ce72385e247b985febd41a4bb21f4e3606448417b939b07fa502d1f9c275a0740e90b9c7f65c5ba93d2a046b1d978f5a74621b6e4c7d3929f30b5ab6648417a81018c495b4cd36543ce3fcb148068c875e78c799a31cc213f7f053f157624d4c8af0f54b29b152a06f5f9f3c26e58cbcfbdb323ba17dd20e753aa33692fa10015e3c01d1a827d9b6c999eab2fb307824ab092b04fb8e0bd72b5e1fe70c05c58701ff0c82115dd03d973fe896d4c9d73d69b6c4820c450bfe1f5dcc08d0c001660f130cd0d96eb1d19f3914736598cb574a10037c972f4a4aae40ec6fe891ea97bc3daf2ca0b903904405490b46ad84e458d2fc86ed91c9eba2ccf93c16b8c31ae58a0294aac7920137906021b36cdcfcf8f1bcc4542f873992b264b3cfba97543e0ee460cbe15df1d62bb9d57b8c48ac0fb10c8bce7b541d8b32e58143fffca09306f7cfb2280dcb39b97797bfd829025d8c83003f0a6bb8b2c593b56915438b171f2b8271042349b05424b3e262c6fa976c6a6a2a4f09f1b63fd0a9ac583c76e5eed85a321a7af3143c2c173258b9aeb606bda90f64cdce6f024de9a4b36f6a77b458038d504976768a0f8d2ebb45d8a1ca8fd25e3617942dfa1b5e9fa4db3212c0dc4814552996ef1f69f506aeb03643cfe4ae11ef452ccff519ca3f809574c7ff525e5f97e9f93ecf0b5552fce20239ac481a9022a094bdc8c0b0d86244200ce4f0c97d4e17f8624703cf61ee797be0b69420956db83610f0a79557b102af40097dbe2ff4a0160bb326a42dcf8e69c84301fef939bfab10bd4f0e43502fef58ee04512d0f95e465550d6123e533f6f119482ea5d89fc6db2769ab42bbe140443c3420c079f640e303b8b26756d571fc8740a4f0764618b6e1e9de9cedc5c5fc2848ef07f2ede6d7c1d00ec7a010e0ff830e6fc2ca8cfc726c72acddb47b51a714c289e68085a5d825ae07f2a1494029005aa378015835614f62be1be51be8692f92b106c04779b96ee285d937286abb29570a5401c76fa6028450cfaf0555bd57d0ed878c350eed0eb7103a4b21a240c5d9fbc64be047fc93b4dd20007266cb5262a0be1d74677bc1ebf269ef279ebb8cf4484cc28601f3cc9ddfabd8f989b8a40e61dd5b4dbd607021ee11555946f2baadc5aeac49f642142d512ac87e349b4afa90685ba2723a2a4ffa4db2300567a464ee11c5993c6ace6a0051a007fb1dd5e9eba84572bd8c6a7795a28306b1e5b9c147fe1c0afcb9a76c35bde4aef7614ed8fc66474125483e4a89b589de9576773b5d933846847308b1a31b186c6aa8e48ac721c8340e559a61503f5fae6902b4d4f4968b9ca69773b37f43c1bc8bf1d6b01f0e609696a31369cd4f2f07fac3856d4d97f38ed5ee1a03775954111991b29691ff87c7a821bc1ffaa8d3ddb9e434edb6cbaeb5b302b6eda721f5d705d5546f849298f5f5a40c3338c42aaf60b340447548495e14531625d1d71bff00f703ebba13bf0a5e87648b215d976e30e2f1a97d48677fe5f2065cfd7da56d138d54ac3ffc2a77c1d19244b96ce781733074031b20ac30716be36c180b82595202dd3dca26e66b01587dd9d90faa46fba8055c5deb452f6071e9804b5e8f09190b6ce9441318b4423725a39a0cc47782c06602d113686fefdd250a4d122eeaa9115a8455f9f9ed7375a20b7e814f935361138e5e93015e22d21710c191f413559451a9d9abc7e5ebaf3d88c926fea7069aa755ec55ddaea5a950ac60c487395c0652456eea47705988a7b9b21650dcae85bcd9583b72c9ec0bac2ea9b15b7c00832648fcdec0de6d7ad7432b95066c9924b6433059d59696561ef7280fe69fdf4f1a561826471a614657f34187e877079e3487bf82a03fd114ea2f12fedb352068f4944a2aad63870e8ee2c4babc7823ebac89b59fc3df676bfc1f024c8b497bab71672c7dc2906aabc615364d7ea3852742992014fdce3c99ab5a318f485dbc53a607c606d9be33960a9a9f732bd1cee4c300c4cf35c65075f5aff2be07002f75ebc61c599ae888655bb9024ba2f5df955034f2f9f86458191679ddb213368d13a7d8f7f608e6af55d515fbc31af5c4a231c101b331a53da049c3c2e617860e819ffe07f3b14c588127edee546dad0ea906e9d54b5719d9143fef2ea96a87f77193e8e21ea3f4a25e1d61e0ea65f6503498d2db5a965915d48ec04609403d827f0c0f76e33fc7971db5ceb131b4c624cb538b686caa5eced7e5e2f62ca321e75c52cf8f75999243448d96252e8b60e9844b21df5ffb62ca0c86d7d19e18a2a9c70e019344d23ab16250a86e0f7fab89b89350a96614d58bebd874027b5a2494ef33502110837148f9bd8814bc662b7b244b4e2b21fd05b02a5998e0cb155c522bb70285582575ced8d41b929e69784bbbbea0a3b9fa0593e9750e6a21839089ff5f26ce780c62c2d1fba4fca1ef51db08ead4fa4774ddf83d645fcb64beff94b76314ae8e6f9c1cd9ad783e351f91b6800ded18f708e729f1808835ab739b54447b6241526061993ba4dfcea4722547b60d95ffccf204aa3d46fd68a4d6a8440cb40d077010d765ab9df1aeb9d83253c137f123c200554c6ceeb3d17f0a504c9ab75d625470dad5e7e66e309e88313619d449c256cbc65bbce35515c5501ac0a2ffe3011211b18ad05576ad7eee17b9b7849293dbf4d27c22ab76a4b51091a274d61f7a0b231a7860268997e2d7d58d759b0a13d7c730ebd65aac989d6edafb4c7fb747d0f8ddda9e9afae4830b56cf200fab91a2367b65d1a8a915d3adde444bdb9ff9f1e5dae454b72c64a914d2a5f61ac49ce78d6baa608a2bd8b9bf731f1327e93b2436d5caedf564197686aa9b9ff4c47c08b9f06f92bc503e8fa2edf5321150a5d2845c2f86650ca49a36fdf569267b5ecffe7deaae8eb9f7692147f6b5a2074ba94bcdf313129c0e22ea960b3bb85a6e4cbe7325940a845de271a67ff9462ad9cbb8085dd1a269301c2cd8a73ff637b21d90d326e51318bdec88a1003d3a162bde35c5e29e4a9a4e0d472eae6350f99ce4be50d189546e1ea5847b62467468b7c19021c1086bfffc1c5745a5a2ad4ae2884d3e09006f72cf5f49e7e50ee0e0158f9fd163c9a4172261fc6109b9cb746123b68c389c0ce74515e073fede783b78fe7ebe0638722c6266bb351f3b50564fe103fc3c21a4af2d385df51c83b6d9bf7f9c4e0a96b8bc6c29b3e763c9c3203d1e5f48645d699996040f765333469f8f61ec6922a5ad6afd49b7ee25715afb301c35cb0c84002c257c971bcf5078c9ea3d1cf36e138bbdbb07a59ecbc92f002feea5b2ad6fbca37b8688689cde439eaaee94df1eea245e3f990faf220f1a77560e3ce0ae0e97b113e4409e117883054764faa8d1ae5444c5a8a5558317eecd3dcd1abd2e74f85b2052c69d4df9d6d5898c6b602fdb3e5d8b3cabb3e3bdb85f192a1c49b9c4e8a85bfedcae3e7ab3e94405420ad1787f63055e03658a64d6ac1fce9ec94033f0e4fc1a854e6bf2b2a8fb210d1b7c9ec3fffd7ade0c02c2b5fbc826c7f758241f99e2a57750814a7126169ec7d0c63ac0e2dd3452d1fa9faa927e6f2b8a6e02bdbcb03853075daf4dbaf87244ae6af8e8bae9f910e6bc05f98eff0bb9869887d25157732810a97dbd922828c3271421dde68c4d51930bbee10bf4f23a905e1d9a195ae2056b902516c9dad45196bce2ab1aa4a4a258a1fc91afeda928a68c7ac930d0d828e02eee4aa1e0817b248079195197a2fba76e6edad708c3d93d53717d46bc5b26683532a39e82d5c2cf28d7ba9cde4b07cb97dc030123bec110bf4c1b622798f6a2a9ec9d24de5394f9525410dd99d0edcdba6f40bc5fb165fd7bc737cc2dfe32c448760e971428bbb3984f5403de0d560b424641c33c47c5faf5b5b5327aa4093144bddcd70c37a634143ed3958bc6740335eada84228df2ab9ea5d5f106eaecea0774ced3051867e1192ec88b796e3f0d51974f6f2d4dbfa03bb40061f4725432b7cea5a4858d9b46c54ed07c66ae089702d5492eb7eb8736534c27e847001e85afd936f2f0e3c7f69232377d78cff2d35fa5212654e8ecfde9ad3aa2014f98cf71761e133e6d969081a46e337314a5aef327e7d6edd8f32de8665dbb279ad4e0db157568d1a381756436fd84cd5d3499ab14181108589884baa79b7b02ba6e0537a745cfc04b67009195d9b2be468facb630e83e76117cc924c0b6b9cfe1cec5333af3687364c00722bbc97936390cd594667fdb722a90bbc64f41452359b444843918190aa0a439ace958a39d58884930b87b87906ed2e6c5e853dfb083a1d7fe961a636e1f22587d57737d463c069c1a3aed7888c97735e936ba2098cc33e13018750e2ab736a2027a9a39f207bf72651bec7914e651b34369a9235fc9fd82a93e12e5dda7e2dda1318a454b12875a6d27ec7610dcfe92bde51239c6259842eb688eae2076e1f88cf01c3c5f196d4d8563dc99fbb3618b56849d5368eba0359a9d25308f6725d14d5ad27df7377d3558dd9ba81356f5f813f7835814c7de7f044db193dd7664e3f3d29b9216b84b583317a262acd64a1e7d661a67604739fdee53b6e93233be30703ee3959e136e5c8f83f4fc1bd6df3b1bae0784525d554c9d349d8232715104a87e24624d380cd44ac3680c2b18fcea4537ae7731590f34b4af59fe7fc49ccdde4ba10d50604641f7a24339c39390e1710247de0cbabc0a141919837dd94b4ae3fb9027fc29beea20cb64bc3bea83bc147a9df9b26d63c525c07b64c03e3277e2ce4fdc0e9e736390d2305cc477927bd267f37d5ff125806c186efdcc88d273b60f80d49026e4c29cad4acf256cad5e46c4d9e470a22f6d135d3cea97f1448bf144a043596f4a8d2ba6f56619907d72a5ba405242faa00549ed8dfbf1dc629aa79376e4ac197af6ed3d32b065dbf0c6ca7d7883b242f61f50ba1cf9ae68e3a58affe7a5aba9b66e47c0d3d6d4cb38c6bce0016837caba8bdb0cf6e3dc6c24d56490a40fc66250f4015c2268c828afa54644590ee9130c9be798fd4f811a41a97f82146602d6057abecee9b8a7a0d64a2e5df9ce6d0b597a785dd1484450d2f1c856810ef9bae4e095751349bc91424852cab1243312d9739e464903a694aaf09be4f67f6a59a5184b4134aec2d8fe993cc3f8396eeba4c74e88e72d617a4a9e6d8ab56303c01e84671ffc21e40b6649fdcef475963aaed8fc65d0b53ad7800a38c499453639436d1bdcb06062194304babbaafb212dd0012383d6363fc3c99be7d57de2ee35ee5cc91ba7241303fc5143f40c632f90cbaac400f0e9afd3dcaadfd6885e97524b6388ec7c274869c6e99fb5387d1f634a1d965cf291d4f555ee7ac78f0ca529d8a9894d648af4284d2b278b2da726bb02c66d06fa4f0e9af0b6ff4a8b6eb0311c38279231314e6954f4ed24a68f4dbf69501834c3619d627f3dda2ff8cc80d2c14f0003ab69ff799edfe48fc4d77dbbaaddf219216ab439b13e83d9e70258a1f5356722265de61bba1f8ee6f56af6c460ffb0648a883345676e20db8c7e0c82fd1a7618d6102505a7362111710e457b7e2e39641c318eca3367296222a7989056f401dcbd30c6b16626b12081f5d1c7185e82f602ab0a5841857fe97febdb5711995ce1644df2468d9fa292e04e620a3eaa3b752eec1b95242aa8e2e064e2bd7c174755fde7211c477e415dbfc8e7af1dc0b6152ef917576a035993e72c24cffd9bd860bfafce30e98821016dec86f42ca43fa2da21d323316cec359d03f3dfa28ea3bba81c6f568271008e82de7ce2b3770e88ab8a623b275a6ab95160863799f6c2abdd1ba56ab6550916aa1e0704feb95a7e73f5d0f42eb6924539b6445b1eca8bc36ff97ea9ea2fbe9c0edcd58f0311ac80d11d164aaf62e0bfa9de80c127d9904fd58c38743ada89a452f2d44f9ad1daf842b68a6cab25082b8aaf53d7ced9f77e59a55c75a7f1f9349d0bb6ee2d98b9e803abb8dbbfbf3a4d11ede487e63ffa82ed1b692b7dbff7d499b63554d1ed1ab75ada9d5736dd5521bb9c38c178d52d2202f633aa78d4bbc51f51fe09d5dec04a39d67c91aa0e3422a4c4bfb4356249522ebb18242f33858c72b825f11d7ae5a071cf4f054a9b2e88c0be6d55d2534bec5b596e4920b0a912a639ee739d8c770b9a2597862811abd73e7f2392f49cb8e1953339b6b878efc54f042cc96d228584929bddd2220cdf8d6f7f3ccc898e832f5ece4c17ca8613d9a0b594a3e78e903fe17001383b2587f4c056ca090fd3cf8db51850673148ef4f15240054780512b59c95082c5232b4628440537d1b5a4f459bdd7c76ef184967ed620696201bd146f03e6c742bc7405b0393f3997d0500daefc26cf83ae7438818da58be331b5421be1f38c44b10c74935f8ff23bd16d7942e607447bb9f0e6d17264a221ca9103dce72fb9ee2463e2ca41d68beb75229842346d57c286deda8d1d48a56b5ad77281502bc2898ae953aa101d1e8116d58fb485dd11b2598f20c7a935245459e036fa0fd349c14197023873c457e337f04a2858afe28f23dbe8aa81d30f25934fd264d8fbaebfcca47ab434ed98df58a796c71dcfa6ce2e5dc9de9d6327ad53ad0f3b811d2bfe30331d68805c2e8ebe245ac445c025b6f1e869f7fad16440a874396aed91135d3797ccf4d666fa660447ee6059d728dcaa669443d18c5fc1f5629de63a4c9cbfba421c6dbb5d043d1a55d6df5135c29b4ee2d276d792d4dad73395181aa0f07f5fab6e47f615fa36e0757096d1bb97423ea4b6900c058c947dbfac5373143a942f508ce5ba22473725ffce458fc535dcecf6c9eda087863242e7f344765f6667f8acefb457fe358cf852d47271210bcb8b7f92cc9a620d445faa8cac0c85fdaddf4f85662184ceadfb3a4a6365cda5964f0c4d047ff6f4c49bc2b6ffd7c139e75dde5cd828329a6b583acad8cf65274954d5ce36f77966efb5c687a16b4d31c070827ece594b2be4a3296919ae3e82006c4d149b4c26b88620fe23aa59839f5ea7f81285a515f5e015b816122d46fc4050e8ec3348afa1567f4ad9ad2bfd2e1502f49d1d806ebd8b5fa1f8a5f2b6ae221c3e9ba46bc8c890132828f4ebcfefc4f040daba8b7eb58e301d1dae4989805188402554355302394af7b8fd40bfed4e1c3f7990a0a28fc9af88c94dd5652bd417d30c084e261e7286a883de4268f5103f2b9aca2b59b8e27d763684e69447c7e8f5d1b3b26eca46091a9b13093dffe310b861f96100f139235012840a98fca8bdf6a07ec2b0e816429bb13afb0f1d60fbc0671963c456ac79c5812e556843b3c431567075930d1dc767c8362221ba3eb740ad708bc6ae4ade17fc1fd6cd2b133f7b9eaf606c3618817ad632b04424a88485a9f595b083d9db918eef320ba5c729b866d16695ef2b8edbfea93cc0a20f51288a378572e8318241c673d33a663aaffa8bd2f1b888765b65eb26dd386ab35640836c925f511fb684c21f4d007fd7513ffc12df6ca8e2476be795d4bfba765b6dc49a0ea0a4edb50a9e41046f69066bbf6951bfc84a1dc7fd159041df38317adf1dbac23afcd43b784fe2adba22783df37001d6304c0f104f9675b9417d0867163e9c0797211fd7fd3cfe63c45c235ecf707530405638330869afb568c3fa79af5ea5d492345139bd2d0b1c5d86ea88a0aaf6a1c15685e1a6820648037ccfebc1cd59d6141e40bafd89c4aa369f0e598ff4cfcd367bbe6cb4931e216d59b0a91546c8886c39dcf417901568b4e7cea27bbe9e81425c2d5f93574088f68b1d55308a3cbadb153acb53b6a0bba6cb5986e67c26fd728ebae8eb7c0dd02b609937d9e6f64c076632382d6c092e5584a3d0ef5a12685f9d816ea2715350e527b7fbc8f97b871b319bef7d8eca566b4d1bd618768bb4fbdf88c36071ce6c4639792f9c0c3de231669e93208558f06e05f3ccec033672325714ca4077b95054f7d8521f027cb60bc2f3fc70d51ba07cb7eead47db3a8e03399274e98bf7db48975539ae711f9a5cb60c45fc029b3c4f2c732b47633aa32e0d99d21f5c39f651b11ef3e8c6601684d5842f9cbc17b0f2b4f579815bbcd65a4ec3d13e1c55f418a041b05191495fa404ca1398e2e33b68f2cafb0bf541dde113ae2b5616038d0f4717ea6245e8c10faf25d6c019228063f64bd71e0e471c8499785d0e467d559cfffe81a350c0c6b81d8458c02103d6e1f0de307d2359b6184872dea866847f412f5827b8715ab54196ceaffb1e53c24ddefe05501768d3998188628df83b5537ac6045e55c803411cc436772cc22a633185a6a3b86dd67b880381cc975b22a68e7f99ab279d0df6c42a3f8b857405b152804e0a16dc73f928e7689500419e8310ee0f8111912f7850c4b1430a959e5c95ac6e877e8e73455f1cab485efd23a48f7232b00cb4ea68dbd9ed1cfc67e4e893a6138db5dd9bacc7790afb6451eebe666e530a8941833af776010b3faf2d5a3580ba35c461cd87d3884149c3a218ecada1fadbd4b86f518e9f2a0e907fe74802b297b9e7582148328500657c5ee213256e143af37d2bc293331b4fb93acf3645219bf831762d6fd50ef7179ff823b4ad584cb975c3375472790ef9e08dde6f0ea046930b8258bdfccf94289390e3c227b72e53397288f465baf6f2c00e70ae4a5c6211fc5fd148edee753af2967dafd511d65ecd1d1643da08ad772f20238f9d02044b62615b987530eadbf1c1bf202bed01186f249f6972e1d8d9503e7a7c48c7a59d7ab520216fd699df4b0c94b09044948adf34b472ea42aeb58b079bafd7a675b3aeb466f751d5b165b20d8811641a178917a161e112631030cff08f436c4a1b27b3f65126ae64765d2b949039e5accfebad62294cd1e6181a64a52f27cc902d3bf5b55be743341438728334afcacc45489eb98cd6b04e86d2159cb8d9d6e78dc63c3c2f87397a1bc3e81e7acebb11af73f39dc2079163874161d87304a55558860876861e9e7e3e390b203c8cb08302a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
