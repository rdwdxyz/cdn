<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"94f582109fc412bf2e33cd667ed970585c822f19b5b238548f30f0002d53a6c62b78c65c1e3f51979fab17428d7ede3b172e0ed9c49252b7b494228ee0382fd78dda67068c3416df3e099802b91d9656b6e21438eac08b04518a5de77532d9d07d01e20de5f08bd08e243928f7b39c1e31ef090eed73724e54c8d46aee2c0d50e2f95d50ce1bd8055d440af7b45bb59fe4dd8a356e2b4e289c74fc606329c28f6989a336da32115e65cdd3b0f31d795d5aba057e9e5b7de92d1f8d07697591a08f853c3b3dff9e8b75855769c517b5e80b5a39f07665c4f8e5053e8278cf2e3b932d8b9605c8cc389951bfba2112cb86d7322902249772c28b080a46e902ec6766ca56bdecf49cf7f27e82a628574d3f44f21aba04143c7976984327963d46e7dd578f6319c34e50729ca53c17d24b1d34d108f21e63cbfb0afb3f15ee362bded1aecc8686a101c92f3de26f966b1369d922cbace7fa5741896537258ecf8f3006877ce20be70e79eba96c1551a967a99b13319183582ac49f3b7b28ebd42e35855c14dd5f5f3aa52b6d4835c2d8ea5130b1b49dfbcfcfd27f1660611082836e16279dc25b0a5516b3bf80fbc2f45c3e90c076f5112490fcc18526d5474ea423229ffd2430b1e85da87188fffe7c92000582e3a7164f235ba9b73cdabc71bdb942ed857df6e9f5621fb8698774c56e8fab2225404d650942a8166949f16a0f036bed6bce86f6bac28c63d739032be1d58511fed71c2b50bf575ccf6798e626819dabb20587450204ac00e836378a7c121b19cf470e22a543253f1313605afd20e345c2ed65034045bedf61b7d7994109d42f9f6126bcebeb768bd7b1af0100cdee7a518b5111989e795445406b657cb16aa6550696aa6d31435c4e8a86fbc57c1c25f89795a58273f0bff943396618b723bd8236bec978b25bf79b0c10b25ad37d62945b8501825510b78074e65e511dad02e8fefae7c3d7c98e985069a38eca77028563b5e7647df41069f2fe8b991b8a14c5877f4ea11a3492e5235932b68c037598a1f2d0f61e0332cd5258a9406276f58ab5b1d1eece98462828e1aa58884aafbea2d4c935fa3b040ee30942af90fa03a53aeeb4939ac32161950e2e41d4ee73bf9a9d5bf2bde54795207983cf1212d1db498ffc63c32b89345a67f1893cbd6cfd17e4747bc1532ba90d40e0655f3933e682da3b8e6e91a78664344a7e4acb2f477e2a34246530c641dfafdc296492035525950d346442220dc63becd44c37ba37c78b57eb7acabec2e920cca0d51b09c7bb9d37a75726d8e5276384f29b47f74bba8900144e9536b1c5df18a70c6a56f66c508ae4b655af6ac98cafec4a4e4828aa14553b95fae152916ddf7b78e425c5f0e749c95b24c597e0d6f803e428100f015605281c54c68d0295acf132e5b541525b51085aecb6ee74bd55e72932b45497e085ccf096c8606ff604f4e1f837de24b916515c63a0f21f9ef2f2c8e4088bdadde98429433bf0ca1bcec2c62e420e0fa4a829d5e11c300eb5746ab56cbebb7b0737d154349ab9db57e6b24dc9d03fa2792048e6531c02fbd4ad427bc4091e3d967d2bc1944b46dce3b2241fd897988a54afa64695d74f2c38462ecc1cf15ea7fab24cca2c866e0db21536a08d6e3c988898cf3306f22b0ca9132de9875806cc82fc96183773e096ecdb020d16bce0a1240b9ff8d0cc8107d06e1c4bbec741c6f13afa6686cea32d87131a48a5628edac7bff74b4010ece9d1bbc316029a34de71e747a041150d3a8bd294a63b595e2889975d111da10ab2f1b87dacaf950b07fd2f358ebe9df2193dfadddfafee5d040b57892781c000ed36c6d974ddffc6f2e355d0de8219ddd2adb502538109899ba810496837cba50ae3bea8b0f82321f8e1c865719ee985cb744b1e416bc23acfb18e1694c3c469d12dc44c6cccf2ffbc23d0d3b30e6b1abe2725a712651f59cf4ad339cc60a0c4afa6b3c3d41e817d811d73537c9c88ceff2c2723ae91f580e885838093865387b8e12760f84eee8dbbb0a214490b34a0b3e77913618113ffe628ea0e1d3a2d8179c7e5add108fc4dff05015d30d08e688592d5542ef76ab6b62932ba82888474c877aa07a985c35623270e14b164ba09cb657d66acb837aeb2b3ff32d1c2a6f6d30d4e898cb72da04085f176c6d887e4d81bd856c2cc28b526e69cb5063d88bed5498ac5fe4938386fbfcf154eb9ce8bdb49b59cebd52f1cdf03b6c2785c96c24f3843cc7f2385884505386effd8ca88b3a7a42a05b84838197a0fd8aa05bcc4a510224726c37fbe82f9ed3712a474feb42a75406f1e1933d4eb7294f29ba69a20798bdfbccb4daafdc465af1c814804b3cfd0a71be61c2af232ba1a763662ad40af78cc05ccdf4f6c43f7059a3919a327f6e8678a8c71da00173d177c9b42956f673f1a2c989b0a6b2fe0e45070c67c022997a33c753252a18e872e533d39860cacd97bb7accfe5f9327412e991bc6851e6d3681c43eef9d7a6ae52b730a56584ffcbba438ce11173d034f111e15f17083c3097461f47135f922d36f62f78f0f52b6a5ef02e676f8df3e2f7f7f188abe53b8e3af41bbddf6e349c3de30e04e355ff81d237fad3fb72cb05cd6ec3df4a76fc4db8cb584317a70931766e1e7cbf85b6157dc63d07ee2a65a179ad546256861cef57562a97ba31d5d3550c15ace3a447fcdebccc523d5e00c8aee11ca5bb9e0dd58f77c3930fbb47be29577c0c982166ed05747bf81df9fe4be407db4f628a84b7849068e52483206a6b94027abe1c678c8092566c73e9280a9fa1f26c86d56f304e92633c6b3145dddc181035c2b49479eb8e57a82a5c43665f3e14bc6bde4bf8ecbcad185b359f866e8a253b74d50552edd833c9162faa71d387d7c0e9917df46575fa515f73d2276ee87f974d69c3cbf8ceaa7b9bbf8dc1c823fd4377bee5568321dcd15c24af7677e2ca4015c968bac5616ae4e0bf834c3646034cd76483f9a34aa523e23024a897539b33789a8880448477ae37980902e769891ac8b72efd6d408c7879662eb127b3d63eb6be08055c433dca92c12aa03e9926d25da127e159437531848a2af0614eb60cfe9b59c2a38e8bd99db6de20dd1b47496c010db7669e39f944223a058c3b7df508e3e3b754d7ef5fe1de2252521ba911cdd23538910f8ec923893037759788408ce7c57822b79e5048789f93126b9a05abb075331cef99d7f8b9802cfc56315b29928c739a3a6ccb32426079f7b3852774325680caa3251625a0918a6b44172d6108521f46e5d79210115767b63f03b6a019976cdae54f1890fb2c510dba86c556e620b2f79df2364d71030b036f98dfa21e2ff11f7f2bbe6a25cd019a4feae6b92ec537ca38cf5f849dbd159c36efac54146f5e182352d7f96856d93cce20c999ba76ee853befc1335dfb66a2f1ecc6bac5bdd2ac3dac1c95b2eec4fb2e9b7258dc98638e7afe80c937f43bb695c0e7cdb172b81420500930b3d614d09229f4e91f51bb540e306e199d3c12a6f143e19775f8ceb13c2681d1f32bc10d75e26ddc353c891b1540abc868f5b8d880f12a1fbe1935f2cffe6ee8bdee64e42889a3c2d03951da96ec07006fd8d5eae6e397a46f189dbad1130b9705b9826bd3d4fa573ff0179d2c162f41b02311c60094b0c046b126b57819abec11e6efc789d3d6fc06c8f247c723a883c0fb96e082444ba087befc2b8b89ef89ba7eff87e66b627af81955862b2c3745d3f5ea0e19830766eacbf53ae4e4ccd813e392cd953cbef72cb582b46778040454b4f06e079e039f1bf290647c1aa612fe9ee34546176b1b09112a2e9e9cbca3944d8e8b2b9bd79f9a32a653a096cefd19ebcc7dc4874f265b62b173c447fbe33741517a45a6f26c895243f118dc01b93ddd7b6665c3d6c054d17ea4dade92719b4aee5cdcb51db427b1ea9bac084625640132e8c0f6ae1eb3f7f5e880a58765bf2711cf86dea7fafb0fa2b41165736c76e0c430cfc202574b0e185e3baca1d813d4e325259989700d7008e0b091ec5815dfc5684fa652430ac4d01f9c9de3de0d1b9d3b408830855cc64024d6a90a51b16e384710ea7e2d533e76ff58530a0090a0921421aa8bf5f9ce35243786497b95c54466d2180de24f954b937bdf3c0df0bbb3471ddbcef30514192f9b85a16a617909c2e70bc9dfd134660b56a4e6c89ff83d1aa6c9586dfb07c2ca7f239a45e315ba0f5b4216c86d0017d1f13b130e7ed41df5fc99ff97659d9863e9e1d9a4a5026481a24535a8d4764a44b2ca17387f6f692f11bea5a65b20696a9c7141c86398395454a4b42fce95c4b8218491667e4f57484e4b54879243798f6928e397170089d11aa2c532dcd33fa029023f1b233f1f7df49df1494182965d0ba8fbb4bdb801c2c58bec0cbe8004fa7766fd3e7a025aff6cedea2433072e2984db087bf07d87954f5b3f54e7b93827421bdf8d6b67caa7bb24204a35cee0ddf3084fb46bde796b1a6f49b82a135eeba7c5bdac50c6648f3c8ae46bcd5f713b46f384493bab98add2bc45183d1c14924b21734901d231b583172a3861078bbd7886d7a0e152e64d9b06a8f019efc56fd581d8397ebfdd34d6ab3ac061da9ec3f253502024c481a5958377e351a570c69924f13a86ab3fbe1567369b2107a9e1c8c5da579b99b273bc18f4620640ea466f21c95ae9fb623fbbb5cc7993a08002e7d5ae56778a4bc96c032cc89a344a9cd69ebcb2a1a7d2bc8be4c4a4096b396f25d06ab31714cf3c1cf9b49798c2b7cf77d7bf63fbbc28a20758ff706d89f37f49610f55bac45568cd6c50231350344e81a791ac81f0f603747b75f346c65af690fc2106ba125d7dd8f47768699537568f09ae48802b1290a0abbd4c3c607b54cd054620a1c8abf94b711203ac09af713626c6cb82554cd1471e00a09df2a119dd5ba3b94e6767daaad25d5b71cae09d5956b648f8287c3db98eaf34730ad91a4c1a55ac54a0d94c681e66ae3e2da987f572a9751aae0d328f4879df4459c87993fc672f039052d9a33d699c9a98ce3e1b5d8dede15e0450858135073590f16bcdc97601c148da0a1fc81b70bc2fffa2e10f1699da86176d25d2e19ec2da3f820fdfd4d26852196ffe63a1bf1d387dd53223349f180ee5c44dbc349371335d1b3a80bffe37405946bb4568123122b1580dacf038c5b3f7e640deaa8e03ee50a72069d584344a476bd7aaecbf57cc4eba37bc8d0a3531e3929119dfa36ddc4913bb9815c996daf1b0416f50f0721f1f1b9df26dabad200d3be7722f3b67758f7b4d6eb95e60b810ff9061b4b061f78056ad266e148e51d78e659009350e28ca67a7252af4d0d2cd97e56216f2fdb02e116ba56cf1883d9dffa2853b0d672265c5633e4996c5ee29c18efd2a95a04192be2a47e30fcf6752a91627fe9b5a8b19cc3e1e8ed641d56110c5a110dd786d7dae2085e20870f8d16187a2805b791d8fdcc68929cbd7c8ce7e1d4aea2d71cd6052ee473db9b2d68ec3311ae0daf33b308fee487c017190943cdbe324cb0f8517938359bb75fd43d26ccaded1318e5ffbcef4e9462d9f6d226a26b53453ac9002e9fd71b519a579a302e0a3adfb6560ca253985af4a3b29f4293bb3ce8ee0361812f5e514a1f69c262de0fe6cbe834e98204d6961b8e0138eeb88d3d9b341cb0b522f96814bc965188c6b23ea598ec2fd8d1a4a9c13caacaf23f5190ed6b1c585fb8b8a2349b0d7a3361429c0273db25bcd2eea5ffa0c72483d90359a6f587611dfecf4e7f556055573a537ee6d33fae1cb41f14a88494a58942402e28afb2bc105aebae2aba3d4b904f73a068a83e1b38cedb714e36e919a59ca524ad348fc8958c6777de9c9a8e4e6671d53156cf4dd448af0a218e8fb75fbef183fb7911ada159453994d6c3926ed50f4f9e0325a8f5f792b4d9dce72929d2ae25a62516122288ea5767c7cac89218e80dd3c99e6a4a477bc970c71c219ed0e9e8729313e43e7769ae67e7d9b547ec35d5fc8fe3add7e7444eca2bf47eda6e562a9ddaab2de151181a26ca9b389b61722d40c06224c71a5e268ef52506a2ee4e182d37c4a3ef322494ec3435bb42ca22f5f3cf8fb24e377a15357ba1f0b562190bf7d1797e8a3e456f77bec9fb73717a87dbdb885a0263366dfc1e1018b42f6aaa7df58a71f61d9058f08a688b02fbbf42d9c9bd19403e476ab3ce198e9c8b5987a0f848839e7c29ed16ecf3ba302f2be42b8384c403e303a046fd011c18a31a3261bce1b62af649a05cdf655f4ee22caad3971468bd582fb6dd38b886773ca9ad3a9479501560cc3b795e83fbf33fb6e056943ef4677b3e4c894ade9683e699ed635b7804373fe77277e74e208a364b942d7f7daf377e6bae5e5a87f4d815e6852a0a4eac6b2ebc3fb65e932891a9b290c00dc1734dd1fcf90c948e95544a7d7b7149416f14712841787f8fbd38b1f33e45a793931e53e98b78162fbcd13bc27c0b521977b1eff8418ff38ee6bece6742b290d3d5da8432e32b8a8f1d8b76a2bd0ef081653586bb80f88d48c638e4ee4cc43916424140c3b9436660e86f9bf48cedc9e706c82452ead218cdb9bc406b63c9e43135ef1d03731cc7a5a2c7c765ff3c5d32427675a45c6c78a83cded92f779bef00630a81523f9d61176d6ec97838dc81f2d1482f1c91734832162e198a5bbe0614a7fb3594c12d704e8b0abd1f32dd258135c38d37e953c3828ee61f79f04652a03f6743f72b715f35b961386e8248e0a35130219ae2c360959bf96121028d94606c36958bf0ffe0f33630924a9092e88a6afb4b33eeed4fba1c18b5929c9f474b9f40af52879b76180ebb599e0ed41c3ce8d676e937dd9209a4e876bd438375e155144a294f86819cbec20e853b70c16953ca9f6d91c81391dcd22f2b88ce1842ee256bfe3c407ea101b6bdc68e58bb76bbcca22596b242307211c462398c555caa8b77d1f9cb0bce1e6d779933e87a0961f18a3d81e4575fce6fefd51052b00baa392eca785c10a7741ea9da487b63f4172e5e8825292a33a70b1a89a6033fef9a5e777fa66ca36b4df56c0c3705a4299bf9b9adc02539d7330b60d2db2ec80f59bb7a5a20fc25e20f20c9cd899f7c95cf5f671bd7dc1f75980e883a72def59eced649ca3ab54066f45e8c32cfbc2a40ba71fff0b77c4c68654a983358e585007e1876bb4618c75f5d52736406c7782f5c2ff82b63abdc9f5fc5390fd48ef12b19f36a3adfad71bb5ccfa2f8757b637bca08845f5903b7c731172fa92b51e1272cc0ebf2b69a3c0a657710c73de0ba57c8662353f2b9e8dadcec337e9ba009759ef4922862cbe56868d1f8781079bd890b34af86719e0b86a0b438190b4dd5e0b0a60e0398e5fb274475bc4fbe9671346f2a38b4af3172a38ac28c8f5634770b12cccbe219a65043e6683f13c48ff5500b1d5e6529d09e891385481c742cbe933040044b71b2e240bb38b6757a21010f8d13f2514e56c0565032ad8c34add104178b73144ae6a82549121f7db7ed42686db681de63c560e449d7d4c2899c158ac48c13bf8c31caec97d46d4c841065452f835e95224616c0721143f2bcd8d7fc8b87249244ef5fb751b59bef67b10255ffd8d9d5a3eb5d9bd7b5cb0d7d81a70bce7e7778ce2fd7f1741d384430e32880b323240065d563a02451f1ab292f1133175546c787350fdbe801ff536be0c5b5298440c02595de9df12237221d1d14c8e344929c430db725893c69a13a0552d1844280a281530d2f838c782252314604ac401a7353769c9a3a2e3c16c86b5a0db1099dd48441f78ce501665093a4ff949ae8767378533303842c90aba217cbcdc737183b298f65b843a90a674ddc14981a3693861a832de230de6d6d06a4a378168f9eb5b96490e1e563b8cfdc1969295438b5341a247962ff5c58e4c1bf101ac42e56aaa21ed3616806fac23441105dc95cd4267ca7ca49e7d79912867ea2981af2104ac4c87ffeffdfe6bbe629519e36cdd1e564ececf38d133404a3e07d26e0d7921dc8bfa9eacf439b72b5e5ba748897759e6eeb405dd057ae630f66da23fd8cf655a9f0cfabf6ad3b5237e8fb89919dcec19a0ea78ca79a706200b2e62e2309dfe00602c2214282730d555e2df55f9dd6a9380cbd3a08ae76726b2ed2444af6c3d94a7a820ae7212ae8a340b7fb9a1ffbd5e9fe89adff87718ae886987be4194ce03ee14653db7eccd822a8846dae3eaa77567a8f11b7f9600ff168caaadb5cc9f2f707d80b5933b4290c61a8a6e827a8041c38256321d23d252af722e19d0b0ae145b73fcb5f2900e96829a36e3c6277f49b537f73f76975a6c39f3b6835555d919bd1d2ceeea8c83668264a48175b49a45efdda57ae3282ec6304ff14c2f42f85497fcc7c299f6bcfe7bb580b5f82428a76da6cb7f209c628d8b1e9686753951c58a70e09a6de9afc58159aab03b827a87d3848c77d1a70d3e713501905e307262c79f640a8538b1834df6991930d5c40e42459d97621b60e0256ac0195bdb55dbb770a5c3b7f88a2b2d9fac8c5bd229fce6909162119be633429df83ddcc397483e313ca2966b2ace139eaf85ce797ee6d0bdac78e2c1f4e17fe0c4b1a03333fc6028763fd72f8f952c414707d5d12f588b2ae9e05d0044b86adfb3c8e846d8e4c67db8c863850df0e3c515772b4f62ea04d98a834de96a5ddd18ac41136c9cf29fd62e54e453f17da021c75a2ee087e5d8a3be1659cf603b32fea87b60889672c6c777c741eb495b6cf2f41f97c13e610b26c75e60e70e9e42a3b71f6bdeb1c26fbbf88e05ae25f67c9d4cc64f08b9afe2456af5d20132dcf5a3f86a24a6f42a442e0d119441ebcdd0a8610930c44f8fa5d25e76b168bba588d708eeb5a42d4b0f55ae8ab79fa5394460cabbc1a388d5824ed2f9e8b9bf81ccb1b984e02b1f5fb5dcc59b431cabef125f7d5e13b2431fd24f5997ba7a117208ac515c53266671f1a73a5999d9c9535c995b1414712045c423ce0aca0d135fb1005d7be1ebfc005ab673f7ef62e1183f8b425eb963914409d5dd4a7c6ebe20270ec5025d928208094a3d60961fd7df6775acb4efbf2ac970fbc8c2522ca26f9cc587c751f6ecffc85a078bb2d0955fd52b18ff732f35663bea8dc80d0af701f7fe2d1e1d353db9f985739c908b6ba3be5a9678c186af2cecaa8dddd988684aa4b504b6b9313fd5339be8458f7bba806986cd0bb40fd8379f7a7e1a2cca600d6594c3bd8ca879c671f6543f3618d9638f301b8bd79e6c88e0fe86071ab2b2c148a748c64cc4f7dad2900c2acef331fd4571ea4d87997337557f1c27f957d0692f509702083c9ae22a2994d2a4117c678409ec269c87772c58cf88727ce3a88d9eacb8274ef2e5fd233f4a6f454edeff647eed52e263f309d4151ee108d87d45af05f212190a5f989c8550f2fd3509968c770d7d8ef022eabf1c7d199b18f24324a8827ac402297ea3af15bcf75e781af3446e4e00af3fd994cf1f7302c716f88705118b4d09061cc1d8a291f7e5eb32a20b5977f342d6dcf4662a102e2062d2c6dba7170876b4dbac857c545bd2d1b4b738da6ebdcb45a6b24be08b6f129e91fd11b8fc0f174650d782c051f4c356883c9c7ca8c4869e9957856e5389a21a73a76ae3bd9dd0afe52bbc312f435ee53ee47f8f9d293ff24625d2021ef0cae90d0db62fb927d308967cf520ed6340b57c6af3ddb64949a407a56d25976d07a9b0646ba476da220a40729de0cceabee7268978258341cc383008022486cf93a13308fc86f4946e8be72fb534c54971c2fddb59dbf39d6b351315573a969b1ae3bc517f6bfa569554456590f8c4f89085beac3948506bd4a3d2eac6aacd3097c57c8b884cf1b1ded0750e202e9938dcfc168f78286e05b5d12c2c2e6342a68a92c66174776de1fd9d34b0c3065a926e7fc2fd1575638c4bba82b2febd8e5bb0b1fa0b627caff48628b8127b7a4de7a8b32cf4d04017afa3bba95ceccb265b36f22bce6a178ff1ad21359f7406acdd95cd43917db36f486b4ef69284061317fc72608560abe2999e1c8c9ae66692e356542f045f5e278e9ae16aee981b596afc72148d1dcb06cb41b7c93093fe84725afaa330be91243222281b4327fe47b00aa32b2877be44725b51db5cba63ec6274abc91680d638d51ea40b0d8d57bdba93f9596913f3132fcbc771e62a0d1a5d3683da0d89d9c06923fa778104249e0b5e2017ad4f60608c8c36d97add7345a64bcc4354a326c1ba297c08fbb3899d8475e1cbb6c24d35c0016d797469c446b4a8eea51f3aaf571d7546427dcb908f7e1934a0c99116af62bd9ee93d04be9a4530404f9b96a8b71b2837167b9ca0dd2f25b626b366843fa528177328038ff5dfd744f84a4b548cbe718defd8b8ff9e84f6a8d677babdd8e49216a685696d37549de40a5fc78e14d26e230f0511264fd1399a4b75e741c3f25031679c21d2786b8614e2ba9987891041cc0efc44c9ce7548fdac16a758137d828bb400b9f4c1bbf69750011184f64c46ec299a65a5e52cf3395c7d514f1c765bd5848507c41f4c84fd24f034c97d0be7d47f0747790617fd5b216dad101be85d32256e8014b1142830eb76227053910b1cd0d986c2da3e55b4a0d3afeb00ac8a6790fecf53d2ff502cf99ce5bfefcd7dcad1e2631e8c8e818f63f76395064312fc8d6d0c2168b28db2317169c7a3d8624f974b44cf397890d22ec6984f0d3187278123ea22c1445754dce031e908d7dd016af2d37b82ba43a6ac5fd4f9421300a6bfa17dbba37c37224b0e7090c2ee8426d8626ae93036c6d3d27beffb09c31e17d4ef291b6c9988332fdcbd6604544c3db38eb9abb23fc2082fca9b46bd2a4922e09d79326d5b3b393b01cb229577549ae5db61de0e355d62b0df32d46b95d7041248241cf0b4310efb535f6d1516f25b589e43d96e2830c71b0b6fd99f28735b945f2c2b6734d596fb167a0f3e4afa71b7922618d859062a55cafd5fce3a0c9375ee499ea4a19c268edbed84b5d7a008fcbc1edd7ebe39caa12450bc7fb4abfced23099306a8be9b1b9e2cfc2727cd2cbb82788a4cb11e47cc102a1311f0eafa5e96be75185fc24d404e3cb250cd8f3e6f7a37a56c29006dffa0f0d34a782216ec86988f10edefaa6a1e947da46357680c8f4d838e874111a68ad460f6178687ea3e187e557c9dd258f22be655dcf55b090b88dcace3e649dfc1c66a0bf2fc186d9fef2c3a4e56f2ee3a11740184edd9a391a251f89c777bcae6814699499e2d6e8a637c4c2974ab077b60edc8908f620708b5eec100b07f4c950b7cf69564aa4c7126d794443e72361b8787ca55c727ed0c9a616e06e3f74114a4cd25999dca8115c5930d3e73c74ad078707c421bf0308b9c92fccd36cfbe4894095f6b9f3ce331494620e9c26f62017828763e659e92fd6d2212bfbd22f9b1b3d5d8f38f82f131579517cba3524423ffcd0629aa9979543ed32ab018433d233d9d43aa24a4a5aceab2344aa5d21445d6c2929e11a3823c4b85213eeb9dea5fb43ff14702127eaa1e46e59187621e3e8247f3b8c422a36f2971af6f0e08c3915ec079abc33eebd870c5583ebb1cc8c1b817e36f972ce0dbe6659682da68f65c8e9b780d4d7ead91b223433c4ddf5d712496bfd4670e06a15e7aa4eb5902e3071e853a3a1a6ad28136e132413b1ae0e0dce68cf665372893a9b0d213d73585fce479a43be2e81993d462d66f50c8cfbb9462749d6ac3974d979a7924508b9da638b0c2ebff634de30dc3dc7e3180a3ceed2a9e148e9f79b9d2f51978f1167adba934ff360aae2634d965a111e7fbfb3a355d66b7115c6aa02dcc9418a6807c67ce19b2c9b9e44f37e15204890c0ff39b8446fd1acfecdade688b61650237b56532e59a1ecc3a599bc6087ccb64edb534ded8fde34d08fe8f49de17535ec2b0048cda6281731a6de9eae7bc1ca987f2bb860caab34e65e3226e7e5847a2449855b339c84f462ae112526dde406db34894320f7c3534b030613d98e1f12fddef40ac6d85c06734ed228cca5dd9490951fbdf18b6d9339bd9314784f84019b25acc4b33d620f3fd9079564c4c6ce4481fc49abe8774beef26da36cf807e1020b5dd83b7be1596c9170774a5bcd7bc211bdb330b1eddd6ec0501576c73cfbc29bae14dbc9a55507f09304f972594fe20527e35a06914e12ae69c2602299b5563f5e91ea8ec74dc5cd7eca7c809d2a63ce00f266662a6c3e55b029768987e83142294f41b2787327fa387cd4182a12749a9ed0ba6e5d1c09fdfcb4d8527f53c24cc3577924b171e5e0aa43b022b72b057db55bd45efccffda3ef3ec244fe963b04defc6ddf88e88319b0ed35596918b6eafb78dd0eb94a40194764221a5150c0f768b99213a77fb7fcf85c85a88c1322dda3b80cf9f82a767fec2bd68f5e09ff1b8f584ce71aaa133d033de48ca656c56151ec7a82aaff0121a38d0ccf0477c20c147cc3a4d33d20fd9049d3504683739f9b4016db0242899b559b143da604a8df421f6bb3f446b79d856605488c641fa7f2afd4413d5de641a3ee2622c230eaa860b6e866a4c35ab642ca90f25ca1f31a1f2d300456a7a616bee2c4b6b4b194a3587a8fadd48fc4d00924c2934efc168be075cee3076af9dd3fb150523ba1f16e497a283a3f34315c4ad9579cb9a9dcfc47c8d903f6c23526070771910c4c65cc65873166927b6b902332c079da078d0fdb5afc6b17b0bc22728efb9b77667970acd998a8b6fdc3a27f57e8dce08543b874ad203e71b12d4af7aeca493841eab9ea85964bbfa9159890bf4d673f0cb6997f3df958af88ed888cd64d6f4f0cf69d520b0d082cd1079e21cae402a2101626be0e72606301c7e1f9f18e66febbb1a0ba59b1d6a9dd6868c90b635679bef1f12b55bfdaee6d089ff50946d36c8139b3b09968a926bbbd48d02e64f92ae68408d38fc5c58345ddd9303aa33e96391f6a191add2e6f4c2666037c317607c5b4951900383a26c9d6dd36ea241a97b189719a33a942d9a0c19bad6ad9f594900ec44d4a230ad3c5e2a930e619ea946e7b40a0b54cf8d5bdf32a2939bfd16a1575a52cb4ea9600c1c5ef95618ed59970cc96e4ae908043c3fa8e31438aca7f953981f13d4f31a33b15b6e904af3b1cc9f1e48ad7e132623f298188d1960931109b3428723a314dcbf2ffa7857fb05707952d3f375d8c21a81db0993e358e98fa6a68115237c42fd53600675c1f9b5d99f34fb0bc593e654b8ddc1af0ab981bccf52139f165568eeea2918a487402f021a2fc7059015aece758fe9b8cafc85b7c0eb6d93d20e8274e03fae6fbcf80815219f408843f7591f6ed9d09f9352e6e33a4af918794589c85c1c23d3e2693392f66acd05dae118bf96dfc1903ffdc38059559010142fca2778625ceba72ed7b7d316dcc57b9ed09de0eaedeb5ba3a79b227c03b0f7add55332e458f3d02bbfb5a93f4732faf70b3c326cbdeb295f4b10b427b2e9fb0992a3edfcf2906b8193255b1d1232cb2845550880fcb5125e53859e197f4fdf851d716eb5526d086cb9c35d46b2ef00f1ff9bf3349449c1930e15d5432bb33be46a8bf20e5ae50fbf21f09dd75c0d259ab287f70e2bb494eec86f25eb38e55cd3c07e439c84c1eb520193e920d7cf6eac36510daebdcff31276dd19354d48dc2b55b298a40e86388c5c0290faa3a0142a090ee4a791b4408421eb93938719a71dd64f8a74c8f6c958eb5623205b08feada07c94f93a54d1d4e0aa1789a85b839941772ba1efcc11dd5f68e0d2c959d81325b54192758d4d33c8447073b7bd915e847643ebaa95725efd3b95c7939d0e6032e0187cd285dd3903eacac958dde67b292f60d62e8ecd256b353737664a3300e70c3299a6be203d1d3fe623a51de5b239ca51c15998114fbcee208bd9e532359dfe70e92601905520331e0434eae484f3534d22de9cc901c3e7881a8e0058f5aeb2f9edb87d32abbe5f0086ce375da8ed4cb4d8a8c0995bf47bb492273a03d56f8fa0fbb4f42157e1cef861d6e5a30ce747507536e9b360bf2a4b5dbe59e8de30a011427ddf40ddb7833309878409f37f9a40c1084ddf533bf5def1ca453f73e797235becf97c41efeee2b559d4cf0bf7c95da6fd537d97a826bb3d6961b56d0ec827d3370a084dec2a9ba5451f826bc85f5271433ce64638fdf39af1475992ca754176cc5ee56f4b065a7a169adcc2923c6123bd74749d9c7f9f32c11576fa813f62626b05bbfe387cf51350ab2cd3287dc8bd1dfa2352e7067a1587876e349e4d632376d409c6af6f42ee3b7fe44ae0dfb73925fbc9c59a63a335dc93228d0ed3c85c78db3a8c7344761907cb07b3acf73d3c9e689f495d5633f3f3693b61e7b0fdeefbf7ace9f40e8a77d8f095df3720bfed3b703867e2e9806e73ba6594fe5fac409e03be8618b2c8521a9381a488f1a47313ef7e91a83c00453880060f63cd3d080335e754ceec1bfb5ca2a8340467549f6ed4018cb7870939afb8021b127ebd1546f0e6459804b70ffbe9ac0dd78717d49ea1c764ea3c5947b61b2016ed5b78cc0890192b21b3f7608ed3af49862d5458e24b634d12b1beff717ecac410227f3a05b7251a01ef00affffd7857d6de438c3fae23cbb4fa9926e2c744d28ac59742dabe51eb80a6b98aa83dd263bcbaec3e8816a874e71f5cf0a1b07294ca78ce1980caa01ef2eb3c019676b062c79ed29a9ce84cb5b1e7feae57dcf63dec746ad287d382b4f055d60a3cc0fe9c95f5091b5973aadf59a21c6cf62821ad648d5aa3041636ab816e93c154f8eb14883f1f09835492284405253971d6cd002f35bad6b99f799ed782deec3b3f60a3b38e0e4234473189a668940466478568f2298bcf0e838e23ffc79b751ce5f9edee02251acdfce74fa492f8020f399655a8e16a9e12b4401b69f9943d1f83b5b66fa97cee838f61b6b57586a00abcb040236aea046fbfaa5be3f8a03de1e0df2c47a78b7f21f99745fe6fc9dbbe51cb66570600b07f14ddfff0c113aa4a9187a0528fa66a78f1ac1fcbd073fdf8091d527a79b39c41de8503657dfce7e966c92c6760d63efc3b86388cd6bf4ef0d9f38cdea69f0ef7c396d67b5274000a496efcc3a7b19aa6d2e61615b412b4454f95c96fc3ac59be7d372e513b1c27f3d9bd3752d9f9d9eef16c38e6aed3189a2cd75ebaa20e8382d6e309d49bf827656f2f3dbc1b465a57c3af3a28cb5fb464bb268c896add194e73e290bffa039a2ad8bd76515ae04f7c1f58acb72f63de7dc47f35b4cf36c1d35b0259ec2d9764c2ac4640eddf1684ff5c31901a88bfe768f772ba40ff2acab23525e16a22bcd039653dfa644457fac6bfc6abafa7ee46b78ca96eb3f93bf69f5a6d7019f8819596d1b2db73a50bbb697552d37142cd43de128d4c9829fc7f1f5d5eaebecd5ad33f15b2765bb2ceee9a7b690602bb88441caa6d68ef3211bd659b0436eb822e0ef91a621773a553825fe238f310e3a8c7c9c33f711e5f54fa5653da58457dcb6bc343800535ea1d3b5b603985dd21c27f65a43625a57057c3263b89fda06eecf7e6770833a6cf7bb5668ed63fd391a9c09d0acc119fd148bba960d003f6502a3400cb75d8952ba0529dbd7f32ad9782c283736f1b6ed59cdead692037901998d1b9661174ab5da6619dc7e793b651791c2b1c81a28050dabbeb85453ab8b5a588617aec3a1e2d5fff25d65e155a77c09823fa34e3963aaafcd1b5c29a89dfdfa9346868eb534a4ed262b49bb311f822b13135d18c6d9b669640649e5841906d2954fe5591deb72439aa966b718ba85e07d3badb2a03020f9ab247d253584b469310021410c2fb7ff983b774e00f60943d2faea16b2e0837c3ce2ce06fdb3fe162d6daaf313bf6210468de3c0510d5e312832b0ff924e6aa13bb9dffc5cf3762515c2fda8c6f84fa8e30c23625da89a822becdcf80ecfdd4c62094865464d78b6b16347976904a665de955f78d8a0dd3160c7beb3e58172f58dfa09b6b6a8812175ec30ee12866df310b03a83496deb7134246f50c2b01a30f5bd3dbb8d4fa50bb74e8191fb082db52104ca05c0012285ecb32ea5410ba0e466a91d02fe2e3787c35f1cb2af8551342a4239293147f46cb45e5cbce93f9a0be69775bf49059dd281861334b7630bc9e0fb0eaab9cdc1a1091bb879f5093bdba2e216a31b15735b1d18fcb59ade9f110704314e1ddb8d031523d40fd2d03655398bd805bd7cc0dd11e62f0ae476e8fade0263b3ad4436f59c844c51bbafbc759aa2224277c04ec26578aec23a23f42b68288c4d2fc85d4479c2b4fb7c6c9286e22284fe71aba78c70c3c8d9c5ab59472d983733341bd2b1c20a760e5afadbdf1f0a6f825be1cae28727dd90f8789bfe3fe28481c91ade5be86dea56e31ef140705fa650d278fa289bbbe00df994fe5b04d334c8383fa8dac91fd8fef85c2b818e585e1f5b2e6b951d17c5575c04eeaf09242fff2ef0dbc1c1f5b1d256538cf6cc6d040fb842b1f4c92b357bf89950d8d303da77cc9697429fd3b93ee7292c114727fde309b1461e50834e2f977ab49b81728d45b54920ed3c5d0babfdcd29e4213fac4b499bd94c5afaee5717c89adeb0b7e6b9e2d74216f47c48d9f9d4b46817affdab3b2323357c67dec2e89ba05007fe01e9103d69b511db2062e33775d6478d089bee403c70b3e64e33fd708c4b364f0cab53b04e364936b98b9f853a1087d04b8b27d0cb91ce8d6449ac2a9e6c51dbac83d5a9094e9457ddc6d4941990c42311ecc4d3f11709188f481bc963dd2d098fb66424669d61ad582bf6094ce019fbeb0adf6078ddb11359b1a34ead1faf833781411050a2e29e42a960446e1040a19952760e1914a4135ddbb92b67ea1b192e50d210d6887bc759f238a052ac5533342f4e007954cc61be002a7057954bc83578515486713d23a270587fe361bb3e659ab48068444e5f76d12049ea5317c06ff203099fc47437f3a60ddb10382e5edc67b231ac009e8ea730f0d36c3415b87ed2cc80d81a997d398ddab6baea40ec8521f4b02375e2595cad7f56c5375d4dac59de279d2113dd2244a169c2b41befb801e4fcaf9a73ccbd9457221649bd9bb7ee7960ff02c5981856e5641739bcc2af3b3dae1b42fc6fb2d82e46f5a77448e75e7c0d29ee70877a49efdb346d3185c155c780d7e65ebab19532013f17f91ee6fcf06b4a10fe87da76d68ccd49bfb9d91d74f299319c649a794fbb9e9578f092b8d6d719e10cbb525302b32c18571a3e7c382b6144ad8145312216dea3d23be714f3baf241b94024b900b7fb2002812bba6d9f82f9fc02709238181cd739fabb431d80fc52c4664a4b2fded95855cda77cffbe578f494a7d66d9d4c159ca0823bbf226d3917da95e6ed285070d04a7e174430c1289f60da5dc637b491c2c1fcf6ebdc0df0483d31cb05ec3ba4be78e43c408d4431912e6a598b96300bcc50f0266c54256475bfc9bfb42d09838ab7fd60ed230efc8c5999b600c06b2dcc6564d3845d79721720f06559d0ba99a026fd426c2ac0dd55743ccf2ac717a7c8d03aecdb2b2cb7f6f8752cca770fa0cdd3db67f494d5717cc2bc71b004c9029f952e9998eed5742e3d680c43b25510c7f34cbfa90fd5339eb650450f612dd73c53d4c502fafe78c401c0d4c978a550b8ee0ef316fc3886a403302021ce3cb47cb69a444b5148dd1ef3fbfbd1e08831482c668ec423ff659d465b255ffd2ee0925c5f1489c928386a9ea99dc62cbca4b55896328854c1ccd270dde40da41115256eb7ec1d61295e5404f0496c369f4df448716fe6cf479ffda14de2925d7a550e3baf283b24edb14964913779f12409399ea0171160af22ce06ad3592caa22ea48a9ea6336048de8c26c20624f4252d29520ba1238ac1664faa232442a1c4381a4526446bfe87a1c40ea8c2ecb2645f01","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
