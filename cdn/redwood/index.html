<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c368758e8b48b7aafd15baaeed559fe759c6c22187a0b483656ba33c188efddffdf150ae355333b763ee7dad648ff4dfb09ed96e07184381484dfc451b31dd2f29a1900115ceff43f03eec4ca0de5ff4c68186aaaf8bdb7b7b343d891bdde677065b83a06e3d5d2f5c6822f1104a20f569e179be3b8e625bce3cff6c375090b5295974b56487264173954cdd2b5ec94bc3bf2979b4bd30bad1ade478f899b1debe785fca5ee4180ab51aa29e6f9f8d3ae605377eb1415dc7b45bc5c68ffbd9bcf27098b8ac100ad7be8b8de8943314792016df83014ad026a6824ffcf3b2a946310bc73e21822e8a95ad6d43c7b182c6df272f2c4faa8dc1e1f53cba5c8e889132b30d4d838bea2d0552b4cc5dfc25bac4917e82a8a92921b56e46e4bc9d56d98697dc38c1f53cd3076c26b33fb1ff5cc8d4618bb02fd5363b8651d40f56443e4938c287ca7685baaec39ba320e7b7212931139ec2b7ce91d26affd8ecff296d41b1eb2896c0557c192a5e5b8cf49dab68faeda81321d5c754ea039a757b1f77cbb3454a71627ae7cd3b2f15d500e0aeb703be9755e6b2a4f7505e91fb1fad575caac7cf73b96a08d15f69d1ff5206db581e97877bc32f4622e994bf5f5295ed474a7c21687a873d9e3ec8a58138c62bb78acf3d4cd0536473b9d7720d769a46e0aee41b138118af53a3ae12a51d579894e5ac6cb75ad82645068ddd3c5b86414d91ba8b480608c4e7b731a863ab307460e2f475d285a16258dc10d212112fc9a6cb483c674b41d0fcce2307ce09ec5d359a1bd02b5663571b2b988e370e50b7c4b9f868facccaf115f0fa3771a37c708db2a31beccab9c485d298893658334061c30b9c8b92362def66e4c4ec7801a92caaaa233a29a76f5241a13633510a91e29b1b285bb52bd2f2f4e3d67710fc8db77c6f3a6caadc43466bb8a9444413ee44936b3223b6cdfeed376b55963505aabd5a4ebb2237028e16276a7675c5c10b3986cc8505312517cc384e9c5a87951c55a54fac29d9ff16f83b4864bde9f1098ea00f6f7d20dca01edd74ef54f671c519d1298928052472d5b942a91fc5dc92e33c90beeb28a27be7278f4df5cb7fdb3bae4693002fb4310a225865bcde599e52dd65d14121cbe8a5472334c3b74582dc99e457c5b1ad261c30887b6aecdc4335c5572cc0af8d822320a29b8114eeb45cac84efbad7f01d7f91b95061288fba8f84d2f7aa411a5c990e5a9971c8d7195b5de981af4c50d63e54b29a72cc76f2e0a36bd54dbe1491cd518cc2493b90f54c2cc1973d8d668d248319dfbf623669e705f4c2d078001744317aa9130e2a4271dd0414681174b66c8ce8118c93886170ffd4d7490767708d69ddd3e7a5c3526935ec9d37cd1c7ca24690e47b52ecfc29b0041a31446147e31b243ec8384395f0de7a3e530a8230e0fae036f965f22ca90bdcf599a6864a9bc8dae0f551de9e72dabe70f5a4302626f9e2b632de1006c1939f07e7594a6a0b151e863db64cd2c7c806b8c5a00054d27a3f48207340bb6f0ffde4cf2c56ae9be41b3ea66af630e689c3d99d945da30ae3911b73baee3636be78897c4dc73785ac4a52e626d55a52807005d87dc46c941dfe273163400c35ab9d4e66c0f7bba6781c63f8b2117be6ac49c3affbe4acc01665c3984d5e639c473a8e34718ec6fc7a98373a9512ae087ecb34c7bccb4b6a514900a44bc3096b3e0f38eed464c31ae7b3cc9677624d9bf4574051b6ff912ddf3d3d9985f05b3ea3f2a38b65dcb25c63e6084e602bcb42b4ffc09ae923a8e21b6f038e40b23532aca9013305bf26e17d872413ca77f30a19a631d4404e16c54d7cc035f880f7a103fbf2d3761c121f9ff1c10ce70f09f3550fe13de5fb094ae4353610f213d02c057ad319e5def196138d8ef31ea2e30d2c3ab27ca9a5699da945105993a3cad8111bedad88faad05176dd9386b2f6d1f8a82ea62163b53b7a380af59e94a09b526df2b88cf8c9818d444e25eb96a6ec4775e89c3fbac83ad097170611dbd60bebc514ca414c39fdd6169d0c079f38132ec15b2960b08411945338ff0995571b883e5f779d1a70fe922a3ad9d974fb131c9ed50684d9feed51feb7fc94e905b5c5ee1c7cc50baf860c905d8a3155e4013ffa67cf066e3448560f1f83759580750c289fe3b96fa52659751a82f6b8960db63c445da50e0e6d55b23f55d36c12f683e600cfb3ea6c20e9762c6aace433fa083224b45e70082d5d59276f2022d9003904c5b993cd64bb305bf2d3c18587bb963acad7183bd01c7ebbd52fbaae1800604524a65c6002123c2a1624bafa2fabeb8cd361869030fb3476a19f7f872eb2f051211f3bb1993c08b4e0a934430b203e0e97d2dccb3f1df52d3f31ec2268562c8f52f810efe34ebdf65df2dfba542fe4095370c866ff347a155629c320b07afa2b87f860e55c3134dc65c24799066aee14e136bee2e5211ca70fc04d086aabc62167d479adf359e5684b822b21e16abcb48d0f6140b7218c0f03cd414185297ccf8574e11dd9a6d1ef855bc6eb9cab0c5f54b970ba3527962039c75be17b63c9c590816d2622af432fbea0a7c765c48f65db8aed5d222bcdfdcf76b1a091646bd1957927014980049bb8fca9736c983d6778da75d6ece6b7f8606a75d20e025ace6a36bbdab1b64c7bc91fac937c07bd2b63ee2077421d540039025eb5a45c0ce43ad9b5246fb08cd33052fb37027c8577b4ad754dfedc6a2fe660259e7bd00cdd49914841c0d3ac507366f5daf11ceaaa6df2f79418b9a95f6b3a04d089582c90fb67d4cd1787bcfaa6fe3435b44dbd874bdb641fdfe9e6a84a1b2a103f6661a321a9c1f6a1f279583e7a67c2b36537af216ade078414a6afeb9a5d380a009a2661d5f770f71f84622abc577a5da48f1602d986cbf134600ca88f38b2b2fce01528fcba232222fdcefc1d2d3431af6fdc7363d3c1128c1bbb0f3fdc1c06a930cf2fee67b3bcb7d01d55158a5c5da060e36ed6fc2f389dd913bc1e78f16b4284fd25ce85eda2e2c560312a5d384af8afaa8fcf3a28969979fb4489da6a7d35293f266db4e3849f2e5ba7cd51083baaaefbf3c023e72a4f055eccf8384c6491233e4bb61a862961c590c56fff325d9579ad8b6dbfe3386e747d11768163f9b2fae782cc4db4e4f348f8636e69fd5f6735661ce01ed0b281437f392fcebf9f92703cde12c768f1904825f58e787f4f976cdda92d37ff0877d328125b202ddf3201ad5c3d7ad975f635053a1f22d19e51ca6acb57e3f596dfe18f1a7f4c19a0a44af6a9612caf1bd194d4037742c8d813a133f894beda1039d7fe0b2e922bd5154607e2c42c024d8b8fba7c29a434d6342ebc79876fd4b8a49e971b39c0fb5bf2a01f7d71c66c9dd2188756c34813bdb2bc3b3cd90645c9d0fcff3326b1ba1e1448759f26419a5f062b16637de350e8f3b077ae528f3f30625c973facd9012aa6063eb068871d00c580daf1f5b3dcaa6a81d1af8aaced5de36447c14aa8fdbc761d589be108a7ccae6041f3e2bd7d68ace694f1a2c3b9b72bff79dc67f3cd9db061a11ef220a6ac0883c3767f67c6bb4a8d4937f545f37a07e2800dc42d15d08c21926e78d4faf5e6eb3dda7d4558622206698e0c1ade51ae6bbe04c0c16a3a253e1e9dc55f00048608a8b54ae8d052e9b1e8879129e1093c70735f6b79058ec5b89f3c9644c4dc8eb7a988e4e3c6917a384f3029554449c705a4c62715d17d6d84bed3c40cd1b9bb39e140a84082477c56924505b9259a0d21c2d36e5543fb2cc5c51a658957516a70a2d6456fb7fd129be51141c151a4a165f78b01e95203042cf43b095d1db0bd1f555e206a5e9822c449bf472396ae5707aced8c26911b5b3df70a8098ba54ac4210c61d0f5375b2df13a54b23fb868eef73d99621919c067cd43855b9490ec883d1ee78a299184bebae0df82e8a1782fe9638dc868aae6ef74e8344e4b7718d4b974e0b6f7761f4dc671d31a097aaa55a10d29cbfb0a2af2ead5d9d123c34139cd104663137ec258385ae835b9383f2cfe002d7f2d093257e898640e577f8be3a3d7883dc6996e4e9988a641e7e2f5e42e7df8e3f66f9838cbaea8312be3dd7be9abacfa707fcfce28bdda75f2bde25d2c1d42320a9cbb6ecba53a4608f4294021412e41f91a29afc27b6afbfd0aab737843cd0ae3d7d4279e0141760cb26dd1092498cfebeac3ea88e71ea299e29994c84d92ede31cd3a01afcc2affac78b293c9a323a1e488fa812394fb84d092264b3ab3fc41457e93633e0d0ea234c4967c7a8b5a53b4ea0a11d7e18e4b1e97d98703e87617cc0ea52749842171402f43633a30aa117bd83bdd2647cf574157b47ccbacc0511b4d80f90368ae8b178ef6104f2e3b660294cf9057c87820784cfd15cc6d2d794a396fb6fa1c1f366c34cd777fac4af8ee69a3ac877e711c7210160b1205f86bcc729b2b9bf34d6f06b22ce0ec6d8b28e96fcc4fdb3a85903494cfdfb48c0ac1ea9df175b15bada6e2f556e2489d6cbc4e6ca6e625718d74010a46e2e8c80c104edaef7f2f1bb446355cee12a53c7f50bb2e4a9bb1da4acdf786eb5c951e23f6ab5f594f82ee669a3ee1efd588deb0b03362dfdbaeb5d4b9a5852551cbace40ddd6d02d95173a40e962c6f1945eda720267aeb9d0982c9c409133fd0d21757e7ad4ba7a228a0630bfb89581386f6cbd5e2099ba4d4309cc637d8be02d5047a292436a906c3a2adbb6276394d047eec447e35ca9f0c524d4064d1174dec37d2a4e32aaad7866312fcec4a5574c047eb46ba98de72c634a1d08fb71334e6cf37b27992f548ad3755c0bd669cb8d966e98b65f3277eff60c71b729b10fdcf03cc87ba6b5dc9fdea96d0027fee82b2c408157c46aa2272fc3b25ea3d248051791d2ed6bd14c37d41ad9a0cd78dc7f9d8bae1111f3b8840b8389054accc522edc5604309a210b46d7c5d4d80bc7fc44e49679aa4f4a6d6c212f0787e9c84e31c10e0415bb3197b0c8222d853a3142518ebb9c585da43619b6deaddce3a0d2702be82a28b5abbc8d860be986af7504fc59ec9d7ca98e5c5e62f3c925e0bfad0d7bdd86121da138089f29191a534c48fbfd8b751e87f6cddcc55fd945e3fb0ba20fa17f898728bfb4d39a48086c945c8bb97b19c42bd92e57643ac8524c689992f3c5fb82a237ac6d3e57f5cda13b230ff29673e399909707e53064fe052cedfca82487da8708f93743aabe5b14b831a053fe2f1adf1b1ce49fcc2663c5007ee60836e51ecab6b8c039d0ce6c6140a2dcdf2feed2609390b9b61c141c8249140ccfd4aaac16178478e87a7e038a2f303790830c92f402af15efa8f19235a81d61b71b3c9b55f3f9f46a927e6aa9c9d32af4778f05131e81db71aead2bd900b194382dcf8eba0b5b6bffb1f3cd15993c34ed1cc44f4eb446cd0f3d337ac6cbac5169d4727ca7eb42f8a41657a93956f27cd5329dd88bf9fbe0ac6f31c71445fb0e7a7da635a4a97fabca44be621531cf7318f89f7a60ac99adb065cdb024f248c9f1dc532cb27a7c8a17a16ccda67fd60464dd9ee24221a7a17b1941e66d1cf18a2e87779788554d547fdb990f04e71db039467ae7e26df52038c352fb1f2236b0d90561ad09bdc738d7a1c62ef259857e1516f606d5d0d520110f55c8f3f3a5cd9140a34e583110372099c7a5feaaa350aaa33596bc38cebde2b53893040a26067e3438fcad94d980648a50f693322d7589e8ee38c805640c46755fc17a68befb990a5839e90359e4dc49a0db5d7994c23fed5a7cff9ec8d00da33e7923265c6d2f556b52a76a9551b5c94aff040a34706bf0ece0f0f6def13c4872bd99e157dc79f5c58d31b0cbf609d6f0c123487073af95234e78a98b8d88a0033cb0be90f4b583ca3d7a423433893106135287754807f4f993075d0dad34bfaa840176960f75e7f607c756305e9428e1d4039b522e39b5ccdad70f99efd8b4ca2ecd96a65e4ea6c9632fd50744134c8d34123e440aaa4a1c55ff70e0b8621df8eff84743c7610ba6e8951d12eb3f5a0a655c195b21437e4a2911d91e9e2b4a48b88c88e140f64a1e04e275e1dc3935768e98def77295c11e7bf8b2b6891350dd07b5b448a261fdf60beee374d0483d458d29ef965ae7e747be9aab47b03765a4ee8f1af55bc215632ca6e9b9c1f61cece9641722089c92fefa87602db2aa694eca9e57d4ca1151698dacc95394a2c017fb625292c705a0048868ced550a614c3c5ae6e1afea6641d13c894271c3e24a078514ea37976dac293a82ea20bda25265282ecaf96fae5353d918efdbb8bbfbf88800f6f8cc3e1891572ca28c3b41f11ac978fc0313685d9ec333bd593a031e1ac6f4f25dfce477183d3fdf6642340e1a7be9340449cd0bd79ad83030bb2693cc2c959494b2165e4b49fcdcea3130c7a08b3faadbe51ecf48f705b9dbe12ee4f8401f2f65928df397c416ca2e044a6ac06d471ff75a5b2f9ccd74a8fdcc1f2946f95680419a6c2e0012674773af3e3d977704fa23e47be83fce62dbb2494a08dd2c67cae2c8ab8b54a148acefa098ccb8f84ca6ef28ed270fb519461507478cfc0b8d13267121a85d8af5757ca8120e15b85ec2ea2fc2c919186b2a1e0307e82b25f959459f3968f782f62fe198bbe2474709a64b77525f2a307ca280303b84b32456a0b855553e2229c0e203360467c25ba6fc185304df5205e479f1ada62246ab609c234dc7c5e1a4b4d3089c29fe7b7e2629e78951eab014412f1471ef89a0276ec3e5238d7070a7068e549ee834a71de4001eaa88f8b8af19e7bfef64bd14f13a73f1969d893b6b6f4753275e36281894d4aeed87400cb2526581d0750761189c1b09a45cb41d9a95843f5a3d065c58b8aff4f4e45c322430c684368c575d79a4db351ddebd769904cbaef6ad21a0027a662a6235334baaaae01640f8dcf691ec231d10b19b38acfac91713047494784205fc28b260cc2036df8b17b8256256a2c10f507f6767d924958692e8152c439aa3dcb7d01b5b88c3eb9f2d91054d7b9934da33c3d8f10024834e7c13a5db93add555c18a632b8be305929acbd4bc427754dfe8044be38550a8d18e731244014cae4f3db7ee303012b907ed5b37df16c4786ebe08494cbb96ca0746ef240a2acd0726bfe9ffa618ed1ff66b611a8820ccb2b849acca45d4ab2c4c2458ee981ece9345e939173052d4c977ef3681137459ef10e4171fe7830d3748254b9b16eb0986299f5c0f1e632a27548f1c4043f31dfd800688345b9806b9e61f4ec5b5dc88346fae368c67366ef1b8047b1ee566ba8fdba1f4dc7103417d95180fa5dbb879f9121f1472ee061ae06279e3de69d4cb074d72f55925d91c03655a228eeb782a9948c717e0aa990f05e75a53f7f322cc4a59af25032379e6cd8c4c1d2a3125ea17213045619624c3fc6c737211208f41510ab04f2762c27d5ac626bd031e86bbb54b4b7c70c1f6efbc59a3869ca6c8171e7e9510d6a9a83744830282aaa561ed88443dca285b786768bbccab6982c8bd0b25736ac8941c3e981769aedaa83f53b6bc1ce6db646d2d0fda6cddc7034c31db9cb7690b80631934f33171985e97b45c0b42ac501ee1f7f1eb3056f7df0050fd736fce5c440ab7b334d5265394ad9fe329da8c2216d89f5b122d83692928165cafc6dbab26a67dde88f52aaefddc175e098d94479669c3b78f24ce3975a27ff17be7215f3316bd8bfc394e24bfde494db12fbcbc4ec3fd564f8f10bce4ab3332f7caea661b4843f3622abbfc37dc8bb0146fc10bacfd579bf1b7d11442e587dd6c8f517636d48f7dbe834ccdc2f78c35943650a1ede210a11e154405e46dcc228e7b27937ef4fac39d4dc1e31f61d17e09c094e1a87c067ebe93b2fd737e7d6ba5bc00d39798c715369607e1fb2c6ef691ee95ce0da01297f484021f8b7955d96d9e2caf1b9dc0476f833138f748dbaf2f7ccdabb18a9835a0d730ec5e5a4c5a6beb5b16d0e1701c691fed57b6bfc1d9a09c65cd1b9aba8a58daf5df32c8a26e753c85c35c08b73c528ec24cf8d11ff82914c978adab1937ffc7c6659b99c17127a29a0656162005b7c7f7a0006c958bc7a993a29a918a5fb5e70e2e235cd7010d8b9fedf1618a5ae005d9e8d219b827bb79829ea0c3b8cfcdd8e16522bd8224291c013ed95e71c153682855b20814dc9d54c684e0065f16e9c6414abbc1b884f289bb86dc2a68a14ad91da429737f7eb86e15dd875f01a930e7c95085222c2fd806342f3bff8e746eadc8eab04ee6fb5d7638146e9ccbd71d3a594cba7ac413d944fd6f0b11ef145065b6c265aa3a9db6f95b4a6c29afdc921371996d3e1b8ed230ddaafadb65b79f3c8faa389a00ddd1e1e9485cfe05daa6c24165483b9b7d7c931053477cfb837e51339597c8868df73a3294c516d6566d8de21f87b0202e21a676c3a2f5202ec216f2c039d7a19bfd39bafda9fac4375cd450efd5d31bf7329efa7683990f9bbad0cfd1a389e7a36a2a58e050a6a23109f73e5fbbb437685004c8f55459032b43dcf9faec60787d4d4ea3bf69182824d0d3d6bf4c3610d4eb94f8bab5ec72adfffbc11e36f4a8771dc302c6ab9c65fcd1a28e79cc800acd14c8493862c932f7e9d9f685701ff87a1ed8fb0522521a9b3412e6fd04d10f13e19f040b093a279c2cca801e1601b1d77bbadcc329929ae8d77383113894bdff2aabb7acdf9f7e922c05f874b8d3ff54695c1b8a33ad47ea292afde3275c6d27432763e05cfa78d0f01b89269ec87347f5314afe6bcf84eade1d62f62a0b20e8521e6949f5e9575e3d7d186e2e2df3ddc06fd9160d704d1db76c1066c956884715b7dc68694c9f55f3a90a1336c8d8158d9ee90de0ee3364c3dbb0f697835db49bcb8669bfc60e63a86288c45eb6a83534ccf5cf40210740317ca6304430089079fc803a3d5f1581c2ef6acad88d72ea81c27e1f7f8b49c9c9c878d484491588ea4d74cfa3d4a350b359f7c8f6dd967e4715f0386cd88ea26c616c58bf9ecde963c9d2797ffe918f1fb3c34c87fd941cb205149b3195e08a25b27b21aa825631c4d371320cf103570ee0130c0ebad4da52e2a7ffb1acaf4ffa72f1b93d52f55f6cef3bc6258e4e0f22bdece39fed584532f382a5926802a14e193e2837da576cde59e1fa21ed84150910e0e85f95c52f323652953ed146a75a00eda1fef742810dc776ebec86209cfac48ddf5d3ecfe3bce82709bce7d9aff5a295879d977f1bfaf3c3a2fd7de9147e95283d98ae0bae1522fbc6583762e4e725afdd9e25d3ee244994b17232c4549bd725bd5876c2f014c66719581b372e466cf62b83afdd52d79973120704fd06b47846c11a40e54f738f0f3551ad1bc7a7c30ddaa06c6a43af4e67950ac8bc7ea5918154b73bb9be09586d9e4f8bb678ec22ae06b5b2ce0107c3620cfdbc6bd37c7f3efe84e01aac21ca008168e6c6f7802222c2ab5a3ce91b32c84e3f332dc4e654cec8a857e98291c4b494820ebebe59db1944d9cc096b14149890ba7c976d00b718edf74a9e8962a390556664539395290ed8d451afee1bdcb8d739a96df8d120650e35f12f930ebf7f7724effe4e983524a432126713200d17593d4f53427b493397a25b6a3b8380c8eb9504e190158d4af499da67109e6f9dd34d25d0f920b536d0607274735bf14734cc25787f6b7ca55d4064c28fa8a0dbf0dbf811f8c967ad5b5c6bb372866ae24bef1e88f8c421e2b4c74aab2a888b46981a808f65b90cf218ffcd6f036de615bf16879db0197fc3827105fb846de9e3f01ae9ec1d52199654284878749eed5263f778bc6713d5b0e37fe439ee192f245cb6d47236bd4432789b47be3671311a0e7ad29e7b21159e9b525ab6c6a8303db99caa0c6641ebd3ca4a3b952ceb355f1625fcbedc25c594e1fbc58ed81fb56f85a0db0f8a3e24a9dc318c1c86125010a90f9e4d0f1eaf8e694912eeeda1db11f6d46118d431fb6fe275b24d81a4b8f503e7d382dbf6cec660256efdb95fd749d3b3ba1f6cda451af09e397331befb6a0b1793250f8ba44afb23b229fc78bd6a6a91505892fecba9022fef7a93ff7e300ec71e55523c1fd0dccef8711e0dd39f781804c1f642816872ecad4dbea7ea68ed5c2853d182f78ff1960a1502159502bb5d6e455cde569122fc638028eff54fa6f8321dadf25f261348c543bf7789d7ab1da3c744a2842dd6732a39054c480eaac56737c0bac0b8c382596cebca43eda46d8881cc6bc1fead06345210f5bd99da094b4e92b328e21ad5ecf9718ac02ff7aa356d273985b65db166aba822b08c3db07b0a542df453c491ffbb90e5e116049429c455e6b3d23e5ffd39bc96b32422dff2b71472c124ce1f907aaab58cd8f46db1d8f699f8f3db5b9d13807003f1f8aee97880fa5b6e92c0c65995be3c2f9f0409804f3679d3fc5866c4412d3c75447680d8fd250eb5c792f3f13d918399c98da3a0052329d59b12bb31b48144611b51098d8820f6dedc83d8d411b97c67a53ba8fb51960dc6b5e9e69ea13da3a451cb6ebbd128bb11b6291704b72819ace26fdf61e51d47ef81544223cd852ffa2c47aed956e3827dab1de8dac70cccfd8879fef9a490483f42b3283bbf44ce184acfe652f38ffb979dfee559b9d611f42afa5147ff12ba384c69d2ea0c950e71d904139097e80039a0134d54809ddb70b5f85aafd4248bc007db8a8c70c9a2bdd3714b951ea6a78b86e15177dbfd9c65c6698019755b7eb980000476cfb22e581bae534a3b0a59f70dd596c510f48643a33d885a158ed6f648d2abbb27486a26264079bc3d93de50b6d910ef8a68c6a6921a1ca0a9bf6f8cf25d566561d8d6f9b9a7ed29b9e6e2ddd71c504f30734cd9eafa8963c0efeb8e73aed32f6fa59e63f90f803ee441a74cd44d78f44211e1dd4e5bd50ba31b739397d2cb87bc9ac192294ce9699c8a52aa04b204327cbeece6a339e1f0dd2cb903d0e174ae6cc730c2d0525f04327fb1b79cb25ecdd1a74f13d948fea2147c15fff349fe8293a175eed48f595f3b3d1e51bb6b77d1a7d29119b631a32b320a107c8a798470314b6b4c7379d050c43e02994de399d28e0c63f1bfde9e63ee6e1bc252e500a019bc8c798a982c0dddd3cf1ab2b15c0f99a7a45cf0fea7b03dbc3aff5da69fa48a4f93de5f88435e58cc907f97cecda1d31ea4bcf35012ff31317f834a521ca28ee502cdf27a9c8034050e1b7aec2f372ebc617e4aa0d95b13decf1212524eb446208cd45f36bfe1da2956a93476762a3f20fd4fa5eabba3a3a097d839a0ac9b522ea1ef55875e9f1395c038e9e2e17c615cb28edd3f77a411864783fe162a2d5f96dab919e8cf2dfce5559348c95f27d6cb769de2dae97d3e995047803628b121591413cc8b2816679dfed634afa1eedd3c6e5354a8c09881d386fb56abda9866b78198931087365ddc117c5c9f5030c561156ba226fc1407f7378fa9377a1d0fe192a64e920ad6c4acfd722cc14fb0ff22b73f31a7c0cd4284562fed9342f56d89dc663b20539f24b721ccdc1a880112905510cf684c2d41cb59d96fbe2e9c62282c172d2febd632cbf10717b8579e370e6ec1dafd907ce67e1aac974b49af93120b35cebfa3d7be21ce90e6bf6eadb6b627d0f2f6b2977386b9017af73c420aa52ff26877178597e1313ac1b3835022c037851037132bb43c78f2945caae7bdbde63e9c7474aff877f02aa42d232b54f4b7094afe27aa18b2a7e9ecb7bb77192a0b99d9115db8c36d022a7bfb334c340b5a83c3450acada71cd0e9a42293e2e4e0c5f9deb025afc16f61dd964b2697b850e850c647776f09fedd65496683280da4482f27840260a720f468c1860da671198385954a4ab8fc778058375f4f3a6b3547a3ee55d3ea7488e4a8880df788debd96d7da45366e9f3e47cd268d4a15ef684e2b6117a6563d20e3af5e8542e94b79068f3219723977236427267dc0490def4216d169a45f8ef138f5963941ac466fb58d62e3f87f0195685704f3a0707b29c3ce8e791d7103691b8d767e3e3c5d2638c5dd6c7766a56bce5fdba14ede8861c451ab38af392fdda6c36c34312cff2576511afbbd6ceb668c3dcc61993ee4144bbc6704697387cb0c87286e62d924b8a9511f42b7bfb4aef8dd0fff09a513afd4c1cb27f29214fa76f8a673245541a272909c44624c21c8512dd3021c0887754c6abc2e5bddbfbfdcc381b21818c7bababc848312d9caf3fdb086c175066b6e7b0d96035644ff9aae37e831cace78594e0c97fee9fd26d077ec067372c854e4c937ceba03d351c746d0fb8d49a8f92c1fa8f6d13dd5d005198c19837e4346cc009056d36d06db146d668bdb8a0646004f5faa796ad9c1e94a61921280367ddf4ddfc16f8f3b4a39fae9e29dff0eb05b21f85ebad18bc3f8d5414522d26e837225c6dae265b3d745d327c9c4af35628fc6b3f820d5a0c4481765a7e89b293d0c2cb11f2fd8e9b78e8d982abcce1df9a80b55a2a812a3e7c4590712f105b52195734037e25213bf705317da4218e420c0756fefa9fae85d0bc948513ed27a1edba897a4b1eac142924ef6b44520f6248a4f8200aa55153864af00723c1885b5d5a5e7eab8d515e4da048265f345634fd1e1c474b998ab41d31fd0f312a923916ac9fae4bf656271178f3335b63cd0fbae8bee1932a4566df2cd753d05a6a60b02108b66b5605ebe91d492a1a7607332eb081693ff99a564b059ac6c6fddcaa2113bcfaa587b4fa4ba9a0837363b73ff403d4879a412390fc1d515466bae767f2663d26a3a2532dfd4a1a94c408de0958f17fe6887061539b094c772b4754138042db3661247b88a2b4930980ae7813c4578e1be65e4e1201d2a155fad58f5613f6ef9860316c311fa811db12d3cefa928c7212d20600349b6abd8ff652bf82d9e5878b96943e08918aacd0e083ad43ce1c34ef03dfcfdee9448ca3fc2abf0f37f859f68a4ee29dbec927b9153e6087527d11eafdcfd4c211fe2c175a0cc6e5606fc294f61e5017a098186ebbb98e3be4a50430a4b4a7aa4b319a7a08026510e6b7e2b7a6835043e116e292a41725d8b64a062602fdb0a802e998f22e9b2df8aeedcdc089f5dd6578e95dc4b140b9fb38eee715b754582c5dc834db87faa262ea34579bc1ac018922a0dbda72ed2505274734be88d115ff42e73524b9a30fb886c58b6d701cc2d65237afbb8b2aaaa3ca7303bf2052db05b5588a44bd651a8cdf3dd6da0cd7f1edd2bb672796b88ae796336b7e25877c4f250669e6c5897485ebeef3cb0aafd5d172691034a5a12e109c45dbcc2fe091919d7ecad84fff21efedcffdb8aef1abaa6585a011acf0ed50991e985ff14c99959ef2ab746523ac04e1e4904eac4d689fe8f236c6a787fc3784999f50e66e6df1d361a4fee885c8c1bf82e01c79401f98828427ca6b906f23aafb4cb63403737b7b48202299a4b446ede7cf9c48850a6b70df6dadc31f3cfef637973ea1b0f2521de77d5522b17f04c64e089467b1f0cc5679a19eb43d81a5f1d2b3947f71cb5f1412ceae8b456017926746d9c9e2b61b137df18b6e83c9213fd0320ca42a2005bfc424086fc4012bb82d74421dc900600783fea514a83fbca6e91b8cd718b0d1f846a1dafc9f80493ab93d30096ec075f962592c5432474d3931ba2d84975a594151ce83029f9e8ffa6939bcce409dc3a3f03e2cf1f749929bfe8f6d0ab7ad86114eb0cc15fe1dee56d67f2053a1552e358c49a04477cb6a492761d3437457f0fa3b65e4c82f9169115157d7bccabf469c1b1ed4d890a967c747948e8e2c3a1ee883b3b876a3bf54ed4c13cb9cb235f507934c106cbf4296fb3f57835fa96d52b407342b8ad50166cdf0acb109e1a81cfb63724cb60f0b9556310a4830fd68a954b424a9c04bcd8197cfa52b49408b1ba59aaa074390a1b383f1065b21f5db2d61251e6105a50924e5a0d21288330821b7f80f497c11cfa0c4013b74b65c65aece86e3f75fc1dbfc765f0df5580f97a0adb1d532f988b9f4d8042b7ce9532d96777420d648af619163b914def3ff674cecc8c05843c256f7575514193cc90020bc57d18965e17ba859e7b5ea9f497ae74819e3afab0fcdcc1cb4ee5ad52f55066afeed6450a7b2566da7cd671aaa3773bb5b5ce98a74d8df8072e9b9e49b5bb4e8fe831b5a62bc91bc18b1dd45e86df5465a17db92ae127ea3629288eec418239c96148bb7fb635343fe05fcd085a08556685546e27091e1f3b9062cfe655aa10992180850bb81a582a3d4d98fb311dbcc01e91d952fce5e126f1e84d65d947ba8783503eeb7afc8da6ae6ba962e2b525f130d69b447c66578f51b9ad512dd3351d8948b6287a5996f6a5d1c6942ec87e5e0c1dea35ae1cbb75494ba1003be7200c408449d98e4d977eeeb3b2e2470b64d7720587b62815377e288934e8da536198ee7a7461226f90b24df50caf9a06d7e178b10731e96a75e7edcb9b84bf70ca5529e4a5d50049ba4018031d6ab3a3e15c187f0410409942da59aa8c75d3201fb70f3e2c0785c7eb3a3813d2af644e1f50c7ec40bd892bd8810e04478448baeca2d6f935e336c52985ef14928a509b27071bca75502b2964f4863aea77d6ba02c1882969bf4248e2cc35fab8795f31bf2b35eb482a79679e6222a46fa1978f83007091bc06441cbac798cc367c99b0425b49ff4ee8e9b33b4ee784f67a2d075cc5a14757488e1e0989dc32bdf4211736207b69880ac9adbd64e97c2d0768e13682df82f4dbabceacb4b09a9b3a5f7d1ad2d67e6656eb5f226cb427247c4dfd1ac05d8dba7b9e931472cfa23e2e7cdce78d00db36c78c6668b831e7331b63dce637b86f706e3f0b437ce19c96b2b8945b999f0df85bf82255d613691154d8866d4a3d9fde8a6d0d7672605641c01897bf3386e563d9763bec8e13ee3f024547c6713706a204973f92eec4347d1831cd319012728c1cbdbe45cd575877b4a9330115b04de969845d9571910d4e4126ad8fa478561eacc416e8aca19f5c4b67da260e7cdcbb614fe25c0768587925d65c4e503b814eddcb54dadb5d2a997c8cf4fc22618bda8e2212980dcf3932e26a0961b4a8cadd694438dac158f5139c0ee5de7c362984e8cea2c9cf46211b77e271053a3a4cc5ff33f611ac603ca9ddd108f35f556934372127981f9990c480d67f62aaeae6b8766f60714eceb7817146d110204aabe52902427fe5fbfacd8647d197dc655eb34f4f7ea1fda89bb1f486e7e2842e784ee844e2b0e0ad5f9ee548f94e2366234260f69f9b743c439bfd599b139965b2633ab67425e7a75c356febc768f084f205ea516249cdd13a33802fe88b17d55c621c569a177cf3c686b959d220818261da7c10fdd2f3e609fdc569fc05896065852743c3fe4d458cc6549bfb7da2faab85a07bbe144a99a26f05d08ccae320138c5af639fadd919bde2f9f16498fa6d45ae6d4f945db5e722dfe2ba2b93ee41052e71a09e3179e294caf570611757c2ba692447df9ac6ed9aa961092d884f82888ce632671c7f35b3be7909f73e8bbca3ec842ff881e41123ef2fc16a7dde95e8cef474d6e7898de67379e44d86b9a90765722eb7ef3ee3cc78d99c0a578c970d49e2a4c5a8c207b4c19e7f1f97de4aa0db38af78df158b709b95bbb53a80a2e44d06babb90b771df57c32649e38db4d263dc721b72220b158a476bceb4445e35896a4ac09f299774b046c57508fc0108e4d2a5a233ddce4ae345e52cd6a67d979b4062be801aac99c081dc8a133e9e42e6cd365689467c01248e2f58fbffb9df2717e48352cc7e90b127735a1ed3eca89eeddfa76acc3127365ab1c4a0fe38f9bbb3a01255e6209d518b48648298946ae1b44f8d1505b1791cbdb209b073f61122d3fbe5b0ceec54d461f9ac3d90c540eb680bc27f7286076ce82f7d49eb98c3c9c1e054ddbf145e28dbdcf0f20181f1e5393dd2cb02046a781b5e27dd142ca91c20a6fadf6610cd13acb70172928407eb139be499775845f725a24c39d4d33dbe279e1bb41f33955463e1f2abb1c4577f4804b81fd4512b9e088b394b9feca29dedd88cf4579bb07b652a752155559235973b41cc34505e238dc799c32eee8ea93dd691485b404aa4d4eaef201742c737af2046d232932017b89bec666de377e5bb8add15400173963a8697190a8b0879608d3063113ee94d4be0bdaff5926bf45e28aa3c4df1a351b1e48679bfb602433927c12d5adbfea6b2e0331f5c0b4275461beadd0347ea36cb9ea527b45b441848e9f37a1d1fe500dbeb00244ea43c9e172f3cd8706585956bbf01c658eb5e10d53910eaccf65efe5256598c8239341d0c53f585d949c352544d82fe358dfdab0b43b81b1b36b247c24bbd6830278f857e950ba918fecdd8c7e1fb67d2def6caa9483e99c966739a00df2d28292e00076a4449c6994272c24b28e0f1a821bf42607dcae888b7f0b7680698670538f346e0d4634f4bde66d8febde9f61127dee449ba3fe3d6afa56fdbb18653f86f96204027c978164602b30eaafc5b2f8eafe967dc2d4b5451229d3f366b4c6def8cc329a1357c5abb611e3a7ac050d36d16bbf08abf236923ee1257e499e48728c67a3c9e7971e84136c3d6ad6cfd2a037a422948addf12ec799d073bccca88e2fde69e7ea332c92a459720c6e6809e46f55da48ae34a99d848fa456aee55befe54c333a861cf80b44d4d99763a6ba99f828991fe6263dd61fc89d36f968619cb2358ac9fb1bdbfe96c7c43837521111222b7c3eab74dfcc1ae90a582e99e88f1b5dda47ef0c8503027051689bdb6ac8f9e8eb29400ab282cff4f443fb867fdbcbadf80e79465c5d612edec003f8f9356bc5cdeae6ae89f1c60589bbdd63d95ad940d1c08ba5726f6352c53b2ea84d7c36390db438675a22f94a67121c296296243c6614776b2d8366a10212ddb1de2feb2f75b93c245c0f6946bfe51e6df30fdb5355a9f24ca073f34520b197e9464b39ae9afbb5a808cd5e2c99ca95438449ff835be17bb40ab9f5843540f496885309c3ff61cbf2988f702d4549f548bde3ed83e6e8a149248578c1ce2b64b94c9f84a0a34b77e6af75eb907796e47e98b96ce17c1708407945f11eb41727aa275df05a3a8e6866c026ccc4f72077f4eb182fa9a5852def87fae8562be8c7f0671e96430d1c3ea3905aceda4f038309eedfb17ef5c986d7d9f216a1719b847603e4c38e70c50c297ef942270ebefe0824e242cac16bc4b1ff6429bc6937b5804e4b64004a7476a9b6d57f0dc5ced6291c8bf703ed2e60396de8dd3f701633c84edff9959bf2a3a020a5b9c4823bc94237910fc77e7c9a361dcc43a8599a45c69810e449288d313835eefb87fe1e8da55bb4b5a95f1a097b6e7f7f4a47ebb5bd3c02242f664cb58212523dc380f22955f84585a894b303effe25c16db2db7760a0d6fd253bb41d3c9779177c8e7cf758cd61db076758f8e8da196af780b42460df8f7dd8bdd6fbef3722fa0fd74516102e54509e1697e8259fc1c057f7b8680fbf28699d2bb6ec3279784483eadc8dc9365fdabc897d92680bb17b56d9e380191fb6966c9dd71552590368487c30f576aba9005b66e4d0e9c50731064b60dce2316b1186404a8f774429e300660c8d85e1e456c380d3cbee403456451e923ae47a2313a8d113bb6c7415a06224117bf30008a9f292575f856fc9676d0ab967cea19398350616796b86865f7f5a27429d4cc5cb7cffb095079e7c66d0743ecbfe951effb63570b4f4beae1d2882299303f186cbb8f977f3fd143b082425439e57260dacfd31ab171473e0cb3c54c48f964770fc284fc03218562bd688c43ab33a42389200e92d284479edb6bc3ee941cc7d812b30d6cf3c8e05d1576328777bd71cf0ad5846ed6034c8a8b5204ce4ac3960a55d2e5826b52391aee0bb931c7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
