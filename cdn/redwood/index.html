<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5d3376f0964762235069b44cec6c6d44203aba085ca43f37bb63354b02776244254c025cc7be1a1920546c1d548d75995c2091416c12b8676f585d83acac308e698e4cc6b6c16f96852dc935e93c28862017fe92b6bc8d6d16b304c4a4bf09a13eb227d9bc3e415d8a5b201785b6f87df9e205d37061691a3069db6c2a21445652a908ddfefe8f598e8303a021f130fb22301b188f02c10fc39b91f9b2058d7ebd0941a0597a22a5d5b1a4f80bc2b92fe6b4f063bf210ce5e969a13377b03e1351845a9130d5ba0e1d43bc54ecd49c854bb825533f1aa9a4b14f7ee35f9ad3441abd4fb5e0e76570c76bc4c52052d6e2574cb832182138df3da854b7a84379583bee2660a7f1ad8cad2b0d99664918830d59a780f02a254f61dba1dd03fdb4177b99fdcac6e8425d2da1dbcc87b565d36ed31b834f721da287d5fc536b1bedf650a1eada8fcb2d799f2b4ebe1fc2b29445431026a5f18ab5f3f54e2a5b8c009f6576ec0ddca2df03a0afd0b49e58bd9ec6a65adb16ee6025559799830510fbb2049700f1cf32b2b028d290742e0d1696c01a1e201362b5560f8ab282d84e245ca5661b9235c4b9c3e15a3a03e214ecefb7679f8371f27055f6447e3ee4ff3307263f6a80572a98faa0de3bcc026c95a3cf2cbebf31b05844876127c49cc348a6c5510f279529ee8a4a2908eb646b1e4a9c8776ee5ac9c3dac1e2fce7f1cfa16cffc8468bc455b0c0ffa81b5dedc68fb4abe4cdad14728db27da3d97e4e535f44fa089fc93616a25e6bd72bc1ecf47a0af8be55b564be73ebe6a0b8d0d12af24c639a5f5f009d61218620eba26282295dd7aed907596e4b6a5e8fefc0d2895a8aa986cf49d5a7ca93fc7c53831e52f7f01c1f83f110a12757f616a595143a2ba454f2ea40ed3b5a7412247422843de2377e55c933f8f9daeda8e358378e0fd1c7091e1be69e876b9fb5e102bcd4f0febd601b656cc39ec9e4148a55ff975a95eb750445a9745157d1a0f90b9ad5fefdd1f476f6646ae583fd06e04180c4b4e8647e646abd549e97cb231e8cbfc0922a43005077791d87452724402bd6d9e26754a8d03530d98d65ff48a8e550c87b073107bf09e463fd32516d258acc89bd9a83507baeff80548dbfdba31bf954d97f7de6f76d438602f464dc03afb8264fa9780ece854b046f27401d7bc4fcee5fe351a6cd095324d066f59bbbf28ebf1ddc94557304f41d6a6c30c14464b5378b5c4e640fe2efe7728bab513998643c86e705897dc3e4c9878e27e8c17c0d35fe2e0cef95e13c69515c1644a118b0c24b529a9d626a9536c7ef0a7b09f6e51e63c0be9e529c9e03431f660d909eef178179af0245889d2b3f1d5566ce3740f396626e949bbe4f38f5c7341524a935f87a0d95c098fccf2be8c3156dca485703bd2ca0ecf9eaf8907a0bd9f194fa5193ac5178bc6a3fa34c013e17f7feaef35180ffd0e05e509ea259f4353bd1180adbc53194ca733e014a897daa8ee442bbc23d0d42623979c0858dc1e477eec4defc2164221ce5ad6cd093f828fd4394f7d59077d0fd8a33b7e5e9542a6fa0743cce080af158291b75ddafbb79fdbdcfe61e8c5ce4807c8e75cdd9e2dc17b2813cd2567532bc42819943428db60fcbcb8fdfc44b47c337ebd40e0f2ffcaba99f9d29eae0496f1ae688a5816622bae5be2cbe554b81b57669fcf79ca05cee382cdac9deaccf7da2e6f5479fbb61bfaf4bd4efb7b03e7edd0b0532ab5aa44db44284aef579f43362974688da90ba0e14a78a49f8fcb846e905cc17dbd4b72ef291dfac8414326d8a71c83d7f45e5495d543098095e8a3b21f2228a2f4468ac3b742393f5fce2d38caee2b4fbf72a1ea922bff81af13422baafad9c83c03c153dc4456e5efce662bf9a14ea8ecc8f32a0774d407b6944314c6b7c1900c889bda2dce23818670bf0fe42d22251afab8236525bd706efed8074fa598280135700e55449d3f5e3bf6bbee7ed402e5e361a193b54bc72dc816e37366d7a132aade568400952fad435cd0edbe776627b1272b3c0ed3c24d0f63f8a95166268302204dcb4c2b5d0e720d652819095a1fa57639cddde34c5e0a976f7dc89eb09836d73f538ccb034d5540a951ac9e4928122d650468ff56a061ee0eeb94df0018770a881d98749c92fd42421b055b77c3b78b6329c89b2bf5884c6166280f0b5ab1e9007ec3780070d5ffe8d0a3d0f3809b274c2418de2499d155e18027f4f29e62b5ecf66a1b385e25c56cad59b90f6844eb38ab60a469b9c3a0985fb961fbd45f89ddb877c7bbc25ec5558508ec06f87e14e703cfc52bfc7f69f4864258993c158e4a57cef12b7acee444b1d008864b26090e8a3b30953ba7f8e022d3ca0e6fd53a00e2db4ab7b4ae84a8291a23d08e545fadad6695b6e5629a8c98d3576dceed1aa5e5f2884231c78005e2bfe9f358b1158f9c218d44ec7919dbe7e7166612e8333a41ce596032fef35748dde075d33a499c067048815495e5daa501402c35e83aea2f8ccd225abd88e82f559b5f06bc41a79e44fdfbda84a598269a9f88ccde232a7657ae209005dcdf3a96854001938dd5d662e845194c27dcc59f641fc8752061c6fa2fc8443744880adb2034207496ce9fc81e5b5e10be0a9260d2921da972756ab258e3cf2bb5865efc650b2ac162744b49581c290bafd44743234cb981fdfd8a684aa9f860cbf767f5409cafc4cec534461e6c4553654f2ffaf0eeac96246b57abc47b63f56e2176c8b3099ee4b1442a0e88dbc25ea7fed086cd98a3c4a7eb2fec07884595d4bcab0ab77dfb4abec76c47baeefda9776611f0dd8c0544da3179b4b1fe586f4f3cf60006f2294a46aac47b69e9a378d2400a348a51a47177d4338944c7355daa96a24cceccd928938d37960c0da535d913fbe5039adaad776bfe1ddf7db18038eeda2826d9d181dfdbf6d8426ccf87253b3da666b84d198de329a27ae0ca78edc808ba3e5e019671cc9e1555bd18d851b7ec76951945482efbb5a546ab3a5fe1b1672ce8a6ccad6f057e495e6a27994d135c831088d14a6d3a886add2005b8602d72ffe51a17c1cf105c87425a7390f0daebea518845427b4d23a693a021b86abf8c0e3fae956ce490667bfa9c99c6f402fd67e9ad2f60f63b4039ea621535a9656bf79b1857282025927b00593bb9e0fe4421cb0326214f8ce6c53f8b4f11ccd89e60f3c45e1d42616464c8b6d7b6b0c7e4d454c288f11e0b81ef09819741c19931ac57e023b150dab37cc6c5772ac75c4a7258c30e3c61b7fd5c9d5951e3022d788c2964579e897a8ffdf26a4dc039612bcff134b13fe1f9be51df29e554253a11e54d0573bc233ac69db764a95dc8ab1caa9f7366ca99498da17dfcbc05c98dfa8da05007f48bec9f905620e7726242075a0c86f38b94d9e35778b1f8e1a871a2412202e66cd309feb537b36586c3778dfa540bc5421dae035da04d919d605ec18f01ae9fffdc3d775a6958e6ed3d49dd993d84b646188f251795ac14896342dc1cd4fb0188921a70bf44d7b32e7a0462bb5d25c26b9c253277648faa46c1f1e99294d6076b3ef7534189dd33ff1d76e63065205b02a963c327d5dcb84af5d1d47d4b8bf659cf19eabbb9f7bf562497c7f6976e38b3c53981c2824ccd08909a4671c4e9584251507af9b2bc8b26088d5df65f41d9f6d03c8c3c5a4568b28a2df69c8e35f60461ac6f830ec94adc40a17ba1802951dd6283b5a0b63ff97e10a152fd90b80cc5446de59f71102db4fed8761c81f355becb628013856b67ceeabd99b34160b7067ad31bf8ec147ffc79a99908634d1e54a0d97d3a2360251240dac5d20b1db7db382d08732d45df309c02351ae8289a3d94c67d11b6959290f1b6646aaf19e76ef332c73792ed088b6437a18bf5d11c69b59098fee7c13b43be2bd796f0d537929210c4c88394b482f46abdd5d84daa08384eeb7ec1a5404c5f2cbc27974890d528e9740b77ee8b4da34bd316f81201244d4f79d859cda695a59dd7231671999a898b077ef80df782ef2e144da33d6b814148f3ef5e0b506a2ae58dd1396bf123cff066c06f2ffc2b5b888bdd2d20a7d238908f0caf098a024cc2c5f6c4c73b28cabd8a6532b28961b71be496a73c5a5532df4645b84a75ca86936ed72e762f4970c402ee476771b7de7cb481fb54aaa7a9494df83d3ac4bba0f93fc15920adda23e35468995213dafc88af76a623533415c60978342bbd330c66ac291a473e9490e83722fe5a17bcd74ada88cad32c9353d8bde7fe1a8fa95c03b9180191d0112d0350af262f370a067bfb2e1bb9373ed9d610c8d9027d40628450b6792be368dab775c584003161fab487482d07a3e5961df567cd73b337d9a6a17334fae5dca05809e4cce2ca543921679e5615433c3376e9528d87e0807331ac26c92d0aec2f3b5bdc6d7463629c2ba23aec74886f7cde552c4040958625eac0e662c20ba6fd0dc0a0016ab201db22670e8e516578327416c2613e520460e9874d754f22516405fe931a22169467252e9e676a19222fc8f9ef3e8d7ba70c5ca224142e2ee5fff6b227ed46a8dcae9f005254dc98f134b8d91c5d866751000d0898ffeb1413019cee93b00b696594eab5d4e7d5767a2f80d04eb72a1865ddac27fa54baba2d250e20aeb188e00850e534ad8d9fd1e58ddb1f20e54d51ad63c49b60f998588714b0f4260690f18e086c11d28a963a052c5722bc6d2500f709e6f6bc9fa9077b869930ec8f4cfe571ca6f8dd4e4c421b0128550fcc27ed1f420e452754dcb82486ed987b78b0f2a5b7798d57cc0967f8f6c324e018782cda5795340d69ea6bb5aa7a2d889925a74f7360ae67b367812d1debbdb14b4a52d2248bdc31d60c1022de25d42b18efb001644335d84babeed75f932265caad971ad8551f13a4e8ee8506751638d2d9e3ab145ae185fb646ac116d06f49cd0754d87b6e0e099898d84e9e8ad5015a83b45bc721e12c66f0e524fcd68455e2f8045c6658921a31bd342164a6f8f1c4db4f3910432b491001095f11b2e2e4bdf770b1943d1dae63f934357cc86aa2afa7d519e0bd6e804672671ef7e54e2b2953d72b2bfeddcacd7aff0729924fa137ba4b01a9bafeb5cafd0946509c5b0e89ea1708f1c1407ddde62cc3dd0addef0151f9490ccca010ec34f6f96cb8b0dd6f5e8c4c0aa9ecac2d4717cc344f98aad2195712c9b3456e7ea90556cee2710e7217150d71a04373861b426382ad4a53515c0f14d537f4dd57ba84eef9fc3b2ad3f557b12bb3d765331cdb08970fad4217f55353947e1e67a0dbc223e28543153e4c8400f531c8c1a5e6788b018899c00e23995b7031e1de8b9acff49a690c612ff97de61f75dabde0ca9c57e60701e1673c618de735ea848832fcdfb2d602d8ce9e5f11b0b5ae8d22cab7f0e5d5ba7de7edede130c17ce4f96fc4e71700254429ed4e546f76dd9f78e909425ac65e10cc8a4bf25b83abbbcc3f4ebd6d1228116cdbe072dffdbef0e5229e1361cdd19abaa13251a9490b50ef6ce131a4944ce8d507d11a33cedc8fb850479ab24809a2ece1b4bb840b5942a06d80c5410add7107d78d6a19b3dca35b42303ce6ed298523c29c7e9da3c9db1d07f5d0d44f8ab3edd2ec0b0e25e0e20b39cabb5fecc0f56a443b9805deb5c17048b8c83db03f3c2fbd55121500049c34ab8057bfcb945cb516a7671fd3238b89228d6510969c99702901aed49c50f10efc52af06556aa69e27ecde309c837140d24d9d67b5aef397019ab4f2d504ab3d62e7ca47e1dfebca86130dbb3cde913e4a6b07999f95ef487e8ec24392734c057fa29a21649161e5ca407a19f03ba08f3961b391250c552076f87fcf816933f5ded213a8c6de57d6cd244f077c2b53e26ea9cfd0a6696be15ed55fcd04c121891cf099d5b25d1efdedc3eb325f5e0e0e53f4723d8c77932fbf9de672815b08d22746b259525addbe471f5cee0be68a0368b7fdf3ce31769645c5329ed7bcef31ab73bbd7c31f641a10f7e70022f304ff6cadd56446cc2c44f590bc599a2df262fc8d33759cd6215b5527a24497d332f669c8d4133ddfaf9fe4f34def498aa11dfb970f2f3e55128375bf2f2b19660a421c132ea6f188c986145174470bec54a2054c17a1574b17a8958b0d2c0eb2842eb25a107cc9095d025c4ede19a4f93ac4fc9b301c7e76491e1a87987d2e80a368a6aaf92d197ac57741553877d006df3e220db4b46d69f7239a058ef6459a0368dbde71f4e7d119d23849a5df6bd360d93d305b6641ebde39f2e569938149ee79c12f79db58eb488bf62158dfb7c2c497f105a58db14d12d44396937b75d54407820b92a4b678abb35351c61b8d0015d576b7ad9e4155c37280fce79075c347edbb2973a7992092bdf859b5b8133e106856220d206280b5cfe89335c58d7cfcc318eaba2f82503365e5a9b83a4cdbd3ec40283cb8866b6213dce7af7da9eb1578e1cc148d408d28c4ff26d5027093a450bb8912a398c3ca607b30421973f1844f4a102283a7f10fd571bc337bb9fa34e4ce6ea3fbb19d62605d3698ec56512042f97aac69afbe16303c4ce9a4567fc088e7302213e509c5faffc05b16ee7f2d1e95846988c0ef2c4384b4af31bddf1ed6fdf9768363b368c8c64e88ffb33aa55370686b8f563044394e148e54b260147e98af702f51fa3617140a5105643fdafdaa18fb8933f2e0dd569943bea6f006155362675b8e4cc274099a02958c6696efda0edaa98b66d15fd849ec4cc865ece2c3a6a0e34f1d2203e39c773f6fb2d71fc1bcd304932a19d16b2281412c3afa5c307996d55b8cf46b842fff6c0146783439037784bcb6998b06424b74938058621594bb0f8dbd332448e08774eec810be33e6969ba7050e5dc8331cfa14faf900f14a9581e330b95819963416fb973c402a8c404c2c525423e9ac3cedb137ce4285523a51405c6903a372e6f438dfd04ebc871511c94bce83fd9b53146338873884ac9bd4c34d38b8f78fdf626aa9dfdf11230e32e5e0bb33123c17637ef1b1240c76113feac928c9339dc2bd3f60848e23f0f5b3305bf079bebebd6c0755703a03d1b1ce114750c9e2ffc9b3749d7e9e73d57e0ea674e4c6438b8c059fe31f00553f1926b1ec9ad825a0236ddddb9bc3342d850ea7b9b0d6d6f35011037a1e1ed206cd6dc3088ee04da57774489cc96f4829dc935da5d5eadb0854495302027d16d177eda4fc339240fb547f5c600bfbcff1363c88e22b27cfcb4121ba93f5ccb1a450e556d4c880e178e308ac3216afd3aca63b3354a2189872529d32aeb15860b229fb03c3fa0c32da4264169c6f1df4f41e3cf5775238ee6f55fc1667d3ac008eb5dcdb68976582a81749d726f41e8040b7b95edc1a4649b2fc9bf442b69ee5079fea3fd6ffb976ce1cc1392020c2284c044f9ce3aee76732989bac0a28a0caceca57dedf402583f848b4ea611b75339cd426758808e72c68d5369dbc2d9b40b4cc351c94ef7e70d8f98c84a200ff46026d7237054bb4f8ce618e8f6480e70b0e5f23559ff7ff3b8facfb943e4630479e3c10dd8175838a8293e681cf325fab0299cb97116f4f5fbfeedfef9ce0af8a77ff7cbfa2691c06ccc4148cef241fa2f4382c212d513608a2160de546efb232e5745b82af6784f88a72c485752fefc0fc940e7f6f4a64036b2f0302c5d063ceb7b8c68e3cc6b368c86c5c80a97868f722de81e0ccb22852aaa66d9d54b8e837f009964b7a37d10a6469c264727d010418b90efefae326a88d1ddc10ce8821f87a491ee42f4b43333e8ad9fe93befd4a659753bd90db3b7b0421a93203463ece6586db2178fdae80ac027b37aef5acea73483549a43e1b401d2afbf8fa4eb5dfd03ee323e098b9b675ca4db59dd597d0112603d0712a2996028b8d4c63f14512d9c1bbd73973de65934ccd07fca8fbc5a1b2bfe2408660f43db69ca4b4d9fbc580a3e506fb57f9f5249ca707bee3904fc9a4cecb246f108f1862d39c952ed840de0c95841e23ea33c04dbdf460c4b70505049c9a19491830520661e5de433aeca2125015e18ff3ff7ca0d25508c5f5a19cbe9eda156eeae260b13ff705399f03f5ce093de57df3e728bf31cf3206c5bde51eeb53394a288d773a7b22f0afab3dba7140d7e709794ed03941c2380d214659ce05187b6eca3b8f5e4e13d04c1c9260221e154b6ffedcd2f360cd4f86757e5d7b25b6be3fa0de81fe9f04da8c1dd266f79ccf626fcfc01e20956cb01ff9e76d1a7a9d928f7fe8cf434e5408706466e9a5e8359109223f76897c2d70c1bd5eb922969bb47a85d3f70babd6425427064ad6bb716c9a535b91d018f4af176ff129c14c448a3ee0affb1609c93bd97b96a98db496d5058757eacd2bd53df147e5003d118925fb74e5bf88994d5cca58d8b6e194bccd31099ebc1d6fc647a4506cec0e428e4e92f20c04a27a4993386e4d25c26f9b39ef7621f7a81714123e5baf955430e589e013a4f06dfef244a70dc3a64654ca179f12bcdf443c873c081bb68f9ef25e105d523db1146949f8cfc3ab065c1bde8bfa690f1214666d989e54181afa619835fa9fb5b176049403f9b9cb8f07625db98505a02233808067d029300de787f7ea08b66e49bcd80dfa71d5b0dac47e250c3c6f41f9dba7c635b29ceb71d2df9525b58b303cb01d1db8a6d55a56c7c00ed58dbdef8712f22854aba5f3048501231607a352bb197e2ab11fec47c6203e68d98277496cc329bf242af5b8e79167ddab0ff4a144b128d1c46eb66920e62ac88a5bd28e8d9f5a2ad829ff06950222ae813cb5cff23b295a3729c867e5aa7de9dec5a5884f35901e42340180938d323bd6eb5f9b46a9e32a9666e8eb495004f0935db8326c52a4738f9a9a6ae7a262dc5631c27c93c8a82616820c19799addc1ee5145c0f19edcd8c52d8e2e1829a131a583b36193164e91e9972893552ba65deeadce4a5d93a54ef184da257dcef3afc9d15fa16448256577c0e371e9f0677b54a750bfb52d37eb7ffab0c32be5945d560779f0b7ce7f0d0d884bfc0051978703247fa044e7fd133b83580c76ebd4d0c37d1ea71469aa75a7dd8f196ecd399627ba86c3ec50e24e0982fa4018a95e5235e47b643c584d8e7f6ddea9b4c3df48f8e31e2d65ceb7b6b75a96fe99d9a0c9e0aecf93069f89e4fcc8df71d0314bea69401b47cd566c443d64bde5b36db185c84f41f9db24eaed1e1727590e39c3f40338438b00d1c97369a74cbbb33538c8182b723109d7fb4be791eb2ff59840e6bdf5812381a47974b46fcaaf620b3af1d0057d47afd8c9cfc293c04ec1ba0ee2158e602399048a0656fed1b242b4332feac1fc2e9ca6345396cdfb1476a89f88a0edcbacfab428f8a7e83dc128602aeda1d2d251a9c6730d357d52f3f272ddd8c0d17f21eca013a5287963ca5aef3e146182f839808c80f7bbffe7538832fa931ffb64016f06af9526c15b1db05673b06d9ec9f09e12813f457c3c0c776f856fc352eaa21d274119678a83c9ae33aca8f725fca31910e4bed97eb4f0e3677417efbc3a5de089596a2be3723b71a6ca632c195eb277af9a169da21a48a8828c915145402c0de633e773ce0e15834c4a28deeda8ab31e05ada2bdca58355480373bab5566e2a4c5a26475b8e55adc9ef456a237e1bebb069fce739d0db0d7eba4c150bfdc42c49f956f372ee8511715a6729a60cfbc0b6d41b0d7804a6970d81f272c39637991c6e53378aebde90c373e71841af5e75b5dc2683480ea843fd64759c5bc4151805fb75009588d1956446d9bec5e0c270fad55f68802e35f56e93401e212be8a3d40a6e0bc19cf6d3772e1a3fafe7875cc2f85273e82e3c8e8a34f1642a5d8a3cc59e192e7b3235ad93de492b904b376cc6f8e436ed73d5f3d98ef49f4cae46f1a0733247d515035884eae31ada4256f3fd34eeefee601b8405a038e222be86f4c0e8bed75f2c4386022a5dbeb441eb5113a132c4a69ce18a0a49add46598ebb4990243b465a3da03852e5a272d38384a0224f03fdc43e61df30cbb2f12a605aebb9468a1c5a2ee6ed7a162d15322e8c762d621200eec8218f68c0e890042cfc8bc97552ca751f09ffab80bfc991f76203dffcacf743574662693bc3dfb9349676dfd92f2ecae0c6b8d7bcba6bc185be02add52ac99c8a5b706f0e1934687c52e4a34baba6dbd59d9016ed707b108e81b20ced1ccee345e80e7f34400ccd6cbfa2181b0dceadf47b8058d9c0fb5f5778b93e90c5faadf13b5fb17047bf3e2c1246194b623e678afcc6aeadf97b43f22606d08cec74d3e2c93a4234184022ebf462b7e8b2593b09a0bbfb29212c1ce6040fc6a11075763ad7b78169fa8871b546730a975f3e5de633c8aa104cfdfde6f4ae296cb5df0de49273b86a634267e8b1eb43e077caaa380a0b14646e4fdea05488f7f842e053d600b92a246a6d0d0a5e176009f26a18f851e07dcef5c06058e1c537ff63f22b7dc9f72735e1d63a2cfbe7fd0ce3cdee9b357c8f936de4916770757c3a0bded2d161761a9acc45100d06efbd27d1e18762a6e5f35da33cbda15917bab692d8622fa6a32e41216656b56068ac3c4f6ec3a2ac8a089454b9dcd9a6668b8f3b1ce58c8eb6cf4c83654c5a803cb2217ff9cd2926581c21012e60af2df28e90baaf47029b94dda13dd22c0721e68f91c3e134481e8269e4cabcd6979cfaf2169be1595f30a234694bd063066cd3dedb01a0ca1ef24f6b6f73838a9ac8904c3d757fd5d030f9ae5d0678fa228b6ea9f05ea08e7e7b347e34961a193973e24d7cd5d3ec5b0778e6dab506db8c5e3c988f8e14764ffde0183f1191fab3ebfbef87168e901794124ae5fbab7143f44a65e8a5e4071c859e14651e109020f4cfa36952c349d89411fb874c85ada98fa79146a778d95a807904d7149e215ceae5feda4438904194277c581d0ac4794682fa789cf91fd0804d561196d6352bddabfe73bf2c1efde32a5eb9abbafba60eceb24ea4f00a49f040569cb86d2a9959f42de322f32d6639cab66a5360451b86715c6fb0a0d70a240851191efb0190592d70a6c15871c9b8cb1ee11dc15d639e87c1586945fbc68ffcf99fe16b920b4717b9cad57b69e201fb50ebfe3ba4330987307b871c8cd5576c87f7ed6ce955f93c4ac80c4b881233f423abc80767300910dfb1062080cf30c40be00bd8d634d46f2868fd5e1d6f0d8d36798052ec5c89eb4559a1792de329c197ca7bb8ac713ec33c12e6835469fc0dcf6f303e847aed4258491c977a3918de14a63e7e31a789b268e1153cd6544b847147eb044d9df8b600981adb5203856008b2bf0a9535313e92fd32f1ae4c0a15df0c399862c52f6ce9eaf755bfc411714f2e33975cbd3c77bcf53d532e86e8c7406dee3e80bc88e691779addf3d7573906089e2a17c0859b0ef643404092198b68aa726a64e5c46ddd45ee931e182c73aa90913dda53fc0a1a8309abfa7a10e344f458f81cc32eb711dd9b6d87b594859c60bea1f6842c9834e28e116d44bd18dba6c85a4f79bc3768147e9557b95030b5ebdc6c0abde1b4547188d2b0aff28847d5ff1c9b514695c87875ed6cbd534d0bebb2a264328d309acfc751f054624ed03fced7f6ebdf354c46362cf6185853d0be70f402967162fdcfcba31a40de512a21c4d4f2ede13e7ead3cf4c38bd2af7daf20143caaa21eaea6eaed5fec9ca528fca64d2d393a0d11370c017d4b3dd36106155171e000823c7ccd76c2dc5c5045685ca54324da5c1d2e8c7db156b6f7faafbf8e041730bd56ec4c886f5c036ec8f96e05c593a562992d4b67f6ace08cf728bc912a15223f9e1522305bbd0b90701c9f703d6b9f34a4c6b56ab2317f017a9a436fdf915766a1ab79d9bbb007c4d837e855b170c1b3582e01708881ea5337024f93f96303c2921f67b04a7070ff5a1c3b2344de3c7a9c9eaa4da715e7c7e3b0cc68ef590ad75585b2766a9bfef3bffffe82fe291d9f65173582269df425a3e2e79650b4080320cbc49c52a22e03e9b4b9d28595a365b1547fd6ac3de300f9953c5eb93150b5dc14e7274275f0ef05ca8d218352e1b3d46f0ff4bd0b5fcdc4cb4935de9d7e4e93d6b42771fb5f59e951b69866c41642072e32e819d048510e071bc759003cd3c63e6f47f7d66115b74330a70657464e02f7d5c258b957f67b41555a7df4ab4992e85a30a6486a4a6ae0e5739f76744693b017cb8f34de838078de16e6a9fa4d850d9f36ded99ce0724a67781a374af3c8154f4c21694b0f015e984805b79b61618082bfbf5ac2d465c85f040753b331f9bdc01769b124958738165e3a347aca8c4c12fb8d746d39958d2aab89b138db2efe4802728413aebaca3e06dc7749612db884d20302cd280cb4fabb46ed2428a17da29611eae24d06b04d6b3d5370e72eb2736c052bd91edd95cbbb8301e49cdaf4a9e1b27083ee8ce678b113a2e01c5c1cad1feb619cf4daed781eea24a5ff46a5dc11b4d83cbd772c9f79e94380115d1844949947da0e58813c5ecef17554313bbebed1035310b620173497dfd1f622fa154a6240fcc67c9e424e5a3d5472916ed52af8a6e063b717cfa854502ae862fe284440a02dc2a79042dea7efb83e06d7451ffea63fc8f38bf3962051f7136bc896a8d1035ea117d3f0c0b1dde92911e9167da888a7f1e36979516b9de395f66206229f70a19591984ef09fe2fe1a33257fd12abb5f58691e4979c6ad2ca6453b2259174cdd5f689e5221eb5bc74836d4ee263b52e6f0ef9d78b6d9bc094a0f5845cfbb75f791330fdde58a73fd1deb3738f1635f953468d46f018d35631ea2b3049ae9a10f58106a0771cddb8812c070a1289f83457f1c6f9068fd3ba156e5b741ce085d7c38d6ea534f8340ef11dfbb1e1b9720787570b435636cd74fe591972d88fc73871ad43044b78d1fce5e34298581e039ede3367ad8e1e260645a8a33964a1b23fed8ca4d20687639fd25819132340f0248df506d2f244f6bf7ba734d564e2719336cc06b3ab6865a4e9ecbca787150156a36be519769cc63fdaf56998609484ed2ab617dae756f201bef44a69e290ee8cabdc420f527e78938893038e87de785b819818464d7ed5443d03ecac07246bc79f5570f01a61617c79a988f16bb26676c1182e9e1e1d5609b752fb1d01ac7ee0b1384d07e173bc31ff16e67da56a83f21f5bb9918213323700c753158b79cc499dc1fb08da4085b91b96f4f887d598585c8ef85573848c77de3119b2922a32a44b1dc1426148a7fc9b525624b79652c8fc234572de4f7be8d2010d3c8b12eabbe2de37c532f8658c293c31bac6c6a65880b2626840bb859826fd74a71b16f3f468b6617df3dc1fdcb414b4f9ce1d0647866c2d8e003bc25f4148753390551e52851a536ced8b02e61ebc5254740a11fd8900024e40dd6c158acea5cc397b8d4e1de9b3e49128f38e0b877d96de1be66b08041d7a11563f4151be2b1f27ae370efc5dc001e1bd690142d65a738f918d2fbd2ea9151cbdbfe7892abfadeb9dda74d3af95fd055db6fea37a7f06d2fbf624804e3179117d9dc3f35ef872ae766c04b118f523fedb869c6dc93b1c73ee857cb62511d2c439009c66acc33a26e4ba8221dd1b451a22ddf330a050bb0ea03dce6a31e26f1a22232b562c69b95c4f1a5ea7d612d65a8ed87f991eb6a15eb5e6cbd8f55ec8bad3693c6485eb8d1b33644cbbb90c7de1dcae4e9da82237e2160268f8bb3dced9a47fd1a6d2ccdfe0287615dcd47f1ceb9f7f8fbeec6f61f67376a81d7b598b0ad1cb092e4df195ae63d7f83553d52fb7ed24c09f72a5d3b6aaad130474f9df3008b9abfc68a0ea3d1c43abc5684147197bd4fc8f1ad2a60b74efdd472913a7fbf9978cfe821900b6c5dece4dbc8332b21b63c0bedeb767e15fff3cb508a6cb7f4ab6de6e4d65646dad2d6ac31a640556ef3b528a6e08de26812180968003d11616c7aea446aa6129a98d2e971dd35e12810b633c1423dd59dc091e97a84ac6d06f15d1637d63547bc5405e69f86158c73d264ee2a9acd0681dea25d189706f4b6cf060d159daa1c072f5d69b9399b57e29d08ae04a1118239cdfb6290746cc1efb23d2ced6f54fbc7dba5e1fcc1e1182a0445d14159c628bb7829e156053ec3abed75c7266b6d21525f632627fb237865dc5c79de7d282be9062bbc3f8ac8162de4c1ebf0c9156cce6a489c0ea3b80b6731914f716cca741ccbc5d4b888fa13441ff7ed98d6893e8adfbf5f451e148d44bcd6ffd361e5a65c745e47bfa248ea061961f1d14548ebfb61c53fd4352c9e6e5e2840f79ed67e6733fc191ccdd0cf59c0d1acf488603cde072d788c3d35bbef0ec4b0706bcd7fcae35fa954c8e8ecede4abe7d0eec62a17266e19fa85392e8bb0c455d9df233722af31f61a8e0a6b9d8029821193dd455f093ec4b5340714c95a4d97523f2b8160af064bcf40e39550e2e80c45b86614366a567b7e4e4885451d5002221e24a19abeda1e31e0e183053b5ff3b47f457b6cccebfdfdb4bcf8fee2614d75b7e6917b89dfd35c7247a81500164942446a26d0efefe812efd6df42ddec242d90f8b1171fe22ab788f1aec11b6bd0fa5c77d009466ee652338340a3c72073c480fe285a064095b1ce04e7be217101dddeff7ef22952d28849737d9fee9f4233dd308f0e43ce9e4ea7364b23ea46d6115275851a4b62cd31a12991f32544a56d0a1d765921ffdbbd7c3b5fb66a420f15b86e8d4d3d7667f5f42ef1878e7e8c00e97bc21818bd2c21266c64690b5e4154d4041765333d79a66a90078d1a77b65e8d355e3d6d3d37061fd01d393b0566cd5680afc5a20d591081ccbf7e185765d3ea67ad8b6ec3686024f2a4fd2693bf2d8829c589537b89f0f3da337359c5884b9396ee86366228b84f284f185a7eb73349f1b8e29532cb892a445579891a895848ed03e018c88e14ec139ec54f57fd338c5acb790eebe3418c70873d2af8ca0b7dbd9cc7882c664bc792a3afab63673034ac1df306eafdf64e4e13e4fe1b4d5512d4b12e55fa50c773196e602a7220696e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
