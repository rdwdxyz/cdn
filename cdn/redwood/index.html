<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"de7d2098fdf4c6b383a55275ba40ba5c2417bdc37e536646794dab0641f13636d914e9c9f816caeb40f0fe716c4a22d219e69d02dcecf34f24c5668e05789b74f40acedcc7128e502bb094c30a160743818db4d33ccb9008c46e2eff669590119429f641d239e94ee9dca0b90f90030635538c46d31593830f55886268fb8fa8b03d5a95208762890db81786cf555da6d428f6322f66f3ba4743a5ef18f3a6a24a768e04f634c0bcb413ddc6362dbe756208c1a23ca8cacbc7b3da8d0a20728d6884bcd7d2e3302679384034ad02f448c0e424877bdd53ec709d68a652aa3d22bdc417235b6ff40c14eb49aebaded4f3e1d4e54f9263f121cea80ded03768da0342b570b50bc14e8a4d9f049586fab4c3dab5f4caf88484a65b1ccb5c6928f8afc063e1d402f8c78ce6d72cb05e5a4d01c4209f7ce354f0bb8bc09348902c3ed0a52a9989c16c896770fe5afeaac6c32dd7d11b5ca47f638995b961a1225206d96769a995ec7bc3e87d6386059e6572f720690465576caef1670ed9639db7d0a1488fc929593540a65eadae60fc2bb9e2b476a4349bf5fe2ebf55affcedf6290e9b937414949c3fdef283b74552eeabcf9a108445d0ba84ba9fae59e9af2d47afd5e2295a37167aabeeb28427ef456657d4442464dea29237c23ac7a204c7e0eafe163f50a39766024ba310f0cc78779ceca5ed4ba4fbc49cda1e83b23064b01d2e6419c666c45d1fd3354936b2a4a5857a11c0129cbe1e62e8f2ade638644c115faff7cb665db33fa69d675ea869006a30dcc1ebbbf20d748fbbb23a1b68de685ba0371d29ce9d0637f6247b26e95c11228f0b80effea0c3485f577e25bf82cd7cf3ad6a4cc65d642beec17981fe9512b2831ba45b8bb30173b2279f151891558672af15b99fe79cb3ca7bfe13f2b2ee579ebd1ca481ec975c3703f140957757ce8717c85090aea3ffe81277447dbf273a980360c94f9e58e74073dc0638d4fa59d7030c950f018346a5d5519621b9d9f2704692fee1063748519b6d3ea5546089ed6e3f0fe63c23b5553e4bb680b0488eaf2d563fc272782ef46a18c0e0aab1b932beab5264e534c250987ba26815d6c869301f7d48ef79cc35ef1acced99d69cf6fede8db48f05b4c78066f7d9df2d645e78c662a488c76333c0e5d0e2ca65a69f50a24505dc7f3f92bb178d9947ae61aa07494f3a615be04565c926423767f3b143beff311be5d46533e39d80eb035b8bce0ac7d0e5d297be5c99a981cba2ab57425dc3e3f22d0d764d9fafced922138bea06c8a4fc8d48481683c0af8981dea35db3022e8f8da2081a4ae2504d73c7be604c8ee45401dbae9f64611468ec0c37e5668451a744803aaa1fc7ea9467d9e22a7670976040e57a6746a0410ffecdd7fd7a44dabe3d86f6aca8a473f3ea54ad9fce2f2adf4c1ee6d0c6f285962720b068217b28d76c94a6152055dac8f116e24be21cb87975ba31d6cf20d9e0a7e901daf9cc5f148631f83146ea278700bfd260e46d46411a91501e04823392b4277dea36e3e5935f9bf099480833e6e292f7eb21ed86218d66920da75c75a84e4d1a80e1c2edcc9089023df5d4e167228de8cbc1d29882ff642e70ab2145415a0689db542d9a0dd3176910ff6e3b5e51acd7e02ecea68ea1e4d76e661d7ba3fa1c6ca53153c67b28d1d797890715fd1444a5c1ebc513bf6e7bfdfb751362295cef6298c59d49e7e61d6911052c909db5ccc92b51d6afd721e7db189b3c53ba69cea00c655c8db71ef0850df88e4a930200a8eb76b5ee1500a53aa2b1b2eb9bb1843aaedbb94a5a29ce3c2e7f14795da18718b35208d40f5cf315bf8cba83a7a1d957f2bef7267e11794428242b5234255c3f27143a70d020a3c6c73f4ce42644f641b05dc44485d21e58b1885fbf6ec702f1b1f0681c4024f283b2695c55e04fe84028161c8219592c36a633025fc878f4b384ce5574fe193ddde54ef01d97933bd485900ccd2c14eec09627fbbcf06c97ba86daa8e938a8d213f05e046cd39687087a8d1f685c18303e507d9299e0e90c181a7eb6898ee8d643351f9b87af251128b2b618ed09d53910f83e609767f679acee6a378c728f6a04a93af65eb5974894cc304c12b3a0d7e17021e14b7ec63ea1432575e4d250f66a294c588fb453ef5881168ed6894b470c359dd89252e7cb8d22190066e7f40f245ab82f25e521af7259c7bff7c688cfd80bdd63bb1b499dc5e0d544fd41e38fe1ff6f72400a678c04eefef377f2e8e6f4f7eadfb33bdebfbb1f8f9debc4625910a5b700a792a21aac6064dcf932f6440765bfec58cc0d7503647f3bdbb76c1da93aa9a988b380406608fe92f0932e6fbf91d3e382b7ce5f35357082c1d3294cea5c8e81c56aebb9f12caaacc7cc0b57329ce51b5d14bc0f0435cbf3a63af3991fdc9c319519f9ce916b11ab82e7b2349f3200b184c08ffb7181246b8091c98cd5fa65f94537f8420b78fc7272a54c505e7bf101e409579ea07e20311e9c1089c0565b559d68ec57cec9d49e4230d7b08165eb16fd543512031e8e5ddb38778357d9835a40ef87edcfef15e8c583991b2358d834905b3630934236aabd83ff139702889b5cefcba7ae01c03e95e2324fdcf1c7f778062c8a9c2bf8f629fc4995c4febf33402d222064643b236b55d1cabc98642e066b24ca243818c0c9a80e93b74d16a85e2b5c3f85fe171735f7bb00f6065c91ce89d561d40099ec33a7a7779c4f957d647e14f8c724c5ea24c8f4ed9da7ec67f5adbf26d8b09f7df154e055be769b0b92b25872712a9375dab55f6602bfc226c6136d9011505ce3707a47b3a7fd3624b9e7d611d6d7942aef39cf9bb7dfb306ac671c66ba29d2db7c7b9cf156c98ec33b544b6c52b091637adef6d6e43061a5c7247f3d1665288ed9eed8b264d5c2bb36665756586eb2991a0133c3ba66f33379c6e52fd39d9d593d5a857405efbe3fa14765807a410ac4ba50b862015f8d2b21bf65352de826fb6879cff36f08ba454334b31536cd37c65ca4742eeec2fe14f838b8eae74a4d2f2bead18400c2ea023f9390f540f1c39e0baeb1261f9710cdc110852924d8bb520da875b55ba61cf87a47c74913f4046fbed7afba68214c6fe16e8f46e7237b48a2235e34790ab225fce1476d89c55ed65a9674410d0e3d37bc8b57e7a54d3bc29478f135a708c58fcbb6ceb128c2f3fae11f5c9a990879291baba8ce0be1ada649ba14ba1e14e5a3b27c02b24cbd0607b5bd1bf089a67837a6acfb064164e3bb994ba4bd2b55810d198f0ec3607328facf3489da7c282353200a3e0002182fcaad079eef24ad32dd8440d29a245d3197e65f2668589568a2a42ddec494b0d3dc5334b83ee7e27e70be3314f051f123ec0fa6b2ea7e9c3231904a5ee321cb029dfa8db8556d537a4bcbb020998aa22b22291514c54681f536eb3f75f2dfe33bfaa9f15c6a6075bede252439a3c801d5041e428ef25929e2feeb2b499e933f03ebe6d781c222b483224e0637fc5623aba4f7409bd4adcf469c2f07e0a397e6b5b920a37972ac547702e1278212ed214c5deb70a7d4a0a81419125fce5ead0725b336f74d87c38bff7758e17ff98087ae1c16513f3a90a4bc32a2f2ed56e4e10c518ad8eb43991c34c7fdbc2e3392c0cbedc07cee2d4bc444ff88ce002003bce8b4091696e37be381d85a906a1a1ad60134fc4d6d75aacdd2864c2d13dd0e0756bc7a66dd39a5f1ed2b41aeeb0eb2c90a8ff2ea3880f08d5185f7b7aae91904021255b08940f4c13c23e24b5d73108e47a2364c65cc727d8839dd9c72b366aea05c5c9cc2f1eae905b0e9dc296a05c86c5825668e4fa2ebb0511f719a92e08e17c1e95c3e8253a4e9ace15deaef55368b698f1dd660416d57964d33a49efda1f3ccd6244fd93bcc79c2c0a4df4046e6c036b0b46c8a61b1405a9e4becddbbdff9e7bf5782d51b21f501af5b9c96e87655bd9b579b7d5a96a6e114b06771242e6a24132fa66051a66c389ec378b8911fbdbb9f11d296d12422e244cf2683c60847e691581f843a1d2ba89def27119a108fa75e0f926701210baeecde7c17789084f73520cd565f84228fb0ab1ae6cc4d9c9d913372a1d0f2280056900e206015b4b6d1e1aef28639aff940499184c06f39efd78575ee639a77b8dd8eab6580f89d815caa4b0e6adef2ea3fa1f6de7ca3bae7790f9dcbba61856e39a5db15e3d9ea3b2b662ff603148a9ad2f6a1e8fa46b94c4f6b2ada399b90b21c580f3eb73b200f7df2a643559bb80bae8de4e2b59e9876e7357ca370aef22c5887bd24d52efe94b66da743dadbb0de67d019f7decb84b4d7d304035e470364c065997c8c075283845aca8cfbe69db9dd58f771a42cb762daa269397fa745aead292daa24195bd1ba6691ac8b534707200935343f70a29c5f277d241bd689ee223ba83fce26d2efd592c4ade7cd4cca51938bfbb6263a6d16b97fb4350ae98d5d49e9b6bc84c4d575012144f0d75d3580afe82a73193e195eb7f568cd43d6d7fbec8f3dfc95bf6b94979aeae3009c794c390cbc7f1d12df84df61caeff2520db6f85df45de75ab02f98b0ffea301a54fe5eea7262c5ed86a52e1a68102615137742c703327c3c2b17a5c7641f8c163d6cfc61acf816eb0a87c3a49928fe3a5b2b7f926f8dd094cb74018dc7e18bb41623bd0e0e354a1761d1c1b28cf43731c82d287ccb1fdbde507f24980eb117171710102c812bf2a49b69f12ee38b068c4372f8a35c3ede3d7cf26c865e98e4246615663676ac4a5e99f683b3f106ea8da6aade5c54beb023e31070ca35565d6976a5d7dad76f135ebdb45a55ebdd2a37c8470909ecea1265dd8ff5fc73c9ed27b3284a54fc7b355a8b0c8d48244e66b8c7bce71b7315053bb50e025cf5e934bdbf35debf290d8a2337c163fc72d3de17d49733f7ec68348ce7c3ab3a75d4729c697b74e95ab85d517d2af9f5620da29568a959a5aa2dc587866b3910375b4a184adde5f93de4f8b3cc975cfcd45a7feebab726908c28df256e72ecc07d0d41ce56bb8f705218fccd3b38ec2029a50bc4632fbedd714882cf667248932dcaa21bae8d862f85417104d1705c948f8d1a45d00c1eb3f12148a50cc34a2d2663750e04e92b2e786364e3e4144d32eb86c730c585d29f9c37a3077a239771712d0f05a931cd855b8299183e98ab4ae50ddcefa3d306cc1f4b6433f285b6c37142e65242013571fcf854e809f672c7855e118eb33793c394dafa880c4541866c5789fceeb186f0dc2b19823ec156177c7bf37dfbfad4ab6890f67117492f37d3bfbc67894f49a6293b12b0edd08a7a61af0c7e0d3ba780623163b1ab9029686a8fc886fa3a51e1a1913a3cd5c5b9c02a1540e84ddce3d290942e6d25fc79c93da41216058133c8efcbc6d9d2be0d1fd1db9c3acd7c532e3d775bee7ab9f4d9c24b10b589a8dfd80e9b9b0b38198ff885d18086b87ee2082449ec2d09caca22852e18be399b7ad913d7996d54555310757e53f00f95d784ead1a57567d7f616641136afcdf31378a2355891f689b55526fc88c63f45b138733342effb2a67e2a49119d2915c3050ebf3a4caf117b73d96f6e85ba614e0120a7d451b450de49dea8f25f4c9200bd7a8115e9e2cfe8709056b3caead4e48a1b1110d1c2c276b7d420c4de1858a60dd7e17a154ffb152ec37289dd668af674e798b7a8efa15f457395c0b87c27fad7985d589d893e6d36508cfbd4b38626765ac2535b92a244522d6531c066f7c2093ce37db8189216c346bf75f7db57918be0c9df67131e5a69fbd0f2e490a33c54d8b10bcdc9886bc5b174011d9bdad285f9f1245b6c343ec50682b7569f0cf6f8c5c68204f85c1c40ffeebfa88393beb3e6ce1f3b1af463b41646c05daae3f6654e11cca97528936e4bbce9a0d922fa49be2c3df79cae5c198fab61726b3e74765e834344f856ab0276412f7750540f140cd62997f6825f4b08089f76f8390ba8fc1f76a52bc7187dc88e62ae157b2871a95420c76a2ef68e9ef986c9c931244e4cfb7d95aa741cb6a8ed42a048fb2a48910a81daf79ead07b7cad0d64884baf5e52f689420c8778587a8e48bf3d41660723af5336e59e4994bd2692d1074040f1ce8f3b0ebd1059c139aa6b5026246c37db131a046d5774141cf2780e57ca01390d3e3cb0f65e99dab2c4dfb0bda55e2cf726344f3a8e376dede66fa32daff6ba110e2b17a6ffc3a535d6cd9fd11a729300161beb29996ecdfe1b6603a963c6ee34d0ab1cbc45119bd655b858110c884701833b946e2f132d97722cdc55358f41c37432146ef87f3b2f482143d7839219205d37d11564672754cdfd62afd7822e4903d120f678c29bce35fb11dc2dcfe06dc75110d9122b121c99a0307526eb410996d048034ac99b48c9c18a1e2c9ffc06afabb7670db94ba225a391c1de748642e3dc9dc630fc67fff2b93df6e54da9f923cdb43b2b2aff442b7bc689ea78fc65d53797a0c3b915cc9e8dc43d7399834b883965a2597ebe0c6de8950e387a67b334854059505db61f251496cf61be8c743d6f2eee92c3253d25df98ab0e307197821583b71050c7a62ca4f778e3eeb1ca999d011baf3f98f4edb99e6cdd0fcb160423e378d1eb6d7a76e98ae20674d1894971f853f6d85fda3c02e15a79e9eb0d56ee52c6910e0c04ff9be6ee49837e33d848321c295d5652b60a4bf3627106af2dd765a88f71a7957f7dcd6c03c5b2d91a06aeec0cdb17a9ea08e10ad6704168766cf67c5bed749a436dc7b966d5c0c000ad4115349434d93680b1e55adb2326e8f0efabeec9661f2405f31f5b711d0bd47663e38bdd08a18b968b48955229a4dbc9dc09d1f590754efd88377518bcd4264c36334f580237a4dd5cbb533fd8bce75f7098c29b0987a5fa6f8064c879927d7b2815b2faa1e625a4bef4ee7f5aa734c91e2583489df9b2374461f33c79cd7b5942c203714cbd27c2761c2c29cb5204a41ab0762e0c63a1bc6b15ded6604c7c1e441da4ef4b05a3a087c67a2105dbb07e5e95c1e49e0783a10190d745246ff61f49976234386037c3751e984951e928271551aaca4de504877d4ca1dcbb533a77f9aedeb03b8b1a04cbb69ace14ec92b2bf87c6f38022530835c382a830985ca89a81f8fa7a42e3cb732c22a40cc454e6f235b72945e539d5152672cab1aad155c088ab86f089d0afd3aa0ad4978e1d78d9ad52f14b2933ea55109fba42151554d2ab0449094b4ea8676d3d8da45dbeb375a210975efc658a896ed2c9e9837ef54eaca3d9675207d98db2f91ea5c423a03adfeb58887f358bb354923ee05119efa1508ed417838aaa8e4b7e12031675ac3aed791b3e2c1e8d3092da6bb7c789edb1e0fe0b4b9fa6dee5630728155d5972916ccef1e525dc833d61076226793e194dd9358540f3311f2a23bd8bb9f1cb6d5d6252a6d3157e85ebfe1122f701a0e42c4295eb9de828148959b6ddd28d25e4e4d259e3f0446f74c7b8ed45e95b1c6ae2fb38c360775de8d4fd4e9ad2aff774cd893feb343b9c6cb725da703ce62453d37d24e90fc5bfcef8a4d78eda882f5ac62a70e68232b8298f9c6ca472d21433def49dd6fc3396f3d2436cec6ab6696e13d9d0f05e87803f999ab870e93ed41961e242dcf84ea2a4067bef7e087394f40319ae8a73af541ad96fcde8a6fb7a3084e89c5bc201ac9dc8329d23e708fb4b23638eae04468e39ece0ba681ec4b5ab3c6bc254366e0954b4ed613653f7360c3de865b8c89122e1ed11d34537c1c7d8f93d00cfc6397183a5fa99f74684d23dd557b52e1ba51b15425af4cfe72c1c0fba2cf1f84114b03662d8a5c67d2f46d75955a874be4a30f216136a3f8d7df6b7e7e7bb2873d17be88007e00dc3e7d8ea59d717fed3fd4fe5cb634fa399f15cb5673124b48ac3867c67424b957a78ee8c9bdb12568bbbad09aa438ad341cc569f6f8d143f9560e4b73fa5a8944fe04996a6c55aa8b1a2ad8a9820d025cdf577f31c7fdf74275af662d39472c69f0b088746f22b7785aa6862507e63d00c6eee2346a5dc92173aa89856a1e3c74140c1a738704f76392e072af3ecad49dd668124218408f69e9570a03865d1a77e5479010d1e2ec122f791dd23063ac29215869ab77fb8668e01cd0fea9d1c6b23cddc2ec591ebc6b183c5c97ebe8b21124d05cd1f73ca5c7fd25de1bb73019573099bdccbbabd404c2e146e310e82dd43d8fcc53bb65cca441be019b85e65cab7ba3b410fdffa8f239feaf047903d1e5bf8200e20ae443d7575103c8b9a373ae9c1901fee31e8b4685b28d131dd7c8ff3dc64c02b0082aac4e2111dd0d14d0f1ad4201c23deedcfadb98968cfbe55fe99e600c6997524a65629fd215de5ce2db40c56c3213e1cbbc315bfde1aafcc9f9b5647505d3bc56d5f9260339898ec0b9971f5b2314306d1917e61c331fd472bd9befbe874814fd007a86840824b7c326361e575c7eb2c79e21742d0c7f763aea7936841ce8390ad156d6b39a5f15c0853e5a3e721fcb4373e577df6b5503933f5f4886ebb006460f3d91a5048e86ccaeea3b6b8dfc5bf88116847938ba9444e6f3c6d177c4f8a70402e05def19d00912d2d94311e4f93aeea827d7c7bb13d82232ba0511a5862f547d317570f431acb871a152ec1805b6df39638a037f6cb084c9733518f6300c14515553a8c8f6957f18ca19c1dd75956dd21432af3c5ab85549875b62f2b174c4cd6e7ec3ff94df2160c0e89386d3fdc237972caf19fb65734f5082b8ce511df9c6d473d743c9b6ba45f16d5e3fdcaca4ced11281c2952b8f1025eada3aea85ead0c962af56faa9d6943cae6e5800af904dcb4dd95a4225d11a5491c04b7cd59d87ede43885c1155d4aa50f1f447db0d3aadb3fc4001cd863aab42c077f5a407bc4c84896d56d0f74deeae6718182f4a9656c142ab386c59ce0490134a98d3e1aaf1b0743d686fdd20ee41dcb025a246a4546c2885f8bcce7c3dde736319c6490f59b24df63a872e3575373b13ca8570f7c526fa724b4d35b8f8696910feef4c5a9ac0fdea2fd5c0cb999efa7c410cc8d9ea8a25f6d0ce366649f29033269c2f0cb50f3801ab1b8beaafb0cb2b078c3f2188a6541b5604931118369ad724260b6507383ceb230d7b8494d434ee23519e276b5fc31c67e88c1729f45a78c9ade0df39a8dbb2d79e39a2cccd3243f79a895159c3ff2c94735f2007eb219576d40e90913c7b10681a63d195a5d795d3a280771042d329ab35979bb4e7575e22345cb61612295b35531f640eb464cf2f6f05aa80026d5df120ed7737b842bac3a18b5c84c4916e2bcd80d340193230519f13f357121926816671de71283afd4aa627f87c5fe84a58b7edb71a755d3f5e1dd0a5541bd3724ec6432e475ec503ddf4827e194e2ccb69140b2c5cf3a0efbe392e57c45025075e4a862dd05eef10fb4eb9a19ac22fe62614e20be5775c28e4e6acef824e8c4f262f22e29f3247172a48daf4dba7281aafad8f0356745b0d63c202beceab3006f5bb4e015d201e440a81589e35fbdd35add79a3935082eccd80999b89bbedba85aea16046565e02cf955996b81a9ea21dde5ab6a29b85b0c0f275d8e358e7e592221cd58d782bd5b4a6f0eeebc3e5ba07d94f94c1520e8a3cdcb559e5ab81d33b1ecd333926e83e8012afce791f947ee8f7d4bc50f692fa673ade3d641919e96e4e283cdf5f01b92383aa83ba43d66a86912f627b70d0e14c8d2e36b2411d14b052171a2a38a48983af229baa2158850cca77e5deb7b3672ccc540499515d6dbfda6ab48cc7062c151aed377c528a5d67732e0946d7349f24825ca05d7e3ead33782a8e79d70bd46c08a3d7cff342289577be456c1bf519c02647ff36ab1ffa83aa03537521a8ab9199231c831f6b8587a74916e11d1b4293e65de7ae4274584e7e71be7f5839d6c4e05c57017a19a8ae1198b02f4fe73a2a17b1fda2ecfb92e9c8cca64809349bfa7e69a672a94eb9b7cbb58a043dde53eb5e128f13d6f68948b51d5a153c6c1cbca5e381028e6cf4bc255b07d1612cd511e7b615185d65f303d593d8223654bfd1147f69eaebc15212c6644888f3c694e7ff993cd6d81be329eeadbe9dd667f5e83821d298eb9d32c2508a125464f4260faeb3c0a1940b8f490276fe3f20ce8719a98fd32beb5911cae84989a791dc3fe87c83ebe739280be7285f7f15bac50a3bb1c9e7262c27721ba6b011b938de3b9755f5a0662390efbcfacc948397fd931d70f35916c208d99f511c7a878e8f910efc40c37de721eab206ab2051029341967dc6aaa19ae06b81bb2d3561202b238a0d08f271ab4c480502cf1c0b62dde256a67e4a6308a66a7c784f5bfbb775aa73e21a238e4f8522dfdc2ebe8011d8b45dd83159aaf1bd3bcb1c5676a44ef92dd27abc6dc8752c1facad84a8be4e2f70f70b3c130d2a8d202becfd861a47a11f0816572e1fcd6f895d16db45d1a032267f1a9c9c6287bd3fc2ddb635cb4e0b4b44620bfeeaf5671ea8df7d3de0f503463cf916104c1f64a545893e870c2cd4ce77c7675b1f10c2aedf2c161b57158843ae54748463fca1a800526b3b14f4ec1e0156771c1dad2aadac1951e3ba827bb1fbf41c122253849009b7ae86f1c32b46e395a7eb21175e02f2e51df698cfd6be24df1571d9274840069c88d0c0ba55c541ab2cc4af907f4cf59fa5c49576cbacbc99954233fa4967741df8bf07c6e81769b438c4daa4fac0122e87e4499676e2a7bd523be30fd81b3a86c904662c58b93fe3a18e144d04afee7510fa84bd7f163f1bd4378e735a9c64150f8c25335ed7bbd01aad1c1bc6f22b9a9b25379f22fad14ecbaf2a461a7f7c7938f87e6eab9838ef88e9cf57365eaf687763298e6e1d467b4f5d67e8fd25718c6a95d2501caefe19b4e692cece41cd14ead8eaa4ad04331316066ec396a5d2a3d76040ee024ade005516d0c32cde8c742d2e5877455ea863418d54094647abf6aa80be8eaada4c4e39a16ecbd7a974f1964b26c7c9a426e524a9d203fb5d6bb42fe9d84b4dda59d8d18b6d68af821cd20efb77fde8dc2a6c8d7cc3570c63df25c240902f5a4ee2768bf8e176a62e5f19230e58f6c7fe7d1ead67069c3f4d90ffdcfb80d29b199b3b5bb59339e89948d71917d503bc6333342b2510065a0f38d530bfbd9d7c1000591a0311eccd5ac4c05e81400db4f7d4014562a1ee3fb07730def7e97436b2af3631ecf3e8511e8df7f214ed6f5c20091fb4cf801b9528ddc21d1b58c71789890b17e7d9c738de7f07441957e8433881bb91156332545f11eec31d48441140c888dc087099ed194cbe0cde5fce04b03aab6a9f951f1d78b0c853e1784fdb6b0d164517bf449953dc048117a6d7172da80597598e52b7f92c4664efd22d46f55fd89e1f5a91dbfda7b753ef4f3c632f6504bcc1e5553c2713b6f537226a8741cbd9007518562abef0910e352676ee9fc4f79dcef6486f15f0ba4ad597aaf6ab8b42484d69f33021c1ab2ecb1d68c4430adb105ed84ec2466fb620e970837457b7546a21171537b9256ef34e1d75eff078fe49869de010946eb0a4d0f5f43522437274ab4da9f7daebf083b3947ad219f16fe72603849389115ef7b7f2d4492ca6fbffc1592916e4eacf5174bf7221ca66343c1be38f8c4139e672396a9f9048547c6133a0b529e4c158e8aa8639e99eede266b5d62ca629d1801cdfdc1f5e103d342a7e66327bbfb158c830424cc08a2c2aeae9352e5b6f9482ace34620c6fa265dcecba75a319d9c3a4a56a82a53a40ec0bb479f87f8dbf5b872f5e2e4cbc00c325f1a4b02bb7ed3988351459a98c5a0fcabc090ff31e34f4652352732b20be25f1a9ef597c6d380258049c39cb5b1eae8f5d731b064e02bb516a02fc2753b156b78f4e0edcf1cc5b6c0ae7172f34d21ca38a43440d879c81d86b47a08d56270a798a5411c076d238569f1a310a2b5582353030338c735a9774632c210085befba69efca64ea8e53c1ab92617a83a8477accd245728aeaef4ceacca344cdb79a32ff0b5e1220d3e4cc4e7ed3030575adf93cbac61111839417a0462a0c2555e5f69bb1d9ef3097d4684723b9d196d8fd72ff5dfc9778fddd83b9c9bb4cedcaada7c1ef25a2f0ef71353e40908b380130332fdec50df185cfb988bec8d2e1adba5a851835c59ea5b9428712fb0fa368a394c19f6319842ad36665055ce630a9bd1401bb7d19b05f32b4a579d5cde4f79e9067b225708ec293e1f9b584a45e5e01056bcb42a368c6c981de01490661ff9f3daa9079b2086f4a50458a38d664f5db6118676b3032f2a4f73069fde5081e90b3f343f78d7275253dfd8a28cf952ab55b4738be33742cc371169790bcb78a78beeb241266b8a9417bfa14e32fd032ca1c19b618d56947d03bb9b246aa8622ec28860c28f8168099658119a10ac8b91e56812881ee29206afb6915984f3ae7efb24a306cf94ee50cf4497201adf7e4b4066b4f5c130899cc9bfeb018296e9b729fe6ca54f6a16df43b4c23c07f64261751c4b363bd5ce80de14bb01cd0da56670d0792d3011f1aebc615ba73e0ea746422aa14afefd1b2cb8e2017bf4c8f9d459161e6a280c73f6e09e78d008249901839c68136c5214a5ab9620fd952cdc055f50b30c1f7e1a0b36e493d41188a12df6b978664a4ab98049f93f7b6c9648ed774df2f153faf10170d936bc8edb6b13355681f55e4b075c3f69acf92cae4b8b4eb9d0e27460db7103ece93c18855e4a0bafbc4cfa647938433f7b427f1aaca700b1a15e33c08ef4786e7d6ce56327ce91d6bf2242ab7b2851521fa54364c76c85d639098a5c211cb2acd477789d01b4ff116c9e713ef88d0896df0e7add2f424b8408d034d0365834fe0e3c4b16b49f0cd1284340a28f9e4e5a915aeee62791ae0630262195c805418c28c7b12dbc79a738422c8ffa25b5949ae9b979a4a1d23d960afcd5c3c6a9ec972cc48c4a04df15140bd1d527c993abd8a31861f4ce4895e320660d16393c3d572ec6ffc0377d567f7127c1f2d4d9c270ffc75b4f46107bb4d452a2637626b64b68debf93b5e104172db3603e750238e05b24ea2dca4e745db49bd5d6d0a9e430fb9d107763774bd9728cb80e0a5b1bd0d1296e1777c364c76f7410869064dc4c6317fddc2699f8811ae7dbe396577f369c9fb9df1dcd622f104d469ec184ad6a8029049f0129f3b2008224f7e2d83cdfb4b6ed0590b2084a3305d503e95ada332b6a3277d44d685eac0f8edffbea205254be60e7d5847e5eb2beae641651e20eddf1ccd0d9a6ca3e49c903b2bbeea56dd99b88ab52902fb91a62034937a5d01474b6821af127a57ffc3e1414675d72e8e221d897c340d171bc747611fae8b63d170272ec3c72a8c1f7418b1bc9fbbe6c204b8677cced3a6e1a8ca02e1d923718ec2325d14cc9bdca3da775e627859f6b2b2e35a3edf5383a5e60b469d14e1779ccc3e70f810bc2537d386146b28c3eb93ff75c45b82d53ef0c2a2568fa698c9dbb405d8bdb8db37752ca2d4bd1b7bd3e54e39331b1d74878e76c985e42802ea27543e7c36bf80d18289380741dec71f79b723d9658461c5c5f6b0e78abf6031e00d1b8cb465772afe0e5a294f2ffdd83313aa16dab7b5b2bf53332085235efaa265f1b5a410a5b8afb58f7e9c7507bef83eb02b399d0a4a0cd902347289dd1351d286ea4647466f0e23a73c73a226ee5571b198db5d76c5bc0198ce8fa50a393946e476d1fb9f2357ccbe52a08fa91cfcf0787bb50fc0c3a2529df27a20535a5fc16f6c4746a77c28f1edee6f781d50751811cd943baff0a1a0cac3041e70d43c9f3da6a0e84d2b319db1d05641fd92300cd401d5bd82c9431f702b1933d1f8febe80f2e6d549bd7a27ad558cf7bfe618a17763fb9a5f11967f12cd140647b8a46eac9b84beeda0e06f9a87097e19e615e0991b1e1855e804b76cf6ce948dfd74573129db9809b9f3f53d2fd1da4a0f05c026c66cf742fa13715169243f53b589a054a9c8ee3450485c6de2a9d17957b403815edb62a562c60c6b5a31c652a4cb3bf48e3c670c79656fd8576c2a86ca91c024baabcee013963b94e4a2ede0240bd37f10dbd4fb81cd30c05ab598ea5e87ca0801ab8380c1a0c94dcab71ad65bf884a503e1548be1f1f0180273de0abd02307335c85d41ee7b86d6d9e2f6a8b5d1ccf42e7ef82a77ce1c5a9289ceb9d870de4ea630f6332d34fd11e560542400bc8cba2e3044c852bd070f8fb73ed67f7b85d8fc4fbab80277aac8cb6d127fd5b6408d3ebaa013659d1c6780f820d6069400c3c3a3fd0a778731dd62b50feea2f1b99e26eb90dee46db2845b29bf2f690d204c5227cfc943ee79f3649abeb59529276291d2929091294c6e2c16255b976a7ad9de807992fbf715a07364b471d5c2b8d01b3c0f95dea5320f1176ed68c0f8abfe9642d9823e19b9ce5b0ef44d8da7d30ea71fa5fa618329acbc2f5461d40284bab10893bf2cac4f7a00182b11d7cee2ce24af97d58528f907a26d02ca52f728893f4311b7881626d8df6115d0ca4f29f202d866bcd18f98cdb330e3c2271f38983ddbc95b96f685212b6f260e9a7fbdf4f87d810597349fdd0b86d585603e9444a235ee4fb817f77466187fe6de7bd7dc67010b8a71229bc8c1217e494476c8ba12c46ce2aad47f223a828e5d5e2ef9e6c766c94f809aeacef1654c422a924a0d0092ab3fa320794a9e5eb8e2cf3bc59f000e96c47a275cd5cdc319d9cffa144863e27bfce7d4735a6577903f0f0f0f010412c693dd907206ed2a3c0634f0fbeb8f811232ce63f8891563cdcd0e106d8925576d2d87fd7ddcdb411d835695e0634a96dbf570ebb35eb5d9ecaf35ab90828d06dff3ab1f39576680f9ace2ce8753531d1a9a37aaad54bb9d140fa524a45ad5aa0b72223248c417c4cc8ba331310125291f628cb26c6fb48c0d1bea80a5c9ccefd188bc296d2cbb74cf1056111f2332e4dd8a03ba7f026379092f47d9d16a26ccb5e3dc6d0ec2e7495380a1323080c8b58ef4aa2505577d50159041f63c25e4a9f3f757456033837eb443a81c628ef161c0159efe0576def673af55cf8d8d3a507acc928b2eb912af6aaba28764981dfeda987eff933049a4c2e6aac52857bf5ad10bfc0b2c6d9dc29deef02b16690158771fc5c958f47de4fa472879cbfe6fc591c1c80aaa0ced8971115bca330c17675a0c568991254128045b29c48988704b93b68684118d4b5b7fa4bfc44c51ac8bd4a19a0c23ec362e72fd4c396097cae7354d594f632f02b0dc64d418cede06cbf8aae71eb27d47ea22f9e7358a2f3ba12d7073bc6af0907f9916db6497d6d6987a08bd884e5361e204fbee91657fde8ee6c4f1559737edd4234fc1b5cdd5f1d96fd5a3a43882379ebec36001754a959e6b18fd80c5f23f3f9ff6c79d3fecde04cee9e166533fbf684e123af73e5a33897681e4e37add3212853f3c96060aadae86be42996e3ae70b657c03463eaacd40362dfc9acaeb1fb0e7e0ac8815e2b907f5afed2159fced08bf746808a12c5a3a3418a07796e4586223e9090756c32f533fadc29dd57c6e0663de0de2f8f154151be8b0eed2cad32ab92fbe3b236625dc045a78e53cbff32fa4d61fa1e6e14b885ece9d7c662de0d32d0b0dba3566fad4bd90f751fe49d7dcc3ee5d907f7534c030035b515b6248a15622d966c397f50de9f2c21d686a1f4257ead757e94206bf477e070f7ebcd6d9cb1ba189b80b71339b4168fc18aab99e7d6c04ff99a9226398eca19e20edbaa025dab8539981d4882f6e52889ada4fdb2ada684677c60aacac21c33a25a656f91f915cf541fe1a203a052ae4b64066d07d89d6d7aec4d8f22d94d70eb71587e57285556962febfd5b0a37f811dabf184d6b430f6cfba46d53ed1501816c460fd9a02f36c15715fce552dd11790bea785d68403c4ff5c7a616f4774d40c79aebab9f75d77e233b3fb288dffad3a40ca255a14ec2613d94a3abef55749d594d344f4314135be09222e371ce3a30ba66cdbec6da7388d6146026a6db398c406ee5d994df8886bed490369eba3cf990ad3246846986bd7c51d8f6d9132a47140512575f20fab951d1408b19a99b2748aa734b01397caa75d61eda7987b3f99db4f4696bb65ead8ce4eced74bfbf5ed80678b4bff5ce304bc3ba2c7af89f54ab1a936a946d339bb2ae29402d6cb24cba4b7a0de9660348138356770dc600b1ee1966fa19bfdebd604dec78ee17f06f7085223f0b330a65ad3113b13a09758fb86672075d7e7db2352c19e7272f3ed97b1f40b54f2dbf084da81bfa26fe7c2c65440797a5a1ec5f29d6d56d5d7e08b73e690daaf739c113f79cee2097647a8f0ff5590be16e16287c5fa33fe4a9b2a734b8ade4178e28fd6c51aafb09d9ca1132bb4b2f965cdb4a081a0440cfa03fb3c6c2087cfc2eb671ba551cb43797305590f5574e43d3a8fb0bf2241ad953275ce90b111352e6cb6a237475c3be0c3f6950219f80f079395f679e68d4a9d412863fd513428f58ac842805a5675c260d881ba5a8f6c7ae7e2164cda7f5d1aecc77aa2286fbfa1574e9b3c3f45a35fea16fbad6a5a3c262ebdd4fc3a772255f4c757c4ff78aab4c4970edc7d6accf7b8f7b287f7a02080101129f90b3340817ec6c12af9cc4080d71240d6be12dd016a54bbab612648a0ffa225297e397332bdf3b3add3dbce3ea69279eb8d27b16201771c4cc078fb586b60bffe117332bbb31177aa786eb7e63c23982953fa9725575a6aaaf998a7f4103a6743e7ed4480ba5514032930d1e2cb7bf3bea2c6acbccc3cd2faa779730f8669fc9bdffd6a990ad4780faf52e0252750692669c008d164287b70b05663c44ba7dd7427a7d6693ae0bb960abbc181a655f976e69863fe96ccdaf2cbf769e4d94cc6034c4ff1547c3db6fbed157612d1df07b7034ab5d2e11c53b120f330c50052da2c1b84354991fa3312592c6284ad61de9a4a7d9240ebbc15948919add19c9bcf77446b87cf486cee8746d28cf859864ff596069fab2eb7438826293609c027368a69bbc8a77ea0002e1ef8218bd8b56b918b06e9f4e8a562745cada764cbab6ffe3b35484a671973aba01a768440f9245dcae827c0e196d05f17a98c3b6e36a3b8435c1f25a941226a74bbf6f25fefac4dc75dcd8e1192fd5f76b784bc34f941cf491c47dd2de851802a9bb39f32b25c84d661767d3224ce6bfba5c6a76258a300cc3254a14397a3da25d30a0a1b7c2174e6f0d2994863cb82f2a02c388c076bd59cf8e003aa57e90ea27a6e7788137905040e55e896a704d150451f49d83da295bf70b4e7ebd7e8f1308fc12a2f956304c49c5ded21149305f91ca91285bf1daea885dbd351f795be9668408626ea5b814da3ab2f001bd1ac244027bbe06cd5f786200c0bedacb2ae758fa79e17bfc626fe155e5e25bb867365dd4c4a0c8ee818e04ba4d696d57be524070229c368e725dab2bdcfab1b1be2b4ac1aadfbed54aabf8f18154395bd2eeb3ef444a2767ba25abbc28f1efc8f65518d37092b83d33f4ee8f37f0c62804dd1b36ccbaca50c51fed5c6896dc18b493cd0d99373803551b438076ec88ed532628b45d901defa7ab5e369fa6113587614d3f095f2cf2c4d291d6f7cefb8de8fb8a5d4ff0c7276e1a802f2af3f6318721ebd88e0071ec60c59e1bd95e1d06c133fb22a8d23dc81ef2f6c68ccd47f6e0ee432034ce7c81b16a0098c47f34052382082af7c1c5329fe12a432be1cf612fdcf82967984e8a05a58a88e193f238e519313050c348aa3200762218234f15044a5fdba91238cd1868de323789d883ab9c088de4258db532f9cfc16adbac8a8b7bd81edc88921e79290abff80a21210a3401e9177ebe738c1aece91c6cde439e6c161cf2c7227bda425e3b81e18a779888490e7d3d563ab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
