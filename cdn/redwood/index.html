<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9f33807ddcaf90fda3d47bf05b4c6de66e7287f8d1e875d85db7ef9db78ca8048bcbd40751119a7f1aad0e38e55675789594e40a2a2ea45f363598fe53167dfce7472762b8f6e2a9252667708058dcd78b5cf188ef24915a2c106ca790c49192f03fe6ebfe15ab9e68fe2b214510942b9dc2795a5c17fbb574d34f2964fe561c25ca570a53d0bef8ec4113e5d24c962437e28cbd38e68736a3da67eb9b6d0112ae7109fff8ec639a060e1385782e0ea841e8369949048c4f1097c8e54f796b0b32a2a1dbdc5a1d1348ce7398456f2a924425dc8552caf5dd05d823d34f1eb8c67219df6d19ed5704a354ec7fcd0bab2c4b465453b6d298e288cd4df13dfd03a5846a7b67a8853e793170fb2d327559f36b57027f0d504ca94edae8e17bda8795e98fa6f9cea4147c03abd9f69754af508eeb3716f747ba4d4f6bccc8aea18fa972b3db4f9a53992c242501a72e4f0735c29718699d946e6f2f5dd785b6d1413dba6d8005d39b755218e7789c44de1f015dc5c94fa35e40f5a7a6426265f50e1e22ab3e84763abc7b79ac4782e060c859d02080f7a2a30954a3e4c652a895b4a580616409e5284b46cd353d1af7db14f78a569214944771f6a832397b5df53f28c03065858e61e2956705e120c98654471ab53f0cbe1978c1bdca06b447766e452f2d2d6fdfbba89a79976c8d7e683ef1f8961c106b68c8e0c71b61197a8f2d50577d7d76f690179a8146ccb9621abc077dc33ee1feb1a229aecb92e94ffadf00d66b69b12d75f4233a2e1c799a79211b3ef1f01cc1d7080570c59b815d7e62c93962bbb9eca89c7f9ac6d3592439d98d70dd6ffa235a8c8e932ec99d2eed2c1b875376498f5ccdcd09d67e1dc64dc4ea98c5b97fa0fbf3e66a159271a78ddd1b1bd1e569ed03691d89b6cd6adce606e243d8d8ffafa0dc72d1b52f7412904377ac914049da33bac004c633b496068e7009b13a2cd772c1c125bada58fba726228a1895b0d42128cbd7528d35d04ded62ab39e05526d91e1d52077ff76c4b8f6c1196b7d55b65df657d1f0d04ead8ad82618dda4f3f6691c037839b8fa952ec54597dd231513f6b2842e9c18f2f8a4faf4538c5151f0741c210ae4058d66dc7f045b4f76ded097be81bc75fc9270f598e44980c25406c70c1a6a305023b299aff75d791fcab5058bfdc7d6deab2a211945b9b18c815632e87a0b74ebd2985629402bffd015b1d542f0db27fe841553819d8b0c71c245bd7215ad9ee3a92e02b208e4c16fd4fbd209596e32a92c1b70d58f84d2da5a5f2779996644f9f3e46d850c186dc76674ff9d05bfc2b98fe57126c9b25ceadab03dbeac9d171b8b5ca87221ea4dc09deef4ef132533b081863405f0071daf43e15453410f5567c37d5147d07ae875e61ae834b468351bc159cfc22973f02c43dc3bdcb07ddd83cd1195023159ad83fef6a8391d5a2462635751e8260f1827b192bd1964f9f3b92d875a0e2147d72ddd32252c88b670ee24f9b5d6ee934735400d7cf5e2df383c039dc89b4dfd2a01b4fa5fbd58d0fbcffdeaabc6fe766522b158267f2f262138d8159128440dc9153856648e8a9b8869c9f2e33e4d0ed4528a59d13bb34d525f0e7daf062380055da59562deddbc5181cef52eb1a43c7769e6e207ef5be716ba0abd629352cccd3acd203913d375c86372fa38834eed40b0b218ab6821ea09c1c0be63683c7b3fdd0579c08b90609200928ac0d7d841a19ccf360e294a2e4a660211448792c8b4c2ade41045ac5573f4d940c26df4ecef025639a5d0c3e9b8412977775af8a834a5d9c79bc03d6caba266f76af293cec6d0a7c08d2bf02db7da973fe41068a2d9737d88a1478f888516003668166670d49ea5f31eece74de761eb99ecb65a1105f598c41463ad99f62eefc90f53b47ccb43b85023bea58247ee234418bc414807aa0e83329db2bb7f24800d2aa7a08d50e564bf9abffb6841bbf17acfda5f492395f1a1f0d5c8e0a63cc3bc941cae510652fa46949ffcb19b1e33f337113ac4c4eb8fc2542b8a1f3805e53f1d0f853728976aeab4f6913101aa73c0fbe874f82af692863e41b8f4622d4fa26af76c3f74fd1eacc2f92bc67de471030e307b9f62be3c1529b94831ea78056935587456ee22fe3ae191611d5fe78e771e04084ee22152d9e0fed4494303d46a691e30c209b8c75bc7821a193416efa43edf58599827b187ae570c749492e2ff89c3cf88471464a5b1f1d5776579a98b8a6bbafa0c49cbfb9b2cacfdc93c9e2aeaff51421fa7d121893570f1029a018b45d0f83f1ab01d589145bf00d2fbc8dd9ce3996c62a69add39505ee6b3662e12f10cd631d1b9e40a30c548f4f8a8e9ae2a55989789a352bc098f5c0c851a5d00f2dbacbd0e1e8f6a44397a42891f63737e1faa493609b407da851ea8fb63993e28da68e7f99d103f459e97e644e706533ac7258e377acca8d251a2e831748f9d52ee357f6628b5bd79b4ee320cbd6217b366fa67eac3e9af08c9fcd2f8fdd21504f9cd1df5a5cc9e29cf7951fd5a04a5d2e2fc0784213f0aba75ba5b72ab89d41c4a32a107d6b7a2ebc2151ebb0d5d21ffb65532a1fa6eb23dcb6a7a8ab65b1838870d078788c46d1aa7740b89ec4db80ff8437f08c5ccd7b844c429266425b29fa885047545f8e501f40a84ae0c6f8799130699b99e995e538ab0f83bbba7066062f6e090219e911247d47ee4ff0e9403baa1e5fcda5e94d138954717e6107372cb4d8678f38e8590f3bd3cdff9e5150038177b47737d70c01eca57a47b40ea09cd44754459da9c51727311d57cee64e7d1cbc0d5853bf98ba2c0dcbccb5846c680d2ed24fb20513c35cdbeb25e63e23b72f5efe175ebd5eb521167cdc5f7f7d18cd579f7e7b1d057e8cf8a21a188544fa169172aa42bfbaf8598a577a768d38222e746bc874aaab8bafeadcb5d83800ed631e6e16e07fa5e4d2ce51bcbe37341b6ca54935df62a639eef0a2a6e20a82acdc3653b42d9872ce265c6c8aa1beb0d183bc677868d8d7976a95e5cf42d974d5e7bba55532cd3fd79fd4c428bb94ebd0c0ac245da618f9b31abc98de80a5e69f19a3ad89636de2bac41f33d83254ac350ef416530e260330363be472985048dcf1f7eb3815c7ca9c3ded55630a9bfb9e64020df2ef52988c09011f2a259575b662df96ce8fea6b9df3cc9a370e9202db41978266272b8567b201feb4ad198004be97218bee95804c0291d61bc3a110f828e61eb4c6c3e632c5227641840921ca7c87159bc6ea19d53dd37e00952292e7733c35b643094b5b9f688731260a0d3142e2cf1e3a854901a7633d249ce8f3edcd3a9f5f39d1e6dafad9f3d1f62e40cfed7f12afe0d6b8eeb7528f625b31da5a8ed66d6d2fef271209e1853f9cf499f8f0d68e1048c1df4c3af8189ef297a5208bde55b525ffc28bf9a17c61a02600514d7168ca6a41683a108c4e0efc16db38eb57573bb12e45fe75c2261ee3dc6f364cf8409715ba2008e9f33e298f41e750a76e7600d379147c90805484e86f79ae129292983be39f1b7565f973714b7d1ac06f4296912780d2bbdcfe559f536dcc8cd88090899a37fc8ee9a72902b243559ed70ec60895b3ab7c2f4175e1791834ef9ef0abd8514199ca647fce2c0242b0742bdcbbc99f02cc38771d64cde2357abeeb3002ac38523a125cf3b7eaf1e82a45dbeb4bb36a9f1fdb3e4db780718831ddebc6fb17ec5754607432b13c04d4efa95e8b59d66dede4e22b5a1e4e6fe2a86d0dd8a577f8ed4ee0079b6dc127e8b6d9af0e18821ad5d0f1c93360c8fab59eb0d0b03fec8eaa8f6b12a66801e3647a926da48431d5d22ff98ad4b779f69ba06898fe382ed11d6511f5cf7cf3ad52c2232fabd8c2eaee9c1683b5095e7ac6e856488b1a21e347785df0cc2821e09cb119f40446957b1e0a060edca21e3ec72e3defb94584befd61e0bf0c14da05a53ebcb29bcff56ae6c76482702a70a7242aa4f6fe6eba011afce208d8a56239ebe2ada898b1123f650c12cab83531dc7fe30af17627ff3ac22244b80785b9d3cef972b0b354be2f6d90e64aa68dc5ce00c4932acf3ebf0a320b2e8b957f3997d23c8db0ce73b9dc28875685548d493f3410c5bd1345abf7c8ff3f21b565d6a8b7a3230bf04737db26b9b7bf2ced72426cfba6af2ebae7bad19f4f5e997a06ca31528a45e888b9489079a52b2aaef67c3e663ff9630a7a3092e112ab4842f38225ae2ce0ef83074215e000ed5514622e1f78cf6112f3eaddfcf977ab79370ef47935d0354ee0b73d3cf53867f73494dfa18d8c0a45f445d27dd3a6ad12a6656112812a5974507c3ed2fe1fdc1378e86b19f6df850678382cd6c55bae9a1c3d178bd3d3b302586d38d91cdeb2a55b6b7b3d2d557c16abb2e844fdc7326362afe8fbf5c8125487e473081f821516293abf671039838c92ce2a801735777270728a8e539e39d1f15dba83fe662970f2f5d6741e260f764e4c67bad208c837201177946a14ba860fed922aea964cb46ef3d7c940fdca26cbf507d8e8a78bc6bccca1df6442e29e9fa13509f32bc9fc79800a191d82ba493b53439645afbc3bafeb56fae735280ac42cd761349f669bb76cc811d7395f11506f0f4e9ba2a918ce406b0bb290022cfb1edcddacf1841071b2f194e280ba6884350d1ebcf4899894deed4a7057f0f607f2bd4c08088d9cde641cb8e6f2f6f96f285ad5fd16bfa991bf9f88ab039a2ae3ae2980f1a95c1fb8580b3169ced022b582caed0abdb0859479f1e9f8f70de4bf487999e73b32aaa63eeabf9dedac285269a62aca7d9153ae8ff5ad78add825f79c877a6866067e2a806bcc1c057a5c747f3a10c7c8689c06e930d0230e0a1110e6595a5d61f34e2fc2360cb8b6eb88f018821c8ee95dbbdfb7f7eaafdfba0d98c89aff5c3380dd6d166936069c8aa9666469fba6a1e5659a174db76d72cd6b40686fd4bbd7072b2f64f16f20e0b696fcafde00de913eb33ad6e729153065b42fee1d44af16c4e248e057f826772bb6c966b07dff1cd59d20e3b200371384c62dc9eaff70982ae2b782a28e1ddd1edc9b3e21359807e159f69eb44b864d6abb11d9c25a29071eb51910e17e6faee555f4e0200a081d9ab20b834d2a7303d9234d54c5bce444847cdda59e581718ca17b39a16de6aa980719576204acd488eced471d7e1cb67c1be4e1ac961d793afbf7554f1f38c513eb21d29af821797cc539843ccf8765e24a462dd0f24416cf1a6a6ed5ade524cd51d1b7769521c2ad73c218dbb784c2e619959bbd9f91020ab49df92f5d583d21e91f50c7c5af06439eac8d06cf280334bade1d899f4eb90e8c871b611e8afc17a41c0a7fc3df60a1efa5e81b2bb3c6aa5ba9b1c4c64608faa3a7ba524ac9346c734122ad5977ea21e9b916f25ce7b0f4b2017bf16d8438f4e339dda167950801e3cf34d970520ae48a4f2b03c057a11ae1c43b3aaa6297f6346d486bf2162cea1863859dc36ff0456ce5ee7795061f3b7f770419f6a76ffe8936ad1adbc08ce266a8782f041bf2bc96c83786ff82c8994ded21ffb89673c43cb371594f2023d814c23fa8a204233e7756995171c0501e6a200b3699b8d201a57d3d45fa9fe8adca5bef2306d01d4b7386f5c06d4ecebc2340d9f60c2c9187e07cd97fcf03b0f1bf07418ce88f3a7e7a35c2a371f875ead785f5a5f0a47aaf12b0b7d66acde4b644aa92733e03b488606ee3f3e2518541e363ed761212d7652066ee9192b6e8f424587b52dc074a89d529af9a44afcdf3def681d084e45ee476abd0fd5d9981757faeeb478fa5b82abb855a3b583890d2ee769f44a6d2d3b49a0a16efb730e3f480ba28b72e723bb8ee9f031c22b576b4bc8643bcd042f55e2784243180ab441f57ffdf627f3c560eabda08c38e91e6c076461d922eb1f38fc038ee1c57f0c6b1e15efec4b8d17740a849314a5b495d4923d24e8bec6c38af441505f5657b6b260fcbe32b27fe6111f423f4a9f01eb43e60e2478b384384981ba9d95375acd94d00218fe02316c4bde09e4c6bc8e202abfc9bee8a8ccd09df2285e03d5b0706ef436fe22785877594b4ebde578879d1edfc4d6af6ea5a8897d0db8108dd7b90f2a2fb4ce327d2b6290702d5b21c7ecbd52c630d789de8cc8291db5f73bd0828eb20b7d77ec00e5d5c1b912d784b065d4c281fb3b0cd8d008432825ff2d3d07fd83ac5fdc096d13a75388b21b90bd61634098317697653c0432b74302aa07b5dbdacadd3d4be664ac7eef479d61d12124c7d38a334a1eabdc2c8025a2fa4bb53074e82e729cdcc9ec017e4d104dda6132b81d01b4e40807cdcdbb6265af49b80f74c6911c0caa81f4eea71e046934c4979d2cc131c9840492f774fe462f31a8eeefff19f768e9fa5599059a40cdb4d77821af881f1e9a265dd4f6a3daef2f21e941a0e555d5c03651f47a63ef848ae74af32a0e29b5ef70bd765f99ef2a0cd9dac6a1a93432bca63a0fb0e8fb3073533e96102c6a0160354e7df9f694204d3e4b348820026ea3196bdb299c0fc815df481831a39dce76f2cb11d7c188ea40ee5d9bda906d25fa7a56736bfd14e77405c28abf171df268770b728e7f8a36ea022a3ca2f9775c054f87d6dec35ac2fc59d90070545536d36c3fcda4a92586362595dabc3821d2d0c0a7da8e3d0e83bfed37a39a012dab8dc2ac53279ec35636c45cf8545988af4eb31fb437ddc007b929a50ac4a4cc85fdd347b9ecd088ed436ad72eb7718eef3e899d462d5653fc39fa95fcd7cd9618fa3aa7914fbdd4d6a9575fa633941c6a622e7941eee4800bbff0c3baeec88e2977557cc54ea2c2dd02080896a9b923140cea7b9bda011f6e7ae7e1ad027c58044547b6f7570e55c706acc047fb22548913e3d9bece149a7da53c386586d9a24370d5c9b3cb6d13ed003c3fadb37a9d47947ed83df0907abd1700584ad411cf42635acb50eb20d1c49618564fb754f797027fd102c037175134092f5f74abe9aaf7f64b42dca1670848f10e429908d62e6a3a04eaf80b572e736adab6fc4c22130213f84b21cd51b5b24aaf7d91b9d3854e9ae659ed3ea5b68c4c4f7f4a14d2261552b1edd1dda0644c236ce96261e43dc7874112fa61ca4f632b095b71b9e424808b3f23a99ee83b717aa58d74ab962493f48f877f70c9ec0d415b5793abd9568a81ad40250e018753a657b56a58318d35748d92755ea40c1ec6c5ccbdbb1005b1a6a0ecc2f2c2240ed4a937845d1574d7ccca56c0d14505d71c2e0f9ca0bcad94a482f3e430f64909645c564d45b8f181b023fbf44bf4f2bd7ea9e39507fc12d6baf7d6f17b5d3cb284543737078357b8ed21b93efa1af6506160fe7a20722c0acd34ec876224e5ec1380e4057dbb7003baf49d483d6360fd19e0a480d2c3218298ace809dc4d4b7ac30705f817e4aa46b41e62e4aa80825ad25e519f9158fca21b56d6aff6ea7c5a7747063891d4ead586b2a56c23b4647f9f146ee88745e2be52e97ef5116125fcdea5de78e071c1f17e4ec7d3ea672579b70789f5448faa7e601889f9cc119df0c19bdc3ce09bfb13cafb904583665ca7239e43a05f617f309b5d68b2ac2cd299b01a4d135f969844d8abcb9d85e44899fa74cacc07e56258c9a55c16bff9d132c4c32ca25de37e999ce2d81692332a87dde9afe8c889378bb6690bb206402d4d7848ea98e0d32bac6d4f13dcf28eb247e80b79dd365e0d6e45d07091f2ef565b8444d9471ec6e0113e21fb5e2c85e5d26a3f23251ead57ca8d7b0479dd01a6e162611861118abe47e7e3c19b450ea62c175e2da705f4160e09b2dc67e6fbad5ce91b65b9633230420f872e0168d2d03d9d17188049e7d53b0d8bed644fb85fc518dd0257cccee960b4719d794c5b88236e6404bf8cfd73c4c1edb1842304c7c9030baf145f0159fc568f975b97031f9eea4212328e1ac2146b8b76033dd3b5b8c5a078a1f649174598c8e4354ee3260ffa1a1cf11f951473f724ccb0a1a912b351d93476106740c3c860c790594b08b6c756e6665abd16805395e9f632b9f19f7fcc5fbbc36b57db8584d47fcd71b97d49058f591ef3e049be905c26f3994e9a3e35791ae3d7beda6df973733cfbb46585ac96a0ca018e4c24d6cc7d501a200751ffad1f97d50f69ecbfce1b2efc95aaca72e7320512af69718a9ecd9650e1983bbf1c9baaf450072320627411d60346aed5564721429ad00bcd775148d1c1e07c16ed23ca5f283ad877aeda6c944eb10bbdfda53d5ba3d604ccd9c5c77825e73edb4c211524841d852d3d9a41beea9a6f6b7aa40de5e83d0483f660c1e8d073125c32312bc98c392af1e9cec4639b65558cd4a70f10b1363f1d145893984a84cc81af37475c210a36aae2a163bd0db953dfb377c89c88db5231289406b0c2852bed6e4561858c3f46840beff0c54b0ab22a100584e8bda26533bef3c8e7b5b4fbb4913db5ab7de6e1dc41d044d3db8909b53b79edf534650f2b479329fbef95256ea23a013e0d1bd71f4c7a4a63292be2443d710c1e531dee9b0f68e1d12ded6e294c32a4361d5a1be4f8daf8b6b5464a6d2f6f18bd9d4f0a12c42e129b984e4042f6fa7ff57ce95019abf276b5539cb22e6bec50312e8d3f5ab3189c99382ec44c4f5c0d1d63f17b2156a91cde8e24c2a6425d2688aa751f4f7dcc6a91384d8432ce71abbf0b927cd5e4e65505c77a730c022b9f74defaa60b3e024fc7aabe3b44e9a834acd513558524a76311d1b2622acb8f0f3bb6b2aaaa4a870c37d69114e8fe607883db0fc0378bbfa2493533e5cc108d493360a837ae64030be324331a4f3001c3af38300b58a0808351513451255ab64ae4c1827c09efccf242cf535e13f3e7f99c8295a2c46449af7a6e7959992f73fb386c7076be269de53440e4345ab6e2c4550de1cdf27eca349869b26f1b73d4d0a28780e6ce1183b9b37fcb7b5360cd355807003c53afb1243dd4ffe5b833a4322c6f007fe617a3308f96376eb6f49c1441b46c6245ce9a21b01cea8ea24ac5b3344a0e7c8c060930c47e7f3d3f28393c9a6af07319dbc814a431fd25dfae9913adf306c426c3d84126afaf342a6044e931a96ec6dad1fe2dca98c5fcc0466c048ca2d5df41d3aa2e7aa0eb22254d5a2a46acf3f86e3664aa4caafed642dc0d03efd6e984bf5243db79cc392d391faacb7645b64d44b7702293ae7799d97ecc765ad6502b7526c6ea0a08dc6007153292164644c96c7cfb6daa8def08e95f3f86fe91860b4552ade0d57573c89920b228e0467ce006dae0744a0b239d51b54cc2380a0220165f187c0e24cb4beadc2565420cb1b0b08f6a9f38e7b7f7dd9c8765d189fe8851553c516c5b7da4bea751516d4b36ce8d8580c3d48f31e81b271cbe2e184ca72e81f1b6a6c1cb4940f316c3f455476d13d4bfe7093ea60b7de795e06807393ed1a041c572bd024fde67e38093efc664961707f4194f8246f127c5ca20b468c2c9f3263737ce38394bad95308b48ee23844dc7a69349683b5f2403ca7e6de261be1e42545a337023f9d772353194cbe21c1f532d4033e7e81394eaec8ff892a034c7ca91e64f119ecfcefeb58a1e9e6e5f2c3eeae0aad38bb2125dfd8c3c26ce25687ec4df526303decea5483be5ec34290bf271294f7d291377e2da6bf10d743f630634b46ba3a78a9e23e9038f2cbaffe44b0c0812767dba39557de44a9563d61b97e8217f51b62c7992b7659ea80389abd7057449c9224ebfa975674cf9364e8586a025ce5e65843db649a0fb575bec04516974dcce72861044b35e3c06b27a59b503780e6bf7685a66db674e4039e5391a06198348d5bca120d0505d33d3f08489d1a323bf7b5f347b8c351d460d378e76b5d88f7db49fa1bcc41ebdefa6a85cb0906ebb5de2af563d38d985298c2558aba961347e327d0387491cdae0ebfb18a9a369e4dae29049d4f0743359346bd245f877e4d67ff214f555b09e6c92cf165c37ca47a819811bfc3b8c8a4c715110eb495c41d216ba6420728fcbee242e320c290165e5665adbb1a2b2c0d5ac101c67cb791a38430ef553002319120a9f468abc84a214e83deab444103a8a584c315aa74df8e00e85b447e278f99c9b6c61385883d8f3ece4eeef34db19b5745e885c7210509fade3ed5d24faac9d2e80b6b9c8145f3d9477531f3996d201b10f8af397eeab1437cc62bc704fba4d74a2e344c61593c9b63dd3eacfb55f8c1e97f9255dd63a4a4a65516602c27c80e689e1b55e7226710d7739f7bd8d4bbe4295eabee4734fdcc1196103c2829543c5685932d4021be1ed107708b8ba7a3e5329258421317f80833b26e969014248c662d3165c2154de9eb5fe2dd1e8922a5c83d3b28ca2e576ecf37fd42ce530763d136b2b41d93cdd2c937dade6c0269b4dca9fc0dfc921130e633aa99200448a3cf8f5a5f52facede76392ce10f408b974e0f5abe2a3fe66e350166e7328f3af1a1a0babf9e8762b3611409c63025b9b5a9b51c52885be6e2c60d5f26f77390037f5fd09cc659ec135c04e5b57b1d57e56bfad980d81c0779b4774a05a0fc65830878eac06ad0010ac9da47f427935c5794219b0297de6bb402fe263bda87005965a4bd19200fd7423072db45ecd73b61202d4651b4f2b0a134a73bc399260fed4bd946e991e85b5bd0fc8b9c7bb3a8db143e05fd2472ffb63d26d9404d2b5b3326945f1438cd2af63403a0267d71e9115747b491f7a73b1deaffc1640bccd80bc524788295ab7949a2e233b6574b06bb8f1162641b1c53e14bd8b5d606e803f91ccc6d7ec1508e1f1e841aaaad5ffb88036eca759741147e5414f73c1f43d194758d7fc52c8d982f54e610761d129e42bea60a75867a095b1a9866cf94fb4d7a5ad1bf8cdde6c1bc14d492779dfb479d6c2557cdf11d70db7c9539f7703e34a937f084c15a94ab1b222812a8db25caa921f3c1848192eab3f09deeb61e8d9c6c9d487db9b94a0cde75944cf32751395f8dba078d8149b13075a4cac46af0589f508058386152fcc5de93930bde3fd023c2cf9bfd16af7c4d1182d16263f2825810b0688faa79e5532c23f1af5b0863b5e1b044dd739f7f1e0ada2d6b05ed0dc71445cbda24f33c191bae4c492bee1b7804af596cb19bad69e37e98807f132ba199c56a7b540d413755a01514284a3ace27af38035f71f4bcb45b18ebe0240eb5b9842057aa9eca25243721ac2bb3e4482777f2a57a930ff43a4db39c515b96a42b95c81cfb483cc88e0c95a36030f6063c9281c1f986c288b29720bd1db52733a474e0a1e51b0a02edb0e50b74d93dce6a99c281b5489ef3831c92415181f0eebe9f5a9ffb4a67dd2be499bf6dc0333dc5fc11444315b52cf9f82328ac41b1575d5b4e261e264343dbe497d43f7c0329764bc1725b2621680ef04194beccb82a1afd3c1e47ba6378c2397858c5172925ff7738da31502717d21b6050369ad82b7a33f1593ccc322260048bb5055a33cb34d38bed290ce2414876d7dff9532e9b9c659f63adcdda4575368e55660770a90f2546c16cdb2625dcf4e61c63e37adee570694db5d68e40785e4542e2015aa1303900a1d603ddf0b510b6d8c1d02d92b1cb2130edbfb151eee1272e103629789e96786c9c3e0ebc67698e96af52e817a11d90d34e81c26d5d653be8adc9e981d67b6c62fe49f4148dcb6c59ec18f4a60a2444a256d0dfa3c33e05a0ba3f32509ac56ea14c1cc6d5257544c0bd68e62c5b8ea2451749eceb6d54f9c1f29ed6bc5b417f6e60bfd1d7b32782c7bc6d9684db142336436f0bf3bbc696c6d150570a4bd42037edaef70fb2d060cabae86746d25e929ce4f3d40ef6099393929d98aaac9a78c7a59be05f38b8f184c996e77c32c8dd3248af68b5acd9c98611cbd290101eebfcc363656047da33eb2c7b6d2889df691d983cc3caec23baa15f0b783bdc26e1f4c316ec58b06d0a9a25f1a6c3262814e5f38b1953a904e74af81be641b515d4fe3aa8a9109204ad13d3bfe3bf9d6b0eed7cc782651169e4d7cae39166d9d909e463675d08fc0a80ff24d0a8261798fa1cb04449cd7027b6f7b7ed18f670771d103c58b5934d792ef69945efd479f3979219eeeb42a2200bd6bc778a12d06e4cacea264003ff7fe0ff2b98164396ca7cc52ed3f0fa81616250b2d75ed1584786d85273f4a10b65126754fb9ff01046e4d7465fa5de141d1a3d00311a25e8061399261f9549e868f939f26bae427b3a7751f993e87d2b69eeea4b56d0dbf2cb2340e53957af87f5d8662d21ebd17303231e9060944b7b8f6ec8b08ee039843d608eafee8b64960ee46e66933dcb265e8e6e8cfd35627cc7a7843b0da53ecffdc07a50e883c3ed5592137ad9d58bbf7ad4d4a4468bb82d8ee377456218c3153158f451c712d6b2cd63b8e455b3d19d5925b7efe93f5b82897fa6ee7a15411872c0aea1bc21ffbde42d166e6e1d571d0099ae82dc602e6e834c17309055a52624be233e018be2e283a74b053242b8e93f243b3c521d30f9598dcfacf61ac4d60cbe57e400910c3876d8178af91e81cdbf7d6ff576a130ab3bc90ff1068e5441b9ccb0d3044f3f402260f2deecc2ba53bc0751973aafd370b0bd8ea3862890c4ec543049d4277010c0154428fe7794577d482949d65c5e4c7f0a2676e40e1819ae600ed8d80bc8a9b205470df7c51616b0b0ff7bbf34403d6c53acd36f462567f89953900dcb82667a9a6f4ff903939f093907fa35daa207a192e0c4c637a4d07c4dd6a6574f2d1a77ff55d29c5d98c6ea59ce6522f42e57dc6dca8923fd983094b93cf84e1690b3a4646f239f85192bc3e5449ee4dd879a10e1e887c072a074622968501b63aad2e92c99780731d630d09f3c51d91b8bbc8b1406fd81a662a8c4072c5e61e3f48fb970f72fbbb214688ea066dd9100fbb64ed957c7600d202eb53da26cd0130cb0d357394102a5c33c26d27e6a361fecf2106fa533d4e0d2c1fd6ba5ae95b4a02aac224b3ccdcb129700234dede0841b671ad1980eea63b73615f2eabef53b31960a2600c36e5e2f51737308148c3462da3237543aa991727440fd8b8627b833966d41027a56d929d730f1d826123dc94cbba1a4a5aa1c9a9a20f36dad7b4a3ab1b813d6ee424194e954502410ba2f53bafaa04bbbe71a743d626d763251edc463f4b98236e6e323a245d654a937739a59f2fa87eb66f25f41ed7548f0d6d9906f37eb0d44308eb4f8f46c73eb23d8b73d4d59aa7cf3fdf63900c1235b91993b61fe31a8cd5af0fb19ab473e10a9a6b8e8254279921552b45cc419e09449ad00a74bfd27ca91bf4413603d7cc7c15c40db1960ff991d622563e8f115c8eb6ed826797e0f9e559d9cea32179e82e7acb48e95dd4162ed3843951c161923cb76cd2b83456d735f82e65054e9ab2091e0dc26b22c087440c10b90e1cf38b32e6924e7a159509377b862879e536ddb459705397194092b125a4bbe2323c84936c06c1deb2789ccb4144433e3ffd5306be0aaafc2421416daa613264d67ecebb966a52f5971949f8f9b9b45864121285097d80af6360d08acda4639b64d05a70661f9e200074231d5b0a0b43a12aa924bfd2fd43b0269f12ef633dd83cb668aea60c7a726dc9cf687ef4e15f29dcd3ced8c86fe0301bcb61041d9902588e462461c50f14f708862c9ff0d430a78fc8e99c5418cd9fb1d8426c2fba3f1f2032c0ac1bdbf05ada714df747326563e50958e46942358cd92d05f23707fed95a7a3ef6e5fb3acf6b79b8df40179b10f95c64f51f65e7faf26c75f84827d6fcde042fc721ddde4cd77b904935ad1005dd7819966315c8a904193b6fcfecf126852bb17159a976abc07cfc9d0e898daac1035dd26d7dc36b10e2027d30f5739950801e83dbe877351cdf6a0e7df10722c53bef5982e0f0fedf92988c8fcafb2c5be30eb6ee3df87409adb94e09da1e8ade96e9cc9b942567c81b7a67d1055dc1dcf1b49297e06214dae7b81a6673eb24219f457d8c0e312c659a09cf29d18283fdf171a304d69ddd4015415567ae277631a90d24751c7195e330ce95c1a2d9816b3ee14d0ae239a0376b32c02ae4c303bef6c7814bccbf3149441c9a093875467ba89cce0312503440d7e1aaf2f0350fc096881fa5bbab3e0521374a809470fcf0a033a4251c4b4462b56eb51a3f10ad033c6d5ba46b797d07f113bd979f19973b723262e0ed931b32cd91f5dd97de78d307869eb872461bd6633e39e3e9ad81c58f4f0099cdf586d03a03b253d1b9ba37d4ff3d8eca7dfecf449f9f7335911f034f6e20bc829fbfe5481f33d9376739f3ad884ccbf108846f795ae252a23201d88b1ac00df5ae0c6567e916482860f01e019495bf21ea0c6452c5a3c14cecdeac4df7a96617429938347dc2f70c62f8332ec3e33bea5b48840870e49dfd8a44b8d5baa95192b6fc3e8c0da3570491ca7c4e4184c95de77891f9f1d84d615eed587fcaa01f1d789509619362e599267e6132f23a0d1ba24027e753df3a67fa36899138708b4f1d61b60b8fdbd51f701affd548ce8dfc320dc1085fd8de736c7eee1bea512bbf1898af13f4f5484a364ae427b8a4f1166c8fa6cd17316dee2f5d3c259bafb3846d4008c65a6b30493da1a2e4a2a4482a77ff69a604a4853a8a5ef64a4529bf234d725c9b5c57bb1ae64f07546f7ad9d2fc9600f60f7b5b79e66a9c64b82f69be0d2f5fdcba2b29a00f5b580a750041222b36761861511fa6f4a4e0b58f629c553cec76c4db6063278e33f3bfd7938234b7ded9448c8cbb1525b0b175a5720ef54bb7e28cf7e3397fd5182e85005bae4da34b4c16a50354c7a3734c08c60fed2032fe5032b863f8e84b9bdb25c0420f1e7d0d3352a54fd81d52893f63f9e364621765b150b3616135303e68e86758da6200fd5927ccd3ef6d8b7ef1a19526254900599b18f906fc7ddd2dcdf14e791be121a65b5f2f8a63f60009e324542673a536f065db63f15c245b842c99041b7a2395896f4b238dbceb32a3f5ed8d5ca0de88f83b6c035c5a78f35509c4240ad480f9571149ea22b99e8ae9d3d1ebc422cc0b49662e99756fc1392927a8db7be24b01a97ec138f696bc8ea98e6ba7a956a1fb4b4f723c5ed75dcb9a78dc88c91373f2c05c77d2439f59501796c08ac32211bea1fc486cbef5d53ddaf559b09bd137e5a92dcdd65c4071de6c78ac087cebc9708c9b6a39b684f2caf0e2e29c4e54781f6071c9a0a2a73f29bbd8857599aa0ab454dd2f864958120ba9cd7ffa6f167aab19ba01fbc11bb52a232b3587e6cc50a6ccda7b0fee6d3ad467d835e6206674270be3c6a2c1bed99db12ca2ef03d8c8db9515716f9502dc29dd66dc272e55812dd7c7a120149028efdbc3ba7a845616013c7628084c60a9112725287d604589fb836a8e516eff618517622676c65be1bcd52beb009daca3b763b6cd426e6604f7d475dd0164fa80bafd4b10a1334a2fc885c1e6582cd3b94b8b14d09a93471a39850c07f908fb17056d659d2fe52595b0ce569ee9e4c298047755fed60c3466cdcd018636e8c9b3dbf98f00a08b1b795ed31f9d9bb672c2e0ee0776728846e07f8267f7d3898ce415119809e223dbe6372356d2491d2996547b64fa7386f2030668cf01429e2d659a4ddb7e0e22dd07a70dcfbfbcc3c608d3762b10a01ab6e2467c6557df0e0a20f9ffb7c80bd06bd1183e3349b809b3f9e8273c9f09dca8f16522a4f4e35e3f7099e3893e29c33aca303193a4326ef07bd899db0db172cc40eead065c58c4d781db5e29f156783acb1a3422a3313348cf50da88ace3d221c2125e26dbd9a1afdbb72b990e628a5947a63490b236b6c733375c23ad51dec9f8ac023d3aaedfbb3dda5c749445739886beeef7f0935e42c3a4adf289257f2bef3d69258459d1090fe7730b00abc01b074135640764154450b447338984b7228629ad1ba43cbcbaee6c2609eb056bbd145ef66321a992cc09206dba4a8ea79e6e308d0c879f0a482bb1c6b458993bec4025b303249d4de9f6d19354cb09de2d14461182faacf7fe2e42713658b9556d446f387a442326e9c304e32c573e03cc3a22e612fd67b1dbcb61d2a6489854cc6abbcec2c8b99d810999b096eb398cc2a03c662e90c05d3986ab029d53fc61cbf8aa8f8fab6d2205c4fbc9a6e607828ae0abfd4029e27a480e3020e0fbd9692aedf59a4c1d0fb64cdeb883e397b4804353fc8e71eddd6fe2e1e95fe93e8af6a305d13f8ae8490b2d8d42dbe853853016de745125b32d05f143cc2b09c654c879e9b52fa4bdce445e59732e228f5ba4b1c99d9bda0ae02ec0a380e196d3ccf9f864a54987d0e04394e18827584b80910bf785c61590b83011e412871f7520d63183f8b7b4f62482b7d96af33651b874a438548fbdcc6494b126f94f8e537ea350df75b82e4ab47db3785319d0632995d1d7fa14f0f5b274d4848d468957efaa56da69e2ac5d672522344a1fb0b076e1e0d07cf90d39f60d933c31a37fa1ab341b122a08721c8fd0c24dce5103fcce822acdbfba8443915e4f93b3dcb71f760caf5a4b4202d808d12a09fa93e7f903d88edc3807873dc7f0496e55ed577c3f1c5740c95eb83778a03334d65ab2dffc3c7c005297fa14c70bae53ae44f5262b000e0b2b8a42003b1a05f121671d96fc2a9279998b726cb201948e95476c0abebdbf80eade9b0afcbe356a0089254a2f71a4930f784b4edadfc2d4a5140c9bb36105f4e34ad86262fc1ea1b6f5026d442f8998d756348c4b9d8ed43066340a5e0bb5e5a18648fc3887e66fd1b2baed29d54a799fe1cca70eae093d5c4d6ab61d09faf7adbb3c2bbc5a7909ba728d69911edae7d4c78045256b639ed8a377d6ef7adcdb043dce93f483bf8b7bbc8bcf00521a06609c785dbf356f3e0c7b33300e706e995c6b7da087f546d4084414a30e42780a1595a820ca670b499c45f87eda39124004662ea894491e820d3296f278ea744c1096cfeef1dff5be18c302ba02e6098eeb7c2c86fd24eea92e2402298c241196a716552e8048bf35de996e619efbd28fe7a0608a1e507a83f836214c6ab2f2152c3e3147c75091dfc718457efe4c90bdec161b0bd02022e283190ff5812617abb59bcdf944b11df552e9e7942c6c05384ecbed3096e27694aaaa854a560959060c31d0c21e70e7e7c50c423ab9d1bcef6e6032ecb3ec8f4e656f659e2f2eaef35dfddf2762eb09a26a2479350269ba2635ee583e6887a58fd981a0511993d76f7b98560eb1ff1157958727cdeeccc39ca7a60b03181efafe96d40739ddded5f9792e5bfe3fe85ce86daf366263ceb6b614bd8236e9891ac06ed70dfe4754ed188f9c8385d952c1e1f67531b4ebcd4f8c682fed5e106f507d2e48a72c537de96d7c1184db59d90f38eaa89666c5457f6381a2bbd25bcbbfae61c34bd451ee89c9d65e05f7648dc8a6b189b654ce5a34a09e4431ef2bcdfa44bb454cd4b7f2c7f85ab40094fb0f729e4c1036080e8bf7a6c2690f0b99402dfa3d73424ee5bf6905cce375d795ec892a2c0a3728a1d144574b1bb9a2bc986fa818c933f5ccf37f1fac8abc286cd1fa3f8e4f501cdf8f94f9ea6a8c521f1753c156a1435bd785fbbead5049c20a44f9d4c667024e506e079bea89c3bd059ae6fab6b1096caadb37ab9a6232082e5ea22ce9ab4a0989755d81e8f9195c907ca4f26871f664685b9c32160300b28a72a97034c6014191f8551c983b2464be7291830034a1eeafe327fc4accf6f3d3d18c71df36eb4587cd84672e1158abdbaad9389ceac726330ef4b44a3ef5213292a6abcbe35b2d283a835962122006bfac409a5f25e9c635596f3c18301e89f19ff84c99ecabb63da7323f326883dc47eda08e93bea7cb56574869929fdce979b3b7be726a267343e679485f32bb68f71e8ac18d9c1ba30cdcd2bd35419fc7cf161ba8c4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
