<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6a1eab22d9e47d175a5a85383a6edb63e8cec75b26edbe7142744ceb92c165a8899c534d0da98f5065b3f202d08ceeb6ded833415e6cefc4c0f2031bcd526637b92f66544798ff492bcd9a0ab71bfac5b55a1f2dbc9cacf07d0beeb010ad61d3cd3453668bee812fe23cd454ec097e506925b4a60e1a30dc97296f5951dc9f7a0a9898441d62f6fb1d7f80e9e2f72da4c1005c86c1e37e45c48f7b6aee1a745f4ea77052107acd08b5022b8a49e7d8b096ec3ad4ee1c6d62198e4d485b231342490347425156a36222c1e97d7c7d195efed3ddff9193e3f187335060986c15e86b69e14ff9c2800898bc6b1ad94d10b0f13de27fc0fe110cbd5c1542912f6abef41a3212a993ce69ab34b36ac59b5f0990c1094f6f671592efcf412dded3a0074d46594127d30dbccb5f7cffb104dbf613f18644646c61453dc4a8b2459da0cbe415efc1b1635f4da13ee8fd15587b26730dbdb1151855270badb8700b82f05f7b03bf95d24219534cd6d0fba471a329cbb6240663fe824286f5210f7fe610ed46dfdf1aebd5c3b5873c109c342ef2b3d54b2c8b03e89e17201b92fd15010291077b86bdd08436d785cabacdad9129a78707a0d7a7762efe8a57bae1b15a4ae467ceddd5b0e2de9a21c32cc3766bee3085b3e42b87c09f6f06061ea6656232ce0d74f4ab621a21672899af0b1e50cfb722a0c6bdfca19030aaaf7f3b216b0c97fa617b8b9b6dc69fec76318b34ecfcbf472e3ea7e5ab1e7166cb39787de1d93b7fa308ee3faeb5614e9a91b8eea569db63d1692fa049e4fbed6db1a508877470e643b0cc5a6938302361b182d33400e29db71d30705267c1181b6e651acdefb004623f804262ab3477b4f6ab031b46764b82e6f4c6e0d066956a53c340e0859ce57a91e77ba97532fcb908406ea1ea6ff35d921563aa16e0260991a97041f011ce3782742cfa08a79e17ef4ac9100da51db5b4bf27d954c77fdd78e2195f36f1ea9566abf75c7e979dac585ddf0eab9305549cb1a055c1878f24a148859249da69414c286b643b1911ec6d1f30d14e3d41a6a35b1807cf7d09284b743f813a967c5eaf24f0913678f2ff4ab031023126377561d86012c300b00307d5c277e7585aafa2d1fa317f1b8991c44cd75a2e8667892b5f3b3336f9db518e4fdbeca8e32b183bc0c1459136cefceace64f1a21dbf41de1293a3d10d3dbadd2c0831e46c46baaca0e4e4d4e2d0def90ce773a2f3172a49c6ba10de80956258377069915c30e81c6fc87e7df15acbb6ca47f295da50101f599c97a19afb79e883ce9f7b4b31ca03f8275ec484fbef35b2ee86ab3369d804a0dbaefaa272c1f85593997e54bd7a3f207816669ec12f7a3b11154675b57ec8866a186f403d16181c59b0a80e3de22e858fc4266e3921db4f14719c3738b0bc531645f34a60bb05a75a7868ced780942f11ea06ed31720b645c8b17f357a798eed46744081d1912766f39b30d077f524544261aaf2b32f003587e5b0267b532f23ccd747a97c2d6ac11dcaf6ed9c785291fd1b980622221b46ea0e1a45430fffbf50332c0d1191d7c02600c17cb53c85c1fb21fdf8d44281ab8ae92d8040c3789898c53d443fa80f69f213f5d76d6ae3faa6c1e5ebd3c2811141a4d75e86841727329dfd2a02ad2b710b5aa7795f74b13a6060eb7f5440fbd5c39327a521b89eb4d2db23d4a7fbe2f0858ef768d8a749e24e01e9a124988ad622b33ca535168480a2ec6a4f040f9b8605b35464893ab28368679898ea3ea3fb546e3c5f6989cf4907f178637a28fd47fa09a80f9a8e26b1a957c9552031a323e7b431cef73cb804b9bc3576c5dac4ce3d7fcf9a16611edfbc9a91b970762668673efdec4202ec3b5118828b0784d2f55307d532f80475e616535363557156c4cb02ec74c41237e83518e4b7832d35590e6fdfe5ad5d148c2894af99db1ae5c2fbbab5f093490c1b9083fc4a1e6cc618e5db77221cdfe98448a7e75ef206b4ea4eaa488f2322c603936dabcad410d68ae0e417cf1605749900753954eb07720f3fd5cbce4ff9f065044ba6e20d2cc0ed7a2eca6b2c0e5da1e302e75d50ceab83d58f9ad26dbd9721c3004b5427bc26aa09c3bbb575f2b23aeabd28cdb3b16de9193fbb6043062e577308638797b80cf74bbf81a331d9307df75c1549d88eb77e9fd287eddaa6cdef4d22bcad3af60b5490fa767fd186529007e1e59b6c748bd13037cb2d1251d3c97c0a5b177c051e0732c672d7156e8a70309a6269e0cf156eb89899f4230a64d428f4d32fdbd03d3eeab8d381d665541f7eb5e776e51242fc51e172c3a07c028e06975bd04e6c9981d5ae72d2247e60a20b7172bebdc68ffb31939f0442a7534fd4805388bc5ef977be3372994613c5207bc7fd9664abed1fbda8d7e68c54b92b3a99e15e575b9134aa5160082e7d8ce38d606bd083c29b9063f2b9c52a0805d4136ab7ad6115571cb751b4e1a386fc50bbae959ab4a29e580954a586c17b2ffefe2f985aa254de0857ea2892537e46ffa94b0a017dc08358acc31abee33fc6830dab5202e206499feb88a223ddfcec3713b6ee0d191aed41b115ee3f4ae0d9f07801ce021703a2c892fe5d0494a5e8ae2be1ba560e25d4b850ac0431a47ba837df9a274e47994fe1a026f7501acc4733016c81baec4101bb40c24e7470d6568d293d5952c0dbdb65f9f80c477c7ef20421065e3800a714f3d8ea7f8f802ebcab65a42bf0473852de117db21089feb140d0c832cec6abed7d3a43509db5e909116ec2df2a144b877718d66702789d5f40eeaa3f539bba20178300cca259865bf2ef661d5e5fb14394873476d815656626fffd69b4b9b4123a8baed947edb8c6e267cce76f6b2cbffc797407f3ff50cdacc34aaa0c6935ea2073eae55b191ca05aa2eff956c6f7adf99bb034e99f23355e1cbb00189b0fe431fa0fa10825f1e65dbd559aa0ac20d3a12f0070eb6c6bc52e325f00b1a525d64d6a74279554c386a0472424ad94fafada1db1e9bf778b4ecac286a571c6cba3fcff191d9c494da807f5c85131014066ecd4e8f336a887750bd1fd6ff7da85824a1a1b140b15ad88be7281cab3bf1712230488a1d31c3b7012f284645d6e3c8484ad145bf2d89240dc449890cf96ed45d45419fb1e3d017ba610469feadcc3b722d4d9d6d60c44695820ffc62c910df08ad30b01e5c09e17050d5b13a79fe2152c370a7d0a31c8b64664f56e6675a0e310b1878fcf2fda3a55c5d338c91e3066d9921a9fc3f1802a5ba62f209c8e91ce9161d2740ad127877f2036ee935c2a3cacd2a529d87ff6bcdf908e6b1c6129ea33f0dc6421f51d7126f4df699c58791e146bb6c3ecc5be0b047e9f62d929e865a47cf5882d416e41e9df5e27ef0e485e33b7d06220534cc964e9b6deebdddc89c2afd18fc2a7767c3b0ca584ed6d4e588fde9faedee5791f770dcd92db5a918f934e47be3fb11935b4e080d20f6435a1b988392c61c7af9c70d1fbb62d7142034fa7dc711a740a42368f4a1c4bd4ad82dcc9d6cb2fb0e01336609e95b16fe3097e901157a8f5559ff68a0968bd02011d549a738eeef1976a3d021018c70e067ff723df6b938102a00287eabe9c3d452eff8785f300588f3845b2ae3efee4791a4ed2b8ba889feb992a08995dd34e06bef8a9a0406891f5c7a44031e2c068179b5e5501d6e73edfad5c37cd7e4f7e76498a3512cd998f9acad58e993f8d158de8a064cf28b597ec3963291b16a05417b573a70e11ab36af9145eee6a588f2835808be73591b51708ae00dc8174e59de879d8bdf4f07ab5a78def66a476bac2c0028bb625cb49a315d005548f41e3b2d3c6dc74376ed56dda4c37d6b0b241fe1c2ac0b425a8efbff035b29762ebf11202696b9ab292d8f95ae810cbe9e1170953532851d288999bb560bffaf03710cae18cd53ab3f830cd60368f10612e25dc652407a25f9794ec2c270c029ec8f85d263f6cbd1e75cad15d183e5f04de1e7c2f6bcede40920423554429ab8cd9b8941fabf6e36767c9497efb5e67a8fbc187c0eec3dbb28539022ff3584769bdc76032a0cbccccac58f1f70664dd5d013f0793fe0ec49796cf438e7b70193abf8362cc16d6e94d1ef5e4efa62a8197210452352bdb55f78c212b243084fba14b87cf0bcd7ca61967c5ab5d5563b0fd3836bd5d600ca08926b36b80829e381a9b39657bb9799ca6269d4fe708b1fbbbf3715bf2a074b5be90fdeb3d51feb1213f58503ebaf08cdd2466bfaaa8b8087ada6c6a55400af3c0d45fb7ce37cabb77aa9ef3de2a5b10a51f0efb5010917f50297ad0d3e6bf8c85248b1bfa49bff8f6ee6df3f52715945b4e747395979db97c1e9ee93181c05a9d09a48353c6429084b5296ea2c3d821a0b737ff650631749307d220a2cff91130063d41899b7044ab5a808c429687117fa840f8b2feb8c781d4c588077b9759f9e39c870b0d123a3168b54d43af531ea30cf493f364808394347a850cba7f8bceaeabf182e863cf6f36a1a4e389a01310878a456f900c2651656f6f87ef33a78e428d66647cab2086e27e173e2c4c79959a98f6c0e6acf1a9e766e13b6a6a5e557cdec5cf212b21a77f895bd24cc997b8e4396a3dd0b78e462bf72513b620a8b5a8927be6d3521e15091f8c49c2dd887540dabac0d895ee384e67670dab0f567b66bec4f31be486960fc47000a1cd9a6d0c1834c3b7624a781cdcbd02b34800445df19e70eea406ac62691864139059b0a9b44dd3598f390e52400494e69924fad3b4422c0bad7abde964f39fbfa3d623d3cab49976267604bc4cbf912f9079887b44457ec9155c0bcc98a0e66365bef9767226df6b4e77de093e284ce9b6fd06b586a62d5a50764c5bd33375d69d131eae1f5c054683e93c4a6bb9f361f39cabf0efee2f14058780fb22e4c69c1aee8a670bafc2466d9a384ade85e71bd27f9a0a2f6c7dde7ff6e89c8bff48277ef08f3ddb2c254f2ed3f3ebd1816775a0582e3dbb3008872bc22a32fba4dd30412d17e1539d7f9a5f19776e2b8b6f53c4c9a6d2ec3633de420e7439df6978df76204468c6a6bfc52b5eab0f014ffcc769c5a4fa9d2a8805daa7ab78ccf41b5791e634afbf34e7ad7ad3e50425fd1dc271c0adf3615a33c92f027337742baab832297d02c2f944e6710424fe1d717a3bd1dab0ad51eadc6591441239045461c6e066d5e2725048984024216aec2af30e0188319527461efa1edcc9f052ccc7a475eec9052597f0a6ce541c58ec3948b1d565ca99ad31b151545287e00c5bb405e091857ce1bc89ebe416658b17d75911744021c6f9f6baafb4e98cba1233b40b342c8561ade970e9285f588b7a9c1dbbbf1bd93aeb8b3b24f678ce2e0f74efedc154eb1f6cb331d845ec16c1e7a13d2e1d68ba7a086056ae190fbd6424e0dc18fba5b0704bda8424c00cc7c35338696afd06c830eccfe8689936ff3ad65573f5abca9302e85e3ac71fb12debe568ac514f41a1dddc3bd2129bc9c50a1187ad7b913ebdc4b52260e1973a39bd4dae93f243e188c27d82543f5bc55d9463b539732666f26e875917594937d9819c78a6f389acacd5f354db2ffa4f9aa2977b194b0e3c409f3334c460d0564c43b060c8898fa958c4ec2d930d87a2b4ebfb6804ba12b84d64662d7634649fdd3a5cf6a0ec6a27971ffdbe931626a668948cc871d7b3cf79f0a0e1fcd87cf51470e6f268939ce19cebf6e6415d516617b45390d5739d74623b1cae64ba3d90ba288c24d245fc2f618dac2bed0fdafed566612093514a3d281c030634fd1b024112a476f4ef1fcae8a64fbb728b72d71b795557468de360b09e4da92e5f4da2cd35ba6f9899b8df5926313b4b79ba6f9a7876d39c5829af88227bb7e6e86b8828624e2c678bbc7fe0933631e922bb56d6b93812b3ed1133f74563d8011a00244fc48581ae44a5bc623b2584482d3005f3df154fd1e4d9ae965831cb7babb5802d6c4b70b1c1e8a6139672ea58012ec6f959ccbe97ee95ca9c39b4e79298dfbdda35b79f9ffc0193915e115e7d18fef94ae32e1fcf6b3510f4669aa4b682ccaaeb48d0c289dbfbb3b431a57c86cf038bf8603f8cb7040e996ba8b3de7ecfbde2c480a09222a31d2beec8b644526586a65867fc9e3209ed668a4046f173cb4008634c0044d6eff79e3476f13845290e098c0580433bfe7ad65fed238a33e485bdb981b9fa1bae2a15c2b1d83124f7eafa21ffc07dc69624e7cf8744c31fc752fb9876b51790a121399e9445354bc45a570826da0c1f09099ed7298a83d2535406deab7fd54757b5a6cd0b05c597cf3a7e2e54eb1a35eeaf769444136853225fd949b0362b6235b1f993e2faacd48124622b93cac6de716bb50a6f5eb35666e50456f396c794bb552c04a359dda1036a9e2ffec8f8a044677dbb4a534699b308448d706ab653e023a3749a4e5dd83d446c9e483183e54bc9beb31c5a72f85eb7f6d8b7a6c7c05e2169c3c4d9e87e63598aca7307db681d458e3ad484aab5a0872453d8d2a276f79760bf68c3510daa8cecd8b9d75090e72661c0d07245de2adc4a7c88d914fb9925fc66192e55adec1fb30b0ad43d0b1d3e8d94e842688f6a7424097ff7f2caab952c8d0f12d5e8a2aebe1acead4de7bb988b9e065dbd58c7d2440b822b97237c66a896dc5eaa578c85a92336c98689a6f7e17fd89c725dd936dbc384142e229e6b96c617ffb274a216111c3cab6806cb378d7b101d7396e050067b91d0b9027461f423260e1d21be7f119a3f65a717de4ab9418afabc73086447ab0b6225f55344eadae01c7f5236bcc5663ff6a9292f6fd7d4635e9e4bb399c7b5eece27c962412f98ccbb40d2147c611ba0c898a98dab7831fcda8d0afa99f377c2fc7c4313a583f5d7ec445680dbbfc310dd140461c2277ee8b36020be77c1b4fc5a818c11359144fef9117d7b1d9e225ee6fd3fefed5a9c59d6e9e3149c8ee4ff89b4fdd1d8c30fb60ff27a84c5e7dbd4f91f609399756c919f50a08ec6364a342d49a5cb024aece0fd71848728f1f6fffe0f2de7fda250c8d18bd5b5b4cdd402d9010eac3eb96fc844b0f33bb49326a71546f7be7c7e58665e63511e77a621833d2180bb2f79b561f55affd3e66604f58cd5b10bd97133605e7fe0b9706831a60d627c5cda56c8a458dedc9e8e38ce407aebd7fdfdba241ce137a3f1005a41fb017df7b3f538591745ebd6b0bae9da3a4b3d55f3ef5e8ab0522839d4ddd8d7379751e9cc455cd92e72ad9ab44735a406dba3e399f5e723d5da64d0ab0bb7d5abbc0509f4858e18ce806fd7f1c4c9bef190509605abf04ba496c3e8ef9ca66811c908941fdf2ace80aa7fbb1ade0b7807ff16cff27e0f1e44c979d9634dea7ea1948133475e74c65a84a71351dd719c3ed7456ed98d9eeec6f427fb73d8d2bcf62c69a750186fe1dd68e4f5b344a182564c057a3efe477899fcdf9cec2f4adb336c4b996e3b30adf2344da1be4da42fd981d38b665443abbd19f6f122053801b5b5184b3923d8b32a7bd4ce4ca0854bc139f94b6bd338789967211b97f931e4abcbcbb969f83226bbbb2ca2565f76ae6f33f6374c901e1879e2ba9953e2ac6304aa5bfb4d9e88631be1432e34bc1fd231ad185147564a4fe1b48ea9d978eb13e6dd3d58e80015d321ad42a69e45dacdfe1ab5b86c717f4f88fba5d060c922dff7152de32a7aec6b66ac574420f880ee912c18a68375e594c0e87429a0e95a8627467c43b3cd67acc2317530366400e87f2850c8b69bb91ff5277ecd51f8ec8ca137fc4958919680af01645b260f7235fb9b53015ba6d0d2151cad0a070c74edeba0d7a8c0abecf377a0cceaaef5078491a773aa80e8bf01498bfcfd9aaa3b81d253eb7f3ab0446ee91188133d9276678f94999709fe4e8c087371698dd624c6abe512b942b27d5f556c2d053ce637d486e7d8fb666a3877e2774cde9fef06788b1c4daf0e82cb14e3f1a6d06a87940fe5c06b71ba5c5715bf01f43de6aa727f68730f42bd172c190d48b620a463db9b5177e7f39b0f187f6c431e8b14dced13b5ed5ba48097f7128f9bd5c8549ef44b4754d79bca428598a476683b8b5b413675755363611c6c48c8260fe5364c9df43a7dac589dee210c0607fe27dbb2949598690308283b9890ff93206b8df087b92ea4be3bf39a7b862166ffadf6c6505c71c085232794a84fcd77e07c04edf167ed3efd744a3e3f20663b9b0cbc8540f608700518cac79ecf5daa820ba06c63fc25d0951ef90f89c8cfc8ca655e0854898d0e11f55a4417e6369160b113b252e1d285a1f52231a2473baede92ef0c55980329413cd1bb93695c2699b3dbeb775df3fd1d0298aaafeab3d42568edd5fc14773aba41af13d83c94ceaf6bdd7799f07707d2781c54af54524c417393321ae5281831bcd9be478df6230f23df982bc9ce21db7f4df490402da44430726c923850204737e73168c1a4af654c7be92974a1f9b3936d8bea8d41f21548f0b641f5533ee3b9168a84e5724f00393ecc869428ff46765cda8986f1478a86df915f97a46e2291e28d9ed4ada26198b011b51a5349d9d97bcb2f3707e1f8d335be11b5e657d81d67c6614d6fe8569eeef40f5472cfd73431fbe1373f94eb6d6ac81039b0319ad6178c35a2e467da19a79df7e489b6644a4fbe8140a88f74286e8509faae3952e7f6cb87cf535d661d49a5a061683590447db70d44083f07b01a09446f8868004946f5c931e7b77e3b2ef48521bf92610b3c4402c93cc8815eea2c279be8b0730f91fc151f4cb9c0f03545757500bc7335122dc4d011400f462e332eb0852ae1bcbc2fca517d00cad8c8f5742f3727039edcf5de5602f78c2ec4c94653a1422674aa60d4217de890dcd9b71a5411dbb14764b15ef9a77fc85b791710f12b0f0bed15e1e904d0b2c5e23f8f77a7d3c123f750d3cdce361b390c6a560789c7769c5d2a086fbf4149fce358977b1dfd8dfc5705b949199931a1dfa414ecf47f94c0b60e22f3e4b5db7b48167f05d116fa8449d7aae9281429b80b54e6497f63fb8ef82be18c91d595d3aa5afe3b4848bd1c83c41b613804e40de428acd7bde20d30302d5629419abbf5367c9c414dae43c6b1e2f3aee665f76774d1ecda3d80bdc354de4aa9b9f56f7996db1258ea55e6e04213558f663ccb6b6490044d90e1f00e9e741d8a33999146dfddec34831c12f7dc179d1ba31bfed0bc4fd6a3030c5cb7fbfc564c5b8b78e5e62391334c938889d4758caaf8db826616648806b94c237c9d7999901e432217c9b1674a8bc8b63151ebc0c962d36d09ee65cc3dec663661f6c96e49f08e7ec6e55aa3eb9a171f950a26ee76841754f5bfbd663507bd45edb856cb377baaccebebe22da90da6623ab89a4793913f5b49734f86ce45f92bc48dfad957db5c56648c059f9268bb4cb6ce8f86398ad50eae8aca1b03d9830fe9020fbdb54eede2bb92d08972a8078a40c965cef5ce0020f4c4fe3dbd23cf067fdc42c02129d97f58ebc0ac93003e2bba31a9fcbad8805e9d07de5bd2d29bc692bfd5abad09aa64a75f4483a98de09ddfd9e40e407a1ae10c9955962a757fca57be77d27c0a580e4a859072fad838191723bbf352fd9e9ec5adb917ff26a80ed9f5988e701a58d1bc260b2182ab05236424418af2e1fa019d7ab9b8bf28776e7f82042b9f9f2c0db202519dd1bedb7c618262bf296c6c07c26d3ce06eef4a8bc62cc4ff057fa7fe29bec8c0b6a92f70c790cff59014c9f77abfefd0300c3a9d1162d7defd460f9315a55e9f1f9187ef5010ffa666f09ff83843a3d57d03985fd2c9b4ef8cde7d547db5cf7ccb171e6f2f01cc78d1c97e71dc563df99dc884df6aea9b031ad9a81f9799be7c5ba4cd5d70f793e050751332af5bffa7f1d3bc9eb90c0ba2fd60b5223c232bf08f229a137d5264747f024f1cc4a9b02aafcd79deea917c6cad97738b9b1af6603e85ef8dab7719e7783d711782d2e7eb6b8e558225a4992daab2f9c43f03518f8ba9ab0cfa6bcf60b5cd3fe7c1e4e133e721b548490ee37cbce691de55631ddd8642379c47f2296fd34b24b590c53fc61229648b395fc76c6995c9f14974ed6cb71fc6cc3eb67f0657f602f150d4eaa066b78f1af1f1ef1e06715cbcc6f0d0a308ce336ecc253c0fcefb1a70877c9cc1cd74b53e129e29cf69e12707f26cf0dfe5c0fae1c234590ee215d5d5341977452d72c7cb57771922c353d40e91424dea12d0107241270e293fc7a462e0bc3a712b4354dd9c53283d3c27dfbbc11ccd9457be4e98ac5a53e7b41b4e721d7b07b89edd51ed140cec65cd628fa99972e902aafb38b76954fa40cb56ce2daaacfc46b9ac3ce64c02f047c46fdc960e7aecb809094a1f2921310081104a3b2102521239f7e26381db9d8f605f4fcbc39ea18506b709b109f0c155a86d5afac7b9c722153e1bfd126041b33ae370a5f5c309a2c8c092daa8563c5ebd941eb7bb20cc17cda90b82f90914f35343e7f289b07432f411740cbc6cee9c722a330d551dcbbfc7784229da953b92ce988ddca5da30c17b1961aeb770f142442f76a65966e7f83a01659ab32f51d6862114b7d36db50c4fb84587bd3c51352f2087a362d0288020876a458d8f03cc76958248a318f0400f1739a26779a7aad04701ad40784b64fcdd12055e076c4487741861f0567f0d2b3b6573964fd053c513725c8a2acdd5c73226eb252cd60242b2a5ce36cc543b29da076f8f7b4280c6f7b318c171635a080e6759e78cba6eeac29b04a7f587fcfbe561c3eddc4daf6653a3cd9ae0899eda74e406e03feca6969304f75ad0f3f05eb4fc20c9230606c4cbd9ed0e886777c63a1f0d506ea600ea8320378adb675aaacf6d26b136e247b319820dd4153fe059909650e6a63ade23510b7461973d655ac8ea59873b514a3f4050029ceef22fe23ee237fdf8d57bf236dc827c96fb647131bc49f2cc68db6690197556e44d8b9f1ddb0aa9b24a99e7b7ee56f0815b06043515088d436529f050c688d7d376483ba7927784d7d4703f9c4ca3aa4456a397c2874b37341fc3d91180f55c60f0b33b1ac47bbef7822bba80eb61de0c4a93496f5a148bec10c593da8dd78920ed5b329679c44cbc7a765492545d866a843f29fc73ee2d4e29493860b19c8b6cf199c8a17b0149ded3cca241e7c8d8dcb9350201d1ccb3bf4dd102a655344ecb031863d5e4d2439ba4cfef87d4b855b0799dcf08318ae6de03a7d9b6a668312e7134685e6069663b57d944349e28215674c04d6dd74ccc127f0275cb263785bb54a4f483fe58a138ce4524e6a5da2f659633c232298ef51240b96645f72b2939c2306cea61e8bb2fe8f2b77c507fd6a818b0b6d636596f9ae15e87eaca5f53176353125228b2531cd795038ac074c6f7ffd6c0febe68cf2e152160859032f3e988f25d8190d983973cf1464cb2aac3b8c8bd124df15872f516c7edb8e077a6917cb9c474a552d5952fda9fd6d15a2ab4ea5dcc09c22bd29f4800352ed28ab760f2031133dff5964a8716b3896ef9fcfb4e0c9d1981d54cf654c5b477328a711835e4d8e44e56a996ae6f99bc00a439035b0269709a174b2cf9aec29247c992108ed6bdac65f6b8fdc051bd90d6e24e686463f6846b10565f19d47bc857c9a0e33528019f24aa3d2c8582bfe3c518c5b2a66e11c83ec439758d1ef3812b38ef409f1571f6b94946e06b46108ab5cff2964e08c644bc32b11156c3eecc728285df2ee0a61236c88e38c22f6d5c02f28335b2c05c3479c543c3d393b67a545c9461b2290944724818264e65c16783ecd09ffb0d6eea1fbd0478a60ed4161c4892afc20b4524ef01b27ac2bc33b10c467c1422b440fbd56fbb7657b0a2b01cecf8c7c7b939f08192d51c5345d3600b954dfe89c9524dfad6d9a45100e7cfd16085b16c6888d2d6bbe051476eecddb299c2caedac862e1b30065b7b73894392d98cbc90bddf8b2543590414732b4ea1d4de3d0cf8788c07bb9b92e612d09955002bbf7dd0b64bbb7f664731ec15964a2de8da4ebd4e1a96b9981404875b861775b9be6c3a4daead730267bfd09335265578e00e322ef70c30138ea4dfc48b8dae8ab2db225e092ad5dbb4aa72041e97484043b388a3688966ab5a7128fed27c2a1c51a3486e369c279d587646c3b05834c8353bda175773285647e1aded21546f5521aac00fbccc01048ea94361e3476568d7338af452124658aafaa53affb3408b384f0775d53afbe4a36bcff77b3a169171e512884918cb205281dbda6fda27db35fbc69b7a8797916b2c7840d9c31f216522f4bb38e134e4eeffe3c1d5d29e042bfd6fe44649a61c186e69897a785e79284e512b8e08515bc70e019fc66951e9e373de5cb38b91718b67601cdf2b89c5833996bbc9dbe119aed0190396118659ff040ab852689962adf8e495cfbea892872650b09074eaa4c21d85031b5f721d804c6ae1bb0a148def5d195c89c196ff121fe0fa5c9860ad9e7ab633fc80425738ea98a7674b459060035040bae72a3ad33653248d255715b39acaf644a5c7058036507255b19bc2fc6ffd80390762b31e367e0a52b7c83539c0a770489648bed426a1aa64a0cbcd1f658ace1d99ea06dd2e4a4dcda7369c007a342613efc2fded833c8a945afe481f90132408b24306bfaf67321ddd05c2b580e1bc282a3b9693d531b53ebc154cc4a334779b2b035f8fe4215d0906e2dab5b019137cdc1468a9513d115855b1f9e07393d858b4a16b80d300b2edf0d9c88642b40ffa722f0f7c56d9d52ff338a627ce608a80e87fee1fb46cd2f9655353a0de7ad2cc314acdb9103c2c03e1932f09fcb8bc1d4117ec5112133dc18d1d4b8c6f5f3264e8b7b59d36ef6d8d5a87c70707885cb30f3a68bd3e6603a86360132aa803520a5cd0cf960346314bddb5bca604924ef86069623790943eccf8fe2f6901af5bad053e5cbc669689fde37ffd7d106a450b29407f94128e14e7a729f0d610f545305ca1fa5fdedf586c4839403b7e12364285a61a776da3e52541cce7eb7ca9102349afa7beacc9184eed6f6a48a3c81f92527d2e27d4d1124e77f97959cc1a0443dbd113fdc0fe1789ecf09082471d954f73a5b286391f0ac60241f41476f19ece7cb13e8111f1f4218b97fa819d9ccde3536ab650cc999544300393d774165ba93eee610086fdbc3fa5cdc1a73dd6560e6082897f0ff6c1a606d3e5090834239c39367259252e822aa3fc639b2d345a5529eb94ada46b4950d9f1e0a5cc26174f57acd2398dd4b1c0a07fd103f2cecccee4f507bb0c40f6dcd16a492197cab4b00051335b9cb6364c6db9758076b78e2e92e50f7ff58b3b519a89a274cbf94a3d1bc1e9761a2ef07b4fea4552b228e1f6ed2132098ecfd9a01e6edca5d7ddfcec3be5866b62abc8b699f87cac780c13bf459e69d535d1120877c671e63325a3fc5f8e78d28682cd284764730c36ad2ef19eceab45d38d6ef18591090f50932fc691d79592ae94e2d52fd13018fd3a2d04485e42af66aab91c62d358f79e576d578e9904adc1170639ac164699247548790b1c27f0ab5661cd3755c5101ccaa40d717c848c5ae75d76739a9aa6beb6d5825d0699fb5d646b6bbebf4a148b50a30a146831fc9814f7cec3f2f782e67d7707e3569fa7042cc0ac43c47c86d8226376f1e75e88bc144f88ca8be312ed1b956dc90ab027f86e56944cdf52adf7a594844731049c4ad2dd37ef7b15889619c1dc91d62d5b5f6b83ce0581173c90e4e11df4a0404e0cda649d9a4a478dc4290eab35952878b91507067118ffa34a586c261c56bd14769cb2bd8b33cb8a634dd1341f78b26fd332e77402f98f95434b3dab817b84c08e22b9977d8c8be10d0aa711e6dcb9d4dfb98f54b80fdf263b036e466902a209ee0dffecf4fb2ba958674971f9ea3e776ea83ac8f5d92eb57158dc402e8c2487b3346ce615bced738ecb14e161cfa0cba6ecfb64858403f5a15f4b9d1766d07f65513e74849944247986ffa3b95c2d8581f2605800188505a61234c2cf8dfb70f78010f73a4ea23856276fedc48826844533a635557b326dd10446be286c31aea52ae473bbaa088787ff1afa62ff629b531e5e738afb2c5e1a055c2e4d98dbfd791f6580eb8d440c53338bc719590beb722923ebb7fda42f08442305f1a6dc028efa44b5a4b590d6793f50b79c161e20ec14762d3b823a3c6d801d42171281ea2a21904553417edd4e3e05428467a8dba6942c77eaedc425b5fe5d21490e3f77d601b885a46ff4003bf3ff4620c77818afd3842f79215e8291205d6fbfb213310e3a2aa74ac648dd958ba08dbd9338bd7f331d79a6a65c3beb9ce5ad5a0e4932d3aa380a6b21c15680c436bd28a18a06887201bdb6b070a3d87ab8f07c935193517650110f7157faf8c72f4bf5dc7688711c86b18e86df9354b83109b687b7ad82090785c8f80d2ee1ec3dbccc85127c79738e66fe62e37c74807c223fa58c915c62c137e98adda02199b5738fd9d6fadd93a2fbfe8137714fd3389e97cf6ecef387e73935c791808af74fdb46235f32e9ccf7712d54751708ab201c5cd1bd329cda6e1bf9105d2cd98630f47cf9824f73922d794b37862172fbd08ad92c6f444c8a7c1c0fea6d9e15998abd95f38622b9b212107c39b0d6374af13b058ffe3bceebbbd3e312e4828ea49c77eab8adc2ac7a11d7476bf531c4e192b4732b4adf625fa90a9914885362dd72b74b34ddb1b41ec2d41a2d920c05978c090ac74748de7e267e39399254fb6800955ac8e06523d1aba0fdf32eba0556ac4ae4ab580c5ec0c62df3d9fe73752be386ee889f5401c5643b8c035e8bc12ca8631dae673c0dc9906544f163f25a78d2e8403e94506c3a44269cb31133213f0dc287a44328205a1f3c771d371b0cd3be774acb274f943bdf421a21b5ee2ee06a25713cd3d7f3e503436c8f04ddc57ae56b851a9d7315948be250ead53cc6829a4291497fc10321b2401a63d3ab25ce9233c4cdca10eecf6d8e02d370ad2af235262a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
