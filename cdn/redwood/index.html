<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eae33fa58a3b5c4a7d07f84f2622f2c55715f858f59a92c48ba40cc4fb99b342828837fc6fd8b2e418e261abcc9ba4cb89de4ceb9cde2b9d8ad71668f268c79a1a1fa2e353995283f8e4eef0f426e72458a79c82018097ff4f973d07d8094af1d3288cec25672d967533af9caaddbb4b2213355a1cc101c1907e2133cbcac7283471a95b48e3447dae26a9892bc4c64f3796a0b56728361f28b132a85cfb2216e9f62ce481548270a1a2b63549451ac803872afb52130bb5ad176fd110ff14e4227502af7d51198e752b038d77891bed4f9ccbc1cf63cb8ee705da00c2e8289723dde34aee6fcc0d7c194fbeb0f21a8d346aa863c18c5691bc3714ae7855f053f96e66aa00ad36b85879d68bc772576335bc88e8040a07c2a1f2992e038e5dbc1db961d1ea58dea283f4f91f6761721dedac3c922989fcabdb722dcdf0b79bc3696f6cc8dd3574014c190c3f69b30314034791dbaa2c82ab0520fd4c8206410049f00652985a1a6d2f884205756abd7fef6db5a16cc474b979002f0bdf3cff42c23d05d3832374fbb842f3fd20d284aefdf45befd3be80c9bd7c86343fd13e123c5d72f949241972c7899d30bb8c8d1868d7ba82e4b6b101cabefeb876e9bd76e9a0d83e3f942c60697eb27b9b7182168db61c1003aafcb8acf458636f2dae73d53ff0e3964eebe1a52db368c9c037b226558ab21c654ca7629857543ce5571e2d11294016e502730d033747e5fb564de45e8e36b2919e2204458acf3e12f993d19be8d25f28e9c663af5516b238775313b2d297923a19a553b272e3285356d857c81c86862a134a0eb551d5ce1f8995e616049df3086581ec500c9aef634e4d667d1d5fbc9fa38c6b0896727b6232e2653e3720f9f0a45befe1b9aeb59434e92a330f3e25dd78b5ec9f44eae7d81dbbcb16a96de81a8f534d425d67b1efba6542d0c73f1a3fbbc0bb01460903bc61776627859f8a39e3807c67a3e059773291dae97d51956b129beae97160f3b66c9ba5c1337a007b47f414b057c0fc789e846e1aed45ee02360999a321996659be2c6cd42819089755dfacb03bab707863f2e61082722fa6d767dbf30725d178af2c5a11e516bf950d0ea242c5d48f38cd3ffd13b68583425989f0f4e1491766ca22ae768a007df91a071bdff592825df2181751010d28b7671863d44f773b6098012c06859c7c09b95c5c71473d58a77a55003f4ef751f4ddb3cd6fe7a9b3fffd7f57b18636c7730aa9b1b0db96eff1080739e12fec0ccc0af64758624af532e8aa3b9139a3b0bbb839616feeee58b9e52632c715613d143ff2e116e63ad30c83d453ca5760441c6c00669933f2476c613740d3d07b8db1caa934bbcc8d27c12401851095eccb017f30e3fb62fc52877a0a7151d193af09e4cd524b106d14b560581bc55be693e22a45c9d605e4ab9d4657a5a1ed9cbad67ce4ac5793e32f5b61e847b8e7f91a484c597cef1e0fe958c2e38fd009d40128528feab1b8fcc4252f558feae273f73e6af40b106c97b985021d92b53f3966c934021eb1fc6d47ca7846939aae4992153a7d9099cac288c649b40f6a7a0582b2c807671dcafc7df978d60c7911c705d1b06a2c5158d9b148e743c59f6279d6576041798ebd528cba289de60ead63d22568d5c829b00bb0431ba3d4c4caa29bdf881a9672c9359a37fc9e24e9ba767ba8b6aad819ae7d5916d8ea04be846663a469850158ea85dc56ba38cb11dde4f28abc43347839a6f57239bc6d8c6c53da1fb1df83241825e98abd7e8293ad3f9692bd79617ab2fb2667c6b1f61f6b78e6b4cd78dfdc73bc6d35e1305a02dc83e8b4ba32d7834dca6104242e83dbb8d3008918e906217ea38d8ccc7dd722f47624393d71cdaf9ce742fa33afbcb36420ec9a629646e885dc05a0ebd53983a6f9c367fa37e18f74bab7427e15a43cf5f403a1329df4aadfe0029c1130c2339c3b064aa97edd08c83b9dcee6d616cabeac5932b4574d1334c651509b9d4605edfb0ff2609d0ed3a78cbb8fe11e242c24ac50b6fe781774b6db0976716d00f655a430bbad98f3ec0e1e640b2cc9d5eb0d33543ec70d0cc52f92910d719b022a34faeeff5777b94e8522a4eb0b273bff4fad6e7036c255703c232fbe6c88090b20c43aab03e9594c7cdcbb0a48bac755b9100b1d45c7541250bb45ff587357c249544c7606343913f1607b601cc69a97a5dd4965beff91cf969cbe08c2c6b2650f0deeaaa7b2bb04b0389bc8b855b9215d41c892b47679be2b40e9fa492b7a9af6dad949224cd9802a49be4a49fd1688a79566faee5a333d5dab4235722cbce2e89721d14ab9b47544ad945927da9d9239670ad843f2eb95484fbec26d20737fdd7c4383a8fafb5fd809339c9ac6946a6a4de3c08a3d49c62f4098ad9815f97ebd6376db2934eb61cd3aa916094fe16b3bdac0a875db095a486f5e3744abc0bd1044563238067171f5959199b34e1d74873d1d60e622ed28459820fd5b2c9044bd50a3939f46bb17ace6f11650b77fc0b40903d04e95cd7c340119d53a79f3f36a0c6d24a800bf2a8c0fc94778fbf5e22ef31c52e10d6d8d23158c957a1b2209a332db32e71344425ed3603147e9b4c139587ecee0817a07ff738ee4f7a27cb9f51859324a4a758a25586dd5ad6523b9fde484b86273213389f43d584e616f63d7f743bcdfcb0d765c245dde70336d84b65037ebde287bbec9bc144f28ec72caea0c0d4280ce3e826683e0da5858c20ade235d01b97c5899f50d84ea36050b9dd2e79474fd7df70f7d309601547ef7d08b3725f780513ec5f6318a1836581d6968e0b4152659c56813f4fcdbfcbf94f4bd516385c2db4dd1684904069f786d6766dc8f46534305bde0b28c2639b8a1c24f2951a7eb3205b7e0271cba97cf445de967b0877ea24b7767592f03d47f830b0e91cd150a73ac71d999ecb0c7cc6263fefb14a475826693d618ece527003b1b780dc60bc4a57431ad6f6f949714713a1fc31a3fe2530fd14dad8b59b115597159e3254e68cf0fccc1a3207f5a7da457a64a9a6f431ee803aed2f5a0644cf19918fa1efe052ba8edb3b2d2543bf5bd2f45eba96d9391d7c335db5fa4befa08d20a451d8e3e20795795f3b8ee3d86401160ff97354a9aa8800140d176a6d407e3e883439ddd8899c6f29c486b8e2e66ecdddbf7371b228ad1dd2254d7118ce02c57bba8177964fbd5059393cd7cf66eb6e3c1ca6017f11e4d23d3a291b2c0e0f5d199f6b675f54f9d9a8fc8a9bd248bd1cadf96839536655089eaf562c8065fe1a56fc1ad3a3f8ed6341feeb73b0394166808ead9f8ab4d6fe69224442c5715b314ce843f40ad3bb2d454b521ac5a4468f263ab8d05eb2b2557aa49fa1209a17474e63f5daffa131192427a96d205e3b6855473ba2475a5d9d1feb31b6dbcbaa2124eaab11b9d59ffd0bafd7b7e30235ece5ad35a336efe09bb2dbe8d49db25467e7cd6ed8051948538562b2419fecfa7711e5bc1fcd88568e7c822114433a62fb4b82f67af1f6b3defb702edacab4defcd6af62431c3448b879d1a12384f4de731b9a0924ddf55266fef5290a9a5886961dcdbc244110d67c228e11764e60ca67dd43dd6638ccd149158d6f2cb3d72f235da2c04b1002a33b6d4165808669094a76d04960c3a2f53ce503ba361f3979253bc15d7bb59d1c05e880a3ea2468c12904118f0a1e312c392a91c05f812ef3cc54e173fa7fd56c104d7f63e159b1afc2c29e744e79bc6843a1e32104bf6101b08681f8c367673d9d7ceacb30aa466b00c5d3a8f57123a2586ac46ab8417364506fd3f91050787fe9a47da76e1bdc02c0c383a6e005c9729ca42211d789f04515f90b9deca42cb956ce2bdafbf798844d7210f9bbfb25ef2aab3c43003da6554a9422c0f2e14f0d868e14b6ef6396fa0673f670a31a05c0d67f1f33d8ee68f24967ed4f50ae39763e62af6b911f45fd022414d1b3cf3f38763389bfdab53df8ce88da09a4c2c49fcc5cb2e7885370c89d43ed63345d0f8be592aff0c395a34b53305d8f8d2093fd55ce983ef7fdd3d4e83d2571e577cb9b5f8f8f18c25a52f682681816460c24260cbddd60cf620d4b8c26f261c686971f81c19449cb8b9858e652fd199952bac63bc013b80a1bc0bb348172d4bf95af672f8d3c50f2fe3b045e53e5bdad33a0aab81710d24c8bc88e60f7c6216de68d497f33ea805ecd3003d8eb076ea43223e23f95ba39d9e045db24045e914bbdc1a6732f030a75094d9f441518695084057063dad235f455d14e3fbcc8249a1d4bf85cf0904534dfcf179b8d59a1220f82265ea3ec9ceb7632e894aadc1782e77191069f3ca2efca2f1979feaad124a61a7606f3f20d585f271f2eeec2ab69fe9b38498f90ccd912371fa9781deec20d5008b7def5d3c5398ce58620c2a682c39a645c13e22e023957c0e6bc1a254f60d377303ab35e70894bb577b06b8a5fc4fd906d5fdfc52a0ea03d0f70d800e31e5f90eabf875bf1b63f738a0c8c53f9bfda2662be245c2d68ab61c6a5c11b9b0beb1643632516880accb77fe844120874e467a25efd059fa5a32934dddeb8031dce5870552c70fb444d49fe1a7fd7ddf04c1887daf409d49792fad5df2e9daf531a180e2d854965bd19b421831205cb529d76bc039b97bfbad4479217644f372228a95932a6f5e13365e829530ac77b7d0f73322bef933efb5b6755bab6928f2d0351aacb231b133600d2410cee33fa8d76f30a87a4dd2c5135098be32f1324c26d4a2636d4b9f35d99845329017b00ab4831d74f662d8a46a12e67c11ee107ae2911efe02fce6a5608a613994b842fc7d4398e95c9d65ce3fcaaf568eeb7e8583665f6bb7e5b1a7fb5321c3d4e97d5dd41b36533521d35b00d7415b908a4e8bc3a244cc0f0c3d9fae658cd6f931f09bbd78f8d091694ee07f1bee18c69e2c81b5a95568f1bc8f2542a7eddbee139521f582969985ab44a9d7f426d7b319ff35afa542a5a68947723900267aa930620c9fbb11ba8af9df7e1683d6aa5dd8c11824981cb5aef7aa07a3fa95f4114e3f7b86ea0bdb8862117ee585dc27163449060d4b0eeb6fcbb76a3d33c558e2fb9d3da87a41a41edc6127bb9836a21d091e34ab59d78463229c87c8caabd132053f3e07fdcffc631f2b53985b67d27bdd13223d2fbc8e2dc8b8702b419fd935a750eb2be823428cd33343a495fc249bc894da4c1ed868116d66dd8b280927f742b3dc6081f5f9a939105fa5c2ce7b813e79f3b8ea4623a01402df5f3da2f8bd31c4bf6c86a902f66757a68ba20e7237e219abda944af60019d32443decb2ce366c476a3269db457b255662af0b6e9dc245421279014dfb227fd33d809af3224012bd1dcb7ea31ec6d31c5140ab340c22ff16778a73ab3b626c3ce85b792d1ef5d6b84ffcd96b2ae77c23dd48465fed00275d18cff86a8aa40575ebcc614a9b267beaa283c8edb21cc6640e8f154b529f5ffc12024f54fe1200fc24d6e3d615950a67413f193f87909c4df0e2996225a58ad221aefd8a80618acb175c9f5fe431d830cd3b999b29f68f31b6158a5000d572e5d71e46e4ce0ccbc31868dcf183f6b77900e9001e0ee427791b42f16bd76dfd4472f5891fbbb4d057d767e8deb4d77118d030a17bb20db732849d3d4c58e728542bfe175748b506fefb09691c8dd808e2ca2b9e9042e4321b8cc686a21649db23dcacbb6f2526cf63845c34cfec170d187c202399bbb1247cedea397c2b04afc9308ef3c956c30001343bac00eae3a2c3a63b1d3d577de3d5d48d30c228e68e1fda821faf6babb34cdef97945e8c4b8f5ec32c3ec380e28f3f8618faa4c577d6a29ea428c894754bd65ba621f71843a24999e7d2bc15f8dc18c1a131ca844dfd946ef921a0b3ef83c124485f66df5f67c63dc05dc38ba641556b1b063b93064903d0322002cbc32f363eb5b536ad68409bd29a8366f10a399a9fa68c1bc6bb0732810282df4d360889efc29c5748289a7c3c111cf98cb040c6c0209eae63a45a1154550502967bc04e8a3bb645ac6af1b3efbc5b1d8b70f5a28473c456563941bd5031fc1f2df1ec4ee6e2acc83493e244b192754b215dec162b9754321c2bab418de3cc9380d3fe37e90e04b760da46e34cbb624eec6d3f9eb412ebc6a77dc75906ae372691b1f7dcd62483cf1e0ce51a733cd3d0e749d18f877ed260cb10106f0acfbf4e272f4f0ebd87775a6be1904859cb1901fedbc56e1dda7b00ff86e9cbb816ac688e49f8838f8e7ea1c4eeff3ba825edbb73a7103c6d759ca804a0f0cd4eea7455725325eca647fa1173c686bfa9d16d4e88eefec960aa53190735057f3e233593251abae74aa256250721e7e7f72efe24d4c4995497413245282362cd6b65b6d640e2241afc13ac278744e01d5beaafc4ba9dfe9bf8c920b0b069b087dca8954c587007241927fbb341b12e4a2c8132d2995b696f99dc9cc151fec901aa219e44c95260cdf8a56da0b93af422f09a7f0d79e81f6875f24b55fb449e4a0298ed5fc82d7dd8444d2b13245c13ef712007ac1b53207098cf0faaaeee96735313afe3d4f40db3fc6dea171279a72c053d501f167905efac4638b7b1434827e033084ff8336371cf15a67b0de9d362322376fb6fadf60c280332bc5e8fde9d5c1f6be2d95af4550b2c3eb00707c2ef6b7244f1a98cc14ae04f02b5f95b761b89549143736a021428bd820a753aff64af5e3e84cda7e600bf91409491e5b5da29a5737a3a7aa1911cc76e3f8d48e5c9ca2b16ce265999a70f230a8907f1b2baa7dfda58bb153e3eedb05d865a60cc8d023c3e6c93e3dca914a9a65001dad57fcccc3d63d840321a1c4f4a63a392ebb0099f229749bc064aa6ec26fdb9b73f8d6929f03eaf957628529db7f7d271c3fd460cf6c592b9590af6818b1bb58cbdfa68b5c6d70574c1b62cc1b1c885b0ac68652f7e22660d33900ebe9d8b138e207462cd96ced53ee3ec9a18201d00f48243a1ce94df61dc5b282178b85bf7bc58fefec24c7385fc5a4c07c72b7b89c3307b6477e9d34bcd2af3d7007ea80d44c958f26cfdca183afbed35deaee073299209b2809882fe35df22c0b6cd87a73c0e731573db15d0addb7c2f561d29fc07a8d4dfd5738482ba8b5af99f0eb6a38f25a7bb6b21f6e96384b56c03ab2feee0d9db0c4fa6934ad9309a72e2a15f17063d7ebe9938848c299ebd0e14b9839123e9947e23315ed81179f02af3bdbc6149f9fba4a8c4058727314804bed3d69e58ba0578c6e550b5add260b7df63c2314987454b759f7b88bb97b5981afdd10227653c1b6890da65500db16b068691c9cde3602cbb8b735f09aa539a32aa199cd96c8df8963436527945bd7efdc0f1ec7f519559dd7dcc4806b94df77164001f45ac726bd9b3fd49dd07b1180b3aec5395dfeb953c91974935003b43830496f0c95684c6ee67d6ab8c4280bc33213f08b29a0e7bb58f1b4f036d4aadea8515a892060ea4bbecaacace7235812bf752a0eb6dddf31d29032e04734b047e96e5af297f240a128c605f09f35ffb36ab073013f7038ebed50814e42b953e643f5f95ff38766bfbd18efe0a370444404141c5297c16848af768d8446f9762683bae02c46665a6b31ef24de6c997f34ae0456b2003b918e1be0eac6a9950747639f7e8d0d6850f201a80336ce099077223f3663e9b311e290afa5e9d9f02bf93430b9ca0b87fd4896eaaf98222f33aff88d4d65280fa29b71ba7fedc3d01621f627ce68610f61d613ea07903f18a386f2253a1048c0eac33d18c5d3d87f4d4b679e245b484b7ddf24d2a5b5ec43f7594a32d5f7efe808b4a95a2aacdb27112a04c288bf66840a14b27719a0345d7cb2aa5d5904468d74b31b7299a83c9a81d6a2a39a42edec230e2443d7d74ca6ecbd34580619df3e7cee71f775e8443509a34a9875e8e584d4ed939c53a4c9206aae905282b1c651a0ab23bc89fa754b30e6ae255fe2b6a6cc935dfffb120775ff181cd49620f505695575c618090b7f810444e57072747883ddb351c6910387562009489784ec5cb5bdf4cfecdecc522acaa7079d0402955944657dad6253adce1ef05f73ccc753a344e933e716835ce67323292335984656f5b92857914071868b0499d9e6efe7d350041f172ab93b2d2a6210e78d3587f3abe6247994b801e6527570e4076fa99b8f1e4e4c7bc2d164c9d19208ac9fee771478744e9a4848cd91bb92e77bc2acc209d36e1063a9babdb09afdd85d3576fbadd7beb3b1aa9cd4b711e7cd3b90c0de249a7c6943df2fd56816c538395286fa609593be8ae32ffac49dc62b473435bcf69698b875ddf39c94c50a26c40fd685b0520fdb216c9e301b44a6e311ad953be3bca76ba31f564190666db049496f2c97dc67b52f4f2ea2385ef4d0c1a62a14abe47e10021b8100b7586d203a292673c899711a1bade59c2d48379b63058b201bfe98c73360fef8205d08d6ecf2ef4c87cb79c9bcdbb4a25d30071f9eed172daf844fab7f4a9709d1886eedf2c675d767de400445a3c84d944f883edd40a6ac26d486b66b0dccb2fa97332fe07b9da44c888b78a426d318e82219dbdfa27ef5df62a7055d82238b9ca02523cceb05a51b12b35db9070dcdfa2f0ab20975a0263eb5ad16096f97704ea5ffffbe3b2d4bc833d6522b1ba5440b2dc61aac31c94af26df04fe7466c4f2447075a16bdbf5338d4fa018f71267874d6185b154b242ef6a0fd04bddbdcae863e388f998f19ef6998a842ff8d75a8ad82d13a57305733f0457b4565b3884d0ee714ed09b01f6b13243c4d5f239521b9e4c7ed8d068b0159c0c1cb5a303d380828e0f4b49b5ac22795afeb25d471c60192124165b46e2bd39cce3484a69f4ee7b08d1888e7dde86af3ebb1d0858ae502a84976dcf81cd9db5812d7e5d78830f34167d97b989b1cd93eaaea11a1be09504b37006359ead53e0d10cccb16250e1c073ab4aa05fc609ccaab2147d6a9ef6d0252d63814419681fcc56577bc8ab4398c9c90f0481fc8f4a77d51b4213ebdac76cd76690de3f67cf37078d72ac800495751efd4cd062704c5f027071b472624ad487e1cebfe2082613592868ca5b2cfe65e84c287bf121d0509e5e1cfb1ea3d47ed37b37127e36882146c202298666b4134924e0ac0a37d8e1672482e10c4fac5fdfdb9338058a0759b887a97b0adbcdaab07cf006088b87ae38532fbf05af9c0c5fab296a7926fcf84ed30d2fe812c2cb8c8102c8baacb5d1ebc7d501dcc53cec8cdb74034d77b6ea1a718d78c883588265ce118266cfa51fcfae3385a41b92f04c5cdd5aadf393ebc630ec9b29d6c9c077baf11fd5739c5522852f8945a4e87d0c5173387bd8ec5367294cc36725cc446c6e90036a9490ed3dc8f6dcd3da85fe715d76cebd3a05b1e0570bae5d2c964e755d1227968422e58011f06147d78d5ccd90f7a74797bb044cc2c96b54dba4f106aafb16b667d86a3a82a3197133a2e4c3dbac9508909280f005bc7685ec13e2f6a565573fd9be68f18e28a0fdc52df28eb9be4072e7672deecff7bd9588358937bc47e532ecde451b2bcd8e0df75541a451df265f2ba66876ca6b5dedffb0f1a20f1a4f13a16420eabe9c9b3b1dc08bb9ef50395a096a2ed0ecb9c0406283981f5b664b6d32eed34ceac0d21287f9c400087846e28d96be447f2aa5f0bccdd6927443ec9fef66af4d506c83a319ca38df2ecea0eb4d555945fc517e58354ada8b25e213bc0041361bebe349f14f6f7d172bdae78ea9ce203a104225f957f3b75bfad2f58dff2310f713d2579a2fef35bd5cce77b9063dc59b0eb0ae6094ed371c52be612330ed73f4f9b7185540be90635fc135bdd223436e8cde2a446dea912b6e81657e6e24351f3cf49ff0416c264ec544355420f64835359f6cc58ee9f3aec8c5267abb656aed03b2fa329c7eb1fb1664101c3a1c12168c4bba9670433c3ca1e21f9b66f5f99a5ca7a5e47e02b080b675c6c886859b9503b406c02203e97ddce2f9fd29dfaea965b5c4167b82aefa3c6266a36fc691bd9b7a0bba01078b4754b21bfea600441c3f36c604ba747087ef53c41939b77618be79c6e147dad506209f59c64609328b78bd3ae66b6ead0690c4a4f32f3f33488dc5e47f19ef60e473c51e686fd5e73c95582c0c944d95786580454ca4a0634d610ce7b155c84ea55096454526b12481c8c10ec4e92c339b3e752522a49cdff57835d4ea8959b2d2be7469177eae1fc61496fd64235ec40e5fd7e2d92690536ea13d93427bc2d98ec6080bd78545ac27936772ebc97e598a87e0c03579a1a3ac30247f7d2045229246a87e2334801877b22e129302c2d26b9f78e07370df64ed91a60b4559cf9896bc989f739eb40c1d0b4398cdac5f21a57ce18e40ffe7f34725f24d0620a104496c208464bada37c2ab897d0102bdd9f2ef42b49c75eefcb3cce3e8c9ba14604adaf31a0028f799145ad8ff60363c28d2a977d8a8c769d5d6fb9dca3e0aa836af7dc7a774d30259e8434940d11b4f84b710abbe52e1a93614cf846e5fa2838ad6c66e264c6a64cea6ece720ce085f042a931d355fbfd5c768b3df508ab3135569e7c50fb455196feb0d10dfd66ed2fe656d51731cdc40a332cc2ae184cfa94beb561ccac5069b3163461e7935298156f42d1930c3837a4354674e504ecd40aec75d02158065720585f2be24fc93862f5a63369f659cdf1e70a6a61992ca4e680d1d8308d641fc80bbbd301457a2a4c85a07499612d125411696b2cbe342ca1cf198102c1c9e30636fc2d1ea65533ecd157018c34a72d23accef0d933442e4c4c75e415dc87e15c31f550d0dbab9e18037624e9c2afe786a3380b8f18613effeac22c6c6e89beb8c17d6e5711dba14ee75a9090abee7d60ab121f9c3397c83bdd8d256d3c8311b4e33f0290e4308fb7a000326cb8c5a29e58589d19140f95496b59ca4f005f16ecbe193643d048cbe46016b8899612bad11e808b90ba5f941b573d85eed5014d134ada0824afe96cd84b5c1e0f24e9150a79ad0585a638f149254364236f656c286a3cf3a016c5954763cbb98102a898a018b399c765b54bc1ee074e691c50338217b2117368aff6ad32417bbc68f64555fd99c021f30a66a2ff5cf4d9fa254e24044ddb1f9b38952d7b36f2691b3566bc50a4debceb9a63620c3181f0ba50986f69cf641190cea1811b04bc1456e370cec197fe82ad0d44fb3b211f97a9346ae2b08b8b8076c28e58314fb1f97ea2bb7c45ebd4a11be9cb6e326a8f7cb44bb03893802eeba158e699a0c4df40e7eab6395cdfe7dfcc7ff346cc40d48aae85dab918d8c2fedbf5a6fc782909bc6221a2baad699a5c62ac7a68395ae1f127fbcf129b289d239605611691c7723151346ec5b1b0666e5a682a258be5def1e5285588ffb12a33e006fc07042ac10036200bf4ebd3edf519998eb0b227a79f2c13c9bfc2edcbc1d9ca2431609dd7f759067a92398e035116f89ac19be4a277d079d43984b004ba38b2def63fd39e035452c7e9c6738739bdc7d8de39cbd7639ee1c6464d30a78546280c0b275d59e1f969359ba57a51420b84d3a0c5ed7c6a92b87d1edef5a6938dc5939cebee6172fbacd333b073511703e7e533c978ed64ea61ee19bfb471c995f93a0436bbb2fbf72387d4713e9f8116b67c21a354a6aad8def713416f64235622f389687e428bf777c395766d53ee5c6cabed0eacfdecfc210441d0a815b197b7d921d02bb7a6f3441f26cda02a32e41f7c9e11cfd1567791de151144cdb97536e9e0d27a86e80bd40a4f50e61ea86cf67bb916e7d22f7d30b8e9d9fa4acf1642730c8e5852f6db17648906f103b944785a78a3db31388e10a38629dd9dfc8269602921006dcf901ef6231c5838315fa1eb56a30230da19a38bb43e7ecd952f034a28fff203c37ccbd535f68dbad86627a62b1b31ef662a966777c6adb9301a0ba8a4a45d31919a5c0133d3c13f7047ea6bbe8db23d9d2f40232ad1172981a0dda8656ead05f75b7da6d29b9743030f1799001d2b3966893d379ee62de146d0deb0604579a989a66d6da42d0f458004b1704ccfbab1ddce6bd5f2714ca3d1eb70dba1be01fefe4605a8d6c426e2f6e9a965c77dff4c88803ddd49198554f261ccd93b89b423d40719fb281eb7f152b3617c7dd95cdac1e424c0cf462a80b4cbf950467fafdcc559750947ed3fc2a3218beb1d0b7dd9302039070ed51a549aa2fdcf5c032ca283fe65e78434356f2928631caea62b84c744e1e2f4335e340b659d02cb82c094d4d2830394e745666cd403ede35c2bc89855adf9b08bb07a3a7513900be5374ff6cbb161f22409cfba4dbe2d611312baf21e021ebd7a352a6365019545949c2095928a9503ffd8508896603db06dca20a68e425f677a45b0599a567c7d474925197531e485e4afcf64fd7c6804dbc953bd7c8bbe37769ec07f812877b55b203b7949fee285cfc5d0c742f39371eb44a51ec04e61baf99cc064078e73d7a4b6b1fc737da66866f20635020b650da3f3335153e9132dd32624580cc147386bcf20233d2df92eda742153868edd4223117477356b768eba1212622300b1cfcafe997d388c193f4018769126e283d17ed59a062c406f3bf45bd539a3c15d0cac60578515c405fdca8849fd5e93b459e2408d12d7951252f8b4133fcdccdeb04a74bcb51969cf3407b5fc69f4bcb6bd2bb5a2f4c200b879d59b24a451bed3ebe336975adab79e48d6d4fb11011c7390442c441710047d9d36be0f2f4bc575babe23c5f3277dcdae36163a7fde731bc3a0f2965cffcf205de72cbe4a4ad700bd679d11802428124ad0f2c8d94ca6d20523340bd9966817ea3ef8abdb1068419b96294b7dfd9d45cfeefaa56d10b1257d6583459e0ce6269691c5e1a2079ce7d8ccd53cecf753e0ce1dffcac14017f8fd3c6a772980ce0d01b728601b96f6324560386e1f1eb35abf9a795199bb19b9875e265bf45d804631c49db9cc8c0c9155bf52237aba7abbe00e28eea0c7a2d0d18aa547b39990d73cda49f3a49f323e2e9bb5532d78dccfad25b69514f5f9875bdc969182fd0810c9dae196be00b90dba21ff8c967cd98baeb502875755aed55f818d98256ee470d380b4472dfaa36d458c55d9a597260021d1e3613b6a205e323292ae658f8e5b14616ad4fa39fd2a635b6d48557f2f8edb8ef8e9a37fa02a81ece4f2a799bebf2af3bb78eccd9901cba587b73d7fd60b1ffcad22b9f7da28ff27ff61a49627e85a93e1c628fa8d8a18554fa17769f13db95762e18ceabcb960f952088ba691f081c7409b047b744e5621ae7b2d74104d8c88fe742a12faeabb1f7918c98644529902ed74c4d1bbce3ce82074db8c039f8b4d8b8666f8dcb232e7012046a7add4a9ce25ba20f2802e4f1e874dd652e04128f50868e7631aeea4c466c156c9debdc2e2116d71a6149677f777e1eaa27bbc83b9e3576b4100e384448e29c08d920ffc79ea0fda1a1d728771ec79c7142478cfb4336715e7ebcf784278be9dcecc436387551fb9c93c4ded8c125923df264956aa5469b8fecd0e849eff2c2efdc06aa3f62fb72df2b5da4cf65b5ea024fcae0cd88cf1e0316deb27a82467d7d21df8de0143fec5a7bb559f4ffbf23961231fdf0071d66593a588f831d18a57fd3060e8423f3aac29549f7326506a824ce07321addbf050925574b84fc2a11996e2471b4a5c270fe7ff919a2ab7131625547a0bdb493d8c51ac49067c64385471c40037ad09b41d145327d12d686d0b951b149086027ef4db9c1479461e9d92db85f412891f6a198172c2c15dadd01037cd1c0a608c36ef9e5fa6370328402b635be14962cbf194911276eb3f519bc6e787533834b0296e65bddf007012e05665e70de5f948db5ad64cb07b185139abea04d1bd3cce268ae129d409db9c81dc1ee61dea7a37c16c4e358c3bcf47792e88f5c3a799c8480a4baeb095a7cf638ac0ed07d35987dba705dc73d3b5ad9bcdbad65f48fd5f41ffafa1ce55c9a6dcd6f71a6c5ece52d3488a0362cbb5d2d9fb784525b246e1fb502e3137761d49d34b40e950b267ad7761b66432723943af058b4480188af25f907dfdc7e7f8e1b43a830d8a77cae8e12321022f1a3fd3519cb041732c69564dc2062482d1bd6c9a0f09f3a1f84f94e94fb8b7e7c7255c9892f33934a925f236341e99055df3d001513ac2e0d7302303b287b90fd6bce7e4675eab060ae36ca95c884b96f8024d27207b4f11a4711246fc1c4ebcddb2ba4d3ab2a46d8629ea861efabcaf466e040030c329865684d3168457ceda69df1eaf2f3294e71faf25b90e4c9c18d431a1e6b97ae466fe357645115dc1059272a6a7817a83112e39007789275ccab74fe83138d28c2403f0f615776b6f3662fd1439a4a02bf24feebca58e853693e75f69bfde2738f47a586b912fb568e169411bfd3a61dac0eac5c7ca350468af9c82f682aadffa719d7123d3596f765441132cbde8aa106436edf1304d559e0dadb27dddc3600ca18886f2613f7f8972f1907caef61e19ecca519f08809398dd042a91766b8b5353a3a1010ce37103c8c6f092a2965e0357db2f07b32387de4de74e6d324fda7c62ca24048f07eb90cb24d9a9a7fc5d6bd67555b35f6dd05b3b231ee66044f1d7d6f7f83bfa437450684b58c6abb2342b3f2ca64f51b4bd86bb98b61b63902f3ea2f8b4a9fd700cf51a17236fe62ad7cfde5f63985b700ca23246d4f87224192b23253a6d7ba26fe49032079bd4e1c78c867022bc4f2ae8873d3c7552d651eb3ff000a29bffb0e3d5a924c4ee79bd5ea6ea3b12d609cbfbabdd1ff51d1e3148db58250984ba7d57813fd443aafce77e7e21f3b31bbb6742f5bf28991226ad66f1ddb4a5285ae948a4d9fed20758b1a55839f74536f1acada2299e7842bc3889772fb9552f44b7272fd9ba8fbe84077bc3b96f231bc2204dc9ff47029d86bc34808150f2824047532bd85eef13316fc786b6deb7b88a068bce94594ff0e567a170af2c638064fb590b557ccad8718128abab198dbfccd206e75","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
