<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c29a40e672439f4f479d5b24bc5d1e99b571afbcafee987e999a6fa547ca745035fbf299c7c22a086176ddf1371d3dfa1be615f6127b50740cb1dc692e1de8fd0888155d48d0f113201736de351939b5843dbd525571928203f94e561a3c1adc4bd4dc1e57e362930544a10e6288180980ede2b82521e2e8fc81b1e6173d8026a95d06f678912673a5dc855d1ff21483a957334ac009c0ee98aea45df6464432ad7d9c0380e0b2014fcef5f5f8280d3a4be761a9a40a8d8a01dbf3ead356dd4412eaef46afe315312e1ed41f5721781fec264e8b816f2f122c430ef0fa7244d4ce37beeeea5be80a41efedb835b0f63cb1b15534eed1c343e5157a2c1418077323cbfc8cd05ba55f389824fa7f8e141f7c6ec51b1c4a83c02f324e05bf4ad0beb18b11729183bd6c60919286cd7c0e10721d634ed48e2d7f363b41e52e5c8ea0213feb024ec67c15af129b05ee08db69ac3acbb6106b6606bf2d90fde791b84f18d50d48482a064d79b6b7aa5c476c147fd104d97749feb33af16a1447c228bfb01667527aac478b7b310d57b94c4e32c2c6dedc65dbf6cc09bd55f1a15820c8db8f2593032d1be00497807ac806bcb2bba1e37a5b17c207b43097bf30c1adc565019eabf822d931d8198ac4f296734b8312d3992a4236b202d3e04cda74a46025c4cace1d4df6a30144c568245ed718bc44f739dd678d6d775d3cc5a5a505c26c6283ee8edd47e72332c5dead972c4caadbd59a210d63d2de7f806afa308a521fc8652a8edeb5586dd8838c71a8f3a185cb2e15d2b55d4aabba4bd90bd78877769dff9d4e333e0f263f7e58fa036fbb01314114d39053148c6f6d990cf8ab5fc89409c2b810e7b90487f7ed4e898cf873fbef72890beac5d46d43b5619c61896becbb5a61ac26120902c91532dc7b3f9803f0799676e1293ddb62425b45c16d58f561e100d6e42064f8600811497f0a8d2d6f7d355c302023fc7dd82f408015ad971bc5863083ee159e2e60c8e41d838547e2a88cc8f4849246917b2ac51f30dee186a989fda009b1f18fe78e3dfdf36bba5fee6a775ffa9350ff43e6f6b9f7a1618466233ed887b97b536605874c48f7fde43716d9d62b71ad993367a4fa856b83baac16aa94c4ee0e45419ab39b28799e661fc38475d79aecc3dfd0c72a6638bc07e9bfa2dce2328d1512bcdc1dff8bb477ec27e3243a5eb7ff120d0205bee6d7ded514a7c50375eaa8e5d00ea987b993dda7c2b15a8c368fffcdeba4619f7cb652d981e14854773be189bdac4deb704c59995bcfa66e1c21230c117e940751f306244b96c5ac5be3154dbdc2c3b1255081fbd0671fa523fec00d14a89c02b3ade360cb23bfa6746ab96d57660d3deb90b058be8ed63515a42f94acb56ab26e76ce1de4970cfed701dec53dc84c06cf811395b20d084408e41afd7b4413a79fc3ecc5120ca35672538a34a89754e3d7e3999aaeb60e0f1f3c0df1e58f500be1be64972fc5eeb597f0380b111a63ff8b749d2375fe414dbc6cdc5e85dc0e4092485ad069a4e52acae2b5ffc0f728f87f67a4758afca238cc09405303dc928f475110b0aa64897c011e6eb4773f8f88b79d6ffcda2c3351df130957321774254f476c7ef505410f516c9b515eb033d944f996ab2efb27c701e48a12964eab5c6b7b4ae16a69fac0075a183daea770eb87fc38267909085c50bb9fcbf9e9eef4232641e3c10ca15b6536034efad0f1b11cbc6d252efca1bbc75ea8fc1287adc3fc602e66b1fe1e8ba2541de1edc4362f7aeda8e495d5eaacdc68efd36080c518bcc5f7080b210c5a6598d2cad2826c46070bca86180a27e335d70056de544edd573db87fa96e7becbd5d4f1869ee28187991aba9f64b6cd99243224d2c7876d49449f4df711cbd882c510518b5ba80e2a053ca0028ea0bd5986c7215c31248828c7c3f2cc7fbf699686a0c49d6be8d88075de8c1180d4dd33e1e4c68dbf7cee2055d76b9cf529a5d3e453f89edc854831cec4e1bf7c166357ebfe9439177f7ff9837a59555e58c8d02b814b8e6102d474861b8cb89adea1690a1e9f3aaa35d624e88ee9ec31b31e68e4b608c3fd92922bd64ff68b29d69184c9f74aba6316afb7582178c12d4b1e7461fe24a0d5229452983b7f449f445dbc94df1043be6ef163269d651dbd26bd2a2457deab1e49e0f99906ba19b16b824b1b209a878cce46832351027d3955315e5a6ca439a00a3c96e75319c67b5a35288679b6c6ea92e91a203f1bb20c4ce1a4b51c730bdf19839cf8d06fcf64c0ed815ad85c9c04e15219e307505c424e2041f5f43cf436524e450832813698a9a00dc8552da5601bd8689aafa61e18c0aa65efbddd54e39193f87d829d985c2c28212b8de8dc04cb329cf6125e9f415fe805bea7805fe7e4b3b7bef097ba2d41c42aec9884b9812006400e6a4308817bccc36c144ead713c15d68df9f8286e012737171de532f7b5ccf74b3faf72c964457a75ace8dd1b17e09a5953e9dfc60c547d88b717701af1db4e36ad39fd068da36084b48029204bee167725d9046dca2f4378c33ed021bbca6b82189942b66e5f7c805fc9ebb63a45898d84823d2cc9635e1d06e32d98a2ef906739d57599d29c70b6fa9fe56692e7e4e1a4cc3d0e444c22f43014faf93ef0ce7069a9573e4fc73d6a242caeaba037a015ce91fdfcaf0f6165157b962cf094909ddbc09c3d959f677844f3ed8788358c01a13fdd161fb9e48bdac5266e023bebc3fb69ee3edc4a0c84a625649efe772fc976a6145e45dc1aa4caeb1561d7940357883c43991d5c35728ef5d65294dafa451b8cc655328ff2e5e41cf240fb10c6170254dea923b85142ec733fa6c87841802f9eb21dcef468f7a548b329910c5652ab26eacba23b0e7a66b62252d65de96ab1b1194bb7248a669039ea6ea9ae29b64a762110e7b8fd4b11d4e873a3a165a8c3724790090a84bb606f40165b12e1c5729ec9a499a26af026a19cc39a748445293ddee055f217157b0f4af23c0718ad4e8c2cc15b2d8e16078f69ca20be2b01f5040cb9cab0eb80616c7e5638a7eeb7137f0e411daff09febdb75c66ce5f9f674357499d723a4025361c835a346c9a7cef41fa87b6c3e389a1ee5fd7db5191f31af6dc1e7ac351df08d1ac667ea4211bc01a2cd62f92a3639fe74cbe1526dc6b31b6204aac5f1486d505d11445fa653c7646a26bf59e2176cdb59d6bf4b43f519801e2a495022d422dd06e6f9b140fbe3036d425b38b0d120b600b678804d57fde5f344790074bac82de7f3be4e7a5e5930bdf82dbdfe522a5e2ad08bd4aba6c75d693e81c059b40531956b59f466529aa88d15b29be7b50e4002b428749d71c72bd25790abac40904cd38231f2dba7a74d7d881559d212b201ebc7da4a7315213ffc56da5a5875bfe3d3135d2978cdfd694e82af2bac0e9db3f071dc8e26f529957b99b0e7fa9467b0e4fc2a75e9cd77bab6674cf7f3ad772cd61c3f90c50404c1e44382a33b3edfb394e1b1d1d515ba01f93b6289455f2323ad53f7a464a45359c5834f43bc7be945c4184a7937988d9dcaec137bdc3d765eec9f79027c5658da8a937c2b443f79b8bf50b2585c3737bfa3e2a1bfa9701b6fa64184be6c9a5b12e4ea6c1756ee620a0b770e84f8efa580d8e00e1d838294a3cded9702e43c62b419943441b30c525c20224bd2046b9a85fc06788cef3324ab95bd796955129a9b6dce987650c9f7a20055bba4c4066e618e0d9a34aaf72a63cc45e5d21cc010a22417f922e26e7e0aaf4d134dedd38d6ebef4c8a662f42c1d12467e2b01b70783d167e6b087f5ba40c3b1b68c4d831e662d453cfa7eae341987214669aca012416bbe37e7ed2d5d23322e5695410cb74a624b92b55fcd1055cc96ae9e78c372b1562362dec4f39dc250f063adc130950b0139a6ac8ac6e4697cd680aa66d2d68e068fc6b8b2ef73f2f4a3254185be5e86f56e0aa882f7b10460c6222089b3eb8254def495111fe4c63aa98ddd30933c16d08e7817946119427ec34d8538bfeed524662d336bfb4e35916b72505f15e3b6f7ce114f7cd05b137d0021480ed6d36116b20bf369b83d69892c39c71b5d9ecf60ef78f5f1cd60f4536830cd1bf7acd200df8d50333af22c2748ade479298c45543bb2c46cd3bc4768bc651e06f7d5acfbfb9d6f0865fb296f3d078b89face656ea312e5d9aace280a4796b195ff8780f6e4697c8e2737473875ef1549833fba4db739e6c2ebf89bc939b3848446dee8194917ca3f9217b14a4d9a2be91de5e5bd4bd35757371be4df6556ec49b01132212c5a5f12c4656ae5cfb2dfaa7f9e5d563b36dffeee74517003d657e63bb8155126d7394de96a9897228163e0e506a1da833fcc170d5898e2c1c7f405abaeff70752e3c4f9d302a482d90110d5124ad7b91b944aadf2a62e0fcf359ed6120d97e976ca32b1792f90508993490fc8b09c531b1922ed8fd12289dde09e5fedde2b2d08c476d6e1405943cbfeffd91a5332f194cbc26045b699bde23f2b9d811280e7b123b2722a4e18f77d6e717ad4bb2a754fcf1a89306bef68c77ffab65c3c9f3d5180d6c9014366bd3c61f1ba00d8c46194a2db6aa020840caaeccbfdf801877ddec45b74e2fa8f42d401db691f12b6251094515884c9a95e9c84b038c442fd81fcc35ca35eed72353149fbf4b2f8505be30fc010856cc698a7673d50c3378e857093f8b9d5648cbb1f9fce7a807751ea570c56d4f3612b9c922aab143730816e2c27eba67fe6db46a4973c7fe9e7f810857371e0b86bd07d117078f287e3e454660b7d1955a48d7e48234fd452543f200193a0896f7dcdefefad59d2605f8b9ae76130f9b8dd2dfe73b84da1ae041a414e931ae1242333afff61c25f4104195d48ccecd9a1a6f5bdf925c058e64bae64d62a9c0d1e4dab84e46f2d785752eee97a775f3cea08412a9178e71666e0f6fc14d701329e4536d27978ceaefb59676aef0554141fd748dd87b01922b7c337a5adf32fa34e307634de9325aa7b7d961ec5ba08830886fe0cb136e0a90e58fa59b4e797791cc8ad063dc4c433ea511f2953ce0a5aefd6eaa409c4a82078119e7d11cbcf87c4f375eea14d8a847b83ddee80625b173c85bc7a2e4fdeb56ed7a3b9827d10f90f68a4c633ffacb502f5814f1658e8f1c0bc7105f523d6df52e19545351d84a87b3dc42c6b034567a76a2596a7356a5383e59fd987eaa5b679230d70adf5c1c6163c9f3763f6eb8f99c459513c940c60af9ae2cdf34dbceb3865a4d406ceff3f798cc54b3f647df0b2d1dbe1b329e066eaa617b204cf3e29c2e879005866b08ecc7677bdd6586975c5ccbab19085681bf8fd75a4680b4aef56b83fab91e0601ff7cdd41fe42da863a6652921060ba6c437b3f09b7f31295c6d78afbff77eab6a255b19f8093cfdcba36ade4f4501b884f1f5a8756a7aefaebbc08380b66df7eab2b029361d75cb1089a8bcdaf84e513fdf9580190b42556d0cd52cf51c0399c397f2f6e1f86162d25785bc6d5e48df59629c97141f84812b03524c816e65a0804cce5a10b1f70b53a7501975c9e2e820e64c0fa8256faae17e4f399bed572edccca52a7819b7f366e8b36fcf89669df8ce5144470cb01893759bba697603656224cd4f605eda3a0badd9fd3c0cadb6011ca3c0f6075fed29373fcb938e009042ab541e83502fbfa0b3370bf4f642dd9b5c828ff0744d630fcf167af017e086879fc6e92dcf3c8d3c1c46969fa25d72fdb249f976e24e2da71e03b33906f19181b551a2c7c2eb5abe6360d42ef5357d82d2bdd4bce5842b7afd045c8895faf1b049ff95a4f6eb85b874ecf49bc7360ba7702f42dfda8cfd69eac110707e2cf7af93c6250b4bdcaf019dc857405f765d7d0591a1de05f9ffd286b23d959025377b9d7fa12eb29dd58601804be23f906fcc05852a82e296be404fcae43f48a4be74b935a4a53726259de4b654561988a2213609ef24a4c33c1c74696cb6f72695056eb202b0dde1aee73de744f2b217982f01262e6f02dbccc017817bf1926fa6227c859e7a146adbb6bbac1d175a00e2b9c6cd09cffa26d14e8c97c5454a3e8e674b92a556d219563562c3744709665cdb71f5dacedd2cb2d83d3aa39d0a8e12794e086c969a8a357e58037b229473beaee3ded3b5e6ceb6f04db50b39b0db74ebdb8d453a63a6f289c2f213adfb8345ff38e53bdea50a2372b1d4ad9461a5507b9c8bbe9dad47886f95e2856a88edc4d93e3829534e1661b84731b1e194fa29e836c5eff81bee35b0771d4b72e5abb8c2cd3b8dae9fb87f278c474e71e8d585f24a2195b7dc0d8cde3d1b6b48cfd8397116f3b73e81f1a06634bfa052cf2d0f70f05bc277eabbf4774c37d0a1908e6c2baf1e5390078f745ebfa0b2389b3e8319aed152782c128578372288cc47da50d04800053287223c641aff43cc266e0e29a90a2e576d66678b047efc185d2114abd3be590fa97c56b9f0fdc8c2974f21ce0e67f938799785102131194cb72942acb36872d8176177097527b41b6083ff9e2b286eb74314e4af65959af847216e04dce84229760bb2d23e28a253a0d938bc0d7a48836a1105b6b404d4dad958b30290e32632e5fa3d08a2754497e8dda3544649f0f61769e8c1a9f3bbd0e280c0f585442e10009dd634db27f8dba73b210f8bbfdb20d130be5f8fd98b26fdef7294b91d6e58c057645a7f694c00d0067ee964cd6961ee17b82d6e93df78c2fe398c462534d14305c130288a0d3312dbf25f321c1787b05ca77741e6f2a1d1c72a0877369d857a16e3b653256085c5c6170d4ac3b40860a6893c4d13448a08df6cf39c824a9f6eb9b1c9f282f51aa6ae4a9ff704451179328083df29938f9d498751e71a0be0a69cf7d72abdfc0238978fa534dfc01316d4fe7a952cb1b99331aadc474ef3a5c32c28639a22916c74575b5e9d63ee5038b8f4e8745ab1328c0103f7786b9c80bd6e1c218e4a14eb9b4a32caaef4b70a59fad13f2c801052932b4b47bd532d3441545f7e3ce558a995baa78815b34790840cdd6e46e99e1af038538690548a7a869b81a3929b3cd65183a1592a562935ee4f5851e29286ee99700b4de8a004e1e2d59b86eda1b78c1dcb503ce371b0a45372ee4a8e49b71b4b00c10d58180aff4e08e24132aca8fb7f978862d2d417c827487a5528cac46cfbb24f57a5d7215c243257e55e5e7f8d26b14b80fedccc6f2f5884a6f44216080e5db69e8bed03262d1d4336a032304b35f86c9ab0b4adb8093b0f00defbae7bbc07212910d3a616c2e83a7b90b06ff699e7ce2078763cac4c7f2f4f284075b8677ac147e1500bfa4c1460c510ca143699ea9cfe64338735d305b1491eea3b4553fc2d295028d971b686e53324b59c9150ee7989179eee91c4deedd40dee88cd298a445a63644de8553ccf5419617255493ed8590c0679ec0b1553a95b80ea2264fa0cc5c609e07174c76ca4fe7e56301d6c08dce39fdb30901bdb6165648e68d0bd6a93c46fc0f779c28fe06ce27e0d95893112647c928d5a27caa3da8542d234d3c42c93ca885873c96acc841594cf2a68efd58203df6e8a1751bffb873a48f498525c013ef8a524b854458d648505458d7d691d0f960356bfa774af25eb67f6c5c7c6aac98e119ea92d80880740bf3d9debba530fd51baf3cfadfd91162818dfe897efb4cbec125d8ce4d5652d46af86d3e5fc42dd62db43f9f971a5e249ad76bb5ae7ba3be2dca9e8039455b4042b29d419d994e87b7a846ef07fac988b1825489c2c6c3cd936a640779c978caee3af59a520a2c8af83ad3acabc045abc5748e85cc2f50e6ad6f3aaafad8efed110f76a33748a4e514f7b2839116b0b106977948027e307705d1dbc9e50869e481269583c383508cce8a6d40ffde8407129100537e68999c9c442b6e8aba3891889daf6c543adf59f62b46b82744f992a90560bd95eb3fb45e08ed37e9e933bc591cb19168c72c09426c0b962fa7d3abc8e720ee596afd83aa6ff7c6d802f9de39ae3047ed986158b16a4cb5903c84c99db4450d35d1929462c6baa61e326eaeeec8725ca0ab609cdcd8c87c39b8a12330d7f50f04ee7a1ea1bf0bc25a8cefb9f3b6d8c0d522f616a1fefc595bbaba6c904358ba7cfeaa80b145067cde7a104042b7707cf33df5ef1c1e95e15f61218975d153f3ca664f7e33ad0d6e5c710456b7792e16482a02259d483c5a161b42cc0e427819db7c7a4b768601f58c05a9da797b24f0a11f4c25ac77f96c3efdd785280246bd7aa95db20e202b6788642c0dd20372ae6bbd2513bb0c6f2248edf7a44f2b4fbe9cd44b0450a3fb657bc2faaeb2c3c037fd9a1cbf8c5d0c8823086278774cb811d067280f032441d54e2f6635a67cbf4742d72218aa471d5e434fef26677ee759e34a65659b8ac45b9342ff94a056ef212f236bf669493cab31ae63e44a40f79884533436772d6e7a08f0956d73dfab3cd145e2dc6acb714fab82c2c6f3d8ec32c661ccc0603455accadf20d7f11847ff7623cdea424ccf9d0db3bb9c7551e0f159ef5fd9d880405a968f6ebd03bf752fb89aac191cc3ff2e0376a25ebd18d803b60df17413d07d4bc060cf5dc2db6218c97c23ae89b511f98722ae5446f8849ab08a66cdf267e8011272b5b40d181f89533efb69d6ebcb2e47a200dfd06884d56036bd0305a16d48ed5ba367e63975451a0ba49c787440b6f49e831987e06f3184128315031deff13261defa2404cac6d63eb41ece6dabe4fc28f5b5e455cd6bba16788d678dcfa4ec4f7446c7a5a34e552da746f6b9cf3385abc049be8709bd5748f447149ce5aeb28e64e830c079e42f954bbe11363f6534edac16de5465a79be1b6af4ab0ba6dc2f707de0539df656a234e0659421f92d68bc8626a37ca1b36f00ea1bafe4a0c801514e64b8bb9f6df977c07414b78d42dfe2e8f24f5b5746af3a44fb531e4f35efdd81f5a9f00894700359ddbc8923de047fa6c63a22cae876540c5aa1bf1f5029d18e32c7d5184415cdce79cd3a259cd76ee1663e6cd56e6170b8b2c536c182de1d8e45e89a89b2b3153af4b26a2d4c70f820c33f44cae8b6eade5dcbcf30d06674c8c79a1d6a521a27d2dcb305974bee23454ff789122f79fee916a6b4c8b76690046501c9c5bbdf2df27d3c8b7b855c1669d4c0ecc8650a4bbdb79e619390d2bac64ce5630ca7d24948988e9fecd21e18afd1e0811c8c704727886d09c2a08ddccf9127757b2b244b2cd61833f67b0705d45d545e3cf983d3e87253c73887b60b1280cf974088db7b7728380f861e00924a1e9ed3e3d5478b3f6bc66580ca13825773508531414f3a992b6628e03ad7a2073f92bde829bf7f290fe4752cacf727ac8ff699fd62dcc9ca582a544861c872b8f8a9f8a124ed2b0dfbe6b236803c96b3321b1ba5fa4fcdad3bfe12fd95283b08d84fa6a2d7ed5c49751d8e631c1a9ae339cc7aa326af99407c39a835204543b1167e7d28e94822a745646aad12ab4801111d033a2b2470671eea539bb5e6ac974974c05f6108373aba21c20f998af066b745f43511ad1639d6b0b74cb941f83e6bd4e655d1da44e97b7077791530af126dc95a6f8d8de8253495275542db2bb5d7d78540d0e5b03c822a9cdba9546045a72978ca77e659a157074be4688e5e2a7c7cdea5f8b4b539f08e2ba10ada6da65b87fdc2b59da648404dee5e2da73e9a9e69b3ddab88601b7903c13879f7dd59aca297447268c0305680766eea0f6cdbfa615434514f65211106631d9af72e27e8ccac9efd02d8d0df586e2aee4c14c2817cb275d1b7cd9257d85767aeda1963152a08b790a7bd037de7cdd01a081b90ae35172b1137b8de593554400e354c729b755ce96d4dd4613b9ded55301c48d0ec4ce8d7412199741d215606de48418a229b5a7aee3c09b0deacde9f3bf0685802bdca3a472cd37a33e534c2cac9e16ec90c24c12c624f0f77d80a69124dab18a93a6c78aee3408075e882f3154fb8b74f71aeab69077e728bc2178fef6b17280e71ac0440c350e596388c3116d71209562bfb101256b2571d269b9bd38e445dbd7b5e2bf265572b021bde5115484da4a3fcc868e7d6a3c65f3443f3f64c98ee30076d6f634a5cd4cca5004f368a86b827f96a0e6b52e6a2625a1bcdc2eb474ac966cb9ee841f3545aa7ad807e3dc1bd2ae7b775146f6a43d02bed2cb32afe68b1c900a1312e3b7de8b9fd5fbe6fe51893d25b96f08aad27a33ca8ee9a5ebd5ba62b41ae728926a5d63317aa9941b7d985dce309f89d48b95a12b37a041bb6653486f39e4142b48412d1cbc5838a681b88c68382d37dfc82f380b6ff28c9bbd4187a330f04cd8869ec6360ec093d21242739f92d5e8512ec1a1fca2052de76ca6f5831b53690b99f0aa35f51375e9176624f5f9e36d35d3bd9955a1133f41308a02db15a3dbdb08cde6e6ad87f4b07912205e96e83e763916e55d50dd50cb830fffcb98f5f6dac9e86e8a7fa741d1ba4f056cb531ee89b6d1d36a22bb0319078ea0128dafe14de5ddaeb68129d8e289468f91be503a39ced3fa92c7a4b635119af32b8e4decef67d2518dc01ecb231b62828276d8b8c4dc902a22990aa411326fbb0404608fbf58af5e27122e12c31f7bb4e895eae4a6afcf9097ad1df150ef9fa3ba5fa08d304650a09cadaa681e09e3479ed611b5c74ef676708e69d123d8288cd63234e789d55f129f7be1a8d5951fd8fa49ba39bc93e44768ead8e0c3a61cae3e71dfa6ec123acb95e77ec38014d6ae6faf6971b1ccd79125f8fd6f342781d92292cb06a48a6d49285307c7b51b135305d48f2487aa3d44e8a89da3445e51f214d4865b29b05c0c95e97a80a9fbb9144177e5e477d18d93bebf2ac5b218d4573f87537d2e32d2ade4a104916953e673ccee61550e26bcedaabc88500c1e69dc4593a8ec245c87e9baaec4bc7834d9f8784b7d23dabb7503b3ad3a8f66d0408f9a82f736d743f7bbc5ee0f2c603c0f1af3083f5dc610dc36556edb83ad35b7afb2d984ba33f846c7a1ffd0b6a4053aa894add6ec38d91fd8763d9658a5b335c07660b57939100ce187ea6e76422046979d04e7b26735f23a55b4a03e246426a73fe93d7a7ad6c2079c701e823b9b04359943357b7f4bec6ba5349b059c5532c9657e133cbc9227281b86aca4ed8ef7cb20a2ba473916f43af61d30b0093547868d31d40d6128f05a40670e88d0f9d78c40232a57c832839dab3c50b7c302d75ac83ea5ade9e27141a093d451faad37c20bae6c7cb4d6ac8e704b85beb971b37ceb77b237d70ba3f937c10abd830e72884956ec412737e7ada70b5e991b0627065cf8eeb4e3ce0d83cec8ec6bc3a1596da6d4ea0e36c28ccc43125de9a6461173dbb2821c67b9c6e435acbd183e12d2fd2fdfd26a7633fac3f60480cfa314f4144893eeb08b3ebdeffa0adbc146abf781f4145a73aa5f9e28931e37ae6ca73eca79e01ab23bf0f030496ebf26f15f34d932cdcc9dbb21a5d47fe9ff2afb4f46338827221a809774f536e404dd3fcf2c483f97b1797fbcd7c532b53b4a529970136cfcd3fd2c6e119a1b0ef684ec8de7a560c0acdef3ca849ae318f307e6bd6959cf07ea2889cf5d0b6d51035642a738ea1811801b3d77e5fe279bdd25dae2b2fc097b8804fa4f59745732aaf8e3e109740f5a02ea0d563f07b3e4ec4316cde59a39cbf99a0d33d25eedb3f3b8285e63973ac67e8c47cb5a264fe038d9d73ccf5ddaca2f8979c1d909e88f6c291c95340c88074ff194dec43447f80aaf63bd5a3f4fdc9947e710b1d7cd8856907cdb05fe3de262768e61a4549a16ab5e1d4de3b694746686bf1ecb85977b3c6cb57f002a3defb189a2f7dae587491323070997e43ad464a9974fb610dca974bdb8699116035f6f8a7abb65fe8ad15ed5af060f11f6e58ec4a03d5a54a9bb668562ec0bfa74d8ad5f9d372d40c199ab446309bbaec7e9f10a6862addab828093ef074cd51cd60f93fe598cfc3242714a08c18ed689d861973502822d5c1f9c0d3e3cc6605fb80caa9036f8b028bbc012d259fb9e09f0ca957127a8999fed058fa943d4a7fdd674225c52d8034b46d2d0a3b45a55941ec14faf05c7e32ab933b59d53e37009ab57532510af0ebb9a5763de4ccd8a1900a25a55db91fb468deb9034abec8767bd5589d03fc86edb77ac1ddc14ea59cc0a9129b443e45a762ec262a756ed1cde35f66a1241cf74a1ec685be7a6579804bbeab3ceb51c4eadf15988f35f3a23b4fc202eec084e57ffb91232f4b70fd364f02c81042f756e1324457ae7383bf920f39fc857d36b499281313671de66db5421dd8052f222695ba25998c552d78ed390030c9ed382c6f9f2bd6c33afecf6b81c5313e84cdae8ad2acb68987553e12bc8dfa5ef726eba3895294fca77806fd685ecc29d351e680df1c36923922339cc0083ab0372ed912347a4679db82d3dd8341c52495ca801c9a4f70eacef55fb74d559102b45c9bc9fc84e7bd1a95f19ad4143cc5956b28fc693e9694b4480c3eada937e2360d03220330e253f0ceb123292d6d9d65942aca1f845ba7f0f5e2600152fbf41c29c45ce44ea0977e4d3302763b2a37125403c3024d54967b4d981124f453155b50bfb5e43d25c755864c99172eebd756b3b39dd093c0d04072aedad0a217c0ef72e12e43c722cfc9fbe7ac55fbbfad09ec33b7f698046c802aca0ef71c8f0ca72053ca7a250f6ac6c0f4cf125e06ec81b6d4d30042dd99488e97c7238f22aa82a8d24455130d562126dda8c1adae88cae7651370e1b0adf12fa01d8113bf4e5cc059c19e2e0f2bcc9fe84212b805595cd3821780ba4160be3d85db42274afd7d3f0610b96e8eb131bc5adb478dc915da182493c167092efe3fe675fd30972e1721c76398e39c2c2ad5172fc28d4079cd10ff6e07cdf4e1cf38cea58fb6c34d27f3bd7e3856b214b1288d9a1ea4c9a1df09596d92d02550d74743fc381aa7db8f0c38894be307925ba5856b23992ccac0f85507ce288041e77351039dd00b0aa0801770a39e67b1101a625e35c912da85a3473e8bcd3ab21433bbfe8983ea5dcc9139fdd4d621a7a521eb2b7b4b98ee9f61becd50391c80f4463da4d597fdc6721551a1589f4840726d19751a931c9906aaf22211777a0cbaf6b45dda0c1fc2b01fd17c84718b9b003e970471f5bcda8711a710fc377229c9a9b02d1d571cbd574674adfc4eab4b981b82e2164661f5389ebe6cedbc4355523cd216624c8a17a6b724e31306b4df5397578dfdf071a805a7f01535f4ce568d39402f99185ad8e0319add113ea0deee649deaeb576d32f0e15f4bbc221f9268ea4976eef8081ed7e171cbeab1bb7614dbfa693fa10532b485151c63e9fe69633f94c23a4c4ef1870de8041a6a5eb88c87f3d8acea7d274f10a6b3173a3d6c67858e3e4e8842472cf7b94621aa526278da8e054ed03b02db419b61e495860a2310cb513aa8d1537799601ca595c7386f0d6cd7c63ddbe224ead95d23f7046e26d7d193e5d803572dc7258af86859fdf7e7abccdb6f680a820336e3104e6b75272a5b045304cefca7ed56262aba33ff66fa28fbf29d1212929d947361c155f415dc4b3378f7d100827e45ddf966c701decfecc40ba7d3fe1cf3f15a4d6fe5c0e43e370960956c518613d4a0051fb977e5c3531bcb35a362e803aa3f30734c098dd818121baca4cb73c8d2ec02cbcc7a72a47145a33fdd4f34c89d72a8c4da55139515a46bf7c09ea564f31f33e342f6a72364e70444e66a8e0f32e2b3a7880ead09d7af334d3f773cc1df0887ec412ad412c7c97b27069dd514db7b82a1c62bfd9fce52ce5b16f7805922baa6546676124f27ad3f68bfb9f740dfce68d985c1b856e0089d542eeec172bb22d0e9e463745965f71f56747cc3ab3413d17a2d7736e7e31aa9b0c3233e6f716861bf02d1ce825e01e0d36510f064f4c059912d34b8a7e1d11a42ef2a8a8b6ec5edb1b799f681b24c8d570470b3e028d01ccceb52c478681c899a14b8a518609be1cd4d5396aae705937a143bb3af66b8c57b32305f53e15995550c3ca0d3acfafbe86ad067132b16668ebb86bca270234208d49e2007ebf8dcf24d6b43b1bdf578a47b75fec5ab6094ebb00096c5ba28eb0f8d7e3e86fd64f1ef919015cdbf88121c0428b9f36f20f1f0931a5daee4c5d2ee9c68ef8df1161781f025818d8f4ccd250c003318d31b5933f22441ba3c6969f5b29f1b6278b22cd23d3e3f53a56b1ffb48e971ddce4ffcf2dc4c8579f15189a3f82c20de0e0b5fb371aaa3e256710c97e8f2511514cae75b0283d9b75e65d9bd2f82e48b02ec6945e056e9e324fd238ec87b9d1caf8538aa653bc2fec1bb6ba58d7a8aa0cde329ac2876590a5a44c050340d80bfceceb92c4a87431466022bcbd78475e3d0abc981bfc6181d89506ebb82138fea5a765c7beb032a73bcc3ecaed010307f1e277bf91ada72419ec8fc76f1d5f4ba279ce5872ba2069017e144d0f9e5d380f4e092d3ef3356c84c5f18d641726cf767505b0a61a23f54098050b0e13a62d787d1304ddbda95786c0be5522dfdcb44d3d87a708373b187e01ba710f0881ad079192d6ac2773eb69d3a930f28f5ea5313a7bcc170beda64797b0c816bd3ff4569300fc9e8e9a3eba884af0681a7f2d28e389f878528c6fbe5a0d702c7585230e93aa221f5f4a7765a5ff344f0063f261f12cf4e58f366d6449790617d553f72c59a8c23c228ef9a4120cde30e6ddd08746d1e174e5c1a523707e74191e602fadb476d7167d720587f2a3f17a43ed8f482928219a9cfe4842d9dd858fe5aad809b5308263188ff3f110fa0f8b64c650da186de7eaebf549daa3e91352d6444a47000f2072ba430ac89a3082351ce1ae1fec7a2d6c1443c8dc2659cb1b6412c097a151b350d271e69dcb95a982f4034a67006d4c3f9d6a76d6ea2d61b6a767fd27bee99d395367673b9140be4da7e545b8577d9958fb59d4fc8ef6b2fe0d600fac6ed2f4486f7931df2e860926c97f5c9a9ac52ff3ddfc7d2f445776314a60b5bf217fab6542ad435efa7ca229da6cf7383832952f80c9465ddb96457c98bebb99484355b0310dd9d0adee937abcdfd23c6282d45be17d88eadaa3f2745ba8ed1d8ca0a104390774d15bc62eb7f6eea197920336b48a27f524e7004f86c214e96c669c75f023b7f54dfc61554b21a31deb7d62e94f440f57baa575e01eefe429fdfd0185ae23870dab19ff6ca12424a2b568b61ae18b7d2222e9fe2dbdad14c931f3e881ab643b2551a0fa3a199bc6f3aacdca2f29b3d776e10beb0d95884bda0a58523e42ebee53ba03d9346a1281c4b395b0f0f4cd38837cd3aeef587771c2a715d8c880aaf3ac40d5d7ff230f01b999175c2daab358c9d0e35d0d9ea9cdefd5ca59297dd64d9da2ddc9a22ffaaf7b33905c90298e800e940b9a61e6151733d0c6e55b0c37c259aaa0b30a4b0a1adfa5a1c1999f9369380d94f03f58d0e7b160f889fbcc14b97a4ace4581e310edc2126f03d9f2e223d0fc81433e8e666b31a82ccd798bfd4e5025893623ae30f5157f54f09cb985690f88f4799de48a5e9a4eade6824316d0ef7744482ca94ff3c985a239c33d46e46655c2b9b15c8d4dfa27d2f4add51f11d0b1af68164e33351c7db0afe86818743b1a092e2cba5a36f931755a985b31360a724765d9dea7a2d827ab27109006139b5656a9ba466eff4103019fa3ec845a4e218a1316fe299b4d549bd822d3e0b563de3fd31cc76670041b08c8fefbd57a80953ab31e47a3a133c443644b0d9a8ae4e124690123d8fa130ee8959e7a7fd41f2fd0aa33f4b16ba8c72ba2e7c3a0d5a48f5c79be8ba5724bde831a52317ee946e5b45fd80ee752ff555b2f46496a08633937128df8a19a10c8d601c2d61c7f26337c26613e4c86d6c512cc3445e0a77632fe856ebc05cc74f03711763dd58b7641bebc3ec2c6f97a7896fa793ff39dbfde28dcdf921a3e898094e44cd829dbda008b84ff2ddf568cd3b3287ee2a70f90e0cc7a4064e107b6e5fdb8341f9701718ef2db65db845139a3e6877ba2db55d9b3596f8f267eac279f8b643f6aaf8d79cd6c69ce7360a92b089a56957b7ced18dd99f33d95ad8ba37b64093892df04f5fcdbd0e012129fd24e66b2b67d3db41c9fe1fce1a4d8006c780da028c862d89dd6b6fdc4b84992dc7d7470ad252b6b28270b4776748e8b0bd974c31081620765584985128fd2a8e33ef8dc6a27ba3f5bd2f89c420d0df4dd510c8707e2121531841b19209ab9d196822748e9d640dadac6c0f8d44cd62edb58f4a0abb4481c4ce0c6dfb15372436a30e0bc31c78a0d2ca5d9f35afebffa183ea27101cedc3df14b546cd1e69b9543cb2a941b223592fdbbc82dafe4e7db4d53e093f10f3f2007af193da07117df9abb0c533d0569f57c9d561a1e366e5b533e2c539bf47acbdb278b011fa6864ba2aaff393e0585ca26aaa054e767d199d7c8b3e09e4a948cd8f793244518171e4ca0b70ab73d0c9cf34e452d8bb3993fd58ed0b6d70414633104c1988e89c4d199021727483e11a7cb4c794d0b26f7b8ac2a5603fbd520c8b43b701b2d70cb7226dae28ea9aa289af026af31dd87720972dd934ffc95a1cd6b04bc300eba26f5f60b4b445d3f479ff25cd0294262291c8d5ae4561ce1bc94f8b6310454d0dc0d1fafa9d32653eb80df83e617350524af5e42c3b941dd6624baec0f5aee8225eef052972eb8e5c3b327bb59c07df3e7d9914787446520e81008be4f1aa1f91db1af555e4b28160642c6cf99a43a69f09efa67251d68deba3cee4f698684c13cb7a36b7a3812cfd50afb732f8bd0669ce589fa63b79320726afd4e92b70ad7b732a98e0a91324adcbf010bd590197ece3271813a157322564b1c6f4e14708083117c92a08052399893cc50e028e0a2932475693235d4885ea6cf0e675283172c9ee51b875e547c0bf60ee3366a6669964d2ea616ae951cf92a9a2b4ce2fa8fa77bd3af30ff5accc7ef630398b54f02c82cf76064739b4a6cd83dc3d46eda1520a45644be7c738c1c06420a50e7b91303e90a1bcb0e5962e242da21342771a65ccee427fce8f7ad5b5c51800f08946852d0c551a86630a56814d6d9cc7c3120f08ae429d375ff89f0b3622e5889e61dcc2cebc6cf67bd4e04f4ec88046b1c9ef95a03a36f77a94fccb498e3227f5958aa5a4866f1b52cae6a0dc50c840b9e7b73d8f0554e731964b272b89676d886a158c562554dfb932dba09abcafbdf7fcceed9b347d5e634f383f086a5721e5870f92e30c6d234387f14838ec7332f8a18ac8b39a03aa4b4459c70bd575192ccb953b425841a236ff5ea22e3c0c67d68f30c53de180fb9ee71cd4e1d5c468c88ac1638bcd549cf7d1f0a219948d6e7c88f3ad7e5bdc5d4ddf4dbcab36ef55cc21dff1e87ab92e75d055e179a1ec64b2f2539eb933a0283cf58a36d7ff17087bf87e7e66e7a23f1d1a0a19f7b5b2d6a32aabe7597e3ed430736d41f04666c006020208fe4008b647c499b0c7bba2f26a37670cff9b8b64569f8f492137afd2713f1ae2fcb1a5c4f358031bd78726665c34400e515b633718b29247849f1c377e778c1d584bb2f7974f61d1aa5cd3c921bd7f7dbdb6e5d7781fea6bbca8bbeeec0ab1a94a8798e1bd820eb28202a5c7ebcf394d6448fb716945433123100c2cce941f89568ebd28adda1b603e58973ffbbe83b5a66db92816522f840ee7c6e5faa0a5bb7ac50d5b9bae4f77ea4ccaa219269aa9faefc79f2366c30c1c4f07abddb6a4608751cad10b52ec6182805048abab51fd93f4381193f14244c936c32233fc9a12f80743e0bb18feea4dca28a899da71e85cd5bc6b1efc9e2177d9a350b00e49248340e8ba4ab2ef8c37ba1a94a7041b788d624314ca66be5b78c3694dedff45","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
