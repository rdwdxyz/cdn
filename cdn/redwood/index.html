<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"083a959af14104de886039ef2a2b1949545664f01b73c50b6d8c44b5d240cc370accc0c04b3bbddb4dfc28e9cfdd3de8cc74fcc9063899b8b2f79e84d244235a11dabd75767154f2fd7e03be4f69f4f78101be29437de2af7f1dfa984feed672d37ce9383c9cdca676e9b7fafb8316d2b6ec74b4f308e25ab3054c33ad024fa5bc22ee8b5d5b9d50a919d9ba9750fed3e0bdd08e3f181b8ffb7927c604f18848f85465fe3374f56a0f7810da66b3b6f695e52b9ed166321b5334f968c08d3de0278aa9e016524aa8f1af75b0cd12d4ab26ec369cc9ac2b5e92ce00bd79253f051d3a00277b728258cd3b49f65a35e8c662a7512f978a0a10e9954c3bb6ddc2233d5e88572277d2346b3c69d961e36871b0d523fa2078a5c8f8a93210d25f75c446fa879ad012fca82a11b517b3ac16b3408af03e4146427b6a80a700e809076014fd78147763753148b31e0bf6030decb082011a1cf5cf2abe5795f61476ea1d35cf477923bf256ad29a9ea2b1e6c8dd9f66df02d20ba0ad42d811ac7575b2798a8430218489408de31263a6facac4cc105b89f9bb9af520f721537b0b7caca0152d0b392928375e497e48e3c9b8d266dc08cee80839d619dfe448b24643dc8bc3ea65b0adce14f09f2f0cadeb0782af43bc51019b39a4690c57310d247eb20c1825ad3bd168b230e69f197328ae6a470caf6e9edfe8387623e3ac9b9b2062ac9ab1561d59b9c7f41272d87d8bf7bf82088b64241765e455653ef401f7973a40c02d2fc2a58cc1de9e12fedc54e6fa603c84b172eb824d4cc7aa293e50684d07a60142ac9e9d55a7e9bb0332a23dce19c8c9dfb09cf5a3222f6f87ef6373fd7537eaf32f0d58a646f5bc75e031c3dfecca02e69fc01fbbf7e40cde69e4a4716410c2945d00814f1d8cc0b8c632a940dccf7ac5f4d33c54de268941c020618b948e0b23eb721196bed3d45412f64953251d8bce94af508ae71546868aa7dbfb111a37ec8db6a45f9571c826909be4a2f9a2066dfbfc012e7ee55aa47fefb2bf67464bdc7cc2b9593a6f55c137394a7d95a44174f2f954088a2b6a141a7e88c49eea9d34de0eccb6ccf5cb1a2fcda08f837e134f1329c55702bb7f1f92f8eba81750ec168ea054563e76a51ffe5b246f8d88e2f8bf8d872f5ec015576ab271dcc5faf0023da02abf3c95fd752b5318c4841f4f3d52683202c2c3be3dfda913075a350bdef4e6768dd223bebd24189b91c22488432ab9b0d664c578eb10aa656d30f492acf0c183000d42a816f8ff7a33c9be34761dd37841b4c502e4b6d6349da3c30c5ef9078884ae651f96cf00e0cd3b3dfdcd4abb518a2cbfbdf173181e0c9e5db5650d07cb0f06f18514004e239f03ab9e3cb1ef78bd2cd607154cfbc34c499f9712cbccd9c51ac0f00950fe1381e53bc6faf71f7896eba2159536ccbbc935456cbff7243633640f6d33d09472c11c667f7b3655ffdd7b0d5e24713c8c959312fc24e83db4123d963a011caa4d31fb981b24a52475b264fc268f852e9f72d747053e133f502abc7de2e651230e1500b37f1633da0b3f84d7c8d3c3739a77030f1629ea6e8282ef97b4af4771bbf90f9005ca6daebe9634f5ca751ba85179d6c46396de6a8062837faccada446d33c288397c2b5caf52ef7830f310ad9789eb0a5d80cce09ce3f71d4475924ecd8e0c9105af44e44a7c4aa11b513ef9f1cda01e5e7f597e63d4f6e757da45e288cd585df83e512b9423fadc498c918bea3bcbd38e80872b5a6ab7c281b2b611de8f4673d7bb0c774393bfe265dd1fb554eec3a378ce1fc513d798ed5b92feb8348c827520adc9ed642c74fe99b25402803038a9ac54e16db500ec03cc45e5e54068a7679b222e60808b311298eb41f99289b4fc43923f577017f0b563d5faf0a6e49f9e58005d1b7d7076f1837ae8890064526d352bfdb0f34630853abef082690f9b74b364207b16ba985f5e4bf9b04efe74e4e6d6f0d43822dddd5baa248669452fe3c2df20f3b67f08fcc65dcda84ca225728ecd5bf1fc43c50aea29415048bccf8449fd843666b827fe2655347f42a04345d95e7af12502075e853e8c11c0f01eb0b2aabdf6ca0087eca0cd2721f9083e71c9afab15acd6f61f51bd0f4fa3ce9471a94f59ae184650eecc4eae7454bf0583bd5f5444eb52a87df9f4e67773ca8a59c480f79a3080cce6dcd1272854370dd564ea334400a2e2be43a71bd26cf15b6b1f3f816a73e88c8b8651837dff8b1d6352df95dffac6e83bd91c2ab0ee274a74201053d29b80d5772f8985b33f8c19e452b6c92d9bcec0ae335bd5bf1a663e39ee5189a17ac5b41fc3dae2caa0646e407f6a2bd3ff85d5cc8c6edd4428aa01c54e7ffffb57caf490a88417e59fad50d0f50f3783325a95061bff4ba6e2c5dc657215b93f957fbd7978c108f38699370f416c6965f43ce061b1e6018aaad388b47a0850f0fa69b23c1b213cf8294c09f852204c53d574c5d5970d79ce16ae3a6652bb40d9c79dda1a2fd6c19f6d71ae891af17fcb5344ebf901a4625f1b0719197963a7b3d14faeacb3e0c465fa2fffaf8e22d19a0509b4edf0e3b5cd49f048bdce519059de9a101941dc7f41dd0b6d0806c5aefb5a1dd0cada966ed7e1f4d0ba69fba3baad8c4afd348b691098722e18bc7b148abc1b26d1cf2e8436bceda14dd8f4835bf848ab5654b3f6fc3d588f6083f4009bb74fd8b0aac8bc089ea971259073ffe6b0c637d153ba946c703c5792f7e965b657c1de7a81c1e231bc5f31345cf7f7fca826b09813d5f5843e9b2859a85e14a096bf421cd738dcf7919ce616f2ea02c05383e3c207f26141ee6cd807c8ad103fb8de28e4c8dbaa7c3f64042fa79e97a243ff336ada6f45fc016dabf186106b4819294bcda7b159b86df01fb23d17e975c7f7fe732af0f2aa3947d31d3b4a386a3ffbad708849080eb8d864d2103fafadb674079891b2865e854f90b98424a095d3919c49bc5731e3b31a56517578b70244110cf06a33b6482ddbd0010500f062fb648bef8efc217f63b8ad250f981aab7d11317d3bb3d24b01ef3a115a210ee7a8b65addfc7cd05ba4ea4846db1e42a0e781c28596453b0b60ee9dd2f276c240105b99a1818ef38a69961f5965b7b6c7efdce9a2a6bf3757d361266862b5ba7c2f66f1250dd27d6a185e3a2ed01c41e75d5243d34d899db76253dd0189ac5e6f88da5aee308586d40d4b4b86c91bee639d1ddab0bae8d632b4be65c1badd9eb652e3dc7161ca6b7eb0339385a536f266653f5df44479495f78ae3bebdc0d5f888e5ba24c27d1d503552342f0a07d376343239de8b11ae085017e923bc5053fa25260665110ea6209b30fac3a729c39acff5775cdb2a30cdf65c1d15abcd85403fc361f9a8630e9ab1ea20a39d0fc0fbb60f4aeaaad21e2eed36763a02759f9019ca079293585dbff1b9c3bab8d7f12cc4015d84d38c769c3c1bf7b0f8e9d42fa28773d33ea6476e23750f2c895c2d86818a832ddae81b3dd81afc9b834c61d053a5660730247dc07b4e42564e53e83832296b75bd73ccee9ada3a9ea7277125ad44e49867cf58437a46765087c055c7e3177036943ce4232f4cc391b03da37fff5d68d81f215820727a9f7d784f26fb751c4d43050c9abacaaea1dbc3338ff6ba7649796ab8298f55cbb0e279b880fc48dd10f0554bb98abf1ab3eb39b4f5758097addb7f57c278a7428b9ffdfa80725ac2ec3558f1c37bb7eed30e36ec47134f20d465696923fab920ebf4c8a08a684cd3775975e5fe8a34866067711ea478d96a60a7cba3434a5345eec8b1a694efe09ac2936a2b3adbc51a06965c1d53b08845244752b5e3733a0e2d3d86b37b189ee22a31772aa1aa50a5c71097f80b928105a1cd93518e982baffa99da1d502706236ef2a02b312f091bd4588756212d825c9df554a58743dcc8112770de58a22f9fa29f08689e71f06aba0fb5993c7f998aef5fbe507767a29b03b56c8d89093295c37e22eb229e07891827e4f6cf6f57d778b9abfc038de5a268bc582a2c4e7ad289299e9380c29fa4c53ba86a14f2f00e6dde8bc24632f4305551c29fbb33883b65e12d8b137d6a6a600c2f106cf872565ce21e4937bf094e8891126ef9d8a15d65aefb0417e34043eccb14f656607e67bb18a4580b967b97f571fbb83cc598a75b1b4398f08e40c1fc932b17de4160f37d1213feedeb70da5fafed68809d8bf4d7cc860c23d4c9a563982f0399a8dd1f41243486dcd1a1ee7f91b7265d5a1703c29f3c3c0c3a419ec9bead73982d7c8e827f61a07d303e6edcfcce658df5b13175b72c29d3a25ae8f6d553f41fcf5017d6df6ed9c87855302e90d03d605e24193ef1203cafccc446892650969b5a4b2bff8d91a884ed5babdebb45611c235403e41f992c88f1e25db8091489dd231a58ced927f59a83487120401499d2651dd48d59c2f26615d6c8f31772208f41c571af586de6af191699ebd74257e1be34332c5cb49be3f3dd167dcc839754c5fe6f188e23203e6896bd229d138736f0cb9e1a90c205dbc0af6e3c2c0e7b4166e8437a2edae2e83eb7cd271b8037cd7dacb1cccfdcd370eecbf83499f3510d04fe845b0f7293337ad08da1f63477796b501f507a8e267969f6d5d5856c4e86b89dc49b0fc79c4bdd25af514a7d782e14758ba2bfb3f6541d3c1379938afe37b2c1dbe8ffb736ec2225bd39917504cefe28c341c2f35063a8b821b726489dc95faf6592d2b3ddccd32ff8d3e917fcf0e353df26a3d7685336f666cf47fa1ae002b2b9fde1d8bad20a8575f1f57195166c23556a7f91711597dd6d13b9b61701988f9a903b3a78ed811668a38eefc634306af57c507f1ac942b9ea80138c75be3a270335e050f4cc8eb519cab1bb7ceba83717f9bc460c05746978905636f15d2dbd94bb0a2ae40649cb1b485ad16a9b6636d64553191302558f5efd9778f2e8de93d0bc83f8d47cfc4afa74f8d1d81485ff1618893401b36af7dd36c215a5280dbbabfce06b1bf353366f97fb38119577adfad05779d3e1106dce6ad62128bb08f42a75ff695d5059a158a01630240c8d6779c699d39d46c25a5b921b6ad16d868b309395931ced0e937dc4e1260c6a692d2b50fbb03ce3b749d7a1ad518e0f76c750bb97a7a0717b1684cc53424770fcea159e559a194a27ae87c429d08d2ccf0741460668a0ed9b72a34d7df9f3f28dc2d267bf0d57743b7d3ecd2a672d28245ad21d318587381432f95b1de8498bb54d0ac02321128762ec7aa7ebe72b610223328aab28a80e62a70e3979e98c89a7d65b4e24b857ce96fd06761ee1b707b89c43d004fe0702c5dfc746972431cadba3588f1316549bda663187d1142a82f4009d7c0dd486e8cf5dc3f22605fcb125248cb7ea5f970859c01f860729ec0da987ae6b7b7b4bfc83c0f81ddb5b94dfa0cfc143a83bc38ebd5c08b1ce3ea97d645833d2e5a53af1a3b79b71ddb0ace11be835fb7f25598da2183d875b60edbde7bd2c23dd639ead34cee4af9e4d5c9e7f5639a0259b06e77debace059ce5c85c1d351ddd6dab911f9be816e555814df78c5709109d3159487079ed4726cac28ca8eee7db6901412cdc948b666a533898864efc6c27b3b5b686286303d2adfd31f132f5bc468300613179397e46ef4d10bebd4941b4ea351bb74de834639346814fccef784ca511fd38d1d82996f1dd8fea8bc3ed7db5344163c9bb4d83bf9831fa31348a9408f30eb094548483c57dc1b5e7123deaa9e3115713cc3968d9bc9455a5f2ee4426ad3ca2296db6e9da0b3b80cc95f9fa99b8f46ca131d921071db94bcb6937014341e384375134a7c1b37fee02860c70db616176395591a634fe5a108f491c23ccbded2bb985b3a240b8b61e362619a96704f031b079978f2f98aabdab19d506e4d6053545f0cbee4a1b0a3a2f82713e9bf9462ab87c29e1377bac59c90ebf8d59f12930c965decf53dd1ffc725bc822acb860fd70d1d754c81de53a6bedb40bc914054c94b6f62e0da2fe19e4b7d308971350693e5b04ea9f16be97a1b3bf3528a9048b9062700f8069adf5a7c9675c71dfe99895aa4580b88e542d60ab341e5d334935a5194e786dd8ad459bc76cef44b813598e8d7d655f9c9bf8a1047509b550dad40be80373265f03f225a3cba1b5eef2228fff550c34febd7c76cf7219ae2e9b43a3d4b4da3ddba64febd5a5a8d4a6461c6f859b27d654989a32297ec42b23332890f77944a3143551aa4023a367b7ea0477cb4bcf0c0e4664f5120249baa15061b946dcd0dec356d017b4254a8a1da21b150060dbfbce1544b54af25f403abf896e2886832c737da81dfc85815269fb6c10abdfc2df21e01941e3c4dcc351968eba780efe2e686075dffefa386188eb8f98de4d6902efdf85a191c2ccffd358059ac1793fabbdbc6d9621b597bf51629023cb0c9d8f77071792930a79ec9444cbb70e7949145be93974309f01a48321a28e051597580454b4e7ec09d105917a8c02a69d9e3d011f4236a5ce105ee2983246f7bc1ce3519979cb69665579910045295430dc5a118063de456b67d57a7997c3326db3bbb0964f729ec69d570a7fe09e91e47ea77114d02f949bfe1beb7db2e5fc995e135971b477bee37c1e9fdaf86bddbbd9938ee0fa4dc63d710e571949ee55c7271f315f8dca95965c09ca8faaa4cd4c13487a0a97927d335952c606f0704cc782109987e428d6b93aaca356fb7477749807dd8ce6beb9a4324041ada3092015031853e44ff0de0c218891bfbe8939e4af2ecf8dc6910369a000912f0b82ef026e5bdfc3e854e64e9965a1597c213f2d66788019b09cebf8852abe2a12119bc0c941f1338dd81ad3034764cc282d42b5ea50a4541c0eda769bd646cdce479e70cca1ccc81d322d29ebba92c3a7839e2b8802003bf814667bb31c8d506bbbdcbaf04f889a87e215407d38aa6738aab2baae09c3958a441179ef6a745bd738c554ad55ba02cf369d3048fce5549dd1b549ae14fc2a027b9946c1c3e8fb9aa3ed1ce1bd42e83d7c71c7a1871960d418f32ff012063f2e85494bd2d9de1add00229405740f93dece9b861cc4f442d655b81f2a6b8707ca6a63f62d7b3c5098ed3216002e168188be73a22612e28f6dae9ee208793c601eb74191f44817826f611fe5dd0641fd8fe1327d17622803d384f8c315f93ca668e681aa484b307007d387f05653587c52fb421787963b5639a9bc384f5ef0b6506bc9e64a5ea1467b3710435a1a7f33f216cc8f2fb025092e716e3c56b8e7b5f92a50537abe35b40ccc64353fab885f6498c4117eac9c77cfdff99a669cd78f034390328275e0da8c6d11a041c305e84a8d647c71326ff3cf83448ef82b1872b9026cc70bcdc9ecb44689229cbdc6d165b76ed7d37ef7e7e2458d00f04a6d09c7368a690a21d4b731c04c75ec7fd4c578f00750e93cb51d8449157a4a102c7db220e13cbd09e6bdcebf9fc831f670edee164fe0f0bef997ba3604b0126e18c7e97f7acccd3236d62e6f6e1a0d6f9759e367baefa520261846e12b19293ab253073726d46719600f528459b70c27348d1299ab5a93ecef42fc706efd199fd2182ea7d2028090d2b40d9075c81d5efb6755665924374a1647b2cbd70ef8810c8f05e07179cba627064f986f0c32f62ac41d715ccb98c2c802e36ebf73c7dc672e5f90e1b3ecc43ac3bfcce1029e3b6be2e2ee924d6369586a13dcd06df469809cac6f45d0f24b38e4f8c8c8a25e876608fd0d243ab35fbc35b91a461801ee45feb6c89e5414a20266f5edc2fcda4cee6ecde8be18c91eff1c78618131a6effe3dcb92e09257e1e07cb031679e01e21cd59563c1848742fd58fb458c8a15742cc91143e8f3d09dbad9078fcda6a6bfe9ba930b34a0cab6d3bcf9ec1b9106299cf978b0447b0d0411d8765ed13077c3fa8fe12170912eb1529bbe6b7342c7835495fe6d67e38874beca027f8b3173984997162086c97fac2da27bacdb154e0f5c1a491599cb44437b4a1d55bfd34e7f564e2604dbd192449ed310ab43a7c5b80a9c2c5664d6f3eddc97bcceef58415751311d42810d3efe6197f62ff7a6346efe3d092c31b3e1cdcffa38e716a4412eb25dcbd2be48e3177405ec77c9af0361c2c25353ff4ed20211addec6ae5e338d7887b3f55ba1033376922094dea0fd255ff3ac2bd1f73a0e99e1ea4a0d91b052e9d616cf139cfdfa9d24a3cb84c90277b02fc71887ea4e8b4d79858e1ea73118dd85cd687618ef6f7470006721f2d90ecf83603ab7ad51742fb687c4164208cdf1a31146211c6bae830fb9a46b7ca6e3563738888a0de61f00b4a4ba17afc6a0964c4dd08aefc5a42da7d67f668e2b6618b3f189509274c7092135ca94463747ab4e27042d98a37b52cbaa7257d356a0ded5c5fbb093208835e4c360adf95baac7431a0d5066ab3701a4ec1c88380bd8829135274ccf7bc0c8ab45e0e74232e4011087c59e5be60d2b126c485d3751f08ff95f7699c3e95ae1231934ed2b8e74ed04d712c681d2533bc647969d862ac0361079accd7292e0a2c80665050b7cc62296258afcce01a6452b1758cf24b61137e9aafab35bdcbaa38c149f0bb99053e277880212c5199f63626becacad195f55568b896cdae69e8c3181854ec787048192999c4d706898292de18fa38cf0c1577644cb30423377c96136185dbbd59643608ad8f2f0ef5aaca6d82f5623cbbec6a643e5a84a0f773e0beecc8985e2782d73b700a3ec7cba711c5bce03559863978af7bb67e9eaeae3b9dd80460ac4857bf59636f7efa87768e934e850ea838db4838d0adc8ddbbbca8c5cf18fb06916982299019014cd72d3b637a2ef28c39f4c7b119bd5bd0c375144086274e70b5ea6a3793fcbb4f16fbe9628e4828e5a386fd2a41437cef2cd350e6bad98039958e671c2439838863c1dd47527806577e0f63089b43f96f88cbebd2fce90cd842c99e05d1e5715bddfa4a5d91c13610907719787252f8828f98034bb9a521337a8aeb2e139c892348dff1f054a1adcbefa233e5bc79e7cb96561caca27bb52b78b8942a467fd301d67ec93a3291d4da7720a42266a55736a7462b155aa4ff2ab5c94bd076534e8e50aad0e4c8e16da610f0359ec21fa85ce6f512048750ad86b4496bd2e08464665b48962fdccdea7e82137caec142b4211b29ed9a315fd188c201623979c202bbf211117994a730d6787694ffefdf9d17c2383ae6a72239b81e4ed4c4e335861a0026525f4003feb047afe62e344aefdb122d8e7c2182b62ffb17c36b3f3fad99f01f38f41407ddc035026319d0343cb491b483956ab8e0ac3dd621bacf022f709080e24b5e33fc992bebe1ea7ea757250e015e8ce1d45048252ce8838a9305ff130de414c6ef6abd14474837985487b0df9399b421bd406beddb27b187237cf5a49f0d3983e89125dc19d482255444872a702beb31ca37344645da34b34b9e0c999dcc835535f4c5cd79dc088bd505548025feed6b96c2223b013611ffc2ec44c9bacad8e6a95a301539c58460925384273863d2375d515e267542e718ea48d6635e74dded809c08dc1326386cd5ee227965a855125e832985e77d9ad13393ac1f395ef495377baeae3fdf7cb6e88cf453484d9f7cb7eba4888c8dba705bfc3308db3dfb8cedb53149396ee077d7213117ae24f4fc1297aa7023847f1ddc49bdcf8651e1971c366356c4a029f1c799ff2025db76d8ad470d853e1a31a06699e7d05a0e6a4ab6c3ec59b8763053dc00846bc38bddc40ef19fdb60f772bb04e4179b235953b8c2817a4c9870e7b8c99fcaf18c376ea992cf35879b57adc754fdff827321a52ea9361871683d8eba3146f4194a3dd8ffc7f02e1648b87d785444fb7b5ad6bd23c1056b8b3f70ae61e1bd7f58952a3e23cd6a544a89e3bf64cba812066cfc32bee64d0c710ccb56b69f910961c247df45dd1713d16bcb3a5a9db309e0ea5691cdd0c5942760c172555b3685c3210f46390edd2b00921a778e7eabed7167f044dafb5a076737a87708b9f800b97fc4b22fee5c4c53610b5d2c2e5692407ee2cf91dee894923b0c960418fe2bc4c76617169058bfa116eaffaa59f4c525999918da7d0caab75b302d53ea1c3bd43a0e0e08f45193a31aa491e9006a9a8f287c2a3a64b86b22d42ad5acf6f308e41b18cf862b208aa1b017ef9ba0541743cf093de93e0a7075f32159583fbdf5677f679dd496b0c8f9c8a107e628393252bc23653549a86e11480265dee6f26ae5073b3eed69c9b40bf2f4abf75261c796e6e30c32287aef9fe99d93125029f6770c97640cf03ee5a0619c85f129a9f33931c9b7fb802f7aa06cd8e0174b83b3456b97ef4be3122bbafdea5fd85879ae783725768d641df1c5bbf89ad1f2f6ec286bd85db27abce4e0e6b119911e450e90a2a5141a2a572f7385cae6ee19d8d6336520697227145beb9ca86b8644b3443d98f582561f55f539e566a4ba009122e263e12916054e01d08b6b9c839a263c61c48e57f06ae8a16675bf2c139b88e81263259d8ba6e345f715d2abf5079676cf5a96228bce69ff83fa8df3c6f599b5164ec3412e8240df1db18fe01f991a0281c4e7ba671513ef2514b4b2995ac65f47c5c34e2e6eb54d8949c1c91eaade6f51aeb0fbf9cb0694afee2aeea05b11d7bb7834b1cef075fe07f166b01adb8c10686083d64a04629bd7a6c2516ab071112d6d95136caed9aa76e23a532a60e477fb1b97f6a4c785f8fa969db7ecba3f78149adf086e9401423e1f02d8af93597e93e6e4875e51b8e14e916e4a0e8ad7500cc1031be84b805693bd50b73490d740717e4ef9ffe4c18247f452042c8ecd302d86071cdd667cc62f82801202624ecfd32ba97c0f320846e5e56eb7c4f8c36cfec25f3b2750b2e439a6a523806f70fd307655fa874b62ff184aab188f6a81ff3a0ff7fc5519283f14216aa95a9e489cc7c04f814f5d7f7bdc2579781b0ce76388a3189badac7caef32f67ac0d528587e575be6e7ce58c4160094167ddadaa8a595305efcbb035f65a69cd76f138f0080a10dd7be8728edf371172238c29840f63694cb51b017cbcc9743a9c9d64a269246db7036a737a1de18d8ad97b1f5590566adb64431ef5b88962d47565eaca1c7db9da69b1b4c594cf9a522e433527ec83c79ff76f70ddc6aab29a10d4b0668f99f8a230306f360596015ce5899a1de089a1775c60a04a7eb33b86843aa31e89dd990263bd3e5f509e390dcac5ac1dffdc3b6d6826dd9b91bd1ec53f1868a130074b708f9ba4af5a95dc9fbd388dde4bcf803367010ee3638f3dfc20843c1c86181de1029b1dcbbd1e26e229ef54b889edb77a78b898565a9dbaf1e943c566ee345af67b782c99fb2c18ab67c196570786bf22bf8cbdb754032b0b1f1e4cf94a45d1d33cd77a27f6f086770d87375ae6ebc2476efd73b4cccb57b48115b6aab798020fd98ab94214578f4e5185efa43ba33e0b445ba410b7a8a2929b903230f634ac7c5d8620e0104ae5726cb38b396496bb88ef21c03e062697f5a845fe733a3920b3ed7687687344a1dcc6945ba0d380ed4710c32b0aa255c994bb30e2a35d8929e530fb1672b6528632a18fa034c85f4d5f1138b130052f0a1a6077335461aacd76e4e743a44171d66ab04c74c8cc70d29cdbc5bee5554e13f1a72bfe78f8538e27559b92aa0975227ec071eac8a4916add86a14ef8ff850ff5d66b897dfcae77fcf38b322a47fe78b0138820ed21300fced1846e4faaf34a0c1cf873e0480addf2ab731b976b7f9e9a2728d9fd021c8bb3aa002d84312e87df17ba7c015f650e3757317279ef0eb3d05e656a58810334c9e3ecead557bd6cfd5d11a5604d99d3f446b7349e3789d3d432e5d6e41ffed954a877efd68d55977b7d36ada7e68c93cea5a357d59900c949858ba5da56cae5302bb6878640ca245c46532615fbd911e0a767083e249d4efde605c3ef80615590fd71e14b78836e74bc74f5d34ef7171e6b3f2f0e8fb009a48ea49c627a41423dd3452bfcd4cf8f7dfa43797c34c323b6b83285d0e3bc17d36ee1928aec4996d6d4d78ab0769271de59e217a4c14d6483e89108c268c0991d240a8814c03d4e83437ec863f99428808a0a9c296d1965b20e14dc3f9d0b500a0a29ed49c996ad1ae9c1cb7c9bd28284a929ac8ed87b664a8cebd99f523ad2c81df4d21f3e87fda405013a800f96121accfc301928ce4d94f0266c0e1d327c1f84135ba7e92e13884266702f9357e305c1984e641e2c24dcfefe59805c300c7c11100eba7e01be7098bcaeabc3ae9112ac4947799ef364251ca9d697e3c76fbb112eb3fbaf1553404f363999b256bb26e00a5b9375e867fd86290688d7b665b1584bf708b7374f236c8cea1dc93cc70ca50287ef4844dc5a500a6f1648046546bb34af4531206237aee68f683ec6c966de104ffd21d908847ba406873e7ea9f142153eaf0d7cd4a35e2c7839f50d0f48dfe8e672670ba21ddfddc948a895d2da1a5f37bc991cda21217732291eb596e867225ab0833b82762e5e90b8dafc2797e156667a38f2a3e43883e5b81af40a9574a42943be09a74fd6542fb5547c79bc55de3c9eee9ca00cc7cf074af4b23b2a5ed2e83f5aaca1f6957bfffada7ffb2431a696e65f60418645c3081d80871059e66d1abc827d8d91f7e9c2699fb7c7c18b5c9fb16548f051aae99d5431d8c95d226266046088132f4fab93c1926948f8c917f3c8b96c4de4549e3b02ba503d4c331852221ebf2f9bbc76260ed29d9e8edb926de272e8b76185f7223d2e9e1b49de8b4553abffaac9a7545f428e8b79fb7f38a42b8ce0a7decefe83e9c3bf053576d3f8d7f49ddd16a7ee4eeccbba0cf8fd64946403a4ba53e080586e2345709ae7bacf95dc10425ca40ef7fedce28704c03e0e69834e87c94a244c69be306dc396af78c8b74b86c5e03f3bcb37a5364842eb9abeb84c47a98382bcb2237707fe2a5f598ff05888a76027b5bb0fc6e067071b31458c643a5dd7086ef2e2c8f0e8db089c1210b1eab77378713095af34678d8cbaeb435ea923993dd0c3cd2f9783a8992a3f559a2790971209dd3812d1935dc0387bddd5eda332c20a651ffd42377ec74de5aef6c1b06fd75482e6fbfa981d2fd05a0ba7254f8720f060e087a2c48fd7f02ae344c13f863740a3b7a38c5d16b0f38bfdd04e93c638d4536eff7e4dab542d8bc46f91c2bd99fac6ee694966831e1c958d7e7d86a9e48ce159676887fe1156a431d0435b90f4e9862d749d09c5416fdb6a6d374d4577d030875d0ae7d2103ef906007bf05af6e22f01c0a1c7f4d74fee1df26c22aaff805aa321167084bfdf8407c12ff9f9c4eb39fa6afcac359fd08688b6b8ec96ad5da310ee0f482b1ea09aa31375efb81477c82ee209f1f5ad87afb7e02172b890d482451469129ff750706de7060c8bfaa4b413e689b9748d27a6a0430e81e273de78f18b749ee2c38fe1bc20c6b909bc1643df8738dfd95a2c01ba1cf1ab9d73020e5f67778c00243ee7c0b685c5f575365373ec31e351652dc2e3d30eac1b696d7d9859f81c6bbc8392d1d48f0719a9ac10e54217404a25aca9dda9fd8d8007bd6503de7e03a0ef6f8281dff91d1e6eb9e0418b983c19f4677da5704a774ba890ccdbce2d382d51b1618c8bd12cd09793da23732f9862fd3a2a98a1b1fb998cea7c728f274a13ea06da31a457f82a42e672f4e6204f38e6816b2ea9aa8a945fe32e64d181f0ed37551676f5dc122c0fe925b47295bc84c8f7405100306e5b7fe4dfd97f2e85c5de8606378dacef30eb878a8e2396c6d55baf1aaae9c964e56f5f63de33964ac2bdcb5612093d67a6b3fbffc1fa5ee9a60ec7ac38f1d49a17c91c961b21ef7ed0174488793d5fa8a8e07b74136fc014d075980be84a6991306e004572e9c5161f1995a99c1acdd7a4b9cd11f3176688a157d338a270d61e96eaa56daf58fead3a9ab7324314163403718ca36179cb6dd3ef99328ad0232f75a90401d77a675e3d103f867eb4b0ab9012605130c4db6e01922e7a03ab8a52945c8343fb91226adb27d56e19643e617e453ab5f4db7a56d1a24e2c290f529ac9b852c487c54825f7b8454ea44358c0c8b2f54d0ff0517ff86f430fabe79eb36ed158762bf6648340df61f716bfc094f2aaec4b1554db3d8bf7a5b0827a976db6ae5c1f18bbe1f6f79a8038285982c97405ff0d754b9d5f2887f21ba4ea531acc79ca0a03b659191b1ccc82c8f41bfb28bb8dfa0ff9ff466c053883164448b64308a356f245b26cf6dcf041acce2c99fe8a6dabd54d0b3a7a3b34edec46fbaffd85d0d5523d6fa70155917a464626380765ac4ee4c779ae2ab095d6d8f994f10c63c3d8b0ffae455e4a29f8c448b8c3825326f9ca85640fb9bd9b7405638387cab7541297993f571491e040efc8729b4318ab60d4023af2982c64013d41ddb9425102f5a2431b71098accf2618e4d0925cb3461d52440298a905c3436062f1369aa37abf06c2646dfd756e1f61e9d1236390bca3424bd20af2cbdbc548ffb52fc2b7b0c04d619bc4865d9215bd1c1588f331884ad0064c867c698e3977641c6783e09c960e053039ab4fd98a4a89ac213b56915fb0f1ccdb852466408a7bab0e7144c0a2e6b0ac92bd4134e1f185f00956df73d6bd80c1833d943727af44c10616eb623070c78e8955e9de0eaa7b1df3a48b29e82ff47890bb94315df30d84e3d69ce859edddd5dd127744c7720348ecfd89fb60d3bd1fb06c7f85a8ce6e5d06b2f22473ea6c3380e0916b28a69b1428407ce40d8170b54fcf5ffb6abeb3c02dc3709cb10ca42e5cfaab579bb40204d4b4d0b17538c1cd70e28c6f836a07f40c6396bac8c7a0dfde4e125e8a4be304164116153f6228cd10c04768700eaae0a9a15e4a781f971a3fb97a217849f4cc9c64ca5e70d8297a9249bdad42e12241025d1bfd2710ddf0ca63f9455d364a872bc90c1aa676c22d676e550f74fa1919acc4ae6ae52ff5d87eb74e9c19f8f94e9b6ba0e8353fde8c8362f35b1c7d4cd30ed1bc2fb0a940e750540b0c1f77d79cdbfeb7f801b27f17f75c33f2f3438dcdc286442d66470aac616504dc88cde5839443f73c5273f46aa7d93de627d58935d0a7e8adf8dbd4f036fa05d951e5bbdb307d50509a45be44b20927ef7f9703313f8eaf451900c4d33458eaa67538a9fbaf384bc2d1f32ad8a07d05f104bf89d97dcde3bc05ced11a468525502228f5686bdbcacdabb26d47214a303e3a64b2e52f4a80624e67ecbb24d3f554318a4484956c72e8c3367e12b0b386b4e9ab179033f467c0de1022e40f956cf7f7764ba75d842bf77284b1f90352d088e08dca00b12234737ee8a3b35df3cde6a5e6b0a6fc44c511a17d12977618d48114f54f2f82d971ba4f74a1979adbc962f7dd11d85cd2a9a07cc31538819644f0326811b67da89f199c919046a4685b06fe4e5a48676e74e66109575831a44aee812b5b9f9d25b51b622c7137375dd1ae231fa20f5b97b41f35b119af1abfa6212cde47510b7c064842b8c3c116ec6de05cbc87dcb5941619107c97484e21e9b4804442e0cb7e3dd4e7503d0a9fb398b1364cc523371b41a85486817510a4c73ef823b560b91ae63ce9a879fc0031ae0bf35896cd766dfbe00ddae1c7b2bb50edbe0a49c7a45e8b52470ac521a9a0eb0a6b5e9c79f5fb1e689b90da3f9100ea0d5024ad1758337372839885428f184465c146c25c039c315fb14d30fc8a3908e0b9197f65624c3d319a0f8cd687d59a64700b3498256a6839e2f2977305d89da4b275471b99aa499c22802785632cce62242b711598eb7adbdfe004cd3e7242b586cc6a9f1f57103c8d88acb0af5f80f792a2c2dfc7f9d79b790ac4e8a20ef139c25ddcc6c94b785233038beb82cbe8c0a041258ea27856d0ac9ec8184edc8fd63c4934b3a08cffab61db9589db92135cae57c66a218a559d5bba0190e4ff44204ef87969511dfbb4add23964aaa00560a924f3e69674e633e892b77f3d371a60be6e1301d04052db7586a4b30eeda81c1d0c4aede6ebcf73e5e5e37f4ab00231699c73dba6280e649f3da08bb24da449176472fae2d4cf11f61e04daab8f435ca46fc5d656f99313c29950b733f275c6cb3055f29edce7b059422ac903def3b462ec5aab6be0f0e46a49e3517bc500cb3e61a77a81d093600822be51aa9a23d0fcacf5b817e0ee3e308ef36427bd6259c503d2221e22b64f9f2fd1d7ff0995a4db13aca19d70904d8212a650e8d1ee879483fba5c20b7af5ca30332f27ef98b20d3d967eb8f6e93fe328a4255e353f6530fab2b79a3e3625b3e98f8f186e3d0d87f37b7ca1eaf7112f29ed99207d22fe3ec3394ac66d22de26d5123b7eb83a39cbc2c43df0ab8704354db95725a277fa7412305da1e3a02705a860d72186935cfcbbc4d23a6360b969390f00e52aec0b389c978fa97a00aacdf1606d93ffebfa25435abc5c040ae07ab138766a9e5506e0b20fbab17b51e413e62fee0a016ab5772454730a22037f6c239089abc77aa6917bc6890080f2ebdf0c424835531e8d8a3e2da141d20757030d075ea990320fc171ae40ff456787cd470d667ecf90234f1e00f669d9219347ad21fe47626190e9da75c23a16e9c81791dab799260d8dc37e0f46f78e0fab2a0a7e3ed2aaf738cb671c2e98ebeca2b7b572d6712751bd9c8bcadc9ee5de1ae50d3c3aedb176ad40bbc94d22647567d6a4696f8752ae67c09671c95e6f2156be51f4319ee4ce8af6709d6de7b9c835b452686accfc9a869d739e5c02d7568ce9500a5c4e9ad0b0f53c8ff30ccb8ddf010bb5bcb7c9dbe7502197278b1ac4a14a299e1c517562eb81f56fe0a167ab6bf5b5ea6df63db0ee2cdb9ae9100dc6af71d943afe98b9a20a16304798e06bd1471af568dae2b9091c9386c921c379b632467a41ac190dc3c3698e7c72a6df13bd6cb89acf088f0170afe07b5355b3e952b00666104a2584b700e26f590ba8bdf3d025e604d8b630862295db5926008b79bd1ab732005daa18cd30ed95f28b7cbc55ec8f7d92eff0c7995d193e62f50120ef3d0752d132eae86528a14a0bc1a08d395b1a78a1fa92ff9d43d3a263373caa78752e2db1aee43a03da87b9a8f62222158126c6a7e49a4fd85b8c915e535f734404e3ec7caacf2e38ec487f4cb5932fca6f96425bce2d2ad0494a9f4dd808135ad8458e00809ced4f02af08ce2eee94ca52ac6a34f36c97761d36e17c3f9cf090ad8d62c28ae782a83f4f4d8e6548262fc3146d0da68396f1f135fcfcd42090a83c1e3e9be848c1df6d98a22a8a15a6df7feaee7e982d4b7761bfe937989e133fa1a16109339404f8ccf21344248d699eefb9c4797caa772b682eca3bd62b1af2b07ebdac29409ff73bcac323c9d0df25657bfba2ad8302652d48eba2b1d7ebcffccfe199e03f9b7a2023ca8f068060d776e745d6dedf7e247e326e7b6b7b6c25556463299decbc5cec62deaa58f1e1cbe2155a3e4c93d7966c8c1c01a80dce6b6c75d8e385597ce3b3c066b5e986d8996d1c6cfbb0e71f0b2f94ba9482576f31698b2dbc6178c96e83e7724fc6070761beb00fb07aa56679578823b377d92b50886db13d5583be3e8efd6dea7d02a3ee4b3a3e2c94d83287947c2c2d57a60b2dde132be700c6df8123d89b02cdf52802774637d9959c7683823ff34700c4906bb1a2cc4c06dac9c3f708c0d56cf7405c573da379442248e6d77c0ae59d479c9a15531cf8e65e438ff02eadcf9ed3b8eb1caa70762a82ee1418023558495054d68b41d906a8864e59a55ffdd28d8f2efecc063a78eedf1fe20d403548fdfd453327e529425b8ccb603bcd74df431c99bf79a5fca00abe3ed522ef5a28b4b47affb22b888660cc1af73531d19ce24a9f1822b78a1e01ac3a12282842ff4177b8d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
