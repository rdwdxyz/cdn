<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"efe8572a60c9f7f959bf872476ee138f9f6487c800a3a438ba2939574b59b2f6d1aebf9908759d2261289239108263a172f2faf3674ffeaf901211902743a9c1738e9e4e570b1ff9321e3e3173c3020557ff861dd4088f7825cb17c4f1441eaf744d046a8e0b159c9ac0580a79b369607791be407600d86e7aeb68d1b8b63a82e625f2a90800063b1594d9516c2b40dbdbe9ae4a467f384683d5f8c4150f61f05a54abfa7e59b04788fe190a2e5c3a3ddee52d0fa5cdd26585942adf7ea68cc112e050e1c4a5a850d5373b2571aa4bb8858c2cef51e451bccaa96ae2d59f45f08f7f138303b5024f736cb7685585b06bdd82ac8a39d3b3bcddb249fb69dfcc9a1e531a474d7dee36e82b6d6c8c08d2245b8b55f73fdcbf287e30d47e720c65c6c71907f20e766770d0d129a4d3a1b0d59b34b048cc2f8265cd110c2bcced22e878957ee1f980f3a33554d1cacc7d3c1a63cd85dff71ff5dbc0631f973d096f01a46883640c6e1bf05c48dd0d02866f2e7453b4fa159f5c70fcab45770cadae5fcd1669f30b4810d6c5b037b4728e99e60ad3e52a691afdb4269830ce7b687c1dd2e1375233acabf3b1c689c21a51d7034a566ac638c042af954666741bfd23c33c8ece5b80f5bc191ca515bcc8f5986790d3eceee8201f81804e23f61c399086993f302907c391b6f01e7e82ff19a55375aa5ef803b8593f7c247ba454eb7aa481e666ae7ac450cb8daf4915e7a6aaec34584d3045c95e1897120716765b49b83d29c9bf4a525917f3990837c51cf386118216325068f37cdf279d59734bff5f137c0c8016949cfc934606dd093a5bfaeeaed84d230b1170614a890f9232ad1efea071166ac6fcd8ed2568cb762513785e0f7521261da4de34d2175088bf4e1e7ec3fdaf81cc7233ef5c82d7874e74b1af70eab227871f99051ec9a0daeb74726c126e75dadfd64d0f6b3c8da2daac54d7e4c0c476129ca84afa418fe74430d2a45f3810441da913709fdaccdebb1ebc7b6e75f44729f8c0633e9e009e01d747a32b0d2f45f5c5963a90abe5b68d61c90b4c97a7fb5b51d3beed1d52bf3231dcf0bdd24d0a121da94ef608a7e5bc05e2dc8d2498716fdb3f26fdff92e31f9e6490b42d9dc057359c6fceff7a22134fe19ec3ed8df2a1650a6db0ee5ae2c1e74a3387a392cdcf409bf2917f3ebbfddb18323b4c694da20cb8844c98bffacc7421ab3703d0fa121e94acbb0a3f2fedcc4beb838a0094be9bc23542399ca81d96a3c61685f835caae524d9725dad9a80db51cc4a8eca61602df42841fae2da66e24ee460503ee6e7f52d72ca63220147927fb09cab95392f1b3e58c13634911963a40ede334326f7c2252673dcff30820b36c2fdfb43b17d31ec54595134222825e2f1619a1e29704fa0a3af744451f6e064775dac1152a49f9e2aa71aba2c3f1b9921453e6358cfb6e84010d6c3beb38d4c5ac46341a092b3b576bee4bba57599ec2ff2b2d30e8482454bf77e345562c2faec15d3d92a67f7681beef86ac548d3a7d9351ae56e6df85804f96b57b437833e40420ae8930856b5bc7f4135e34c7176977bf09d73943f3aa88834a46566da6bd64cb29aa6563f0d8872eb76e53f2e6308a5d5cb112b3dfb9932469dddef530511a4a1ac56daadff0371c2acc466405d18a10f9bbaaa1b60199e7e698e12844d682dc4e6292f5c700010ad5003a9e6047e48e1a8f18a814eaaaa9b10673010d5f61fd2a36cec567aee7c3c04bd7498fb3fa1eb7bda8a290bbf0f4da308905b08e2952f601763efda9f565a8baa1bcf5d12efb0d7e719d842f15c5194f43543a28e308b9a329dc79a60d0525b64a5c52d223003c870c0bc3193530fbb436334bd1f76ce7cc0acc4f39d7aaafdfb81338456c4bd86f72760ac4ddc875d506ea42b76643ef035b9c759d83027c05fcf19f658992208d08cd39a638c24dfb36582e07c2493666a5ae35728f4b64fda7f93a42b0be183ba4ed08f3f10adcebc37bfbfef34a076b15a6a478471b07c9dc3d1b1318a4068f6ff22fa75167cd9a3632e51705e2841eef4c79915c60fed4546887b16fd9c22dd446c951d0c6a67a7f7297460fcd1542bf1bb29e2c1feb8b8b19ef6a7309b5d34c9e63cf79a17ab1658d6af427a08412d00458633bfc156a1ff649647adf7e3382fbe84c819970a141084583584f8ad813d67ab36cf9a7a30001661e166842883023626312e7dc39023983246c4ff2cb7a21dbfea45b7997599019022d9d68db16d35821395a4d336174906ab52aed9c8a414c6cd4cc237b02c8cdbb641637afec67c437c7629561c154b3e8d6c64ee1b68f77216c2b7968b145e28b04bcfb7305b2d344ac80df37580b1e44c1fae9c527c6b2dfde7dd5712a46df974baf686708f9963b03664cfbd08776f014c8b6aeb7fbd15a73644efb452d3e5d28d38d0ad08254e9bb798e60fa8675480cb1252904177319b76108c406da0841475769adad8f88043ac60c4148eb80d174de077b754226bd46fa311b4579ba8220ef13e21dc8b000268254771a87a85f64813767e9e886a922b7b750a085f38418c833b98f4514e828fd4e27854453843bfe3e3e61ff2080c4bccc2c5abaa05e5306b7db425656e2de3202073a1008b3c461d32034fd449b4ce30c3bec7ee334ee27cf177b58b2633730378619bca20a33fb91f75b498d24a4cb2738c07d95189afd2657c4d3fd25010c641526b9d9ee10ffab0f736e8a7db2c98a04cab9a07a92ae34f4d400bc9654ff3cc400b812469c2abc5abdac8be67acc9e6b1faa1d077fcb73a0104853cc7657b5ac1d2d6c5bc57883203add502641f9896a566df1ec1bc71621f2a3c154e9805c9d7715b5d2437a451f5ed622555c7816979ad2e4d9661e8898d3c1b7e9b62327eca5f93d6aec6648936e93d38af2598b2191bac8a6b2f34d783e55b78bc97b10ef6c385ac76838c678f2e80e6973fdb64f40d5aeff5bd34b7495441753aadb3c44c9522b003d78a999c173009730be00ee743c952f945bccecf0be3699a92e98d3e063f15dc1ca7451e5b1dd9f9f39134fbd3b729b3d5a8e939db6346064573b59155871c0140a8f4232f973ba8a6f9dd33afdad45dbfc8ec45afdca782daaf57ac69efd8c8cfd28371cf53498bc6e8f85280fb1213d50136ea38e481865bc40abcf0ba8cb25a3a598caa98e182de685694df1bbfa8b19e8358008a936cc0b128e6291abe91b831e223ae558b30a9795237878ddb2f755adc2d2469880104ce08c2c42b4cbfdc2cd1d72b4969089249eaee86b8db77073efc0431dac3dad3b64b0e1eab9704488c49ace3225a8899980852cc20e7e8e2391b02d976b311b3ef8d7795d7a54ee9381535b0bb390476dae26336be60b4969d342ca248f1e7747f6b8ca701f274e459ce7fff0a6fba592b5cd914ae321b377c437216ad5de8258368451b689974a78b76f2646d3d4ae92adbd3c1e84d528cc78ae9304cc83cb1d08b105b2b5d88474a430a9d97c16f3b5920ac9d769f706a8f1d406b9717787d9cce10e0c0a04d1cfa20e0ae7243c743e154734d4ab00980acc8bf8810c49bfb5219ccabc66563065ed1e2e5f9cf42392808430e10dbc110ef15f960130a00e6f47a297ebbcb638b3dcb93e1c70f10991f2758658ab8669aebd8f64425c6c9b88eab22a6b62b23d8a5dcbe8ce9dbee245b2dd5b3cf515b747686bdee7b1905340e4d2f4551bfbd7b568cd98dc6abc270c2b8421ce61b17bb3964fc9cbffd291b90b1979de690584cc30db81c861e448c9b7b97f645ac18131aa8ebe4e9a48d60b9d042dfa15f6d1b9ed923287e98bd726f8fcce4abe9ffb33008b6c4faac3bc3a16d5753105bf806e55f1e342a2f1e54d0fb2582f3d2dcec505fb243a9e51493dfc4cd26c6266e0a772a79ba7cb780fabb61a4b86d6a7d21a9060ff28b44ad83a81fc7edf39e495b1b894a1df2f9ca235dc52d4e1c55e2d1f4c89e4322b6193362eebaaa68e4e7023ae7f8d1ffd9c2ea379fe58fbad3e063487a10f962b78392b39012cc24676049d6649dabcdf17315bdbb2b7e6fd1133de66d031b8ce917c1b77b76bb70857de853f9fd1cfd95403d0fa1faacf2d2d292b7ff166769f2c286722fec0076465d44e85f42be5d5025adce24fcec96386e4e0f4e301b848bb5a5afabb9c9c05aa85c0e26eac3fe827fe46861dbd8a5777f04a9b8bc149dda360927ede797dff08d205485a5c62b09190e6e7892230406c5786875d4b071f97241e5bfa68dcbd8f0aa4d9df11fd8facada739e7058fb62724bb2c51063fa2e9cade0a6d0a1615181672a117ec5c46e95cd50fb492f60c9f8d48ee6a7d141e737417bd28e8ac03a1c870383dc1afd730b776e6ebf1ffad12422c29c2bd0f7bac3e3678f83d50b591792d94e1da41395ff1515a9a53b8a3e583bb4cf4cc9d0b89d2acee2ee975134e0596d7f2fd4e80a27697d4cce5ec69d22751ecb7e1a8777d5a12b0f0c340392d3af083e80c30d8894094e325a32a6d9d39b300b667de2af82ead2c26679804cfe74e8c5c93b412fa3d2787fc140d1bc7309966671dd79edcc091c3f6fbe05102916e47db102ab6b2c91941b1ecb0b27921d0f62c0406eac567580b14bbca998778ea963c2217d9ae93bf8e48657d53dd30b19fd711e8ca12042f702454fa71703ea831d9378c95d9f45b2d0ca107fd9d60672c172154424824bcaa323b10bdacccd449777655991b263bfb01c2c6d261912d608ce29441b3cc05b0f5d26b59960a686e96ed36eea09aaf65b971cca0095106026ed302550856680247824dbc04d6281d457bd36d6b02e8e1b073a38667f38d501f1c6c81a3afd93e99c7ae83b99ee17640a6ba54714c54c33b7a75400c99a05f5c9a2a59b70381bfec29767320c85756bbb4300467ccd0eb91d010555db1945956f3aae809f1e4ad255ddec2fcc5211be8b06b7230eb5855a25b0c1f1eb4dd834704b56f3ff9fadf6cb60dc81d5af87e8b51035c8fda4395bdb0d2185466b842ec8ad00dd307481b621f6b2bffa55cba21c07cb990a989bc70585da419e545c044ed759ce1b9f60b5bb096f01287135fdc2e98013306c62c08c1498407cc9ef19b2fe75a4ae12c92aa31bd6484379e6e5e53ddcce45f15aa43641962f3768fdca0236f0b1460e6cb46df17ce6b1706b2151778599a5c49fa6f0dfbab6ac4db9c4ec28827c7929af881e78644856c441809c1bab3dfd7963e8c4f061e142621760809901820927f6ed87165f0efac61fb1eb8ccbfe90940846dc868d312bb0c12346cd0ceaada28b9ce2a96e069ff6d34ff93a8bfd9384d0b3ff9f6cb6d131566dbe3d45d2790acd3f8b61fbe83e65f16c4ebd3eb063f2ff06ff07cb58f4a0b79267b6d9b102b91948065c7d09608feaecf06901a62610d94112013d7ca79d756a85df7dd88bbbac1f8bc2c98da3382ac04dd2834d8f061b8b45073f15a71ff795d4c1edba251d13f7a252f1d7648030f4985bda5f2c1dfa6e346137abb8758a5895e0a3d7b4e26d888edf46a1d4f565b4782aa54914cea4463e609fe5826780903bc38c29664fc6915e16125260e120ab0fad55c7515743a541b6cd05e205a7ab6d569582afe2da3cc2e93e71c94479538d4cc4ebf8d5c156107c424fd91bdbbb1f3aa726543ac38050adf750137ce812e380affd9e302f17028b90d4b600da4aa25131eee9a3e2ab84609e713e546722792b30690393b5a8b7a8b5bef316640054bf82fdaa468e65282c572f3df7b0400009ce9912e04c6176be3a56b360ed34169304cf7e1664b7b6709a2bbd33b0094fed7b3261f4a7ee658ad8e4e622212cdc09d85fccea19a232ad09fe1dda79d8ee2f4aba81dec14ecd2d82b6ee727fa474c6a420dc26d39247bf61d6c94ad7455b58122d57f2bca21cba8a89c77e70ce5633bf021af811a343441b39ea70c2cd6798f0d8d5af69525038c534dfe0fdc945ce5dd929782fe4885c3b1914f510ff406e7eed0ae0538a04839053ef782afc7cef60a9a1c8ea85c9ad12705bba82a429a5c9253c313ec912e3eeb16c53c75dc6ed1482d1e4f1e650a74353ba4782b9064a1b85cdb5aea381534d25f71e4721b46e45ec9dfef5a7b0d6b3976a4d347f5af32cb8ab7284a4f81955a770140ffcbeda5b13cc1559921f456c458519ba2c3e555ed6d705433ff2e0eac07f6627ad3dfb68339ec3f2f4799ec041c036b1efabab3efee6eafb8fa4627e1a46672c1929985ed392417ec815eeb911a131f6a9f6764fa585ebd0e1bf0b94dadda08efee912f94315e0083fd0702edbabd3faaf8d0492746589eb7003c7b2731802bfa3fbba80373c6f8183aabfceaf988e9c02ea86c9179ec2e9e4249d3c312d436d41930e9db78a98311fccdd4baf0749d924bf6983982f32783f84fdcab0c81b783f90e0827973a7178445d0e206113cf5272f16f522c05b14dd178695a94247856d95b9b2c49b78681a20fee1fc36c68dff8c8cbbc751a053ce4cfe916807a12df0c2f1291c309a3b941445434ad1b417031f8baf5719f23e9acd9a8f7b283d939a0d5df696c3d8ddcfb9790626310183a738d2b870ab1934305411f082565bc072fada6d3e6a0c24c50fb861bf6032674eef671a47637485d838803a211f09a752009dc31abe8133a75507a6d256219d0bf21ea8c6f70b91967f8cf81c7e28f0b35c6f572eebf6e55b3165ff272f6bb44c995ae0e5379c912eca90a1a89b613218ae8d15c684744fe156b821488d2baa9c96b379ece2b1976a1b20fc748c87f9dbeb0acdd27da8e828eedef821b82d5fd57ae266ddce9fe093dc452289e7c2d4e49b5181d8b8386c33928e37e0dbd6bd2ca2c932272b9a8c59d7445c2dcaf43ab3dff6f55a149976fc6775e2e0d8da590feef2ce9c08b531f91def2d6d41f58812f46859eaba1fbdd5bc303b77a12b1bd939a89888d60da17e9bc23b0625fd949a2e988b061c1966d867b559675dbe0bfd53ed3a69665990cee98ff625f8ec918bab157da74e6705d1fee41f649bd85cd30b4408c2c810db3e8fa0f7910062b26f1fc8a2c4990e48ec76aab5f5aff5b0caba2ea1c4e320e6f4817e67a1d2a44087ae4cb019aa93288ccb9b3eedb22add4ea12a8e5dff0e265aeff8396a4116dabeede83024a3b206e6be7e1a1e2aefc67bb66c3c8eac6bae0b832e7ff5869b5e13aa5549c3c66c2b50b38f86278efccdaf021ba35b8eb4ffdf0e67fa3dcdcd71d8d249ed22040bf91d89b66306020c8d7686dd6008da5404a829bb528c082fc8c8e7b9d9e224b3ef86789dee0998b3cfd4013ae72f23a62b104e157c99d3403b3cf9f7ed432845988c7c7bfbc5c7444ff3447c2001c0ea378d282f161f9d2c5f0411ea569b129f89f3db6b5149b507c8a2adf3390a87ada56cba640e389a944b3d8c93a6ba85c12f43add00a902bf34e5f5058c402491a874ccec62c676a7841ac7eb396945dec72c9c147e444cc49db9a41f9496ff74b98da1787db8fdcc385c1bb5003c9f0287e1bc8104783e261be5ab03362eba054830bb65f40faa18b11a98ec12583585377eea68425581cfe0de03fe668b6e93a5ac5cd7e75805577db7b5080f9eccdd33a3c456a8704893e7ea2921813172aa01f233abf348b2ec1f7a386c1785f2351e86a06c614de49826161ccf88625fae55c90cfa81e337bb6852addaf645541082558c308ca7d878813e4944e0e2fbc5c34e38d9ed4d966e362112a2c7db3c8aa2a5f23b72ba230b06f9db90c1270e53f49a52bfcf01cbfa16497cc8594db07eeea9cabdc5fe78c7ead5bae8152da1370127801ab1229e9b8c86e6ca8833cb60f898fcd948f751b220f5a423b80d0ec1a4b42799ef5792db8d8b7e797228d5229474a9f8fb29d5520901eeff17a8c4de5fd885a323852b454e1faf58dc6070ed35fe4b9bd128e39a888a18fdfe75e5f4f8a4e562e989654b472a19b3a5c3c12f671583b7983912337ad271e4d65c258044664e7cc541a021125484211b1c304d0584fe0b96a9a85466bb9702ee776784291053a8bca196fcb741037a823e19fa5355b0a8a2fe97802af9d9a8eeafffb5e9736e7e4001150ef481d3a348d28b2aa8dd2947382fbe2eee38a947d7717595cfb4101fe35da5109cb3889b3f7976dfcd0b4651bcfd913fffab735b3dd4cead67f8f1145a5ee24f6cfaebe362b1e85084b85289665ce6bb97df8ed1ef16ced9ffb5f0580b6901fdb5c1b6ec4533087e8347a1636036299ce86593f06fe3dc643ed5c47af9a1104742baa9bcce6e434240d82ca3d283f4248ddeb04db9eed7405680b5dd8503d86c2a873b11e2a7bfee7e997fa55004fee19d67acd647089822f223916650365528e5dc927ac0ee7f1ead9f937661540a71294672c286f946a6f4031780e858693e9c7268b1671410cc39cf11b49129d67b907feadd8221adfff3e91c59f4dfe533395caa55b05e3e5c2dc57beffd1257c30ec71a2a64623d2e2c79bb3878e550e520ac658e1c87fa92b2ecc083d8dcf231c0ef878e1c52cea6aa7a65a7bea97231684caaff10214105ad6614fc406bfa42383fd4180448f643f1405f2bdc2436ab584fd792792f3f7084fff08531082df3e84d8d9b2f3bfe6ef12a04392607b161468aac9d5075044ed009d20f8c327cb935d3ce08b5ccc01132cbc87cedbec1d819ef27b2488c2c20233b8b2d9674b5e798e32c53202c8e9b89fd37a29bd713516c4d9d56a7b43ed6b6db8ba340a9b77ec1a6804bce6ed06f39c260a8cbc65328e939f986d1958042732e174ac2051b77764f0b01196026517894356f09fde5bb6d44c02997c69ead01825819735848415ca59b9987bf81178acb69f653769702ca4484ffad6f7e4ee9651d10c4c0a2c63fd3557ff1b783076ca470483c18c2a8047ff2d97938a2a5442969a55ca99d0a111cc7228222dafaae33f80ddf9a0756bddfee7f7c685eae5fd11f38e372ab04c6df1d2c572f0d5e408aaf0b1f4fe6e7e1c687254ea95da0013cb3ac847f23b61b74d03b31f476dce6f1420b7edf1d26b3938808359d0afe3cc2d5efb8dd26dc7582ae0f76b29c006309820adc05a160419cc6466bca7662a7f62e97f34919573ab6c341203691e9fd55163f3d9d888cb7405fe4dfe7257ba779a3fa40428bdabbd69d1bdbcc6d8def1297214551bfa6a82bbda29fdfdb877aa7da39809ac99b3a933de6c27aba8fe561d9e74d2ea64dfecb5331a8ffef62952b0ab1a7de5f1cd9e0a7cb42d4ae71dbd6f2340e65425f0c4c6ff9529ff4c4267d93e6443941d441de38c33ad492ce87e2b484bf968b2371622aa422247760472b5e99acee167baa3f338e4c5b5f121ed70eada3ebd043d850f65c92971abdc29edd86ef05a496acd9e102b2e4427f5b41e2bf485b83a6072c3c147f74d15dabd94653218009c103ddbb20b98fc22a5f0189594c73c9da6709ee33d33527aa143b93bdc63f914c245d1ebebc92f966fefbcbc4621735ed2e59cee5ab181e6e1602f1468126c5cc6d03703b09dcfc629a13c2420ff98c164e176ba206671284f17e4185448015a57ff6d8bc6c2714763b9511c1a2ced5898d870aac3d33dd8801619b53b015c5aaeb4217aa73fcbedb24cc703175f1b42b621eb4e86e24fb4b56d45b989474e327781f28904c975d5d1e130466ab196f11c4771811e1320839b00dab69e4b290ccbb1b307de84c5365befeb089b7776e7846aff2a08226f4c6a01499b123a5eddacdb5bb733afb29d75fb061aeef17a539aa689bbd755a68541d7ba0964c03694794fa06c5ec17a0d2e7d2aaa4be24ee4073d97e0bb2147dae2125a629809857aec99af6d4d53d91ed5777a460be16c67a08ab52b1c29f8a86d9ca93dd3029e4ed9ee9b2c5736996051e949815197d6070f6ef29bb6141abe898379b367b9719cd977db8d147038e2154550da9525a64b75168dfb9bdfea9442d0714635184a887526ba5d596610a198ee2fc79e3cd8f7efae29d229aeb67957cc341c3fc8881b6dbb1f4e8b43f71a03ff22c02bc8c8c9a3b4cb67f0e3d5f63b09eb71c89ff1641e35efea6b80025220edc6e0a402be9b6b04b140a10be10a8a7d22116cbc259a409fa8e8b33fadbf2d2f7891793e0def7b6c31fb67cd4c12ab1365c35fbbc480e15b50b1182adaa34e58ef72e3dcd8d72e0a18d25d6a7f0dc63091f700b08ac4a93a8cd928f258d32092e3feee9f1dfabd7977a9c287b72bc9d1b39be0ce8e94aaed389315211ba75806df3b8dd7323d7149cbe339d5b7834036f4a51add829e23a1574fdf25ab7d05ec0f8faade55b5e82c52024f0000e95d8363fee782f620c6ac3860ef802ccc217133fd545ed9c7c3331f83e8d0215a89f89d3403b91f3975eda6908052807e5520dd5436deb8456f4920c124ae1fdb8e6557a77984cec9d096a5e2607d57dcd308e25bf85fa5e818fe44b56259c8f6e3eb4a89add47b82817e2fa397a7426a621da8e51bbbda624502008a09b8f78cb76b523e3627f06ab31b6033739d46a738c0117a813251667957d9e9a0673b6b93f300cf668019e852b56f84adb3a1e2c1dace4f760be88132a4f643d223910989a20f2d0cd5508a4f124905bd3a5ba200d116b63e2e0ad2de6cad8a0dbcf79ca7d8ae37fa64e6bbcc49bbd4a2a44125d1659da30dbd4d09cee0b0a52739b63ce4c8ed15097371d4d3554543a4b146f7461a65cbcaa96b2a24089c2784dc5a7f1ee0870a8ca6c8e9ef527a8e6f30e0f8286612b5108fc11f9fd06458bcaf53ca5c293ec2468cb9b097b59bda7058a7a54ed0e583089a8321d82b19633c89a106bf65de30776dfec4c7acc927b119d2745b2e7b089022f873e67143b5c751c0e65ad91ad4280a7d0607859c5eb62a3aa40e3783982e82efcd1cc367580cd2ed797d5e892ed8a466123132aa492ec1bbefdb5e2d0e6f6e058e3bdcb80e873a2a21e9dc6a9d80cb33f2b741b786c4983d87b035adb8dbedbf895de07c6e1c90fdc95f7ecdffc14dfe2f73218a1e419dd3bee822d003ceb2cb9245a984586aea7e7b449677d012695850f3ddb77b5b76f3b1f15e7f7acaff730848c39ed71eac04c07a367f53cb4d60ddde2684acdadfe6cfd61900b7d07488fe70a7ee87ed253276b43b50337fd8711383c7f306c023b38bff4c22ab8fdfc4a0b9e38083fd9e30133efe5f2f81a15d566ae61eb60f40de6d91233f3681732ad513ba9b9d80ea175cad23c4c42c00f951c50ab3cfb0b76df7dc42c72c69695f6f8e646a12e4403067ede1680efb6cbb431524e36071e352870d070f5651046c0384131fc3f38ca906d7d78f15726dd204d4b3cbcabc2c25f81e6f38d8549a5cc31bd317d425e472e640c150c6a96564dac702fc2846ccae8c8fea697a2a372ba7e0266875f8d10d01947663c6234aabffd6f4ed1a8ca5cd1f900602ba81eb75147af25dc35da3ddb84fc5772c3139e8102858f230659061fd69971506ba5ab3840dd8a9858f70eb34d3044ebbea15ef42fa650ca10ea74fc5753c9a26876016148bce8d5080467e0a9c62270e36374c70f3b04c1d62b9d9099fd1213a83c2384d46a710e4b744fc0f63658e481c2d5d193e1be716d24a6ea39e69d05bdce2cd0e1be0737992b71030f9d411f014d373e9861473d23bff983e14a52417d67b9013c638ac49079785e5fd08bd9f2d2ad0802c9141ec4c91aaa3952030451aab0d350ed6ffddf0ffa7ac25820528ed4563c1492171c62822db0939caa84a534e85ea10f3ca7d2029d7b29cc50d01023d6f8d2ea55d6ab23436f1b426a48d4e9e234b1a7e3318576807f7140e407a4151eb54f979b3197909351b18ec08763efb12b39b5f238c72920c893f67dcbf6520d52b3eb511ae9243b7b5e500776d2d6cb2e60c50e99c14009a3dad35a5143691d04afb04069f49ac7eeac9e8dcd183674c4358e51984b3f9353dafe0b8f571709c7a9a73aefcbbd3e845b24d67543e1c43d3599cd1138f74d7b455656ff9f39ca790f459100546bc89d82d1b84945b8daf415525a5b9f3b65587ea74959a7a10466b93142cf8bd0aaa36c853ce091957b71fcc159c14967fecd9bd82586007c9e633221b4143e5aead75db8333694193cbeca51e286f87435892d771518fd5e049a5a42216a135e72b60ca007737b4a7e3eb733048291ac1509544085c7fbb98e7efd5d962b42d093c4b968c9935fbcebee96b91db9770ea4bfc1d796d5acf1994e3f02a755ccd23e8db44d6dbe7664542d842d6e1a8bd8f37f4b706ed3740c5e130ca2ed81c32459244f2b5c2b79a077a3af73c0e61012c898bf8c9133e722d110e3e6393fcec3b6ba49c0f52f475ae5c9471f8ce126de8dd259ea7a6b32c4d931a3b93477b4a98d633bce3cc6084195a7afe35d23777891874020f6a411c8fb435195427d322b39f4b284f91a899a7b2a77d30e11a27a93d6b0dfefb0e3fbfab8b38db85530cea708e98fb7dee6786589da91ced802d0ed9be94380b23a655c60c765c8f41f96e8005f924042f4a0423995a3cee773a3c5fc0f2a3191cbd32b9595260285af11aa52abebefdd5d3c5cbbc3448f222f13501bca7d77ff9ab97bb14256f64105119508bfcc234341d80153bab42cbdc478b0aee6d6c61f27a7a7682c32d8b1d17dcedd547bea2248594cc8f12ca2732066b61cd3fdcfce6a42826e121066dbf88e8ba5fea718bc10b0d5e3fb2643ea2153aba46ce024e233759d8d1686f8f4e76d946932861e8bc41b5cfa6534fc6716f70f35a29277c73a359cfed0ff81739e98647b91fdd0729ec83813064b146829de3af327b4b469bc9980d17008498fb08ce4ebcecae993d1132c7b2ea105b462e69bb1947e3f534935e2fd46e7a1ad7e48f5e39f37d2e01b2aaeb1732d698fe85e58609f3b3a426d321bddf633efa5a87acbdf56f35dd26f0849e91988136d389b4955aff3b393f8fc92efc2e158a005e8628a0811d933cc767a8ff2c6f0ee359f0eb1a091abb4f3c9ea0260404c68bff7b381d93c21f8fdcc1839601dafc27258f6bb6623114d6c9bfd39b68a0a06c3320e467a9698874fb7a8da1a37fbf3529c7b674df39049ae6101c631df16575860f8647cc9e656d41b12e28f631199769ad1207c954c47bde3c76ce067cc66bc7c56f5ef6e6abb01ed06d29f021ffcb4561b634fac743c8342687d938189d1940a36d130edf9bdc7cd6785b0081dd590e075aca014a7eb577ee9a9000db76123e5bf4391eb823b79acb22860cb10cea5fed9b13b71f7eb54243492f2196852968326552081df1b4ea3ae1432216feb383b81717140f2493be2681693ded0e05373e97046255b2b576a58d11b3dcb4b04dc4914b4868ee14dc66f972691ec29193074841a32547a3db6bada6bf01d64896c81d85962e6971f879826d10accd72eba6c497c33816f5237ac638dcfd4f509d1e6216ca5f2a98f621428a826799213b938af493ffae6e0f53fef7db1326b6dadc40b385449327e595c14e8540e6c61a21dcc09faed920693fb6e75d336646cb69c8a5ba96cea13b21e20898ac091db9006501a242d0e67c75afab54861f5a8e213cfc316addae5fc8bf85370476958a89287e7e943c9c62f370936cbd655b3a101ea7fe80dbdee6b87a44b3648432853f14fbae8d0db706bb6cb29ec9a40b63e76010d7b3ce48e2b492f22b4d65b57a6301d61b1d7e977be0d8a1947f44ea907ed6f690a45620a612c459d25d2246d5b3bbaf881ff610518d2ac6f040746282b1d054087f7ce90cb8bfce4f44dea0ed2fbcfcf92542b29d39accbb66eb0bd68ac7f6cd0ce894e1fb4510675470268052630d134e5a0a1f0283adcbab9a3f3bbf5c5fb393390e7496d7cc3f750d22c64cd138e6e1bcd7c22dab024667e3a51db0ae972bff81a7985af04fd4ab7f0b9ff2afe4b1d4ca421c4c6eb1f0044de04cd86b97d8feda1b3e80f7f50703f6843ebb31f157a525b48944ff50cae4637487b2320eb23aee9beb08c0cb0f1d4196ab199d0411917a3c0e0455b0e512fcfa1b0f51abdf8ab675b19bb6938031f23e9b049faad0733bfdd4d542bb3082622f60a08bfcc0876be26c6d3bae8b614e5cf71cb1c0155c04827754db938fb86dc7ca4aedf2d68635e4bec5ff28befc29b7dc93c25ac05d92e6502a04876457e45557518ccf3fab94e9ae087af214eed06618a8712c081fb7a0acf7502e55590eb7f83308403abfef64804b470c6555fc941ab4bcdadaf2e5886969439ca1b99b05453ec0b8bc18b490c91fb83450e2c5c076c0eee828cdc6525452325c2f18813f58f75601c8a142a0a29cac98b3d44a3442e20653bf1ed63b5ecb00fd5f34b87757dfabddb84c1b3ce811e888a649060875964df303ee6dc4d597340b194c627cdb37f25f3313343a15ec28d9c6f91b302887c8763a8563fadd0e2f4d8c406cc6a4419220b10aa754f46ce75f7e434075632bb5bc0a61f85d6dfe74dd428bbf8f08ec7707dd84538b3728ed5a948a800a03dc289d4462cd98d43977ed8a51b3750da1f3e744d227dfa1992cc82bcf89d26d2f9b637d9738bfe8ae26a13dc5c84b4421b360e3b3f346776bf7dcbb918276a000905de0aabae6999a8767e973f0e6f37f3803bad371550ea6bfba7f14c84772c095833d98a16ee41c3db564b318d5423fe58b9ab5adbf826b369b913d4c7c3f318b9a6dcee0f34d19b42f5da25b5d97a91b69a8a19bc79df5160da318316695a29926646b8954aec9314afaf0daf5e24140537214cf3284176891be63a4b3866b659dffc6235d5279c4f45acacf6bdbc5a28ec15b240843223627239be06285c0d5a4f519f4252e66c50e63270f958bc8f3bfffc4f8ea381113ad766b9b58533436deab26742d119396a7f9d793524fe3cd1f448cc9a5938aa185a909c1d0aeb2bf15735499eefd5e168e9c62eec1235651b2489a72c87161882b47c011bb309fd984ba6d3b3c368db77f14f844f4769a6b23a2b068b532a549780b4b3b72373b61490e44bdcbbeec0fe1ebc2544a99ab8b2715ef4f3b3dcefa6e87bc16da0c9666da34a34b7ec1976d4bba6211251709c0fab8c1b4e74f76c7d4a0e1ca4d6746a871690fff743d01e1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
