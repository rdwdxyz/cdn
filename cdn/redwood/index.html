<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dad99ed8169625ce00c7c6c3244b5836dbfbbdeac6dff90488978bc83b5ee51cc49aa30c5b7ae9e98f9103b47e703170d2777e97faf4dd4650177188b18b4629ca0d822e0b111c9c6261fdd276c194b46f11c5f8e8d0c7e1e9f60a27ca3e93e88cee95314c1ddcc640c7189ce236ca9ac3a4c3481db3ec4669f8baf239c0ff90a784b2235b02bef3ab72710237caf2a2b659e2559c9a4fdc352c609b3c49b1fffdfa6cbd7d33b409ddf6d3ad675738778b156ea668813f837931e2bce794e935598789c7308e7e4a1c4692a1b1561b3519623e60cb2946a8d68ffb5aabe62a0f9b9f5d57630bda9b515c65ebdd0b2c71069dcc65082383fb1b9a6385a205104b1ae62401e1fd91ddb8689c367cfe20ab6db924a5f885160c3f32bb4f8d68d65bb3093fbf9aacebb256b5622299000d6a20bc23e7558604488936fc7238caa16c14dab1ede2b13fb6028f6fec64ce5ab96e251887ade722583ea85ba653bf45d354e66a9880625c90a930ea3a5d6946297b7fcb4b502afa1299d33d682a5ecab0e23d000f559f4d5dd6661486afb356693cc2acb072762623393af48a40f0bd62f16f44b19e87f900e106f90e67c2617691d3eee87c68512c49bc930626eab76ca99e739313c0a5698a030fdb6dc6d2303266d0463031274400d5b4b20a13420c04d216e0feb201fa675cb7317a0d123331e3d6a5d26fefd0e431379bd5b1ad796284a3f1cb717d1fa8ac3fc664e193b80ef07089f73e5ad6dabf411e8e40538869c0c62f2d243665d95e3ac2768e2216cff4e9e3ff21203b961cbe098daa626a7e1da52b94e5f9e832992e5747988fa5a210734fddad99ca0f843efa6541b071e2d954b0cabaaccd3637e7d867911ea4f5be054bc77cceede9046709b35145bca4fbeac81523b097de5762eb605f45d15a7f1136836f5e5e0c95344673b4e31692a6b07fad12874c8139645147736d7a87a88dbb52481af397825b42ee1e391ccb31676de113c58c362c6cea0833581e534ddcb142a0387f98e4cbd1afac6800b37abe75b664c57e04dba2e3f8ec25fe62263412b41649ff376ca8909465424dc9f8c1d8e92a86dd38ab88dc1b7565de81a4980b385bda99df5f57677e46fd6af13df09e6d187ce8eca0d1f95c2e06b7563dc7b58b7ad13d8760db1f3b7e11e847576a7d8eaf11d6f6316d322af813e8ee39e5d711ef0d0cd90bebb6239328006246cffe0df53c7048152324ed6934b2680431d5101e1e1cdfacb71628ce1c05220d4cc2e71dacd19b67227352715360f6bcb6034b0806efa479266aa5195f818127cce34ece94d559ff528e91ac6154797ea57b201d942518e59a0f6c71e7d96ba7488840d2fd43432d86d96e20363ca8a1cfd26c8b539271d3de2a500d687346453b1438499682c8ad8ade229e75df741d8214688ac50178532fa9514faa25590f038d8da70504a75c21ef063a211167991c1b816ca9b4d6503d76476e75ef33b1a6f84f29f1e2fc973dd4c8f6e695b9af335edf3072f9782a0766467612b71127b6189559f4cd93985c301bffcec68d0382ae8a4618a695d1716568d0f2cbf2a3b7ae5cadf56a178724bb254482331501cd6dbe5427a1b132eb2cfa13b2941c4554a7d8680a8f737dc1bbdaa4cac59efab54b2a9d13d690da8b132ad8893011e476e859b54802b77c7b98d7456d04e586ba01c3fedc4bfabe38d6f8cd4189e125b1c7d3961966c120b89153085ebd9653b8ed44f8ed0d158fc482466552d541e2b18f3dd9209b18bbbd0416ff90a3e7c4e3d30a923dc94e94ef1f662c87382d72a46468119164630a8069f9f69b65ae57c3cc573b4c3cc218aae96fb4686c959cc07476033c88b1257fc6030057a59a54b3f882c7783c06e6ac8c28562546d2eb37d461281eb674288416b491f81fb2116ae6dcb4ecf4f2263b5d71ab62ec1d9b0ce66882cb0e895c05c89480e4a9c22f608d1c0191c290c238d2d6983e374413d510d2bff818bb014ddb630e8bd9cad0236cd4ef08c4c8a193bca9cc19e22a24e443a25f45fe8417890b4ff7c95720c37f8180348bc87dd707ee47c0c1f5ba437405400a8d7d8c4f7e77dfa6f059a0a4ab288dde8f970489c73178d543a04b82af76f34c0efbd6155f035f9bea201c5d5ebbc3dac68ff9b9ee661bfa4a8b0ab1ae91e1775d858738b0a930fdcbcefb3fbf44b1d1dc77d5f4232b0655afb0366544e837918d3790a592a97bf4be4aff41261628baeda6d724614cf4d2701a8c1fe4fcce9f5eee23e57e184b64beeb8c1994a6bee1e4113f29d3928616a7b204e59db94031973e8b2567cf4c8f1bfa2aa008357722048337b45b72050308411a251690a18ad2bf299417ef37d50ad4413a9c12648e1d546f82d69734f9a3dba8482e2a0fd963ae13c81e3cf4f6012323f67e79d62010bde0def856b35491449e538cc7259a6145f443f578767ffb28790ee08acc30fce1b17a62e57b312bd4fe83c1195d7b7b6377806d153f3ee348023d8f7a953535cb1c3e49f001918d3d9318c4f2e036496eee9d3d763fed38bd03ab1bb711cf2cac13708b59009198cdf00f898f05c8c37522a80310d548a3cfb99d81982996b7b1518f573eadf40999a6a8958fd5ad14482aa9e04d6e558260771cfdbeedc9fce1226b73d823580a218c2e1eaf6c6ac4ac9fc5c9e1fd5886afede99e8094c692d494c5d27f7a1d5245a6be88f201c98f0fbb5992a6b5d5f3b40af9fc824d6c8cc664249b79bb8ca134089d35ed36ff7c520b68e380a9cd308a6d116af392f69fdd450c64939cb5626e9d26ec5dfcbf47303e36cf4f6a506f69c3ba951b9a991b5b95e759a358bd352bd259b8997fe21c4c9afef93a43cebb898fd25e7debcdb36942632d9dbbd87235e8630bca1cb3bdba3e25aaba9bc6e47c686b72c90d4876cdb129f93b3183c0cf3cf1dce4abd9d7c2215e9332975f48ab493b544adc232484057341e4888657bcf510e4c15697abdab9ad06fe7c5d1cdb43fa7efff2b5d34aa8015f433ec7e7d2afbdd8ea9d7ece6a86a7583319d7a9971a9dac0e82b0083016f588af00b8a9141ccf88b779199b4dbf468344adb36125094ec3e010c7e492a0b5630c83134692c993ff072c43de7c45d2e32a078cdc0b866ef9c521e299ec2ba05d8d5ac07a031f6d39f5109d75aab83492aaaad73923e49c68bf874d87e94aa427a98005d7356b94f85103a5a98d2a8fbf75bfd1a5d85f27ad175cec886b3a92c7a2cec15113ab5568c497f53316f16c8afd8daeb336c8c0606439c5b17e10d78fe9cd608dde9f60685ce9eea2cfc550db9a06dc9d53ace795033823a7356db8153d5118e222d500ff35ec34cd14c87ef7322013868944fc71b7096a209ef7abc66114d05647b75e695e55684da12b4ede59ba7bad2008dd7b0dd70b2974ff601df5457d7f25f00e6a426a6f02de392ee913521223c73fe7c7b2c5758c385699cdc9b22d56fb373f448c2f927e526279db1a4f9dae01f9a058a0c3e088a1b41796a69013dbd9bbf94ce50669ee26a610f6407e7d2cba2545831616a0a524329a9b97f114786d94af205e5c105f4acbfd1f716e6ff585caf08501d4bfdea54c91dc736ee10d9d796cf517ebce952ee446e72f7f10ef063e7deaf481cc2b743ebb77cabf8789a876cd5659913bebef202f9e0f141d5f901b7c7e3b761684fd15d276af73cf97d6e3c5e4514614e63b77593e3b2086844ce6d3e52cc7257aaf363fe95c3867a0a74c72400e8a3706175765a8466774734a18fa54c1ec3063eef015dc1bce99fe017d475961e12e664d649374eb26f03cf8af23d6bbbd6e7f64ebd408e005f0d4885167c6b369d765f3f59168108c1f27b463211fe5f73cab17ca266f7b25b46e2e53fcacba17780909af32bb736892c79549a1e6e615d0b565a6f7a1eacfb507b31f7d994141c7c2d88990a94bbf4ed0357ae533317ead8243954cb8ce93571509b03878a5f63b8e516d504bb92e30adc211bac82d476d891ef9c7dbf22faa9c45db16360f13243b0f7e948bbe67c3130baf8b506da9a7d4820caf208dc009c7211f12e6a4a72f3fb69fbc246062c1d62e0a357285ce9ea7fc155bcc244e11ca2b9d0eefc7e7e6da0d222e7055649ffb1702198a7742537581bf9627b405868e7501d48975c1cfa039e47a3f29c1c51677cd7309e5daae203480ae877cbff9879807b26128ec2a43ecdf044efe9653a2c98ac2f90881e73fdbe10e95f3a72d219197c934c9a18d53649339bd4384487968b0800797ec76c1c54d2747fba585175b894a9182ee60dde1066bc67c23ca723d723b5f69ebbd0c07e7b4d907ba6193acca7275fdfba16c1010c66c26e34843cca7e462f7eac8d4b09a0103379afb3c3c46ae59d135983cedf491218aa3e2aeb76d2ef43ec602fe042c08905ce58b287b8f9b449a156375ec4726060884f8eb037ff21c77d59b7006df7c1a754ada7790c10369e3da26551a12817adb6822b6f1d4f89570b8c4d2bed6edaa0a793f40cea98c5e5c5c80227e80c2b39560fd4996d91bd720427f15476601f3801a724deaeaa37eb88daa0202ed267b75319bf091acd2e09d06d1ea38a99913cc499c14ec0d80d2af71384ea6c76762743754c35b7168e786f83668d03f8704bee155dcf508fea04cfe72edfefc625ca9609a477b6a000354849b3d45af42eb238d4546239eafed9cf07a004c90ce29cb27d5d44bc2de28744afca062256a58fbad2899b4b3ff6b9cd6d91fc878cafec052c39eb99f3e9d8ae4f1030f2721e673d481a91b004f94269e1da1554a0d90233e8e1bf3f5d604393ac32d527d214f642360b99e664142ea4a55d3f84d6f8736effb4d330aafb5d5183cb5beb32e970076719494b51ee2fa8c864bf0e06f09c6e69dbbc5d652fbc6e87b0ce2cc930c03fd1c094acb604a9d28bda694a5609101004f32de392623662416349beb3813c4008468668bd6a427096e5017cac10fb89ccde46e1cae8f51d131c894ea9b427c5aca3c7c8468179b4197479fad1e9b27945134164db7fcf18f75b82473a38cbca93a9ef5a2747d4cb3cb64e11566691f2f7f443f4f865241cdd98daa578124763a8e5193e3c95badb26e59741ef264b14d3bf6b55f53cd7497e2a5c7ae9a459253b133baace8989357f8d850e54af3c4135d6d5e2aadb6c8ab5a045e5b3b6b51365c322f1122e851a542cde1d8f0d5b9ca108106843676cd1bb77c427289a696762b30c90c414c22e50ee8c6c3bc5f16926fa90079e0469cd1f8a90dad905d6cb94660a997ec8c6e25ccdcf0a321853b57f5f446ff93ee3850e64adc6102ba92030a8ca83743f3245bec442422cad6ef6e1d0e28a0384cafc589862437afa6971a7ca858931f60ce84e16108fabbed642bce152ccb415fb3c37613cfda84442b86aa9cedad21a853ef9ed687c706401a65a1ac36ac04bb05f20081eb7d8a7003055c705950ad6523b419f3330cd37d692f5d0a7741f053fc38de0c1e36cbc3a03b03792b5369134a9881d49bff7f2af9e5c2375d3d2623f6a8dd58ab576e2135988c03ad04b91b3c0998ae85271bcdbbc39bf8a22be699de1d363ad396a0d61e4ba6568161d4274df8ebe792668a73dad404dc0672ebc3c708bba5de337e2c0bea8a2f7d57277f38cd28bfe81a053350c9f189fd1af1ea78e5fdb47187cbc3017d62548cd48cd6253646db82224c69870a7b0e8f13a182854aefad0adfcd1fb8f9375c9e56bb5a740d7055c181416944228713a9b95d3ac71639276020fa8f3321c9df87d8cf2b446c949166d5c5167cf2458cfcdbd359f02e838ae30ae5caa4a86fc6e1325c57877d89c53e6d8ca53d49f7b72707fb848f95687d6873b9f2fc56ca077e17e3f3cecfb7012b3590f1e1a237cf7698aa2795420f156575601328c73dd02403af97bfcc22be103a76b56d8510c31975fcaafe740b32c5602b18ad5420c56a1c5a98d418f169124367eb9c0308ce651f4be7be26ddfcefbec9cf508f537b5a319f701336ad6bdcc2a17a82e8ca37d5e89b440b16ce5b94a89a3d18e4e1a9bbdeb5e75fc1ca739b76be2acc2b14830fa2b0ce60266b85be43effe1bf9773dee29a1e56623cc4eaf009211626ac79d4775a853a6cbe36b7e9144d42dc5df2cd37927526b258cb89588cc42145482453a2b3cbfab6811e7092d81a7a5cc720967e7a97fe87d7826c4040d98dc645f1be81d0fcf66a7417eba18e9c7a581168c31cb4a3a90b9d47143b90481807223a8e5f557ab32082a4c410e32b599cdd6a4de2a4403f861309ae27544c467849a82fad3b1eec8e0070cf678a9c1d8b899439f85a2bca8cfae3eb6269ed389091531bcf4cbeef34676c23e5a0e4d7147ea6b0891544cd8ee20b55466993f295e6b673d30444de66fd526501e6f074a130e79871c74edbead4b1765ac722d16611e2d529d92d11a07aeb55b6ddb707ae58ac3b711d5e3f5423e8793e73ef0ceffc20f23e23cf1a3cb2df8fe2a7c9479f36b7870db1d0a88d491acc971f5319421d61e71bb0cf8a75997e49625477ea631bcb3ffab1445bea1a4060db3a9e862af1d8cd3ff2b12c48726345332cd8ffd7e6c9a61ef0e1790b873fbf7a2768cfadaeecebeb9092c936dda46b7cd1eac67efc6281e413ca9e66bc062bab03e34b20c3831517e3a8d5708ddce87a03d06c5ac68c8563fdf9bc603237d51c86338cc80649d9f6d59b96231f9bb1ee436aad02f39b1570e0f3e12186e6492abd808cf46e9185360a5dae42de25eed8975355b774c28ebc6a6f5fe6f5acb8b62000e0ca9358f851eff203064f1ff0305ccc013c0e691d96dadf20e3c6334779bc7a0612e5e30cdb0b3ef46e2c7e9d7b4f3d1e31ee89a9b68b0ce8d156bffc454204b40a6514d2b04a0a5872513820e4ccbe76b00c0983d4ee8df6a56b0dd61baf6c55c155d08ed2753bc007b0e0135b62875406ca53086c4f58f12446048017507479757b8700be28e1a34d1627c6bebeec38def390c6d9b209e386f6edcf99cb32826f6c1f6f81244a2e34af70b219a1770260b133079ab34aeca222918a103d368680ab9edf1aad4976b662f0202483dfb3ec921744dfebfd6e4706927fcee314f29443c6d409ddff1681c4768e96721a33e4b215781de870cc9a93413385110bd9910d44bcd79c40fef42f568c0c5f29c3800d5b52cd0eb9884229ab43971fcdca4ed3dbc50712035cff9029baf69190c946d7b3b76276e49dffa50c71ae8c84f07158fee23eca1fa2b448429f8bdf957bd8cca5641aba09780ea000275f7658aa552b549f49a15b9e8f924d31d44865f2426c2172e01361bb030533f7adf3ff424551d375c4f02f687b18d290f1e7c00dc9f445968284b34f057a2fb5f07976f977f3369cc34f8811a3455876a488afd8d8779513a6c97d1060f4076b7baa6f4c81a31c052866fa6ec2c4e53974bafacdacc4d69e850f07d4ee045d686e897067e5c4b70d26086b20b6a20809ee199fc97422faf40c174cd9fc77444b3828a333ce5fb4b8a5d3ec0201c400a63132bfef95fe806d29d9fe8fcd24ea9161b9152ce9852081acc3e89828f5429c30ca2e36ed301984920fdf021315e850aeba461223e215d2129fb45b9649e35897296a6f3f5b046b51df2f2dfcb9157d61a8f30eb20e073ebc9d604489094c4bc62f103955a659dbc118e2e3b109f336922cc3ef99c033614a9d171d063df3d6babb5639c0fc198d561f68d822f49add49424f2f6b1d497867bad266e90c9eede805b69b6920eee77e3e8fc65e0cb925b1ac4225875f1b3a37a93b06ea82534529d8e7f98383d73f7594c537009cc9f399f80aa5b9a0034b09efb1dec1cbe7823de47c431166f29e6d4b16e526dfde8a1f95488fe34dcd4cfaa9abd2908eeb2771eb32d60921dfe73ed172b4503fcf275ee312e3cc24e83cdfe4f92e31e48cb054bc1eac2468bdb5612bbe74b95779cafcc563790832f6790dde7c40ace58a2d84a8a9d72a665177f5f7b5526b62861267671cd171909deb4751da0deb805f976a11113abc6c2a89db20291baaff12913fb2d6623e186c40c98ed1fd6bdcda64c313c081b7e113561156806f1417947bbb5725ede546cf6af04f2ed7caea5a5d23aea6ad2449fe1235fb36df2d2c3cf448e0450462ce5ff4632d836f55e72e3bebbc955b827200c56d568cfa5337a474f066e6065f91e71dbbf04eadb99feb3db88527110805d286922da137543fd0fa319ec9fc9695a3612afa0c6a8740b9053326d751ded7c0c6667ba43c31f9357869e31f812585d591f1911d6360eb6a2d8a4e0a71f7c3fd08abd786d303f9d0a8ab6ae15b1777ddfdf23fb30ca8f06d4bdfdb9596618d5b1cc4d2234e7b1d81800c7460ce2e02b570f1bd82baf45fd136692116016644a199084b6d9e17caa8a5dc16fc6db4565ec1faa95d3f2fe1e5e3500b9a9e5105daa5a33854248b9d8a6b8079938317978bfeba251c547c6181db76cfece6ce3228a40302198ec21a75a91616d8a4202961139cd71e09f19c15dd6dd8aa5bd5825fd576a261de2ebe47870c0c48d58f1d8ceb222fa296eaaf04a06e95cfdbf16c04f78a317a0b03d89c6d6c27c45904122656a52d19c9562d893f5d71a7bab62abd2b663810a3a5b13e86014773a624c0fd0315f9c674eb5ed127df2c907076cab4dc59875d91d0b350c837b47617de4be2273d2a38452eac4da1cef6e410d4b7b29e6c649092b0f5f08a08b8f2e61ec7ec5fa46f5d926ad7db1c1e11adbeb28f129a0e4cd9443734d390dc8a9eafe77988b6398d29949fc6b7d8b7593304601339d017ce2436dae159a5bfd17137e44a7527dbcaa7aee3aebb52c3d3a0d6d47c6bc1263099a7bd4ccf3d688733508d1255e34b2dc4facb301568ac7f639fe201841b6869b6c7efb7ff1359479fa7d4c35eca5b911fa320f815f4754831a0a0cadab93a6a7dabaa12ca68874ff4ea047e52c908f187f9305bd52cb2dedb32211f9dadce16b5b2ece5006a47537fb76d5213fd00cb010dd70c19a39eedd49bda2111e05f66cb2bb8861385154f7db9805ad51b6656b0321a20cd43ee9885a3228776da184b8e98adea704a36f0646b5c21af3f5f9cb2ddeca2f3f7978ef297daf644951f1e9f0d6e850ee0fb7b5738b6f5543f7aacc1a986b2ffedd7e4c7cf14c9dc1ccd00891cba5763dd47b857ebb2059aae782a29f2a6bcf53bd8a54e2baf18449d69b86a9527fe636c9ad5b93bc1a4ca65079218a2b74c65efc5d4bbe1299eced5897db4284113c56fee2163e02c4d0855588ffeffa7529080be98c3272a30844de3336160afdb91cbce65cf5194e33d9f122309dc633b0936c8c284360b2f16d1db75cfa0de3ccb9f948dba49f4712c761e4eab4910f0a8ef3ce7ecee6abb3f53dcc9ad3f26f6f4390602a930c73a1aae5eeb2a629dde6495a91a84b977d632fc7dc18629819a02fb46faf64f885c616612e1d61cf9e8a4206741e7a5c5396cd1d9c82064d25520c2fc43114c7d810ce59552814a3fe0d63fcd41143dd4a7825ad121d831625dfceba11af2850f28b8df633a779b2b787f2691edcdb0e40b43dbcf2b5a56ef06ba04369fff772a205bdf72cf9c396cdf16ce3c00fa5d5f3289ae2206720ac62acd16c0153a23fbb9c0e831b0c6753f35d5c6a04791e14b20fd2a5d0c73470479a03affd2aefb8ddb986398236f2262b2098ad403c0f141bb2bc6d20c238755121a5b797a26337c12f8a3c0b0e2c716244c84b3c23f98dfb3e0e63bfa10e15a465a8b8e74e774fd3d6912669c207a528bd88a5461bace59350095db3dbddeeaae2bac3ecc89d5874cd397583959b7af20fde737fb55540a6b079acb008d2b45577b8bf4d94e8f498337cbe62eba620b5c72302d498444affd76983838d65b9c88e14a56282f03338e39cb54753edd82a5638ff221b191d9b730e46e5e32ddd8678cb50dd7d0dd88d36f83e1b137e6932f0394db58b1f10a1f628ba659f6968ceafffb08194e8719422ff0af09bfd965f68979d0da8d71504cea5251ac7191d13fe6c26ffcfa328d8eb5701d023c0600304eb9d9bbf006ef269ddf6498f269c00e4dc09da299f701116142f7c015e4b6377fe0398443af626b74fa221481561f42252ed03945b62e52f455733cd4ad01c97c458d172fc6d03f69dbe8620ea8a5221a4a9aa3347d2f287800574be4c3dd469373a41bca396e5efb4f9639b0b2c649050a3bbc0298a4a234ccb6eea3d7b122f26317967fb1922ffbb93fa246bcde76367154bb3cab2fe3b2b791cc5b96b62eec57bb09fc2c5e3aedbc1d71290195d607597ff618763aee446b7d16b2735b7052b30abc0e559b1663e5947e5628810696ab540d208828a3a266f04816d9211fe5f4fe0d485e56e9e472276c0347aeb0df9b398037050fe417b10c8a963df1bdfd3eeda0c424cbbf3e8ab2ebf2768b1969d7d840d4509c4a22c017495b0a20f39ad4228d9cab685e3c6b6c47b12261e05dc8186b0256630a74a326b0aaf6ec990aedf45fce9293f5484a899d891ce1b41594892c8fb890c1c59071b6565e84c9ad05953cf23811e78e2e65b0d710858e948239bba80843a415b0ae69566cd641dad66bdacd5d06b69773025c49119e3561182d9c0b7c3dc2c6ae5dd4d3dfc6990bca4ed1c6cebc089a2914e9e5f0c1b864cdbb8d3b9ac6659d87dc21d97a35944c60c5406a665027bdfb67567fb4638d891d5f0a162c54edc83403b31c2f4cc8f58e9120f94c93ccfe26f07ecf0fdb8452b1fd4728c77fe32ea1a671321bdaf54c236ab713f278c9d4ac3fc739f6462454e93dd3e47d7270044cdc57b842b5126efc725fc5fafa90b52f52addb3e1a3f2666d2cc769abb66bfdc7901d3c4eb5eee9dd38712092a6853a25bc268131e8c3be1e6ae05918a3bdf4c8d74035f478619f9778371b70d8b15fdb02ada23849c88da5880031b74964ae4030643e1a8b52d536a2962ae53b53fbf2b66f2f22925ffd2049122eba7c4e3a7c2788a43398106c0b0bb44d40d99dff43c42fae8652003c3062ba92e452e7fbc422988d1182dfb4fbf89dfdc78634fd2c89b2993ee3f3e89173991a773dfb4c7aa1c3dcf92c50f9a57c6c9944a3e5b22d1fa2ad21aae774b7258fd83669b0f32630d3bb87a89ccad0999161eaf9830f096188153b55c81b6009a1ab8f81607d9402ffe98897dbb32308d4c57c46c11be97688fd9b30dcb6e6a4bbe96cc2b9e7127a8187e185209098cc1aa49ad7cd874add725ecc44fb38605c62b5b0f43196ec25f7fa4555c3cab3ea05e8fdf4dc8b7b3ea16fcb44bb7f87a9936db2555373e51309cf43044bc58dac8cff6ccead13c53fbc74d389f73c1f30344b49fc3671b2d47babfb30cfd886b8a2972a83a6aa0059d6bec9a390c774a95b680e373cc4973502427807441e34a76a387b87ff91ae664121a187456f07fce031adf37e52052dd1e4d43c2ab81efbf18530eaee1f128ca2550cf687ed719a2e191db4c77d71b0301f5b650bd3c5abfbfe62d88134ae01aa2c91dffaa98ecba36c179ed6ab45b517340d09925052bfd7af63669cf489e5dfaf61d40650375bb69905f755b4d04fd838d9839ca50271233f04270fefb70d9fab2c085cae4f629632d12dc7d307a72e81ba2ada055a7fe9ac6a9b8eecb4d28fe8eccda71723e6fb46096f208e0ac7f257d9b921fa5a161b4d03cbc077f05e0cd61bd50e122c2cce423f3e1ff4f9e867be8a2f56ff2fb46f06bbdffed9b26b061585c6272eec42d3dcd8c5420ab6a3ec865e019dbfcb4f41e8052fa82f15793c0117be309c4c4c51b73b71d65ca34476acedf3d8767cde368f38be69f80044261bad6da88e592e199d8984e5afe52df2709779934b60cda226fd3a247fb8ee96bc50ef2450e8827a3fad8f9d6b31c844d82120a5373e52a0bc900b4951f00e2fa6810e9f62b5600b64047549bab6f7f210be2a451c7589daa7dd8f643837b18803035f1e182c572c5704727b834244c7e83c445b1b3140f1784464cb044d18d7c419aae249594bafc464278347f33048839beb5c9e41d70338d56eb99fc7eb1dfe6401b02f72892f81506836046801c7e8c2655fd31bded4b0a962c71a2ca7f32401ae79a3019fb2fe979c49cb0677e9ff6e881287faaf94583ef3105d6127139379d52d43225128f3e2b9e2c7a33a8cde0b683f9096ad544ac32ccef726b189af9c768216ec8738008fc2702cc15f81bfc6941d3823742f4ad14a794ff72e103e7389957fdcebe082e8f04cce36205d0e3400881e1e31a0c1fc43485b6d733cbe251f7140ae1859c38fd3dee75becd7354dce4cfd3080c9a72ddeee5d9e3894b23dbdddfc19e7a8f0e0db657d051a675871f37a6b1596e869b78bdcd39ff22f574b9de12232d4b5e226ca35a9e1a1152109049e46e56935b6b3fbce058aaab921bd9f54d2c62aff1d6e8a0eddcb4079efe73d79c7f3494001b54d774acee987891b17ed707ae44b12641a39cfd1ccd4e4a3eb25c296db45b83fc0487634cb36dd8b70822c62c76c9864d65cbc455f2135e3056d5d9c2c5246425286ae48695f3728f2735dbf10ba3857aba874fc15f5cfa5d40ddc49806d451196e5adf1f2ff5dcb7243ff9928c0a2c96614f2ea59bcb98a7f0602881625894ff8caadc693c136c2339ed2943fedc0bb9953ec95bcc2faea5bc5f9f9e1a233cdb991be0503ced77617ab98f5f2104317ca7e6b632eff53516600e1c5b30c84fbfbe547b1ea78c44b41189b40ce388c939d889b9131becef7cc1ffa7a4b8093d11055ce3cf36074b6af1226cb95d7cf04fa0da30d945311c5e135803fcebde289dc9406979b775ed89ef78a95873d0f66a83c80b1fe7a303cc7727108066392b9aaa7463e4026f41da4b37a77b0cd9bdeb7b593cc3ad01b7e79bdc6303e69ace0a2eeb5e41d01693fb0b1f0a81562bc4360c0e1b1bb3c6b827574f442db7386e18bccc2826b267b4e4e1ce41f3bd8f0e3f083430721885789d3a7a639576af6f77e0aac44dffbc3173ed5191f94a6b931ec2a581a103b9688ec850d7892780e86fa92c07d4c2976bcf3c71af1a585984193347ebcf37dabeacc15d221424987389a55089c67b29cf06a14600bd5558c8087936f6463238e662e6e4656d10962f43662dcc77857144e3b35c316d1a15de9f889aba6ede9c820ed1beeef6c3c19ee54b7b8dbbbb60097df4275b572e30a218eb6287012c303ad6b3aab802ad5d65e63ce13a14072931a1fd7e3849a0ee04c77607cd10799f05a13faf97fe3e51592c7a90c199c4b789ea96106e62a3965f31983bf09029a081ddbe7f4181d0894349fcf638ca93f6a3528fea995664565c209b50573e4a04386bb60c7371661b4ba61fc8c5ddcef68015996d0f59fa891b1deee2827dc379a462b46cab49aea9a8e36b88951ccdf79a78a220f30146339842aff9cb0a75c0e66175d7123e5629d7a79f8607e46d172e3b91a260d9d67d147fc6ef87830a1886997e76c48285c2d7dfd39cf168fa30ac32a7d73f38d01f7cfa7827db90ecf5bf2b8bd2666ab9939e23b32f111ccbd172be6215061d1908f57fb151a5e05cedec37035b9e003c3596f7f354a6569cc825312ca7f3a6e5951093fc34293e4bb4c596f5a8e8f26d00bd0a8ed5bd77b847036e159b32e896e1c4fe8fe83301824e1b9d02004a8d69b3eee94ee92d0c0b44be2f6c12e7811f00f9fd87d39dede6d559026b84c7e86c6ffd5522354331adcf8b3d630234b78aa76a55333341783163ad43d1a956a82131cef99eb87cc73955c10c887e5709b25ea0a7fb3bf0e42d77d454f509a65e772194ea55536c4a4dcf0b3d822cfa73a06f5a264618a2e9d70c0666065c835e57176720c59768a33db0aad0785f6db3bd55eb4c337d1a260e21fab5a461dcd46200bbe4577f09a7bad079ea2608bd6dfccab9a9e25e2ee3635a8c6d583899b49f59cb852e853e70e99ac2384927581071eb710462a8a46c6d10b5de166962095f0666324916006c2f544aeec4660a73b11a140b9e67c9e7ac9cfac88a51fcfda6679e937633b9aec6a7caaea785df124b2b5ccc46f74471a411d2ef42f113a69e29f5cd18b7ba9f7e0c306245850ddf61651a3344533976b8b679a272affac6150fb5d1891fc2aa7f20730b80579e82bfb17d608de2f1e5997ccb6a9ec55e4acc2dde90ace7941121d2b8f457c5ea094a5c35a45eb74d4ffb0ae31bdadb78489fdf1f07146d365a42b158fc05a507a4006231b591893c29bca7c3677b84e2d018c483dab854bafca45a8c6cf1dc18c455f25b6999aa3ca27082446a5c9507d053838151653b82d846e92fe0bceafcc8452abd22219b95681c878ff0ec4ce830378b15f459c23933c7f3b8e6699acf6b2c485da86a808033bd30668a05fcc4c99c3492ebc468a0daf21e39ec906a1108bb19c901f0f2af9c186633cadd92057cd70e4a0910817b1f0a173c7b072b2627ae00605bdae4a422ca59c6c333308957896d41aba91cd54ea64d9903a23fcd9d962bc4c8918bfa99cf9396f244cbcad06b468485fd0fc0554752630c1c56aeb398ee9d3fe0fc352efe4037a23b7f0939cb5d56b624b6933ae3e808e78d2751e309a78429d7ba3e0ff22bff1ea867651baa8bca7c2e32ea1763a0ebbef8cb182f12af4c499a4ee91f24a2ed0c76156d77ee3abac1035e41233447b44d0e67c92bb3ce20aee7abbea57b9b7218a4cf19647226f2399efb5e7e2a8fdebea046e71683b71321acf608b74e1ed69d819ecb297e8b1485db962d226a34818466687c5c3cd71fe4d64568215951c49f58b1856bd0d2ec5fb13314702fef1c5d60505e9be636cf5ada8fb7f09672781bf99e9f837d357df899fee4bf25d76cd738fd720a07b3ae2674491dcdc5f4df1857d24aadaab5b534e26657e333ded4159a1fef770b54751341216df0194aa1a602111910e99605d6cee09b4045c9879b583b8bd68c1ea291bf5b752b0362bcea6c617432319031f33105db2a21a891b006b88fea2743b82aaa5a2b35bae8e790990e64712a410d4c341930748e5eb9042a3ff1148c9c7fd8d06e3c6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
