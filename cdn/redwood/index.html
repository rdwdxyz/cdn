<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b497f3a4bab3ec174cb7d901fd8b42c87d404f5d5382798632531ec507e7999bed2f1dbbfffbc0292007db06c6df7a5174fb2978f9a7b2fde40e3ab273b5d984797bae88e699887852fc59ed7b5f959bce0cd9f14271b2a5131f74c76de851cc1128bd85cc04ba8454c4a67b99388c47bc8bd081028b53e7676ba8172039affdf3f630f84830929dd2b2c2c35e159af470c516bde89a188d24e93db35eeab5d9e206d9b020e182dbb592d80482f1fa008ffdaed0a0ffc74b4385c2b564841f97303f3a3f0c186ea8197558b6a583a73d0e5d1c09d7b3f538925a5bd302c85b3b565940974893ba8fed28853624f0b8db2c8cd7e322ea5c2c6d664c17f1202aaf273c109a99494414da07d35e1998c8068b1cbaaa48dac4032f73fed08eb21a4c1ea56af665b0e887fda69ecba632795e1e25648f8e7d46344650a8196f0048b2ec61b1078feb46c650307401a4750b4c42f6a972119d5ebfcf1c2df4c9b514a26c8bd06b9da7745a1a17b9bd9c59ebab64bcf3bed1556e2d339866441f2dc9081393933ae28574da44837083b487f2ee1d00b792d7ede26baba10d36f5772d4294656781d77ac45eaf1eea55a42896fc03352605f3ca850f13c81ead484f353f19aa79ae7a43ba0c1b511c71e4c7c2c8c55c073167c46dbefce125b7ee83f2ddeec5587580bd568c4c247244fee638fda638ee0461b2b3c5ca8536be8936bdc12b4d674b37962b13a6cc0718b3ddfe5f61fc901a7d1c0d6e2dc22e897ab09126bd6ad388f948dcd4138a5dbc4acdfccf2aadcd3c94fdf91bfd180fa7fbc269650ddf8e9888052f1ed99c791e032633406163769c52ad25880460f19ca28fa3bcdc098a7b1a31085cfcf745b78cc507243c182c8d6d1a14b099a1d49dcb89c2159caf5a948d4b6772aef3cab5ef5a691f4c58ec58fef8cad4277b7708812b344e0bf95f10582d302622d52ed56fb285d4bbd4204e7886db507139c33c7de0784c8586b09638e90c7d4d449d77747c53997c73db3c0cd616129c90020b550669c354ce47011aa65c4e9ec096ad382d70b3854c2d564d5ac4b2706658a8109d60ab280a1d04b9b383dd3d73a9c62da6188b5c51c92296b67a085a2133928af06eb1945b587df8409180d53901d4470df53a9f30b9f576eaee3ca3f25e790982745f6667be87e0a8a3e98d4e4bec1429a2bcd0d8c6a6fea84fa8bebba8d9d1548e042d0cab242ceb9ab7b3a3ba794e0c0e62441c43fb507266363a5fd7145efc8c85e05ca432f7ddb2fb01c8f71206f2402b9187210dde374746b6f911f66ea1dca4b2c97e94681526e5d7237e047758f6276bcf480b6385d5c1062ae14957f17e56f1ec3984b90e129db6d7c037642a54256bbef4c3f92c8f2fecd75ca68d54c66f63051811c3e76956594a5bf213c9488c1dab33c7707fbb9823e34252a7afb400d0ec77bfe41841a0e018dee3f8f1bd4c3f50c3f0dddc5f13c294cef08bf24b1a2fccb1b0d4b698bf29fb8ddf76d49be115fe30d0aee3e95bdb693547c1a409059e21a7ec96306540cabea3d56e672c70432fb75179e9f6c267b58a88aa8423038c7fc3c11a16b304d65bec167957f64942217b557e6d55a008105a28b47b2ac2bab6ff407ebb2f892f29654c9a6aa0a036a01c32c5e3dcf097ecb6eda4bb0d230f73ea716d1e5a08e9f0c2510cffd5391c24a6f5c4aa71a19cc9afec41e973d771006621afc9b3365ca333a0f0fd1afc01f027b025aa36a8034c5cd06b97cfb12a363dbffc8349f60a4a3abfb4204e96320493da2b9e92b726eb710baaa31b9e97eddabf8d91253f602b5e8f050cd772f391b9d2e9d8e36a5512999436b0572c0376befae329e63ac7f589fc77c853efa9a4665ecc0a6e275b48d62c0c7eb9473a983acb9a3bc81f9db5b9061a4d563d88822e301a332b887b090e7fe29989f1ce2b2805631a0faaf6a1ae951e4dbcde99e1f1c1c7e58b0170d96173bdea0ddc4f03f3b1f6067e5b952c8103dbbf0896ccc5710fdfb9118317875cb196ea5463002e5e4b0a2346dbfa7b91915e3ebf52f07c177bdccf83803bbb30f1861b7a9beae6ade6ef4c24c56b6af20d9f6cdc948da690a6efde88f22bc037ffb96799e566141cbf8f2f23a8219c81efc6f89c0083676d9fa398c92aa02039f79975539d647a1e8d791198f9a9988db2081e9fe42a3ca47dcc3de33af92d1b022ae00e6ab1604e0b9fb92624f5fa43ba280c6b7a76eb3cc3f7f9078a80244b202d50b26915de59435fb478f394d4d8b9f0a5bc542bd7aa6ca7ba735e6f6839fd9a4ff8ec96e939814bc34167d4cd459f7b677050515b61a361c0a95e019a3cb101fc5767fd23609fce77d6133d3a6a482efa2383b1cea2cc2ca5ec8046bb655723a03e930683670e711060c633bf68bfd496b99cb4a470f9dcbcac42b2c4ec580308f037c64779e286967020573ec366ad442b883a801955775ef678d7bcf98616da8869fa0da312f115968fbf92f249bcd14d457019862cbcf46a23d4e52388e641d1b229d2f59b256f17ed92cbaac4de02405d8127327f2d5dd27957f2257d68fddc6eca1391693e79ae3f497596e438241d9322498bb6d4fd75db2def7c93e95428a042226bb6e3d443804a58b591483afbf9435140df01de134da6c01550a32be743a99f50ff00e4d6e5b163afea7061464cc38a404668af910f34ae757d46846c1ad17b21b440c51f77e51bc491255425bbd4f1736e1c187e48b7648b8eb283c3c126d12d4a364404c954dad0d67ec8793b866c4d3bd965a49e2489755e8bfd29c4a1cc2d9a1cea77ed446ee50bb650dedffc87a4381bdfc3e25128bbb0360e7db758015c6eed2de6782cfcc4f9f0ab1cb8558876982cefe1a6bba95d7931cb9676964f2e3d0ed7e58d98a6b98730f7507f4179c87599f3ecbd6eb1e99fd88b4915cae41611c9830b281c36e2dab6d4322212c97690af6c6e084e5823fed984cefbc5ee5b5d797eee46ac1a09ea8ca9b0da01c6b4788421d020aa4023c641d39c64d02c2d0e348f01d9ee62bffe9d4ba0788889068f880fd861b1288043fc7f04e75b27e57792925a1d7e835097ee3046fbb18b79edb78d9e65bb0a57d76b564415235c8ea7a561e294977798594db751595dd39c39f9aabae1c4afd690ab39553f3ba062c09352967e4e99e4cacf064a91925532bb9712d68d9be3434d67e1f0a6200883d2ebc9a33988245b3b1f159ed0da8f4d77c4502f907abe7a3d0d652ae761431537f7e5eb817016d020819ec0834e1035142a954306bc57339abe0ff77c0b8eb21082dd4cbd23d774abe387543c4ed52291468a4f7510f4bf6af04f1a79da6d1810020a73367cc6e2990f54d5b4c38efbe0581efbbd71a2370d7e40aa2513bd881a39fe6e1547f7a41bcbb2db61667726efc15ade5bc8c3e8221b17e9b1cba421a6336e345f5e092661318ed0da6c3b7ba80df9e8a303d5983db82cc09d2ac38c1fdab0b351f851c4e4c771b5a91ffc32626405494e792cef40795e9563e4861c301a6c69e8905e91c7ba85a852696f8fc43ac83ad4f042c44e84f56618502e635b69c72fea0388dd4d99fca6d48442d91294c15e1cc62ea3a62d477a8455d6937f13ef213bc617ce4421885f4ecfdee0f8a9e0b158dae1cf58ea16193f4582f981159db788fe9d321391c991d582a71ee917f84684fb3e7b80d0c6e15a545b172ffb031af91d42dd9749234b2e75fc426bce3231b7a0cc82cc83a0ee81d246cb76ea1fa2844ee0facd157f0914630ae56718002835585a429b0f35dfdde3e7def0239d8ab55158c7980be5dd47d73c026848ef8a8c16b7194f94540a0f5459cd3f7b519cb9e67cb0e068fcde1dae68cd1e99c6ac05f817829f43e27dc89537e822a0872d8ed8bc65d53216b9b4fc16cc7fbf4b59f685ab6b1d3871640f4d1c5d9822603df1be31ff8268a3b6291828018ed575eef99458e32483213dc25c33cb40dc1af502aa32ecf6b19bced223b42709d7e1e74e637efcda512751636bd257713e2e3f9b94abf2f81a38a4fbdedff09d705cf6574fd48eb6651b85e5fd720e4885e9815f62c98174b201ebdd79470772c333c4bd6849171894afb85766075ce9b59ffb4ee50868de4c8f2f7d90b81e1a49b263ea67d7b2064aed7f1d29620d0353a5422cb505b1a080de734f9de5301761278b2b02a24f4f2f75b8a13034d0c1cef429b7fc49cd8826da6bf034f7698cf9717adbd2f41bf9a8ffcb1d20f9eab15b9e74feaafa788475b65b67a3cd2c02bfcefd1d24ae31c8a73a323d0a54f927211fac77805fe811ca6c49fcb5ee84c94a8e4ddcbd6e4847c27448393b648508b66cee59216a41e71742da2bf7514b60737ff045be093b1cc247058c7a01233b1f79f33c02c5ab53102315530e4202b1f390cb1d0fff2a3780b15f0c1d73b1efc0f8434b3e760af2ec2d1b0d705dabcf40cca0b8e1780424bbda0249d2dcc7dec275dd0055c3129dde724bbf179e1320e57652be6bc916364daf9d3d5b9a8da37c986409d8c5bc2ff4926fb45442d3d4ce9d7fdb0f738633ebc8e56fdd7cb4a17ce1896d1e30f90656a9a4e477d0f9e36b3d6119908722bbc74c0f41d100135b4883e786b890ba718d0cc40c3c85441323cb4d2d58d16e92e958c928555f20f5ff527f8449fa53e8d721190d2c8b68b2d2f7c6b4af07a1775e15b8668710003a29a744f62d8976dfc2dd2f1ad9bb2c33dc5b35d94afdf27be03088fb2607187bda972c4df741f0d3a0816681ec27660cdf47eb10172998e639a2326c5f5f53f9ec7ab4cecae5ead883024678a556d44bfde28f8f6750ce757002e0706128357120a403085e114304e1b2d7519f008fcad8af3335e9b1cf2a1b8ae60522f43e31ee2fef660941aa9f33d5c21d96edfe222ea01b1cb3668c7729d87f50a3dfc7b5dee59f3371607b0b1f2595529f1d8c77463a8874bfdefa4aa6e859197e9fb9f274944d0e26fc3d43c7363390e00fd84ed1247ed7b474288d5d62f5a56b56241ced2263efaf49f96596088b264eee8bb3ae6d4bb66bdd55bd342fd6df7f770900c532fc0312bcaaa45a7cffd20e7799a0563e1f1771060e78f7a5c5e4345f30e914e1ccb4960a5bbbf5632fb0200d37296fc651320aeb549922d8c8120921db2f80384bb4fa18d08732969625e08ca1475740d57615e63d9373fda9a885acce82c39b8bbc75b9d57ba3bc05203afd6982f16967b5ac699ae1d010f3a89cc703ef053ec34b9c55b3ae3741f553884fc35d1755a9faf557ed79987c2cbbe12a5f4710f075daa09514f8160c7b06467a305fcd72fcce273e2288c7b1afa50939d81bc5acaaf4713ab6f20098a4eee316474316f583693d30f69ba5450ffd41c6bc78b5c949a4a3af873159293f8258e6fd7f8f13e5923fbb33d5b680b1fe21b046fd83edec26ab0deab66867f883bc9e316e2695c148677839d4e4a802d8ea3b242ecf941ced55f7d7e10ac159cca2257c332dfaf6c747c36758d40a7bc0939bf529180efd70b2e73e2231802cd20514e9c4dc990edc2534c2f8456dea6710c3ed0fbe7185208d2c1c084547ab5685cdfa484c5ec77d10250931160367e0a8ccccc3744b69ab9b71e1d44411fc34caec0493e9af2cfc03291cc0c6e21e8aa3c56f1939724543622dd45345e6b74bc4ef45de0e9edf656133a6ae3b9a47efaa581811e9cd29cbe31df6c7c34cb5d29c86821497f9f8364b387a12d1efa65d960d7e2626d4cc13163d49f7061a81a3aad481458261516093374d5fc9215ba7e092b13d56da65ba17aab4eef9978783e3d17a5dc352ad5a538a6c187234acd909e40659d26a658e0825eaa51c15dc9d55315b1393ea0bdd46ddce920624d66ea937bfb7123a7de72f386ea5352705882cd2ca8d195625c9b2e30847b1dc5bb3973819d6e44e0ec2ad286552e1be66c296a2656ff520e98aecc605a7f6aedf2fa6b877ea2618dc36e054f034b8301ea3012c057b66924c182b3741372e9888aa14e51fb5b0b873dc6d3ea02c2893790d336862232a877eb216bb214669930a0a7c05decf95d898b4ca69ef7caeba0ec6a8d60c3c9e7ab88e5519a2db5cf13e59be91d76c9f55770441cbca5f61f21d28c5088dee07f7020f59a5c35f23ace19a04ae105441771043050a15e1b5f1915b7dad8fe75b7ac1bbfd72b70f6c8ce50b1f88fe6a9596eca70d4b707b7fd073848561ed29e82acf0cfe86348684523c775cf35773c2562c9fde86fa84901a7323921d1bff1c4643be925c79bbab485d9c48a546b0a67f50ec23443869829010b84e32708d54fc853073cbbe1638a08944cc07abbb46914a31e7d87c829ecbddf7ad3117fe691a270abaa36baa1001511a4060c2d7d07c066909f1359f9857b3cac56f4f47d2dd468fecc8829c7be7e2476182e77188ef81c1843d6036cf55f50409ddb125c905d10cc329929935c549d93e6b987679fa176a6e9186e92f92850bf8efab60e0ad2e45d1d22f870575246b9c3af96ff157883a47863b37110b2a7cff0bca82056ffd03f2bae56951eec84ebf695f6fae35567ea59253193a6a84e877d6465ce6555e4d67693a227fbf86c3639845cc0fb2ef39ad9e6219ec1f67122403545c2006a9b77239e58c48d8e8b4fd391412c8a54395947a07bfc9016682913603ef04d57ba2a69cdf35c241f85088964e59f10f1ce836d11770544e4d6c13a98c9b576283f8a1b3313f8f0c1c7f8d0e26c4ad9898c5c1dc4ebc16abd56fa67d68fc078cd7e00ad6572d8b123f6cecb7e293ff82c8aeae865cd2b1887c312514b2ceed716d5ca8239e93e1e1291a7e0c4c24d827727be67ed9339e16bee4877f48cc8a4cb8ecf235e2793faa722a3209bfba31aeb75a20edf7755633fc4495c0f48d2ba675a8518ca07bd0f8e27b38135b6ec7fa28c5fff40eb186c2bdefdb6c0e3637e20b1840c57c9043d32df40a02ff1f89ed34c51bcb4d6b06c4b7affd33aeb9d65cd3c4d48a3dccc6bfb3661e8f5ebddaa891300bfec649aee81c8def0a705f2c2753e98175f96b658102f88da8c9f5238b5bde30c92b8263effcf9b7ca5f1ea3c0d41b9efe45df712001c033bcd0d9d8932910df4aad88af92eb890c8b1a51528256e9bcc2c26aaaebc6b425d5b60fcba14b62a2ab41dcc053d9a059838013cebe3190ded84c065aaefbdbe44979050cd474b28cab0aba6d6f9904d7c63cd09829364921af352ac04b26cce588799ec173bd6c2b086aabbaa009f7801b2b8187498c1c508f3db5c6ae08a2e419f62f9c0b2a4f307c9ae783ad1afd60a9dbb529922650c580eff54adc8bc2309b70eba9d9fc19161976d4217d42a372a1ad4dc2855e805b24d7a9afc6a0e66a1e48adc26bc113460b4c2012769555d7944f797831fc4926b346ae0209ba15805090c23ab66056507e1f89212cfdffb644f9eb0c24358ea11ac1e03ee7ad7166f9e9f102d159a23887d65d04a77e6dffc475b14ac560741526b664ee932fd52ba4f1aafb8f2e34ebbb9821dc738dee571177681a289c32a1d24f258de1ba603b961d7d20d060ada523f892b9751cd0ca3db880c0cafeda3e8fce30144169c75388ed2d9830dee7f789c27367512577decb4559d8970ded7b04bd349a99a4a04d80976bec9a5dad93f37bc3c7a699e9fc492ee2ae3bc6acbc9f070b44040e2f04c5a39459724a0a0e660c8188b340ed2ba0c52d146283b82a8e1b5429d555e083de00239ae23887c9eff10f2d96dab59dbc7cdea74037dcb45039c3d9b147f7dc90cd8d8a493beb4498c8fcb8fc1c8207a8bd751bff207f29c4e991da2b64ca602eb4425416b9cf7795d0f2dd9323007ab86a767c065b096d783370f3ace1eb02c2f7c1f2385a4e5da3b8581e2e915c3d0e7baca3579542b4641d376b93a61a1a4e93694bfd55aad053d7ddfca16f039cde270c348a239179a17103079a3b1c8979f23ab0e618baf006e2e0670bfc590db3b966f4789eb031ad826f42546a98bc24822eb98117e3e0a706e834f4ab9ef91f4deff7568aff08dda6b16fb90136dabbc951f7f6f27d4b24f2abd788040adb9415618fcbbdad44b041c4b6975cde86f2d940594d3b05955a8bbf251fb44b2669803a93ef165899cc1aa73b9c2197b40807f39f38c8de93b55c39aa788a4fc2613fe2b1f071d3afb93b0cb05db93444046d44b38e376230058fc55fb9f3e025018c2ed993d478908fa708a4800fadd7adada9c9673d2082badbd472df44d65f654479b9654ebeef73625d6662892e0aa785cd7895d5028b7605f038dedf104ab4d325d5e4bf2c9fb08d733f09dce7bbe7861e1dc22bd4e518015c635ccc00047ad2b2709522ad21fadc4716a89a958ecd8ae8556e0434955e245ee7a63410c5c248b701ef62ff669afd28a0c66dcea54beb7f6e78dfd3f1d9873a13ae62713203d7077ad40a25b46842bc6d0f46facb16752ad96b665a1d310345133f852e7dd86f68dfd629809b5b6cf0e7e7396837850c16e5e7f93adb3c629303ecb804dbc026c8ec6e8efb6208b8d13518e435de9d07623f619c399c65e598b4bee8c234ffccdbc4d273dffd2b77ac8246849ca0e84d03e8c7bcb8e2ef4f642c4d1bec4f4871138832d8cf03ec12ed21fce87c2344132ad41680f1b114653147daf781957523f0ece633932f4a2f216a6cfad47f0dab271a0387bea103328aade529cac72829cbba644e38971972f4d12ac13e6ace6fcbea0ad8183936f79ff27e0099b0bbe3273d2e0d908d8649666f3915b9c365111873c61faa36b7b9513f2a3dc899078001e6542750cea670c783a2668ed02c17e2604d8e41a0b3a3f695dd7641d8b32303440857ebe4c158a6d11c87db826e47e18e7ce98c3fd07f6e313a9954836b48b74e381da794fed7deda176cc295f38cfa8c1c7b7fee20d684a8475627268346324850e1042df8c138b8b538118463bcdf884ce7816231f38d48440385cfc4cea99db19d2170b4c07029904e249db15834d41718373cd2e05f2a6883e15d865b2ed1d542c57b2f0366c7c7a335a5dbcc798271ae6726318ba56e2eb2a4d2079318bb84f6bdbe613e07d8076dfd7a92f86b6aaee21ab7ef8d6ac5b806244e2ba0d9db19c325452b4cec01b22e01e7425806565a3d16ca66ca446d337dc7c8b9874add23f944ee1941e6d85a64f99de6d80c917cd2e66a1155a54292e5ec36a8b8b46f6893a4f0c229f97e9098e9c08e38195d419380ac4f2cd5e426af6f01c0484543b9ef13aa98f5d0219cef8118be1a3e8751728735dcfcab630cbe5bdb36c92b85b41dbe3eeace33c27f4cae11fec5680d2c2bba27d97e8723ceefe7ef023344950d3bc9c71620574d58be770a9408e43577a192e0a3cbf901d5c7a565c8903cadafcc316a5e3cd3fedae128aca9de96df0f4eab3a90445b0926cf78e71e2f9cb9ac64ebbab943673574681e51f20243d5878825823bec936158384d48906a7f05e34405d1eb8ac407ece2e7b0300a0cff9c8cad65d4974211dcc8e37095c71139b97ba397839647b4c48044d5e0fc82295d0c8ac503e0859b6670d04629fcebaeda2ad27685c4343d85477f9ee9e8d93912f90f390b129274bb75389969a32e837eb269b15b9685a23912bcc2b64a61d735683c88a8f247c56273de2a2aecaae01a51a767f6a32054704d9923ea2506aee03c429ea38858d09b9a96f3da2e07b7c2c0eb203f514c7cc4e538ffbc1c6a6d87dbde0082bb46e5d0d3fad4ac1934aae3a6724266c315488a010b279a8459e2d273324d398e0fc0025221082f473d913d819bf2bfe9b5d6e9868eb71a1c816ee66791b50f1ab56d6563533fc3467d084f37c9ae85865211f731e8659bb357cb1a7e0cf9b3e6e7cf97f824acb221e8e7ec7b33b8157faaadba1c04d5d37a660fc57cfc79005e044b6f80a8a66bcbdde5a4c80e88e64cbfb51f91e26b7f1338f5cbb39088356e016f33b631d58bcb6567bd08c3b5994ad44beb14ef45956ef85547ca29b37fc2b36a92e13f21129e9dcfc151e92c474afdc77c29557fdff7523a0d5eb4b3c44106c705447fdd3030b68382d546c224925740eba9dc92c229b11ee625720b38be451ef398555a08853295e55b69c395f3e06a8bd9f5943c207f0d649fec3a266594e0d9bdffd7b30de82fa6630f6409917ffe28d3b3894d46e5f2c8c33e5605e7d071b7dd85f7b84202057d217199802d77b5a338482ac9e824cf024b88b58e59b2c72cacaf664e7d7f35fef2c2229918160ded2b29dbfad1634026dc07cc88cc1e6b944cd337e8e6a9753a63f6966f6781dc25cad89b9778dae97353f8968929b3e6c4ba3fee004e4a3359b3e18e143cb89df014889eaef2c258d7d9d4eab8975a49dc0c9d5862498b7b70c99eb3380261b55666b58f278f7bfb00bf2895fa318e65a736d356c8d3d5659831e5b0fece539390055e54631fa815d30c4bff3ad8763e15f2c6db2ff9fba1087763a761805218c8a31577682ff93834cb9a0b58b62ac9f5b4c64aa1350be2160b1c842ec8c65dd2b0286a7a40d67fceb8866680c2df829232ba6bbc026f39b63c5ab09c8b365fa5eee1ef9e149371b6783a5d5cc3f3c4387ec880ede6e84b98c0039872f5e210e6745aeea017d4bbd13a61bfc5919e203f45a3001a530584d2a5c84f7ee5c91c7c9c8c2006c3d9e4599e1c1713170bbc4ec410d21746215a7abc5185c759bcde3ac0526c0a2cff5223501cd97efc941cfc788cdecbf02c6a3bbf76ec01dc2d82d9f3984323463bae6ecc62f5da8d5c3eff9a4a45b518c2955f4782586e0ba4cbf71e1f2dd445873f65ca315a5b30c53498a9a71ce778dc4246f4bd6f7cf2c5b7d42a682e862581fd0329a62374ba60e1e64e3103cbd5095c5c6d23931f3948067214080acaa7e2d77af35855f7f0ce1ebc2564ca001f9c99c9b96436136c3b031396aa672dbaba55d3613124d30b7cb48dc9eaf5ca1d3095792fec9098bdcbb35443ffea81038d87c24d58da1199cca16c1157ca6fdda07d42847bb65d12007588f18c90bb08a3bb89f212c67cfac42193bcfb8cda1922f08aa34ce98ede347442ba7020c7478f405980a8e33536681a46c8f1aeb36f7de534961cbfaecb0bb4ce2a233c017c16798e115f7a9d78d898db570856cc814b3db62db414e1dc91074c55119fd686e6b156b56f594a4c6e91df7134d3e858e543802a8b5b6ecf007bb53e44edd5586605c93fb18344404f11b697b1c4bf766b31bc9e1136c93c2d8269d39661c396c9807f07ed4dfa1d85ec0e0cc9e269352a820391e9be45e46a4b8d9b391361d5206a4b9e51e716d7305333918b7acaa0f2520d8d181beb48f0b3ec490e671742a3e42a2962908149a8717ea41fe5d395d339102459548c8f3965b4b7f7079408fc035a45c601b97306deb3bf9cf267d455c477d64085ff0984f3b6e7c482d886c0158ef03c80fba26fb56ebd0debc01df5abb7c7d96fd858f99f0e66cf17206abc517416c6bd56b6af0227f1550f947f1df959a8c8303c9139ad9a3be3dbbb9a3e2f85940af2bd15ae34dbb65ca6830d37b8677e4b0f7072d9dc542f751d57530a46c526c3294050219922c0b337fd4bb4ff414d271a9ffc5ea6dab9627540124be0c3515dcdddfafd848b3202422556bdc10bf657da496f8cc5f1c342f5ed61060d72e74c874c96955eaf80d11798fc5070927b8233bd9d04feca30d44ffd8637cafab66ff5728c8779c17629a847b06405df003f670d20911938a99b83d080136761592ac316d4f6b434167ed0dfdea7e0ce51ddfefcf4ba41a1685466d20160bf761cfb71b490628020c729cae5d677bc80b5b5199495cda67e12c6b70033d7031c0b453b0ea8769c114112c8856afa680ebca086b76a2861bd677bd715b9edfe2d51fa8675aed78f8f16627b3526db2749dca6a91b2101a6576837e0342f9c74a03c4a9f73a25f7d71466b1cbeab83fa1bc127bccf75191c7a26f117694b75c68c43bf713a3360ed93507be0fc96af3a6dcebc01dbd3d96e7df778edb59063d869404fd63c94038019078a8af041a21ec5e4fd2a2eb555ed5d8c44410f4f6705fcb1e355baeeb61e0703299bcf5b6f919d2dc7303646b682b89a87dda2bedb4ed269ac0d896e5f9934fbc528ea74ab028aabdabe107fdb593cf8318979351a3afeb31795b13599fbb2a7097f4c52be2e49d8dbb767350a3b8f4e0d3bb30eb2d03566f09e01ff1852c989a8f3356f1d7df79b70c29a222f3868c0b6172a7908a2ea481675ccdfdfd24414a3a96fed1c1329ea95bd798e1b6a209b105a8ce0510bf9a0be88d607d593f62905c5c464bdc04bd73401845589904c5e698dd69b1414d73311dcd8f098f7ce37f26fbc5b1c35081b9298f6b45cf4a70f41c92d2e58fc3e0b3cc937630eb9dfcf181b1215dfe292c15aca07ac1376b12f7a88c2c170512e5eb77cca650866d4ff502dd5c7271d4d1ccb730462080ab38559272f2207a1956af63a37af054c062774866be95e741876d3459288f3a32205edc4a8f864437421673305fd35bbf6a92e109a855d42d9e44136c19dababc3a656b89c4b624248d90789daef64cef7db4b1eb040340f9f966afebc6be0b2266c896bc69519512b44df94288ef98a3e35b7a6224cb3ef494efbfacbf1b8ee455e66314ddd03d517abf686f161934dffe3e9de317ba8df633d0e15f30cf5b939f3885b52103b7fa0ef4cb9624e9a9968736fa37c431ccabf951428590b9173fe1c0c61c1685d99a4f8043604a6a5af5563413e17e80e80eaf5ee3abfb8363956dc03f5e9a70d66b802932b4de5369d240b2a7f7436ea7d71a341863f53c8dfa80eb9cda02759384d82164a7e0464a4ac34a4f0329af13df1bb75272cdd83647b23bed472ba2386a78b26e1a6b3bf26ee482cbe6871632b98a26b3ac219a6f51607a07ffb6d900956402186631a29e0402c533e03e86c737a7ff0a7970c7ee171b8577bfaa8922e7094fcd2913c9a441858677cbbb5621f874fdfec9d808c6f81188c6d9ecef952e490e211c9c0f455079eab4b250949bb939f57ec5fc12e5ae647574a1c8bffb3999e4af2b110a047596006daf34d3a06cec565ea53fd3f8c6eecd9ebafca58cc9b231622e5e184d34519062f186d05f42e762e5b22712d8293d92175f2cd2fb1002998b5e35a2c13f96722afa0ed702b6286d8a99a02aac0c8beb0a678c6cd586976ce93877a3ec5e67ff56d2dbe1d3765e17ddca3f2258febff779db616d0a77301197aceb593783ea955073b9fdcf7f2498a0ecce89469fe5ad212f6de29d49cd41b134d679a2a72671fa9f13babee837e6b1f0a4b96b0af7ffa64183b509e090040a45cb50101b9828f14f38b01a55d825ad0236ec383e20db8675de7c5714af129b4c9b5b22af5f939ab4cb535f4484527e97cdc200c85f59b6bcf8a4c43e9c7910d7bdadb9d3bccdd12c9acd55221ad831a5e77682b3bb11731ae37be154071e9153abd47a9795a9b2723ecf54310b34f7cb28d940a22614d67c76e2c0494c5de00d809fd81698779af305c81fe6dc734577da41aaf20c28c199899167d4a13ede56632440f901e532b5dbadefbd9d0892891ddef8dd7baaba7c65f96d0a61fb44379cffb898b883b4623610d39b56be4c6b2f45b12e40e99534d4974912b58d12f17ef68b9784044634ec5adcf70aee4227a138da86c6b2cf1be402b4655c5e42652b00021d0d4f7fbce74a3e8052da5faa81805c7fc3694a118fe874bf8878e13a7716b1b8aa5df0a0fd04bf968e494e97dc5492a0f1b90b92cb1b3c6d450ac0172c072627ad7ed37cdc737ad73689100ca5734f89fd42cde55d52a6f461aeb8feac76adecdd94f02b341974dc79e5ee26896f319e08ddd4d817a0bce996d1cd0cd31b183339a551c33e0e34fa0ebd04d9c9a763e6a131ab47661ecbfc1d6dcb53267b3eeb01d81b6363cea49bf35d98c0f48f4a92460c0561e856a65cd2e55fe022ff898bd724d7edd86d0d6838da6d32bafbd5ef6bc152df71b1bf189b61966a18112cfa175fcaa70d18d81e76551950ffdaafc7fa981a39bf16ecdaa27cc68891d200250b051fc1f02b3aa0e57000f48fb90a0538dfff15046df77c1fb3cf604bc471378b58496d9ef08efda4c26c857954965a3d706e20180a0dec467a039cb3844b6a6487bbd07333cfd73a3d04962d814a88d9560a478cf13525c15f2ec907dd6cc72fa66070ab11b40c18653328cb25f1339bfcdc59d900bd088ac5e81d6a84f8c090a24273c33225a838496914ce910cb2661ccf29fa703033af3c08bdd83d2912ec7fcaea5f177a0457f1860b30a2e99fcf5c0fb2729508bfe1375eff4c7e9fa5ea965fe766cac4d64598d9d2b502bdd486892fc0abc4012f148e290deb36642d89a637c5a923cfae9d156b9779bb20277140edd9c4bc550c820d170b4892946599108b730a3c36096e622289ce55910f4a9453990cd1073da37269c92577b7c60340a7bf546a05d55d21458593b7d0566071f6f44f2e510403a74722a7ec15fe83a18dba94265fcd97938a5dff74d266fc43df8b5107a7b142f2ec7062cea608751d9e409cd8c178821ef1634066436a8d10e75c1da083aaea4d4a6f438caf49c5592342c7e10ff4010e56f508368a06c666aa9e536793ac6af00eaef156ac901216f9715201754f77d2e1288d95ba47c63d2a5c383c822633bdb6eb803d4ca16aa525ed1681b2d845db5772fa97b8e3c5acbeabf177550db15254575cf02ca639c0c6dc501c3174b80fe7fa7351afcc768c0538ef5f87ef1e8a6a7ef3c1a21225bed1ee0681abdc766e3c778c9254f39c7ed6f6e556536135588940da57d1e3161609a470280f12d2125505e6e3e4cfea333b966ea142cdde5c15e775c672e3682731df19bdb52aa7bf4c0ed2cd1c91f7d887f4a2ec71fea44f512a4a46191fd2fa22e5f4cb0d9db8f00087fcba780568540c79346c017c28a9d3b59c0b5e85ac0fcc70b9dcdfffa1a20978cc11f46fbcf99460789dd683a7053afdca83b079503db5f808d35ad75454d989f1289809501f6b34f923bacf0e1f48307db667dfd9d4d3f73d7d6c63d7e8fd6da45eab327f8796a7f7df712df33a0cb0374da8b2281de3365c461daeba4558313fc5e878df13d19048095785e7b4ac4ed57518bfc7bb37dd5cf96fa953fc8890c380ccaf6bfecfc2e133d6025984967eee8d4498b43ab36ada17ba137295148c95c02e80cbe868fa9ab7801ca165605bf0fc9637cbf75319a3885d7452b7a02029796d97cb9b8b71f386bc96c96e7ef3af43c7aac14224e21b3beee64de1fdf88d32acd28b5817925cf7ca829667faefaa58fc6b3261da13e8000cc40fbbd2bc8131bdcec7c688f251e4aa1f385bb407e42777930dd69a168e1b5c993d45a0da788839c0500e9ec7bf3956d0ba6b608973a5b3ce6fc9ffa050a882e4200508d6ead4b412dcf6865b2d7c6fc64a7b9f75146934a9d2d8e473b8791f04dce8c0b5d3c2f0281a1d735f3a373b6d1148297a9c149cf3f077e90c01019c03d0828017c50ddcca18e8230c865cfdf17cc74c9153ea3d8559889f216ec2a6a1c29c55d59b3f5a6d294792994a7440bb1b00e059e37f577250fb293d90289a336bf057aff6c3b66898fd4313fc003e8efa50d48e8d8097fc30e1c3b4af8ffd75c11a05c9a329fdf5c6c2bd0b998abb3178d56a0f71e0c740d1cb1da192155fe88e263484dc77461a87ae1302bf654ba661345bb76403e04546cfd6866f2d9fde427f00b3b7881f1b88c12d6bdfa650eea703b16ca4820d5b23ea631736f719736c7989bef7d4264de1d6bc8d7f2432318d37194b22f05d3df175058d31f2b2d1458a9944351396a8006ee9341c98150f8841f31bcc81e4a9c70ffd46c83e659a18cc46e764142f71213bb0da73944ff2ab38d099455bf93031100353f276fb5c2723839229109d6b8cb358be0d59dfc5bbf15233c82bd56790f42d7e85f4811b272d4132eeba9605a42042fea2835d5ac0c7cea4fd2287a8126da3ad6d924897f1db419dc8d311c695bbae90ebf3cafebba271ccefbed6000dc07bf4b5e1b33f0156a41509cd3de0a7220f2f571c4bfb33a9cac10da6aaf5f2da96d59876782854bd6baa94ffde680b90f2b81f941566fa74ed3c9bd63eaa5e7112d4e52243bb0aeabd82cf977c80cc0bd643a87bc8de33cb6d701f6904c239dcb12e1694e138971ad826de4ee9c4ced5d12d51a0952dcbeaafdf67b7f712266b1eca5ede9270189281da065184bd755b354ebb279f64ec94f1dcb0d35392aecb99cffe49d372dbc72be4d68bd9a44625a424e97b68ebd49482bcd4735e1c1f87386dd1fb887c480a6ef82dd9fb721f3dd3a60ea291a6d2465a422a50bd86288ea103fb352ccc7a760eb2ad4d726ad7d9466c2ac65c8dffcc7d16def0fe9f11a3626f98b2954847611c703e0b34604c90fd2e6e9de398a701581bcad8cdad9d692e5a6575135a62a0a6905d3eeabadc81ace26de9a92a4cfef9989ff7e4407d1e2b44381592581b3a6c2cf04f6f8d62d0716df29d2af0433e05961814c9f8d1868c65d5bf296a4c9eb8a5213a469b304405aabe32addb86935bd9435ad5542da4f04a4f17872952e6b0ea555fcad8a29e182c7874c710448e12574a904bccdb2d7d2043cd89865f9e853660cd37499e6d1156d87f04269a345de572e64c0a1b0cd24b0246070d03c6efad4eb3d76d66a519ff5245af54cd380fa930b7f8388364b0459386e4310899e736731a3961e51f8bead7017bdb8c17a967b6ad0c334d195514f5a2e2da722252574290df6ae56764f4d3045b047bb692beb48fb180415565a76184650d49d1fd7145e65f49c7d282310ad7cb8a9023e205f43c0fc1099a5ab559c687fe23f27f15673c5dfd353835a3555d8be34e2dbf46048c08035c60f55209024b93a20ec6a3055622db47778381babfc1fac3acb9bc052f5a1806f1dfa709f82147363569374ad060495d040ad781e3a335d580180918e8f5a0701170249ffe1054091dfa7da0ca1cf204b2335f82bbd7640a4656ef42319ff389d40ea61975731923a813ed58a734b672c79d8cedc7df8c51306de6da2609c71a8bbb3758a957ec184e22145f9682ad01f4d9252ade27e9cd4dacb50bbc75ecef3282d2c38f5e5ae44557326a1cea40adb9aed32e42e76b7052de2fe6a9bb016648dc8950857cea745078944dcae4b9d6935006ac7d473d1c63fa1f5bc4bd87e752fd2d86ef809df29602bc1b925598e79f38014205d2560f97459192154bf924a6afadac2e17ccb35c4bb1a1fc5c8a842d38e8c9a4d1cc49107426ab51aef5026131aa26f9141f04fcdfa5cc498d51d71544bae5e1cd06b46566412e45d26e504d8b259e91d6e3beaea147d722a858e96d66871342e2807853bc7c84ddb243f881e354a1b8b1c68b3c197b23b9039e414dbae43bbdbf03933e987834c976a54aff3daa9f1debb7a0c4895d64136829ddaefb17328f05594ed98b499e4453755bd68ae2fa67a281cabbfca34e3abfb48f9b49d29ec6e288e9b9dbeff8bf333406591b296c59eb367d8a1485cdc598e7b894001521805bf81764a88c5142e4321b329dda0d6e7419f2f18a23e058b1e67d748da4a411a7e3fe23651ee22a20dbec67b29e9096b472dfb2d8a3d7e49a93580f073e0e15344fed31db056cb97b72a19773a8bfc91d38a66a9b09eb482f5ed8d610d08ec90027a77491cacded7645b7b4f9bc3ae444532a5c2f2bd686b1b9fc5c2c10929bdced130bf0e2a517dbaae53b190501c922041b65e9650b580318977be5cb8a625930afd626d49276a28f6db27dabb24be916113a78c8e8cf2b0ee1db7b3a1e5945e767222a15bd97aa6d0adf76bdbcd395b203505c30b0c49d4d8d1bd2efa566f28cf44c61e1c5d49ffe1d670a6fc20d2d2aab9eb0265b2d553c936d836dab50fefcea1e607206aee82762f2590af53d9343af48711028693da45aee1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
