<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5bdab2fbe67f53d1c3b7e3700c769d449ee1b0af44f2db895c748ff8f06c6deae81d17e5bfb8c4d3943903f2153509c595faefc9e2c7c9eb882aca6421d16090c3857e01950e9d5bc313c6e58b3086ec8ed08baf976338e2bf545c72a887d91425b10886f6d12d7b48c3a843fe893337ef53724b9a4c53c41eb32a2fb90a648528d917fe8b2022f56600f2bc1a924ab011f9fcfbc19ff68b1f04e0df313540436c15c0b5730edaaec791c683d9b24477e249d081fa68615f0cb190a715e25818e027c2a490bce6ac5f304ca6f0a2f0204cd58050bbff5b0c1945de2f27d8cdc73f3ae0da83fea5ed31e2d21f7fc32ba721dcdf71e41f369cc0d523d3f8deb18c45feb0ecf7667cc5570cce0ea9005e31faad3c46ced3c48214689e8f5ecaa7ad03a1097c5b8689b05e045fa0d2a8fbb2bc8c59b16174aee32995adb043e37fc8e7e4455ead5f3a3abeba3596201294cf7e4f21fd000edebfb0a96f902c5322481972d47ac941ab91c496e86b19a6981d48e1946dea7c345c4f8c937c3185be83c10c56f79d44d77e13c3e0b594ffdbe7ef26f682d43d78f603c296e88cd9eb2926e1da605adbaab073bbd9a557e30f1151f373009bbf535cdc8ce1ca24179452392269633ed8607f8011537c9d461b2aab14dc6ee532032c41de3a1168650a26a5a633a214878c59ad14b77996f6656a8590e0bad22faa0a8d144b62454d8ff6971420b6ac64051fed91ee163a7c527c5de29b8700e3ff4c29094456ebae4a4a07b1fcc7a11758feccb9daf29718cc5dd49d106367bb3d75504d6287bcac30e8935d54a148da3a3c83c781ab1f7cef9f3714b49755621104170419252cc9b48c8f217e5cba1c2a20a981833639f650993ef1f8e2d0ae5836dd2e2e99097c9dc7a14159c85ea3677edf39dbeb2699a063a4bebc29ae7cbab3a30c4298234bdc661c259c444d00a16c1576a484806f1f5a655219cacfe20103a3e15517d24261202b3021a963aedee4fbafbdd8f4ee68cba214095b995cb8b9c8dbda28824580f7ac6b0c03bf208a8ecdb244727ef3d62e85e561f18d4b990be5d787ecd86c9aaca98bfba516fd44f88580105cb8fc044a30085e0716a832a1f267665ad8755640f9b0bbc454f83eb33ad3d359872cf5a8a494c04b6ead5814993cb1dcce3ceb99f51ac4cc61193f440a5cfa9c66f9f1afeb01c36d10e6cf225150c9df3d0f4134ad364084e62a68be60c4bf00845bcd3b6abdd25be5155ea1ff8562ff7b9e6adbd8c27a15cefdb768ca9a3a3a3be6e51c4faa732728fe29a58938cd4a6bc3e96d2924f26b6b471641f2b104a496d585609f0fbf20984143a6fc60689ab3d69d92e8e31a94e5446535b081045b5bee9ed8d7c7b7279e3cb398513f01d14b9d7b36b72a1b64269654ef306fe294838a1d0f45f4946ca4488cfe0ca0d0b4c4ac047bb102062aeb6d00c4a535438cafd19ef895a245013406e61fb2ab2d5a1915f1c411c459425152be3cbc48cf3aca30cd5e926958440048f978463c29cb07ec4a974bc05a9e7b394f491ed2263f5dfe679acdc5a75810978adc56f4e3f5f1ef2c889f2592df6865159cbf734cef93e78e9c8fc963ef8695ef796af3ac0262d43b50273aac5b5231e91bac29bd761687e9c472889003335c640c020348225ddc23e37d5997c24eeec4f5acfb83da0ac4b0c1819beb00a53e4e544f0f631a7e3e3cad241b5ea604d7d297592b15f82aa43c9eb928adb661ff314b79a31709fc7f3ac23b6cfe49472e882d9542afd47f6aaa4114f04d71814cd1f33390a88402a1ec3c1b1fb2ad21a84405c312574f4c41fde75473b864726d90ab6aa2adf6d60d5c0900cf4f1361a1c164a1ff68037474cf5e7c58c23c740b72451825fe129eb0d21176cac8fd6af3cfae90a859643c2431e5e819545327fe16054a537354e3cd06d68bfa120bb380feb11cf1a4e9c3944481e95e301b21a50de9681c7bd7dabd12b60ef0ac57a9b369715dc4c3e37ec312f63a969b678d2ecf4b5955304074653413052c6bd787519b59396cb176a2f010bf8f22cc22e426a1913b660e3f195c61de8395fb62263b333fe6ade76525ab317f95d45a9ef43f11797e591601a63b9336d25dfcffaf9eb7497685dbe92905a9e520f809c9357e60f7f05ee4c404af4ab8a545dff09638a3b08c240c114d47f2d84e418a744a4dee6064e115dd2f71fb15953acb16f7731b642593bca8262e0d9fc513f2009675fd46deacc77cea79e2e0a450005a2894d1d37eda120802a0a6bd08ae2c046f2e9f78598479e39c5e6cc2681e978948742b63c399360a1ad47535feae61a4230c0e99c07375737a3570444651b688d4fe11338d845b8a8cca80f0b790c17db610edc1ce830dd897052552b1ce1ab275709c04d84d8f651ef150477d4e8dac715c4367e34eae3d31001cbf3e1d586b69fcf0efd367a541a808bf6f2c44b94e44ea1aa055086ed48660e643bd0025550debdd3eb378f3197ce571c9d60ad4b6c94e7ff300b076a81a08e4a7b9300e653def5b07578b23ec6873f11c49a28e5632edb3e4502428424ecc64d28c67feeece0ca5390d6ba6c28c535dcca69bb7bd3742854376b08a28971c4111c313cf74ed361ef4e78dc9860dcd9a60402f648781b57f406a6637e049f22259655b3da669fd0eccd6a0c59f1535dbd8dc15bdc6f1b7596d8f2de518628bb4cdf70ea4b14f87db8d643120f57008a5e97796aa69185c85224c94178aad8e4e54df6f207cd6f984f18d4cafedfaf6ded8bad82ee5bc61a1308633c1f3a0423e86867bc49c1d27a79db7d499e6a71fce2ac30b93a666c9f1731131a66148454a4bfd77bb6fb8f37ebef546906be7814ebb0ef31dab8a0ed0413ea76fb9ab49d6a718dfcff5e5fb79f758286219f13b93f316a6c304e2490de63831bc57cb3a69fbb58015f477a7e49a3b2996d35184e95f773c8c62e91da2c5ec7e991e36561e9bcb7b4bf81c3089fa6050f7c425f06650788192729942f90101faf7adcfd6c6499b2ab1c5f33e3741e2f5dd0f94e3ff6c2d99f787de96391557cf3e59661cfe10f99cfcd2ec68a46048cb716b70f67c8aeabdffc261c0b3e6556c7712292bd25f57c6b2776fd59ca44b262b90ea638aa62dfb4dc071cda6502bbcda2a951dcc73bf0fe6741afccfab521b60a4e20d740fdfbdebcf396b5f632143b851f16730659d7320a981c7e03e7cf4d1d82103e62165bcef945e48a0ddde45f3533f16ff8335efacea0eb38e178205bbb5654119696f4ae85edd383722a7ced7ffaed5b8e82b755b4d78d2437b37a5fd04798b155f0992c400fa75f52dc9d26e557dcafdbaf09576994a0db9043c63dfa3bbcf8b9fb1bc4098c30ae8b96968bcf208d36a09204f87d872054dffcf7f60de20279f3e08700d1f374aee7c0d9263ac09aa2995742a30ff7056403ef15e66be5df73c66397ffebd7d6e5db5af2725810aabb6b082d7f119134c560ffcacf765710ccf9e97e96a995b200933004b4d993f63b694e01302e0f0fa3187dd35879e9aa8b3b49e4fd0738ea12403965950ef0c0c4b5f5c56644a4e841834f94e707d72a47592600346679cdf442062808c3ffbdb7bab32725867b1f6a528fa94436d3e7cce0059119f7c9168e6883fdfcfd7238efcc1214f56113bb54ebcabc5bc8d3dc93b277bb78f339add4de43812a175dfd74d1ada72b3ff69d92033eef058277d18349f0e1088734dbc1c636bbf31130b1f7ddd0acf1f6e71b384f7b7b23e7c96da8184826841a766fc81d5f2d58716b6152aadcb9adf1c4182a4231e432b36bfe3438b8ee60dbba743b596aa62df064022310977a3073ef09c402e630760193e32e2d250e15a6eb2be50fb15ee88265f433f417f875026d1f93aa149d102eeaf627a7c0b1041a0cd830871c8e0ec0ffe607873193e44a11a7a866e8f21913483eeed198e4a4f01f7be31caf5927e05d7164d33f22b1a08cc08f5ab6b92554ae9b0b82348cbee3c48725fe191edd343c815da3c925cd3f1b2c957f2ff54c72f6dbb85fe7161e43f39abf9fd3754ef42e9918c3f586ebb496b30aa6a199b2c47e8a09ff0c9ed1b065ff283e7dd767d2b657f5a0cbed9625dd48816679c1c70094ca5fbc26cdad13942dfd8c18ffa01b5530aeed3624ea050fe87ccd91abea902fd5eb66ff9b18e3b01600a58c57dafb37843660294213bd2fa6a03ac3df8eb19088cfa752115ebf05a7acedf31660547a347ccc3a0e34aa7949c171c1f49ced917aa864b0ebe1831bdd1aeb198db60aad5785e206545596b38f3e1ee34209fb2a1547150a1566aa46222309ec8b2891c21d44dbdbd083ced2e1d4300df3b9ef3ac79dfc675b5f145a4e5b1fce75fb49dc575f1ae891fca8345e68b4282469f5b00a3a1e661691ba681abbe627b3e6f4ef545c2954d64582991da111adda93a9ae904ffc445cc22754d7d366d6deb1d097203fce2df4d0dd1fab4208da300d4ee55d0470ee15d43bb34d17c6b7c173968ec635930bf9ddce6e3a79e70ea271f701ab8fee75fd279fac52a5e88848d7b4b92aa214d4ad680eb3815a3cce584ed729052f834ac7141682d309c3764cbe180694bbb24c62ad56be4dda1352cdf74c76ae11c77eee133498519887eefbb67545bf7ca4103e0c4a217e748c319f6301bdc63d739bffca07f9dbfbf9d658c86d7792d1b72bf058165f66f66cbacac2f7e51937f157c66cfee0bd84ad946de8421e07c52b60f2770f0b744d851a2f2bb6a7316439d81bcd87a83bbbff225fc7245a92375239d3e9a804d9bb460a364769075235046deb6e590dbde927ee5458684335bf5a18da4c42b254efc0eae72078327ed8e5f930430605545165fadc8553405636a567de8169d56b30994df5e02cbfbdfcf054b08508677d7e92f20d13e6e92cdbb7476dc41fee88526dc575c90347bb5441fbc95fd9790531ef75d256f95bd3166307c6508f91572e74d66abf0f9e82b709eb37470f51b48c4d7ce77825d5f9bf41d8f341263d62025d13295c0738f249521f66aed5eb44f4d7c5ee942ff4a060193e502a7cf9394c1b457ff01c75c4d03721f046406961f8bda50c2d718b24ebb1d305ab3702b404cd79a865e95e593d205e3015886426a4b6360bcb3c53cdc56bcd07e75db19a82a289b3159b281b04d61721171a83666048c449428aaf12e1f04f03b7ac0c537cf9208b282adf687df9dc7c5e0d31ef5164d185b94a9a95af50f6b3b00d06d6410c98f22c621d1f2bd430b3258afccf3182a8ed821f70aa3564c8ab2c87ccdf19ae96d164971625daab8a334d1f36764c30fe170759d8f423f7ba4bef30cce59325eecadb3b261ceff707a67717b619a20507e9bb0d8cf078cfb5456986be79ec3684957c83f72406dc5f9e6f80021e21854db4ab81fd7b7f1f0eaf29012790c7922bf51b134eeeaf1b9b8757bce46319503845bdec2b970378e005854aa579cb1c58df8bc620fd5e7e67e70adc77d12f85511201de102205dcef30b7fda8d7c22f998f679e8655cc85e0fdcbf2a1c6a5e1c04c78e20fe07a75b67d289616959dd2d66f08503a0b175cdc922ebac7a1f8fdba3cb51ce3251cc45577fd1c61590274feb94b87def993a10308980867b38f63026115e79304645b7823b8d542d4532d693744c438fcc157a2d9805a707342c014a38520560ba1e8a690e03d39dcb13764af87b8c17003450c9334855bd523f20f51089434fd82acb03ef184b9a8763c99634e80608d23cec04d555d8b6bc5b9e6e0bf5d18ebb56b0c74a42aaef82d139c6a8528175448a991d83baeae7ecac346fedf2a162acae9d8a275593c0a4141227fddfc900e1ceb772510be7cb43f44db128b776eb23bf4005ae05bc95973cbfe261184396f148b6f1f2f523564efcfae998528d426338636256f7b1f96b03f75e066d55183eaf1f7f0ba0ee65999b370edd4e068130f2f83b7923e8c6f2657d2c62f57b154aafdcba77dd98bf104839d46e6fd153b756b0ccdf8d3cedcf91ed040685f3f82cf23cfcf8565d6eb0cb85b25900742e8ac42199eb9ec450a40bc6be6b332b67abd0eb829bfa70da1f84bd2bc5795e98012e190cb51a9e9a3506cce1677a9bab33d888f48400a2323ca7b67da3b533d89ce509ecd770aa2689bcb3383a3b0f4926b10ca488fc0415c57fbeae9f8e7711e6125ee05ae60d496b878cb005aa25960679bd87cfc9c7f1eceb225405c837918f15abf36fd1b5a81d02ceded9cf937684ff9cd65531dcd05d61f89afe126620cab3d131233d4a41fcd798e8943bf0ac1a305c9846c5fb6ca63899c4956f09a07bdf9e599389b44ccb6ccc37b0aeeffa42be567cb614e044c2d96002647ee80c423e30a2bc6a7cfc76ef3a4045920e7cbb38d0e9183a8768927345d084b826c5b58c7b41517bd8ef29bfd70a67543e94bb69eece0eb12420c900ac0b35036069bf3a06fae640075dbd40da72afa1031c7d54f3b85b105f0bd274f85e7af8b6d36471aa779e8bed0a3882fcbf72ae262ed1fc45a952434e858e9819f86e7023c936c41f982bd9cf70cc47fefcee306f9686f266ffec3358ed8fdc9aefcfa3cf4d38ebc81b3e114fec8d56171071f2c73969c1de40b05db3dca7ed1bc08ab33df8ee531f1bfb217b628971cb91d0eca5db773aa94bdfaccf02602ddad89acd5c1c22912a69e252bce709c5e9bf84b496fe7ba9efb82c4217c1fcda9f22b27e7f98651713bd79420e89191821c2b22fbad1f92ec9f9dd9d004c78b4e05cc1a9b9024049abc5a482db3cd6a5cc2eee7502f26a65f7893195b3645f47e243156162c900caa22f766433a640504d720a408fd24c49a4eb802aa4e04684324c8a11d0d56185f150a4c4147cc26eae036aaa74620d14b8e19bd0d48d8791d2bc02a7f5fa588fa4770d4f7780f66fde3506f1235d60b85a6df8fa30e12d01ca96768d5c6dffc466b07d3c957890d9a963d48eaf6a7f1fc65754f839d64daac2c38725770a96e310d55a43fb2f57ceb0e7830ee5d755e5059134b1ea8457e9e50eb96c87718927fc55e3e955ae12a1d61d5a79e658d2947ba22b15ea90718c90a397ac0406435a67f0f2e677810894d65d50a69234c5682de8ba5c3e92d9842fc4d5831dfaf1c7c083efa0046041d96da029c9f55848b7bbf3e4f565b14316777a3f3debf365a7569acc9fd6a133ab35fe599f7913f4574ed924830881fe8d0e01159c32a8198bf7f863ed0809bd49a0bf9bec2093d3a3fae3519934c6bb04537ded56133e9064cdedd6ef89717c0e76529e58b0cff81c17da00600373363fb7fd56918659a4d389d4d223459608fc158fc131781369c47cd73581e7c0ae324a447a2ab7aee872ee49dee3fb6906856dbe91cea5b8298a58d3549ff8ecfcb2ee8c3ca6bf811949cc07a55ee9090320d11bfb2b521b376d422898d4b73c7dd662f190172e2c01b91d8ae85cce111970063f3a791823fcbf3628a4c3d97043a3abfb0dfa439fbc60d24eded77a40a70588088436f12a8065d83951170681ccaa5aa058169b86b57bf8f59bbd9b8ba35e699a67df6d8082b0d7c38d6018aaa7d3a667a37cdb740a0bff939c6e8da89908c1dbaacc0879771dfefa3390f8e5554e7a5c0f61c62e66bf70540f88bb7082788160fff24631011325defd0b808846f47ee07626bba94771443934de6a61f5c0d1414db49938a99a83c282f512ab5ef1af260d96d6d1a2e40d7910a8c3ea257ac03110259d2fbecc732044f5b8c07913fc6b2801889f9b8ed7d11a4f0af8629fd297cf4828a774b65000d0558350accafd91efcf5e92c9b6c610eb399e538f8cfb44d0866fad569281c0de7cf443cbede7797f54c4d96da0c367c68d48f52ba8bcb672276729ecde7351ff24c658d5adc581127485604e280d582bab80eee29e412741db917e77deeb880079d52c4047850b6cf82bd59800de6ac339aa51865645b32bc4ce8a8b732545a8a6c208e26000c903be6138163316031f97a8cbdecc858df5206fffc6acb037457d6fcfcbdc24f34cfd6dd4a792c2679d327fdb3232423ecd75d1d095b0d1284520ecfaf109bc264b4bc07bf7f7af26c939547a3eee0cded95086171676a5219f257f99c18399efd2fcc80ee5b6efa82a858e317672144d893654457c6dcdda7fcea76036fcdd1965ef11a4c692b5735368fc0c2429c355d85c91eabd38b618a117f2291e7334a50abb3eb370312a924e9a9ad84d0cccfb2ce28cf33d3c65e2b0675bd38da0ad9faed4f598ad2ca7d7d3749d8714234697b36fa3e662a76f69338f75803eda65ca9944c5038d97ca28d40ed6a2044c659a73599fda5435106742251bcdf9544670f3eeb0c5bd779a98521b8b6e33bfb28e7ddea5e81a5d69a880dc6ef986e3471da8fbb696059876a69195d70e392a0e82d4d64e9e1a08368efe7dfbc7f50e3ecb75effb76b2cb1807cf4bc4d6817c5379301697f1a1c58e80bcdbef0c57dd20fa855cfe46921a0642282571a3dec59a9276c176cd24b5ae94dfe82d79992604ac3fdf17fd45870508678c901c43d57dc7d604cdfbc4c49c1493727624e8924321c9443f31dc5450498acddcdd411ab083a701d726f2389169e777862b3e9db5abb34d3243c5f650f7f496a60f335543d0a0fc6dd027a537e221457b92b8b99f8f25ed0eff4f133e8477587c313154157e605f3f08663d4853ad9eb55b70cb1ba5ab9cb4afe63ade269005a04493a0e17cebd4a4c487edfd617fc276820653ee54d3d044cce15cf7e2ffe255bf1f807e7051b9b4220a14e806d4282d5b9a05f591c30a1df616cf49853e637cb0f71cc5599907e86c7d7ce141e1120df21aae9b3b4014b5f13dab478f6866e6d3ab74bfd3a9bcb07e71eb4bb7b8bbae61922ad1a5f4f8a0c99e239bf4cab96c77dfff79563c979a58c0f228efd1b3ad43913d7b3fa56bfbbe4df945deae320b3e26dda3a54b816e3d333e95a5ffadffb3faf670635563b523fe94fe2c029fe90cc4ef84534f9546c717f2f74305d93a3dd133859f909c0bf615de18933d1831908952dacea9986eb7de4be1d0d5479f2a84f756d548aa5b1bb3eeca758724e3a000ff62870b087071e5440774cd0fdd8181c160e121f771f118d0da66ef6aeaeb0c19ef102b815556b3f0d1435a9ca75da69f42a2ad7e31e6f1ce03c86872acb178b688179a2024525feb94362731a982a77930a036f92a0ceb27a286350e4e8fb863847c5e9d67ce89bf672956a65fcb292189a66e20ac32920ced40bd6aced8f3c936bac8984ab4349389eb3e8f1742912db8d4dda57b3fa4b5cb12e828f1569de75ae0a8cbbc31974817575ca3133215bf01b2bc01124e8c03d2663910ceb182a4fe979291ad25c5891e810faa644b24ad6681be93ab75d2ec339a1d1444ffa9c48318d080a7308f18ab87f4c9bb451ceff4b10c3d1af97713bc13171ad073aa9a47e6c5cf08cb88a1139445f1252d631aa475c4b5664110578f64da8d88d58fcd7a5fd88fa07ccc5ef038974c6f0cdb9507d3f02f851ebc4a3203a9fe87109aa292624b34ad4242b8896461259bc4ec4f736df02e5906de8e74d344c1dbc73207adf1dbad1f7dbc353ec908fa609e58589ba6e8f9d827594c4a584002e80a6274b11fd45464e9602b494747d11e64e54c76dd5978c887422a209a8a6fabff54cc4d245074035f496df92fa29326cd297eb54a79df90d66c98ecc9e6a3c7ea336e5639b1a08a3ce1dca65ccf71d1fccfca8ba84b0d6c5e2505110bc08be64a6cc666a3c60411498425f33cba45f0ee27070c3ec35e2c9724105a84b26c5f2dfede4731288b21282406d61f22a35dffc1a2956eda35b155f05a5890f3fc25172fe39f104c080461be425ccd16e50de0a82027f69df47aa572686677c27e6101b624849b419d5d6ddf9dfc26d09ebfeeafac92584b932362413bbf51a696baea662117767dcac34d37ddb4e42c6cfa86de7d099c8682a6c9f9c2c5ef6a88888b3f501a650d9bd317f455a7e05d2b1416fd9aa406d0a54237be9ff13fd99bf56c1e886432d7bbd41e1777710b9fc582cc0a821d785ae33ebbb78cbf41e49be69163dc235d33f4da8374e3825e8023dbf95e8511a9a1b8b24b343b77b6a3ebefebe04cd70f014a47bcc0633be4ed0faa91f5861a39ef21b134244065a9b89ac115c49ece94738c049a559a2b2067adff429c00c8a103afe10b24c2f3d01dde3d8c57192847a789198910a7d9ade29cc5979a867e33d226b20437a4bb3cd04cf91ffedfae610f8dc303c263ca84d35c34776a115d11221512fa6ddc7187d721c52c57ce13acb1e24b50a68aad8eb3bb765a81bf3f574ee3d3188a488790177be3288a6faf9af96f3813ed6ea8ec522fa1dbb79966f2cdabeb01a3ab391211a7341b152d4812f20156ff3405bea963371589c3ede84fbd32255a6b720b9a35895eaaea7c46dd945133ab8f6dda79cb0c90affe26164e6a5e30c3eaf022ee93a5414702502a1422e8b9bf62d7963b7fff5c65ffdca4ddf7e8d8d19965720a1da3a5c196cc387b60bb365839ab9cfa3de3a0f1b194de8c8b497b9033ae3376ff98d811942a1b465896319b9ac37ae3035c515079517d52b8226b6ba02641e9bd42eb9b40d06dbfe92b1bd92d37519a4095d3639dba47c1d4eae50860044d5bd5eb9e9d3a8316611c76bb9fb5db00cf5e8698d30cdbe166706485a3bf8ff8af4fb36c2d79da1557df1fa081f843386c87465a61f6e834e0db0aaa38a07ea0a1e700321bebd6fc9cabffb5ed3181b97bb58963c1e275c2e2899e49eae89d8d7def23de7d0a9e4aa356954b00330150c7c222e286c170d4a1ab98db4c5dc0ad7b9cf681de776d8de79a0035532d3332ec42ccb02b65dced35e2504d7b676ec4290ba50d60911eb916aeed358e4b3269b3821b67ab48edc921da59a0e10fc593b596db976d355248d92dae0264a00359275fc98eda1228838e59501d6223f0c343ee23c36aeeb1793034580a016662b15810dcf28920a0412badaab74350822b2cdd2c9ed0ff049142e52287ec77a3408b3a2a6c2d76314d46b166f56c388fefc887d7ad77d5f4a6902f21b94e1b1e6fc7d1ea7fc8240799e52fedad2f7e45a6b76f34e58062a8156a6e9c5c23a4a45047c149531dc02348ba28fdd270b225a0cde110743b2eb42bae0cb8ba5745dd63d03512fe1e3879491b18b38241cb8976d2248dff6e54ed8b2501630523ce7a8ae2f6cc5701827c1d991139212c08fe2396b6dff8890f5e83e18ec381b1b022850acd158e07cb61120a19c0478207752db1153647aabb101d09f2b84633d607b2e497e0a1b95c5bc3f0479a8c75e5a6d0507f42a30863416025f7a8fbd4d206fc2801a0c858c13885b1b53cfa8488d2a972722add1aa969ccb821805d550c1b6343650b62d4518bc62c4df753b92bdb3ce1caab0d72ea99655a31c44546eef5316f05cbb4ce37919df2555ee0c176895e5e1f88a0ef97ea68d91da781b4b455003ca1928cb8ade5804844ae90115d35a0657845f80b26bc10cc46a5d5c72064d29cbef8a71c17fd44534a81d59802dd62873c79983ef405842e783c2005a7b57065d7e6081e08d8ecf6c5359debf11e709ee21c952485f6cdcf134d92d618ed37efd2a777814c65889cf1cdbd00e5e2d688aa363af47fa925f79bbb8a98df59f569cff9eb93dd670250beac4b526585cccfe5e3dbd39f8a4eb4dd0a5a04a9d40d0c08673d67001bde025d028eab6ea8b99bfc4179365ed58e0f33a790fcd60eb48a7319b9a8f5a5a183efeb7f0e00aaa5a36899a9fac69d298135bb1f3aa12c9ff135f61eb787f0610fda2ca46f14886fb9b251a2e911446a4584e887ae79d5be35d6b5343ddb5135f90692551ce7d59745c31bb155a29422a88f271e7ff0e8bd04c3eb44006427d80f317d194f9208896b8ce28a01604d04f235e30d3242ef445d6bd1d877d6566b1f7d005afe33c52fa94906b13812c01864151a47479c6e99954f07b43186bfa5e5034b2ea4d1ed3e6ad472462342b6eb55fa42948545e4720c27f565f327dd68cb5253486e92f4eb12397c95f16bf237ef5012e4beaea186af3ef14126ec82ba0e240af56c7412b9a1f0960cdf74a21cb6e00b7e465f2caa433b83c00897c2ddeb8db9e14e6b7a6682a21d789bebddbf7309e95c9b979e4ff10959c2dd318825173271b103d682e08486809f889cb9d28ec3ddf48ca5881c73c22d8dba39966aa1034b77f58e430ab8b915e267dfbf96ef226d305279f1d66e63f4ae85855a1d6ab6640a5ad9a10314545a002a6313eacf49982d81995300023634c359906ef1829abe440ecf51f9ea4c6d61ee2a34bec8babbadaa0349e14b9018be1f7cc08ad4819b0c3348f5f91036d0863853b4a8d7395faad5e3ead61cd8b6df3fed9b319abfcf964060746aeb46bfc3235d49c6721353db01f81c3323626dfa83d19d9fa458a6e306ce3c794928f116c32d3373a4081f2f4d99b3f5cdd5257773a46a89c21b39b1c4fa84c562c54688d0f3e7256a8ed6841f42750dc800f6c06aa7967248b89ab9093d54dc8019a6e03d20998e732404079adc159b09f79cd83494e6daa619ac2d9270056e9604990381309ecf8ff938218a5032767f2692c555c43e29cd1b3307cbaabcde183e52d1b19d737f624b046c770a3f3bf4fbaa261ca460235ce65de9d7b39476e88efb5c10047cbba86bfa6ec85ee8c571d1cb905dbbf45ff8ed0504974b60fc12705a559adc24c1d5299242b6e05788cbd1f90f9d07b9829f0572bc4ea6815ffcc7567df848dc544a52efbc00ad3b3831105b3dfb162f7265e165e38dfa7f38922951d09e03daec612ad967a09a516281b21df918045e6cdc7e5338a06d6861140441d93eb0dbd9a9c29fe2b198fb766fde21596e199755ecb9ba1b2837c43b418c066e619f7f923f696e3ae93ecb29ac9f8e319f097fce2da8e25c9afe863bad49f71d1a7a3689e06a3a9fd278cb81684ce4b2ef5d15702334aa7e62ef0d085548ece8e94b494b54922347e4f951e5d812e91d3b9a5baa8cf02b2f970815605584efa5e74cc865ea000cbd67c9678a6e1bd56e1a0dee06385b93cb41fb0f54cc691239ee2cfadfc1b9ce3a11d9dbc3f3d2f0007179be5382674ce8020c943700359157cac8464642164cb7b40b1a0da25eba98b3f4921dea1e0cbad94353bd1db414ffe0f2e80b33e1d959458323e19a363fecde5669044f59a5a0c1ccae9aa973997f3fd707f3f4fe3e0bd530ed8861967a6580b486a549a3596d7c86eb7c97688b607cc01c85be91ccb148ef7ac1256578553790883acf5eca0dd004483fe34f49605078d1aaf9a3bce280bac3dab554e70d81091932d8939c222e8685222ea65f9c6f70ed1d1802fc641b6e196087295f8266eba18d2f8c533a5637d037b933067ae0c49df62a291d08bcc03e7c559a07117e7fabff661fe8883ec6e178495c9c7a61665d1ec69f089231e1e1619c8ccbe22a6d78a328d2cc0cd9564bdb7048231a5567f3c7e9a96b9c50115fb45ebc80e77a38f23d0770b88c787d35529b828bb3219927f529a1fcae9ed2b6c5ed294989945c432884188c80338b0ca205b5f098723afe71dcb5fb2109bd3614c180b102412ac5bb34ad057376854f88b5c214f9fcc0728f416ba118f0e63548a934680f9c70041465b574d23f7c40657abf112048c54b900d0731053a01d71167706c9eb80691a6ccbd1fa9d468d34ee55e0d85c338100d029868a7d4259be1064b2a862e1e105ba66494fe213a1693ddc6c0a34d8a224636fcf739198403acdcf3fe317fcb042b46b3cd7b55ba69054fedb2f9e87a44e2fc367952157ef2e0ce66badf79857ad6ed14d073a379f23d10ae072920e4a9703f0a77efa5cd1d401bb45e0f5fa687187d778cfe5419eb803aa2b0c19ffe5e599c80a1e9b1b31213df013e0b42960cd65dc4a6ab360f92a39653b1d49e4ec24283a71c50ac0b7ea3e8990a5ed43ebcd8eb4f6d6255765646f3940f0f878b9823f499a6881f1eb37c7f5695e286be812767b25fe22d22815a300e4dc06adada10778eea127a0089b007968c2f61eb6294dc779eae31163604daec273b893c70bf5f02b6daf093eff71bd883798d67ceaa350deba75d059e2f604a315213e89c56554853dbe602441988efc3961a643617b0fedb1f584a13345edb2762f5b1cf2be03c445d0bce796b1f08c6b75ba14dbf5e4b9ea8d4dd7da9229d2af94e5e6d0a6a511169aaf9c935ac8a8176cfcf283998c5ebad09cdca0c9e67407176013dc9bb6476207439d24d1ac3ccc0a5d0b25138f47c20ed0380baf014cc11d7640463665cf437714261b175a596d989ebd984a6291e4fc696c7751c3ae26d4ae8b9b61b64ecd63e5f2bc16021265039483ce2deddebc1edd75444fbc85dc21def07b639945e45cefe27dd1b6cc83a1e4f8483cc4b61a86401a7d7b9033bd1222029c0c8a06ce63bc3debf1185b6aef3ebbfcc5febf4c837886c0fac81b0d70279897dbf390444d8d96bcce6a73f8e62054f5db9284770760e2c0d8636861b924e6db7a9524f1511d3a96ebbc3124520efca2ebc83dc3b9863a9571557f50cde51ba1241fbc6559978eaa2f0c716b7fd11b2a7e62db81032a63d438241df6471d14648ca2f1351ca70ab5d90e7cc4bbcaaaa5e6e02b35c9067b463d04d4a5c9dd00a4befa921ec98811ba9f77be9db6a5dea1d4ed8a9372765744276406f71a5834243f1c55682f9cb092b3f9093732561a3fa204ac0458dab4a593ac422b824fbf05435f7299a98f45e0456e8633f30e14695a4c872c483f0437926a4b7857dc55b0c666c7cc12a644f1976624405e85f2684ef8d6bedff3d57c759521390f299f16575b030e1465b0a7e309a15d734d73ce3087c2b3a2fc3e28bdf6832bff1055721e8000ed1defbc792132e63ac848a12f3c525de243de65367e85ab31a44baf42f3ae17e78cdc78197fc32e9f171dbc0713a95b22c8b6dd64d911baa6dc38d38136486a5309744b1358ddf4ac74b9f76e27c21ce08f92683368eebfde16391be9c0cc3c86bfd3dec532d29c1fe8d91fc487b01f205cf9c72015c8d2c5d0bc2ed4f9519cab59138b2c54ac8b17eb63646f8547c9890a0ca681750682faed829d5fc69e3cf3ad06b95d97e7bd9cb45095e92a4b1da85901c370e54368785d295f52357c136c03053555db842d3323b32332401a0fa3fb158d3f60a5363c9f5461435dbecef13a079dae9955035aa9d6c6dbd41b5d5d2d66a1fa90a668edc831aa9c22179676c900f2f94252e4dba602e813fcddf95f0e4b504a342a5e9e1573aedd54981223454e307218997839e97d0ca5659f70603da4c7a28e23759346375bca172acbaec5f901fa8a9d5ee5d0a736c7b11f8ee10c2bb5ff69b3a18ce34372b3e6d093e62377f574b616c86bfa84fc1c97ed544c071f8719ec6fac8cd5044f5cbb5b8bbbef054bdd106f524b98133b672e8f64351c177d92d079f7ce9e151748c0143b6aef1e4c6e19556c5c1bf6c46eee928ddd89775cb3751d2cbbef908288717729e93d6341ae01f79981050253109336b0c8a3ccab146c4bb4a8170e75900467cb8761261c9327aa914f19f1951f209cfa35054cb29e06cbb2c8498e6048515e99f4e8e6e8c901cee67311a57d97a8d53377dbe048f031df761f4202efd392362b45d69e573c875dac98fa64f9a862136f1b14cdf8877770312dc9416ead78719c2ebb7d8fed4c7c2eeae68171556a5decf961bb6d4aed9721f5e06e9e7013457b93d1287f6568208ef446cb4e429ab4f3d4424d72d44304e0a48d58c3df556630e2f1d559ad752e901a8737effdc009bbb47bd54232e110db5f4138120a1276773e76ae849537ce49b835354df70ce7893f899fbfc52a464cfe1b4611293bc6f4d53af1d899b34eeaa1a8c7b7f76dc98701f2e5397bad4448b516a89634463fa1163ffa064c3fae3949d906cd873dcf2d3213fd1b58ea3f60c21eaaba0dca2415a7862fd93562b0b6138ad41f23a0589b0b610990da0fb7d7fc001fd29a222b7dcfc2be294459452a90a2203f54de2340ca9d978c0facecb53a6583b7da467a513655b7efc0c9d5cae267febda83c1bf95227464a5d68c6b7c9a139f06c255f6c540f37cfeb2802d6bf7d57ad3243b73b8b0ffafbf213067706a17b1532eafbe6d67039e403683155db9b06f6332375fef12066a713fcbdb0f3ec6c6991ade344c2157864bdaa4078ae092e224707ea91c08a7cc01c6f75cd3abe7dac3a477c6477777da8da4db8e1edb15b9985e29b6dd3ba0d932f9b8129298856db0fddbdf7bdadd0551473099e087da208a7ec799296e12affc73d889bdf2a7993370e61170a709ec119eb5bb2725cd48f06b8551a2646f5f2d29f478f12c6b299725432fdb786bf5f6a9e98c5c19e6278735b5e128de651e7c18f77a20dd34e3e8abe6f08654057af9b7d294df0c5a8fe5db06c5faca3a0fa7dd89ade68650ee92029edf708b5d72b61a60adc6a699064ee37e2870b70ce9edb25700d057aa26fd34f317c823e8809a0163ab72cdb011915ad1aaa1dc3ae5f58cc4ac1316f26fe84310f73d4fe42d4f66cfdcc79fea1dfcb98c5ca1685536a4aab35f5e752236d6d2bd2bb66448f26b20c124b5a14c057758c343324b6a97fe4b0c238831d4e572bc447ecc635516ed588851c59393d41742b4cb9ad9bccb315d506a02e0560d5ec02d997b46bd2d14bbd0598209fa84c93c78f8ebf57152ecc5c64d808b34c7a0c17a93f12d40858375060b1f971920eb6ec57f9a1f4ed03fb83f97a23c10b46d4653ef655792775026eab001a988ffbb417cb3ca16b609511b445024b4b62cbf29e5c8dda8ab4559204b0da313de51e36c02583e0a5049ef1beca23f05d43a78f3c53124e023c9bbaa8802ada52caaceaa5bbab39c1977b5d4e63586566b9f2b4c694ce3fb3a54505633eb967deb55133c29453112a795331e39c8cbeec9af534079a4c4903ec14645fd7e29476fe30e912a461fcf12ee7907456767ef8dba8840cef9bc9697fa60f8d2c9bac18f231f77f715a93aa8ff072ff622100ecee32329cdc054e3b62be3caabd77ec6f842d019ba37da34b8e222ca36b4a8963d1cf59694a14172c2c1a376af35df31cceb7cb4992fbd7447f0791b81aaeede68304c76370601789e34a1df246c732b7bd9407f5128011635d05da117536505d915bbb85ac62c008f7a5dcc519faf19f1797c9dfe10cab8a3b419ab484877be3829274d145782da911234fd566161d3da6a9c1c43aa541d37daab0de93181a62cf90d78942601fa7a4c9e16efbb300e98c6acda81d19f6e433d31afe087afeca8b9769945794c8b145c253b7f59aaaab54de69777bb5295e7acec8e12a6595711a5b770f753e8a2af54f766568022e4051be5d51f7a1a454da9eca53127c79300c9140a110604b615904a0b068139b4c4fe208dc3efa73a8cfe2522ba92e8cce60df16b1fbed112bec151f46da030b3730a96d662d461250710f7c7e1d6e006a3493a3af49c1cbc76974cf3b5ab4bf28741e61b63910bbe1fe832bf9c8e1b6142e8c88c1b98053da128505cacfe2c580e42c193ef7c3e304f24d1f33edbe26fb4962212047545d35df2345f1abc1506faacf5e798748db343387a83040142c041a85062f3531cd4e46604898b0921124d347ff4d02b43d17e4c7d44b853d3cf997b70f4ae90436b87818325c2eadd363cdf141894d37f0b78dd593ec8a3517a61fceedf3d024b92cae545e6a8b718527022f6872d3d50e95d32891f5ed37eb5c2c9fa99438a9444f7314ac6aea2f9ddde8a58fb4e863fcb04dd3328ccd8ebff0390c8e5b956c7baecb8abedc4decff95ed56e2e82f1df6f12eecc6fcd241130483f1c869310529483de5477bf096dd51ccdab43428deb772b520dbd39d6045f1cd4a7766507e6bf817b9a9ae2d35cecf335f8d9ab11660adfbb58db","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
