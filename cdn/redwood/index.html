<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f817648aeb075aed8cd291b1c67591c5ee54ee339b7f91cf4cb7ee21e6ce69ce3f8d18da4817af3b072241b2b1cc230db335d84979f18f9cf909085b8df74f05459e244cda474222c87a1e824f9cb51187cbcfb4096e5e0b50df240a62223132b11bdb3ee2eb791c3cf3463c17c17f7e230cea7cf3a30586e3641b1fcebd24fadc4269cb8f05d4ea2589b8633dd11d41209bd2048b3558f5f4d52af502f24c7fba6b784e7d9f3b3cd696162826f372ffe8c24e4269f03a8f944242401365b5b33b11afbe9e18853ca878928a229cfdab777df694ec16a51d67aadb0e7db9ffa0f82501c4d82732006c79f6a5d693cae4bcf4b2c7e24def048af4a338b523ef2c4324b6911f780ccb2415e47593f7854b1300a2c8c3b0f171d3638a4a533ee76089fdf6ecbc1372de53ac8e1317a95f0d1cfc338f4368ed43160f518b85dae8bbdfbd714668d64d82c1db3d67379ae89ac3965ae59efd7b27ae53069cae579c1c0da78af661342ceff306806608f92a249fd22f522422f13823cd3e7137f23ba4a78b172118b2841c2d147a22e3c9d3b4486e2dd0670be3b5e855edcae4f963f19824a60e4b3aa44310935742bdaa2576a9a06ccbd87d1d39da298c346f6a2a3caad1b2f0bc324bb5e64a5df7474a6fc28888405cdfd16c4bc4be8202ab82614d6883cc45c2957d29cfa96b2dbb4d94b376badb5eb2a3524812116bb31284f189d05f72b3d0d9f77339fe368a0b4f2a26be10166fac7d7fa640b230b28de1d456ab8ba07ffb64c339f283512a5fd6b790af7b82f5a49d7ae21c34683dbd862f89ca158514c7220db1d8d6c1a4b5e52aef45203484dd8e42f057a680accb8610edcd82200c95c47953e9cc164f133ca09b20d8d002264ab62ce4335a9bf3afbd16517a5f84143e9cdd2e70cbc218cf615301d530ef3a4daa57b5cd702fd736c1a3ef5c6ddd702031c5bb8d6b0ba917a122d0f2649cfd87c1e24aa8702d673ce393f3e98d8de391a6fce6d9a43cf9c87d7ad57097067b0e45cb7fbcd4af5c3ca83b9212dfa2cb1b68cb19128608a171253f7ba4ba9e525b3d1c4fd730e97baa80e03d5ec04a48f8de766d6f7089b088c7126cf34883d50ec363e4d618e31658270db8fdcdb1c7d2f5ed716edf58f8a7eb5c5f8d7c75ee2fa2622ee99bcc3fb8ca053996b0bd303fc1649819a75513491e38501f1f73ba1e46e8a13a57753eedcce9509c084a6cc5749bc50d51a8acbb6027698e0b79b08130f934127b2b898589231674cf1f95bad55a838f5fe223c8e181a09cfa071c8d9619c66036f3e58843164edf6aa910cf58b3c4bcce34744a8e175baca17ac5d608919101df97f6f52c041f85fb04bfea2631c28a7ebe0e9df866857963ed25c487805802da4a89adb362e857fecb330e1829542d8d5787b8a83f98ca4cb14159556d0d19ab4aac2a20e949482a324b03acdb99239d74bd75d3a2e4447f321630d813ea954d815ff0683647ada378313ba51b0255a428e409a543a5e7952f828d5fdeb5798da9d927d39140766647e072b243edc9a93fc826531d470efb21165d3b6d48edeb920d58662a1581e66742a47817b083e088cc16807f2f2b791a2b72f87c985e3327c3fd1c61199e62bcf00fdb75980b442bbadbdcc5f5bc20232e95055c11d39a107b00b03a037500610ce0b81e8e616fd0c7519d4d04ca425e95e15f81866ae90005354db2b38cda6f14a375a733a8ec3c6311fad8f2923b83c38ae470e1b582550b61728f47affaa26a5be3462b39fb49fd7531b5a3bbfddd572e167c594fa2b043a08c8579bbd9151767da905ec4441a9455c169a70dd46829014eac166d26267ddda3ebaf07d132f7e8b60cd4358572beb68aa71bbc65e6dab7c3a90340b45ac44221162350e4dd13f9eaf79aaa6f2d804a47aa363509ddd99a564dd1a1f959830a7d70d59cfde5e88bf50571fcdd21e8df311d46c10c3fc557c27392aea3ee7eee05cc001190bc6e00445aa5a6eacdb82de05d7e6563eeea03dff864cc993760b64b4c8959405d6e7b3d97a79953af433f47268ed5814a83210353c31072886b569071d9b29327ad799053dca95d175408b559175d22f6eccc37ea989356a2a22e54c607d8bec599aafa842ddb52bf69450f5c0c345cafc99e161fbb7f45b148b172e7bca50829dd142dbe7af4f8807089a414cbc11db59ca855c8013e8374f22868c57da5d1809f46f7af7e3b7af3cfb89eefd7ef48055615a6a22222f85373cf8dee4524f311f95c4946bcbf5e3b572d9bb01b15f40dee9d6c8784d2dd61c61dcac148145d453e6e5df8c5d734d496c1b394c25bcabc1d1ae3e601b12dfb3c7fd0d3fa1d9a2e7e1f514efe8d9091345b862921fd7be788a901fbfe23644b27e8b0526e91026005842013a70e4961eae40acfebb9cf26408444f1f34c96b2941635bb455dbe5288ce45aff37664f96277585922abb5552b9d15157a162cd46a1e90753c19e0aa0698896d15c5577b59323d709d688c39917d31440346762f6c9749101a92a20a6bcc54af6a3d726b4a5463de22085eec3ff25d92d18d58ff391af52e36368be68d97c4b87d972e796bbbb0922d374d38da088ab7af2cfcdb4b71859c9afe6e3b2346f4148d3b233f1fbe7a0da9e6f8f21876424a23cff3a1c8287070abd3a51cb0c18a1a22e024c2eb1d3248d9a93a467c6645e8c218cafb80c84ed04e29d8b4bf610415b7dd79d4b6637c31b97bd8106384c24290a9c530c7a84ceaa515a57712b32a6d9bff29a67a42353e556bf6b5d79cafa6b225d4b7392135eb084d1cff46bd92fee09972b396c9780b642caaaa6d3d8c52b65d06890d1d77cc7ffc3b8127236be8fd8ecaa3a7756dd597b3d0f9076bad2e60ad1dbf4d834f8d491d5c08aedcdff772a60d739a31e932b72088d241c2cc8299116d453b0bf2704e8e88322fa793ec95b49be599814578948d77d97ebf2c347ebf8b8edae3f017273a4c29adc29f70cf1b0de89289321351dce2ed0ba012bb4ba4981bcc51241755e16922e308431135a7d394b8424fde879492f6e033e12f4ae5de258e1cce4a27b1c578480befb627ea8bb6cf6e60fd77a4e8e4d73613a79e0d4d8a76e5f8e8f348bc0cd709a6a0b8d1d14e4a7a1de0d7cb39bcb441f857ffda54f8d1ec51437f2ca2e0fad47537e7df4db134e8c2d197d1f4e84b11502a81ce6b9b2744bf9bca079e02d6c2a6d79e4aab6b3f7cc9d5ede9be82e9d5d27abdbb5b9ab722beff5d1ebbfc83f59b7c55442aaba4b25a4b5e74b34f1f2d790fa7e96229f7dfb437adc6dd176eadcff35970b3485289f1e4b41cda45ecedc8b342e6f5a4e54c7b62411c2556aab28ac17a5433eab9628b8a9b1279d58d07e899663c3bc3537d880419fcae698fc17baf2cc5df1aea3dc562c58443edda8cc1364747eaec0be287694b61690e882c3c00de371395d0df86b7f65d5540763a3753ed1df61c79097b188723ad2e7b5e55dd5d1893352c7c02245548c753326197e43ebdede6f56b62a70078b7edb705527bb78d22463c56a5cac5f2c511d737143a5b4fc70521bcc300b5d1c50a7bc3b766e5628ac5452a1c2785353784e9ed781a0ac29dedf399172a59aeb9198cba79c9004515d1b3723fc544ae5c338eddb1d453060e7070a633a905c14d346a09c52a61aaebcef5bd79b21ef1e883e2989d49e193706d2a2bcde3ad2373008395a42db9e8563addd21bdd20da6c50568984aaf19aab74814966ed3414c892bc94bcdbab3a10ec92fa1550818808c76e53c336af42a7ec8671ae81df4778a218e024bdd21f1039700e628f0e86bd409d9a6f93a33abfe514f3ff2c370372405fca108e01ea437990682592363913b9cc5dc3a1c09854132dec3fa8cb270252ca09b9324d8e488dffdccb51d8827cbe6377b2af833640461f32226a1caabd555bb9d90255fc508a439224cbaae0d54213e52bd065fe3a8e064b1f9a4db50da63ea65e972a3056527b91d2d289f219afc53d8dc67ab1a7099ac5c3460a96eae1b0c43af56f94859d5471ca00aadde17680c791b18dbbba404e5446ba7215614e39ea8c865f28bfe2583bbf42e2ab1229c527728aaa1cecc7b2699142dbedcbb5c4ff42deff06340d977fefaf171066597231e9a073f31370c3e8010b428cde77b36ac258a33954b31c05f86030daeedc990e5584ce0e40b8753588a65e45573d96f99e410bda2c360c23f6be3321a463a982c002242fd96726428d2abf8e236aa479cac3ef827f2730ba01edcd4e632c42a5d81152b12645ba7d5e4b725b221fc306641657f34041ee8e4266eb1ff0b6079817644641c5fe4e9a20e9221baab2d498f0e9b9ca93f4c3ab9e4d955ed03a0df82faadedc39f1ad9f8386860d0ed845520277e569070aa201cec459153c3d40ebf5b77680048112e1f82bd56523df22605a4223f231c786823648c39317af286280c2dd0dc3289b2f0a5015781db762531431fdfe1ba31af268bfe1f2454a646bfa2f4dbed36f63db8f56e790410a70ae8ab6b8746961e7a0ec7e150e269cc342a2e065998486715ce036ea5391426b9a3fdcbcf310c5f56e875d978f547a88c1910c7bcdebb6670680a33472beea33718b9c2c5b79eaabf192f37b2d73d8a8aa6b7036854b5a44b9b572c6b4f5a9487dac0868e2e5a390854adf1b0f2f028025dc14a21c0af4181da64a128c5492904efea2ae6ba59740d36d1d78178d8e86621d3238f5f18740bb5da596ad5879ba4334181d34fd61b641695a54ead15cb7f837c70579c2ed2fdcf8ab83bd1406e490622ecc45312ee2a4f29aa13d18dfa9828b97addd5ebcd6cb3a82393ea8ec35ea73edb2be9bec2f5fda5dc5fa8b1b2256c4e04bb5e86a39e8d6da9a395dede81a50eace8d3f30d5b69643807bed0380b768c113f4997fc61389a5371de45daf59cdb6fe32a9a4ba1ce38d42a785daa14ab667773fd22d34890e73bda22053ebab93070fe803bc0dd809667f1295ee530081e209d791584e5980f0472eb085b760a788f20dae728cd88aaa4cbd380839d6b81d93341167af9c6c27ed45ac40c6429308890bbfac58654c033cbdd484150883acd81c109e021d7985dfc74f86265cc3bb8fa8803580961ccc23738dc5975560271c57e31f4cd91b08874a05378c216c778471da9440e202bbec1e7579de10a81e255178484b882b7e370e729247822f72b78abf242d2ad1dc6e44d919945524b6b4286d6e121ea3317e4b287d226e174b02d2f5619c5afd4ea52d884660fbc7942808b36fdbd388bd4dcc86d5ed1f897ec9d719292d9fca2f1039571368f6ceeb9d73628ec5e0deac851cee1d84173bec34285c24fd4b6fb2d11d4e1c04c56bfbdf4a2f9ddde0bd70f353dd9a63c61f128a88c1181ef9208bdf2bca0fd89ed6f2cf7d7e044440e75b4923a93c760e60290e7d5dc5e416aab9f6e94be35cf4c1d3537320ffa69ccde54252935b637337beabd518af940383b63855bb667e0604016f93a89b395c967f556f070474b1e7f6dbbfe124993b173ddb27affcf86518f7ebca4053d31259dd9fe46de29bb01d2880aad5c0e7eff5030e0bfb6e74c24b200810a771b1e3602f15d29067684cdec2b41af53eb7bb1c81354151eb37ff1b0911b406ec8ebf72c914a1d810e10250e7be50f642aaf47709a757bb436caed62b0ea605c6ac97e6d7e5acb229dffd9e064806898e83b594be604f2e3cdcbe2158a112deeb792583318c66dab679b63297bdeb6ae2afc12099c465b727b749e602a5c75388fa7df6f7318b4dff5d6dc9e715af2937c386e3ac72f94a37afec3653699a824f5c54206711717390e89af86e3b822af6924e1a49d97718da0ba768836cd21fb99670b89f575104212551de63df3deb39a69da8f312be4401dacd786671532c06e30b358f15a88acc1649697de59a59db307211936b5251bd9c973f489bf7ff6f1455394575806927a1f7e390f2887af96b97add8d9d86bf3d2b5ded83e96ffa8c5bc6ce2d41f739d97c337ce7ecd1279370c89b26920f96fbe58c88878cfb49995c64d6cf6ae996ab32e9f1e0e0c6fe5a31560054eeab084b715ba9a2d5e0478150f5b3f1ac0657a75a1f9dab8e623b3514b35817d874108702b1b8a6c47d726ca7faa573d754dbd8f8eb0be7e702ecd88450764597493a91264857b654cdfa71552c3fb02e65d765fbe0c67b255e59e89adc755f20695177cb3277782aa4d068e7437c88b84f89e624f0ac06230c65d3470c866393344a67e070b21c20f1eecb0703f355241a82ba3d832c15c683e2ab9ee01466286be6b01255023bf32e461676670df0c3ff71af6b69789941787ae2a50940f475110595ebc2ce0b5a695ffd3f9ffdf5a77dac27f42203dffd24b6181983211349d39f104515db7983df716c06ac6d17601d91e5e71d3a8f4e31063cacd663b6fb59833fb9b131a7683c4a3d6cd0ea8cc52eb8f0f901399a312662c63bde7cf5ad25d80bd784160ac6e60ce98966ab32f3d83caa4a9d9f66e2491f4eadba8090d63917b07945f5e10b13ec712178fddf41e6e937e65ab08d26bb107fd1ec8e0504bb3bf4111d6683187a938a2c78518936c86b3a3188781d8c66c09699b2c3aa1dd6cfab0ec806225b60cc3faa121b75dae12a742f7e8202dd2305ef3fd49bc93cfea52fd6568803de18e4b4223deb65e4b18d7cbcb9458214e94a1a904fbb59ec2a513f972c6410b16863523235679b6a9b0a98e8dcb5313822e5d9ee71a867eb9fdc8fd0a7413d5f8d6f8c64010edcb86984a60f96e33856e13a78ee3534a326621776cb6d4ed1ec71c632e4383bd2adf20f26803cb2712a52338065963ffe66124dddc9df7b6c7dcfacaf40e86d615d7327275dd2d0a9a4da711a1d1f49d90e444ae0d65170f25dd4857a035f92b86929ea7a421a35da4703bb39d221146fc72577080b5ded3f5d5176b65fe788684fb173377592e45aad70485034bfaea4aebd71ae4a181069166140094ac56519e40f953d22960fd0ee81143beb321bee93b369c2bc2aadce55f33354ffdc539321f7da5c51dfdcf015f60d2aea2e588cda6d8f89cea3e256336875a83d5004c7eabaf781b3d4bb70058278202d0fe0f6520f831fefd7bfad44f10b1b7719ff081164c6a34b5a87db6a7ebb107528976ecb6b2255b76c70a242efbd688c2cdf8421eb0540b633593051b243bc4933dab100abee68ef614b51e6aebf87864e322ac275ae46ab1386a19b96b13bc3fa6483002c8c04785e1ef8595d29840c30d35d6f0870f4b34302a0177221b0bbc04da35fe5bac66752d6a6d66a546f988c49a7872f43db4a5e279a56321413fd5732fd51d9d51f0e9c391b8099526a3dcc9c792fb60d8acec627b5dd60a55e65c710e4f0a8e6e01acb3d7404f76bc48e60759ef7cb9b9f2cff757b69cbb59521e7b1ac00ec75b6a0fac4ac25f553b3b14544fd2ec18ea2d5600bddc355aafc31073d372f1edf496109010a89552a9b421a30cf124040f25108a59f6345629790e91d9860e904bd22862f476365591adfa8a3d94e6717a445674c1d95b2b684734414865358c9b328c60a37544f85e78d612a4cfaf3e731aad7a32ca17fdfbcee0e0dad1ea5cb81b8aaf88e9193d2f47bb79480b96055a38000aa33a2b229f1548905daf35a0d5d2c55b0de6cdd26af9e36c7816da725b8a9269662be2f2f29b066e3ced4a9bb941e08d2318d8e6c080d5506ddad6ca839de096448959f33eecf62af35b9ba9b92e67e9f69bfda172e63f61a02a402772df307ba0b32550c6f2e3c8341c21d5cad3900e8d96f6b55c603c8dd300ebf917127e9db739a1afa2707d572e58d3e7568a701438b62010d78c559b6c48ab9ca14c22f465776765e149ea30ad4c31b6bafdfed6a0b7ec81ddd20d32390d92fbdb415aa6c706e9f729c8a0639c4700c75c628c2ff449b26bf0a609022d120761895955e6321ba4e64c93ad5f5ee65959891548390edf2b588713edaf0fa67214c668d2d784bd262a312912183c2a55829ef4956730d0535b47ac3c889c71e79974236bbebeb92ea88e1f6347abc1e515d6834e26bcd29e7fa55f14257d5b5279d90c8dc072642ab8db9c7fe77eadc14a9ce1baeeb6501afcad32a7f47fbd36d2d672a5601592ccd83c0916ce531126c598b09dd64bb7f3a9ba7fa867ce8aa3acf4e568168ca2b5a465d359a8efae9c4cb467b11195bb7bf21a658ded8557e34de7c6b1ada740965ac110b2ce36a083d49506b4bf283e9637bd429ab0d6f3d0064b4f9dea6c1f69b968f524da852db6947e6e3ee2d2083382068c64002a3143cb50e596c7d438b9f96f8c8bcf205ebf359705e0fbc209af019dd6e719f6230103a53d1ad32c49b87922fde2288a12033562c16f3305b29093596d0212772ceb519c6052558e187f037f0344e420f7f7a1e2609ef7fbf8db3a29b435d11d56e864ad5099f0217dabb7dd2d88b5e60bad7c2cd7e7002211077e5abf4fcfd3b0bfbbbac4acbbffa9e8d7a7117385ca4775fa51e13d1a95e7c9ca6ad7d479406a5d358d211a178d0989e73d61abb993ad54056b9e8f0b9eef9c5883e902586d231cadd30b8593138a58006ef3f36d06e227fc78a22dd7f015147655ad2211645c48de30ebfb696db0ebcd4e24a643a9f86ecbde893c4024754a41832dfc368520436e2c9395f930874500bbb70bd0fda56ec64fc70f9de9423339bf0ba81ae4774edd7ee31152a5be09f3123370ff07a2a82560eb8f410307662c26c2c2326e5a3a1a9aae6d11c09aab051e018ded2021beb6a94192b3cd49a5c952563ce37fe6bb276b849d7f71454c4e6215c785535c98d6413d2a634bfd41c5cf355f45f0c0bd2a821a7f3e4e68fdc33af771ec17382b18dbce14684f9f600005fb3d3c930eccc959c366b98f96ed545f6a00b352771c1536e28c1453af97c70173c31b78c95c2c10323d1bab7f30d38a0763e471406887a32e9d5bcab0dad78e47b330b3ef6e12288b6eb39e1cbca38594403f17e7ef283f576e742cd09a6c9d6777108cab7df91302175e87e574a6dc2fa25fe9a666820f501f6b8461a50aa1251b9cb4a53662ec6a0c8c63d652c66c737a785d1c7c1134740e3c74e3f6ff0e28ea65234b17779178f8177623e721fac7ef8fb0dffd11766288da7232420be9c5b3472f768a14d7b34db0ba0146ffc400c3d227ee47c287c9ebee6f7337316167e42fc11a25aec90178e5412b52c39c314375e3128ff90ffde58686102ec2123996fc2e1a03096d7f933e032f4b886a90b0be12e014f0131ad6a127f61af660831326d1d70fc871169fcd682a90371239d5b37457f67931edb8ea3b9a29ac70a25c2525ef48feec9f35d4e013bc5e644ebdb80c0acdae8359ec2443fe0f7ebc96b8969782e4033da411539332ee5d831a9d3a88f8feda1ae7334cee6a00536903adbeca114d920019fe8492cf28a50ddaed757d88a0d6b61d419e9f8bd3222eb437f175377ab246bdc34b439a68b9e21abf6f79bd65c941e5715a3effb619b1453fb604f924772a4698578ac25c53336400115d2c087c5ecc020e8e2fd8d14cc95dcbc296ff6343f37fad972de3d889cd69678a3964cb16c15878545f170ffb05894895a0d1e0e40919c14a0e2cbbf761619e73a37ae35240b6bb50b21db038210b7c21de72a6dcd5e46c4b2cf4c5f346944709f64172d72b8cb60de567033c5764bdc12d8dcb1dd4175a0c228bb757aec46067cf1e8dd4711581e36614dc018e8a65171732cba711e933ddf8310b97b9dfeab325b457ef6d8cb833c7450e5e88847fff4b42f51a27d7a22948a878ed0db66931daedd57f1369830a464c903a58afd9c99aa3c5eb81579b123b4140f6377a3f1e00c7c13a051e69ea947995db5501369385929a944e16a14fe7baabd3dafe830bd6043b6bd598cf4044b4a7eb95520f939c45a9fc630806af246ac8b6f21e1c531c79cd455780911907353d124873eaf283194922275fd43c34a6375c64dacd3c6811da86dd6d7df9a93fee805148726a53116a261582428012937173ce1ffa6b02d48559497540184722470ae618bc0325d447e6235e286dfd4923b00170822567d74e5743f4ac8f5bfc5e24ea2bff12dc888c8adfea8de2d0991d919bbe90b5273548a91e93a2f44aacdff53ff146de9d68302115384d37cd55a188da49beeebdcb420779fd8da4fa50692e27911ef0710d06813cb7a05b364676397033c2e12a96061b0d0b0ca5fad7b590bbea3791c60fa78a1ca86a0108e7a75f4be6b240202fc8f57d444168d0ba9fb0fe4c7a13e559b2b8e03ff86e81d8b389f81826136f012e01e7f1133aa65192ead88310be4e02b17a349745c38b2a65f861eb857cebbe0317d6d2e4a73c6cbfa347b28e58c82a5625486c5bbf1e328e40b3c6738f710be3c609acd6dd1e4e840f78a2ce1dda63ac5a879ba8d5a1ab304b0b70afa11b1a064be5db427b886baf2bcebc12e9e46a19268caad383aae5a2cbbbb555f1005f9e6d4c112fa5cf2cf96c3c6a10f0569a197d33148d1306b3ee80978911acadcc2fa13c3b21635039f5002f324b726eeaf5f506de649471106f194a40f41345fe6e0a49070cb44f6105a78099eb6ebdabcbac57818981131e8bf411d94a12025be59b746bf99842c34905d5d380509748cbc6747affab54c2714e238c7172ab234dc349bbc562a99684263d72dbdb6a47e57341485e9f434327c6ae3cae98241387449194192587377b572908dc8e41e31af85822b7178793ad7133b756d74923eb35b52dc90a053518a06b524a14fed4e3c403cd617a1844c1496cebc3edcea695517b71868fe8ef5fc9df867132a77570c2d678f466f65e8019f42f18a714e1f142e9b5b5d69278674f877946e049c0e2745322f44e8fa843093330750b061feb907d948aa096297028d4253d464e8affb86fe14a2198537f5258ba21de22cbe86d9e8ce8e1d8275d9c9de3f2a9911d0065482cff71c5ae12d0c15a828e63ff9fb929fd9da01ccb155462976bee084c7cf68e1838d796dab33dae2eda30865cea46619abdd8c8841f58a6cc03d144bb99a3ce7a23211fd8ca04b7305d0bfffaf1066c3389a0bccec4dac60de26ee527ab5457c390f9537bf3c0da4b3bc3f7e781f9351c55595b699c2de9b2c95d8bdebbddf607a068cc505617172e345995f43b4e407ff3d2a170c7b7ea39eb7796ba54aa0d0732b56a09ed7fc162fe734d39ac59231ed17b1ad5506521d60740fb4e56196f4e47876be6be82ffaef334858543df5774a38f4737fde01d49a3eb714e7d1d33768d2467dfdf75797ab7b6335471964c27003329b7aee7580fb0fc9a72d15a158f8c476ae7bfbe2707f37f6141ef2dd4a500f2ee52ac6a68e4b877b10a6cfe127a373787272ec87e47cb08d97ea95ab47d0ec219feef0ae36988568245bcb88c4ee325b354b150aeee0429fb1f03aae68c52ab590e485ac4076e8110fa9db2a2cb66352c7eaa98a1cfe31013bb0e990af3e2904b81b2a6f47a785718c0358d87210ae544d9e7f6c8159e8e673e2e92a2cd10ffe497f59c869761637c604a1294aab7a591301d676eb0d8b37c537ffcdffb2ffde65dc85e06acb158bbec0998e5c3ff704d43e39c10aef75478bd903084b67343efc4153260fb31c5b976aa9dd36bb7fe4842cf325fa13ab8c9800a8db449ab40fcc4ea0bae08f22a38741f0e804c1756b85f7d6b41d4443ecbb5bcc884c0098ebf7ffe3816a9303b5026799488b57d536dae0364a93376fc2956449d314167312046971d90c2fa9903e7fac0ddb3fe9839df3596648afd6c5e952fc74fb7192c1769b16ddba8df5c31679d0c56c5dc31ae6a8f954921a6302e8cc47251ce3cb1e5302f07abca1760ec996e0b07e009b85715bf572ba8f865ed6785bcf83176e477e1d2441b3dfaefd62b64bb4a299960187fa5131b15c526271a2d1b15cf409d6a006140af9b83a7eee878187f886d5e4b5af9e19b03ddb6203b14a8e63ed0264e228b0f0617bca9314baa8e40ef2a4acc65b0f45f0d630234ebd8a6e351d6513d45bcf281dd79aadd2e705fa84a9e70c034830df245e59f70c60fb9bf8860305023f18120ca4d7bf29b3c65fe863aeac70aafb2d25dac24dd89a21c5c5c1dd7555b6be055e9b40389cdba4acdc4761081aa58d3a94ace35b8726133286b8e337ef585891faed84f62c627c9e1c46298432946d20fd28f4c49f9a1bacbf6946a72fd084391803fe54432e02e56b0025720a5193c23b8e91d1f2f7bffc83b5526f7fd022af1a128ff3fc1b6ebe87d99f0f000556f9add12282ac871053a98bc92736aa620af7de698fcf751061cadd226da303ab838f9517b5c9ed858d5ea802ceca8833ca47a76a65fdca53ea54445ddb4206299683e9a8298c2d31c0cc5cd1ccdf0bbbd5a359885571dd0804ab8be077522cb708fc32e1759f57ceb101e0af0dcaa238aef7431406c22b0ee087bf54183e6c74084f398f6b244b1572ec73ff00b6bd16a221366da3a6fcc37d2100d69d903cea61a1d59eb85a4c5a7f32d6c7a9410b01336730a04585e51ec274fe05c01dc23f0b76cc248834cc74d8da7ec842216b5e0a9c0d249fb62dd4c48849ee5077c24de3c04b5e51d71e465252365457d0919411afd4d385fe6eaa48038612f75280f5dd874bca21892a578578ab370d2068fd6ad54a63d9022fde0f8b62c004732a8189d0c34bdd8f5c2af9f18cffa04ee31b01ca28c45745bf79a1c268e3b5e539531ca6f55ee017b8e4140831677a7a6f91c98d714fa6c0f345fd29a7b35f40c504f8e00ac6118c28a61aff705f7263928d33d7130b453b22a7bf43256d7d07797533b70cd711fb60c33da344bb80f40eccf3762220342b9edaac99fa27b30dba94283b3ea5f2394bdf6406a489fcb127e24a5f8af80b03febf52531d5baa7094f76275b06204fae2d6d58a2966f76a4b6a2bc73403d0e7a1c18aa3e293430a5c65d4886851b0b352cfc36add607ecfb1421cb131c9d4a91405ec71c415ef1e652c33231de1ad77a729b10bd77f5238ec8477f0cf07678f844510c829becb794258d77aefe691ec2c6521a941beed9822de5fd5358722fb98ecfd723633765d3f9313b77c1742beaa9f566c28bfece91b8b0e0ab421a442cd7c9d6a7097fef849f2ca8084fd2c923ca6b6b9b95f4ad41904690e5229c392c3269c090fa6ac050592b167bf7b2dd52bb6126b739065a83e8fe8176768d9fed10ab6318f0bea242e4338a4a5112655594c85d1fdf60dbc6b96876310f8d7bbcd5bad413e13adaba9062cc00a22abd3439ffdb18e15cb506ba0fc63e4f08c782c4108cdf953054e21ec961bc49e4174718a92d85a7658cb31d943880075ce096387bf53218e4241ca97fd33e35990c1d7c5faf90cd3475701a5b165fe87b9c83269fe09e3d56d1459e6ecc5e60294d490a0c46c8108c28658eea557d8fb914ce50adb3291a1e115d62897367608c4b8473950b28d9d2798772a6d1c2d0aade9409424cd2aaa13de93b89d13df7fea83ab313dc96f24187babf789450d4116270d271a99f70b01464436c24a3e2a8a9c2def2716dea9171b94b421b81c339cd9b98290680b3591e57753117b91146e1a37993ee09553df338e0e8a21dceb4d36a4aea101a3438f842d0a378014ec2144f4f98b7ee2f56a8b6d19768731d348f45da08f661cce877f66e5baa2892118921a8e3f9f055fadca054f1056e157b95091259273f930ad0735a336ea527958d035c98ab6aacdf89f874cdd2380d3e84f2c413a09921d9e2b072f81c31ec4a86773d503f2967cc5e9409d57611641f51e16056b00b19007e0cfe555be4b1be6a64e1f82e1a87dad2f367edc9b85734fdc141a014cb385ef3678b81a211681901168e5aed0cf9f826beaa01bc6d74a659d0fa38aea1e79990a78860a662829ec96dce6fede50c8294887568be1999b6dfd9e783091c4b9d0256d63d61d6aec81df961fd1a98a1863c313ecc8ee567b0d95b8afa806bdf6272aa41a2cdbe6a181363cc124fd67a978ad3fb7acc63ee42368d1dbf664828088a7718efcf4cddd6c64c0e0cb1c09debaaa6b5c15bde8bb27b661da0c6275b8a4885a251fba7db6f837725f5a045b0a87ed2bcd92fcaa62587632b8a4c3a5c652d99727695a9c2972dee3d89399626c81152299555abc699be22228d1b4c13076161836bdf7bac00a220e0a004aaae0a75b62bd5be3f3d9a61f5265324b61f7b93fcb86f53cc2ec1c8e051695142c660ef1fc7a6aa6a80ba0cc3d72e868ee890c1ef771a9f3c00b21db531c412c3efcd0e265b1d6b0731a26fd0307b3f6fc1e3c3c302cfb715b5407a41c0bd23b4732b45abf54fac0f9dfdcffdbdf6b4cb876fbd67ae681868e8c6dd6f6582674b85537556ab4138b3b5de63eaf0f3ca68191c16e90ff67318a1aa5d3ec7dfe26fab3affbe57caba44a6353cdce0f17b1303431b7dbd4bf03d6da39e3939f2332666cd0df124a402f53580b2220aad06793e10b0029a8bb3007d90a60958e790fff32d23f73f5eb8f65f3b244dddfe4ec325b15b3ff662dc4baee1d1b1f0854dd71a4e682f2f67379d599c3ee5bf98867363985b97ce92ed12fc88cf4977380f259f7908aa81603dd2f1eecf7bcf4b85c9199f7855105923b89a1ddb3430775ba79ec7dd5b3c652fa1f700c6bc34478fc96a986c39f8c2f4e00643b509829da69606de4bb237a225088131b1c542827427a2ef7d61552dd73c6a949e1a52450ca23ee7b67472bc3330013067fef9572ad315da4701efd3550b16e3cbab1b74cf85a7186c2ca4f3f410034e2e61b7ce9d5e57469f2b30945a58197290a8e716c21a543ccabfa5ea1f0cf4e9fc21ee8f29d58df35ec95b493666c44e21a53270665b276053dd3489e293f3ff23be5e29dde21493ebe463f615a31463c7de0a6dcebaea98e14c937fb3f4d935420164d56bb4e4a696d79bfd8b312435f6496ff89b43ad2092dc83e2bb8d5ecaadfb3d9ff434dbc3f3f7f7ba036d0241f81fd0cfa663fce834b8cbc87b815eeb34a6c9769fc56519fae6b6f5bbc8b5dd4a9e91db76d412d573ce4b4cb7c0555464bde9d6fae3dc0b08988b18b602d67d71a94d7ab2756af0c3cb2e15467c15353427d6619d9715d384e98ddbdf3c0190cb83e628298670f77a5ca0c923c68a353db6d3a2418c18f240a13056328e0f9e3831380f20205220057f42fe2678a93f62306d860eba3951f51689b49c27b45ba6f1e48d76e3cef76bcde8ca7489b5fd8ad7f15582df8d1863bcd3f137f7d7a6a68a46f6d47711ea4cf61810c65c57a8b1c826543d2f115f4ee53088db24aed82171eabaf22f6253b87fbdf6126315f6b15bd6f4d0946ff5f2ee4e18a39d4af61dc6300b2c5d3385df61658a2c665638f3afb609590ff4509fdb60d546546fed39c6d65edf4e15b87a591c4de08b37c39d8169c551e9d3419f0854d021d3b3d5dea642131afa9780a1a70ff603cc59586df805331d9bf3e4c5c38f58aee45c95913d2b8ba4d4cb33e87ce973f6f72693a380f027a708f84dc283a5947d5e2c4a3370e34416c07a39263007ef267f6204f5b2d3cd247a1136293503956b1b50f851ca68b83ab9c85abc1222b22f224a4dd65fde540c925d8ba7ab0a4d0a733d8077344f57ebcddf5c90c8f6b1a4a4c9a575659c548ca73764f7fd0d988044ff6a694ec9128809c9f815099ac981e153e7a3eabef3d5ff9de83ca57137a85551334be99eb6f4f4075e1ee6a50a20b9de5e9ab99d856991034417e3d41cc2a128dab65f0dff71d8afad9d0e73b611f8b043a52a0ed6faaa491fab1b193ce93a81db743b297e55a7eee70bbe3e4e9b287f923b1ec6ae42df528a046e9ec1d7fe1c051529ae0ecaa8305992ace9bf2d3df37c572cf2f4f0feea998825679a437dd0d4c229d7cfc633492e2a530e2dbab4dce0625b9b0a30fcbd1ea1cef6fc2f466396be33c3736091fd2e2ba43eb61d5d9fd44abb361b3a911995cbca014a45b1ae46b1f904ed05866b98ca606a2c4ad251f3a06be8f2840e1d1dc32dbf8ce4bae1c599ebe08ebcdc5e0af0ab6b90b276a162cd02cf51dab89ce25d8747bb8b74256bd72aeb975c8f3fe3a4116f04f8b8e497f5b3be43a2e60986eb41f2c1c84b2f3af309af170fc9e691d7ccd05dda49d5a34b33810e592735128da00286fb3dc3bfc5cdc9eaee555643681bb5fa602a772fc8139c05cb86c778433a45090dfde42915bc836fd3151acca21e2d51fc099bb3127e43c9f36bee8575cb0f578207405c009f57bef6b1795dad917d9368d878a56fd6b10aef0196c44f3867827cbcca6430a6be5edb723d34dbb11e9a37f703c22a94bf05807e7e8b07f87030e21f00913b077830b7f4e96eeb4c24eaee85c5adc755cadba87d0098a96f39d44f1a79fe63ebde8c9c6666edebe5f9b64c534e3343e6e7959b5f992ff729224e847d8ccfa918ec7492599500448139ccb0dd33ee9115147488fd4ec4115be083d157a8b7d97535b23819147da3931046c8cdc851b7e1452cd4cfee4fe166e5aefb8a20fb3ad0e0b039ad1f1ef1ab0970c484534eaa187c021105dcb79e87fd439b188b77b59e4cffb3a0bd5ca4f640ecbebf8ff86ae4da3a22eb5a13415e8072bd2db601505cbe3bf9e0c655b21bdf226bad267dd879dbcce793b0f92f45882b29b3ad8f05c03858e7edc6e3da3e8bf8772cecdc39370b936f00480c594ec6df2ba773fb4204faf1d64c804aacbefa26eafee50c3b0d117e900b4eeabe64bbda298df7bffecc79343f3974ad8dcb4a25f23a4347f7c57362993e9a9f05b405531a922bed40364e002f6f63b99f6c2205cefd9e819d4dca0bc8c1eb18f514b293e93f89439d71552f29e8484d65b01e44ef849daea1773d1a4f708969d1a9e50f55594726eb7001d5db4e88a5c67c60972603486d51927c5efd3db9ac89ea85f587d597e47c55c2e6aa4071f5565bcc9e5691ae1b361e62ac261aa34c0df847a8b1ce57fbbdff9b46a348a700b72286131822e28826ef475d9008048a8fc45240f82f78c6f92e2c5f60ec3dc8f537a6d732c62901e49eddb353e4123870c714935866562d3315998a82ecbff76d21e018d8b085c228942ca0b537e51add1295dbe21d12a00f4c785e0c06e3df5c1fff089dc0e52702cbec0a26ac1dbeec0ce96a5c2af1c42c57f0aa3bc3f30197a1714791b1c1ac3505a1e75b311b73204ecb20d8afcdd82680d2b3c664b6a1e5fbf8dc829be3888e5bd0422727c1513ee4775357d03f3a917bd7308f966dfa8ae6e597973ccc8f232b5c0829259d6f0d3ebcf62327ca9f16950c975bb67efcd2360db004a6df9eb0a69b9cc4fff5ab6e58d13846e89f560bf6249372e8634883b68930df77dcb3e60dc23ac4267e379bf5ee93eb502ac0163a7b1a469761e81fb0835b42753f193859c7bd62aa6eb5d2c63d0466363281526a31ac6a95c84634111561506171b670b69e3aa001cd251f3549962f4603aa12b3e6ae5503eeeee61e092de77c0f2d956eb9b4ff6d6ac5c6f7a78b05ea5c117fc092e9dc78b72504bde77b99538a89ed4715550148ba5f387ed044a9fae93f70ef9fc294f7d48f2590bb535738931e5ad93bf50b1c4d6cdbd8db4aba1d86f6f23abbf36a650cfe7f7fcb8666fe8a21e2b9f4f27f9d65a9553dc1b488f32b41b14d4594a7a42d5679bf1e84bf64687ccf2823fb27303cac234108d0c34708b6a836de09950ff007660f520fd722995546f886edc3d1d2cd8973de594c5df90ec68f4f26d7a836aa7bd3218b0e6e7e2fe44351fbb616f07e10a98564590aa1425e74f7dbe55786abadee53b9423ba0ade19e3b97d83df68a7d9f25b59d58c0e83930f42da3d43901ac11abe7f5b73533be1b26752be83d543e76fc8fedcf16cdbe6396d183d632c651908e380fadedf02d020c8c7a9d8d11b632b9b1d33feb1c05f09e671c7d259dba9bef288c459bb7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
