<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c5cf347d967e20546483139b52ff9d57b2269e52dd01a35620de16df2188e3b7a80088f77e54fd6e6cdf0387df4c5d1380f9ee826f94e4224c1783457407d4a13aacc46ebd4ab1ad01efd0bccc10999b70bae9546931fcf52b646c96ebe26ff7e040a2940571cf170ddba89346a5e0efe3df76fa26ce7920c17ab0487424df4afc5398e1164a879882927c9722a58c9d18d1b1eb40cd87307da6d9bbe39ce897208a5870d571b1ab40a59c23438ce6fbc600224ff6e19babc2ccf27d742f67262610e6ea9131cd5fa165c73a6c2153fa792463d3fe4096e750de8c204159f2ced7f2f9c9780ed7916dadb90b43ca215b3374a8c3e89af5c52f3d4e5ce65f6d705e3a3e8dbbe267274953625681edfc903072e6aa6091dd857746a1296ed508cf2d3694d027ab182213d91f07f484c92f964b9cda83138b48019afc4b6b0907208ddabd99c9fc4e1c217808cfd37b0792c0bba93d5faaedbc208d57342b766b6bba57713ee03e7384a91cfe8c4d34bc836f763abb299672c6f8e38a90751edc389e2e98a015ad5950c5109c6ef404b9a653c53370650643b0a9b416e21b49426257793757a5a677da4df34e246e949b94eeb8f81f46f1f02340c68719a77b233ef8bd815e762376ac906540d4790981e01804932623a26874ad7e6cd47d028b45405443e96b84be34f7b603302ed14adac3a49c8b85adb723b748cef89a57e426f9403d6d30cc584a75efcd52e36336c702d47caee94488e69087060f8adc24b0e30562804a4d1353a43c16622cd437f0a24cfc97107ed99e7ccd2248cb90c1f094917043fbf4ff7598be3c85c7a20d339286b7555f72371e06d14a832fe02bf3facaf20ff0daa0520345c5865ccae4383cc0f73c17ff2c26a6af0d1027382f947f48d4bb39ee290d6f404a3c1b1399aebc31e0cbfca1276ceb7a13630aa238c1a6c6d510b841f003c48c2fef7a7999fde50648c105e721b35789c80c3cf19b08706c3154bab922bd03bee38d192a4eadce57b4a81ea7723c8f7738af7a6fe3fce9c0968b51a5086428df4b714c323412d9c5682570188e46aee31124851cdb923dc12303f883b24b0b1b6eac829a7062e9b444a7948b77bd9627c313c44a25f5b5dda11e88f75558028c626d15c611736fc09fce48d287620f413b1c00cd249f97403a0fa164e1573b91d31abd54ddddcc23a5dc9a372cf65fb329d40fb3a3ecd3a1b6f59108e475d8ebcdae1140671a2167dcba064cc66ce9236fdfd1b4a3a575a3ad73c3f6a400bd229e1dc7360cfa12bf2a4c72a7a28c8ddaf0a8b862a13134a4b9c5df77273fe0bd243efd15730e6bf0ba48b928014deba13025f441e469ac5001995481d1dcf1eba7ec5782ed8141d85707097a6278cfd41e442444f7e56b04c75c25f690d8e99538eb7410131e8428e161016ab432c841ce8bf80ee58d733f0b8e845c944c1485d564fb9752eceed1fc9ef62dba446a2ff49c4c88990ffa4e65b55d671dcb36e60c386d1b82333743e1e946f6d9c72f4f5c5e4e34d6ba2e8bdb6c8a2ae182d4f0982b40ec3d29a3ad04d0a667bdb1aaa5b7e50dd932ef91a5f0f218b2a5a73d75a171a8773348cf49f969e681a36d7d33d292c46723e3332989c5629f6130cae1882eae204c2db5b6ff27caf0455ca6c8dce705238b0b728c575aeaa88dd4a1c43da52ea0780956ed410bbc6f065ace16eb674b4998185aa57ed2d4af52cbe51eaf6bf21e9ff93c1484d9c0f1533561cde64cba2393c88c60a5769c12d4c4a0f01bacb46a8e1a1d0c8be081b69059f5cfe9d514333060fe0781d878bc5e454cbc1ae25ab0380b50d1a0e9fb11ad1c0a70d3e09b1344edd9a0d93c01068050177bffa4e4d9866dafe8c34c2dfbeacb6065f8fac1f10bc33bb0554039e0b353979d29caf31e46ef31bf32dfae466f214d3ae9cc140d11bf62460b3298afbc2a93a4346db30ab853a2ca8fb169e96c6a04d84ba83259de5069b9d1cb5befe136e49e28a687ffca98382db4fa7885595fa83ec439e45bd169bdcee15e0a008e341d692776ebd16115572d3897be218d4a3c8e7f259fa2eb513a75f4cbd3b56113977ff9e27de7d71fd7ec55840138cd81eb1956793bb1d00326f18dbee76ef3a78741ded20b6269637df6b890ff7988a017ab3b98d48e03326081408aafb2d6f5ff5d2eea25655adac67ec797dca2f52dcbf1eabd724fd93566e28c28de78b134798446ca25aca7d9b262de99e15833fb566566ddcea9e734b160f3bd2e4992b1fb6a63e973111ad619efcbedec7655d0e8746e222fb229a8127321ffe13749f507d7316d1c1c866b6ab0b715b00917df6d399df479015e5f64c5b59f1c1e824bf7d74423831a4bea0b973c05bd050e56f7cfa2dac52ce5c1f7aa571022806c4d62069a7b8095e216eef6b081885d5b34a16c683c3dce60db33af977ded7095dfd5dd5a550b6068cd94beb0922089390c6138929b06316b5ceac582560ecd71a7006609abb826a571d8f850ad3c671598d93431dd244e357537504d2ad85bff10f7e814ef649c166c5c0b8e761f94268c5f7828e621149eb8147882c2bde39c5b985041c6f68c48012c142c2a5ce0582394a1d878e3a27b02296ba9c095a7e7691b6534fce833c47fdfee3c5003dea416ae4f1e1f94fa0aa1401e5485c773275003c7c2486d657a8a975639bb044e377580bb444e0fe15f58c12cae5d1e5db8dad086b3cc7f4960d9e84f545311366bc61c1a1bfe4a1b4c10f53e00b2b088b6259257096cb89810b76919d3f9631478044e536c197bb686f0b767b4d3b629a39dba986e3d701ce23d7852a6cbb93e2533991d00045317323630a4fa83b775e7f43abed006ada748a95bc7da3698a87163578d104a51c95ad0d0ca3c4b131d366e337208198683b84b54677e6cf151822a03768a9c586a9f4eeb200fd4e6150df16b31516d9c390d56527516492da5514f9d6a6dd03ec455dca28c62b9f9ac9cda421b38d525cd1a3398c266c07718c7ebf2a29faf98fad47171de3656923d13e525e4d4df34a7526f88261cdf69115925833f4f64e64f0e32fc912f4a4bdc7f657eeaa2c236b2e337619271d5099509bbbf33f74095e0fa95145bf0ff6a6a01c89bed5320882a6d3c77752bb1ed3c1e38fc76dc6c03bde818b7045d1d55b467ba4680b667d8cdbcfe9a8b111f669314a64a1ad628c6a3bbedd6af1d71161762d18fbdcfa0d95e7bbdf92c5aec874f0205eff27be2fb6aea927a5bf058cd0ddc2d15fac916c52e6d8deb1ffa22bec08ad52325b97acc2f27a0cdbb3258001656fcc48f7300ae8f953b58bf72e882f0f67ca7d12399bfefcaf44d40112b01037471d81f1dfa74a56a0286d1c785df2cdb18aeb0d7bf93c93e50a7911f15dee1b26dfe39fb9396036a95e341bad50d1e16d4eef551b8f27b730265d8833c2cb80f50341341bdb236d03720cb4857d7ad5cf57a970fcc3c6537026d1bdb88bdf8a67d21e7bd62cd25819e27102a3c89e850acaef41705a08af45706850fae5392397a094e380b145bb36866c304f19a62a31e9a4bd1c85718ed5b16d8488bee54a010d0b9607cacb93b6e2c124e30700c6b5fc766308aaf247a71bb44dfbe5dded89be377cdeb09290d8487f7cbbf2d5b38e778c88ecd5f02b161ab0e504339946d977ae999b2014b1f53729499cb48e63250a620e9becebb6662cdebffa4f5f28be11d4e360c635a5c06e47836e4568d1b6256a77c933d4c1c476b4837b6aa0825a2385b17d1e47d7025cfb27950108968b86011057c49279c23f6a341ca332c36a05938c450daebafa1581c5551d9308aae6be5d3c3a2de58248b14e4174b809e3a0fc641eec15a22fab090d40facaa755f5e94934f03de2848fe39c4e5ca367e893d25179d8042d7a5d7d662146cbbe9e2ff801e2d741f1e76b6a7cce06a5fb25553653e2714cb75c3f1c2c8ab18dd3940e7416e6669ccd965998159203b9dec548756d151de9dd83eee19d1bef2fb28167a9a6a7f0f3cbc93e80d8957ebce7915b3c6137a33cfd69509f9f72667be82062c4e5e387ab8d775da06c2793006fee13894490ee4d454a669f6ad34448bbd4abad1c13cc2f34b70be36dd47880d77e691466045392653f003a76a351801f61def8aef1bd698f9f9fc76cc6e76611c8c828c9a3adf14c320177e8406e62f29fc58c105c92b8fbe73fd39ec2bb39a266d9c16e626adc657ad1070961d38d336a214ff3b9b897c336dc22c145ba7ccc4e919cf4a81319187632e67e78673c55809aba4e0f7a61b065fa03253dafc3c6c849d930a6e5627a41c07555d20aa492935732d54674bbe5c4cee6e3d885481a99377cd74f46e770bbc8148ae77f0673b9e1b85eb4177f210ecc6aba7a6b7153a6509b52af471c93c36916bfba21305d26620f40beadecebf9a792aa68c8ad9846c5af10f3d4f67c2c535bdefc84a13c09467f93d2aca21f222c05d096620bf4cd15599f2e360b80dcbfa05a7713bc856a6ccb06a1cc75c019bc78d4bc310e23848ca3128573775e24e10c3e954c21d633ee2cf6d206d26ea95b82df54076752ae7afc3d2e063ca793d07a4402118102df656f34ad19dbe5dcaed0c6125fe5f78c023e8532549ad3df6a7d5d95ec14ec0dc7304478d32f7ee4f0bb6ad029c98380d7a71cc57509f9c9b0d9a922c80cafcfd652bc8e322ced5bf8447ea3a3e6bb67c970885dbea0d3c861f84b2d1420498b57cc0a9361fdc6c0bdd0afec96a4d9efa749536b2a0940cd9e552a8b5e7af695779eccfaf0ba43893c26f42831f505486d03217e5b5b7ce58fa2dc17d60a0cfc1c997cd4397d2cfea9fbda51faed0c3f3c3143c9f470bce7949182f260b1b62ca721dd06e705ed3e43300a9f97dab006fa4df1c7164ad48cfa9568476ac83f1ab888f8b2af266c2fc24e10c5e771adb600d26bb9265690c30931a832cfcb4a630f6f14386b326b5936c7ca74d63fa54a692447af1bc2af61ec1da3749bd16433d65a9ed18077e52fd8a51ef51cf8614ad609e0303d271540240f43c6128c444d3a6131d02823385024c4cf3248817f9a591c0b09bddae43ec923be01b5f228dcbf5a7f85541c311e3378de3c8fd9a07102fc1131e67adaebc5bd0efa52a877cc5b0b4114675c3ed6ee31c407c5513d5e988e205860fef594e68303654a2d4c3735228667c2bd7fde86f44235375ed06bf502b601267a87a8d3fc80ca7c2d66b3abe07fbb18cfb2ed0dcb6556a879bcee028db26dcbee187ce7b8db8e2acd6a35fe53584115486e5ab5f0adefbb4feb0f92da8b0cf817364411b60e5a0b2c4836b85a2c0a2c64778cdc3d7dfd4cf9ec52e4da26b64128e837c231f11799429d3081332eac60f7aad6ed4020c83533bbd559a6e8c2d7faec10dd63c8b94417ae8a5941b33fe03eb1ce74bb94ec7b56d74f3bc112e0ec8c58b953096eff530e4b9fb3988d276fd14368ea403701349d823f350c1f5052e680a461dc3b83df53a2f2609a6325d46291139521fe52dff35d018f2fc22ee54c323ae9b80a0f27d9bdedd72b9087d8fcdbf275b2b1ea0970e7b2f6c33b81432f3f9b9fa3b2dff406d768502e75dfe33edd4fea3c959e2bb78b6cc689526f271569bd96832e5b728e60ae09c7c9c138a5c57e2fe8d88ec398635c145b61e14fb2fe5f1c5c31a36d1073c5f2b288bd13ff16c9e398c6079107b80f58626119b790948a8fe79d2df9a35efe4657c8b2b7f6983db33e1a42b3d1ddae763eefbbfbc2acc82fa279ae64aa6232a55c3f06dafd8e395384e535e6178dfec8b94a8ed40303d20218d2905748270cf2bb58d3524d0ec22f4eab6cda6033f16a798d913609c2a741264adc15470ee8b3e1faefc47e199dfaaee0623f2c5951c211578d205e85b204a2388f27e6af62e9c9e2dbdbd038348a93373a78b828087d10cdeb25a700479f559e1bbd3cccafd06f08896fc284c643c87dacc2b305b656c5ce33f30219832c36d44d5e6c8be8dbc4be193c37b094dc4527857e142188358ba285bddd9f2d2e1556ade9657a62f69f4983f734af07f736bd3ac12a957f7a47ac347b940e3ef3bc39df588256b6d828574a263fdf39cd163bcfbc91123b2c202cead67f293116c7c6e78aa04d10e9a6f58f107cf2d7aaf22bd30360059ae4128f59f2bc709ae9eefbdf6668f12765e44c79bd97fc5e0956a2e4933b0f4ddc4b9e2acc2ba3db071ba5a559bda0e6d04cecec171f7bdac81f12dfd51ef8cc2506d126608ba5d2e4176f5efeb2bea278776de55d4cc623c2b482b25886e05fbfa52c50b1e1011a50475d63fe9f3a268c7844fae80780e2e8239ad8ab2f04329fff968c8bd823f1ef5f0b584966cdab2b8ff9c54fb1efc23f50da4c57b410dae9aa74d603c466976a56035e74e0dd3180a8b1ca02dc2081c28faa6185936c678a2363deb497957f2587538aefad251f19aff10f5e6effc036d2afa762550302da927630a63dddffb04e0ec03975e5cf454110757e86a0172e2438a3ebbafc42fdf2267d8051bb5a055f437db5af2bf66c0c2577f10a824e5187e3654f71e90135d1b537a99b5b7a6b2c5dfc5ff0c6bee7c299a00c088c221c2670f58d82309b08f7f6ed63eedaf102f899d9155e07a1c9cdc30fb5c2cd71406b283a15c8368b81f03539d8670a88c0e7970952e2b555fe4523206c149e1f11832a35102680b11f43d07b925a3d279e508e310f0e13e0e5c9c38507dc1e6f6dfdc740cd104c68c68d1ed52772ccbcffa372027f83dc29d6678ac2bc62108357d5b5f2efe109f50a999073101f710b038a3ccb0a6de81f7947dd3b8571c1d4695df6553d8e2a181c0ea1ad2c5ff25b473b80871e681c9314d6365bb934bb133018874fb475c7270d4000821108357ce1d5d6a70e7811b9a828074b60591c727113a99c345bc0564dfb36b8115015a1a022b6ac8a6edbcb0d6e6c54bd227aa430fa8c41e36c1d7f45d22386380ea08c406f0785aae5707394ee2b4443744ab847285e910ae1707182c7377412ba1025267cf969d04f3723fee53876b86847c8ee669aa4f2061ec50d7d221def6e63b7b5704ab930b4980484e73aca7ac2daf0a78c21db4d334fd58286bf2bfc6af1d58748cc9c42888c1f80c64c1c5f306ad93298de5b9dc0e1e23af588664405152965f294f8d04f823d20801bddf285197dc0e3a98415dd1ace5cb08b3072ccb78055e9a28beb6a4d3f52e970ba23aa78ed1461d58bcc1b8ce4288b25446f5d2c00ba64db9ada53726c51b25d0c3465bb78171af29bd2be044f181b64e77673865574d595436eed81e04a99c4ff4dc96603ec73f45febd3c965443b4c58a73fc4b493359eed40bf42da34c8b84d56c5a803c46eaa0c03cf8f9f699dbd02250c78687b0dd4b3715642d5d00375110b9c96cec2579f0080a04730b69bfbb0663459aa72f851543407aff5348088df558b21b24a97c369e8e655c8c2cd4e4652912b18e05efa752422e2ac83d143aff5f87744c64b428d63eb7a6a7309b0cbf9bfba94a0d2a808ba4e8002ddd6b6190df03a7bb1359b0c2e8b9c796a9c57b5ee5b5a908c90cb25ad7ce57b15189cda840adb8fcabae1a6c398b475b88bfd09c9ed7642011215f4472896e2384b71497341e7d62b06a81f044d6b8f28f3d1c544991db8ff3edb57382a5d3fe9907accc1e5f272048ac63aa54b2b433a988d24ed028ac9a6e51f6b453cf7797b2fea43526140576d22163628c6513851075b22763fbcb88447680dcee2a967a5e669f03006d22a3618bee7b8d54c5da43621d0ba9d38c3e8c29f85cd6f9af97308c1a9b132f173e653cb5ac952b10fb7795dcd87d5a7c6224d3c996fcaab07e3f82f5bf483b0293c3d6ea7e7304c2007fa47b9dd02c30089fde5e3ccb05d4d15374a7af8e7762b969ab114b7817757677d68b84e129f1abc977b180866fb2980ba7d31e2c3d95ecafbf4a699dc86433a5cf2e28c365ce4f384500160f4489e5d39a5f7a03542e8e93ad9e79be385dc577099250d48d1aa309a9b2b84ffae84c735cfce6a3f6cb7722f93ab9a9a230bc17eac7a57710229e089f4052187fe86be61121e9c4ada921558a0215f588c25108671b70842764674bf721af08309dac2b47e79d66c1b6f30e38f80b0e27744cba5e4f9b74f819b866cd0d679a4040ff22cea898ca9265c3fb277be00efb9187e52bc2d3b5c420c01b8e8dcc5114eeb1d4aaa54bd36d58ee916ddecacef5b1aa2470528058557dbe161044947e9bc7487a9226449e44f060ac7d862ccd6db5a3cd6edb7a5cc8324c5a0232e3e01cd50e9f0880b68af1f57b0298d2731c2441e6da5c99c0469ffc94aa74efb05ab2cdbf98a9da19ce37a5e754a2f48e9b3ac0e65286d6cfd0a78316d7c2ee581d176db5bfec0967e4261ed37a6f8ab6a3ae2794e594842fd201dcc569f6bb7f9cbbf3bec0db94ea3b518e732d53ecdb2a4cdba3a8cc8f75d94c986ba8a0e66e45999f57677262279c2148bce99e7a54150001bfbbc54b09ecf3bc27bbe96ebc4e3c3cee00cfb6af28139af578deadd444661081369cb3f18815579fe285b647b9e23c50b37e2c1ca766bcf0f8fd12ffbc620d3b2ede30626ddbef7f579764bf9ab8d1c61653dfcb61c53cab5a068285ad31f8c040982604042760e3f843c7e5c331bc8d5df189e1f4608e15cd86c909af9e2faac044838e5c979a4bcdf58a8f0db1582b0f00a252637afbf740cd3f57f300628a3c890d18d9467ca980e021134ff54c579ed9fb299ec776b864f1f7a997e8bb9a1e9151c4b940301ac94db3bafadcd08d3e66dfb61052769c98a213c6be65cb2e01295eb934b09738f0c5fad1e6a03b00b019142bbaa541dbb3013ccafccc47dc542c5e4feb880b17bcad48a5bdea105d07b31c6943ca0088b58d3c7aaec1bb05480a8f368fca982bd43b31b5fe20543d8b30703d27763e978c85aa4c7bab25e563e653ed6551b994b664a17e67369fd4f66c0be85bd32216ef879673d18f2155939f1a6975b487b80e6baab5c0a04b4ba36787ffdcb85494f74c57f3631d1b4f56cb271a8ee2cf6e23ffec2edf5157f79998aafb2a1b752573f860fff81649cc31ae89729b6c6e4a330c1755b2447b70232c38967fa7e1e5b90e302cb9d06901cbabd3bd4f698dfb8b2befecd3d311f8a8ee5ac85635d41817e49eee3e4ea5015c0e0daa7719684a23a979a4e3bc42ce5b3fb0849fef54f2fe756d5ecb45bf24cad94154fbb7a1452394fb4dce415b24d2a4f0859e551304b3dcc8adcf40a8d2b5d82f4ff7921d9f925b13046b9ce828c3483c30817deef8e0fb575ab45ba963501998cdae7d48522c0e1a9b1b8d6ef0ceffd946d23eaf581dd778b8cd445e994e3d9674b8fb6c701323c1106b6c6b4a8fc5c490f870dab575513d7a2a1cbe6dc7523f58b5cb9b71adb0ba8c8084ae76f8b00e991140dc52fd2f2a404e8c063af88c42b8564c62a64fdbddc5bd56384657310fd5bd68e4dc4d050c2465f52e85b6856342405046d9c02e3d88eff7c90ae39c650f3d8b25db644fd8902410eb33f35893b26195eb2cbee954864c0f417de887f60fb53cbfebc7424311f89bb723942a3c054c4aa18f130e97df7a2e002e8f9722c7f993993a79b7236709bd00aed33ebb476c7d3ef81cf473de5bd2236b7d1c29f54f2f9f9a31508294bc355467fb5518de91cc52e2c948f2ed2e112ab98164953144a1e7ffd738014b87c62e2c986c885575474465184026e406a646ae904ddcb6f6a8f9361d0cfbc9873464959f21d9ed259d3a4259a322445bf924a420da396dff585b451dd46e806d7ea11aecc0f088ea7764170f6a8e14be92aa0892a696ebce7bb0db6e731afa8ea3734e711b396f58cabae93b47ecc6ceada3704017d7149ed57de039aeea32e300729b744950556a4fc7af00eb88cbe8e77c21a44bf0f76093b54a7978a57d24bc1a155b3a0e28c749a7a9eaa9542e21faea6dc314e8c7123559310da93ddb03d0cf6198ebce25d56466ce6540d36ac4a7a8507abdaee9bcdd4f59a176dc4cf7231504c88746975b2b7955783b4e32806241619e671e23c3a52795d0b5afa7bd8cf61f525f5f82bf3a5cde4563d6d3add560133ab4ce8cfd0287aa1260a653f4f582058396b548d21e2429e1d19207a72965f8af9ebc258bc60f0e4acf6c31f6abe49f5a8b74ca56527c0cbf74752254880d6b672862c0ed6b2e98b3aa3186272eca495e073fbfcca5def36547d74a22cd9c56bcea6a5e6e5de28c2e583e327f95bbeade1a2ed9f4b955e50e9b30691ea677a15247de0d574bfab9b20e7fc02e134d0265f2beda09a729b301a04975a16a26850fd4f6e4a974e7ad036444647b3c90cddeda35baba74bf02a9e8d3af10a873fcd624dc75fe1846af2acec3c6b794a01ae8231e45a5dcfe40b0f6010449428bdf39f6bb32164acd50e539d6def143d3730c6f90bad94248d36e88fe38ca7a3d0fe97dd31db93ef4f5820bc32eb4999ba61f241bad5b0900d8c7046a34951fb9fe2fcccf7f91687f4ce39ac553fdca29681b91b68e6e470a115723f5f9e367905cc56ef850027e807f073e8c39a73074b566708ef0294fa99ec47e24490a96f161484fafc45a0cad88d565f4bc20ed1626522c805a19fba13a7b57528618178d175c46ddb63686673207a3557ed5751a3a0e5df53def13e6a2c678afc03c90e2a5c4662280d24212df83ed0fe53714943fbefeb2e46368eeef09025b2363c23807abe9fea6db6988777426d5dd6590ee27ec52ad13690d11294728dd2e4caf9b203ee076b9e7e9de03654bebc105d02f0c37a42f2f8476d15e4d72eb16b7e4bed63b33a3eea228dba80dddeb8b5e219e91ab1fc536bcbaadb6eaedd8cc1c7e11fb9b3426a308d4d59e6ca520062ec319c25e736754af919277263b1f48aebac27da9eddf60fca3b027d0972cd07bfadf3e6af63e722574cf518de39c1fd48c80a934c164357ca71d1e9c43c1bd9657be78f99f09e4d699aaf6dd7bb8fd005d352500e155862aca69cbbd30988b742e4b92cf970daac478159c3bfc802f73ef200838486a067b2fd8d465cc08f56b4e15a265ea752d5a2e71e31494ef9dcf05108aae56d236cf66c3f2d34fdf599b0b634fbd81b254cebb98bb307d76f4945d2344a129a957adec5d2b3482324ffc77c790d916261c6a5f4310306f5b303d2a98a53e7e72b82833087d628f2a01bf8c3c18429b1ae2978c656f438cb733e9df48a993b9c60dc46875cb8853cffd15e725ec2ca02432ce2b0cc977217e36956119361235d942e48663fde01885bc500b7ada9635885f6660a011230b79cfb3d8746052cc5099a5faa8637bb35e6a4d93a834b19706fe41987ef1477e017c65053365894ea0cc452b07d85835111ebc30cfb27ae8189624b43c507869162de7f0a587816c616fba5fe95a3725544e9c6c3580cafecedbf790df2e698db319e4a0c9c93f581db20687d0fbf83cbdde02d949e4024d609cb342c0a09f5b175b14358e0625b013d362f44da6b617175b25ca5354a2a06633daa696004853d9f5f7b25dbd5810d11588061f48b2c35e18247310fb8e58cc08d800e8696aaf46159d50f77843bba1c6796385845fc399eb87b3eea732d2f9e4e210d9f532a3a7bb888d0da3438010ef8c0c31b2d7170702b0a962e3758af7f4744d4d1fd2ade0b5d87f982325a7462d75c5fdc00e1bfe5f0a0fd3a72948f5b21a8fe7be7f33e4bb1875a28ffa7bb34013ba5130a0ca2f54de19301ed9da9b8d921bf3ae0b8cc244672ee30ff63d0b47c61d42a0f7b149f13f630e08a8d270746fcc99b4b73bfd97bd5e7274bd1e052533b7c137d909db1d0634246dff7463232d3a8472e4bfe7c124af8c917924da9ace6667c7c9288762dc0e4353f6353f8bb0a62aa7e0c9e7c15169c1904dceb542251604f67cc404f251d4b21024322df1b3c9de101d620347d46e4c4e4da5ea9b431f80370015c7a1a1c77a82c3b16a196df0eed3f393ed46eb306fad9fbd813d4a65e2caf9571e549d282c561e3531d866130e99ec99367e8cf11e06f1f7383aec68f0c1c26653d71bfd378ba321fbb76bc277bf49c5472328dbd11e166d53df94f383699f8e4dc4b521877a608ca2d85c4239a152b8388a84c9c0c7e273032a9dc13bdcf5bbfb4c7522545b2e1257dbf17feb30a41e083c6cbd4e91319fb7dc8f8f3aca0408a3e04bbeeb0f5b5285f0afd96aa78c6f50e1006cdad10b2be4275d9de85e46ed412b80fa90718b838d84f31504a7e103f9eaed969f7c3b2db5862eb29a532ffcdc9f0d8c5b16b3039ccab5b3059cbe8cd135477a8721e92b6fbaedf63e2e4191d8d0034220bdd1c31feea2a5557badb5c1190f18fe1619a1f54c3908156672d1951dac83c2ae2ebbe56feab97362259633251a04b4ef0b9baa0cfa387b12e5cbb353676e05465c5b474f47b1d99a3dd9be5888ca22b4387d80d9de694ee63e68d59c1ba1cf90a87b96c68548fadca065a23a66b1ae22e45424b721307ad73042f453a1b0608448407c22fd49c0fdc45c3023eb8085ee9afdfcb134aec126d15ea3b1d11c533958ceab8100d0125848eb49f43bc020cdc7aee53471a893422ea30fb456788a9b60f391c80f88064960256c6b2de89ff6a44f172cf562317ff48b6b25c6c4fcb1754c66e4b8bc4df945eac043e5c49b2807b3b021df5f8ad79166e9c57de79585b8c0c53a5504edf0a64e159d56f3a562e2ca459f83551e834aa954c4fd670d8c667c6690f1c03e849e687e0c68c3923f3e12c36aaf04f484347a31570106c9d6e624788dcdda9189a6a4e473fe606d3ebd9bac2b418138db164adccded0d83d0710968bb59b40d7ccf1e3209eaf6055628d5e078deedb3310e7e17007a18bd21ef9690c63e298e268d441b638ce0677db0b8e720e96eb63e8dba6d2c08ef615576d75d790cdbd891bb48d2635022cf93159c51f8acbad19c68c2739ca62d64a637b2d27f2de733c7a1ffae543bbe4aa8e37da6b592e73cc026209cfef1628c9dca06a28eef685e5325bfb0f68b54200bc7b98f4098fd5d2010e6f902ec7aa60cce8b0a7b879781c2f6e7c5a0c57183032d4988964dcd031034f528e6f683b97513b7fc86811a52fdbcf304109766e670e3ed3f3d3b16fbc384957382f8b41bb89e523f7d8b093a7b20f966be050841b3da335636b5bbd6dbcd2d1275347f9d8b30b3f6ec4c3d562b9d64f2d6bbb550f252741d902264cf5737479f8e21a5f18fef20a37f3722ae1f4a0a76446df210d640cb31a1489d0310fa0ef353356195a8150ebb78e1a8d960a876af5ffad7e566f718a3725340430117886dd88fc2567d383566671d5389b2d6e4e1d37b6818d4aa8666aff12b0ee33a9f6d5a43c37b2a7541b4dc9371fb875830f9c52f1db10ed110ca1544b440ea3eb87553090a249102d95cf8405664d4a0d0ed3cedbcc63b46795ce23ae09ce1c3c5cab35bb4f742fee3e8f235699867020dba197d99576374c326b2459270d5510cf991acf2aaa67690497b3a837bf189bf50490eac6c4a0da8c53cf225b907c8f96218206ce914c6509181cea9e5f2687cbcf08bea6dfd965958a12e5a7041ab7fd625af4091f1d51895ad654b585fdfee9369b3ea4ac3d9b035f3403039dede00db6fa56ce014e7efabbd4b0b870621d7a599493d428a293f6f6151e895e383932ee4b87ba48ff24e9def04c1d9449caa8d6b3e54dc7fece84b683073f2ced3f55eb1e8812367200c9ee310a77a24639ff294d1dab6606fe3779d0997ef726ad57a1b349436d821d25cc75da3c55595ba15af995c1adc39ff83ca8248fd8bdc05845d0083d91a7d1c9fc3ebdc67e012d4080902b95d7213f8262bae4315c55cd1178be9b72544ea672cab71d1c6623c4a9e12d40630258cc88e27cb970fa9aa81f74633cfb66433cd8c5898d3f88839b2f64b791db5d6fde71145bdf7731268bf3889577beb65c6aefbbce073e79ef3a4c6c18de920ceab0bedc8e3fa1cfa4131e6dd18b336f573ed0a91eebb6045cdd3cc5ea52bd9896bd7c34cc7731d0481492a47ab35bbd05eaae6754e16a4d9954958886a9fe6601e0f12a9d05be851bfad6df5263787f0b86781c66b8a1bd4e9fb64a17758af36926176f898c4f92ac31c2cd401fb4164f72a728c4a9b01b0655a1f539be7f5f55448a620ec8916b04f896325bb039b3193e341b91ae751cc548db5ae6e44386c2236a7268208a740ddbd6a6b7937c58bdad5b197a8c2dfdb6ca30277d764a8f0266fe5c8f5f1b7f3dd391a1fa90e9ed378b0fb2cf7c137da15a8ea263cd56a2b78e81b779834f430b5216f88109f171fd534c2eba82ebaeeff19ae74d590b7dc06fe0d33b25da1beeae5dc390fb3c84bf66aacdd0d55b05fd496321ef3d63738574646142ee04d9ec4c9b384dc75773b5e1c268c3c656a3f4d599dee5601174f3feb372ec71ef993a82557ce903ee883667329e7be226ab4ad75cac324ee6220149e3a9f0416d7983635485414e3b90f431634c396111bf41a98eac990b390dd98e13712c7fcfbbbac41900b7a75eb89786a8c9a10d26b5d8f3150cc14b727eeac01f89a5d3599129ac1a944e3dbe8fd020250f77796df1708c0423b42a5ee94b1253d54fa572d1a21f2bd09ca05397a71cbe5f277f67327608d885fe4040dc3893c0ac83e16ec4c0f1cc69c398dca44cb93e11711ea293e7d206ad90d84f0a232634139e682a32b84c63500aa844612cf3fc5689ae398ec38314a279da64dd5ea4642ac638638e73b9402b7f56b91f0f0c4c75cd81c0a49e38ea8e4509d26ba6c6c7249ca024034965789f13f30aeb680f574ec497fb60af06f5796295a49081f8d64a192988b920e4bdd745e7a7e86e4f0d6f904c88e9ecd251832754fda90fd140e65fd11e58d0ee02b6de6833292756134566b7011554e4e6181cadcb921570284dea3497e848dffcbdd13878b1e0c3e93e0e39497c9260726a0ed082f5646c786e2e4f3f4e98f2154fb288eb7d0a3f7860ef8292467532a22e66b051ca5bf6e46c41d155b25279df8fceb5435006edf5ff934604ecb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
