<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"765d0cd96f8ddafa15310bc0a95e978a1afc0d247d674650b769f6d5ebebe9df3f490f94dae5078ad0a38a9cf9bb67e0701ad047441177d8f0fddd233e6b7f0f5e0deae14af409082762348bdd7e20ad77775c80d6ef92fe2079cbb892e09a4b7da10ef5b614319be961702d1defbf7cb4e01f0eb4cbd6de440f417f8d99665bb4d5253ff56fba9086605d90ac3bed38b8c5a8021e2afd1c7dd6e14af292a513bd1831abb3c6db4d033f3b05e8b92d5f0db24135fdd510dc45e58aff24beaf7ffcd0f5d984868485558cb64979dcd147d625392b1d34cb1651f69062ef11fed4bc5717f75c8f8587498ef5673376637aecc6744d7bc77759b0cecb10b87826578ef819683d9e2fc9c8ea893eae671f0ae5a2dc175f09d32773919134fec857e13538211ecb04b2edd00e6f6d0eae9c0fe416750d4238580826cae02706315a363c6fba89d1ddc9792dae0fbf24bbca7799a8930d64ed424535bbb3bcc5abe6d9ff2d4c4b81a5b4bc898abb2ae5db289723e751cc932e14973bb2e9897f03411f4e410361166204ecc107a808da02ff00887aeed2e825fa2ae1956d554e0c6124707d7c064645c952795a749bb54c1c4bb3b92e74e36d64bae36d41ec65b60db9d46815c4ad4a87eb9e046b63f91bbe9dbcc48b2ab4cc7dd1cf50404cf44568bfef044ec37f9b18a17e626626a0da2701f95e5b71df46401dced0ff684e2e6b3b467a0b1c1567cc079293d996bd7d9c733f745f0eff80af3dd3dc1e8761a306ad02b1ff2551e8bd9d1cb51a2306fb11a23ffdad055772efffc87a749b43867ba970863965992abeb48f5aebd3bc433a9887caf607fcbae87ab6f573f0fd286d1ea2e535125cf8beb7a5af7fb6999ffea92a0f35487d7a6b93541853b957035194ed1ba01429e7e048c2f3e8d0bf83eb9fb5737b7d650bd2008145a56a062ebfaa8fcdba9ebb50f573a9d040d63ccc5b6e92df608558bf7f45501bec2ddfa8060822986a3f9c8164d9fa39773adcd2925b37992bfc2886ec8394a7a7031bef004ccbd35fa03439b7c931c3098dbe0243d2b18d5ac653520500eb35091ab9109ee83b41fb2d102a21636a8807320210a75bd74412fff505a65961d55bcb339d829729903034df971eb95ade13036e0686616dc783727aaae1eaa1a7a10e151742c6535b28bb145e20a1c39af0a628eab9cee8ad80f68838671793246cea8a539ab2b6f16b03e76797e15b9bb90164b501c25eed209fa0ac4b6a113664a5881d0e301f80be81da2550f436134cd76c2160d1d0ab5a6df22f50c020c97ee1f379956750edf766dc2e85a431b6b005347448a490338b6efe8c92ab3cc6164de30732ccca31ac71a7c508e55f1e1e6c21f8ca276a9bcc08fd36275cd3dfbd9709f3fbee65e2940c4b1cfdbbb66941828d1615fff2ec86bb8bb93b6c9f4e662ffd04626ddd2d8f39ab8eaf8c0e7f1edf4176fed22a2ae2bec125569e06078725f6b90bae8f70b0dc636187fb1ffc8e9d692a52c03934b6f71bcdcde49dc0b1552df84ce49fee7355cb66d51727bb61f523be95a143c5536808b984643fb4fa3b82a5a1c7324671b063cf021940cc5d3963878781d35b8391e9fbdb7361ababd83b4749f2aae881db0ead9e38e71e1b90ff072340f60f889fb0f34a755b130abbb62780a3bec95fad975a08a158aeedc56a54f3723d0be75f0b498b36ab07c86ea267dfae30f72971c4ad74a4d5fbf2b6a6d9df9196ef82449b47e2a24bdd860511fd0cac53f9bd5ebb9f9886784dba7b39928437efc06fcd7e4120a1dd014f23c090e698b0e23e2e796bb8eeecbb527203eab2e494700267d38e20b5ee84f23751c77ca462ec2599e5c1f5e5c7eacc6b9a02af7a19cb052659b34c6c197979372ff0595c89dad467f2e4ab952d2189da839073125f0644593789523b4f7a5e1975c58d1c92c68858cdcff99f3525b0ff702b7693f75e9a162f635b19294d71fe8ad21564784ef6c80285fd084e3fbec1c0cbd22768a5a49fb3a53b778b4c62128c81463d51927e02ba47ec6a1b37ec4bfc043f34807f15695a8e2e6d6e6f69681a2995203b0d3bd6feee9ad5d926c4fd1864c31007f41a91cbdeabc708d5693d09312a90f2da1aafcd5205b2e9b2a88ab32985f9c683d2d888cf83b4edb6dbd2f933287edcccd076b88a6c0089390bdf6b5e74399f0e4983e3b1c41d50994a1b6c870714979e55f56c31757a723c8b2389809268ddb7936021f5c368b9d0a1aee7f63ef884782e31c2e55aa5ea15b533220301e9269d79583d583665028774152143c40178dd29de01690790b37c7d8d0d494b2ea6b808f5df2bc565456d06b83c63c9a866122cab2ff0fea3d83d36b1d976af888f46756484a62e3ab2ccf6adcbae38871b2dbbfe12fcb31e5e4709d4bac4d00b3c7d603093204d88b729c6a93563f02fd8699b2961e50da1579b0108c0f822aff0b2348c56a8aafd6b2977e3852c7bfe2d8c3a59dbdb402f89bf1b6c0ca277e6ac42df7f799f000d9d41621e5be7568e7f2f88b6d70278b0dfa3e7b1a9afee0a45b63aa1543ba729f169e46ebfcb9c1eb08aae82f787a741522db327761f9c075d5ed1f2ef27fccd13b6519622d2656e78d62c535d92116a6db4761430aa1cca86334f95d07f4f22d1d5921ef8a10708ccc09eb9e8fa2e74ef1eccb1427bcaddffa26d263872c9eb7f6d50d2b4885e46639f7996ec2e55376fb53e334a7475ed4cbad1f88358fd1e603e43740b737fb41ebc53c02b96cf20c930bd9132360ea1f12d0f73345a2a265ab7e9ba6b140f1b9e2fc619dba00a563d4870879146b7869de39bf6a4282aa60324f161ce61a34e83ece5833e6493f6b4fc45dd21d58251baaa87c1646695d97bdd7623638f53104f291cfe7127709d223eab185e4328ba26d0aa74a043c5dceccd0a673324fd47aa15819e8c95a4fd205e57b9761f0f3fa3e9f5d8272b7a117eb526b80e7199e928a8e8ab504ba3a45b4ee23fdd01d1513b60351e5997a856f58a0360a8967b30dc4af8c7f1b469c43e761ecb7352b821c25fb1ebf3e2e28604d35b1f528bb889325a3f1f2e257a250d9b0457a9a7e0016a80af907448ebdbed4d3ba0d43f15002e113a49b4983dc405949e482f12dc52d4d99045101d3638586957970fb1a78740eb64f87447bef2bf9bfe8785d7e33fffb786edadaf1a5b39c5be9a890646e296acff4e218980de5512a1de71cc507d20893821644714663cd018977369782e7525d3d9e56d0ddbf8ddc04d67e0766d09e5217f84876fa5ca938be196fca7eb433fa795545d085dc358e51eb15644e2a40dcb3c53c0a8e5a29bb5a7243e4f63b9dcccde58ce66b5ee2b8baf6488a9a4c143d7a7ea5cff7f0b185c10446fd2ba875e3998eabc159bad3fc2eca968602aeef64eb70968f9071606b6c58423d1f49c63db74d1df757116ea995c83c2b7ce15a1ae2f8340f55a64cf3ea3e39d2b0ef92ddc7cc0139ca2507671629f65e8108eec5941981df6eaf0f502b9e85cd5ee8bddf7b9368e95348e21e9cc64cafbb5532d7504117bbd061e516defaa152ca387d1b1c2ce620182c029f541a65a8d5831e34a00d8619357c3813fc7d1cb17f99b55ac19ea2c55642a6c4e355890501d8c3de84cb56c27bf7a788fca66b313b830b95468ffd201da8ddf7e7c9d5856ed588fadcf3549e694ffcc8d25bd795480d7531d6e03b5be32d1badb8af9beeeece4661a10bf8cdfb00a358a3a67a672ea787bdd3639f9114204779f8b3b62c239a76a4d6be46336acba09a47229bd31fce06177a1b05c6f99db53884d544cf12192c4fe9ea6e6836c20bd77fe1c236888bacf54b43f7199a532d08e211161dab99453511337a609ad3cb2b09e473ce74b1c62b3627445d037044ad5f40161d5211383f82b5e518abf0863918335071f1c977a1f1c478ee40fb3f99d411fcfa095e6c5c10b14f71e21a55f0b21b40f2c78fbd49ea9de23ef3a54afb7616c76324bd95141caeae5ad91b2975e40df25ce4ce12c87af4a9f6bff62bf678df22f0e8d6fe76afff971a0c5131e542e8619dd8024d033f6a188d282b341e07bc86a749cd9e32461684978fca6a5527ca9e787394fb52e270e1d2da5c6f7a1ac704dfebf2e10dacca4eb59998460ccef0be5c3e0bae9b60ea604d73b5904437b70624a0521a2b0443ae36c637dc46836c2fd3413d81fd064268737de47c2de36a5177bb2cea6a634da7a2db11daee285e2ad738bfb7d431397eb730aa16fb2c153f9a399a795d6b37132038dc76129085595c9885dbbea8004d612a972f21c3d53da541898f71ac84b2ae8514ca67d1f9a0a26e3e9228fa5c3c1e9cc3f8715c4e2c7eb73612db54f086a85ef225e89ad750f28216ca20b9c56a25b920cc73ba0a0bbc72b147fb095bc10219e9fce9d6a69459f23ee21847c7a0c26deea42773eee7f338168f48612836300b852732003bd4fec85ef752b2f9e53819eeb75ad59f6b906e429307c4b9398faa20473be8cf83bcad19f3f6f140b9a33c416fcd0cb9656e4c4445fb9ddb5b830f096fbe0ce3dcfe0cf74af4911c9d375b7076a462e1610caca5761da32d5afd11760a8036abcbfb8b5b1a249ccf24a7705683a94b099ba7c72efc25af1deab2c94820339109faf6986ecb0a4efe941296eedaa6bd39ed90ed6a944518305d42b75021a346179f371108b2f72c29b284d662eb37693177ec2b5e642b964fe030b3eaae9d2fdcb61f95db93a9e2efd0f96ba3c60f195dccc20693d2e509e2f02f1581588dde52db3d6593ac295f4ebe78e407b5a827e5d2f0cfaf2ffc9aad7404319b62400cc2e534bd7503ba862ba6969b5ef17ed381f1a0492eda4e2db6f1d2c972db74259baa24533d2feca6dc1e4fa088629ffcf1192932ecda5cd2eb2483f9c95b4ec65063537761236e927b1b3bb5cbd3d93426ba370a29a7cf072a7be19690b5a20052a11cdcb9cb73871490b8c991c84e2165e17418aa1f8db6a5d4dff678b1bf7e9c10c8ea9a198baa197e9febda75a24b3400b52ed57d2eb5806707c0f461cd44777bac9062796ae393eb9391d4eda7a89718f171db03a6391c158974cc69cbc76695e94318deb1078afeeb473fd92d06dbbe229cf6ff71a3b187a9f7edb3a2974520193caf8ba1b036b46170ed06e838391bd0f412980ef623de8fc32b3a4f7b5f0bb0d65865cde4e54142d2ca172ceefd0956bc0dc1526f91d266ea8124053032d9ecc9dbfc26dfdc5d91db7ff09f82d4f423b2fa25d219be15ed0967ee165c0843830da177ab86369ef3bc3e57ebff7cbdfd681d0b212dfac2e76ef53c90250317e1e5751773718201eddfa5cdb7f16933e369503207bc9ad2a3ee402d3aed19cd765ce3b929602d8871117ef26923e33ef46806a0388b09f9a09e13cc13e1654c94434f649e8d54068e9be189ad0efc805c4f92efc856462886667b3a0391785012d070478c6bc3036fd1002947a032038536da7d68e0e27277a88edd60590028fd01819d9295fbfb1ae3dc79ec52b379d291ffe9700338bad640d0b58a2faf045b6a3b2a4e710fd11221d8b3814d0cc02e3f92eefdb8ca33414bc8ec87f89a4609cd3231fbb0fd9b2e68f955585e0615cdd7896b77ad97046bd06270565577acf2f40443ef6f862ac4cf063c76910354c62d10cea7beecba5f3b8f7a7ae5bcfd783128973aec05261228a6437d692766243c94b36aa5d019bdd32ba7bb09b8f4311803be16e7b9073c0711363cb800a1fcbb0bca1aabee7bf6ba591c8022131b9037e971acfecc54389ddbe336c7e960e2182ae9887c91924490198ddbbdc2f98166f9a670b7e1b3e3928e45cc16d3fa40ae8591558f0dc44e866f6f2a2b9698c0ea35b1b45ff3297046a22382e3d9ccdf9deb493125f25ae01ff1a9fba17c642dcd86c11f176c1d34da44299afaaae0d176baf2a30bfffc196db9d9b2cf87fc88bd6e5e6f76f194a44305179e09a7d5b468623f64352f040e4a157b50480ecfe926866e48fe01231d1109b1533efb689cb08ba0b2184b64916cc023943c3e752c319f4fe8230792b222862ca0b8ecf57189ebd46781f0163867bf161976e97c160b40a081185ff76da4207a3b467691e326cf927b1ee9a61a3554eca4cdf6d718a39a583ebe856bcc38f4bc827021344358bb4b7b52c1dbb9fe6de0c470ea15872ecce3851359d5307bf04d11ee674dbbb1db98c0bf6624e44f4bcfd8eb72e9a6a85cd7e6ddf956b23c89cf31b1b839cf57b34b434669edbde64e0a0dd4b49af02b281145fd5ff181b6a239f9cb045c53005571efe78cabe59b59765e27fa4103509a8d3f813c8b62fc26eba5c46c486e7704e3e48b29bb1b31da419373da143e0c5f60821d9e30b8d7038e0a17fdb48ec4536f7804717f42071ec7dab553d552aea8c700ecf52207f97a40db7c8a8482edeb787c5c28bf2b70cb416e6093866327532007617d1eade211e4a9af4683e51f146a9dc509cadec2e449928efc4efd6c606a566d2694fc97c41c22b1fd4dc36ec8fa2e04b4a8c739911ae2d492690becd0cb9b2780b4e2ef0c05644315b3ad82018f209dedfd71d0c8ed3a8d5db74a36ff59fb00217258444249953aeeeed5a5ce2d2a6992c85531861d9faa17d4a1c2dae727fefb49af71ce0e24ad80ead0028020af26fa862420ecb9c59961ce368a66bffdfa52852cc9050ba98751bf58aa9a06fd502ea3c234a2e33ec20942760148d9609c98de2e134b27d19dec391d93922ee2286554afa7a46c75cfb14800cbe4e305ca51bc6f8060abe2eb1c2eb2e08b7bc2d0e94d7d429244b5355d60aac70008fcb60fb9ac8c955a8e512f7148dd4427bd4099a407d6f222a652bab8adb8ba505b6040826d25810d286845e281bddab3d8e78ff06cc4bdae8ea5bf93c3c6d0ae5bb69f220799101a7a7ddf30687c3d2be9844bf9a62ee4ff60d3c5c35aa502670c45adbaf560f2a53b227b0d6d5cbbecbb65eb54b59ae0a6e0b9d5e47a91ac5e82014b0916da6af49f3e2f970bf761c89ec430a36b2fa675bb64a2832ac32e20cdc1244ed0d9b16512fcb5f7e1b243ae2f207c4eebee01018cf063738511b56f88f617f1cba4c4724bc1e8131caa54d4b1f7d65a3387113f6b599cd3e76c9fba384f2dc3ad3cb72366b0079865de9aff0bb7afac84ce0c9d47403f31b3389faa631a4826a4110650a93efac0f47e8ab5b6b8b86faa21f557dec40ad01909eb0ccc0ae1e48895c80f980f8b7b088e9e0d9c2d96f5c728d21db6ac409361642cf474c6ac3016be0c83f8d9051eaf9a857e44b04dcda0e366dec2098b8f3f70a71bbf68b66a96fb27bd57d12ce4630fe2d616a755ca4b4b1be91df879b084db90f87c0ec38f902e0d2d2041215c1615402e33ced68de64a80e8251da86b89e774b1221c7656cf8b4b6a63fae669b57c080023d74b2ff30d803224d595b62071566c8ea2d83ed78a0b6805d685f49878a8f00d9259fd7be34f1670b902940cd37a4762f129d162691ee6d65b147605476e8812d3a5df94249354d404b68698ca449aeb57b62f45a1f43031b001e66000e8e99d576c939fa4555cb0f4ef21f50a870f3f0758309f7a82906cecf45b287a6dce6d7bc4af7b460a33ff109011de6717937e1940af18fd7ce3cf6104ffc6852118eba3f3d091633bf87fff7d40c4f084d191aadbac47539cf4ba004fe68144af99959dcc77e63efbc8c89ae265c6ad4ebd1f958064b3fddcd38f17c266dcd97f92bd85811616c13ad92fc7c9a03303378a6746680a1e9d5f5c923378940bb85cb2046c9ce2033a061eb9e8693e800e615e7fbfb3d5287b0d09c1d9022e1da4dedd340f8145734ca3227765d7fa931bee118c69466c61232efd79aa28b1b04a111e06fbdbbcce7c1b7ed1373b2b2bd3a9b287deb724a304e2edcba75c9947ad6b6362048ed0fec15d77d9589aab662365d9587e4b2b5b50d4f4cc4b0639018a74c35197539d14fd2b1f5de0a267486a3e51bd3d95713b2c2f9408a054cf453ea9bec66696ff3620e61efd46a43c4f0fb0bf665b742a928700471edaebb638a52170fa48cceb7f78c5c6cebcfc90aea05bbb4d631fbfda680d0b57f34ec02bb9a754c8847157fc23b290a5c6b532f85a54393deffd1b20faa6c64f20c449a885af92d62abe4badc93fdc5e14058481579f687a6036e91ecc2964f9f99ece61870ee3b6d9e53b6d8cecf2d4bc83b59c32dfb0f7983a007edcea1ceac459267e3314f9469a946966b6a15e1d93098d72174dd381f641365b0dafde19b56fafb3c67ceeb8e02528645ca5de56c5d5d97998a8a05043dc92852f657393f7d04242dd323524a45f43b865d1d0cc42f751696d3068258273d6763a1da937d5a13936a1479969088430b355d8a79b6947ea92f4f09d9a7cd1c64f56a440872834d7083c8753bd0ca326e56a219ebe30551933c1068dbbdf62e25d514de9e2f1bf3ea259e18a3f88662a5f90c65ac63b6034fae6430fe8dbe126cabf4f4aa29811dbb305877cb02c9323e43403e3ac6aa3a074b3735a254f2d4ede89bea64ed483cc048bdd0051cc55aa0dbb9d3517991563b6a0534e3f754f5862485a52537baf3dc70dbcdffc1369bb96995dc03a7f67ab2712dd9164b66b7e713122c6737230ce5e08b826ef2145630a9ab7ed4d0fccf14ba6f34f5316a261b08de3e7bb2c52896a494d2a06ec708d9f8c9bbf0c197cbf1f9a174b590b7ef3061cd59b739058788ba356df670132f3654786543e79aef06eb6fc6d00dda51c9ad977aba544bcabc037065ea6334884d204c936d0940ea03811441c75057d401f9c8e943073121eccea9d5a1912f9b9fb86484a05fae1b68c17ab14d95b48a95b1881040336104b053c995b947d55fc9f523fbfd3acd215e54d141d7801dad4a4f68cc14af4a22f042ca925b266aa6e2a19698d84cd01798d317608683ce32ddf20ed23f05be1c8c20a0c4cd386858d7d8843fd6ae2c0b803f4dcd2bdd1fd25acc9dc26d41a1937d2681e3d4365c6fcc0b8905284f90a5ee9e227988a318c3a52b4a8a706720784f6b7a29b46d3e2c4efc759ec30f6eda41bd210c6e4ff6eadc9616c46666c5ac761f3e38aa4c8a3c068b4a377f75c477ef0efc9e198904a5286380900f9933d045ca0a8abc1a3171e401fa2871c240f0705773e021fb6abb7ce178761bac5fa26523add824dd41278de4e46f56208b6ca9629008a7e5a79665a83343e08d315e651a87897629fb511238d08f3545716bca8f621182723599807004a50537a3b447c6fb28f4b119eaf279d4fa069ffdae8f9a788a1a8b7fe5c462970cbcf3003db55fd296a4abd4335042d539863ac455966fa350dcd4fdacfc89abbce03c5940d42adf65f347aa3d117cb3e80946050702701729f79f18ba47e124abdb8dea3063d66e2b7d676d8621a14c8bde51c64e39b24b10f0eac0043ab563981889bcbcf76b5346561c660fcc991facb2dcd7b9c0a272b58c4f9952bb4debe30359d2ce41898bfbafdd4a4d0e40dcc5433958e454618bdecbd3b46f59aa4f6af8d44a32c8c6dc10a9bb069d93ef2f03719f594ee5c24045cf2da0045e20c0963595c40c5bca482a197ba540540e5ffd52f1ebd059c0564a12fe36efda51341ad9befd1ef0bb0f2491be2b4f6cccba12c138523c38392d718c3443d03644ac278829cae9eab54cf1a2cbadcef3b12f43c2ca1f2f20f73c3b1cf99e565affb488d9c875b777265e4fa93dbfb28b925365328e67b7a84db0c8439b2f5d6da98789b671724f514de3e66b4317395052b8f2ed908471e9a193fc812fad264ef3ab414830e6aecc100d7f6ce26ebe6e814427cb801a17a8073d77e041bb14be58f3068871f9e630ba7a5facaff0b8b97e9927dd64c53438309751a4cc3015e4af15852123cdde8582ad730ea1d153f2b8bea8467cdd443c7431222f356b84bc2b5bb1a93ddaacf91fa7cccd628c5ed1dbb35c866febf36fc2421d389e62d72dde2bb0145b636204d34c1491d459e9a28da927a1930f5ea424ac2306502836fa1cb1391330b3736777733484be66be6e2c000b9f01644104da6741b291352d567a0e78619eafa82a34066349881d37a6a56676394a2ea1e4ca2ed7d2efd53d42f4171b4d177714c3fe39a1a3d73e3b690cb6d6799e7ac9da41efa82dd518533779fe254bd3eb7fb8c7cd71ea8e4a2c3ad9a05135a4e24e077494006026642c2984bb3ad1f59cf764c81fd35850801c05bae33058dd1c4d28cd4ee22d6c9167ec4018f6bd4f8778718c2212b853b6d6d0a37d06797c7ed76c451c8ca6008e85ddfdef2618fddeedf821553d4aea17e7bb746779f695b57c273c32d5667358c6804e0d7f36e8260c1e4b598b114a107797106e405819b3dd222a1822d1e33e06201b63a3aa9e75d65ec80fa71481f0be5b526f1eaf9eafd307bfbe4874d24a7918f0c6c50c3c7107ac2244cc9614e37a7886a42d15575396ebbcc66d139443db162ed405e1b3aee9ab71b6e04df230e03c3084c0b03091cd1ccf01816d3f67cb6586b775c41519702798b1f97cc53b47dc711573832a2485c6ac0feed9d6fff3525952ffa4d9c1736e53b3a786c44571bfe97f406c5311dd0410bf9737e30f36043521584af919a4844be1fb0eccd0475d9eb8e6c18324f20452cd185c00c04cfbd7d716d3923d08e54229e1b710549fb7fa90e37d6ce2eb1a90db142a5a16c55d7bec49234c738ef046b934421ecb7714b41cc5175de6cdfff1256ecc19660f4e40e1fc19c16f0632f13a69bb8a969cee395cd2bbdddb09d0b357cdd3fc8ab897e6cb8e4d20e11b131d40f3f40d48b2ed49e4b8703bd49ddf93a53aa223bff065fdb640e17460e58d5ff7ac41fd63d01accad83bdef170ed610375a08d1798a9f49af7f0f9d9a917b5cedade91770fed78f037a101aecb5678dbfce36183c9caad8f917727c272788129c9f5ce2931662c81aa2e99b04e972517c93cbb7d0e939de89ed91909e539acad80cea10b42862b92d41fb841a8d31ead2a4bc46cf5e1d03f742222d6e8fb4ae47bc67d323e348e6bf7f3b280a4ea3171e6b1222465ab6025df9aa1bf9475e442d4424dd00a04ae2d8560681c1165e67fe0edef5d4df33aa4577edf13c6b0818408aab2da2aec308276f17b7cdc932e4a155b8190ff7c1740ab9d056dec1937200b23825e1b7ef03d7c2a7d38a673296513ce2b8c25adc66cf1c7b9e28e5c2b42a7dec8e85171b98bd6d5cff5ce92f260304e1bf8956c8a5c81db146b822891062ee0c1a62274dac41ff8fa80c2562e5cf89bc60f3fe583403be1263e3d6192e9240507958befc473c4e67d92a71b1339c3de57c9461540371a11256ab3333ea75b27cd6ddee721a34b1e32d7b39562cb3cdee74bad54b2abecb1cb7c4dffa0c3fc696e3ebf4f6347ed2f10e73b1444717b0c7213d385e9d27a623b58e96c74b3388942d2bcca63a64f264866e3e4cf7bea3371df19b0967bfc4746c052fb9593cae4dfdc7b22de522d0f6f6442eb91612eb3c67c79e35501f33137e3631722502a9f1c4bfded0d4a1b2e063aabebf3e645e7ba5e58a2cca4ef6bd00e8e30cc09fed3a441686fee552246e116bac7b302cfe9e96d6b0b6855129703ae5b856085abe2081e46110e7f690f0c12b8396c3468d47b35fbdd009c08c19a9363380a3e25ae2da50ca3446e718fcc15ff7f80b45389f663f4badd2a76a1eed0e9db320a12c53806870ef12bb3df3d53c623aa4dfd64a8cbdda1876a86b46ee3057901fe4a8d2d18b7596a656a72fccf00be6a0337bd7e532df4c70dafbc2bc6ffc3089929d8dd546b67d88476386883774ccaf1bc0ef29d6d85f7afd6b5c65008fb9b5628932237941df8ac1c932238a4dbd48515970b4069220611a47cee50e17261d5c11d066921e08d667202026e275fab9062167fb7c816d475f639680f463b3bc72b90e2e01d58722d4d423d354767ee7778683fa6b09497bd7d59432d59d4734df206e5a5967f31ff5ca5a96a58523a9a5dc9e9d94616d27216a44ada97d599446dc8381a2a2cf3d5c7e0223d0c8b505ed91972752ebe149446f2d9f94e3c5d15db066dfee12c7fe539a77273913e1f8d992207f3089e2831e643661a75d95089b66f39378fa71aa0184fabfcffe1a39fb2d506c073e46706becc649b3a41b5aac7a72f109bc79761eb8b2c9465ef0fc42ffe23eb416edf7bf555a47087c2cb33c2a138f85e4178e392cf178e149e93f743aec630dd79eeced30b1ee1c82ce4830df8ae7ce50cf0d1a4cd08fbfece530aa26e47450d46eacc0bd70569144ff1905536afeb99919b377d6e228e75b211b36efae09e43ba6359dec607accac7edd7a040784e883fd8abdae508faf215fdded843d07c2bae38119cc758624f5691c9c712deaba80a20ac455d6cee371ab2921c873333dad734a80c14a8dbfafcfacbc3ac38a20fa148abf077c8b1dc8783a0aa41fe8f6b36d6d5a44cbafe8c9a3613c4600e1711881bf19c02b3ed63b9fc3d8af8f9c783a2b11d04876f05e6004003b8d5c1e414513d8bf263052531b2cbd5e3538c25ff0c9ff93670371200882e6794b86972107691f480572ddb3e97d44aeed67175889ca736067516dae78834dc3868ed9946b85101c8aec933607f99fd4eecde9a2a1affb708f90bb3573457cb5d1ffa80ea5775269cc9dc75a5c9ab57c15a5b216d4afb944e4002ba9f8f31a275e9d004f7482040a5b6829409c12b5b710187c6c9d498425e0c54b03c96945ad311354e2a0d5d41ad96d022b4531ecb172b27a0aca053e6d2a3e2257e1eec3a59c69c2ab01e98a9a8b89be88e47cc76c21d264fdbe0ebb39b07d3bb620170ee0749cdd3c4541cbc03d47023277a981f4caf2b088d38a999fca0642db28acff21b2a9c8ed051002ca8b37c61438c8d1ca89503a0c38c8c07f67f2cbd160444238cfb96b15eff31a598641b61c1ceaf81393501996e7e61007fb21c994916fac4fdc31d2ba4122d337606282169cbbd74a5088e6e0ce8438c5d0363ab437ade5cfe4cb9ff51fa3aaa1f3cc72406dfaa3a6d16eb4bcfc853003163ac018d59e652b18a76bd63e52bffd60faca4c74f29b0a9045c785661f5454811914cbce81aa14762e46c0373cf6df4b745be62fdfec6093d771faebc4827b0d30cc1b664694c772124e5f5f653d722c3c6df3285ac3c98dbd161c7b4465b4644cf05d550a444c1b8f96e21085ece07eb07a3170df9de647246430e4eec3977a2567ce7b2b4c43f61f23f47a4380e5bdaa6ca22603daa0f8fe95543ed60da7e158d1e7defb61f0c4fac5e218f9d44633adb686229637224b5398c854deb6fd50f3790fd9ecd0dc8c593978fab8f44e41589d3bbb0a8c23ce67a41b1c906c8a4b3ac919873c145a6407f6c70f79606d415108d5ea210f4daa384eb5e3bffd369cd80dc936addd03338068282ea2c1a6f4328d5f5e31d63fae1d7f5ea5b54412b3d13edc537ec8ae522e18f66bcef788dc67bf1effabddeb25d8689f38374f87e1ed0b0db9df6af5ebcf4469e74a8d1281059c966de84c7e1bd8f4f43aeb193f0412da1abb26592ad311ada342b8b8a1e0463cfe8b02d5fdb3292b05d5a24784cbe04d1f262c6e7a08d91dd9994a498d7273dcc9aec129c2bc61de8412f233a4cc5e3e3076b9b3846ccdb6209ee83d2213353556f52a9794d37debfc7954ba5a4e5f1b1a178da8b3e2e85a08e806770d4f9a8708903a1e9451bd2c46d6e0433d559afafbe97e6ac27a711a33e0cb9d10e97d1bb9e1df11ae6a2c7182a8c8f797d4f0a109e8f625217e32db63530154ef2d2fdd7974ce019ba5701c1c1f1a9ff7348a6cd2eefeaf58962ef2f9408f193f2b67e57348830e8c48002f838f77d3c2edc83d6a7d69c7f36c94ceec250b8e8126b651a322f03ea4c994d5433e028589d23abb89a8c8251a648117cf1716f7800c923e8c651162fd440529ee5e5cad28cba8a3f73f5da0de69f7c96e48b6d59fc22c1e2d5045f9ebcca5815d642ccfcde2600cd049192fb2536666082b7bea5fea63d04577b6410ca2d0a7a07dc67144d0c8687fe7bc7e65f9f0fe3b89a78db971184e705f2210579580750b77c9c989854715ab3c76197cc21fca8a2debd7da3645726ce2731780f0358ee3de59eac7ef8d238615af74b2c06cb18408e3017aa79e05edc98cfc1800ec24e802151e034c588e1948d7cc399eeb31f0adf7e303c3fbef77e430c7d6994f09387c1351185cb4352003ffbabff1fe0c923b98e2231c9c08e70c01c7cdb484ba222dfbddfe8982aba359fd89de7fa2dcb4652ae759e28c1197d31e7ffc74bde9a028eedaf72eb130723b62303afbfdbd03913d437dbd1e79b62d437a78075c04fc4c9e77ab6a12628927b87f4583cc207e09ad45117299806cf9473d37ea04841c9ef4b270991b4dcb378e165b46b4598a987283f71b190b4c190e02f7c276f49e22d79724ea85a152c5798bf7431cc192a579c9a60b57323a550f0dbb04cb933a1948cdc25273595df01bdbab081a8ebbe546277235be6904130b74a2fb821065e6c52a84664ed0c44dfdd0545b08b4b31c59d5412d0c2e5fae5e015c0e05949b57edce2e41098ddcd6d35d12d9029b3b23cd56ede3ca3a25e6a07d9ce10edb56302cfe2ea57fba4f9aaab2f32adcee340452a38e5939b50b39d144a1f6e67641de282b82f6ef1210c2329245ab7c4144ab57e9bae0adf08df218cc4d6b99cecffc27162226557d270a7ad72aedc4e86f4c921fc72b383f2b7581ceca0c16d7a4965b27cf2c22a704efff1be7c9ac767506b835d6cf389fcc4c7ffbc4e596a9fa2d4964bd595ce2d8865895e426d96b6387c440d5a01e384f923a8c5b21fe37c28cd179938e67a7e70c49f52b4995cd9557618e1d1e1e9514ca4de7a30983cf4d99aafe2758a4ecbe2faeedf97b974398b4458c04aa45aff57648ddd3aa2e0c08f2449765ada9b82fc19f421aa24e15aa52ef494c3efda90114d371dcc2f04d4df091196623141b26b6a6a271cc8cbc3f330f2f4f9f7512ae9f8c0a8b3eefd8933a6788b97f7e2f63805a37027f47e84f429ef6fb23c1228d80a6803e18dc68cd0eb71767f3893f4121044e300bd3dcbc7d740fc66f51e8a7a2195c51af4a655de75f0ff48b39c2713ba8d6da2697feab8ebf59ad49b5b03533342a262939f0e71cf5e26bdee72ff008dabb9dc4d44942cb5aef331e34990e1c1513918e35a21cbe5bf278bd5dc1534fc879fc9c64b2c07e3bff8fcdc9043b5336531f81fd5f6186500b4a3b825cd84523beac2f701db681e6bdf0a60dd154485e8d3aed11ce6f223d605c4dc885ff13d7e022e748d2c99c4e7c2638a9b293b81b45b1797f19ca76fbf975395640607fc293f80aa647f410b881baf68392efb71265cc99a405140b1f4c0e8317773594f6b16a22d4fd4417e9c45c574e4e312646f185094be728f36e4bafd091125e0e6649286a4dc56c29168a06e9c85ef6fcdc61425c98393ccac05a11002f1046ac3cc770af261c0e543a0e79a1a921886868bdc380e05a38cb3554485864c09a366015795346068157dfb0af676c6314cd2bd46c76f14864f61eb8b01eb63bec14cb60fa03e9fe97289fa08e71bce1b49f3a052e2616a123fd2fd3c2f68eded1defff9a474e193ad0a105aeae1705410c78c814ff9a3d822696594bba964ae9a1be446acec901f8278a1659399971500a68094069c82dcd381f8eae0fb3cbbef0e0bee83ae56b2e6a2c65fddd2c14fad9379f048cd3d3ae91e27ca52399624d807d3e023c2bc221aebddd2a64cca03c46adc5f01d8a9ba184637b374c6f889625cf9d0a461fd81af3c996704773709eaf86893fcbc0c0e45e88ebbfdf7a06f75e3415391bf9e98964bc8d0a0149a9418d4ef695788d8ad65d7b566bbeac543fc5f4eebe5a806b1e7fefa122389d234e9ac6705536653504635e2782ab254c5d05e6f61f1c8ed6008510d14416489c5c2ee9cb865c9b4c40a9152f08b8fbb836e37be1d2d764bd7779d720eee1b3b148e25d93bd5a568c626c2a023bfa24625e7cf586b60f224a91ce76e7fabac20230173e96d8fb7d29b9eea854141549733fa69f02b589290ab225ce53d097ac3c0dabd43d58a2e89ead81519960e99c7db1c59e1ee44efb9f2160c515de0c5b3a776f89abb13a240f8d1907a457e7da60f1aa95765e1c15e3a07008776d7d81d7ab21a58367e496c17ad40d0d9fc962c826d3b7965d07d8149776db32c7c62b6cef21a0f226c6b9b620f3bd559551ec3f5dc967e65151674f77ebd6c5b00d34c1864e37f6bef8f6324785f5e06158ddd28b259b049b361da24c8575a870120a8c997c7285da8842f5d2b8b0e4f47de2440dfc499cbde96708fcda0f5c0adad191a7bfe97217d22eb4540e0cecea783365dce168b563294655b8a66d536749b21e6f7fa789fe0ce588350e22542b384a3420cb21e632e60ca39bdcde3f8b4ea30273cd3159eadff6954e79a21c5af8d3eb5f13548c550d08134e3c92cd60673ebc1cb91236fcd24b2fc6c67d2a6c43bc2150f11d257ad618c2974f8cd8334754fe5c36d8659498a667bb56095e6def6377f7279d75a446e7b475f89fedd472e0ba60eaa3a292f47aa29a65b1718db61b3f92972128203e431d9b343beb0b7d5e5b5a97dd99b587ca5e511547098175668ab73c745c15b686d33b1d999f7e83351211a9337011987db646f851d0815100bf109e03cd3bc24c30d27050c584228433c250c48d5d0ca16da2f4400f18ad73e18440336114c0015af6499f1360768386eb061801b435af218c26f9ba3424ce1aa8610afed18ff6321f646222997c59f622e0891d2357a3004a409e2dc08182b9cda0b5d624b39608c9ebcf0d4923383ffa432e7ace0c0ec1f2066694cdbb62f188a6d49979b53fbcf1f2c5938da2315db9a0d7a6fd13348feaf4261f580a6a9567197254c199615967c3060099585663907aecb26e36c84aaf93cd63438088433fb18652c9ba6d83329078f7507a56f2f6552ac9d793e39e34c130637bb31116dd625a9e75417a503c3543b28c2e278ea768e0790fe4a1008b15d21cfd746eea9c74579f35f356aa415afb008ce2fc9d0aeb7b0d96415cc79a6dcb2a0017064c4953f0da680880ab9d759b9d422ae8cb3c072c7ef4a2f50e61ed2dbf8a19593dc7708333366da0c0177ff6748f0346eb6ebaf60f42ddde41e85ebbb68da57f7e8973b2cbc5a9ab0a6ee79f8b92661a531325351122198284ede8370d848ecb584730ea0db1e1d5140be71d9204d3af12df4b0c64d429d11680f811699c61a0b1643af196f9a58d91a909636d17f21939861b65bb0af63d557e1df359d79a61662a2a8d867e9b5484b0bd194473a8dec3e95b8361ef10569ebabc09566fe632dec873b6ced5e5e0bada9b103c847fd31b775dc319fab46073abeb46945f2da775945afa425113effeda0912566ec108ddde614d1c2fd721ad0f225cbc572abf6c5aca7cd66ca0b1848f0c5c932ca22e50c719e58ce71ee7cd647784e6b1a9d41753601ce5c93b190c5ced34a46a13dc7384af0eae4a670de4288a95ceab2b23b4112ab1e9f79e64db6f7ad0c6c2c0ab419842467d9572ea245c871612488ee982d0d9b837bd203e4ab05d5d21bd1eb380afe044e2930115ed7e6dab13ab18bb4892526ddb9bf126c3bc400e2d956d4878c3f1161a8f8b63b869af3a5ac149fd7a71853e81b59397e860ad5b471d23e1006bb2a71e3f38f9233c9c67b786963fe4027c82d768c84d70f00d75781a0bd5b8e7c9965fa9cecb7f87167c3ab30b06013779212441312721f137f1ac7ed1a5ecdc930529828b5e9ef6134fe5bc9b15f01981fc2c70b7530ac67ae61500026f9586bca90ba1b6a652226c2fa84fd8d084a5de60aae275c62e6cbd2e10c5fac3119a94180d1a8002f013a1ee183b4d1c1187e4b94938c6517da72df4023bb00e2f662a7b50c23","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
