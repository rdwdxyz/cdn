<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6a267e5369c25e158672f9e421e9dcc13c76da8ea4d11db2a45cf8143f1d43359c7a935944373cd6f3d4dbf4e1c7e746f9a287bb5ebc1ce83e8ef636c9802700e4476954a908c7105d6889831ed74eee679bf1b97e3a8f1db11fb93bd931dd905a7e6223b415bcc0249c7c79783975360f4c0a1b4cabbb600c84903c95dc138a6e73e8a8f17c74db1c94ac7b8c9deeb6c7720c569ff81268d0b15e7d4dc61d34daf54d62fc3488e98493997715a2f91fc33acdcd30985649d5a65836375d448a6680310ef8ef6619e9afcaf7ac138bcc369b4e5f496fdc3c7adaacae1a7b228f0ed54e9305dea613b953afb0f9d357e560f349ac69f2cb0d2cba2f30938bcb0bbd3ead56a615ee004c8a9057d6bf61644eac235a30449a863444edacf405919a047c32aa4d5b206a2632953dd8349b1a8a5fd6a6148dc443c5a45ddd9b2dc59cd2c6855e1ddae76d34b30826733efe94792ea66f5223c5d17917feea801251c5d5dc6eab1ca77d1c415e4eb430146123230257020c8cb8d56a3c4643d3278b754b804d5e8df73878c549f33fc314c681d23d8b6471924e17b665ce8a2ce6295b5fd5f25dfba149e29c8163a192da4d9715d0ccca3cdf7904e2958b0390c956e405acc7be895434ca38a6176a0e84637e33cf5e8eea197a71cbbc5a232abf6828a937985c8cc2c0f9a229287e2305efc838ec930868439db50779124d869dfabef187a5981859cf320c66abd6dccebd6383e5a2968df339bccf4b1d37f4f9b1dd33bc30f3fa1e149d15e2dd012457a2aab19d38ba442c4c0a20937c21245476b5c110496c82dd3d74183355779e86112d359d56ab7685b16454853594043ffa4ad8abc1a4a1eedbf214b6734d71bd54d6d1682f9ffa2a5d8587dcade6b61376b1d4ad7d4c23136837646c7d330e5d3d1284e86ec04ea3b09504a7be198b0133d4fb1766febdba99aa739dd0e7eb5afa0eb03495e4837b260a04daf921a9e45444824da468357dd9c7df307b36c0157fadade0b0087754aba876896daa1e43a9f11e6a7bb74adfdb054031ec871d27d209ce2238dc3ab928f67458fcaf1e624fc8ae2b1ec53bad89aab0772e97f11b25df8c14db16850f1e699fb020de9abb73c48afe5f4e54297cffa4ae2a4929a51f94a5d05e37bc6dc00888e8f80f0bee44d5822c3180913f84a65e3b42d048b73c09035baa403b2f40d149e7071bc5de94341d0f06d6ea962dfeabc79644b62e0db0fed98e67092e3999e76fd36a9158c8e03d544a3ec92ee47628796cc2031adf8dc7cea0568b11d33d75439a87af5ad030b2d7580bddd0c9542c735c168a3594b1c8a31e24a5389c4e28afb9e0f73503f02f886a37adc21f85fb6bd20356715d0737cfeb2904c09a8c377b927d6ba964fa8fab0a615830ef517728b42bac080dc6be72d27f1eed0730e06bf293623944f34d6c6af48e7db573184a28b314a3898017a6280a85a1bfc9ce97406f68b2db7abf573c4bedb1955d2cf04e44e5928379c934d859ab40148c63b310ae7eead458f344dca303c55dee3dc9b1481c32d64bf3c8bf14f5297ad6944076a08ba8dd5da588ab6aa341e432167f1cda7c047334122991c22572102a176a123478694499ba95f720fd1b07bce6ca05cbab225f2a79daede654d333347993e69d83f4277c12b4f217eee065bf0011b2fbb84a460f0f38e0580fea6acb47f4b974b8bcc56daf8706d25110457d5a0b714b4db2e8f4be83592940d0f79e3a7cb1be123c0551a8a743004e4b9a837d0e7b40cc2fe90f226ca939036881d04b59faceec120964e52a2f953e6d274cd30fdb0d49361e1395ce27a874262028f13b9413041700f4808286cce763dc046b975bcfc3d043761b9ed95c57ecb0999b128c55fd77c1b18187bb8cea2bfd31a2f76c0a8ea6e0a8d1162c22660f85e9514a22053bcbb61e9b4ffb103258c0be926928d118b941445e2cb6849ec11f9b99a35adaca2c932ef25cdd682e7be806029d579baf7a4d2e74242f3c5397292bbab6022a6be5c8783df2e9a6fc02d0c38eee74225ffb3a385584798a68c075e56d93d53c2a24ec7e3619c7c576689867be150b3a5c47a5d0f347cc0435b533ae75d1b7f7eaea4455b1e151e0d4eec7f09311ce3cde7952f51774ddd2a9cdc368e956478674457f1b356aa0e0a1376ac97cfcbd3bcbd1d2159c3b52902f019e6b2b978aa060fa1ff8207035d1060bd252044db2cfacc8f119510c74cb7985f59972e1263a9aaa910e96c3dd66aa49559632e358eb6dbfb480841d62abbb1910bb5cb87ffcca6e59813b22b50a043b8435ad7e3e018c488674c00aee2bc5f499ada296a8b86d5e581ec8de81bc781a00c4a8a21b0fad9857739234979ba4ab50cb7a982e666bf247767dc7ce67ba2aed90c3c3c95caacd2c80e48ed89d4298241f07863b45e016049f6e39822cf3cebaad9649beb92f0e3322e5dc27e720e1f258b85e1e5a13bf427039325c200ae7a30d19f12c05e3bb3945590de0f2fe194c3657be633389af505c49307d1e5af849d4070d39e8c502d785d5b97aa715c75e54cb4b1d66a6158bffc464c6ce07aba1c38eadb1d05c7325ae799b9cf8b54eeee25f60b67309ae48d81db18c5e9d75ff0f8a58ec4bf5c5e160e11968abfca0d44667656d6eee9901ed5cf2337372f8c2118c57c0789f0817d96f44cfd079b5d6d818e2ed12a61a669303127a1b08e52d54e23207c06caef80947e8d76afd609ed303e0c85bf3ed0e63f12be6444bf343914ffc42e7182b0edd469e1768fcdcfb759e2ceb051d64fc82ed07472a711fcb5fcbd6db3709b44f503a9131a14aae4b4265cf74b58f10eb951743a866a0b62093346b445089a3b2644a1d4139c592d250a4be1c139bc7444c0afa876aefa0d4d65754f7d627ec5f77dfb0a5aec976faf14b432dcc2e1ad4602590784a5616990bf36247f432776d76da5aabff8a4f3ab5ad6a96e2761332fb7b1428737ded4e2bcd0d1f7995948e7bf7bde7bc149085ef9dc392f8b3f8d176971e77440c2feac4b6456ce122481c523f6f2def26f7628e5ce2737d487df943afa1f67f3c919aba11fa23570f7885de50878a46f48be8feab24f9b3100e80eeec6f9700e0212ef33ec0a0632e0aa3fc4235b336c6a7c04ba607025fbd48c1daef7fc3951ec49a2c89b7388a5108c239bb9666dd969b758fe43935b3e2670e4efef48b4fad092b2505970e3f24c053a502450a7f0ab73468199c009d5a0ab46db539b438fe340c405df925a69eceb82b6e27d7f57ea3780dd0be40d81463b92321b678aa40b9042320ccd8dfd1de29f0a4e1856499a441e53acf6f1fae7470363ca33f9f875acf66221870d47557f9442c6404e8b131a9ff0be376316801ab376433bf650985bdf8601100bd641cdf6d1e4e31a2bd3a83ab6a6fc2593efdb8ce1226ee0f2228e23d8b599a62bde51a87327cfc949160656af1df72018dfdae771184eefd5d2885344a9f797c5b85d802feed2972312fe86a79a560025628254f192d7a74d90403d9a2bd97f774ee8cac2b2caf65a9bfe58efd60a1fabec7cf28d95648a73a4fe8186bba38a48583c316b72474442c4599329b11eeca5125ef1fc7a54f98c7d96157460af35d136ffa701c46c44034ca894930c2415bd2bd4eeb77652d6588d879c439a405b18889b896faf66ea36110fa1b0a971a31dc136bb61e985ccccbc72cf3b4144c811d4f97d7842718f84bb784facfb3d81fc6d53ccdf4176190aba480ecb7ea62ffc30e5fd98c19dcdf110fecaa1a3dd0e34b34c1add3b9d09dfdb74a7f3500cfdb5413fec5056228d1ae2d4bb885146097404398a6bcb14940b765e60f9ae90aa92616f29651e87888536d3b6613194dec0fea8521aa1aef0cd901554b65ddd9054e55db5172833b8eb976e32b54190dccc6c825dfd52b3fd1b1820c9a19225d43b3c8cf5f19d32c5e639ac378450289bab850b7f351cba826f1e61e467e0194c7b04215f9e1f0d21c6ee002fba4c1bb0160edc9da5551bbf6ea544f2620721153f31a56d94b154a94005ee79e1323b5bbc7d0c02b54ee5f66c1e4e5129d2415565551598b70479312d320dac02020496b9c9936d89a7644aa4b86dc8e2c4eb20dcefed6c89416e3ff3e001414cb5583c08cdd82b4f1813ba3f3267c36db1344d4740f415684d17858e6105a2b8d9a2aa5509863baaa69b00bff5558f3443e7e27b740b6925cc2b77f35414e414d3a6f4eca41585606b07236adfe5a2ac59a4014d1b414529a0ad69431e86958ae5a53f0880b03f5d2007e484768f45cfd0d5b1940d18efc8a10397b00120e70716778c5902d5f3751b155e45d430d5d23e27948bb05940363dd127ba3483876da76a45b28f6e274554c9ab70a0174020aececa784cb8eec1132f91155e43cf31485684a9333ad2a7f0b4d069b3c28abe45471f516a281aabff50e90068b8ca0a111419f9b5a3e2103086feeabd8e3a85bbeb4fe50596395173e648bd8bf2fac7e8e110bbb2744d693138411514dd70c646d91b719e9694deebb7123f5834e10cc38064249feda4556e3c65c0a29ee1a47d4eceae9fd5fd8f3b0e5d39a3e7bf7ed21dd18690eee1e4460fd7804bed0b089fcbacdb104cbefe2b34d36bc8fdc02bf006c7402e32051cb0a9cfda636639465dc722bb8afcb16408669f7e33befe647fc7d2abe78cf8e24d09b2bb3e6eb867256eb5ad80786a6f7034be1a49225d46503d13cba30162eb10e28c1aaba81e023c1edbcde0779b1fce2c15c2d43e54e59d854292dd7594f2c128275e7c8377e8de6263887de9e145351d169ac7123f34ddea2df0c32766acb151b24286e55d59e0df064d86f8eefadfc294f5a60a6ca3ef675f7e655469542e9c9d11e57ecd34441fcda7db8ec858fa45e1ccef6b62e2ff6cf59cf917c79d8fbfdaaabcb1815a54250a0296321717760fd62fdef80a892065f7cc952aa97d87679a16d33f75bed2de61e4245f1d58c166dc2444e7f84b8d270eef856cefb6ec8de2138030e2c0a5994d258ffa1e610440a8d6d824a790b064dae2848e8d0c0d0cc606a61c6db0e3d762be821e1d01e0c4c21aebcf59e928cb1ea46c17e84223f19b1bdb83380034a4dc7546683fb48468db5895980d10fd8c19aab4dcd79f31b6ebb40712e546fa19ee81e6f6e59a2d1e5ddaa6d2fb96c93a809d8c716af22bc8c2d0c52358a9f95b883af1223f6a228a1a82d38251603f5f9b276e189cb0c780d5768925fca1576ae6dd985129cea536d3e91c9c70174080b9e9b3c7cb450b1940a238bf73dd02f6539208085bddb60bc92b9372d2d1bb65ecde1bda818557c80a07b60df63cdca3047c5ed7087dc16f31078c5680b1557329af7eb6d7db9abab13a1f5b14a0b4a8e2497929e710bfb21766929ed6c680251cd0ea936c6cc0994220c1feefeedab9fea2e09476fc0c3f29c3cfd01e2adad7f375c9ec122bca5a1a4046a2b70a433e47ed1cb688c6ed8fbb609d56cdbef694ad2ceaf11edec809d74ab8e3548a98a02977165f07d77a34c4ab346e1aa80308190f02c312bdd620b1462927039dfb4eb757fe7734c855337d9f5fc5d1cf13848b0aea99f291f0544e6e4690a90f783acb731c3d990257c601a84e13b6e2a9acc19340f530ca59b7cb43f4c39dab7478f34b8b10b028260460a9d7b1bd621c7d7b919a527cc46172b6265602535b5ddb0f9060b659783c8a9224c686f946caa81fc9c7fe95497343c265f30eb0a0a5cd467bb326604dc8a017b173f8be264807e6b82b391b2711bbd6e8e19f5ead67af0bf0e40e004643aaec2df9605c6dbbeecf33445b9dc7f2ccddc1f6a40ae88a6b6d59a195212cb9c847bf9de0d11f3e8c75357879931246116ad05e73945dac57b58a08d238ef093dd6881542ca7cba47ea4292a52140449ef9e120520ce0dd9243b14a0c24ff42638260fc179cfe19aa8c03094c0656b0cdcf7402c24a882cabe69f76b29c629eae6661edfd1a92f829435b62e5dcab8235e2bbe10e3f85d81df90fa32cd537da9690f9b499ff99910624a072ed99138c4b2b24a64eb931f41550047369735e4b39cc9ea21dbbe696f7de93aeb402053c716dc01926a3fe4146b10c9e067eb21bafc94c931b70a89a9ac598c8b313b656ecb7bb14b7a5e3725a1ad24aeac59ff56c3fc09375054b71083295122dbdb22b2c7bc6ebbb17534a6592d27a0b9e78bc1ffa718d5ba7eb1717b320e69afdb2606a782f24924e2627e95d8a19dd7283275258ff38bc49059de69cfc5d1112863a1df0e0996dfc463af37152718bfe468a296ccd500fba564250cf1067d70f59093854bac00882e9a034f21b7fe03b41229c01e2b3cc1b3bed15ca3fe6d3859b41291cfce6f21a460f27af1e22991155ec4956dbbc6826ab77f55a6ec909bf3440528929a0b6d4025ce476a7f1aee8742c1d1a997f7073173d17003cd54353bf8bed355af9e3263814d12217691405207dc6a517e95228814fda9ad03497e1b7aaf62621a1757b72cb0776f53f617b85d55d45551d204ba642d924938858052caec05f89f92c769c244addf1511ecbf62c0257714013e76d8c687d80dd6329561b5fa7d3312968e5d67a3aafa512abda2cd03626c976e8b71bbbe578a35743a765bae6a569c24147a2d253ecaa622057680a1a6d0cc1a1f8cd2f8bffed15bb21aafb3dd45b4633c67234246282fb18b0714713fdc2ede4401ee3169fc0aa8e066254bff0f6414a741e265b7689c4f8b4f50679a5fd6ccd9b7cd628610d6f17cb198d4618eadfbba1f65187b3e311b6f7a0638b2abaa96ac175fedf1b8fc45a1f7fe002bd2e89bb76eafaa13caf72543c122f8dbaa4111167c965496361363f06385cc079824017a39e64ae72aafcee4b379cab9ce4ba02a28d71d698e292720cfd1361c05ee8ed1bcc2d9f63753ce76d0d31a5b8b3f51d6ede7f6f7a88dd09ebc110040eb2cbf624cfb161fd24761489a5381655de228a807d5c07aa2469fa75e4d6f86a7587459b700f9af1a64233fa0565886ebf65ab86aff2791529e9f7e39ba10e0393fb8825d6704ecd80cc56d430698f5d12c1431ea22aed41f44a43f540ec4696b3416249550da9ffdd4a47bd880f2e8c59b4faa193f46be46122c0631e679c42c37f9bd8455600f7a604e8709fa83cfb6137f34a954f0581372b6fce6d2d4c3d0d0a3ec45c33fffddcdfdd00b23313cae129a053332acff001aec73021a03a54dfed483f290428098eecc329e3599f0862ac1db85d5fa177e860858bf05e953cdba60014b097e9eb0fae05b86c61acd2c60e2589cc79f2738252a8b4032bd6f6ff1099f3c60fcfeb51240200058b5b86cc11b59be2c24cc9ccbbd2e0775a700843b966d700f9a8e1c4cfbe80112da29aafcd319d9466bdd6ce882671b224b5aa172825fc1afea302cd01a64f2d2bc05515c97d7b34893472d647fa7af4abc2a6756ec5917fb36e58a6e7b7399218aa6e78c69964f200be2ca055b198ab429bfefee7377bd2d9325f77ac725f4943e1005a52c4f28001e002f5846784bf8ed79268f7e21f149d745e8a6613216f6e54c09e663103d0f91c38968e9620fb6e8b88391a88ff3582e050383a656a00ba544417b3596160ae3eb3a583ecbcd801c7c681d20064e1ef18c354adac55c823978d9d35ebe12dd6e602f60df89cba903365c7090ead2ca64e5562e3cb1fd45fc4ffd21996775c970c48b64e4b920ba92d9d311056fc49d4731cf910d04893947423626a088a536c4fab970e56e70e35f4c2b55555ff00c92b0da6d895dc6dab28c64b93fbd4872c9f251f1d07e88c69aec6f155f27135801441a77a65dc7116ba5529aa526db9aa70e13980385023b64c2fa7a51de9509399cbde8cc2c7ddc87aa9ee7109ac695f3105a07879f285082600e3b369f36b11695961f48c180b662814686350219be6ad7ee2963d41e0d47a8a2128afb458e2fb37119b103136561754c3432b4c1a6c274cd075655513ff5333d429d2c185fe1db280944ede1408cd9e9f411db1e34d876890c0a868135e3fb5160c93d33a0538053addc408b7ee9fbd5d124f3181fb34845f619d147dfecbcbc99c87dddc182a3c3c79224f1c07fe0a0a41380eded7570432152d54b18c62afd465cc096d8d178f446af99f35c441b1684cdffa37c1d44fe11429328e91db900e9a776ab0bb0621b36eccd35ca2886314197a6c072c5b01761732940f18f184a6e74840b4aa6143d9a4e5a159cdc813e0ba7dc7fdb917f1306bd30ec8b3c5e6783f5884bd086852a27608e07a392d926e553cd7618b9a51556b60c29ab4a105e66979f4ae1bd768ef9bd5666d3d726ce7b1278313f2768f0d3af917c77c087bdcb8ed2dd1952b646fa4e69bb426caafd74c9766a9af215839a77f6091989319c2a8b247a4b2686cd4fe46df1309cb8fb6d88293b7ed86d427954c4ef994af9e2d1c7f8c04ad45c1ac01eef0b53f345cdc0a114e34d9e5b06d7b1702fc61c3221fcd0d2a72393e0efff69b22cbda8ec7b31c0680f9b8765f5eb8ecc5f8144471e99406a9bd52fa4a70d57173215c7e2fcb592ba762fd6fa72b7211c82a245df20f03e642565635bd7e14294b2134702248897d226eb4fefb24937a6b192fe3153ec3e9a72a877ad4c4a67d0f38919d6bce167bf6bfcf1ac08dd34118e3dfc3f0455bbb5c95a9386912d050f44b06ad18d34cea0f943fad1a530b812d92e34356ed13030214b0d55d70a344bc5a9f630d77fbadde303ca92e264d083998c0aa073faa84b6ceeb663f67b947226cfb0d73e90213e147d12b9c4eed42214fa45105f794ba6c74951bfb7bc1bb088e4031be702bbed04eee5451d44d25305ecf6fb0d6f63604cb7b5da1056e81fd99cf2e567433cb02ef09731b5ae4950d7788ccb3fbb1701876be8de7a6f383955f88bad08d93126efd67128042baaf9f0869d472b096702f23c512d2bc41312ebe945e7861f11f09559fb896bb1b39b3728b8da2ec59b9c1bf9c2a9467b6c34ae2560a05befd7fdb1ec70740e729ece07f6f040b285f9c71cbabbc4441575eb7dcee22820b83c216fbfb8368a3a13bd7a102ccd08cf54ab2c5b312140cb944b2ade413768017e94780dfbc0cd9ebe1e01adf84ce65aabc63861df8277e3525888bdd02c1d92250512d32088ddd74c2f5c269d4d833849c4d761f7405a6ac0c88fc54be24d45cd56d1baf19fae0d6250dde58af54e6b07020b38a6f8afefea5832d591ec786f10303256f14a8da17e1220ff537f089310f8051706db8e0dc09a32e820942424b8b1bd89fd3c458f1a5e6fbb895cba71765cc8a60c317690bd46cb815b380dc2b262b10f8395c47ec25a80031df33addf2f63ffa7debef56e09ff33a52a9b3fa8e319c22697637f344c6ef37cac1031f5d31e77f28466e58b59d66279eb122a4f624ef6821800e8365ef4e8d97a2afa2a5ae9e0facd8262d6d37d60dd543fc27c3d38b41953e6b77bcf46b6e4b13a5b8eae4a083799054c53f9a43f9b4a520f8abbbec87995001cbb6e8ff98986902ae8c9d104a4a321edb539ba0e0b6ea4b0dd882d0fbf7e4d0289f2b21a5c0880c0033a2f5c25645cc34edc8641a68bf033282df7dae37b91553a8fab12d8f65009d93f2d887db742567ba9a8441845d7056d451732780d803c8d5648dd1a2dde0cb9b9d4864390e946bffe05740d03e0d6055c80c810a59471af64efe3832642f04476862020b698b09f4ef0817c8def602ee372a46fe5c68fca7e56e4d5d9b9320a0bf22d20ac84dfc4bae9ec4c6511790fadce4d506d8c23f6eac15665150ffd8dc5bded223a66189735fe9069198ccac03b1a9bde05f32e750a3dfd5c1abb0f182a1201f16c268e031168ff2a4454b8e06d48bcf40a3e884ad733034bfbd9c1c880a23756ad2fe03ad54c65642b29159bab19b0b59074d9d8e72b7d231fa53401acce206f3750fcc9bb7240ee4ca675a20f0f9540fc68fad4d0aebfa1b5bc7ed756c92d356a6bbe939468240231d9a021293673573712a0fb932cc9441645ad28d1592e7351bc9ec8784eb5403251fd0682986abf8ef861c14aa0363d0097fb62e03e8d726236a88180b3fdf6d951fd0d8087dcc405ae5929620c3caf2c19709d35236e2178847abe510a3be555ea3eba5f961a3221763fb726479850d43faf7dd582d706541e315d9182aefa3323a906af90144258d225ef773ffd8d0acbec33b4a32a12b01943984576feef08a8e42d39b216929bb449a51737ba9b025242642135471c25474f876ed1f14348eaf48f8846ace8f8abe4d862023347b993bed537c5d2e3f0e54ea7addd7a780d521ecab70e8eddd10f9a2538ad037387af361bebf4084afff7b3e5b01dd43749a761de552b42bc8fbd806ab88f9bcdfa24ef8903e68382db7342dcb603ac720ffbd4dabc5f10ae5e5f6a699c82cd7d0bf5bd26f9676aaec5fe22cdd1f96bdf3d947c9ca8fbf958c18c20413db0a5c836d3b64a2f509a66ccc1363056c3d7ef10f342de86e00a0fd3884b345fe32d6d9d8f7a254eaec51430423d225b0ba8bbfbdcddacd33dedd5d217bbe57731011cffb093ce5f5be60c574d885ae217215ef2d8c680fd761de0c7c9f7f88ea06680f92d67fce74de0c902c2edb6990b7b00c22b3831b153f05fbb2980331c9c07ebcd226e8e7c4eae3f90b54f7158d65d601007ae6dd1217d41c69b81e10f872a3b3eb15747b3847536ef3887161fddf34cc37aa29bb75d500a72c282f7ac84ead9a9abbe642e07de97ae40abb5c1dd8300dd35d62162a570dcc79852214049b5f4fd278971a8eee270ea33b430247e4574ff9db753c8f1baa0c9c897ab6e80455e6c76b00b8dcff18ca329d6875465859caff937da137d4f1973cf1caa54149519d669b8ac61a42d95b5bfeb2d5c1804bdb1253e1597f76bf05cb2ec50a5c3ccc7f4cb66d880319ab1254bbcaeda896975c882b055113b5e8155219562bd0fc55cb1cee83e43e190970fa048ef7b2aa64a8f6c935bbd0c71420eec58a41629acee2128424a7ef5400c4f6672e5c895a013f68b7ec1e126e79464223e768fb073449f561f31b47d80677b90057016fa95a8e5df40bcbd5e32fa7acda1d25669d1ac50be82411bef2b3b7f8d6fb9e823436adc8db764ebef5c65ea0c9dd7b3ad86f9e38ba902af7b54978331606056819d35176801c2718a0d1b68716a960d305fd1c560853b22d16e1c9a41ec9c8b1556d62851d54a7e306d1fd428246791a39f1da1fa19951d07d6a38497d2d50754cd4ea51f9c0321b310f8ae59010f744449ba3e05c8b70095e2f58852d7092a4ddfbc1e9e565cf250210b2f530fe20072fc29b9e8f506b462b97a3d8ea3173db270493ce517a66acf4457eac591c45724b6323872b441aeb27ed5c3b268d6e4fdbe5a40288d6932a7cc739c9bad7d3867bea99245de069bd5247144af20c1ab165040e3365d327cbabf116db82f32ac1131f67b99a66c241440cd305be3d271a17e4cfbe58e27cca2891903fdd1729a4fa8671dec94a222707d5f9876767a826f1ca48725ea496b1b8b6e3befe427666b0830a363283aee252c8eb8d2b601bd17ede523118cc97fd7f89dc300525556328905b9ec11438a186b87322de449e55756255761276a2629baf43035b9f78148744e034ac3aba5a28f40100ecca1d1f10f10a92fbb90add0c8090d560d4771e8335dfb53d23ddb2d2ac9a4a724501e740fdfacba1c5dd230a4062a8ab6eaf6ad2e4f76fe0264b32e099b24bb5ce26310a9e1fd1ae77bb222ccf1a38764ba065b895a1afd4bf0a91bf4bb794225094e98dd9ccac4d2b9a14281d7ac63732e0868edce8fe7f2452072622866ee4dc315b8352c271a0f0643bb084eadc146460ce00e1f61f5f3d4c4fb3178934cd29a4796ea4834068fef9420200e5401f42dbe3c2b9f24f26f2d206e8a7260925746a89a742fc1b020821af925b5175dff4ee43f484bef7b2fb327f500013adf95354623e4d6626f4c2832829dcf4f12dc89a4973f40c2b5eae62d28b4462a329fa8782b2e4883345a180324e632a7c7d38a247e715cb1e4104420929a4cfab21c5b9293867b2e53779d3d4fa0029e52e5a3f9dca38f8bc4f87c8c8d4806260cbbd4c29037c3a02f4a2ead0b58f90a4cf68eb4af3c2b7348a80c1867982663d27b48a2804080ebae82a29656a2d1b9bf4d60daef0f50976ca3ec2d6a5b5f7516ef0b9a7b1cd8e59550c31067462658a62e728357a5b79dcddc9955643d119ce8dd3706d6c8188227328589a8f8eee0bbb2723c7e5e8d0677c173ad8b9816204dbcad3084612d97bc70a6713b29852e1f1624e4d949f102380a4564442cbea49663e2e2e293a2b83c2bfdc03a6db6026d1eafed517a8d075368f7ef6be05e6310eef335cc3dce7547c4c5772cc7a2a9ce7066547ded11b7e9ccf8c72f9a5abe7465b352ed5f1d80426caca8c08415902985a81320c1c9a7f452a8e065ad6e088b004a0c7b1cf95c795db1a90bca80dfa78b2b1128dbbea3d4a771d28baa9ae10da58a82c7b795e86457f51e468087883241447f1a4c4abac95cac856fc58411d0e65c2157f5a88e15e64b0cae16f46cab87ab1e2023d25a2c981c4a197e308257fd7c92ce0108d0cdca48ab49940e38feb8d8e5a79706b8e85571750a70ad75b33b039aa3a711c5bb74e67d52f47c45d49f60c60f4c9a584e8f37d5b074147903bfb03a2b7676efad7ed4e83935927d24321dfd7a16bc065b1c62fccec95c2d6e5213de2075f7402e09a5857390793aa05e0052c08065bcdfc89cd0f48de4f5162b919c731dd05a19ffb40def87ae9f2ab8e5daa5d41e683a2164852efeb2e30ed464e27cff0d3cbb2078d128ee5c3fd5567f2a75786eb1c6d5b8e62a49f346e5beb2a8901d0161dfcadfd8176f82c27d57e52ea916e63f8d1ea4f4c1f4edc219229d65fd991bcf24b3e8c7e6575c52f8326fe4d583b4b8cc3fc43ec5bffeb99bdcaab4abdaad1efd8479bf1f59c86093b8ce9141eeca4d6d718ba6ae2596a6ead701108cb52ead78231aac808094317dbbe205c63c93d2057dc6bb2af1293e6eecc457461ba72140661999c012b3d49b37b1d015cff5fd13fe41a3400c4374de6f1fb0dced95491d128e7f07e872a1c932fbc0dd28adebbf6a3877580bee9afbfbebdcacc3315cbedaaef6e0596315903e0841cc2ffb42d8725806a4eef10b23c844d19a1c3ce07b391af3a74161c962a50af6b643c8d3bc90bd2b154c8e8a4df4da4f95b3e6408544839253d7ceb0b5b9c0b05e69791d13e2431f2be2caca18673a31ff7d575b931de61b2da74b168acf547a73a2e47befd8fc3595cebb60e2182f13df1158c4b44ea80fbcecb5b75ce213149ffd6905ca619a322660e3a72e068fc07b04683e03e574267ba3132e1d0a69123eb76e5c6d60b30b2cc24d292165c8d64ec7554040440c5acf6ff8a7bda25932291a00ac073a3d12554dd6047ff2a7e3d03a70739dc63d107ba5f275dcbd47bb9a2cae04ab80350b4a315cb63738ddf44be98455f3207ac1dbccad5480da40f3561022c2035c39d8702ace3ec644c2ce1d1f6bf31cc5e1226adca71acc37d810485aef535f18038f38c3a35f0330d43683daa4b632d7d9ca37184d94124f11762ee8b61f3583a252e847bf99b1044c24ce4b8797bdb30b38be7925c97325180cdb41f883008c18f67ffe7729941e24346121c96b4725d52b00becb558a724b15eadaeb7ae31fd9ad9d6f83b89d6aa0ff33bbcdb74ea4c94b2ae86e8fd2df2247caeeed8d3e1ee5d5e04e57f8d1f2860f1caee296825f458b7c1aecaa5cd929f1bf332b26a141327228bd5914aa3d65863f1b861fc34845ddc9aef5419916fdf1daeb3a9be218f3379a193588a69dac35dccbf882c48f9520e50f0aa9880ab4a3469a631d16c98d61332ea1df3822715eeee632ea00974ba2b1e8b75ba7a9bb064a2a51285d3356899008f902ddc38a22e0338a7f27b255e16cacbb4287364c0e61d6fd6c6679e04698c2a382f832c00308345693a35ef2ee78e2cc99a3cfb1c3655abca2d9449f1807e8701c55f082e7ce773499a3711d8f16093baadb686af875a60b7f28c1deff4cee3d89ffd2dd11bb48178f721cf0b0f61b5bf1761efd74cdf23360e4e744a7a9c5aee471209953960987d9780ab1307a82cb0438b45cf960ea90383efcd7a04ac43bf72523f28bdda4feb540da88442c9e1e03764e3b791dd26cd4aaafda9148b4bc1dc76cfc8d9da2a4705eb4988bc7b5c3e13ce095a3c6abec1a9a7b59449ca514d4bb0a148ef9a480d58ed7ea79f8c46e5dace0aa2a32dbbe1b1628e51c50905cd5961abd8d9878480f5f70d134cba5e1d960b9e50eb6a07b3e508262528a583685c842b57eef9ce389146b26343eb66f78fa67603bfb1fa5c3facf66a1466b50d329b30d828623b58aec71d8128b51051b3e14e28effc4cb158e4078c7f85e6c2f198d0dc4caaf5a6c1f454328cfb422189694dca181bd45923b33d1734acb49949a950fc62386c43336ab3571a15c4bcb6648326913561d438958024207531c22e73e5652e5d56b7734b8296c7089a6ae2f95eea98df709e1a0c1fc2e4a3a37dd245a84261db5fe363de7bad75db53fc924dacc5b81f8140c941fbb2e7b80ecc20bd8c736c5da873e16fc60c231ae9250c70bc6b25c6f22c325914e8fed4c7d8e419e0bc52d39b2937cb9acd39c2738316f64f61b5a415151d1c7a2a0061b2464c74fdce930642885839e85c99c21403fa553b6e61134adb80e0e681c1cbf27317b7be896a64d004e4332b23d6eb01ac5f535b9ebd39cf5c9029ea041fda002c91b9ac4e46a91d6f0ffaa7630c9d73739f4812b72115e4c03285ef48147d98fe32ff1837493091ef2b8e252beb4d70ecf4cf157ca93f10d46df9d003f8800c1bbefdcd69f00139ecb9f7ff342c167a887e648ad3c6ff1553cf10b02d77985f1c747851309fe4626498563223257e0792161916a899e0e48614897a31d2a53bff1daee9aee9b3b1f50e38752cf90a163dc4fab65266913ab024a4ca25aa55af77726a149ee7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
