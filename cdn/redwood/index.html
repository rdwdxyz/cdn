<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0316be9a8888b282115a827863b2ea385d262d219fc57dd992ec6e85660e66028f55fee28ee650f617d04540a7764e3444fd2ab5efdf7124438edf8ff62eebb73f14da23c9f7ce0c66aeae98c7f3a85b010c8ed94490773894cd17a92e15856e88ffec469ca79b4904c4b5d50b2f21624546889066b09e0079f5c61391622b890215aa466127d0554c8ca518848f3c81077124cc5bf9389b2de12fcc35cef19a1c3df8cb9e13f282a9ae1ae1f2375499438862283e9ab23ce919fe27fc73a455542ae2c8edee840a174cac440adaac92d92e6443b293606d7ace98916757133a5b715e87112643754e1ade0573304e0541b353fe342d0cee51665015b0bbeaf869e83cebfbffe9c142170e3238df1faa7d078275cc75484dcd16b3ce7a5b3d6e8767d92ddc2eb6b8ada0f419aefa28cdbd20a487ce3488aa30bb060ef70a18a69a5ffbaad153c449dab57ebb3ffabaec3331933e1e660399aae121f4e5e0d388803f3773463f7d95fd5baa210e4e0209c4eed24d62550c77e87b7563081c508fcc564b643a22ce18b8cf4edf1dd54af4c2aa3df3a2b4d35e581a8690fba693f9740a3dcf6f4a79b4b61747031da288e38763fc51b81a193633782586fac35e37d5e2124a2013160491dfc4a6783252c4aff2eb61f78af55205e036ef4ac531bddd6d97e0e630aa6323f1abe2afd4bf38347eab8a6bca70665340fd324ca385d89f7643236b714fa4c5e43fb6647a784b8f897d8dc1d517320225cfc58360227af5ec1a6b4dced0f63e923085bf5de0c3b35a85f03ca18991771d35a0498ab91fdb269e8bbbca8282304398e2d4f5df8ba7c333d445ccfcbc8bdc59b4ceae34797f11f78ff2789ad087872fe21673200a0ba7fa8419a9de4e9da1e70cb251595a0357c30f3f353e995af9855b36ab5a67f6d974912793cf79867fed9d46e2e629e10c54ba79ba6558276ec67c063ddebb012aab0e142eb9a9cb79e0eb7cf372598c0690c4f94e157fc1832b70764b4890cee36b7feb8bddaffbaf482f8003eaeddd813f1ebefa6f3d19153fd36f9d06de73b27d0fffc6aa7ddfc1cd174d6a2eea9efb5cb8935e8e0842f95f42fc5d8e44ece983fc59c762ef096c239e67140060d15b1361ca05adb2f6910011f79f3274359f75f00a671c10845949ef78b029ae644153c16de5fab590057eec948318aac083c3ad8cb49fde521f8311c3e1673e8512e10b438dcf20d21f55702ab95d735e424b3d1c3760e3d061a88ab378c80ed90f946dce3c82837e67068ae004aa378c69efa0b6e06452fe482decab442092866f895c563d41f235c24ec6f74b0c9f2d6220d5f52f7a77d7a7a3eb9df1bb69981a2024ea045a5d6b9c536259a18af3597d08ae7e3b6f5a0120b0947539b1910a3fa679f867deefcd16c3cd21e31c43750380d20fec725d0561cd531719e8f233d31a1ab385b81408ef3cb79585c220a08e895e07e12551649c167c60014945b0a0d2e1e1d08a512cea03f30d825c8e8a00b988194367f94b11aaf43e98f2ae98902cc760f427fe654a587c6d229ed8bc8b1185d4c96044d47c3ba5e458271e153ceafa1e500f739b7578adb8dafde8a1f535c8a04e3753b45c81a8d21a9da577b39764d893615890b85d4ce9b2f8df4f57418d0dd51c86797307038137b888f7c57a1545592261aef32cccf64b1208234953a92b484883e461322315391e2767425950949d27eebc57b41dde1421e7e35b2d0f3477251bfa007b3088c8c26d3b1a53a690a2fc982cc1451776a1d62ec71595c573911f02f45173c478814f6d2f583b299e10e2a2eddbc5b373d66cc7f6610d3a7c8aa3ce04ae20ac37773b38fbb8813610edaa810b530419413937de0fce4cba2c4a474bc6aaa684a4b4f61c392316a8bbc71860fe81f083800d8fde970e8b1635bcb226d066c65f29e624649f82758fcf653f72cd2bd444a6d9cf2269464ece81dab9d1dd77c38eb579657211e86ddf472cfe4da127e52279b8511229d6de30626b659603afd76a3347643570b68390dabedd270dd916e417cbbc5086f19658415c3d39052328dee423fcda9324439a644451e7818a47a061e8cfe527083de221cc843f5a39cf41db70c7c3e6fcd9501faaefb16502a68ad5fef8a6c4fa419772a412fc377c5ee1f94e7e1102f421505c847682d33748c5280c825a92ad53dc430e191aad1ca3c3f48c1dee74a24ded3a157eb9a20569682674186389911bac1498064f2290cd65c7dc0d9da4b5fa6e012b937a85d17a1ac10326a7ac3eb37bfd2e6a726336776c0c3235239c5bb1b45c3c42c04bc2a2347091d29c852c32f112ecf9dba96621b6f855324ad2287dfafe2ccd34bdbf080877a7b9c9fd894b5ad3a454bfcc637cd35e18ea7155dfdb7850d1d258e997e1b09c4f7f279eaceed296f2d4b52f4a35eee6518f38bd138b6233091382b7fdbf6ca3c529e20876429b0ea647b6cc2114221e355a5149c1b27c4ba70045c96b82daf4b39d473cefad8b5f424b3a7d2b715ddabb3a71d82e9b99a951fa6165bc1fb0c5fccd76f186d905db0818bba90b06e88f70397f967a9e72a38389dd929be56aab1f7d1b814d9bfe3c420a937deb4e772617a0e383520e3958ed32c7127faf2303766c976dfcb59b4e788e6a10f935c9219dd934f6833aa35ad356a15d6ec7a70c8582d68210333ac98af34de67dc30bb1a25abb83bc39e64f8847b0967267219f26de6de28e5dfcdfe63786049839feef1a75c13d264164cd65996a81e710e8d896f0d6eb8e67209fd90443d446bf7edf7b663217ee486df2ddedee462d4ce07a706d0a72979cd326658d3bca115dbd707e2d15df5c642e203a5c4ffd9c0aa6c829471db33df3231bff09263e3315cc419dd56f2a99e6f7d9a88abf9492fcbb1c50f15cf2fd9a96633a63ce202fd9b902df0cb2d25c4cf8b25bcf449244741d415c2e435d42c02021928a43fc20e3d694f37b39fef4090ee13cfccc70bb0c702d5edb452fff36260e9bcf2254166963f0d7e26420a0532d37c83ee3275ae6be9dd68c5d0261899d8e9e610494e5344f52f93f61f9ef42bd9fb916f65d08f1f173d14e52e41a6a8a05353de6449e1291dfcbe28fff39f66b8a0a7cddd5d581242cad60a5b97445e32268bef54709d5bb9b2f5884b1a5e7fe57e03ea8d92e13a8150a7eb8f9023643895eb9bb3556d47e7c72715aa13360ecebe66533f2a96263bae0c6e8bd0cdeb9cf1fc5bed619e477ef07d818c5c77d4e65acb017352ee8ea113d4b5992b804cb9fd803837b727674ad1a56966a3caa4b2a79b93a0f7f118976d7ec0ea41d8d7b8e41eadb20f67a576ef380f1f068894424201c5e525f1e2b407da97c4bf92619645220b422300e469b49f8ed87e55222d055304aeadbd8b1554ae832b393baf05ed6d2839a5fe5f4fbae4f8bbcd1acf18e8bf4079bbe4d6c68899e929dd057fd64a621f8210366c9f6d4b9692d2894be14a9af1a8821c70219c115c1e4452173162c21087ccd7a1f35d988c2918456786260180839325e937b568a52a03b2faec44443a548ef83853c94ce51a23c8e88c428e17786cdb1da7b0ee758135d457e3c98ec3ebd5689d765d3b648446a5c2fe262635d79fe0d7de20774e320d1c99869c34b6f71331550ae5976dc2ab07b73d13fd3f4a0a9496cec09d4ada51f0ea785856db74eb4e84b397375e204710b65aadc3eccdd366d453ccff6e2db95390020a1da5e9a9978a3c32054c51a042b169f6a65b2709783cecc7c179400d76a2327b258856eb82ede57234d73977462fc9b452d16aad4520eea66d0e863a191241db32cbb6f62f7a35c5979114bf37169e55b64fa824df714cb84f4e183cdecf79ce5159efc6f69245fec7a9b878cc523bc3c4d05a06053a83d1a8a988319c257e1b41e751b9335bd1a5a5613af0c08287820aac505e4e1ef670df23a0e05e54a25d426c71eb533dc974677e46a2ea65ec93fbb9ecebad143a6d985fe6820c0d85aa0feca703430ac01536d845097d8ae7be8b293da01184257c2a07032a4037f9c7141158f4e17d1a86ce5a140ab90964051309a3a420a282e245e24ac854142d6a8c0c9417e600d232662a30c160e05c9f091fe7b3d2ad8650c066619ae4168a58d9a2bf4979db5d43bd6df4cc4b876812760b72d07528f7062b835135940afb16bbb75d590b20de1d5cafaee9b43448f31125cd76b2f73902eed5f49bb4182b03f5423240228fb2ac327a089f877d13b523c1ca6fef3091429d71399cd163c28a5d79cb09b50eec23e214fdd7fd1e6d40ef7b176da800f04d29bdf2eae198d784a7dbe9bd14b5d991103feb7f081efe6b79d61de72d3631f986e5249cd746c560c27965d91bdc5d81c341812f554d9dc29dce78e776d73280966b467c5d63265da07328b7b7fd82a941d325f952f9dbff8d23712b90c4db9f2ab4dec36169df3309c9ac342e1b1b34c982fe77c66cf427484897deef5c078b91c8c5bf9f863937bfe77b5ad495a7a2d51f1852f5108ed3d0ad3485c61983de95446dc066e66b11f3e3711d2185309eec2fc996bf0d5c442d38127e2476dd036e770bd8831e94bd0d2a7604768c321251183ecc72016f40babc4d8cac34b58d86ecd5063f0a59774c30c39ca19dd24059fdca4f9aadcee435f5205207822d63c00b558bb654e2f1b854d0d9302ef37f6f7ecb0e87b2ebbd6b4ed00824a653fb3f39b3a715dc60291db5597aed8fc577cf429a219b428cd9e80a08152c27d9d88a17c1b7f5580fe7168bdba43da0c915a3c616c7ed1e6e568572c38740929ebfd70df617cad19473979ffe6faf593fd3e563cefd806b80403a871960cbed54ff1e949704e1a107ede70a96823106fb9f746f5f8ac7f67d9084cfcfdf03eb7e05ca454657bccdacea5ef40c28bbc687ea57958f6bea72f5a328de7e2cab6a1b9aea41000f83d857af8ad3c96a0f73231378f4b307fc0af9f9e42d0af2d75159d62e546ae7b7984553e8915c6c997d94e68a0826fa130b281ca6abcecfcad904731de458a9442712703ef91bde56bb27f335bba442675fed393bccab970c16f70b4a3b8fee4730b4817628738cbc2006b0316c7ad927036e6fe3adb597f069b7d16a99221b707abe90a625230c631dd5717a0146b7bc636264f55098147c36fd25e1d2b15ba29459d3b15a7cc1047d6b574d186c2e2b7047a2fd23d733d3c752cf79a0c06f19d8e9e3ada2dbf06d921b8e43a3c06d9e7fa3beb416b0ed0f3adaef08d5bde2b4d100949874509ffc8e19bc42a384c353e035e49ecae3b2a63206116fd684fbc40e11089f13594b0cf3563c5cdad14c7f016b63fb45bc8f293cc8ad90d438fdaaf2b30d6252941bab7180449a64a045dcf0793ff0f74b7b0a701f4f0d616383a5e2ead6b502df1a2fd913a5e1a968393fb618cae9aebafa698fccc0a4101706091bcedbed18321f64e2e0e91bdc02d10cfd06476d02dff2a9aa1c5a0a3c1887e4d70285002deb0b2a51e4f7aa6cc5f7138726dbb2e03ba2f2cd26abd896851b60fe29aa86c2f8a4912f1fc4044742bf7e2e7fef240778665a419a412584a704f9dc9220b26b961d5c9d4415d29cb8ab4f4418f3e552556c66aa566ddc322f8f1f7c0706daceab83acdf14029aa3779f591cb84f6f1876026476f283911d35641147713dff9238577ca4fa32f9c4232b4ecdf441031298d436bf9742cb815d7b0e9985dfb2ff98849d923b6254b9f6b3ad420129fb8ad0c865aa2984fbdeceb37b8414322e4b0c1b40882569354c04095f5e3757212330150d63545ff741d873112ff9b3c84f4828ff1940126bbb7513813ed466a15e97dc68e9df422b3dc1ee225cdff9af4c605a8dfcda48f18bfa9e4c348e4cc44056a9c92e1389785a6cbfcaa7cc37641c7929f9886328d8a2b33a5f357cb947f2ef983196b7d79281b70cbed2be8a2560ff20048111c74aa7d10fc65b5b29c845c984a4f9a1824c40558e4b632cd4d4e908841bb73b81342fb3d10c73d96da844005c5175463711d21e6484e3c99a8e584f6b5555197394e43ac9ec4ff344e35e1800ae3944d4ed922bb6274fba125c59df121b91c60692da4efa6f2531f0245dc56c03f54cd4b7c39094487ea22b9a86cdb198b6d09862224893aae95b0904d5428168b64ec52a5f753d7227844eb85d0a3cc2fd5fdd47fa282a000c21e80cd9ce6303db37e091d37e7778c671f27870fe5e810fe757b8b7f1cf5e981c3727839b03b0c06b8480cf82f47d63457d8814db819a3e83b3e61c18fca151bb178413573faf7dfc9f99910bd45a7bab7e8eccdbcc98ebc2d43c4219d4f0ef79092a70c613fe66f3563774b588f3d9d354e8ae253b3d751cca8f1191808a383f4110003e97ea4440bd2e2e6f6b69848c0e7e35ce07c1201c4a11f75d25ce95a452167c38dd0896793936e138efdf6a3575ae2877ae5aeadef76a8b93bbe19289e782f5d5a46ac8e093dfa671008b79943071a93428d0fda0313cadf015ca8bd9904c7b68d3c75bb8a6bf8743a1dea4ec6e93a669a5b4d89665ac9c6bfc1f8eb79a25da4fcd45c9856cdffc029df68fdbd0a6c2779ba79f9b4f823a5ced24b38b17ce1cd37d7c85e7f12e2126c792e23748a9cfd549b58d0aea5594613c87a4002fd42e2c520b0f9e3f900bae9241a5865534544d2f8eaaebd8f7188c54fef605687c9f527eeceb970b9b84e79ac11067d07d9757dc1dfc6cecd87a02ef95adad40385bcfb31689975b5ee472e926cda6bc446468375de77a810dbeaed0a0c197d8ab0f81cfbfd87840962185a8d6ef176543536ecf798c4891a790c154811415ad6e44ab9e46958e0be48c9f400ec126db7fddd1b6e8367dadfbd7c2c2cac02287ae5d859c588f652cd7b65f4c73cf600dae9907676d223b24476704fb799fab0d454f7346091ea913d58844bd5b826598e53db48e9e88d34d7f947a400d1a87eec2223a96103da0d11ae92b07706267d4d3d0736f274ab73f9a4f5d3b0cb6353b8778cf0fc4fd542cebecb836c6b6698920c3af13ed583c0c1beaf549e06968d80c995eeada3453c08656ad78b568586882e652b1dcb3dbf05e30a6785781c25e61e03266cc07ed849029633f33f6f97a183c66db3a64943f53a213c0a054ab96a569314d6a0c3e2e0df1de81e40d49bebea96dc8bc765345bd5130fd0a5b98354f99ae259a57ccd31bf11fefe6e9951d5706a0581557e21c809633663074eb779b0ee16b1322ba97406547d2cb8ff8a6c2d0a4fc0185fbfae89b772dca7eaf98daa60bd0b57e46ca61d34684c6de0af4949ba37a2249c7870d8b98689f2d5647e601da140e485bfe964d0cc923e9037ea55e07f77cb0c0f7b4ac9d7ce7b1845327965349fd84296c478d028e2b1f3b6a3994c70f21e015a164ac748e6774bba02e09aeb6eaef92cbb9b2552b7de1c32d2179170885cbaa0a4343ef4b2863b3a18779f56d83278e8b8a04aea8802c6c1d362d6f4a7f85b1497428aa88eb695eb7009dd3640de028e7a7f25968443d2d663b3c773e7402b13d34831e6bfdd900005c17a019deba17dcac94e7cbdfea798e7c17a30204a94047d287f975601c28f49bd4ce33098dcdce96b38b1e794be6cff43ae1f48dae1244833a10b37cadda1cf85377b0b2a8dd12174a5ddf084178dc3d8d4d938bcca981f0c3028468a0c9b45a9bec884d8daceaa5af7559f880edab5847e31ec4ac0985463f2ab8b5b18b91027f387355936161b572af461f3718dd6ddb41709405e30a59f98c8dc9dd62e935c9b1cfc99e72cd7c284b02a6b00996ca19b5480b98bd86207007f576a353ae475e47df1aefc9486798ec95f38c09c91ca99883647e70fd717e678f0ac8501aeb22f2df0bcc343f6806252491ec540fa17f74c805e10414ca0d1f1dabdf1abc417e6cb142cdfe503f66caf933fd7c6512f3bc5e9cf865377fe7af2d14b639d0f383b21c715df183b661ac7a80c5bbdc63fcab2e90e44a8bbf70b164e76f7a75a4e902e87242d91903ea8ed00935069486ac4bc529ad91ef7d4e776b35a50778e63fd90b9ee494ef2252c30794b1aa13868b69d8ad60d2fd6735aeb6163d881d063d2ae15e917ad9ef9dd2dd47b1dc03e80e70ff4818cea0c2abd0c2b569d82ec65dc5a95950c9c2c963def4c5091cb9164bf939d7d05b061a570906138558bb11b7ef82af142683c8f80364642345fecf2d77df2fb3a3cf1f8e1c548ab8f472c8038c2b9f87fe594a1250a8198395de25777c9fed4b7d293c218e9c158382ccd8239e065b50c81b87c4603fe50644f561510f4ff64595efd363029ef989ef53add1e0b016749c73bb55921154dafaaa4312e5f9011a97ae90e1eef5a0d6a5610b1ffa98ca9098f21a19cdfc0bc294e4def6447d081525ad212c657884e0bfbd0cc1ba94bc571a418a9983970e6d0cd58e82032d31a80564a043476cb18b6ee8ac8d0e5dea61aad94417656ee619f61f855f9e2869df1fdc9beabbc3133bf452bd51190996620624a8054b1bbe7e4d2873ec03c2a9fdbc301299b79da2ba234e45eab590a3945ed41c12dbece37298b2ddb9bd60eb043eb357918025482016f0870c8a0db5b027899aaf69b7781cacc7592e6fbacc9736005c614ad7baafcb6005bd2409feaf11271d381bfc6da9599a05f9996b7befb6135bae0bfc52266180653e0a49ecb6635ed9fef6f349ba1c89f5ef72926cfc1b79d3338a3630e26b2d1a9dc17eaaf22c6ac5aca7b07c7c4b7bdecb38fe3acf817994849dd820c8bfcfb47b618d813af3662113bcd256d16ad6602eb395dbe5ae45ea0648ffbd2f15e61c9935a35c9d2909b66c29facc4002c3c633d901f9ab01a63111e221e89f4402dd7670ff3e8f384f4997712c2d75b648da0d686215c06f2f012cc989c3a0d3e537e8255c4e3f816df83cd9b3ba7835e5962ff3f56e0b8c4b486dcb1a5ebdb8427132ce3b569a85f9d4a965a43e3505e8e27cf54c7a3208837dc0f134cd8f44e79026163131f99bdd2f47a2b9a797fb27bae3e9ff98eecde53fc370490a4271865f9a18a59504a2f2fcecd295a63db941b2ac5b8cf69f1ec002f9704385eb3d898327c2afacf12070297fe30b8771687fbe07af15b443a40abb907a9acf2cbc077e8c11c9919a08b5298dde0562e5e21f3475401c241fd9d29f8fae7a5e7d1aa0441728163caac312494d28292967211ab9c0df350b0defca05bf456db486dc4f524c3904546cc6fbd72e0bb1dc5dd99af97b5d0d3f0c5090bda3f8fa62316956cc0c34c8bfd2f3a3399a18740aa32012f917f56cb73cf0b2290f0e411f3fd667b08c94ed6d7edf25a8ea0984ee2580ee63e4260e636f575175af725de5fa810a767520c6e74814ddde6418ec44bcc6b112dde15fc23168a5fb1b7a8ab5a14f5fbb2d3080282cbad4cf2f56bb6d78d71712721994262628ae638f8dd85b981eee71b0d9df5c112a86b80b5bb6b0ef15d47880dbfe352a7af024e59be31380c67c2fc37d588512b11072627440b7d649339499d4847f7418345b84c03d3a05e2c5784e45fcb6ed6f5771d9e0d6802b8d548e0154f4dddf0fda074241bf5f1a0be96a3a69ed88e35a1cf365df00ab4035c1f9645d0ea99c1ef056e5c8180191e6d16217d8fa9d419174afde1d43cff738a11b59df51ac93b7e39e60e12dc93bd30a1ae99aafec3ffc78bb37123a1fbc529e1ef324cfb1bc2b86221bb9ce6552717b7b3f63fed83342e64118443a9d877813c32a607e0da63a5ec3e1d0882e717acd09eb945f819671f9bb2ee4057534adfcdefdd9d3f48998cfbfe836dbf38e82f5ec3a161ecddd81d15853d4fc68c14f232813649878ed6b76d3ad54e8d890fcd632008e7d0b677b7521637f401988b5d84b40918bd0c8751d49820bc77492fa7a9ca3fe604f0469cc959db34825374a6971062730444a62850c2f2b18af7acdafd58d1f3e74ba1fe56f349b91f8026d0c84490d20db50792abdf566e92e886a5c045f8658bcd5ab92e2927bb2927a8edccfcd82480727045e8d9af1d082b1df65cdaebb3a033387d525374941653df9bde96a46438d1d8631188f9f97d28f8db08fc20b934dc529655afc7e530cb682b122b693196e909b367bb226147c4998266e0c196bc50e78649b22eb780d35261fdfebf1ab6c01b27dc3a5f8a804258be0255a807c0733c14ddff5314f2c0053750ba0d0feb885c1b4a843bdc2a853ae26d9700903a28c977fab64d9a36f27da686c25f3abcfc5326534f655212f59f810fcd3db2718c053d59660a4790dcaeee217d9b98cb898a1d6ff3dcad09aeb1cf624607268cd0cf721558fb52e1f95d8c1e4de8345429fd403ea92cae483ddc72b66519f21c0d0c533cf17eb8baf02ee1a434d3318941cb21659060e76d4124e51d07b0925acc2367feaa233048b633a2cbd50364b2c4b9c859146f3d546c3a25cd34359b71532ac7560ca5572376884177274f8ac28945775e4833ad32d5330c90cdbbfafd577dde2d71848e3b38d3fbc220f8173759a8cb7262399d4da99e0f41a33c27ef7bf1b21febee050d56a06d4cb0b136154390553e8580aca03796dde16333bf705915d1393d577a23775e12cc3e340225e2f6f45e69e33cc16b82079b18348269b446388458fc3de3488d4877b1aed6980494c6e91775b447c8803c91af030bceca0dd37d3a08423bdcbfb86a120208e70f6800ea860dcc47f5e1c36a5232723545ecd72f25167324bb9b8aae9d9f25c616514397f6b944847b87a4fc351901f6a1c025a8928ae83ff3371ce046917117b6ac588d1ae979ce3a778e137bb3a376d9fc08db55c0fc0ed64e2267674333478071b944bd3f89ca72cec2933a15cff4cd24c211ad97d5221693ed0ecf383663daba8b1af532862afe9ca96fa3ef269aa232c1b34582afa6c6f770edeaaa8d0bf4bddb3331fdff7e58a9612e1f12ae3f507b963c64823181c9fcc38489d552219fb5b372ae2c32129ccff72512c473135a33afd970e01b5ff66ef5e33d6bfaf4023511d54f563d25e0d70f15be19a62afb4f780b15dbe52853f8123e1d0000db8ff91f2c3d4d21a013734e9a6d307d55cffc385455e79a062b5bfbc7d7d024f6f67e68374b823cc55cb9f5248b9fd9e18174b5db78ccee2261c09485ce95200b0b118117baabed1c57d1d880b6c4959047805a19bcfacce2895174c09aebb71db471ba15df634b62b14c20dc7e17425869508c406691b9b8928ff6e58b3cdb31179a39d65a6314f73889333ba3804269b6927b409744adf8f5a80e7507a3d608ebb1693b9e99102a859633de11880d5fb72020bb4675a59cff97203f20a7ecbe8284198822a5fa8d8f8192b96ee018a54b6e8629651785ad178e8feb1178c2d8147d13cbe61908e86265f0b7e5016950fbdf53ea8d2d198745312c4d6ee89995344a208d1dde05028886fd90080680efd7f0ca08bae6dc2136a4edeaf33ac5f9376fdf217a17de62b7995e46b848d09e7666203672447533745025726157859601a626c49c95fc70d72a50170f93647c61649b2d4487af526c9d8703cfc4f62e8b1109f714f64aa4a7da50cb17fe51e6e690c782924103135ede001aa837b45936ddf5cbc669fb969e8539c5d839f33a79e89c7badd78cde5bb231c61ad49f5f79f123bd60830542d42e9d9b57d03baa75e9b519ece0276458594e5165a1a5f56e100688c46bb5310ffd3b65d6bca3f6cfe756aa80c3262849d68fcfb4ec59e4249f89b200a89f14855b3e629ab4db3a148d5c68240fa45ad255749bfce3823cebf5132b9c05b38ae7a9c564794953c0c3d57253d465297c5c7672c348dd7ec495336ff5a100526e502f2f447874deb194970ff5ba3a177fb696005f64626cfbac6b07b5763cf87b9fe28fc469eedfbc26ecb13aed6c41bd8c188677ac2aed35fb30d6616e374e77805878a3121383ae4a3e0cdf2f37af35f65d8d7ebeecc9e0fc416cd775cc228cd2cc26d3c67ec7aa6d96c20bc055fcc3c72490c0bd340d91c8ab193b6d85fe3e3b8704d40f03ac4ea98b08030964eced27543f8ab7b8a639bc3622dce9817a21ba5e424eb336f375c1839e128c9d9e627eee944a8b8653fbf19f539a35203e1a976c4923aceb216bb2ec89e54d1ac4146ee052d8eef53ee9b0df945d503e66ddac2861a3e41abdff51404329729357afcbbcc96f1bc772250224d711ac5e474ca2b64d5c7038228421276d876aa5bd51bd5c7e6ef6e73313c6f697d291f027dfed125c94a721bed69c84747ed69d51a10a2e2bebd3aa5a9ce0b5e49d80fea834b408f53deed442fc3a2eff92dceb7abbeecc0343b5b3d0db667244ed4501b98be058bf2b001c10cb087fb736c4130d26ebf45e0f76a773ce535f4304e5dd65be7557e79432bc54512216b643fc04fb234145057a6ef7506c61cb1e7970042cf7b7ee3be7bd4db1c811f3828d981e839243ebb405ad9be984e80c3a36a1226953ffa6c06c6dd614c07c6173738d3313f522cb3c536cc3e849a527dc813ad2321a3fdf086f7772ef347eae2c1b51c13871f72e9f310e989cb199c9658df23963d308937e33dbf8707608aed05df9982deff01c60a1f57d771e1dc47becc69c9198f322dca761ecd7ebe880b50acb210a258cef3ce8550c24ac8846a7afe566c4ed6c5a509f0f4e7312bf1be340ba256555afe174309f286330426d9fc6a3bf0b24cbe6208ccd9f952c5307547a7032577f00da3139e73d417544abd71e4bf81fa22f130f6709aed735adb1dcee42952b9c654d072b750d23723fa71b3624b169012d41f2b7dfd70203940bf6fa8b382309228dfdb241a19451bb65922577c49d6a4e97ae1260df39500934d7d76e1a8a78a040aaefc0ce9c01875350e4e8f8fe90f2753976f63287a0f84da9f4c5adc10dd81d6b783b7a0065f80666baf1c761dc8d2258fd7ca578e2ed724bc7191cbe6c84d8b739e81a1c6b1f92876210cf5153085fdf4259a982e2b6671f5bd6bbf3c7008298804abe4bde82b450dafd3c0628486520e9982daf09196870510dbc8084787c6cc5ae6b5bf4b26014806ad499ba858ac67188d5534897f3ab7322d4622006125afbf58f72caf709b1290bd4df4ef3a4e7b487ed4e6dcb0a7f7e0fa379049877a074200f9744bda5f7d1feba69a2bee48da25f807657ce188c16df0c7a1f46a5b705a73c4291e5c9d12bd7ac816446ed1226b1f9cff00d396f84c4a0ab4ba4becf6fe061214073ba2a8c7b798898ed634aeee0be58813d37117fcfa330463513adcf39cbb4ecea51a09d29381cc0d632bda7fcc9725d56c2ae3c245f8fd4b3352e2ec347249cc3ad437167928faf8bc0c505de2cf5a29f34b7463ee8feb90458ea6435f4a6ba2b71dba84971f6c655dc0924b0fb23a23ef44dcaf870b27767d6df3bdf3d83f7cf76340582aa33b9aa1aa252f7be75232b7f22844c3e9b8a890b43d91b3b629520d721a36156a92b5397164b88afa5c4873789b7de3fd87951f288cb763e6830eb2a478a349ee2612386f1ebad31d412f6dd959b083d6b9089f5cf8e602ef3739fe1d664bd9c38574e98682327f35a34b7afb7d0f0d00ccff59e22e81b664f785e9a29d82403f063de0264c4bb61917cd6615e6a383bf7200248fb08fb57de8dca30eb49205291a68bd1b86fe7e1d602d261df85a90625b34bdb6f236c188aef8fb3ac26b288ee7ca7eafc0edca488ed5bbea3c5e018b7269c5176e5ff3f112270827c513f42f84bb0d847348ddfa9d81c7cdfa11b1f5e0048e643111b0701403f1df8fdcac0b872124b8b5cce867e0e1d9bce87a53923e51cf275aae0abab25e3b1b151149ce66dc5099ff8107a83c60862902812715d32089600dced149c6fb1913be3ce1d84953014582b76a6092066cb5a97ea1f550c59f848055348610f3863137df45f65f949aa97a3a070fd15397a70fa3aa98c2f4cc2c089c2f1bbed0d8337332508054adb0a483d84d698f18b6cfdb9ae2c17969b68d688b0eb00d555ecafff9b6e4359397accdaf8debafb22a6512381e2fe6f7a8072c1e0608efe233d1c7e752f247a0b59ff693a55dea0823d127e99b9d4f44243ff70d5b0baed67c328100a4c42face606574e0e7d0742281876814eee5b6f77fdd6fd61ec734a42bc3bb16a55abe7abdfa23a80933ad4cbb451a86b188797a40d9e01c62a54f961a038e30863cd8bc5d12addbcfac6abbe945bfc79abcad528ad8dc37b6d49badd9d7c2b85bd9debbf1c44110ca15e2af42acfbf2033c9277285081f96401afa83157afcc0e530c3170e508420bb4298bc0d01fd6de649447adef8b2d7ed5fefe2b75faea55d439f0afc7038de75045a8db495321a82f1144e3b7f9ac3245be75e824432d819b2f03ee2928998dbc7ad1465ee7e44dbd6cf12ca13c18dd749ba5706bf0615e8890809baa5599a3f6bb765af3eab0ecac4722b50e8f44651da1b0bfcbe98795cc445187423755150585d457a1f5f101a348f7fd49d7e4649651a6fe8d7c933007ad3e5dbe8d432138f65692f1dccd5f15e9ad51635e91225229e9a98c46ec90b011bc64f215a32d8c8f890038f688501a04fb06d3dba420e6f0ce00ac7ad658dd914c1f82ca9a822231cf9aabdeb016529fc23b4191989b73389036bd9ebc75c3bd50a68a9b3c2d82a6cc6fbd106465c2bc0d6441a6a6e2dc4bf618cbf56d301920d786e5578bf79bece276be950cd364ddf3c1ca9940f12933b3e988424f9ddaa8c8fb02a5516219fe472e679ed169e985030dba3d2e220ff2afba515f1f844a64b053fb921eae6c58a24bbdc59f6d7b8339b4c09df62b3d8102222f5757951795621fd3871b88df1db26e9098e3e45ef4dfba7dd1b6a871d9b78565ba81c7deb62b3378bda1e3da86a2f921a6f3cd6865009c4afb1f172b4a981b823bfdc670df22e9b25c919c13681246ac7c5008f3fdba8bc4727af74601ff357d1bff39b54dbbe89f481e642a60a930b10985a8032fb419402df8bf0ac155fe995b45873abfd97cebe360883afe4695ba22fe9a66fcce6779ec4fe36061e0a5561f826dc354532a2ddeebf52b10320ec0cbfbc13745fe9ce1284a00be5a573c62be4a609b10ae5c8de2dcec7624bdb0ce6201c6505e2f06b2d2a2e44dee0e0640bd0b162d9463f6f3c44bef0ca7e24b85add11dba61450050307c69929537a1b0db3e1935f99658e521cbee6c4dd8c7210fd6e2f33798f62d80b30141792844a07e7ced92bb95854613a4e485958fe7f9adac1347e0620f19e0f5e78dfb2c3617db5b1b919e094fb3f62f5f830d130407d397a05cfff717bd04a059486ca557a9ed7f9689b2527d3d15e2c653f7ec03ba1b6f2b6d18d26589ddbb335344e4d458800beb2417bd79e3a1c317f0126d800825fd6d2a662a212e5af7638a569f949c3718fccb051b6593f3e498be14a132d41ec5dafb0a30db85bfd08042214343239c97547c7ec4b382e3b12ea7a1a3feb1daf34a371b56feeba3180d119a93c03bbe4111f511dffa29fac3a3769a228c236012acff101a106b4377c92dcf3646bebe297b7e6d3352c397cd4d0376b6b23c76dd3e263b8c0cfc47034e25852171757a1d8010da9524dc6b529ffae26c27a285d78f17a20731f9c0a6688ed845b52ed083d0b7cc4a85ed67e4957edf32bad8cf6402a103f820649bcb7b238bf63b388106f9fa1b21c9d981b360f12df99d9f5c6ad59ce133edf7f094d6b67fe88bc275d0433adfa6e5e0cc799f3329f558211e9549ece7b5d15d4c32675f48eb4d0142ff59724e86c91b95a50b06dbd4408c7898e01253a236d399560c8629f8c71fbedbd99bf0b6eedbf69df1014f23858bb19d5b96fefb9c28d72f115ae221efcf5d21ec8507c2a13115a8eb0f223bbe25fff3d2bcfd520477061db7a323c8e1ca0eec568dcd7a263f80ae87f366f823cd71605986f06f0625f4b16c21f5d0b7fb8a2627dc970dfef453be9e3579bedc454e0e2b049e3bbce6e7ed3c07ed423ebefd9519979018b02485a6a04b5d967dedbee563422e4f3a8ca6d8bfbf9e658115ddc93cd1e25953244195c6950f22e1e034199556a24b8102d2ad07ccf43ac6e6f94d2b762f71e1dee33a5dec211f356c0f945bc2efe0e0ab43121f044e7a53fb735b820bbbb91ef6739024ff7e61ce796a3811533075ee4a04b69bac23b068bbe78c40f2128c955efcbba538d2fdcce5923cbf9633f8b9e5e29b471ef7c59489c8d7fd20245301a94850119abedacb8adaf45b8f9fc6fdcab4604b975e9d79830b39cb2de63538e1d8009c961aaff7a23a8143e05ee269c2332d49441b89c0872145027f376dd2ab0b341cc69bc040e4bbd8ab52ef08628ede55585c23094012b02a6735aa8f1c41d14bfcb6ab86c1f6550ac27019269bbd11b45bfa47dcf0f4808c1ae9fcbffb487298ea7abb3c7c7d9c117e47217c0e52c960c5afc595d9c6ad7e207a8b0b363d78807817665189ca6dad30f1561e0027f0b864906caaacecfeed3ea6ebea6f7ae1824286e22ce7a18c184e6dc13d522f0f100d393afd8695cc1aeed15968a54b51c3e0d34cb1c367ce9b0cedab6c65ba8d8073d134573c4888bddeb49871177390c864e044624c5295bd8ad8d4a6d96bf98e90884a7f3ae2ee1dedd106efba07dfcd484bc6140b503b8050abd9ebaaa99e9cb32d8ce4463e32c9ac1b66b2eaf327a39857d7de541bacdd4d9d9b3a7ec558f40ec18bb6c31a0d547db41b2187ae0622d0fb15e5adc50fee813f40ccd2e62ea1c592b37d842701f3fa8fc4a44bd2bb27779fda2af82c1175d84f2eba2b2efd71ac16515149c278ad37ac820a493c456f448ead981260e93a2fa05497fb344685c699eb91704243fd4a4941d7547cb9fb9a275434d4785857fd52d558e5d542408a88bee2437a6814675fb07ef87870b7d29dedfb5ef8524f32f1d043f48899dd802899de5adc9b9f06809f865810970c6efee478360931ac25398b632ebaee9a2b774952c298b61625f71e88b6ac3b118e664b0476b3fc47f32a582b4fd144686eadc8e9f44a61fd68822b5066c058aff1c9e029442c501415f6b63ffafcd159358d821cb50635fab405df3dbf2e0df925da11989f707caca62adfdadae875ac0d7b7b632078b3969fcf5e8f732013c74fc0ca11b4447b6fff7ef80a96fb81e9e57b90f95f27e81c76288025f3bb748513a7d30cdbdc2e310ad8d5c4a5e70265e25042494c4c5e276d770b4bb4709293a8a1e380c5ad69eb02943f8002958728e938999c9beef385c3859571bdd1f3231d1a0bbd4ab28c6fee1c68a940f8318e6dd16213b162183ca1d80ac469ffa4df5a82038a89eb62355a9e66898bf08299f1955550e383aa80449ac2fb4df95a0895e8cbd30deeab7e07464b9151477c7a353e185d1e3632643483774fdea914096e879191c34a66be935ad02e0061c70678e6d2c953ad4f8d8cea08a276ce4c11fa2f0bdb4de02903281ff0ab7a6f3318daa28ebc0d1a068a6d93450900ce3ce84b439ec4a42830bdec855f37b0e8eefb6c1214efb091171e4212bb46b145b4c5ba89e74109f7c8f0e80138f1b09e505227b81b10a87a62d35901fabaf1c23bc9fe0ba58e73b739b60f9da88b13c295c5db47a59f292e64e397c9d3f5ba7526e0d19acde72348d4010b9237055c372498b7937023f980ee63f345398fe8bf6439d2acd46e4b8b5b3897331aff5cc29bde39cb89194fec1a56b9901a190d73b192f4a721370ee859c5ea1437577f2443e4d6caea7268029b25b85c286d700ada3a5b715cc393c72a714fa10724295c35d43709223ebf99538bf0919aa417c45b666d92834f92e2b4c786d94966f8b235c7de96a5999951f4eb8ef80eb8fabb3d480cc2e4a55eaa7cf752cd75ca459bb099f62f9841c2fdbfaf5fd2cb3f86233ea44678198db599b8ce91e70b867a9bb6601f5c44c4a7214c2b73f78500aebdba9df9b64e7a0d08ee609f70887fda3a6e52e121246beb2fa1f107","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
