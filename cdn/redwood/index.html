<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4b1b1165223fe498866303e46fe013918a304881dfb5cfe09a8accfed3258ff6aaed23ba32ed3e0240e06cd54ebf53050f55d3b5f42d0d4588ffebc38323f3e2b8441bcfa9092ea028147599933bf9d05c7fb2386e0bb289f54010d74375c223d9d630192d22a6e95fe9937ea60925a1370bd85683ef2cbd3b5b75c00c2e311f8a981ca22c02bea1fc31078c70da005fadb5bae7e6d0966d87a5f80d456bde501b3d359f833015b5533ca570b3b65256fb53edf52c4b54bcfc648ea5faadc5791bc3163dd91b5326c75f7ed2a29438d82e82be358e00f0f1cc7e13d5f722ca820efb2be2558829f8372bc089536fe184a05777a74a3a5120a9128df1931820fd60cd9ae5202ccb633fbad89a34a17652797590c39546738aa806e282fb744e88d8bc7f532a8e47e27f359e617dbc668f8243030d5e2fa3a43c1dbe87108838880b75e0d9a7522832b5b22421ac7dd3dd0f78518be32f26ced49fa62ae87000e1bc84f3aa374772890be5498959d79615226ec68fb36d9d78a3844d3cc1d456848655e58a0df875de50cf424ac1b639b14a506d3faca09c725f94fb931959cda1e4449122a52f6f41006df0fef3f9ad2b27f11ee8964b8d5796acaa19451500c9fb42b3d269b7a8fd49a16c5dbb4948afe50b00b7952e7eb0ceaabbb02799f9f7c3af9eb28e1fa5228ea02a345711c2ed69aaf9fd05f59fd8fe7c5543bb7ac4a72f317ebd6a229bbe2724793447027e1b9bf6d5385b92d865d027c560a4b8e5ceaec57dcc0b67e8feda3e548f34369772625004fd3125b0bad9f683f7af811e6d1ceec1d5bc7a088cd99248e3c0166e2e4d858329084726eb512a365803426548b315a4224d22f99c29a6b78572506482a9a45998ec9bf732fa1be656dfd53bd5c70a196127720a17e03acdac18fe47a3d14b4fb03320e3fa1bec26fe76f5c70842bda9eae0aa6d612463a4483cda3a116703fdd1288e397fe379cd9aab39132493d7b87eaeff248c1bd752efad4d54a49f5a6c3169cef3a48488d1628a9171cf6d5ff5e914a5d5bce67f0ad64161972916de836efd630f5bc0d8e741d3a47c96334ba0ddfab03a77020a4df9504ffc61b2b232bb2225dd8243c10032a0d4c1d78e77d0295b2c783f9602377812034075bf9acc13dbe27b2a999610d49e9f66b4c47f87708c7c5b1e2dfa0d1c90adba8a6bef9e9ef430d9b07eac6119fd67a6148342bff0de310ca8441ee15ae932b6fae38a74cdb06ce1d22188787f26a3bcfdc0dfa4ea45433b6436e910510e97dcd09ae77cbbbd424f2c145e7231a9b7146e89599ac6698ee68b598d4cbe2f2f690626857e32c8aaf251ed8c47b4bcb1ca2626e32312c4ec8dbfd280e86fabb81e35f0e3216fa0be7ec4a133276584a1bf021df4db20975d8b5be8e23f7a307d4f1ea7259798de84bff7b121ea24a1c3403817c8d6965e60dae976780663c6a848a84a61dc49355f475a99551c769fd9de29be077629a621aed6153ddc48edf181ed34aa52bbefa3d9ec70504a308a47e09b454f1dc888a0874c8c15b12abd95cfe73294fe8a6ba080675949ab199c428b03ce92a1de443b063ff29ecc21d37e427a55f2673d5b7e02a17d02c6155c6b0755d9a74a3b3e1e6bd32ea7bc36068dfef443811c4e343239b72fa07536504657b6a108abda804c8cd752140fd5a7e1d441a22f4f9b4c46fa52925cbeb20144c8cf76a6a4fd152acc6ac09b702117353ade2e2cce49c109ea67105e0809e5e35d15e0a86960da31053c44603a2a08c5645c429e29e10b80c3d7c88d50fbf3e4560294b0f12afc69774f78aea401e7a06b9561bdff65b40fc778bfa0f343b45eacd29ed7fbfa175f62ebde102e64545028af446c314f2b1f0fabd9ad824e5671127894aa5ebe641d9f0419834e27b3ff2eb5b07b9cb6898c2a6651b99039b07fe8064910b3099af5b080810a3c2382ba96f88b771d808e3aa0f310d9b8f701cffadecf88fa7a4479f32df77aaf434d46c8b85345eecc6b7be73109956f9d449478cb0910d36ef3f93b42dafdd3f5433e3b1a343cf5b314a667f88dd380a455c85fc2e7ddca45ec0e9c50e985316174354780a95f05d2e8a56037be0c5afb7dee28079bcd1c20e88c7f73f3e30b45f1f7339f2f24e2b98ad3094631ed1ff0f2b410b6b4e377b3bf78a13e31855c9d76ea042a732057c0359bef50bb313c11fda1a6506faee5ede5550320fd3233700763ae41a7cb8b4820f80915114c9ee7d2e19c13946fc39778f383f776b8aab9c74d39d7c90ea025ccb9d357002d522f6b153930432e0a3b75d4293c85561965fabe1a5ff22727042d1947e6193545a17dc878d52d0f88b0b4da530976b3b40268baedfa6e802b74e32582569b21d344d781c04b2881fb7df5e391499505f8c29c616730079e1b1da91c6ebce1166fe2678b976072b29e2894edd4374e818a5e26272d5ffd61ce662f609fa60e720f9feaf1c2a9e24a9959e5b06f4b0e2c73ad0ca93112e98ecb2867d677cb3218062515e701503aed306fdbda2c89e310968d827513a83c972fc7cc63a929638649bbada2b7febb4bab8e2467302b666aaac6d7119e43000dd3affebc3195edee62b3870f483b80e84c407175e0374347e81f8c10685ea1e5cdf1561792545cf6316ef2c42299d926af7b0cf73fed3b7414b36a1ba7df6b06960a67a98610f584636645719ff57e28800047c531fc27f82e9879cb8449c623e3b3f8afff14df3367417e012fc4387b56eabb5c58d6fbc5ebf76c73828ddb956ac4c77e00bb80672e6124e06a547d10359e9f4ecf751beae9b28a3b0bdfb2455e147276308d57921ddf90d24d730fcdc486e059581a045e6bc00aafe6f067ca4487642a65896bf0426e634d59faca908b9303a6027887186f602053bbfae5d944968b57fd1b8a821af470f4890e2e9eb227e7607232f8e1815a918c7a4e578f00fe0becaa9f2b479ec6d513e8e3201ba4af44b262570e5a8c24f8af9a850cef1e5462355abf48356753d447936abb241d2500d1b1ab6f016c37b61ed7c56b83efb5db1c3f21546b90282b8bfde7657a634ef72cad67b26445dcbed854f41a4774bbb472b8fd5a3b54f738ef3dd1c0592360af95d39311064e5ef7ed698b30da69e1f513c244057ffa83bc63067670d4239b9d88e90afb277a7c117ced8936198613bb6abb2fc4d03baa6e44ad3dcef928fb284933b9f942da5e5d8c710a28b1c42715d50b843eafc8275a20f071e6746d16bc6e7b57e6bf8b5743e61bf65ff8d674b9687544c7555ed8c383dee3dac08bab2fa4e9f022567ef6f93b7c30b7a34ff0ea0640f735a8394075bbf60753f00fd982d8084b4a3b65974064caf01aace2a0b08fa24ba2edf04563835ba5ee71db4f5a91bb349c7803c42f9b00072850832ca891c3d5ca34877e8233efb2a05add3f69c81707e407fbca43fdf7b2098d348d980916d3cf8a031f0002c249985c34c8acf5c73620d3f922f5c140122fdc49950ae9b13877dbba0770532de3e8d41e3484bb586ff3b19dee6d26d3ebe801dcc7dd41420161a71891a7511ca9ca289d477868789e0c3ad396eba348dc6d5621c9d8017e0b8659b31a142bc16155fc9be376907ef850a845caae18f633fdaf070afc216b2c274b63b9fafee4053a9d131168640c58458c07c1833d57034b89beb8483f476e2082f617257448d9bd3599e1f9a8153eb0016fc529c47110a7c2ed490278dc21d8ddf12a0b1186ae83abadaf524af885605075f7b28f201bf8b243a1085bb7400752d8cb076bb8e73900e0a686063c2a7ffc78a5829005e49f876470ad214a4523aa5f9ae6fb5acff90ebe97896a6697c3a823f3f6123616c6445ed39d737c06f01f29afd74ca63839c8c32f7ba5f2abe9ac0df0083803f6aab3f7e83f2b8822efb99167c46800fe898ee9b252932c065696f7005fa8263a8bde682612c40927ac11ab0e8c4c74fad4a8f2dcc70e9a6b7d614c75dcfbab26f4bfadef6ed3ef79b5c4162134668330117afa1ff1cf0273d037ce406b1be480f7a818233f9f2f1db98d8c305ebc52c619e432c16a107d9a1de175a7f74b28b0078eaf1bbaded155774e15ded4ec569b759ac09ccb08fd6b39cd16b1fb96b0fd265a030ccc08a2e423a803164ca0b6299d51b7b6dde4745b710004a92a480131e7c31c3ad33d9f7d80afbdc70ce24f8537e8660d0dcbf20be0a93b7302789fe0edb496ecdcd9ac75298503b4fe778207062088c8bee6dcf8c33e455e0e05c66d476c219416034c9491aae04ab723b13615341cc417b8c8c6acafec3515a421110201d7f5e441a55452b08a4a93ce9aef7e680c90bcd24f8771edca1eb8cb597c43ec5d4002ab25808e8753f72326ac9364148f3fb16b9067995123123f9a2b492793d9d3662e76b2465ad7f92b90c382145c7918d829a6edfdfa35780dce1a1cf388954c8e8833676680bbf2e65d539e78eb5b52ea9008d914c7553f16cfba2efc5bcdcd51a8a09024c15fa9bf8bcd03d72620c61a953d9bcf429e863a651a6200ad3a2f5b3f6e7f87898bb81c682f0309d1a77f3fa4b58c6a08d5464db43f13f9d32260a0180838651f86596dad707627d858a5fadaa3a6f9f72c58f9d45e980d359ff3c1667d9cf9ed11a2376004a66b6db5879d3dd1baea419e97c1a43a69fe0784688f14710635ea9ffe384c5fd25e8776009c2dda173676cb1f4ae90a6742427c388a9ae8f7759b98f5f49dda9f5a5718a6cc26319ffdeef950cab31ae3fc7792ee4ad77a806da7b52f20331beca80d00af5a4df6ef089a21ed03d6e60e7ab4a5d2e6d1476e06ba72fd17569b366b475609e6fbcab69db4e50b94a5e33904b00cf4d3f0188840f74a5118f1b1c75325c70ca889f017077ad38f8c680eca67a800f98825deb360c3e4cd6c392bbec0ceeac00a5c8d260f8c365df2ab30afe8d9eebe811829f38bbfb8417b62070b8d7f86de0643a015d091d3772f966237fe9fbcae4b3db402d28c45e4ad1686029e3fa0f825120ee36ea171bdc55d0d1707ada05dd3c59c4e9da8c039bfcdd273869dfac10716228433d508f2abd4ce67e8ef6ffe3831df02bab745324729dfe398952d99373005a8c9af919e7d11d3d48d7382a574ad47310a4cd025bd4b570b469d1af7da521fd4bddd2cd8f86598785dfbcd0d0b46237cf3c5bf369dc295ae123d7b62e09511a23bcfe420a151a8d52af9d3b986d77e057a57d0c13ee62bc8842c9ae6da59ec1d0146db4c612b60b243e0646872df374aaed656393c6dd72be321dead6774e12d459a94fdb09210f5fc6f1a603390b353066e25d5c007b9b47f638b3f7dca13a9cee91ee9215a750311d4f057735f608864e47d25a81066f11c3148ee0a371632e722c14cb5fc31175fd5bcaff20c5852d16ceef1b431f21389b7edc7a89ad7a3d235f58b7a86094b3ed83445d5adb12e4a233521df05a80fa823a2c3a8acaec506ec08c26852f603adf7f488df6f2cfd784e323e2083fef59471bf4671ef8b399d8941c30722454c0d063b9cd6a20241521a2dda917a441d4338c9a0207134452586a266c32cedc99148b9f0eb8f7424a3c1c6b4e9e17b61245554c62605a7fcb66bf96d52fc823edddef5c55daeafc9087196eabd25033f00c914e3965713d7bd6ee8a40525f81422727d979e392feeaa630c6df597747d7317a450f32c84fe1124d66e6e739bb571c7a20b3bd239e218a705e79a1fd04f2883e7da24703fdabff7e3af2ac80089630292326d84062f4f5933902037140f7eacb1ddcb0d88aa702b0143620590ab75c603c2fca13d86f26eefb51ae01a653b65c48a34d6a433687b4265408cfee9235055c3ccf47037d1d7916104dc530b4809326cb51cb81e54a6c905ad32c4f952a212f00601401ad923e5061f556380f2b0bb8ac32e13c627d4903550c43cfd3081447958b52399cbed58dc4e2923cc3cd06cda00cd8343fa60c266cd2ac00780896d03df080a3c8704bf22432df0c598523e68ec7be008f903a51f829e47814f680167269d62ff1ab26a7c0c1ee447eed38e234339b48e7685d333e4dadfe931e13424e5e058b68faaea09c16d5c6d5e7e90e171672e812e5faf4d70b96da9123e99c13e92a40fe54076cbc4c2d2a29ac5aebdf58227c751318444990360d058630a0c64ae1d0dbd13a04199a341fce517e3831deca172bbfcd4364f77b352b4a448731b92b891081994b4ad2f257c154a34e1322dbc8e9ee4179e29e5b15e9b7381f2f8b3bd709fca98277ff004db316e87f47b1e3bf142577e219851351b9c3995c8f82ee386066db11b33d9d9edc46cf3e2687c373471f1e55aa51b7aea49b2bd979e905342cb5a396a68084f4284c34fe4f6df18745109bbc2e00c672a7abb5f5696bb13244b29a26e7a64073739b5bed6b54b47c4bdadd4ca41f49067115045254aaf0f97c9e30942fbe0a867f87e4f87bb8ef37fad58b77cbd4e2349061b02a2a138ec1d5e89948f96555a0508095e02a92d57ea04801c5660741a546cff9ff91110cd713053b777f40526648a9b3a4cc04ffe31a5728d591e299105309fd69be49850a0386c739015cc2662ee58c2e2e73a68cc6efbb86c021b519be22eca76637aecbbfe13c4a183d53f7995b7b20748f3e7bbdfe507849ad4ce5c6a7124d433c1a414b1db3be3b86a72e6479c07370c2513adc42c860d0f0558c2d960e524f990bb9e2456b862d6b85636a24c1bbc4458dc404d3bf9e8cc80fca92c966d7b0e77c014d52692ecd040006740552022c016a78b068c58581614cf2e341e14f83c00a9893920060cebd0a31f7c1b39eda5ce97d8e2d6601c73c5d951cd8983d18f2676d5f8be0aa8b4b3739923253d9295c4221052555e064f4df8a47ab73edd07efc8adbcd1bbe58c70858c7bd2754d9090253d1b8de1578c10341f9a9f017a0caf6a6e7d1c1f779f4b48fa8fe56b0d9f6f37afadc879670ab888f9ea9d90a4e57eec90861c3d6a688273e442b57b43da828b0ba3b05ab0db34529a18b21996380b735879f87acf7cf519a71a100ab4af64eaafd9412f620a4a7bd3c74459902e87f3e20cf3b10bae3231a9f9e6bb11ded0e640907ebfe7f03e98298d0854d159926dc836e9896a710d2df4e19c75b8a715bb97746ed5d30715244b8e0ea69ce578a8a68c2abf600141018ea6327d106deaeb9e4372873966064b407cf4582557e924b9a53cd0d00f32582af901cfd8c3a9a83768451e610b03fa6b520a85db056fc2b9aca5ec6b45be6cd231f6340807558043b86df1e19bfd13957733ef27a2f3404d6294dd93d44f14253be89a52a98cb086364618d67a8802047db528c18ab4486dcbaf3f6953135692bf687355eb1cb6d161448306e73b9030479203e74463cc97c4ab821bef31f6d5eee416f0fe9b385727af3252811ca5899f50e43591e171f270f2ba769e218eb113da6e5525e314f42a12efff1e0e61a99f0120751a752f45a0b11df34c849fa105bb924abb984cc13a88e948b37d5619d64319dd9ba1079f255aa93e3697c3485b304d05ed1061e4afa7a8bde3409e95f5a428b05e0f6bfc92361deeb97b457ccde46264bf00951efb913b471dede5792c89f91d6f15d4154d7d813fd3cb58bb21ebf136900124362e5a2864e22530f2a68f39c8a0a63529048cb51aba055b99991c1a3f89c92b098b18762e9aaf2031f6f8ac7389022ac481f932fdab077ac9d70aae9891312ede7cea9cd787219fa700d609b5cfbfc3e9a8264c3eed6279fe8fa49d4a6ad231ae93b4a5a576b1c59ca5bfa5b3d18f1cf19fb81152a97c81a3b418062e12d6c9de964e2d7d631dff62fb6df9bcf1cf5bdcc8cb5d033fbf37df78754fe3f9012099ea68009cd6e12c27b9af472ec0f5102536ca6228e93395c6fbff0f508ba32b73e8f58f7560e292ae4bbf149063f851b5199796c4b73888a8f853c64859d237fe5446258db3cc050cc10abf6fe8992c5a904b260f13e743cc9646267a49adac33af972c9ec26e0498e959c25f559f10d0c67e320260a9ab83d87794a92d78bfd9bbf84a39160d97ccbf7e0b9906dfb281b9364a9f5f3f53d91bd3217123d2b282eb5e8aaba25369feae18148b04bc9478f18aa739cc5dd92a01d2c8db89c548ed460eaeacf2c36db032191218f0cb0c3b8c2eeaa36ecb14a50d6b5b2bd8097bc5256503131b80a90828d411666df0e781e8588de073781d5ea56a4334c66fec0f30618b240258462c9c4a71194323c4d94700b9ba8ffad229eefb0c913a67b67e5e3df276898ae55b89e033e77f07d9ec7fa7185f6634504dfdf820e42970e283afb6e830f9a9dd9680e637683eb7bb682619fd5a154032b7c3494493db0b7b3ed13c3a6042be21ff6b05da604167be2ba4d2a550f8c6f8b88e84f86bc5086b4d6c849aef9c58d9b4804de03c3483c6bdcf8309d9ba72a4fd087eececf19441b0350b4c3fd2e0c40fdf1fcf5666df7907f02517873d31f55206780d3f66832e17a31a4ba841fd6fc8cfe3fec15d3703726bee241e3aa0ffcc7d42b85ced4b09f040814bdccf9329879b5da85c2e6214509e7e74c4040420a2ab7a40366520ced0275852e2855a8071c3019461d8729e95421cd3267c665ea387b35ef21a7e80c5ac65c7d8d244b4e88be910334b3bfc8978c5aa956a31798a0c43ffd896a1c2dc5b21b3755f80e132cba566d3f3bea8843a907dcdf19436211539d82beefbd2f3d7b483e1ed9dd90d2bae62262492aa0e5fe6afe65179b74578a902b212440437734431be2b9e48bf236e0d5878061ff11c449beef8d29cd93a7790ebf06efe511b562817c00b71cc5090453f5ec58b6f3677460488e18493656f64e6d7fd6d7beb8c84edc061437fe2ffa926b89dfe7e1891713beccfaa1e0a1344ccdc1a5f18a6000feaec0bd0bd5f0eb7ea6d9cac4c81a2f2cedcae06bc7207affe3b8c1d00e5f5141045ba3fdae46836d35ccf51ad22de1edbae2ead437646832ec1194cb1d6040c9fa279cbce34accb73f1949326705b40192884ad428468a580348faa098ba43bde12b133f9d3d7d16bfb59e385e9d4d268090006437e3107d56820f8d6e87735890c825131635acb8a4604fc1670c6cc6f55fb28354a82d8f903d454299341cced08a226a991f55f24a8efc9eef14e4fc1742712f391e14af465e3f93fbba0f1e8159a5adfda38687edafd4c0ab18cfdd5b56da661621697e4f77e2eab51375ed544b2961ab21094d0f9b1393b5d95727c089c753231221b272f46b4fa424dfc2e2a9d1c29a86f4869f1d8741413956077c6d9196d79dc5c650efce48d9e5b12ae4475d9502d92a0036d0b4946e1cc4f12f9bc52f7e513d0712e545f95a76e82fb2915576989997e5e6ac99905a86884c160bc23e4c16d5db6dcecf1df215ff4400a506a04b54e5701529f874f6a93a4d23f7abc945317aedabd8d7846ca9a9a9073f5d0a897203cb776254a9498784ea91b18f85fe724bbd61e06afd100f36c97d78805bcb9bdf55662f4697df95b0e6a709e31d19ccd3725b1c05368a4d7295d688f005d20a875bbf7d82e0d69e8ed694cd85511013a40d1ff40049af86c0d3f2c1f2882135c3de481356cafcb2ffa09a92c3e0057d0526d2710817a1a84f05a4e1e24702e4953630bcadad54626582fc1cc1d405ca3636da16bee72a98d8b5efb88fe1a6e46b96c6858afbab0b3da85077458d1167f8eddffb467a66bc89c3fc92cbbbe10bf77a18626095b3a271c6a3da973947b03a3c4a69c6b3bddfc9ced4eec0e40650d4b40b4495cf2ffd46846d5fd734e84fb654bf4b8d4522364a9b8aa79c2c70af428864bdaf5c6e446cf6f7832bf8ce10d3a73e14550dcf9e562993f44f012bf5be9d493c48a41246c109b1dd7c0e09e6f186e8b172ee06afa5727b9ad69a893a6fb7421b0f98e811820f0b6050ab799a16a7210a90756582b26eb35497f628a0db3a69e99a45902631c6fe4227400120221e834347de020eb07b70ad32b5bc5cbe329f00ee830f1da93c8ce8491a0eac57e271f02b71cb338242fe208d4d9759498327cd24789863d7b41a1d35b554306e94f421cf8c8bed4160ac5219615b854f50d0edb9e255ef4ad0193ade08d31040b608e61f2f7cb03fadf567f77042063dfd3ee58aaaaff15c528deba6e90e87644628fdbd222103cd32a734ff4efd8b11ac9a9cdabf4a22aa2150e2acff9dd855f248879436afda135cc7053ee460310f472ae0bff56a5662148584e5abd8e83bc6bc72e0b87ce1455e7798118641a9abc0b623c5d0e4a17fc997636108526911a54662ed1b7cb07da931be11819a1ae730c2c0e97f68508a0f9e9170318d77fb139f2d7318765546410583dbd666ea3f74fe79d6bd6df9f626249c313e28d2ee162cc83aaa66e9cc7ce9664c45af57457c82456fae033e84be834d14f4898080592fdcafa7dca35a9bf6f0885c46592062d82f0aede2407fe4ef06d4b7bbd2b2ad42358b13708d981ba7fb7cb5f3e377de23f04bbd5d9fd5017157722a68b0d0c3b80b756e4fbb88ac0cca1b15b09348fefa6308a92ec594ae3f9f2052a07dbd9e1c1eb7eb07fd5c8f5c1eed12341620189d6a232bdff41e85f280713a9244e387a230112ce7c783d32dc2ad6dc49e68f3d7b7fbe37c1853c0539cf84d061624c1b35094d8d5e091c4e8008e7b5ad1a799f3138ccdf9581cd885385523d6e6daa8bf6267ecbbc1d8c2d906f6d70021e9e205cb2426941d46a7714c3d3fe965c81f627d652aa3d4a5e908b2331b3ef6d2417caffb89c9c14a234b2f3327500be3df43ca05162dd9408efd9ab8cbd15c3b50744a0a942bb528c6672d57fe4a425c7917e0cf5e01107b8dd3598e77e5cfd6b02ce5fdb7b1f76ea2e5812a5da07799bf44df65a8f4c99d26d890ba53acd3105bbb1cc6f244d75e906bbfd6721572c2dc4b5d3b5a325966a6532a8761b9986c5b2746d012c38c6fbe19c57a48021a67b0a7ca2e2f1da0226e1cd1491bf6d525f3ba7be9fb82770633900649f322e8977d8a498cb8eb3f5124defc8d8c94819a726d87c79ee7b9d291d5d8e39e320e94819881f5b58882590fb8185dc5468e24059acb275a057b0fa7fd6f8f8349577ab2d289934c5d50e0bc1ec77595616910ad16f59d48f11933abfd45e4056e75ef1575c90b4bd9f3127ad6f6c16235c40b28bf8bc9376ded5ac8a5795ea177df37f8808bd1bc6feefb6519aef58d91d4e113c6bd68e7098f6ee1296c2e75a962df4829c8c3a81e11546287a25f443e580ab357296bc9691d92d955f44fc8210b6cc189ccd4855a7d2be928c5283d3a71e9ecff040e3485c7aafa589aca0a153722a723a5eb55cff26a1a190207740c5da11005c595399ca8da0033a5452764f226b46227a5bb5c3e890b5a1432c02eb807790aaca1f37b166079b1f0ffae06a900822426b0105825fe29fb90afe8936e75950d01b8593f83e12ff92a48ff3f5eec5c0646b341f7655463da3cc4f9bb94f42d208c478f193a7dd2adf52a97a5a2739c923d079b8146c7269cf4b835eab4cf71b1942929b9f40aa2beeb603f7243d29f7d5df3281a4bd6753179e0fc7fa790f977e1357b0e2b09860f85b129281cbf37e7967675713322191ca5f3fdfcfa292ee023360b49757f67722495a5965bc3b8e52b8864d457df39aec0c9a67d793c18d6547a444bd53e4486513f1ffa64efb44c74530d7a50aa638ea9e89ade48d37f17944522a0a65a3e494e97a44780020d9a86b14f413b3a688ed1055a1d69cb5827d7c3f23dd9ae8375a1e0226603ce53d1928175ec7e829355ce62786fd4f0e695de835132a06d82332b9e511a87b5c9d24cf196264b704387ab93ffb11e666fbf572c3957eec4aa288071169fcdd5066af81c4506940805b88a39e849511d5164435238c6e34ccfe9ad7a36583bbdfb4e0a7017aae65430194829e18a5e29df16890f955ac13ef8548053104e05b5b4cf69dbe6157937def7808623a768fb1d70a84506be2f444fb0f97e99aaf6ee5a540940e0632786d5ad8b1119459e47f46ddab5631bc9335517a1f4e166f1e1a0c4eaebc6c52670c6bcde87c0a7617f723ff48340f7230cd455b2eb9c1952c94b71162e09d85bc807ae2f5894d71a9b0761c8cc4e1bcd486911db90c0b1050bb21405662f391497e08e66d4837f6437713111370adf67ffb29763666747c4adb61f55fa45fac10ca069abf412805e3d7a8d95e2ffcd19f7208cd2dbe6c24b70908e7f7f169fe4a7f219e0c05262b0b02a49631a5b56bac3b58918335946c93fe208579e04bcdb16ce0b3c8e64504b9fc5a16fcb4710dcc49cfbf85a889f89ccec8ba9adc7a9a20dd9fe32faf05cc189407879687e07233011d62483239931a77a32920231a2886db236f6dc0b7285e4f623706e98a3b66b4f35fd81a948abd5a5c57182e20ad72d73b161307af3801dceaa18f8af102979b7219f1a59dc1db95726e2f437819dc39a00bc45995b63d893d89e7ea4c07481810e7e8a19ca8aff2c1731763c92ffff02ad367fb31da09cfb92f0932317e22ac9ba288cf9502cd61ee224ddb4a2d9ee9b2c55f6be45bd592b740a7bbf34fea2e1aa3658f95545dd8fb5a0a9953e7a2826965c2afb80f8700677c4b715c1010fe2328d14c4ffc98768633387f59dac86c2be97701819b8c673436a346fa9f06f5087aa07730d6308b8b78ba77b34d9576bd9782e22da6efcf591f950ebb8f7241a0760c78454fe0a306afa3e5ff14050ded6aa1203365960ffe1d8a501d3863eb34ce1e113a11685796012768083f701329f6407a947775b0a4c0ef1f217783ab3f40e21437ac4af0cc9464f499b2b27e246361d4ee2e245740bb17b98b82f64450d847a15fc7de8d5e76f78fec53ec70b45283412a7980c7ead48aa024debd4d8f7099808d044b915878a40a15b6e5fb43a629ddb64735431aac9e24922be623a32b9dff2731e606b4a7c189ca848ad34ff8c0f8f62575cb02b0eae8d409f87754bf5229df909f4194c57f741b8d3746d860d0d637d2519c79d7938bcbb4b5e0a5e39228c8398379b05605f4bc266857917a3256fbecc440988f6e5ffed0cf061f117b11008bb610c3853778819abb2acd8bccb3d92704ba0eb6a13ec58fe1824f36c9a6d53943f63d208da6dcb0a7eed9d0028c875de215919a9454e8f0c0be47316d1d4db9d9c17d4371f7fe144df73f7833c0294832cfd0e37c0a272b40191318c00026d01f9d97fcfc7065dbae15bc89dcbce59141a6f8692b72ad0756bd64f63cc83e14d6a9c0d910c01f6966630a6369a6f950f417c762805585cef81a5bc37933001395e961e585901f95fb587bf2c1a8d0b0358399de1459a834ef9bded4d029959ef2094f13936890f094a6b4b50dd09e911ce687c73e610653b2cc406e02995714eef5a0cc84a58a61887be1a99918311427f8edbf09a9041784d2b285b122c656d7b3cc4251a63364547fc509bdf881e5aebb9e5d65138027190031022a3f108965bddb64dcc82c63d1214ff4cd8ee2aa0a8d22861fa854773c056ab7dd635504b4078e2b09e3de0753f1078780532591a295b30a7fd9a001438dae19f9b9b9bf52f00e13caafdbc93428937494f0138d983b908d2068c72b2d1e1d4d826c18a5bcbb311d2ea480425f0a995e69241b9cd9b056fffda0077973b42083960233838bb13d678ee0f81fc00cf0f25b8259db4b268e2b657b763139584573b07dc0611ee45071e21dd91c31e9cfd08c9b39e7059da596807b64893ba10afe3291cf52e47620af9c14110ff2ee5d33d2da4635a5539398ab8dc7e939eb2280a4b7c4b99c28dd7df8574ea97e2002f78443766abf095c57fc45a11d02c468da79fef3f2dfff5907929ab0e42161adcd786e2267f508b7d5b480484969c8bfbd9fc8de5d9756d82f62457caca48752d0d2aa26a0e68186d1dd8b1861f0d08b282139231d27eb7d6496295aa9d8581f40bfb0e5782fa6914b4b93cdf860b8cc376a9d37c2b52b50cfe923611f16b9dad61cb402695bafd16483874823782597ce44a330e027e89239975e7c26a965fc70c11c412e18623d38e72dabc36247fe8dcce33f6091e79a2ed6ea8b022cc010b4a381b7423707145cefc48b658ebc6f79bd1bf25ae68586a7dc6393c7c4d367cc5182d515e78346b91eb23282e79a82023bb3038f6a79c9221915d0ad1992a65223468c87e047583fe5951438269221ea49e84499968f3c1e5aa8f92c458f27acbd3f4bde287843377d88bdf091d99fda3d455894d0d367d0da5e6e193b5c9a95d0d0ab99efac1d52b1666fae592162e1aa92205a43c72ccdb28c93487c4b6c79e3c2ffb1bbbe4923c5bbea7cfd0a34f3acd011551d28221baff353147b840f7254850f00257d0240979ffe022e5743db6acb042a6f872d51d9b33fd4a6ed131e5f443b9e940f879f5adae69f3d36646d673395df6d2d65a8ac499e653d29bc056472b7d401c7397cba350860bbcdb0fba4c77bd1a5c6d31270333569812810ce1e54a65f07e59c9d994689565bfc55c3b636218c2f375a6c7d04e23ae4547d5149e9f7987e0233c6166382b34bd62d94cf62c2504b717f7a07164a6b521271b58ff88e9c58eb7073cc2be41d04808c8467ed0c9862a5156105a4ec5df237c501ae9545d2b5cb1170c801b2af75b2c80a9279c1df963bb54e82abc6c811f100240668962826c82d78e439943bf076982eac08e3402e6ba44987f393b9e74dda078f527426ea9bef43cb972c03a951ec7c639891013d230699a3f019c584fa9cb482e25758ebfa696d751ac3f88e5e49503e638fa2cd0d8141c3c466a23864a41d4c4f095a49cf05e6adb82aef68c2e655a62f01f5610ef1cbb775ac1ade7a89710c16dd4f1ee93d4e1d4e4a28ed2900bda658bbaa43f68d9d991c2c385e07943d85bc2a313c702c2a583cffb0ee4c3e9aaaacc2b28083311f219965326023a2c8be450db78f69b18c6fe95445dfe4e18d74f99a2f4458fa1b4e234d9ecfcd9b34b45eca8aed49ee10faaec84c1b73ae518cf0ba06e92f6dbed4a61c4e6cdfdf33b87eb130fb63f04632d0018ccf0ecdbdebd945f77a70f5578106c9431e464139b323dc6dfbdf1d70e099ed70b7ec134c5b1303a52e228e0f96d782d0607428d89cb53c984e85e201b26ca594eb2f3a7d60e799ee215fbd15f351a7431e40615bc2646e631645581e59d90dd8d1df1baf716d8b93ca54f9341750bf79cb7e80ce4d0533a1a52443ee2b083bf1c2dd54b9e694b80261b419d1a3a7e1dabe9f3649324289db7494e62a130aba09410b670d248c336786a34bc0e3b5e4611c9da31c0cdc7a2fadd5fdd9eb51d33034516515c29ce0fb5aaaba8d468c1a34911c3f3639ac79fc07e299936468c50ccb31bdfc13cf50b5d412775877ba2c93c48ea489020743458f17171c1826adca7fbeaefdbfdd3bd2d6aad2538418694a9c4813c276a8731217d8aa59962e8991e14f2c60bafe69279aa8a07c4b2d5e67812f2060c548604a9f5c1600a11fc44eeb216c553a125b9ed08b5865189b9e1479a62da66944c61bd29d24fb1c05d8773f5746a073f0cfdf49ea8d08abb67e9ae3b6f5597e2405e791ea953499cbbe0d3cd107acfc1d723dc9d6f3c80abf0675f9148d5fb01617f0acffa0886e009f0b0bca45c017152b7c0fcc18c1515234a9d0b2a3d51ab31fbef4c2335dadbc2726d1cbeb13658a96ea50decbd7eab583d6825d8e7c9db5a04d9f6b12c18f0ccbcac6e8c20b4dec4f0d7bf4296cbea6a92041f3ce3b28d6a7d6297511da84abf344c6443655eb1bafa970e9b1a52531cdc3face3390082a2b17c85eb1b92d5c30f546e6422fbd079f1a50f74ea3ecf993e3d259f0ceae148776310f5878eaebfc7a8fceac93788c44e4328c76dd52a1e3fb3a46cfded58ae6e394ffbb364584fdbed7e77063f75d43d671896a9b43a6f0eec26da6352acfdf4f1cfd518358837f4fae7eabb390e82ffa9ecdae04d58990e3c329684c4dc1608c865798c5f81eb9814f1a51f67773da7c0d70c49814b5bdba403da045d86bd2197a70a07996315902d2cb813d3a3a72d259aaf444e819346ee3a848dcc0082df27a24a95e8df337b2bd450f2323b6c624b41bc8b90047fb2e6cb8f115d4aca4be2b74f6800bacab79471b4cfea1637fff98cdc8ed020c29f7eb825d17c17d756c061f8e140161635f470d2923ac0dc54c7e1475eba124d40bae6e8c541e8f9d671b7e2cdb5dbdd32eb0f65f8a90dc71daf5b2dd24329d56cc00be044f9d96c52243d83d2ad009c6bdc41e17ac26e9cf2581cce53b937edf1d0db0de7ba01d72aa4c056f4d8600033532339f0d3cb29902d9b8c49a38597fc1c60d9fe0a61b78061d094e0f4282d13f08b0a1ef41407cbcb79d094fbdbae3118eec9f0ffd833e1e469aebc31b1e77d7f02512d249676c1351e541ec1020f5d3fe5344a6d7cc0fe9aa2fd64a8d8b9c0888aefd4cfd51979e36a795aa3b6e97e278ea9df5030dd22f075424a8cfab980ef8b01cbbe8e9dc86479f42407fd59fcc200a3fde0a64e0c57834f0016bb1dfaad4417bdb66b04d8d7ef20495a94fe7091e794a947091e88f153593404c0ffc1ec481f120e46031d98013a858aab69c4ffcdf29493f4cce23d3674379937192f0bd976e85ac27047f15791057aefc6a58d2d710b344989751d1bb052656058cf9558c271a19c995be02d04d02601948c3e3168dd55580ccddad1f6e5ea1074fa4ffd606d9c675ea42abc6142b614afdb0125b72d4bb812c1efe7ae0146dff1c5c4905bbcb54477c561042724257a1cfa001b0025b1b591910d5f55ad79ebe01f1cfd0d8cb8f98a2b9e29a25f299e0410632642cbf9e211b03bb0e714cdefcdf5347add62766d5ac906d9b7aece97152978b616f47ae508d21602d9b696c180a2e3e7769bd2d4b169944a0400a9252b3bf6b45849ea3878e170ac081c48276ec2e4f6aad76765eca45b0fbfa14f71d4a8c237a9a42b01d5ce2711fc67e45688f743258c6f7cb528a83810f896d823d13b6ffb4eb481dfa979af60f079d35a4a04955d35d77f202c713e81ba337260f8512cb5d946a4fffa2f6a5536dc4d963b0b0391857060251a2d335ed7ddebbf6b1bbd0609468520c8e5b4782fc113c2078eb165ef5ff4e7f66b2e989488e7c564bdd1f3f48bf852e34c6e09b39abb16b8c942e3d5922736b94973a3209fa3ff7557519ea0395663588cbb8515eb9a07ea0f34310dcbb98ec80bb971e29b00ac5ccb8257f016b3c1ba4f34c8148250dc3ef992336109f36c6e0061bb312dc0d3a8c482628d909a6ef2715e5178cae48908e0cc8f1090a1c1f1c3dbe792710a38e3a5630944e0e53a4a333afa3224c9b1d288b425e3f31ae233569ac590cca676cdd880dda537808f6ffce0d19e7a826b82c9ed421b4a8694cb1401da3bc58f53b3ea6dc133a025b838422bb2a09d747034c0ceda3ab943b47824b192afc921f8529e5990297442b15d2fc17ac86201e93f45a1a1c5ef6fdee684aee54cfb61c63cdd66a092eee35d70f7ab74b009e4912bdd91ad9b62c33e5a95fb531d936d89d8b8bbb456ff15866d930fb1cab75374f25e977fe3186703a6ac2037c37fb7829428d5e2feeb5316962bad8a6d971da3b3334d8bd754036b4c0ee22662de88d4523cc3b03905f234d63afdeb9e802326a9f5e1b57a1e479b4c952d9aaa23ebac0aa8c093783eb32973c3d49affffd6b3e387ae2b64fc6f7fc8095b571f6bfc3a26b058c287c8fba519efb96e4b5ce1510b4e072326e1af68bb644d71abbf3ce06ac3309ef15cfd96df622f7885be61df9411fc04bd27843b419e36d7b7f2f4b8403db23f09ae40cdc4f218e0ea8d95b6a30f73b7338f199661b4e02be13307c2d9ad41eedb09524e874bdac8b5cfa1101d51ab116a7270eb1b6ef0d6e77c76f1b163b3229601456bdbbd41406c729aeffc179b9bfd78e15f808","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
