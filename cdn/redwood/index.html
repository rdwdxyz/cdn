<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"210b3107dddcb4e99aa262f7715141754a758f6dfa7f78b74ef765b2363e5b2d9f8834496e4b96a5d78012d425c3549c3e4f027327324b264072b97f83de0abb95dbbdcfbe0ae002383e81e19a2543d366a470520c1f9fd9b36f76c75be1483cbd51295532cd2eac6c701ac7581cb1d41b52d92d1fc994a686d80926bbbd27cdfe21ef4df596a091635b7766d0a2b22ec18e36d5bf1adffc644da32c2b96a2f361ded01a124707f8d97f8a7587200e4c7927752996152c5ad8238b04bc9ab8ad79132fa6e3bc944ca3b9f4aac73b55576b3e5f5b91d3af7e0948c805b9649356c2642db5b085ddb0d2ceb9d37a2375493b948e41058d2d742d952c18001874111034d60c25ff3458169901eea3583c8174f2bce2c0c6473f81ed118a0699fd26f4512ddb09fcb6339f670042879c06820f6ff855172ba607eb54880b8bde5ebd06589bfafeedfc50088aa563dfe2a6956fd5f609c1bdb55884e0f080c34a1fedfd478f0d17846d4688d18211e1074a26408a83c664de8b800891130e99e73659cc5863d9f9f65dff16464a6c83b8c0afb1bfaf238a31505f4e0bd1b8d3d622c4bc01a478261a63889581b6c09e6490d778caceced00f83a4fe9ea4b7fcf8a5ecf54ccb48d0e6a1bd0a8eea06e50e8c358b12af1a097e0c452b4be9e92fad9bc38d6331315d62d008de1390738de765a30229bf644f0cfe997eda1bd77280b5dae86c0b16bb4483337f6a51778205ac16aca71d668f4dcfd9fcedd5e41101e0d0b6ff5b2aaf79e4609103e6a4477cd87a8be1b415001586facc9fb35e6e482da24c07362bec797e5e50f0bc193b4af11bc6646518a7884b21858eb40d9e38f98f5b214b865dc566c2502ef1382c2ebaf7390298565c498f70fd4da6c0d66f785bcf0931ec25ba33f9928e625e33b229c357b216deea86c2d61bb391ed71895a864c3db0b3408ad139a4db01086b1d72dd66a9f208501e176b5e9ec1b9eab815e5a412506b9a3c1e65a28b9247ba47f182ded0b3cee2cd05f9817afcede14d935d78207f10823a22c5e9f8186784613638dacc34c926279bc8cd14cf01d366f013b89314e09de8ed999b22cbcafc77d8d90cd1fe66638cb63492118cd4de75f58992a0ab4d0570f58aa20b4dbafb60bc1ba69505a893de77c70ce06ccbceb4a4faaa3e6d982ea59b9216813c568f5b51714fdcd082146fafd3a9bec8745eeddb9714767c58f9e053ed01ab2ae866736ecc1d5ce175e2160feea71427b8896b56ab21e4735e8f27693e13e8e86715fb45e28f5bc4fd103a0e6c9962116eac45b2cb1e9e28ad1684c8de5d1ea1146e28c86c44fa152c1df4f978403e9857db8442d0a01b7596d4233f3eb43247b61134f7f18561d079be462a555397b8796b9a5ebbd6b2485d240ad4c202c056653c13d61779e0459d03dddd593812b7c14de9975c2ad8579d6a9adc65fe9f8415338879b35e8ee8433b15b2e405017701c554fef4ed303b3f1c9f249795efca0a68a1328608850893be9bbbc122cb1accc8c9ee59ccf9bf45990e797fc641e5785cb2c5d6d1c058ea5a37f9930501aa02671ca80f875e134253230627ae49848cd07e2cc1e934116615fa90b88b45e83503620319d6f2ac48b423b33811cb0a4a0921dca1ade2bcc9ac70068c3d3d72047947c6e719fdbc75d758f4a6430004d78dc35393f160c45afd0d8eb50ea6b7e16c5a13b699a44c2bc8708e2b3d813616f02635a2607b8aebc0d5876a4f9c8fbfe408feaff6a8c45e7c6915fab89027e475ee762c28fbc77d54f42cf09bf493792428716ec77634d3c53ff667c432bb94ae67c69c7dc84b08a1c5d23a79bdc8506ecc8bbafe29c8fcdcbdf84f563e3d6dedc2c9ea6ba02b8768f20d695ad67203d7617cc93d1a9e92bf3f2b51e8b0970a1eafe5e54b09e22e150c4a068f570ec6183433cdf9d2500aa38912fca4f77efb98649cd2078795c5f64d0dee293f821a28dd3b439dc66059136724fb3fe3ecf27e4e8341decab054ed1b308d41afbae4563cb980412f9387cd210a0c85862ffc70c74b6f153d01503ee3123d54fc7ef3c55863aa75a457bdef7d6478dfad33b23dfec7d70e7b9754ec2723404a725596306c615cb38a127bac8d82e029d366caea851d5d6869125d43c5b2f74a1edd943662a11af7fd8451d0636ac1b47137ee53589b4fb672709078d281af9e77e06257d8113f5967d8b8e831c09857933d89b7515860f9d3b9cf5f4828bd4643583b66c4a92dc64da8fd707aed6accfb095ed92e571bf5c1524aae479035469fd2e3396bcf4541e349754ac54bd7c18beb827a529f34eba1cbdfebe40b8421b9d1754eff33714c223d43486fa9c2f2bb652b5ef4c2181548db1f273978aacb25de18a6720d4e5a43bd00b37eae7527fe98ed694d9ddba90518d7dd65ad0e0c1e9c025e1754d75c32a45a8d7f13aca042848e42dd06fc5e57b04c98be2d7b86395d283492c4214965a54830e20c55b9fab52ca64fa34f3ed433a7ce45c7484d5cbdb13037c0f912e2867ca6485089961e4f80b94851a81af8c4c17b595f47aed7f947ec144d8ce7a396f297e3548273893a25fef09947ec25a058540ee65e3c04b4effce820e7139e62bc212055af3eef7f09f3faf6300afc36b502211824428b99126e1af5cb2c8b78b5a7cee9194924297b2f65a088b436717842cb8482227da4c2b82a88a57d5387330d4852ef0e19e47b8878a336be972f34a5d382b91ba9c4258e7fd67b86bcaf66fc72b6d7add336c2380a59a158e78604a16a0e52d6e4b9c7fca4d6a23d3b596a9334b7e30bcdefdb6121f54112baeb785c2d78481f028d65c862d23a2b6b0fb894257ad9825d5136e2e61873efb35008bb5f93c3f5e76e3cce1a354d3b6a45f99071459443cf61e3df893d97b20273cd49ca9446ccc4ee11f407854f3851043b2896dc64be8f08ab173f6606c9696c5afc3e35fe3abab5da847a52ebb9f6c765e0de3c2d60de0e4efeea17259be2267dbd22de61de65b7bc566e7a103cfed302ad93810bcbd3f5084ce34176b85dfd56cbc9207caec6795216847f67d65c3326c82ddef55f5709f530051fd61a5ddacb6a8430fd3904c671f31b1ad17312cbdcfb9968d9084e8e78c28005dc380ab90fcafd3fbad35065f351924796e95027300db3df2ed554bafc04e1192899cb2b11f82f6197a9d2e8c2d98622c9eab6de0ad0dbef12e793de9cecb138379568047318d7dc66f9bf7eaab88e9533716e83a3523bde953e1876e7ab338216a8bb29a20a9e9a2a5eb50f032ef8e9780e39fddea5fd6153a74fb99678f48cba50224e8642fb9a60a00f19d5e28824f20bb23b4a61d55bf25ff18fefd25c2cd42fdce516daa4c6cdfecf0f23dc9237da7e1d277ecfb1ee77913d52d3f8616ffee1fcb051eddd4060c049b81921eddd3bf13653c4d140c484c21c7a4abb6c468755e227e48d13aadd7554992ae42396fe0514b829f4127247bd5129021ba0631e3c2c423191c6177ab2795b8f608b99a1748af8a13076525803f49796366e8dc147531b17a78d4ad8d072073850805335b89a062bcb36412c2a9ef7816bdb836efe6b422b07c547884ea3fc7a4da1ed1322e0edc16987357ee7fbba7cc202e28078f12a791b13fb7babe3e1b4da4c017f7d3c731cb68ef14f71e63a8a68aec186bf17a5553a9f30e1814cbebd7fed7d92e6b78d7d8732310740dc165f755a456354b80d8c9abae6a2dd18b355ba1062f08d340dc78b6f9fc2cd3d68cce0897e3a6cd7a5266984cdd55cc115d9d63156426124e72e086a227f8c0b28abe0596940ee2e1d8aac119714a31d6b37016972d2d18d71b8ae0d1455386b785e23aaccbd2577eebca4ddffbd786f5d7badcd48555f8f7473806549764cc83bd68772ed557e1405c2891b30f85f83d5861913c1b055121098cdee996571b845f0b6d9a2fe358ae820d813272d47c40f04574bb0ad228d72170d909c7093a4bb8378bbf4277d78f695047192e81313afcb5c9df838b22c7ab03d5c7084786aac822d7cc93d22451e98408d6d9934fda56065988d5f95d8bc32d05a2982c5fcc2247c60a7a1eb93a953d7a0f53c2f37b52537cc244840d57b2629ba04d70ab408a0523f6225b710d1d63ca7aaa82c8be6f565b902fb6fe4f014e26e71f2cd88569631959938edc46c1ad293fa1b32403707bd44c743927e3bc5b8ad45b7b63d613e16285f35ed518702c7c70f5af9de18fd9c8585c342a8341ee47a5af17eb67b8b35655d47ee4701220d6daa71a9aa68efa610465a58d43180ec90a5cd8c349230c73c1122b67785be6b5cf014978936a6186a48a8bea1101f0cbe98e257006ed1e9c137a35237f206944dc3219f0ea67a17a2f0373c20c274a83991667a2ac6ece13501bc61f1f7a1645cf726166a466e1991efa47db2daeffe61bdf80d6853f1c965bff05c2da07bc20a8ddf83c97389f504066adb588ba04a5c7d84292f923b1dd982fd804c2922b2f698e0042e88ad2024892eb777e2c064f0d30a40d35150b4b5526d39bc8595a538da8ccab421e247a38b319e8702f1469dfd07dca530979e20b08868bebac168004a77b8b232a8fa23790fdd7c8a12ec04d78112d2dd38e83aea993c57c26b8d1067c69e1b2e7633808e6cc52a6f13c84b176115548b897a3a4c2d7156339425ce770be1574fd2c1427a27c4ee7efa901bea65b4e6e1c8556a89c1e869886a083e8f633a498786ed2a440c72522e44d9940d88814dcad76b64b290dd6058b8912d77c8bb1c7550a3b93836d8736710b81218e665b9a965ce14367f537b86262eb58a35a10c0a0c3cf609443c97a2a04c0133852c9299f56983983940f8063a4cd14c1d55ee8ceaf4c0ef64e5d4926a26b2c4cecfddd6905073c7cef1ba9f98f191c40136c1c2e993c30d6b67356e5d2c76b4433fad2097e8def8f39ff5a233e6cbfee1a8e84ef52539e53226242b231012392389f241787379e81293d205825214ecfea2f5b13576d1db38e90726e328874c82b7206e0e1263115df3c3197356d9136436fc8e393eb78ffcc1a5b8ff21f2247fefd02583fd4b932e18c41029f8e932e3af8923be8d86dd17aa8769cf5a0a4cbe7d13a36fcb65e9bbd2e425d44f139578d480fa47ad66dae9b1f44882dfe14e15b551285df72f3b3edee648afff9b180131fc9f5e1a75f857952cb0f177b227bff39c2eec615522cd5e4a095581ccef4b00c51b404fa6ee78d0b570ed8aaff17568bfc9df29996c7adafb1fdd9e1b2dea93b4c20c6c33ae62e1c20304bd653e7aa26410f249a968f68f02ebd06b753eee6827b9ddbce07cf05dfd7540fe4bada0f9848f4858300f736a8bf8bd226785030a19adc69168cf6c2a1f38a97f505a5aaba4da9aefaa75955f8373a5587bfd621126c4ce4d0d055fa891469f0dc644bb3cdcee527fdf538d4502489e3b747151ec899ad3bd8198d44343e4e564c279974227b20c5b36d35f523238a56f41a8e2d9130a25d68e75a797e33ced5bc79d5cb43bb98f67a57bf362f1304b5f008dd94ca8a377c40c88d79b7a78c8d9a4e139ac8e81b8fb8d61fe3cf0a0e547f329e8021852e6cd7ae480b92de40eeff773521719c636c8cda6d5fd3c23b4ba56b4dbbb5a5116487ce32d0f7caa7894d87ec755438054b74481b14077f87c661d74d06b3c85cb44a161fb41cb2323af537a616c82f702d8fefdd8e701ab875123b59b47c5a3e760561d3d6a5d89aa4169ddf59488f8a7f06f8bc3baab255c7b952bb46c59ec33d701ca4d5823118494ecb596b5c20949b0b5d08640ccc6e12e94eb3614311730484b8fcf4b6774379aff9b9c2fa905e94b78bb2272ba700d91e6ac2e1d9f19aad676bfb6b20ba2e41f1eb495ee141cd3be212226eb51e67598e972d172dc22df2f4f62701d7bb0891bde40014546e6bb1f5214858536ac2ceab94690087b31894e082ca21069c81bf0ed67f15e2f1140e8308e592225ef190bdd1fac9cac8ae58bc6f37a419de782a3335902055678691d8d1f0edb4a9feb010b3d5426d7f58fd7c75889fa493fed03e3cfdab5f6ab0c2d28bdac39397c07a282d57162c10a9ae5c7b5d7b47daabd519baf25588fae42fd54e4376926828cacfe5fafc0b974756c8010457f001b5bf952b0efdfe4c46f96fdefe1233c08aa03ac677de1d01d4e6485d66a98993384cd8e0e2dad4ca1401f48c2d8d7f8b2c5b6fe1c1811cc838000d5b5e970f0d460e6b914decf6520f0d93ab1fdbed7896dcdabe987b61b0d84d4dd66f92dacdbcdb9c8389db24f2f6efc6f419fb124b0e49c6428e7624db984ffd3a78993f7a164ff27c080417bf5e50d1c1ab8a2914186bbfd4188fdc298312be1ff553af695cc786cb990df90a6b5facbc1ac6cfe60358f54114204fa1e04da3591761558f10bed7922192686c49af1270cf991b272e5a34d03ad2c308bd187bb57c7018da179c9f1a57483e38ad854d2a171560c8b893d876bc4dd1aa5f6a3b59adcf57a5aad664155ff265e791241c8301a9d59c0b0cd87ac1c23f2d7c87b59e33e276a287aae493e3aac78d577808482c829e4d887dde189e8496afa296ad976567d24f2cdf23a127d7e8c62841f354ca6a4c52be7f2add6b21b9ff7a30386689328bd8a35199e1584c2ef639bdffb4fdd9abb72dca499ab7c6402b47aaf0b29f7d71abb66249df47b11e0de5763636a75ee8524bcedbb5efed360149041fa910436670d5391ff50f8f8707c2c56cbd112e34c9f414a536b489bdb341a982f0e6a94ad2129621a3f90ddb43bc5f4e7e14c07437d8c51cad8210f8214048d092ca88c5bdb50cd7a62e459d7653384458c85d95dc31674d7bc131a3358fcc877667c9172e3aac5486778057da5385a53f7a5dc35213060fdf7a2f15fcc8c71254765bc982727b16f782f4e9db038a1d20c8ee4f695be40d05460969abae94dee6598660c5e0ad7654c8cfbbee2b114d742bcc81814f2742fed2e796dbdc7001ab9f33f7ada554c9c5eecec02f3be3399ae52590243d8da7ec239fcc58ee0407427543ee292f37807f2e86a9c70241ec38c65f7546d27af15e199f4ec971d8c4cd8886ca24686a94568be0a655e8af7007375078f1895afb83351a9e25520546ce47d8fa493126ec0fea7961829dbafe8b5e9c28d16e04b0c21cb77cd717bc9ce14ce286bbf639a5a7898751fa1d1b8315130b3a93ece0abe6d9be3fb5807902e462cf801c25d31993841f1a45e7590a07d6be19436af3d7c33926226118783e00ca7a61f1cde513a6d36d6acf1ef9f23a7f54993ca485ee6d8f717e8ee904745a31fd95611c7a36348072cbdc8db51231e8cfd6d4f9cdd5d01785ef3c015840ddc35a3f827c97413a2548409c20439665a2611a2df7f4951d29997db1962cfc63ec4b41f7e06d85bb6933d43a6d841d70615ea3f8466e1c05e9394b94f300b98f42f5bf8e6d71597c185df1b9259fd5a96f2595d8a99b850e4a78beca240381285e3dd64542fb89e19ec3984a6897b3d2e7c1bca4e6634726a7c9170bc84b4148554f09f48136e34986707c934e878b1b365cb1be62678ad44908816820cda6e4e9a0e48defc19b50d51e5a0eaa19aa259574c6e80f2c93728c741e4ebb307950ef2d80e4d6699caf632329427d6ac6f3ae405d209315bdbbaadf2edc7eb8f8276ef1c9b5984dcd6ebb4c838c5dfc36efed5bddc59c0b8669e4e1a6f041a32f4f4ac5aed46974dadd5078f0840f6e653f36f8bb90f0eb900ae1c5be7746585d399315aa17e8118f5fba3808be593da300f35ff0da9cf204c84d4a11636cbba951f5c847d31e1011d1a14f437c3e593622c4b2a055955171eb60267bbaae703bd6677c2b3cb32bdba408b7f3f97f75b8e2e61df4159fd4fd0ba98da8025aeec5bf04adb05f2f000395e413d00518220c60f6bf56d976d7e313fec92ec1e865757a1300de4c071214d882886f5aadd36b7e94027cd04583a89b4d68dfd62702884df69d17073df0a8ac0bdacdd01e44fd1e6556d358ff8baf3d0091bdfa0474af2e8c160d70ace4ca1752922a0396bcf9cf45b23f0005a81121c80ff0b505ce88df5e1ae72676101da6f622b13ff501a133d4dd7664cf376363693938e03b60a530e650e1d1711ddd5a2faf76b26c6a940ef0c14e0e6659813c912087cd0e9c1374f178114e19c2b0f18a685eb9aa9120674c129afcb329dfafb3d8e05638f91b3265510186e4038c90d9dfa8422cea71459bd8ed5a1c39d6b2d266747f95521d5a55e0e18a01edfd66f9500d30c328889bcd2c0bd21d5c7af28d8f9ffd6c3151b69b4d3bd681e0c722f4d1f9500f6e5b798db3ea1952efe259adc03c589c5c18bd25bd7fd1d1782ce278501b4017a5bca58c8761e6de36934cdcd2008fe0811f4c2c9fc772de1238d5aabceb426ea697b083e29ac769503c784f3e8a376cf6649d3d64ea49495a541d3691be7396b10a9fec87e4e389f8cb23267b5c15cfbdaf734e34bb63ed2754132748bbcda9e584c7ca1af01cd41c2a09cea0aea27423e7bc09f413b0a26616b228c90572215dc8d5ed17a6fa89ada1e7a16051e33501b1f463be7834ba4b84a73ccdb8f150e5c773bbdb1b51fbe360e96d2fac94054c728ec8c7ba14f9cbfca51565e8e30dcf427c42819852cd89da8033b45a97b8c25083635d2565999a2da044273c2ff2dcdcc1cbb28e3bc07db6d5a8dacd7ff8281e4b671fd2c94bf23178cc5c774f06a47dc635f00fc5d8498ca2272d004255f9687802a6a97f4d09eb2e9f32f78815c2caf6869592449d841c6ad10d53ff933958cb185bde49252be0c220b3263c6417e714d92765d7a5ef87e746a22bd6f36ac9cd401dac533f1d2b9112234dc59360d4178ab6479f5725dacfc6ebb4cd99cf392304be048e21512088864d2abcba4824e6d114c0944f2d65be12cbb9d1a106e4aa843e90bc0e3188d42d85e6dad07d022568e7a8c00f372990b378cb187205c35c0ed392939b0e8fca0e9756fee16c7c799d356df313d72e4f24efa0cc4f5565452ebc743d09a4a187a186faefb1851a522ee6fe17073615c9ae11c05f9c755eb799cc255a6b5954f9df71f466dcca699737cfc7bd6216f0302ce33b0545abacdac1310c6b29f175f993ef5e826b92aac8b04fce129328d07dd2bb798ca154b71b23d76914b024be20a74c0aa8f57e43b9a58c6a4a8ac6a87292158c662abded9a534cff30b3b4a141c1ce7f3789024dad6df6774213b5506a672961c079627d3bb1f0b9cae06f8f257b213b537f13decd441916c369c0cbcd101300ac27eb7e9f04192a1cb59ea410c5f55c05230f8a4f8bc09d196e8c5932215d3ae4a7510ff7c8c79fd7a15255670e105144bc92ce7c7a091d0689bca6299714cbe5c7b15dd71853ffee4ab65225aa62a54271580e731b2536554bbeb464c1a63f42cbc28d721c72b13cb165c993c665e6091146962b716e8becd740c148f1557fa9974210cc63732dbba5aeadc0f44c33934aea1bd5f9db15705ec5d4f977d4a18e7c131910eed17813aa72050b6b9af53dd9459fa227206bb72369003818d945c667f9db3d4d101a3b35b1e456b8730768459183bec14e3f52ca618baea7ce5ee3c3dd6ed524ced79835457fb0e696fefa727f4478315c33dadc6565d1cbe42cf3afb1023dfe8c7cd56f6dc9dd991adfd57d79a81908a15ddb73d5f48f894263431e5f1e7f4dddd503f325730cca15c00361eeb61cf506b5dced32c190b27c44777387c8fe87280d3b7bbf7c227dd6a46852f1a0fcbce4030fcd130760f3bf0f8b18a1b69082a40dc53053bde2e1fdf52238c9dbec95e62649ff12bce79206e350f69e8519dc3340aeb93e0ec3dfa837dee89a873c9bab771186eca90509f9d33fd5d3679ae8654c2887ced5f48cb571919dff0c6b7cdb7c82d71f455511aafc29397e970fa321e37cdcacb3296440f342a1c18512e28c6168965bbbcf446948253170325c3151e0992252081dfb9f9567a6cc26961e48544a93512b7ddfe2295afe269f7ba0eef270a582eee08381336c20609ad1e16ac214cd154d4eac44586788e9d44b36e8f965407de66dac647cbf9368fb7547e8f0004a3cfe8018d7f69e101bd514d6435602ebffb27980b7c454c805c7b0be91dba678f659833ccd20e3674f45dc9d5b6685f8c4aff59b16847cbbe0020969ff7d5f3f8ac75c7f3513dab30bcf7bea4caf25356cf95462107b749885903768b550d99b7fe7dacee0e054c18f847257e8cf864a58aacdf37f9e59009212e33349220ca36f50abb8739e41d514842e1b2102373c134edbb3a7d7c3e861816b271efec8a479b1fa2d6f64a7d79fdb7f08c5beaa7e1ce4a46345d94f1ecdb995ab604c1f45af1d0655551e9ce13bd234c42d0e908a22579a7f240c9d071409dfd14eb5a2b2577ded022f8c49efce21a1f58621dbf194082c2cc1e7feafd9bd7e2284c835e5217bc26dbe6d165276bcfa35fdef7ce166cd125d87a3451bf652b86c31517bec9a7fb3b60252edeb35d45b58e55b9f001fd31690512360cf57d3c8d558db5688f8e219a6ea95932ab0a9ffc87e4e12adcc06bcb50e1384d62e135ba7538cefc2391ed432f925016a8b74689e4bd8ea31b2c2705524833e2d0f193978f370cdabb8010b84a05e0c0f0eb30c17d12b1a9643a4476e0fba9a6276570d6d637533e6e0243fc413907be081005658504acffa61fbe803a22f2cf36c662d01ad3d892a54c80b5e4d45f7a84cd1002e1d2e5ef9ec11607174aaaf1f48022bd343b278d28feca7582430a33ae018a09886694d8671e7c73c3f180a7dd89417adfeb06b68c71f2a44a1ad86697279172beb55ad9c5e1c5acd9717c05f6ee3bc25cbbd1cc9deb2b9c030db0e6b274515f814f6c71001197ae50791ab58eaf2ab3545542f5770ed6cf7524e7c0ca47b9d2dffb5cb06bbd5b8d15abb61e3d277069a138ac156d8f27af7c41025e27df87fcad0b4a5e686725a0e330d93acc424c5d1c4f3f3d1f2af09e74c8ba26c0a7bdfab309b6a70c4111d4e1c486f4cd6ede1519127131a3ecebf54be2993e8aa9d8449fbc66ea1ef87799a2c2ff222623edf08625942fe5595a25f012f7d82ace19d9016152e2ad5b9d01343b121db332e2958c70b62ba9032999220eaf9a3b6c29473f12a262a755e28baaece722e3a9559dfb8429252ae4ea64c58fde7febf33b88274189a16fee94d354c2f70144b846672973497cbe1e4361d34b25a246d2524a26f2040da7418499ff212f115cab91c80b1fcdfdc8a7edf7c3280384437762baa542b62bd5159999b8646689d4548483b412b605384932825df88f1d85f9d25e9c58a5b5bebff6f9ab97510e09d6062c5a66274acb17d9aeba9c7ccb3f193f947d9eac6f26508b1d1b4e5ed44fdacf09a8f9cddbc4718398046631bfd878e1c6659c06d7f009524629b7203629250b2ea2b383961b86d96b5955b65b6370f37527cb8901092c1f171357106765abc9cc6b1cb2a0ed7ce62266079a41da8bd3ff2aaa12d624ac5bb86877056c2893ca375d13cee8004a2f11e36f1e452421b9e0aba2599338d2845765b1bad6518e8cb97fac42737268e7d6a8aa6d9a864c9d150b95f58a9c693bdf54764f0715687829040a59af1070521a7bf1d7a6f5a229af7b16f40a857f1a86b2d034bf4a3346faed8e39b089ccfb03fc281767db77e8f8387f73eb0131b7d502dc5bf6a78a5c0ce446a327d7815514fd8a16f0d3035f1e93618772adc84edf7613b5dd2248f507be8b5d443e685811358aedce9d8d4f666b2d1b76969af77f8de937834c0111917d19030469a4d3d8024c9afe5c1e930837e2916962a4115cc659ff98348722520e33817ff3f63b86edcf1d05f1ba33d36179153f159a6f7a541c5898d19a551f288775343e02e3ad5e2affe58daf374c95ba3747abea4c39ad2656f305d3eefbdcaef1330a732b9c886092b037966b4429c55d6a539902c55231d155f8999b9e34519ab2c4ef280f3690bf6afeef8a0d56aaaef829615cd8c74758981d2eb8f46c3cc73838a7736a6e2c906473def86806ee54d5f92e69ad058b7af6311b9b9922d6a41b717e6a2c06c8407b54fb2988afd7c86700e090f4beb07c06a89eee20d85c74c65980ba6257a292d93f72f046b7763da2c79d987ffb9353f52072f6b2406b7f11961a288f15f263398465b801766a9419cad6ffe70cedc6c0c270db7559ed8348625f58c38084b5f94a03c22739f724948d04f3298822792ae4a3129cb581b98ae57f5cc3169324c406968fd99b5ac3ea060e47bdafb0640daa8ec879e6589e8d0550d1e1a8f312cb247c0f72ed141286e3dcb23198d7b6b2f3260e98617b43a88ae92fae42b56c0d4c874c25d956f8020cc7a8abd7fa7d0dc29ee636d906db4c683f3a98cae934d5d5b863930a9892d2dcde4b3dc8d3a2238aa2e193b9d93247a359a48c52c78183c723d182bb67acbf80e4c58aa1086b44e8959d1d56236e42787cf996d6450c7af99b9740832e2b7c37e73942ecbe05a68b9e87927c9c66a4e4e4b9746f76abf94204ab8604999d948e4d94398a882d775616215f34e7da64e2d12288a8e54d6cd3ed4f0b45b9560c3242a4a454bd3d7b7ff96b3605874d2574fb4f2ae3c6f8a77be6f4e110d08276ce7f669e5428ed5f058f0730c28cf379657a79ad4f0cf3a71d2a0806c975b3954a627a689234d76181120f04530ed6e35b253e43893798a4e80f72ba2b4f9d38404429f83db77587b14020155a8724fe62d8087ca53712df3dec025b4e2439e79ea1f4e3f7c51cdc33b0eb6390c7a65b1e23d74f355b08fcf433fc448a51a25a382ee7fb0c7863879c3af056b5a8e442c2dc0c84bc60da790054b268b370a5a20f583bed414a766a6cdbba724513479d3157118f4b4df126fe390b33761d16aa817cb4b561b14f8ad67ba8ccc0b60a0e95a7d85ea857cf9665e1350d2a6c2a1205ddd1fa0ffd341cb0470d834ae1fc87cae4f056ba4ee53d63c8ad0b8383d4a34b82b55c704c45736dd420cc1c2a2ff0533ebeb4d61676d889f1e529a851f7d1329e39e311bb2be8d6a7cd194e458076ec9916950e63c3936b8516cfbd423f5605d470a0c435d1018b55a3f21593b9fe685a6ded4af547756786b9c68d0e3f75b0fb083cb7ffde810be7d5380bd53e2fd43a4f1f531b76ae41a80de7fa39ec24497d5b450592098565a177c371e03e6d3db7755b0f4b3fa32b816ba8733a4ef97448e148c0823f1673b4929015ceea2040c6bd82ac2481f76174182a48666be4d63ee3c75437c7af9f3fc36a218d0622fff26c3eb53b16f8fc78b0abde0d2d07aceddc55ffe7b4d5ab95b36df122844ba9980491c65e6041f047c1517bd4c4710dbb2f510de38ab5b948e97596644750bbe5c6c103a167b7a8d13b8e67152586209d3e04286dff8c3f28bcf122c63eaa36b22759a623d812d5e7985bc0adc5ecfd17fda73b02fb181bd39c42215a677defe2bfdea500b9a4a8c5ed41a5dd575d93168b980c7423a57439e13417c4d47471a3e550bcddb9f18cf8ebd981fc755bbffed73c6feee7ba6fa144ffa4c7375aeee9a534c2a8571f82d533567d4c2b5d8da20661129ccfc8987c3202441b1637a18ed1d1c2572a7eab76230bb373368d6fd65a8a2745935864ff1aa38caf5277fc6b0c906f13f708aaf9b3350cbe719598833cbe0338b773c2dab1880385e04ec64a4b4958e5e5c7e922539a147c109fddcbb5b48f95f330ce7b8ed3ebfde0b37910b4697147394e7f7a67426d3b88c42365bbda267082688761cdf71c4d17948af5cd293089ed09d0d3701e34574b2f7ae52355cce008ef51c3a2ca808cc64af20dd3f552f6e849069f5d1102549b353bd83af607ed096718e3dc607461de071cb6de9088ca546b87fe02ea08f48dc6982ff52cb430efef8234574403d9c61182a3176cdc5b38892f12b501f402202d7e098f65ad6d23980563b57fe7803c53ef1b4c7d03224d2e28328384a5fbebb1fb9679d4bbbd1abdf82139609a858533cfe3e4a0056832a9f92ac0227e56c6b68ab1162eb11d84cd38147c7b400eb56286d496f26054b81042fdb98ca4b2bf1b81073b8d54a97ce37234d72473ef0d6d2580fba358d919f08dcdf44ac688a5a8220767487d6da66cda2563a28eab3bc42ba2120d4459b3fdabb6ec5f886cf808d69dbce6b8a5a58d675da6bb9eafd4d7371828775b00ecdff0688360e9d40ed690977a90e3457514303c921da3968acf7687ab29b2b141de2b741391fddf1313aa7180444e5beaa0e9291b8b1d60c46814b2382c2ba3600eeb4a3225f4445cecdec2431aea15ce4eab498d9415de4b95d8be46464ab4676943885dbb840aef353a77dbcbbfccc8f3a54522910f7d67be29cf857186648d5e95cf8f4045755483df4a5347e6ca03f7ee66d366e2404e3865a336a527db2c7f5c37f1440a5f2f4ddcf082daa3ab09f698d243428679f48d131a24897c32840c829ef8a274d67636cbf9a6c82147c2cf7de8de5f05697476c909158810fad78b881888a76393898c78307710b99e1b03e0170b85ae2b32e4dadb27a43c5d5bade01c3c6fadcf773598e02e58476f5d720abbe17d54f78545c46f26824bb99ba8589fa35e6f5d3a946774eca8eeda593e51b64b285fe404e9929ceaad5a2baf2d9b74537ddded8fea5602995f4765ec4f977504672ec40c2a01670c4e8cd9e7fd10eaac645a5d50595cb56eaccba6451a66f0b38b28af1ae855ce8814a77b4aa0a4cc10770b4ad93d328d2f31de527deb5417dbf0ac3f12e2fa524222ea6d040142996de6fa1512f410757b40d6b3e8406147dc425fe940ccb250e24cd45edcf11c4ecf61fa9832347201835343da2e18d35941f653fde492e2cef74ba32e4836ecd8559ac19dd91c603ea9be507fa0cedf5225171b69762cd0c1a2555077be20ff88b214877f4b0ae5e18a524286eb88be2d554a2e01c198df793ed76035a0a9f9aa84efb24d519838b8e11a3e3751380d6931db2b7fb624d516ab02514f02ea0bcb3ab7ac0395719c08167cf44f31ba13466b86f00f725cfea7b5ec8f2815da540d5a511bd0ecb6578036a8b142d479b501d9c6e6e17ed1944f27568569f6f029bee6504ca801383e12584954a70feebe2dda475460f1097def88fcc7007874a04740675c19c17f7d171c0a4fd16937a860cd41858a8e75e80c5749f906bf1164a9be60a6ea44cc46070c867efe5f1d5b3ca0957b354c4e446e4abb41ae8a849da69f90a1edf1511bae70bf80ecf4e454777df8d9c496ef4e3b699893d73ee75dbb8b1b431613898d1c44ef87b413ebb4548fece2bb24fe6bbdb2b5b31a67cb92b8756973f91c248f7746d33723ce2966a0e763fcd93c2dce5df3751499e2df70663763d9ec047424f8206a448a840c2712df17a66270befccc84ac0f47a77f5e661d26fc68fdfebdeb9033a84cc172713bf390b78768e216e726350cfef2b75525068986a184b5753cf4bf5c494af4ad4555c38bf6bd34eda6476cc8bba12a91c6ee2104d54eeb74b25cbe04452f26527e7de1eb8e00fd9475bbe5ac4775e4a98520c6c965f12e4be471edd1920b668cf971766d8d659a40da546d4f1b65fdc61c4e5f76de09d7342b9b625156d00f08300b8c551f204a971d269bf7f65b79e08ef5981857750f67b493ebdf90c89a15fc098cdb6941930c0ef41d94ef34d8f46897b81ee20b6c2d96476da52c32a5ef947519e320ca980f9d584f7eee900bb7ff0e32632f4a9154d1f9f745f27dd4029c60d9aa60ca6bcc2cec285a1fbac454d311f9e83d40f2327aa11ad387fd102fee8616e45b4364718e402277d225aaf144c361d0b0c18150d863ff7e22f6fb1ce712cdaef80e7d4998981a1c384da3a97f1fa09826232e890adf6e0eff7b4ae009ea429983b8e277a14eb3eb17ebd0bebdd30fdd0d2ab772e3a60973c6ecbd0bbba568af6d9262e521de3bd1e2a84c23fe4f512c35ed7e060b72b77f1508368580d484ec369b47a1639d3f6c4ce573ad68fd46fbacf9be00f11a755672367e7a8ff1bd35cd9b382e95e0ebbfd1b9fd7258a83d0e50eb5a4a46621ffd84ad3667d140d3bf4ba6521bb12f06fcc8649ddfbd2786ec7cbe87306f83adc9d60c07d849ebfd932d71902b96475b5642f0b840b7021b1a1ee3c8825fdf765a5e22c066a3271457e62808b8dfb2dcded63c548ef8aeda8bae819334eaee8d355a38682cbe7258a1ff32cf9e0619abe390e29a3f86ff7fe767df197ff13a95bb41d0112142665fa862580ee281617cb64b579a536d85dc23220065ea57f01b79a416bb77d0c1f6b3b34973d691e6d426472cb3eacb93cca31ee4014ead4458fd1c782a4a9fc38e4f59638fa30af5ac0b7707bc33e23b1a26fd291f8b770634f90e5345a192e7c938402fc79ed13c7cf00cd3e51085d9d7712305efafd3cde1e222cb3a3513b167be73b6267270b428de4031ce1f0f759f7c1728104fb9bdca27fc27842c367535c3c80f5966b9b512b344af59e78fc31763ba764fe796b2d13579f9c1ff7d156c37af0fce9a8106cf64be25b2a6a8aeef1afeb1deee4edd757a2139e428c580528005fd116a716ae7472b4de62c4eab04164a37fdf0f220a95f4982f263fb584eefb4d410e6ac6f69bf9db3eb0802ab3ea14a77b8e4926a49aa71f38d98e052197c853e9d6f4c044e472f8ac48c4146762773ffd13cb94792b461e25d34edb9f2a58ba328ee913ef04ac614171e230425a06bcddafb8fabd4e406b0f9a186361d8a2dcfaa62d6a72e43111728da8acb1a85b26689ed88a73bae0f03de8f4d2bfc8b64544f776228d9656ecafee7e2fd476d6916a053494e7e4c40363ab808a438b26f64f26c885c137814575fd5eb436173f9064d574c3e23514df31559b72f52d723b5ed28cea1a98a6a8e2ce4cc6714097687791bac0704a3886b6914b3acdb2cc2a9a5ce433d44cc9d3eef0ef80dd5811da40d490c96198c5368ced63c29ea05660d9aa328d4eb2c9739c51503c6596e094a13338487e7d293d0e6e4838e0f1b4a876718a61500e35ff0abdf1f2723c069c9230b91f532ea45fe5b165dbd2b757df000b09674c601484d0489e7335bc79c56e6393fcd070b8da7445009373ef34fb32fff29363c14259f1efaad540f11f7c38bcf185a1f5be236babf2ce5b9affe058fc607e34720a2b86e45f330a609b950457d22778b2af81222f782f422ceb6dc24150865de5c9341296dad52913154e9a2e709ded614a6b1786598fc1cb4ca389b218be6a6586d796b2076f430cd6bebca4c70890370d4c3e3a4a5cb3e9a639c7beaacdcf61b81ee425e9318fabd2febfd2a11ef567b3feb941d5f556eccfbfb0ea437e5e19f5cc22c193b40378881af5a50367c43d9ad358551998d79abeb34b29f837c99a3932d68f029f2d1140ad65107f6765076105e7dc40a0a5517d971461efec19a6020e03d46b6315db220e0ff4449bce862022120c1f1d701ad44e8a286533097e051a1ea76ad1f3ca9957feca578941f29ab185730b3380fb5ea3e94ecd4cbb82cb7ebfd9bb0f4560a18071fb154b7ff864eb288152afb2f193bd8fb1d8611e55e11b76db0b2e45b5b2076f6f03eeb9ea5fb99770f0178e35bc877882ad6430a07f9c8cf2ce88f7ae6b4bc2a7899791fd1c3651364534953b8cf5cf57eea88251dea50447fb607d1eafceaba77e7e3c792fc0e6e541a9d76a4e0d408c5b08d5c2017e62e6cef2e9c99fd5a68cd45aded7903976526cb314a36c77ca2492920356b7231f47a976cc0f3d9b0dee26cdb255aac5e0525014fd7f251993f48a1c9bd31bf2858c6e094d5082a3a4d48b74fea178319ed4b1a7e5c2d0f4357074c958c9e97ff8d1d7354c4566055635451d024ec255c53c39e40f5079eb0bed6c308677ffa9f9e9d0b39405c530963ce95a81db95459c03e97692760eb7ebf2cd717520247ff8643dd88ffba","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
