<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7dde9109f9966d21432af19ffd3f4fcc2c2544b4ae9f3cdf0cdedc6ab76753e748143c3f867a2f7a2ec0058d06f24de27b49cce1112d5b3cf2b81018737035ab6a1da75cad61fdbe29f499d6eca91269c4c79fff6279fb34f73ebbb970e80ef1795903c7a3f89d822c0b20cb9490f26384e6e0d19a9ef8b6e0e1b44b654c0ba9fad4e724b883f7f3940181c33b2332c54b056a82e9ab9f7c36e0b11491bd05bbb43cdd389cad0c023913f34e1b7125ed6786973649fceed0e3dd2c3e8ad2cba6530797db350eb22b6c6975de4dc865c46cf543154482792dc4cdb5b38034d52d255792947f53131d56c90fd684b58a94ffba1f58f5dc2329326239942c97dd7e39c1209cfe21965d7cca3dd804c20637e807a86924b952ed2a1afb44569df2f19e2830f1f44d0d6fffda3767cf1f642f2f95d16ae9d68134a8fc477ec55700650ab283057636319862044adf2e78c59e162d9d994f12d47fa088068c87bf16f80484ecbcddf5e3199bacd07c8b46095392e69cee3a774ec5ca4d6315f7afe7ea79405772c3668b07bb0c2655f38d63dc54d49bde9f653187bf289ed4c8b28336e38606e989491e698d299ea0542bc05158317d4efa0a1189fddbe122496568a0de12e0954ca62fe0b8524f2839bbb1f68ddf0b445cd0fabc3e4d2db6f1376053f3cfb98337926967364cc6a401a065cee2330383fc43a47aec3847b23ac06fb26d096209927127a0709690a9de4b9cb7f7e3e51323dc4ffea4535f4a1e49be63cb1e1fe8cf88c083e3a7805494b7dc985c92e21a2fcc0fd42395f189afaf0be4c86d8e5fc9be9de073209b54673a160dd247e33d81d7b247c0567f95488e11af885450385cfdb53b03434fd9f8e0bd7e57516240d98cf8ec6fb836a5f33c05e5b912eb61252b5ade1a54cc7c63dcf1a115af5a83ae9bc109b84b6c936468e651f28be74b469bffd00f3af4d0a71f40adee6bca72688d5f7a00d92f4aacaf7dada1b5b98ec6a7d4d9e748d29e689685a1b798d2048e85713fdcaf733e2c6195784dd18ad9829719ed5d0da0b951f5d282c408aafc26d7cb260620814682491ac55b4ca06cc8097454e14f0590ebc37c540c2a020a8657b882584b7cb6d2fbd1355696f1c92a238b1b476d801cb40fc37399650fa5f1109ac4c316a7ec32b79adf01f22d0e8e3e5eb479c2bb998c69a40c2f2f9c21d51ce8d4d71bad412e850c4824b54d27eac657e6e389718a68797ad638413470e4a0fdb06d0727782bd5898c0fe160343784d850ceb5c4b953c83eea99944ea608f6e08b17909c2360b57013fbeb485c4f06226b7ba484edce59246ea7a183c00ff07ab71123166582d078f6746f2aaff4ee828ebc4b03b740703ec7ab0f702606707c39a9f101d4f9ecd58fd71428b2dd623da7108dbc76315d77447795e9a189dc8284d2a4d4fefedc2c1a41b6a204af0e19aa7859ec9a98de1e2d4a359cf4c5cd2cc223b84f1f3a1b072f78098d35990fad91116e9a9c5e5e5305e777779b081bb7b181441a571dd004460e5cefaba1320c9302d237e75c1066669806658e241cad67e3fc507edead0298223d0564ddeb721edfb292c03a1ccc64e13f9a1488132904d56078e0c09bc2b13ada73c27b05fdf7f5733879146a2bf16ecc61eba0269ab9d1eb52fd8a212d8e9ff2fb3a2d27b1718097403b618311e3894d4752c71f12a71d8143b68e6e6900266c1ec8bbe537a5a7e499c29e47422a0278a450e1d0c4e4ca528774fcb0cf307d8481afed1367da44840629baccfc2d36a0c7efe08046651c4310067dee7544b287d4e11ca559f6c0e5b4a4cc608cf097631e5372f3259d746b2d29ad45bc858a9fd929b52c8f7daa846bbcfb06ec1f24f7fa8588f7a9fceae592f9e9fa8a7b4008ba4f18069721d7694c583657d8883493871593b81b95d3ba4c0527e0ed5073b5f23d0b0ac80c841abebdcb48dfb95a4781d19434f1f03f81b9f1f030de2b5cddd76c6833d59a1768ea00a2dfdb1e070fa2d3388d26d80080fb51ba0bf4ee0bbea4e409870467d51a711912dcc273cb29de8adb55cd2dd30757ffe1066d53291dabb7ee209d59bb8b9e1e07925227171f073e5d2c918b4bf7b566a941a2f2ad4cc880d003ea009dff53c63ce53b3dd1d471570b5bcbf64608412a755e4d722a13392caf6a1f9d1bd77b67b303547d5eda1e2e1c9eb58e6996428d351ca7488a70ab5a76fc778a63ba5ae43e81ab1ca7741ddf3299fe20bfbe0de377c593eddfa5a2871938b9c19182f4f681bcbbc707ba254568c778b2238da8828b78b6a1993c7d3399250e08f0962b34f2fcee153d4dbf1ab09aa78e16a44bc034eae68cee925d979abd429cbe4004034f47b07299768be68dd169594115f6b75b69e3923f87f8749d0309b86b6fce651f2f6e264315bd7e485b3defbe9baf4e46aa0c3648df2dd1490db7e59bd89e29036419374291e733355e90e1118b9a1111f47b5b9156c9c82f33af1ab3f6958869ac6fb10bf47d45d8dff0cd6fb54420736f6f9b08bbd41b2f754bb231992a1cb3eaaf98eadde17d55398d45964e0d58622fcfc046d487e6fb80ed5098a2549f4d57385e63834db5513cdff18e8053d06c60014f55cdee282df90b77d3b95e0effaa668711077c68bac9619486e4e536c1c4ba6474dbf2f06e9ec7d6b17c372d6538aef8ef2c4e2322ac5c2751c2792b5dacf043c3f1075c63e62dff3355364c38772d28b4b38791a150b6bde20b818176dd501418ea4ebd985b6d33ab842dfdedf67009eab5f22d9b5777dde4750a65d141cb6446f4782c8007c55654ff8bc6de22e5040e9e6aa03d595aae7bab9fe8708f459c5cbaca17efb8fa4f910eec442844481da74d56ff333478a2a1c61314fd3f0fcf10e9862202112e52276160d117b2cafd0c83acb65682ab4ebac1e5623e500bb382927d6ebeec36130b7270b177e90e6585bf0ed5615a81d6ac34da30257598c1c3ec53aad158bfd780c2381c1669bb5a4c2b67d99b02eebe8c703227801764b8cc70a67a4302bab7abe8caf7e0aeb0ccfe39e04556fbb91a9272767675e0788efa1f16f9ae6b557d1291f4ef57c4d066d3d61b52c93e13718bed700a69001844acad1b775b99acb6881767c27176ed9cf413c02d79b1be53fba0c05671eda6064f37793de94cbf35e562ab5c1c271690d5081d4e6cfaaf6ea91b91f4f59a308d30fde0de7ae1526eaa8f92d1f91bb765128641a56264112747ec75b430a0e1cf4f48b0b27abcc751aebcfd5d71e86368547ebe4ace6013b7a0fdae155ff0fec53045a5d51a5fa09c0dee9e6097e870e3f7d59c18c64506f83ae643edfc1d4ebacd6b6a67d133cd8a630155477be90d69608832d71bfda9a09dc15864bfa666b2a1bb13fde1f4cc43ce7e0b9fc2cad2f8f194845007dc5fb2a2afc3004fec68eecc335f86580bb555e7e6ea13d4c19d740df005385fc3d81a24e62f802bd1b0645d9d9e3f47132902e0676f5555d060576f8b2402fb6af0bf54fdbd9f7c1642d0eb227a1c74e77e2166f096936956233d7f72361a618a3af449e0875910ea2200d71cf1127116f4ad5ff259c3e6c498ba0e7bd1e534ebada4cccfa2209349de9348c09d4481a727e2670f793063b3a7a53191fdbc7e8aff5cc3ba41a3fb913d9cc71f93b83b94cdb05b56918a8184a4a50cc432387796489a2112ff1e4fd5f0fcbb914b3c8fc77f2dd74b0a63148024c0106246248f1369d538fe765311c1c80f91a31248f486cd016713fef426dfea7751cccd15c1fb5f8faa92cbaa4ae65c033b8b3812fa4ed3fdbc6ddf87f5a8931a59a4e190e71330e32a03601f9eb908f2bb05ea7b7e46911231f093998b9ecedd7b9b995367c17c244b0b1281f16385d51f8769ecffd0b56ca303d911443dd184a723920444eb56328f38c6dd8c9ce194bb3879bd0cab963d588d7f4c1ded3b1554a66600b43d333ef6e29e5eaf28e21439fd890da3e9b465f25d54065a3e598bb46be36d1de6228913aa146839175f4b7813c6e3f6b59ac530abce3de36300e566a3bde104f5040f7274071c1191bf3304f554d77a23827163feb671eb0d99bab738c227a1bed8e181141671c058471726447da6f7ca2a2043f8fac9284ba1162e0e1d63cd5936a2ecb87a7a2d5ff036828381842111c56b3834f84896b86d8e07a11cd4b42ed9c2317d433b13abbab2b7a6fa98e76cbe0bc9b1abcf7e7cb60f2e0315ce36811633a38f34a8faf49a60ebb1188ee3c38d2c515c3233ab54048e92f48200f43912ebad6a8dff369f9d07b5b9cc34271cfcbd5a4d5d176003a7a74133ada8dde0e7ed36cb292e0d7015b66e8cd42d5f9f65cbf08116661aa4b9900bac32383d3af1963329b72342737b8019fcddc497d1f40d3ff2915c9cce38c3bd9c2fab132ba30bb9aa4a2e7ad948c88706506a24183a39cc73e728656409a9e9ad97c1419ecce1835d036bd594435580873b3a27da4cf87764a91491ae07a6d50a009f9bdb5a363d1b0d34c992bd922466622a75c6e0047fe3a63ca671a35fd4812b3ee66c8b0755756f39e878546834cc73fe57fb7bfb9e018ab2ff8d557cb9b7a4bf68c2e7c9292d43f2fc539cec7636eb7150ac3dde509b59826c6fa44c0ec0192f6e86de51747f57c73f9a4e7f0d042939f87634f970c6c166cc03360e663c67a2a766a722f21b4ca1b8140d27a4cd5c41c061a825fc04b329925477a0383399ab550255a946060077cd3327a6e098ad51cb5bbc5cdf3ee2ca66a7b9b0036777b226c4b9d12cdf34026d957503f3baadcb96b2a5520ea21d529d8d570e63f21b8b67000eb40be513735a600906ddbbd0fb8720276cd8d9293387c6e3f2bab8a8de8cec4be4ab3de496df23d4f5df07918f244f5b3b353f95d90b63417cfe5400e866bdc8ff4eecd9cadb314231f91517372b8c7597051803a7565cb357b8c201c800f98bcd495aaa69015df4db8716153ea2c5144e17304bcbe53f4a33abb1120694dca28fc190fed1a771fa2cef432877fcee076b141310260532fec8bebde1c1c81c66d6ee79c7177065dd51387c968fa05608ad9e12581de96c220a7cec10c3f318cce57f96ca32491e857132c8a1c919846ec473cf9e3c248a32e62643598484b26d1f0bbdf97cc5e5762787e32d0503070be121a9add5bc6fc8077a29424466894bb4aeae366f16a039466a25648195a72f89ca3d9b675a86d48b6210c689197e9f8c801279743b7319e268c5cbee93a65c4d61fa9ec34b240704952c474e11c0e5ca60613fe7a81ad71292200b34cbc278ac6edb1c1e077dd6cf2f50122c5f7ddd1e14d1150d81557d9b97236d59d77573ed05a9d25955c619a6b5b284a11da191b84553d72c460bcb07c808b7e15a33414c71c4cf68a76a3c2a970b66c60d49fd8600ed057d1f0e7c766995ca29d627b565f39ac9f93d0769954314d8a640619e100a1ea79aa6ee4d54f9398637458465c688893b6036cfc8df89bed8947cc15e164a3db2f23b20bd8f54ee89b458eb2a6f7d1b7ecf34c2dbde906d6eaf857b35862ee8d7d64ed76fe326f5551c6c7dfa675be245cd4beb0f1f2f65adfa838d9cbb0f407bbbb059aac543ddb26aba8e8669653b8045e96000cb12ad9201ad6f2e139c83824f5abc6a0bd72f99b8ba782b1d9e21acdd6567c9886609afa15b267a0e62209ed0e62af09ee561ac4d509b9f379e847ce7abb2fab14e8206751f2d20d9314512d44c5292fd7eb0bb4c91d0f491e6d449c443f1298432a94a171d9a450873362913b3c8d351cd9498e1c475371080ed11cb9449ae3f619ced7e993d77d3da561c4218f266fbbe3697a3fb57d1a8f707cf76e1d97c78eb9505f7544db26c7ad0a78af23d5a9222f3b9de4e7b3b18ea4c7cefeaebfe75da58470cc64a4ceaa150cc6d1fc450e6d1ad07d791cff3b70d07e9454244f87de916984f691ba09e1bd65535d033c8ee563048a97b8928955f4684a84d0e795ac6daa09a246e25acd94c3f4782d417d137ca8623cd6c4809d247412f5e999dcbb73913e6ddf9e92b549dbc5b448cf573f8d3b57c3235217059c670207f683c11a63e3581b4b41651f135ee2625a18801442507b22841aa51ceca9d61fe65db3bed39424b3b08446848620dea62d69459003b31470fbedb4269e826ae97ebc657936af7665f31ebd2d3011b5be6da2c9ef551380b95a436fcfd11b7e02a83ece4bbc41a8913beeafca95cae881c63b18a351b3a3366f0c0b3c975bb731eb9ccfd5a7ad06367d6514deba50e78f5a70bccb4fe847f19e879f46bf98d725705f2e81558e5d0d8480335ae171aca780ac903054ee3aad94d55adac1ef15b85295c7ff607e4fc9c0f20969a03ba60cba570d8bcf15b9e7f4981e0f0e9b3243e8c49c4c1d31b21cdd2689dc0566654175a7aef557887f4c11b6b71c7572e4593d077eb36aa5956e86e4da87ed62453d0be6951e075e0af84db4bf7806774f744600416c3596d6420241c94b69e493a78871a2f083522ae7a62dcee0fae382f96d50d5a28fffda7b4b40029eec39d47281a82a82278cf93b6a2e3da0fd15d243e66a30f6362caf8fd54e024e00fbaebb0c9658510359e629abce2164578e6fe5e22d593f9adedb1da0ebe045d1afd7989d3aca9267834f83391adc7e8be74a084f11c3667b0d62e9d8fef1b56d191f40bea708d51e857069b44bf6f805a50fb4a092e00e8a8847f57d5eafde6e3b5aa1d561858519fae3a11844a43fd01c8f0f80fa843cea2233de6766fbfea95badba9228c0c882d298462b9a967d240409550a48fe4c90bb69151ccd25fe754617157b1c19c59dcb0a53ad2d127371d688ac0a47bc173b61421ffa862dbbbd94323d0bed73feebd13d8cfac44f4deb46767003d8695c94748b613ae18070a83500a7d87b57bfe759c50fbe06a828fb0ce040b8d8792f9d055e187a5754c85cce7caa112b32ec2866650d99ec1f902675cca44100354fa38127c63cd3a54ad64a2dd5ad239b9de3cf75a0d07fbe808ffa2a4c471a656b628d23ff5c1e3ab2c40cde9999e3e3965e9ae664a0fcfad080bf26bac02c48aeb9fa8007ab69facba5ffd7741d4e3679b68982cb495ecbe52607452a2b82cb8d9fee70b28d37cbc9f5606ade1d51ad1d3b8f7e3be1a1587c42331d742829320669f741c8c0f631cbb4ff26f2f1aa0a3708994e87c408dc1980259a64837f9cd7174162d6ac998d70bac3d3f83f454e750df6ac7f62297c6f9d75309e11517f997dbd0c61cdd68b5e70559fa8576b94814bdfd7f85ee94f72c5315d992cea42105c96c79398c58a4a414e04b32000c6610f49904ef441d5bee7a36959eb84c9a24dbb1b138dd10ff2ad0a790ccd1be39ba24114b0106560ec7a2a1a672e4831ad39ee98b08a9558ce6eb0bab12866d0863f2b21ce4ff6c10c16f62f2286ee1709cf3b9e07c9e3054de6cf46c35ead8deab72f5e6b1c4c0b01b978d6090b078d23f341fad248c29b20586984925c7a65cb24b6d24e08201ef49cfe77fceccc705ecc4657adcb6ae5b4f28ea7aabba379ec63e97da116b5dc241b285801361fdb39e24ff5f18e3486da8c3fa94c1cb03fa22391fadd7e84d903c88bf099de09d55def1cb9c50ac9cbb9ff7e8321fe6e4a9bcd9bf266bd1944b97bad472634a4a81b8ff22d76a430b6f3aaa4f0d26dc65735b53f289b3ad0eb760d61b40c936a6ff7ecc865bde1e26f7eca7744cf99b99a2460fdb49dd54b1f0da4850f31e17be51109d9a569eecec2e0c41881744985bb8ea5129a8596357ee7770c04d079585a4b5c919d74e60944c003ff557788a8adbe44c054c0cd59fa6ab0153c30168fe2d8f5273ccd73b77ce42055a1a0b9d1918d2ca68b15c83762ec6e9533b68426c2239ea3dfe9d2a91ab37c84201d9c817e594040fa9967ef72515d5419166a5847067f1b597cfac650684bc734f5c04e42ab5464eedf44e1c90b2270c3dcab64d5ede6302d7f9de65d2d80d2e8e25a02bf3f8bff841575127d042c1f7cb0086caeaeda6e96a402a29da464592e2e5eb43c0a898ccee7ef63b28c8cf800384e906342d823ba55c6a3da8a6f8d7c5c254a0f2311c892a19ff98ef92615d291bdf1456209f602ed5368e63e9e253d447c1a9a7b61fc88cf049df5393237be3f3c5481c82d597a8083934057906d632461373eb234ca752b99598b7ae13c783cc5417dd7263f1a0fe12ccca14db85ac05186e0f512d801c8fac7d3e9f2e849fa9539d72ac3ed35c5ad263dc95f3058bceadb809b318b61955dad1f158f7dc0459228cd2ff609dd5c406cc1c84d0b9e7df701bc0f22a466e55ff3c40c3ce2afc52004c034a02d4089a29b475902f8ce956f3ce7ae23066518b8170644c6b78758cb7c4d3482ebdf31500e38d90914170fb47044bf658b89fb38f7bdc7a42e8e22038ca80d99ace1bbdfb5c59a6b60aaa1111905741d2c4fae7867dbafc33d89f5f1b42da3fa2a281ace9c745288182edbcc5603208795a365367c09184022379e4f5de8202a5384b9a2e669de4dda5bc99ce7edeb23bda3b62e945ab51a5f91e4bd4c835c3d0192dac400c1313bc926445fb9c98525194ba12fcc7c1640d37ee7b300ea790c2c5644709f521f06d0789dcd0cb452b9775ab29b4c1d8852859ab0b32ccd00cfb2b00aec3d070d5944d3ea161996cbf9005f7ad7834dd59ecc92a75f42c0a8cde99521b105908198986d810f5b6144f64fc054ef5c4859642c5dbae598596ac5f15ec995b828de1dfbb5c3df9a322374cc070da3f1163dd41ad05424c23f3e93863e624abab420229ddadcb2853df7eccab44b78b1902260cbfa57951d2a5d5acc408b6ac9c7e25eb70fac255c50a7c35db7bebd8a3ee484dd69651dc7e8903afb6280b4dc7c24475b780921acb5eec0fe97c533d3aa45a5d5fde428c244c554d0b08cfb440bd5fddcde27b0ca9422b007c2a329fe84a90d307100e55c8637f5c3f795d1c0337b4716d81a6e7e07ecb36f8ea4e4028661fb8e87ae96dcf802df4443c469445872fa7863e076b0b7b9dad0f5b567a80e4c6f7886fca9c956c9510769e143d3bf18ec3af1a45f34c1a88c07e93dc8edf7365efa96573ae00ef0af44fe94664d605081f595db4feea73d7b62a5459553e0c4b048aff18aabf8a64a6689d712aa7ae00929dd664230314f886b018b98f8b2856c881fcd5a4a0cb03664ce35382fe11aeb9567e3507bd5d468996196527b58248102c8a7c660a45c895c3909f4121dfd84613d2123a35109344e348329fc785be50a8be8de8bc60031a7a520096d7caccaa29d1ee49fc80a6291cc408a4f0bd49ff85b8e294bdec81127e0b680c76d93b5bfd5dbf2470df14e913f017ba6701f7d1380b9674d38435e0577375fb9f483358348910e639b64e900b196b536cb1dcabca7f1300b7f28f234273d1c1192ce0e317d57bfeba099eb4e48afc992f56a6af6d84076601cd3578979fb2da77248126c8e424a4020c97ce5764d84e4cf4495465ee50f44a1095eaf9b5c9afdc2a954e1416356fce060e6f9bcfba4a1f8b2b9784a3a0b12196fd9604a2024a2350ad71e0874537c3c885ea3b889864ebba90041071cd4af865074c475f1ba2dcbcc56bd90917260ee0f2a10704ad966b029bc2d8337e95f1b8fbc765f497c697f757eca0c35e32cb0fe4f39b219603d5e4f8214c3d43c39f80e2934339e130759a1f629b70f2d942c5cb5820d4fac15ecdb503450fb94cd5d76a3e321d4baf76a6c38ac9ec045b8b74ce0fc07ceb7473d8c3af9d39aad7e7f6a3560008ebb5b7c60d40d290764bf94927bd5b3a5c9b7a14d14673b71e4b8cd8b7a48a383b933f697be2a82b19adddfc7d5055f932bfd18c45bcee2cdb20d2b8ef9baf54c2e7390c2b27021babc530e7d741947e126f7bb89762f862e713c4a2947480261a9fb45b7e0991d95313574a0727b338aec7d2ce24595de3b048641087f988dd2cc70b42c28e799329ba7d5c8e048432b64979c1f2e5434151a78925a5d1fc5085ecaa44604ac9872546325bfe1f855dda7177fbff409ed04d615a9e265d4b11e9024fb8e6569e5fec639981e122ca37b510b9ae22e930c6857f38b13e7fd9812abab051b1645a5262ce4bbb1f153a9ce45aa60a646f3066573d8dced23bd29c91a4fcdc9cc3c79ca90f3f48df70364f51583417ccd767ab883a8d043678485d7e3a7517378614f94f154fa533431506e6ac689bb8ee435cc68064f78c0249040685ad438767c3b26522a237e2f21ca77602de212068a14bbc10b38084086d37532222c16fee8d4dea4ba2058240fc5ffed5877b3a0012b1fddeb6f9e217b6e790d20df4910cdceeb0aef8063c92a5b8972a2ea13057da6ad43daa80940402156419955337bc948a9d30cdea8395cf2fc190b0804e701175f92c71fd53a95595790efcbca55b562924e66e07855304c6b83da9078263a2f4e73773a10925fdab92951266fc5f55cbedfeef087829626fc2f81820de927b2647c61a30acdca98a783417d371559eb482bbf333b70a7cf5e34d757b76dfaded16052057a1d34fce530d2ad7755bd8be091aaa9ea6778f40ecd43c01912f47ab82632e453dbac8cb8d8d0dde2cff1703775f626df62e5d6d72179687c1d9db9c77bff1bc3bf0d8826d98aaf7b759345799438773d13590c4431f532852963968b66b55b9c3ec52d21a9138019201ba52e46c1ddfc209ebd079825d02565b76cf33d7906e0c4c87c89a03aa46207160bfa6e62b09faf1b3a3ef6b7124a10eb422bb5b81ee88ff16e7b03e6ec1b93e3fc8ae1594eeda2e3c686f50f3eb48190e763f1ebac117c4c47ad4c489d355b41fba8212a360ecc0a8f093537e242bf9b071dd5a955986335dec331c97752dd9ba04e1c612ebe97bc2dcb81754ee22f0fdf452822353dac679413edef81cfd3c960daac1b8fe1735abff7176d5a2c8315ecad199d95f003e968f068f351bc3c5ce3ec7713c6f83be3454304030833aa53e57f40830fc12753f51ee8160d47585aa125b2509f265a45b85d1191f5b289ea950e98be6e137b006d5b4e0400ae3b72e509ce4fd3c8da6bb4fa2903378524b3729785bf8c8b2510400b56f46e412b0a4d4f9a48224ef08ac377416e5b6fb2137bbe829aab54892b2897e62c017a61da023e463295a2c9df8dd1faea2e8ec3d7880400f61a61057229ad48151127529c393fee727dbfbbea21871c0433b280769328c8df41379d04f32a9c6e4dff0eed06e796f272454a251ccae56292ed76ad49a690f720311a277f7de45573a0c6a799e87155d95a0a2988c4a362b905e253de56d53ae88d3dcd516dfbff00dd5b9aded1b50a986313a6153eb8b5d48ab19ef5fa1641d9170622cdab505ef37aefcfda23e5ada58cadb6ec6729b0be270862e81af128b026cf58869e419303de99414df9b79fcaa6a497d31cdedc3ff52c7ba8094100d09f925bb8be968bfb8c0ea6a2505b118d614b05a6fa9259e06a22d83fe1bd7f5a1115e3a5f0e481c4764eafd00b3e11b192bfc67ddde5a7ad436c49309cd8d9b17e974d7955c60535073c241d35a15df427b289399424b2571b7839298aaf739299068af7f325cb767d59114b7a50020e40aee55f52cc86bd2e6c02a787fe10d362ef871c4b05a8e5a9f7a36b0961bb3f6e502b89914d71ef5fea0f403b0314445f5ffff00479646efbccc3186798434849258ce2ebdbf2ce4416ada500230953a61cc6513661cf7dac4c190ff5d69ea6db926311a336c099d80f268332cbd83414dc6b581dd03e689d2b0cd00f7bf8ee5890656301a8b94b0f4d799071777b21697afd1f57b3ef10c70a0ecd1864103fcb043d05bab989f731a680dcacd01b435de6ac400b0f2545f7a7ebe4c9d696cbebdbacf948a4f4a4e4fda304cfa6b669e658fdf83d6600ab221164fc036568c4f4c3d9afe2303761c7b4b60ba4eae42b45f59bf57997298b35f67232215efa59a60ce5076ceac1da75e079dc0819674f8b78758dbed3ca893d12f67ab1f787e9681b1e758f4105a63b600db65671d1182851b3995a194ffe97fcfab34bf98b7d1f60f27352e4ea9f1ad6c303741c9428c48d3f4eb3e1907ebaac29904ac92b17eaf034896a34e3a78cfc6d16f88666f61ac414f48408fe59d377faabc42c4f4d48c855601cddd3eef8c4088f964d0d18c444ade6621584b8796e3d4d1ebf4d4695df4d9fb43908115a5562d1c3656fea2a8cf67f710dd710974d6502f1c96bfda87de2b0d1331169e7a412154522c346d8f3e60c66ef6872ba30f93db9e74e72722f1f5c76b7c0fd6c0804ebc27921d3e769eb31f9db5fe53dca6bbef1651920903829ccb52fc2b14748c664268bbedb8a6b804d487ae010c4e0cd1a51c98412537e01f9727abba4051f6f29f93f53d076b973a5a192132844c0ae402ba2246963bac8694f9b8a45b7f77ee73a910630b3ac752585dd846cf36a15d28bc8a0b3a5ee212bc17ae3dd7af194996bc54d73b184d7c19ba5e88117418a35e8d2be5ad435612c8abcec1107c510770b44c1100044e0798ef1beba8c50fe102e6fa73cac2d2a23b3550312e512b71739b73a55e5d768db1b066e79362b498ac0f2466dd9244014ac489c4bcf1468dd385b6b002feb88ffc8d84583448c11e2ca0853b9d8c85aaeba80b0bedf7da1bfe6dc791910ce0f86ac04d0b24699a47ba0e4a56be9945a341d435ccb652721a28f5d786831a8d20e19e3afb756f174d0910e3cfb3416b2559ed71e5b061e39c309b5da920b364b11f969f7ac3f43b1364d56c3f408ef2b48775ed3c8e756d74441bc2075079d323cd4e93313379c7e1f7f25aca09fe95a750835f32a78458c3746935c7f100d4abf7e3066002abf655e31ade1d37b257af32c9514301155f3cfc0a2bf12c08f96f3b2e46eb73a0a1000618391927269a7e2c69c57fe9be39c2519138f40355db3221ba7b97d50e317322cae09f95242ca7f8446e4ca30347401cb078bee3e40ec4a0a8b883e41d186fbe1cb46e62e9f6cfb9ea3c334afdf7fe0cf6b41c4ac6300a0eea740083d6b269320f3f9dbbf8d635ea872e6ab9b052ea579fbfe6f2614535860d32f33bb2ed12f1a29ef8d723a0ee866c846911b65c5fc2ab884faa0edfdec0912402cc09184a00eb7620d7d5309f9c2245a8d8e49fae1be999554e3ffd961ac7d6e30aef47f39216afae11af26e162130366c026675048f1e68e2511e377f4548ab1734639c423942e6b068574e4ef8beeb5f6903959d1f39a5f3d2060a8ad681b1d10c59199349d03439bcd09ae543f69d220ae245474cacb0f735faaf2223d1694cfdaad02677865938e63b70a27015d65d8e2da446fb3c059f36bad210f9b3369752d9eb3c3794b7ea1d343efa2155b61de8e7c1a25fbf5344136f795cb04cf5ba2b472ce9ca557dfbb437999597fc6b3296bc11c59ad7666d2e007d76ab6ca3da92da30e5e82eb12511ff724d7064ab7c8206c49a17eff4183aec439e6fdcdc0e927d254dc8a1827087d584d870ec76d58c9c13224f94ed8486ab9baffab82e70308fa917f648376a4d4edeaf7caa109f4f4da6a1de76adddecbab3e782c7e8801994c1f36648c6a5b6f419d75e1a3a1d4d4f61440b39e96a262b127362769c2efe56b1a8aa8c175bffc850a6f949ac0ca3bf9fef96d662e8c89943f4ffbc92979c40ad3fd613f65df08070b5e8b3fb74bf78d723b709f09373fbd41d93248832490215d7fab55dc417fb9f861f0a2ab996b933d61af3eb3cef94eb27769af61a9e807324bf214b82ee83148516aa94abef98e33deb272ad75819f9a06a022dbcbe9fac0f9d2cd0534add7ea4d623f4833004ba8418383c0ab850e166556960708e2be079ba588cdd9e8d9d07d574337e00e5a019f22d7a63b95d19a17ef7f07934419d3a85d5e079dd6ba06773ba2fbb62a9e539bbbb0bc27f2af1693e276d682d0cc5703a304e3208ad206cf189829b21bcd48b5ad943c4d746ba95046af5c71e244c4ae530e3d175f188ca98224e0d9bf36f708c078bc75fc011f7301c72b62557c200d51ec5e013583ce9f76b0746f87fe34b0b43426a186bac4fe752c91231a400d03c8389c8be70744a38b18d659b66faac609fdf674593960584f48bef8bcd5c9ecef47f8830a4068db9a986c4f5d3a9da67210e74f73284671d93e892387dc9ee82f40fc4afdbc0700c5ea32c1e4a3c51243bcd259b1a7e39083027094aa5324cc317a83adc59e480f51e1af4668b538fd758862b4af9d451a252d797880cb9b7400b1fe83b0f1ad3fce44251390b1e75fe88fb2247327522a8c3d095ca77b5f7c63b42ba9ee42d9c20d27507a90cd6b3118a0199df9a01a340a935a26f572f087c77dc7bef457a3a2f69d909a43b76cd13aa15f8fef301a5d82052eb58beacc899486e3fde1d405eb8bcd39779997f0388c3942e45518bb24f093efa0042997bbb1168a0ab15091b0fb142007861e3c0f9941a830504bc1a14d5031433950ff279d5e99b1cd086fd7bdb8c39c27aa48ed8e3ed8e2bdc7609cf371252ba0cd63917d82ea6e12658fef9a76d745fb0578a9684d439ca1f99f49877a6a9c30c7292b522de4532fbf72ebf10c8878059ccfd6ae2762575da3d7b76155b1067b3691d4c873169a70e3507d9b817a27863147b374794d6ede5ef830a3c3fefbb86466a3346ea7263d504d5aa735c45b06e06e8405ca9851632b8faddbdcf70a17690cce5344020769a5a57d73c3b904cfc49c484dba523ec10156e9d33463d759f40d81dfb46a3958f64cddbd6d6d16da5eb916e516c1c852aede40678fb49edc1cf879bcfabcd1c31318ed954c6940cf42f7e82426f2fb150a6cea398ddaf14bafee7d25fcc31f6f4ae7958c9454c9101f87ab3a252aed17705e403a0169adcd39c9c104ccdca9b211b536d95b030d2cea44302514dbc6fe509dcfa4ff7270a05524208b3dbf51f20cce3fcf513b4a7ec18aa239db88c75b5989a1b335c8a64859cc369aced05601d7433b0aa6a722682f95f24110d5b9351d8466c41a31466b62afdc2aea57c4191436f26a99a8b9fea81d783078c46df2f2cdd2b222122219b71397a2e8ae9ea47925bda08456b398bde466f76544227cadc93e5b6c360247655cf5feb46eb66389a3aaf657961619b16151cdaef589905f11154394a521ca514d327f2f7f98f5d3b202112503ccd5a434e1c280a8a14b145ee13ca1465acc0b6bc84c095ade2e6dc769887ab6e46cba2ac168726538ddcf301fa162df667e62d79cc5b513302519ce5a830be3bcd793f3a3e8b7b459598578d56cb92496033b9b6f2b9de2b4ae9aeb912dbe51d52d57c590c43d9fdcd76cdf0adaf108769c55aa5538ade416e392f8018131c4e210d7e96cd09b22018e43ea71ca3e221a69833f3462be4e506e4205c8fed4ddc1f70947b0820778378d4994505bc1ebd15f5f9df7f2d7f32f0176b78496c3773536f6055e2303491e080013260219cabbcc8d934420ccaad77dea3aed10451ca45bd19d70cb27309ae6a0c1fdcbf385f6214f03c45035df6859da750b9e0c90c9e8951a3314f43c7600635be38446d671830a0cf923472bfe34cfbc8958efc05fcef70a69bb4db0eef86e917d07ab44341addb73f38d881366a6eb399e2474699586065658d83945dee7dbcbfb6e3cbffc68ecc45feb264950c7612061d72f23ee87c10fce992028f8f86335bd8edc0441df85367eb71906bfd0ebc48002d886a69ad0e9ebf699b353e4659477f75b4d4b518a9e2bbb03816157c2b82d3811b517801da13a21138f9c1428c8b0811006a3f8e38b0468e13871a0f9eecff98d5a9d0591595fbd39a49af54fd260eae1adea9c629b403354c319942e7faa386656f98e5fd4a09e22060cb64f36140b1a64363adb85cd164dd8aa45e9cfc97ff1bd70481636222a606f881d1df91f9bb39a5836abffcd3655afb1dfa9a6a56cd5a0b0104e2e6aaac4f08e161ec42c5dc005d99e0ce131767fb8a35b72c0a5c620cfb6cb09f1f47d14613240a7c05b05f6497c06410456249bd06c3de1950d25b8fe6202188ae3eac740043178ec4c8c9f9081143ea726bd795b7b1fb08a8f0564d4a4ae29b34775e7eaa22de813b5f579631cdbca913609c57b0921259d9414559a961648dc3b98715476d6f6cd18a537bde42ebf8a48a7d417ba53200d673a721d69b07a98cce04db82258b7cdb89a4b0485d189a300dda9e99afa04f67562d23cffbeb8187d1f3b855f13a98e5c3584abe5c3d45195b745f873f350dfcfae8f478b4b8b01d1297468c923b884e595a322bdfc329bfa15658c910d045f78188c853a5b61bb1addd01d96d5acf84d5f4c68057830e3e84acfff7062f5f495d046072cf0a68b140fed5d8643d1517ae40131f32cf20ff185193c8b7cce216d0c0e8d79417d73eb63f94893998a6a8576c1887e9a2d399701f74fce757ae5d37696823bbea8ab0a49576b4d9a5af58b3902e1f1199364d4fbf2cca98056d3d05f1b70791c139128a4ce1f28bb44f6c28f35fc36c94cddd86375360c01f7763d3993fa17b23e3d11d8271e0ebad894bd8faa6dacb09c1914cb33571e1c06e744eb34d412b5df8bb1768cc2016280525610e367d4eb892a7644de51fc8cde4706fd17e2eb8578ab8053c6a4d09da7c3188fa695c567b49ece17ada9354950b9fbd836ae1b087b0754d6aa3acfff4196f8970f556ce5ed93097b7c7f16681e98c757e65d5dd5ecbe565be21f6b7f62d6d0acbf9fc528710deacb9d1eee5e16d4da1849f6a8cb661c13d02ab59507cb6b543dee1933a11e3836cc501b1d9b19fc2023deb2f7dde622633cc57c53049eb4213736922a86280a7e10ef8a61e921a942426aa3240b1bba1765b6f5ce6d9b559d1d35d533aed095ee3dd0e4312d7b86a6e7dd9ffa0c03c3a3966600e83a0412ab8b8ad5d4831d2cb5248159d5cea87ebffebbf59a95b561a15008ca81859c3fc79cbec7274082d4ade016e3bb0d657b84abdd7d920d266a44b68b85c4b7fb11c36da518b88e861c2ab4d28cb8473e4c309db9b69e369d92e6927f7b67847ad07756f878a4a2a5e52a781b486cba86451f845676242da02670bb72b546aaf0f645e78ecccc5979775828585f259a5a37f7e8baa47f399b7e45c68f342b6a4b49bcb0396393f8bafe422a144e292fceb06b0222a2fc780792604f17059500783f0818f21609cb50e764c906a2e80f599870d3731d840e55701ff072cc9dd0c5665b1153ed03cac220a358d60a3b3817e1b97b9ac6b85f837f8bfb27ea6a5976bf3353db83ae9ea7a201898f77788aa1bef4a788f1cdad7dfc8d52346ead9e5c3d7dfe09e5ab5b7f09c505edfc86517ec8a6e617874b09609fc5486bb2fc9baee2bdeceb18354f9ac2a8250dac633ab1b44c61cdd1b1213c75b55f965a0ce9b30c24d420409785bb3b88690e291e8aab77b3108781cf3b0e3951ccb50ab6eff6d64389a6862003b36da872c6eb8c71f4cea7712fc6111ed71a42e793b404a2d27a61ac588da1ff85fcc488f8da03da7700549f02dd1b7d89b41e75636d351a17c73f413dcfaea1fc3a2af8c787b65728ba330e83ba0ee6440158e7f15e6bff0440a2044338eb0f19c83bd01e868dcdb8f20c80f22639d5b3bd7f6e5576cf519d5f970e8786adeeb9907976011219431dc5c22cf6077aa440aed2e0c4d59b1ac73f6866d2d4c1869b6abae422354110f80d8633612cddeec062aac51502b4a6dfa3ccc2a6a400f1fb9872fef0e55f70ac94c2ddb87e4f0f366375ec0b7dca053d52e952238698eca822f66651c13286eb7256fa2205b9a71dbadb686a0aa5bf3ae56defe64a1757a2935873eba478024577103baa0f2f3ad01dab168c71fec316804b5a60a37dc61186961dc4c3f937d053b9c25c3b2b8dd088f6ef2916ce88faabefe8f4bf993c28687ef96181b5e4fdc63c42fb0bb6831fdf58e1a9ba2ed42fbbc36f55789d6548e37879cf56a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
