<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b8ff1b7bc7f1fb8b911054fc3866dc71ca49b03598307e54cd147052fdd80e504f5ebf527dda5e3d471aee73ec5cd8fef82560cf53921e8289f9baa47948539b87fecee975289ae167924284a8112451ba0d846e4c7303f9db24af6166d9d5d20714664f26f5203facce8939283e0accf3ac4187a1be60a4b9364873434ff1b935e2d3df85899a745b8cff6386e5720a206ef682f7a9c558d5371a168cea2056ce58c37e5a456ca4c7bfa1b59cafa8c59e6890bde6b9a5a3cc173adb3a7d655deb6e153edaf40935f11fdcdb432234c51638813e476d27eeaca562adedff672ad5ad047c6702ac04a11065959234de20d71bfd1f5aa8fde548e835f9de57f655508b7639905a121e9538db7a00d85334d91b810c69e2eb55b718fd43134c2ca3e686911f2d2aa1706c567a2af5a54c6ee8ac243ce987d7d0707e7e55e5e7950c15bc94703ff2d04203297b1c7b157cbb16a1452416019e7d5b0b80f8bfda3e73a56f240fa8215199c87b8bcfbdb29bd3a1dd59e12b32d77bd48750634d48fef5a651368a739911d16b644dc215d31db5801ee428f07e9920101272a8e19b46a9c6b704e2e0d6f7db703dbd20db0d505cec6fb1e6e9cd12926456f13846812aaafc13cfa8db404e08baf76d712f6a8de4b47514b378057b7f0d54867ea6f584abdaee5b0b2161c0235a555db694412f293061f4c59293fb8756cbe6119b322d9c96c95ac560430a8b4f533aa9d9b7aae91ab9bc0a35022d6bb79a8df07be91b24008ed28b259fc9db7b4689b52fadffcf7873c88e3ed9e6d2a073b737b64850ca084e7e3746d26645f25311c5bc37ed3b320124d95874dcf2956a56bbddb7d5e6389ac6391bd9a1a17d98b1c16b8de42b1875198062167e1dee95355990491373848b195c35be82dded3e98344b6b00da87f10138ca72774bdbfdedbe7a8cf9135de0ff2da6acf7d43909bb890539f093b1c4c959ab40d58dce75a8111e24022604d4a779ff4f9ac5fccfb4b625d52369757b67feb5b2cc0806a7853a1397e1ff750b97a4f46deeb17a505e74d741416fca2e79464f85645dd65db588b829b7537c042938bc59ca341d9e6294328e7c32e18b657e89c929247c5180446b615fa8ce525d3516d393cc163c1facb5deab286336ddf935b3eb14ed1419206ca707fe5099318b9f890a1f4562b743b3e1161e30a99b0b2c1e2e34d6fc9deea39634501669fe6c242fc0d225f9f4286439427c27b916e62e7c531da6edf0be4d2466c9ecf09c4ea1645ac058ac49eb449f48617dc5f36ccbdf678a0b3adce8a6222ac785d40cd96117cb617337cd556d9933e4611903f7069b56dbcd4332785ad60b361f89e7b4854508d68cc5b37960b435218a126caa706e1ef4c8ef7c044103e91a17ec7b86c1494fed07f8dcad479b0331527fb36fde5591e219013bb2a26117d6c45b7e386de2de22e75e54036169a3041f16fa18f596897310f585fd570e220b5a190ee39116808f56a4f3bfcefe1bbccf4ba9f7961750e7c35316b2c1658525c66c66051a1f38d3ee644f117e9097307dee03b4e71383988f9262044988e6cdc5794db37a4360a3ea3cdc9f67688c9af5f33604b852ad7e3cc9c498aed29494ee47be5b7c1d8cb1727df2d441e7c824d4ef4af83a920a1e02ba198b5c5ed4a5c6eb545479fab3987c388036bccb6537e7af09cf75f3f143c969cc385e1a55432ae37276cd44fe20ee160e2b545b3779077d5675c14e192f6eb15cbba3175931f67681b354ecf7670cdb9842f4dce3d7d79b96ce3aaea0cc4769ebae0226ab2d08a332db2e1100b2c5a30d6c407427da906e3f0a6208bb5091c217bb3b8e37b439704195a42a64d3a99cb0d79ac123f6ce4a66c1b08de1e91ce694117c396e5dfd65c0d367185194da6cf402163df8b40aafaad2a3a2eb194113d3d834a9cde81768b1b6516a36d362738f8b6a72c72d7986ae8c923049adfac9efc6dd3951a52e5de5e53e74ff92bff3015c7468da93333e975921d436ce28e88e565df7b45ff8c1e99a36ca77b18f409fe9ddbf3a2ee81c0f2d82b758af1fce79168a43619091825991cb5277bdfa0b4e2bfd25820c1699eba4586bee2ad31442e4649147a65453a4f9f0d2d3614c29cff4292dde3dd06ac058235df600c3182a887aaf603969ccad510dbdfdb91632be7da6e446b1caf5ea645881967ea73df6fcce3ccb248fb89037f3b67c142e8cc01535a38f511e7b786a8651aa11959b36866cdf16644b1c47159f57fd9562f8ca455a8d40d274819db31c0b15e4f5f2cb9b47096e7e011493887fc96c2a226af171d5d6f3eb2e5813d64974d0820d1ae8534bbdb2f9dcbb4ce48a26f5727f49135874e47e620be820bf4114ab301d6a1835eeab1c416507d9b934d6cd6686e25cfe1140bf755bbbbb5eac9c1841bbd680c6cef06a598b2550572c2250f88000652c5a717ef8c7ea440f124255e4e3cf2b618d9862d0dd67750e17db75165d859bb175e86159ebc432a7f5093369524d32c8ca149013e87043043f4ed14867d3146df744fcc898bf5c4f54253ca4b83e65e34ea8fa3028ead0e9f531265834bcdbd4e0df13165bd3b7ab5674930467e2d18d9098aae899387d6babb579d3cab0acb974d5731ec5fd0d448ff76286d4d541b39a63c8c145792102a3a3e267aa5645e2f16371321b20ee8bfa3cd471ad036eb92f579e60f13cf1fef1abb4ebad00d84db89f3f91d300e6db9891bdd018cb9bcd2ac4ac20487bcf92b6c421c2ea58c717ea300eebb3073db95c016f3a2fdaf2b79f6e820fcf3d4156ff4c92bbdc2e0706365b5aa5dcd69d077f214052a76863407c84fbb36b323857936e0922f7232fb9a8cc51d115108b5a9c640eb18e47c0e7f7ca6f7fb128730332b5f41eba1a252f5893ec01d20c1d2e7f87d9af30e9bb0cfc3e2114070d04af66d3623178a7d44f36eb2c847224f60f102b5135717ba1e4f4c238daf094f2e443fc530e78f57ff13be3694cfc2278d663a792015281fff7d586e87fc1f7416f09eee94e65e66097e1e7eae6d63ae7811e1c23604191f3ae23b01615e598887f8069dc30d12292576e1ad944c895f2ec028f059fd20e1d562e3617698d5e891066f11d5865983e2b011d35190884d33080a5d06c00d5ac4c1606eea3520673d4803c72fa79c3d8d05b04ff714cfe8bc4f9b20d1ad606c4185c6cffe073a28ca0826ae20ba664338b71e4844682f1bcad22181c956d1b7ed4cafd372c99eb7dd45ea4e291caab4b5aedf5eab1cf5aae0636929adadee422eb4107e90a85b69602374bcad3a1f0ce4f52efec127df08b8dee829ac1bde7a338b936b1581f40fc8aa1afdab7fc9579aab394b40adee1b54012bb91f4f5351ebad863eb2afb292fbeced89f14877fbb8c6247e8d2379327119883e184c58574b32d75af08a2deab206d80a0d06270528ca8c14b475c266f48eeb1e70613f8a5159c380af7a58eca5c100636ec97fdd5adc491cd8638deef263f2ec5ea911ac96a90ddca184965db6c2adbc241179f22f85d4d640722c3b67c3867ef74183ebbf68665e243892fd5832f7f28922665147fa3d2a1f6410705569c6e01bd999d749eeabc8d436e711ef83cdeb159dca8f6cd84615dcdf5873b5173aa196eb4481dc4224b0e4c95d75c88d21da8e5f7c846f5f2dfc9b6f424672a7b446d346b8945f93bcee90040f8d0bc0e244f0e7ab791aaa0d1075e87ac2aaa7166711f28ef5a945b90d8929f5eef21d6ba3e402e95a3b73cacb519becdad92194158e5b21e227ef5ef7860541e8d7cb6ad7e917dbc51901e0da7221008d5928a48db9aa11c22429a9ca4e634b213e7358f66dc915e6e7e5a1e801cf01d4b8ca201c020de66736a3586e2c5f8f8ee409cccc88eb74216ea010593d1484f0caaf3c8263675ddb54bafacc7ce547103e66d35701f8e8d14ffb581a3adb0096cc6b9daa6f5ac03c15e8f01ae1359d08b94091e3591e766736ec773c22cf7cf29e9cff5168a94a07f86cfbb3ca1c19d9df70570c74d77f01bc56808a342c383f95ee02e7742dea79ec0cad4ed1478ff38c047fd1b3a29bdae9dbc82cef05d3926f11c7aeafdd3d3fd431b7fbed4b23666c3fcce245730a13b1f44f3689be4d31236fd61698e38cda763f205206aa8de1a4337a44fba3f2b71934ec2ab3952809d2fa731491a23e312582334c02ef04353bfd849bfdcd9347956ddc18218a99fd6b8cd977a82060d22a63a4bad033d9240475bb013eabbec5ff51b5bb488e794bd77d2162fd4ea79d9a728e92c85435ac237ba8ac8ce172cb1d93710c072acd3611232a9f9362ae3e4b0cd7cb1003fd0667dd6c480fb1c5cadbc5e6fdc9299c600b22cbe92292ece570801161cb887df7d0491a81efb17be55f047dfdc31326ccb60aa564f239f533cc6a67d5bd360cf0636f2aa77d8a91120c33e6641268ca46cd1e67647439023384667fb52fa412c14143b27d10fd516ac7473d21e7cdb72e2f8a81c14f62931fa5c2d8295367cb7b7ce92d23c50bbba5e7a22f87337638df26556b2798aaed405c0a1ff20f88e5dd35401ef38d3477ded92fa1bc7662f63372b9b9988c99096fabfc4d975a760678031eebe3433be143e06533c1fd85bfe37852777682f25d2b106ee38670bc4d45d29722a8eb3442332f05fe34cd04120ee6fc33fedf7ab1bfb57fbf4592b353d5b89d49fdd4c8ffc3f89f3416794b12698fc7c70966cc75f9fecb9a1014db9ac1e755be1922a2502e75a31a7404a174e3e88a43a2b0bd19ffbe7e208b3f0074c4468c08ecd9ec9a02dc373bdce3f43aac688d8b343206e6a9b275c14f279ddc43178e4cc69837bc422cc6dd8c7da48b4f75029951ffb63a9664a3fd03cad3f8bf0e58fb3e591f0b6ce38ccceababcc36b687c8cb4e4e2a2f44dfa0b2d4cea9da222c779c75e2e0fd3ef40bdccbcf6a5ca6fbd343e8ec890fc0f751ca13e35d999f14b5d288c42464bcd00b5afdc540cd34de33e346212161c5c1ce86336a06c7be63bbcb7117b16d7c301b33a54ba92588d186f26be74e8b7ed3b532f25162a291f27cd92ce278faacf40d6df8b821074357b6d08cce6d4532c175705106fdca5f21f8aa3e55f9cbb23b4b40e623365fb41992f3fa2c13cf8110b8beb4f663ca304ab845056a3469aacdc3422956eba50eb9503712ddca7d80ae7c2ece4982cfc28cc0e10a9b04336d33a8bcaf3776a4fe68e852ea95421ec8525f962f3a2c6857dc370627cf5d6b7bfa5f6c8a893bfc1c7d30d1c56af4b7e0eb32894f86e30fb1173b8297842b92a78209f45996372294fa1aed3981533d8f004d0e1d29bf6112ba2fa142ae603b36435384883104f1d8a1606831adb009351102feda37be75efb93d62c2201b9aef82b1e4fab392420c6f38f72b54643e0ae32d79dee0726b1c348e2ebc0dfae3ce74122c4f17e4f235af9651e59b7bcb9ee74d4cf3ee2ba26a713cb612563b6be6227121dec5edebe35455fe238efe3def2440f862dcfeae97dabd136480ae7d143453009dccb0d680c9dd9ee9a3bc44937e9de059637394d561ff8b5af3f8ee1a9cb8de995d85f117be77a5ef7cb5eb5f731aa40c824d5261222468e9936bad2e5c1f92e5df47548aa53eb88a804d58a93977f2736ef5f15984289eab706dca544793f9bf8e15a09573d76fecf0e32e9bb7c8ae13c515ed2f44964236c2bb80694c4174ddedb3996cb609a73dda92e00b6c8192414c886ae76f135e8b197ad256d35d6fd4d9b71fea5b434811e4c9b899a0c85dff2531bad6c3b5526d12d1123eb1c109ac9bf53c41759a3147896012c43d11b3ad88814cb6100532aab3515bb02ca3395731b4c9110ff838e5055b5bbc17a9c78ee79fcb07dddfa26bb6dc4b53a43e799847a7fc633e88bb7e18e3a384542b9383f97804c09e84473ce5955c42d266b9f6f6564bdc47260f2c65f161717d1a17c7db999709e965661b90581529ec0fcf882576b23b4b294d71203f682de306a5d730e1b4fe01c62646e6322723c50c02f461f5f08e92269e041238a5e5847e63577b94ef3d0b4c3d06a22f19dfead75f4f42623dd41e46b6695720f5c6cc37692568af35b7e3d99497f8a9eed6e8a26e3d6b6e1c72432956f062c354fe38b89fe7d5ad12ec262e07e74df980cb636316cc3f631ba1c81b00251cb799fb1447972eaa2798be881e653e4ef5e334edfbdb5fea571729c28c737f5985824ebeb65d7f6dbcd7801aaea7bfdb6a1a11c840848314d95747f2a8de4d23f7a127582b042924d1f7c60645c54a3ea30b964103c8cc4fa0441f75dc5a548c4a1b929f572396866030cd27e5e0671ba7a76f6838f6634ee8f752f0f66df6853a893fda6c62952925e26fe6cce28c9b9cb0e288dc8fe4c4465e716b260b97c681a16a8c036df690f884852020108a7fb3c76b16fbb767ee4b72ead76c09be61cc13dc01b03391c0eb436c40ee3358a50a07185c8781a67907b5b1bbc534506efa1b80a33fb97f54962c664c0be4fcd6cf138b36dd880016cba0ba98683b2e8c2152b07b3dcd323243d691574d2f74d55e5c4a3006e8406592a52b9a2d7d429e0af23bd1d0effaf24e9615345fd9be65535391758e8f48b7d76e8757e37773e773548c3b3ef231d08e2a338941aee2bc58d44762bcd0860684a8f87ab78b9bfac07e8e3065dafe693ec95352b3e2938f928cf5c44b1b0a7229c81b593046aec7069801fac336c514f97f0da43b563dc1b871c6a6374e0b6292737772480610dcf0655aea9c02dc1d484f87d44b70f714a5cfccb0cf627d8c1daf99eb184718680f025b74919f5c0ea1f403faffb5b3515cd87f76f2626ebf584b9e18d8160486d8b6924f07c07c5a217afb623ef26a5f1a290c242181ed91f1722bb9e48418a013b60716b04d8d0d388e0dc06f84b8bce19dfcc5a3ed24f1a56520863b4259a3c5da04439b87618fe67311ded0f03c80c523e92eb69cda93bc622ff504fe724148edd79e31e014de5185a40bc0da293f445f5787afce3e6fdb952c54e44ec38f003c48cc72a14c0344348a7473f56f3c65a43a10c39571d23789526a98a2cd755f7e9f729d1e962109a8029fd87c7577517f29c7ca8f44c75a2b1c3d1b98d1896f7919b01684ab038e0ce4305da692ac84761ea45ab8b6a4018399f6fae017124c0e8c134cc0db7f31bf6c06552e0acc20db61f5b5fdaac676d1613dfdda88f88882c02d5f60d4b954852b95b194a09b1b39d99c93d6fcf6a89d772a8b45a74841c6c5eb2df7ce8ed597081707babf3f791e365c866dd3ef1369a7179059fbef51182382fa4a63a703ca2bfff8a19ee9fb6898d386e83b9f08b999d6e90da01eae15e5bcb006287fbbc3204db39d87936d506c2de329bd72c51deac3cb72afa8474d16c8f7f21087e00bc257e0c631318faf6fdb4ab49e20253bcbae6415da401d315a594eced2753adc90107917f88c49dcc0eda9aedcea9559fa441359da4c8d6334f326f6f7b34ba1be0a1444d937d4f023ba12d1d644a94f85f3cf0e3f5ac5b34fb3785bca82ee3ec0541915da2359b0e96a0fca4f96ab351c208a7529421860d42574d1ea8d8f95a937edac0f03ff56bb6c1294b37926fe05fb14a81c7227999fcce56b2f6ce7351b92c94dfe0e4429c81bcb35311e499923285e45ed6ff07bd6556c8d6fc9d645bf3a82f60651a1d072205a9cf0e68a01bf58fd51f6c50ad843c2e4ef35b8f528ae3f6567d4ad70072b6c25ff954ddccb52154dd9bbf857b8b0c5f8a34115a8d3a1f939cd513bf4bdb245e4aa3efe5417b531f22e2c733a53edc49e061dcbdb8bef84228ff7f7ae95d4e04e86dd1a5b176b8527856883d5518d21fe29164c393fe231118f73ffc10be126889c9b088220b620a5492f0e3d2e1bffc57671e59d8af98bbd27b374a641c5e7c80b0edb829652ef865952c5dcc82f754cf4eab53bf933180f472d01e6ddeb2ecc3703a4b03ba17e01ef47be607304e9a3be3e0e2c5ea26899b9f749ed66b4cf67edaadbdf4d7012a25fc7525b532002dbfed39dc83a19e98cbab26eeb6cda353b520ef9c2107c11a267a3bf05d87d582e3646566a3f2b57ced4c33082b10c6dd20be9e98d8c451456121c7a4cec91080de57f8559f1f4f68257d8b239de62d478f34840fb86d99a88f94a4820e2ef35f14268d84dffa1aa2b2328cc2abfe086cb64ea5c38fc00514903b05fa970fa712b96c87dd4b23210d633b49bb924bebd61b5d0fc26f3f63a0c404e9f7423475a4b9db1cfe249e5b0f3420454a787254dca3d50027181a89ff528f06b48ec0e63a3fb5d034505548325cce6d594414c752db6e3cc025eb87b6eacf1dea78ca98470eaf9419ef89c11e6ff1d743a1df7c16eace5e541f8c985a87ffaf06d167b27b0ec04c1c75eef88dde82d48a1ff46b6f2af8267b18bba30b63817dcd193a4ae1f4855508a7824369746fef89edc41f13e791c0460a634df5fd2f257814c7c28c7c5b8ee6c7adfb18e50c72449b6859c86882d66a514b030f75539fbb8b68782505c46242863c2e116917df64cba66a4a4300e8dc4c09587d9403a858561ba17a978d6afc6a7a54d23a94a73508f2cc62c26ec0aa707a1373666a6fb1e166990e0b363d09a428973cdab1cbeb9e0e148f77e31c03584020a881258827354e02d580a5a4fbfc16aa81f1a3c7ebee9207354a558112eff277edbdf4cabeec2dcf535f35fc15508dfc0b55de82487fed03329f208d4a4b188b6648dc7633e19d89a13b5542d5636ba0b5c2cb4346909df792b6abda31033321de26fd5907ba71d8a8200c25b6cc655409b98fa7c5a64353054acb1536eeefae78923ed6457a55c95b88cc286bc5b544a44025924458d6bf85f082d25fac50c694d7116383e99dbe0bad081a66e3272bddcf1fca56ce4f6d8411a555cbfb6734b9caa14ead2bafb6265e840fead01078b0be7e2a01de0f5d80348eca647623daaecaa9d04042b333d9a9348fcb614358603334bc1502b763068516b8b82eb302d5c9e1fa96947184a10e32c9c7ba554675115f8359d15efa6186ae3774ff64eaeef3ac8516611c381654f5e41525a341e7dc392f8722bc88f5c3dc8f7a78fa5addc5811714c92cdd527b952fa022edd4f034ccf37411d39f18386d9f2b4467d8a461312744d5e3d5cae8bd275e66d99825c748084c4c14d958f31a2f515425b622bb82df1094629ccca7f1aea402aa9bb588a30371c7c506e01846fd42cc0a4e9b92e517664a419d8b6623bfa7819f496082b7dca28df5b4a49bda1e83877644171f73a979986d4ec1efe18a47bf1b90667d2015e7c3f5bbf56d0ce7d18e3c305487a84baf76c5e72a395ea8baeb8bce9a3b0f72f8519b31163cb117c100d41466d8146f9ccacfe0a16a29bb5b060ecc9b66878645f9e8b898ecf2974457a25a86784efbc0124879dc67bbd355c4579068ae7cfa022fa8e0088a450666e7220b29b9ed045a29db062b7a1b4ea670c783593495d4e1aa53d47e298bbae3b8288010ac3e8da95da4fb629a24b90a231458f719b111fec6b63c39cfc5a1ef6be525ea40be4726f035044f6ba728d49625e8d99cb67ac98b26839864606e05bf20eab82eb2a330728e2a14297870ae59d0a895e53eb61e58611c9868ade66d8fa677571d4442f27db2f222242b4f338bb8bcad474425eb373a199ed9104c138b78ab505a27291eb446baa97226c2ebc33426ae52f43b558d4d3be13248ba18f492f7b4155b5dd9ca88a051b7ca1153aff68531c99fef1f178874470767bf4fb3c88b8f18fd58ae8748c09b9e60570e3c713727f48a133e9e3b31caea2a61138d868f994767501d3304fa5f0fc5409f6cd6e9a8e5a9277e632fd84a438f3f970faf106e7f2b197f4c9f7487e59b4f8397549240d4860a3248c17e5d07be8a23f9291beadc2b71395a9fa83d22dcf0562acb7c80179018dc04a50c8261bc138814ae44f713404ba4c78d4fe95b26396b5c6d049b0a08eddb17a8fd7ccc4aa880d9c449c216e811b1deca1b843bfc0f6be93487aef58a2ea172d57fc3b72bd9eb9b8f17816a44021de40673486b5462148ae146022ad33f001c4b45de45284cc0ab229bfa17a9e7005a44edad8cbb08c234bf1425395183fe01558cd8fb7e91d7a8a820eaedcde931cb2ae89a8fffd9ef5a1430c0fe9980cbbc43be15fec04185300735b61c885ced9fae574deea6df4a1d17f1e9f915be8e409add2c15a97ce26f3ab8d0238df126414eca79dc811aa2925ffa862eb0150b7f895812389ddff5f139962c19021dfe6e714b29e7a34fd9e0f1f42df07df7626979663d88f7d00f2f8a0ff9b8110fd4caf629c286222a47d96a29634b161647eb16be920e87a7c906fe7b87f82012499d72d82093769486bd02befac3c9e56fa03787c27efe483a14178a5e4142287b1220479c8f20651bf23657401e8d694522c358a87caf4913f80095b37391ba9e44fd8e7126f1d8670d9d324a6fc815059b0abcb89ce857212733f954d72f8251bf9b3316b4a7a08eaa021343c8192cace84c957962d34fb912a00cb9bc3e84c55bc795b5d21f4bce729bf2bd4da0be255f977ff5edd620c2085717a28fbc0e1bdcd0cc2e812d68d49a2682a195335a83ff9132f7a8e91b9cb32cdf93361b01bfce6804af0960a6069f129eeab0789a73bf82bae683325e4c55452c47c25b5f2c406f04156a3ab64b19736d9e5927adab64ff37b16a62d6913677ae381724e26d8fbf3abd7a78f6eba0dcc97c25d9e5c6a414eccf72208d0460bb4b6e22b778be5c0d1a797e7f52770de9a847db29bda363596c59a047cf331f7fed216644b18313b8131db00a2c24bd3e68b7e7fe4d586e5aa35924a1f97e65a35f4e8cfda3a743b1de534f204d2580ae5541a6f9a26367bddc64b9117cc6c8e79a7f32f8701ce0c84e4b2076456f16e0869b335ebe368064b32ff2dd0bf31aab63eea3e87676d9102652a059ddf5502fa917a1ef43522bd956beea2a115c2a54c7e4013d782d000073066f2c999d386e023f4c87cf676429045a3f6cb9ac3629cde2b1463a344a2d8eb9bc6fee0d713be4bb9c7cbeb429575d8e6e9e94d4f543e03c1f1c3f0d73a38f42313d08eb55873f132978f6d8c1d86afe5db7381afa3eeb45da2f878a5ff8848eb7e2da7dd1019b91a9dfbdd8911b8df1163e3df5a25480e66a53e5d69caa3106ae4f77f23cbeebca6e833b04d5ff187fe8df979ca999d6c7a34b24399be15860734f385af6a68f1ab1fa55046761941b391472b5bc09232bcba139294a728a9550903f1d735ef0a8663a8b1033fc7efeaec615509c3d32d35c85ba2ca009aca39c9fc9a235d0bad5026437220ea78cc42c35773c9419afa5443a9bfb697a05532a9900ced879fa52ebff0eceb6eedc84dab0cab69ff58f0282f69ece62949f8389cf34cf5bc7856898b880425efbf098654827a4f9dc860ad6b0a683cc0383ae94ec295b77a014116e34d077c7505f0135b44c4b74741c6643788aa2e3b4c684f24d7c77f8be9d1f803bfa7e2cd46dac33029ea33067a343016b94ff237c65c87bfff2a7ef3092e476eb63c1f01289fde85716bcddf0d7dea5dfea09b67e7b5895c8e2b0178136a33404d7d26947c985091c646b5ed2465247d5349178bd993972c269a72be5e9238ecc617e0ff39f38261054df5b1ada5da2192ab774c6c3d30ed51b3593a9bfa4534a7824ddb7eab7cc815beaf765848c75097429840ad482c8a6ed621053464f75bcedcf4c5cdead4d6979d4cbcd08bbe0eaa327dbbdd7888b226ca3b1e9278b51262e00f932d94431e5c2be1d4d03f1cf137413400309ca7e4e80bf192b967cdbc7e89242273f6556995f79a4ecf3a686428d6f74d9f7dc9cc1c5f1363b8e6f8b2bb238113addd5bd817865c32db08e74b7776c52296c1c49207eeafde24777910579f7910081abff3b4fd5f96032e6680b5d1db2df3c79c3cd1b4290b1d22506314402580fe57f9671ff9d5f0bcfadf21181d9e910b9a2b6094b7d7e97588500dba91a8d341b2bcc4b3e3aeadced8c0513fccbe8fdc9888475c30ede64fe1eec5e5bfaa36e224b926d7468d0246f23153dc07b647df11400d5483ab89df8545d52ed0f4c5317a8c4836caf4895e1f7293964c796ac6488a0e5cacb05b1963ec6341c35574fa380448cb8f8569eb3c311d3a520d7b58c4a77ce68becd220f23558591a132f8ae3c56e34033b1d225ca4651a0719e4d6ec893ca27447f5676650dbd1e9bf557d780fbc09e3ae16ec31d90e90ad710026568caac61fc9dd27fd11259cd7caa32a2e0b083e8a1327ab86e336278c71f12b9e8525657be27f6575c41f8dfc7f5f38ba17d61c3e39f35d3fdf9f07753e55b156877b1851f4e9673f3188300344b53e1c9e7a3936b6253f8d6009e020c32926ffaf2e85a5a0e98dbd02a7d5e7bb4831abefde74064dd76076b2506aa22bae76627d473d07a51e9c795285b2bfa38b3fdcfe1cb7ffbe4bc4a29b3b99d34fa8a10b72d477e4319442d188484e20a60fdb31265854b25b0faa073d2796648da324c4ecce58e483d78043f4f0a0ed301567028ff958405e6f536a930bd9e8e2ad4c1554b7c0a870d76798e4e14537079cc6fdd06433da815a9fb04a20ddb4f9aefb29eb0910b132f83ad7defcf9e58d3e475f09c43da83db5a460abf47c146528ff6cfada33e61438c8169a6afde76a3492f3757d7be3fc948dbcf054a7474b35bed665ff4ba9b0f5e08749304d6b71f0b9a554c4d466ffb01c01ffab2254bae43e9d81502bdd7f06818f432eeaf159ae370d5b3d30f02886aebfdc612322cee0c21bdebc3f51d8d848fae41672f3b09fb44d3e50e0582fba937726ed856a1268b43607aa31d51624c9a2877d37fb563b42d5e98254be8f4caf90cf617a0df9418bd38bf09089595646cd1fe794c2e4ec3179d927d901b614cbe43767285884ef89e349e8d38c93dc70321cecefb64458d11e29e59fa879a7f9b4591297e71e344006202389928e18bdc3d127b7cc4601b93e7e78c913ee91ddfb92b0a1475ca224055ff11f47f053651923e9c0458958dc190d756ab7093193fe25424207d909582a215212f93f45de3881fbadc1855860fdab5727ff8b64a4ed0e7fa47ab462d8d5c46eec4eff7917c7f9aa9946db86218505fbd1cbe97501428f0881730076a541cb1062a3371800d38c82085c5c6fb860e7501bac0bdc4537373544c15b31806cbfb9dca386b8c9d9e4b0de0bee3fcf0c7313a4dd0cdbfeb7e2439c170a94c0c2cbf43a403c54b0712df570c6c74c296c54fb93c6e91ac74782e67f7672610703bbc59a68e6e0ec3a71a9aaa1a70d7237020a4d3f23ebb61b10d3d97c0c19991964748504fbc7435e31dece018f3b7741d9f5db7101a3d42f32fffa4e91b7f1d8cc6421100f970f94a0424fc2ba66647e608956194b721dc8e08b4a806b4dd1be482d3fc8350aa1c93dcd97e6ca38a9dd18c9d382f2a2484eeeeb25343e6a52227fed675156197823aeb3075bcfb99c18e4f22be9c651657444c8dd506ff5f287ebf5964f28adea839a4f778b076c548d7455d1397fc8d9a78c030db4fe6f5449a69a47d58405058dbab8b630676195bca0c970a6b8a11d4ba25a9e5f22fa6c6ec0b7d8fc95294626ce9a0695125be8bb4cd79894842a272b4c809454507a10b22f451e80e69954f5a6cbfedd5425523725fc1101f007a42851fe717e00fdfb6109c64a89de6e609352cbe2063fbfaa4bfb8cc06ea0c91e5397eb72dd129f658ce41d400f40a110227579259be1dc94704be6e0bcfa632e30157e64f4330bd97b20a620c765e179649f6a6c33ac32a0e1e347b36a94ee6a913fc5fbd7b7c524bebe5a0669d91598c4c459709833e5eb103940ba9979e7e47199577052b97ebc57bae014458a364c66377cb18959e931caae6b74ea01f42d3f34f794a319f056f92ddd711257424f49763e2807556f6c204a6454c8629b5b362a952ddc59c9eb6f3f5e1bf4ee4eaf404127ef915ef8d5c3b15857e6800fd42cc770f98203dad4d36754db90b36f4efb6c58ce15d26bbab51270cd8aa5560de070194493c7ad62596594a00c045f70735f316f36559c24ee2d49e5cb094bedb988a1b2db5df06fc9fa74f3d70b15db32a8759f0097488939954c027aa3531a84614f5ec99a498629e8f3b03242467fa95a24a37590be7d2e02dcb0369f8df107f942d2fa816ab2e33126c585e599fdf0e6e45baf8269779782c15e7c2a4356d5eaf260fdbe3edaa5093e84bbf60f4412145af44355b4c3d0b84fc67e4c69967042e9738f7f092da1c1b0922c184751383f9f4e1281fdf6e0750b1c2aaa9c4e27f3805ef87f9aed6d30641d1cb29f270b923f21c403dfddf92397e55f16be31c2796419cbb1e64937305c5110d2c20427a00886aeb821c07684bae260bf68d879e115029e8afee73ccf8fe0edc7ae9af6ae6a1cb877290d8ab8f84bd1a7befc7dc23ecc361cdc756b5fab2f914a5779887bf183fcba23ae5533520baa80ede281a3d58ef0bae14457290b463958681658f27eef700cead8019f6c673ed7b85db7add9b971c325e35a68e9a55377bb5c9e2d8517a6c599ef7afbd4ccc429a15a51283d14d635e5ca092cd3d62669d5166604752aae0e62ce966341b3381d565732c50df744e5e33bc862bae288f0aaeef5347b5bc7a055bcde42417eccff41d618c7ebee99b27294e09f0008c46bf4e04c8c26658fe0828539f2f6bd2ee2d01ec2d3f8ab6dfabc67fc02e9f4b897c2c8a7b94e8b196bf57275a2d70ec7780538f51f2fab79fb0dad7ae02d9cad26bf0b87fdde57bebd5179026586ed094ed258c40d79f13d337febf190d1b619865573846dd3a98a36e2223a97bbb73c991f454566f4b578b7cc5734c9bb3d9549b5a85fccfc0b216dc26cf531fccf8c26467838ec07568c557d797d415cfef9751a872543ec38f75170de63391d4af192c01ccc03f56d7aca2d44d46c0e37ac6b4922706f36a0858b7d555c1161efdc974ce817366859a9ac59a2ae3cf1371df6fcda622dfc6c2e7acfee7ad8a56da3d9e13c84c0f0aa662ac3d09e2a7a530d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
