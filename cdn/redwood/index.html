<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"41bdc7a1b1ec315014d1e588d9bb54b6704108d1cb893e7aefb521f16692b1c9490b6b059c96c38942cda832d5808c6ea0c237c83549e52e823e81c7acd9b2c1d78bed966ececf906ae0ba3c622445cbfeb934cfa7312eb074fb793159bbeef79038278d38fa094497da9d1a9d2677b77b4b61e419ca69407d579f81391428910c52257bf9570be3a19d38371d06e4807c59422c05eb81748a13d37bd191f8a376af1dc4dfe628fac091c36e2696079620bd9a5b6762a2cc175ea8285c9df9cc06ad37edfcd94f361b34eab2e5b9fc8fcc472e648102fdce8a08a00f3e1cd2fca676e4b4fb961abe1beaf79c7bfe02830d5da3cf37b5bbdcc8dbbff3a848c471500cf803c59f31cc081350df4526e8f51e698a2a322e04f0e3a8cd64632ea08d1a1caaa4e39b266ee9a2d733134171dd7ca9b75760454c8d7d97412d6f533d2e0e21d48b077c57c8a39964641240633daec0af3b395e4cfda53a803d0a9ce96484966601e58d886ef5afb937c1393ced20f0d9415898383c00fe85325bca5c994ab3beee002950da27afd93631c59c28be1a1126dc7f94c3ebf4be0ec9f51cd47fd9a31b0b5d3041f9cd009f0cd573ee3f864dcd5674ca3358ea61e4e7460da6e0fe4c6b70592c146d138649dff5a71e6366e635b973f5e2812847ebc6ba3f96b7293a66a260ae6edd892c64eb05be66539064b195167022c9e50f77b8c78c4c5282631a42870a7c6ce47d59728d0958ba0f73e58e56cd216570416cc5cf569eb434415e5f5a1710e1e4755f5594c53e64cb1f649d33c72be9b35f2df211519993b0e001623fd17499d8423e169824c667e03d7faa1d4dacb3da1a5d38db29bd646040bf64bb5690b74686ddd50873d3e70aabbb6a69dd244a7cd23e29e2a796d9e32b4484df6a9257f07ca8ffb1357412f6c0398d7d533caeb87941bfe4fd78d38014b25f7875dd56b9a88fc6ec62087b9045d3db358d4ff8784500314acefd13a8c16242a2644e4b46f9a420207631195817b25286e2c6cead52218712f54a2590b4c225f70e212d543023882c2882672c704684b927dd7762000c6071c3db4bdee5572fd680e870d729782b3e86d215db59d2b88cad1e964802414ae8108bb0bb0f8cf927fdced6821c25186cddf20f14d71cbb8def2ef9fcd0cc59b71524e75f3311f37c0c72383f3eec20a7cb5fc77387ebdeb11ff1c5f409ffe6b8b3dc275092ae5b66f8ba11bc9fd102054e9af19dbd29717dd4310d1cfd55631355bd5bd1336add67ce9dee5e0c5fc7bfaaac927d8952c35a542e53b64db7f86203d9751a510421efa76f0cf825dca93a28af7fddd5d11abd1fc7c8455a61ce7182f6a0b2f27c4f49b6f60c85ea99dd90cd75a6dafbc84348d51d07793b9fee71c3fc46d530dd79667cd41f8c4b0a739d3036bd30008fad447483b17f739ff4a1209d4450d7436f3ea63bea92eadec2f7ee6ad8e4914983a800589af0ddb5cc0b52c37bbace88f54a590fdfe46ac89e370184e80984fe948858ff78da3862fc6eb5a2755b01b0e13a228c6defdf595f38242d16553ff395ad707620f1639cc8a0612f1f3f6328bff58c5ba50a14e5b1d37b301cd7898b0245b05b3b28692de4af4bea96fb09d7cc569ca399ac90e9524b4c52dc5bbd6aff8eecfee48f114ed1455972a4c32a2f4368fe8efae658688aaed1209211366028f0d4162acbe143e8c005ee6fd35887b22df0addbcbd8299df9897323973693c04e796605d47c49c71583abea0934e7f01366eb3d9b96b0b9da48cd7a71b20b02cda1629c80092b87399d91797d3be7c866bb4c6cb7b4a1356e9b6de74923815f06ed3409c59e3eebcaf06646222743bf2bf1e07991d00377bd9aa452bf05ce8088bb6a8c19ca4b154eb7e053238c865b0b0a26293ca03b9c9cf4169f5f7fb67a183106fb098bf7bf268b9ae4fb02d853fbf6839bbcb05f3c93fe98b7e2d75a19c621e695ce02822616b9c230fe4d339847819da9d65585a442fc7e10324705256583f0eeedf6b1af777c7b7c2552169fad6ed45f740f31bc74a6d10e9b1eac8276f06ec1d2cfaf3de143e81ba5bbc7503c77e212311f1d6ba076d361c94a6983fd518bf946755fc0476411c041037b53fed83604b06d478dbacb2a86d899a632e2e47af1797fbc1711a659ebaf18d28e9f00071048852f6c34b0c71829671d77a8482fceaae975759882f51c582ff4d5c23dba2b3126aaa41d745b9e750327ab0bf354cde6523d299896f168e5cc0bb8815387dc124c4b104c699f0dc786d26149f287b2398f2c593836ce0a39914e22bfb96e9241e87d71cf6d8903ec60ae865cda46ee2c34957403ab8c31afdd7e88a714153def712aa0e38a57cf15ac8b1a1fb1f828f314fcb1886a39dc1a333effc0ca2f2409c360a3e30d9eb66fdd27a7282f495a7d3a739b6fd4b6bc7509c048021feb071d529d3b87c40e122bbae4869d52dfe4f3901149a5d825308f366adfa34bb62e896123c8b674e79fe246c3b4dbdfb9344357995c7d5aa4e437cc80734ae7a22f6d1229bbd4b21d147308c22a3ba441c52bd8825f52ace9b4dbc5f46e7cc33c54a848d06ffe484a7389f5a58588acd33aabbecf91f298d04d688dfe290ea85c2f2974704ad1a2b8ebaab3984b68a5fc32ce62642bb2c0ca093e899b54428ea9a6775bc59b0c43635e02f5535954120b60d661081795bbdcf1c8cca7afd77e192be82f2c2521266966bf6bc8e0229964295c2a6e68ff0f03edc88093e3346b8d5ceb7ce9299fd6da423e0b62acb4c3c726f215d3c553db450385fa9f39ebe1b39b07ab294478dfbcfd1b8be1f8fdf99f323879fa5f425ef7e28aa0c86995c5c722b3b4ac62dea2aad9ecc87421f7d452ccfd61e4c887e891ff754f997f946598ccdab2452fbbc25c631dc9ea1d00aae9582921c67c8b5be3a4b688767d9e2bf649d70b571ed698652d5b00a5db9d3af0880050319c26f3fd447b247bcedf5c822025456317926f61eee15fae2bd208f96d842cdc8c4bf62989123f139b5baab7e827571ed73140b92ec6a058f663364fdf18918e1367b17cf70976da4e3b50631d47b2e68b801eee739db3498d2897f01e13a3d11f69a89a32de2b4cf3b1e16e234008c104d00c5891cc9940eb0160770e85da5fefc529724523af1128606ec0a311c1a5e501c92fd67f77d7ef472ec23bf3e4eb36c7026ba779043539b4c4ee1ef12a69467bd2c3d2d63c84201b92d708c67d9a5d9fcadab61a083149a188a50d08329397d7bd8270d3a4a3e6b87164f7bff49c82e9cad817831f736cb562bf984d7e98c218d45a7666c8abc5958c2f5f3490c28f264ee1d18b677c99a9815cbf4e8ada156ea3da259fbedcc126ff390c8aef64f9d277051635d3c0de32ae67dfad7ace5e500fb8da432e24026288316fcdd85e870c8bb80f7fc720b1edc419f413cc56106c99b033c5ccdf7a7ccf95b091b9ee8b44cc3dc969aa04c218c84978895e6b1a3e6cac0f8e99f51f6f2f9479eeed4040b17fb0bc4227c4b27a0e0790229b7cd3f81d243ed691d24d6780c995fc1ecef84f1109af23f21910b32a08fdd2d61e5e681192a92c32462eb08e8ee5b190aeb976d6b6cdcd4c237c523b0d2f3db066355de036358d939de7f04b374e581e1c6817eb4d98a42fbabd83c2df2488b1db74e9d7545de5c3c1275bb9f581a879f79c4a2f306c3bdb504503b33a4512deb1a83725ccf3a0ab10d56a20517b6b94c2f09b9d689761e1359d2ee3ad085850b5911881e0c85afed53da3d43d3f2b8d6c6f6f6e8985f737a915bf34180ba0e79b0b9e413a574fedf2209f4c2c739be29baef684726173fb384d713c8ae32d0cbaf32de5758f46e265d796d707642f98cefe335cffae96ef6214160700e9c40c2525db80895284da7a5495cc49801061bb92edd68a364e01a40c295747535376882fe0339e081a92d22a753c701aca491a913e82c90db031e6c11d025b2ab550badde22661b9f39c8a514fac69ea71cfde60804706a7d6eaede01dff7fcf21f1f411f678f867b26f8a9a035b15b357b0ca65e684002c128cf2b63ecbd4f6384d0e62f7eca4dbc44d3eb0acf4a52d12aa791a1d978ad16f23eba6ea33c5006263e558ccdc7986036dcc05682a91233d298a54c5ae34306e32e4bbf74196acf39f5a42baa002e217ae152528069af87829010b635ebf273276dbe7984d673c4cbaad6fdaa7b4788f6325a05c11dc199ecd6bd885ad085d4db2d1b4364ae4948974fa1b42a2f858ce592ec86322eece538a131774c7645c0137484af6913619fb2415877215e19c4a3bc4a7cf0408faaa958031b63a0ee5ab0009fd44dcff2f2386005d088b421b6f9be5030cf3903b1c17528d62d81ac55fa26b5fb171237021dc717addfdf8a52f0e1fcf5be014743497bbe873cf3b1ea9d3dfdf44ca2c072485d2652dbd0828de43b8e3dd45b27570ae9d4a4c9e029297a8d6dfe08f86d36326cf4344542eed150001eb47dc62cab28b4cecae8ac55f2b54ee6e9f49c17f7324394f8b71ee5642bf8549db8340c828c834fd666611d2e07c591ca7577381f2136c290c5aa05b1020c08e7807d3c64f40cc0c040d4fceea5fe773fad02df65b44242b98a884e9d638e269cf18f34fec5d40c3bd86a7e2eeeaf7e35e356b08b0ba22110bfcd9469a22527eda4a2d50ad6baab87d0ed82c1a167827997bc917a972646fd96b2d87d2c50379a73ea62fc811bec41f3b50cf33b88ebb36eab076c1807bdde4136eba432748d73c18b47f31a6f422ffdb9d39673ab992b83d67daed8caaa5509cbfbea47ccba5c969a071dd016566683b683e02f03ac83bd9e6581db21c27e339f07dc812fa7f46a9ee8a8b2e17c3a08e917535fdae22ab51ad93287c0a0298ae82cafb949ebb870eb8a30b23094cb9471e45fd4666f0e44feb771bf88769ec660dd15aa921bea3c08fd8440501d63de9392c4d53181e47817d4e18db7b12ceb3a5caa97dcbb9c2d0385878e0952c62147d930cdcf96e5945d453bcb223d3050abd5e4ecebc6e09efcfc7a0d546f5e6574326af0cb9a104b69f5624d353ee56c95cd509d224e6ab077b77e42e9b60882179113f71f7ac448153d1b5ffeb68a24ed0a319b5119d1982c86ce80ce379549f0d4cabe1303728fbb4bb4f7077bcb55a4df9958d9b80778982fdd5946626f6b90cd24269aed24f1e23a320c59c231689131621879780cf1bf7ce760948e250e0a6311c5a315adff96f440e4ef81859f2538df69674d5004a6949247a7fd5d745a8ec8119b720fb231dbc2386501d679201766d4353a5bd843d6a52bc90e884f158eeb92a2eb1f8d8a18212e667f7f4a49d14ef7256a54536b5893eef615faed9e788b6379eb494f2d90af91625fa8ea5c3f803301918979b78464254b165ea3ea106d365cd782b4073e5d02ff68e290e7a1e23c162269f9b334538c06131ff336b01cce0700605483781f1ca7ec14a0f1032805d2c2f175f121cdb35e384beb20f4a237dfb9a904a623ff0c655394bc451d9d55484700a04ea90fc2672d1dc646ac4a3f87ce9b9f75fa35fe2cfc68c68668fc996553ef4c3ff0078109bbe26898f6aa106fdbce972e8cdec112b24446ebbbafd42cd1443a745d484ba80c022580ef0289be043ba0c54e177b9b9335ff32cab258cc76728bc44fc628e0e2982517066de81f0dd872952253e4177b46c4e9769ba35fd1e84c3061b4bc998256558b0d609db24bb78a34ece96d65ef842ec7f0f4f26015954724f5c68215d72b0dcd5e1d0a7e43f62decef4abc03c5b1de91825d214e165a488831598899616e1f71cf5d24e6d5026ddc7204a53adb315d9cae471df9213f598961eeb2abd28d86ffa028c756164831c8ffd386b54d49774ba0801f4460a9d217f6152258525ae2ee0b90be5e2e209a25d9a07eef238502e66f4b89d7b3bd0c5240bf3d7e1e3bce7c55a4d7c879afa2c3436b8124815eb998ee4151ba0b952c6744620a3c8a87cfb3db947dd741d4a42fa91b23984a5ed9eac57b7cf7d40ded2cd3fe5b6d3ad24687688684ca939f9a0aa99610bf13ccea9395863e1e408d6bd623f9e7deb76cb5c023bcdf6318c8bb4be0363989485063d8e172d0f61dff9ad07c677d86e921c4b38a139e7e3173cd5ebc03b68e6b4eec2844b0d88e250b1c5586ee59d2b8f64c9cf44c48829f0df4fda28a01ed0d4fbae2612101a9ded74c6085ad804bf81c7eb08d4558336954b9c2b60e95ac3da9c9e9ac43a9339d73548c28510d01bb0768d33c523c4d25042c866b5e0b44141dc5c2c90adf214eb858ce93495bb71111958e3b14905ffba21906f2d65069b491e991e2335076e47f1b9fbf097d6247552c557649f81187f475ddeb932ff897fa8f55b322c7ec8bf8a737b0bf8d3c2c110e3763651f00a7303e138c5991b5650e2760d2fdf37d00352dc61f2c7a71d3c1663d437c7859625080b7f15bc87aee9b4f080c9f9dfee76c12e28f2ec1301889c6cf8506fc6f0e1fdf41001de8829353d57c14d018359da5314660dcc433daf4be138013220d08e8f807ac89627c4ffd273c2d3d67e9b924484ee97be868a7a13675d5f33af4052e4350f001f9927ece8710e135fe475347a5d429f2b5c21135bfc0cb162b31e794cab4811acfbac6c72005ec3d20fcc49d34bebb027bd183b27a39a43f5b57f841d25f45b4344dbd856f2a79aafbe35c9fdd64b81de7ca6bc283612d69fb49fab3e92ca6411fc50e2acf4f9413e6a67f5c5e5a61b76e89c4781d770910b35fa4018996c3528382ef9c3d0cffe9013312305d8cfdf8e725d0f14c8766b2772c7f027c14f9a7a08eb5b735e1987e488c412be8bf504067f321ee478785a7b0b55b151582e0484152f557ace56ec2b5052568dc717e808e2d14724eceae823950f98510b78618b47992b9cb1184e0df37d8cd6d1916c353eddf31a2e52194990c7c0964cdcd5b6fab398a8874871730df5d76c6c1c6347f49526cf4a5b6beb621063edb457d8011309c360bc2002cbe861bf8d356a7d402f12584a8a8617eedc52b454ea25b9d00f7451d026f4e189702177dcdb6eb5ae5cccbe7e469eed69fabd6817537165c8795d3afebf5fa293119ec5bdf47afcb23b4b2a7e58802705a720e4649519a20fc0a7f668ae8d88cdfc333d3e4215467c2726628d48c941b42d66016cdc7009bdbe56423ca309ca41a6ca7d64e6d802cf452d76f1d550f5345bd2553c566ea6fdc3cabe29587cce12ea04779a19ac43aee9dbb1949bb556b76e8f8c413d1b65f38cde1ca569d04296ff91d9d4dd63c99b4e88e5e8521fc4e372b40e1b6dac99576b6610aef8696412c8f906d1a69bdbbc55eff8f7f318f593e9dfd35139c076f4122391b9771edfd32b85bca206986d37e3865d2307d5a7423d2fa6da356c0cb1506396a4103b96550378947eb8c810e6b8c2b49da7dd1f0b853e0a307ed7589431d5c6ac7749427671b70d059d8ad4e65d4cc563e8006ae01b7b826c8a30342dfbd5246ec3e993e454a28c50e36aa1f39a9f2ecb5ef2d990874a613e3b1a82097623b5b6e4f04f0abe70385224f5f63a76e7f7d7fc1a1e3bfd99726f5bdf9b7ce21e4a096a8f1192e6b0b9f9d3206dd0366f21223922625f541b00cc5cf3fb829a7c65ee69540beb1a752b8c4678e01d779a58171768534e086e837ea32f8e0c748c340db9f72441b013a843e63cf7275d000b4bd82a71dd1850921d506028b9f1d12e362a718bc75d8c4fc04bc7645d3ab7be4b2ce4ee75d590fcda600155cfec811a93b85c79064b5654c43719d0bdf04f6fc97ce9386ea577395a338de88ac4ba300355349b1ada96817af3c6b294f4012ff41e4ba82397d612b7e5fc76310702b1a2d7729835ee5d2e205a1ee4d95deeb8452f2a99181c419c5c8c2be03b02e9ed7c39c0718a58a094cd924b1683678786e5cff4fb368fb826f18b3e875eee80e1dc4c4213c601b10bb8758281fa952a30b134d0ed90efed0782a51794e2eb7d3165f28b97f0dba7a7c8bf9f7309f1ed66dfb956f96efee7087ffcec95edb8f9a323e8a6eb634d4a2fd209f1dddb44e31e9a4c643fe62c710c64e24dea59ea8003b52e71a4e0e25ba28df4ddefb3c06000e326d31d548ff53a68d62594a75a0cf45a564dad87682c8d9ac9fbf2a2b5152ac31defaa3406e439b4fa883c35d73b8d57dd8b267deb15315b68600af7f253eb4dbce9095e2af7d13aa107238300fe69e1a49b2f80ef6051fc3d671810a6d1a8f4f9b2c3b567d95027f9e823b4bac3c82ed9d4caddc43702bcea40957036950af35c092920dbb750c5bdf144f6f5daf4ee1c1431389f3d2abc9c2aac1e529996ed52b2fced0a006c8da0f88c9c99281a7f0356679cab812a126f99956c9b7a63d0c746a34a69753b170df1fd33254f8dc686ade023c5a2b71e76824c95effc834dc1d6abf829e3b16f6cf8dc3dc78aceb99a07fa5a88c1b6b47218f02f9aebb411c66fa99f6d237d458b8b424d95f82482afa8c41ba68ce5d73323d7c420cd635c858c2fb1dbcdc57b492eb22ddbe2c5c95aa51ec4288e3e86dd6d155c1db65dc531919d08829b71c04cbe29d5ddbf13280f8943511a48b3e00cc935132a35e9b1e31234856d103532eb3608f55b0e8e9b084a499e8f2bc1973e913d6fe63744b8fa83af7a873e9ab4edfacf1ae14882255bdacb9d48351d10bfc1ce85df3fc44e921237b3c506ba3d991b6a0b36bfba56bcbd51acaa4c0eb91e653423c1717e4f78073b6e2e35f7916440ec49add7d6e4e7f3218c05b379f678087a2bba897429a07324e16491c122d1ad6c7a861e269d8a1c0bd4e9ddfc6e52c5f5180659a8b64668f2da528e1920bae875e845753d6fc6678f3709842464d668df82dacc3f2fe6d31e5a82549ce63ef800a5870abc5706f65770a51e5a15c1219cbaf0f309daaf6e4f8608bb90108caed7b6032390cda7337e31f92372e58e861d758d454cf33aa5741bc010fbe2f74fd0972d89f5854128c5bc0b3b53e7110b9834ab85441c8da61135b411c047bef65b4d980d099c3f2a7ffb86597ef4acefe1fbb557043cbdfd0d7ab78f49f461267c2889c433adb162b00ad09a660782b07b78b7f174621b34a88ece4f426ea1123398e5388c8b8072b13d31c46708cfff2dec01d779a848b51634133366fa4b498e95e0645fbdf9cfa9b3d5cdb09b7230b99524332263ffb04777d71092a1f776d976dba767cba734f22353c3312adc845dd03fc7d188f5b0a15bbb5c631beec31ab5e5d2bb510827cc69ad2074ee3c8ec447cb7314f04582bd23fb7c5b21dcc39571a2f466458112cca39f5af022d0eb9de086aecbb1c7795538727e4adce85964f1d0ca25f94972d26da50cd0918c53def66f5e8496566b6c0eea0bcf57520dedf73e97c70f9639c6eecfac3cfc0fd103bd44058f1b1012a9f194c7bf2e9f73e8e3aa674441380dad60e6779ca0d58accf1128ce754bc7db5255d4e9851c072d992a2993e0454880f4732a8e78ccd6b88946f2c57cfbacac699109fd466de9823bbe51a288c0b5512a90de6f4e2e3c1f8e3933f72c90a96380954c25933596379fbc33e1ef64a5326494176ea423a94fbf9ade7696c0acb116c8990f61c4fc948ec42dce079b1c715e81048ca4bdb40a473d0aaa6979204cb59d8eb1f7dd213ed87487e78adadc64968bfd1873e2913d71fdc134cfd8aaa666bf831d555082cd9d56353c184fa3142c893477e8cd03ffd682f50d3f5d8316b0ef98c50adbce87a04ae6647943a8f8ecd482b902c0315cbec356404ba9a217ea66cbeda8c270bb7aaf2e1710310f82409164a6936dc9a2bc6ebd0823845322af34a15a6ccdf74598aeb51e96fef101608267624246ac43d4917d64c19accfca447e1db120cd10e6c2c48fd94a2f680c4cfc7641adb2b71b8b5ae6a9f1988b1c78312ff1dcd3a28b779a77d43cfe66329462380a8a384bcdda790992c9c68ad6f41d10da5f79f12ac7a5bea37d8c2a018a6ee005e0400c92c98112765ab7defcdeab4a7333aeefbcf3b7e7e202f7fee8789cfc0342d7b30f039e28c057f20b2c128dbc81cb728c90086fd64549692767db12fa4354af97d687e9d10231ec221c0021723adad1e4a523628be7260ad8709fd7b32a1bdef3860220012a1bccea02550099f504f1d3a29a6bbdbcfb36f36a1bd7faae40eaec0a9f8887da3808c7d752d5c5d5a3455d87124c8180ec79cc75a1263c942943b87ca0a0b0842a810106b76c42897679227a919d3a1e25b807061d50465edfae6f4106914b7a19f595ccb8a67c463db6aa8333700bd24cad1925f5fd2bdadadeec49d46dcdb4ead66e7278b1747d771d19d0f03b4abc6e26659e9ef1ba4005d514be9bff14786982dd9888cc0e114553641181536f456bc26d9d306741171261f6c08e7b9b728ba8eca9e9ea04fcebff1579da3067a49c2479716e28948a007d16d3c1a33c13bac149b90f850eb04f6faa63151e1690e34eac096c274f3926c9962c58729c58f762f0be771916eb8fb1dbbefe134b678f1fdb7f915f9ab27b481bf002ba5844be2596b02c636aeb1f7b9ca4b66741e38dd7dbcc351fb6ca95e566c1c783cd095816fb039a647b4300861d0d76232c50e05e15841cd1ec0cadfc8802cbfab02ff642ad9a3564ee4a17c53e0d8d1740cc111e892893d15909a3a3cbef08670aae372fd7e75fde63da52c1675800ddb3c7c08f21ea50a09e2d7a578e4115e496c0f3c9dc8e787f647dbff71b060cf2a2c31e384da9919a086c6a6e7425dde1a7b884837e152d5d5855aed7d6bd125e9bf6fd49025d854ac4498969959bf27dd841db77536766d9d44bfa323feab8192f970fe48b8cfff567edbda9504a3cc81fb98ded3d07aa3fb2ce2b3fd2e9ac3e9f160afe3fcf850d06e5451780e33701bcf382f7607ce57fc8e87624ad852198dcce6d4a795a79a579d2d757ee4ed5a47948d3c3a04c186349f32f12ffb19192ca02d522dcb88605f9bd05121dcf3445243a9b6a0f2704fbcaba479a80c0049c6ec596ef519ca050438ca92f43480143f416d53067cd028fc21f81c3350dcdc94e4cbe36f8a03c268c38748fec6236fc836a8c8fbb017bb9231c16dc0a4818ecb3868ea5d291a431510f463f72ce9a2028c5b6b4ba8bb120d7b54949c3caf2ca083b959b50902474b80b6c276193ca356d16ae9d3648e2d0f06373e3983a1113c63182f55f9658ab1d6d57385b88bfdc5af2a14092f13a13ca076f34b294d90ca967087e0889f04b1ba9ca92e808b1f3f90f0c9e414f6cad24cde46cdd5190878f05d63e5c64bac15d5fbf59a20db5c387d14d321e57497332b403faa60a940ba364ae44b8315880c1ce631465ad9e230401eebb923404539281fdc6b2d5943f533d48b4c79bb9e17d04f17031d7a88668178dd27418b2315faab582635b6f87b51e78c7c5f60a23a2b88eedf38f18f63be61375feef15b94ab677dc9e5f6c832b6326a60fbf7037394dbf5e3bb5b16efed74e9a735e0ce7a4db5ba6c0a943284cdcf2bdcd30b7829b3852ef745ead98010407a222a92ae2abdfffab5ffaf7c24503c85cce09ed45c0af2e04dc2fa5c1849be0fd59ed6612d2021a995fd29c72e68f1eec29521762e83e6c7347ba5d10a475d6609c43a223dfc2bd6f0c47a10c4b42b0d842a2bdbccae70c0beb42d502c29ea0a371e531c4b813d096b40bfab3797888f9993d63b75a4b0c62c5a35315d4ff796f845e666daeedaf2c6f878e1c4095648fadc800dbc74f0cb74c880c5cdfea12eeeb4be2ac9a511dc169d1dab136a0003b9e750a7be68b89e27e64d9cdac241283c030d3cbfda8e4be2c7c32712ebd9405a21b6180a3191af85834237ae5a3b85a4fde17e45bbe10e7de49fc761bc89213b7d6892887cea5777ba78e68262c8f4134d75470f1264c6b8ef62e8202cec6bee291c18705cd9586ee138a4553267d7d57d24875a4b5eec1252d1c55db97741a47687986075f5044eb983b5efc60590e5b19eb19c9f623f204277792560568d9a950d9bd32fb2e98fab6b5d27c9a300ce8fef3b18d12d27eb5501cf92156e0dfd5758bf37488b6262d105b44223e9f11a96cc446b15ea41497cdd14c73052aaaee117275982b6daa66acd8b692394b15c1c245eef820a92140b3c4548325766374c85ccce2c1375fbf261a42756d7c7326186f3705fe2e1f9c936b45028b5179273fbafcaaabe7e12975fa3cb40e6d3e9427a5d41d4ea1d724ddfb6eb9b28d8de677275febe98743edd9c7682182e1d1dc9c68592ff92d736b407121310264589e40677295fd5c94ee3f19a7b441cbf31f57a8e844e79f61b7161123213f2094669e6f350e70e21b3f5f27ac59b691a1de615892de64acf8a1388788761f0ad0d9943d7bf935f95ee1fe3469fa9859b5f2f8cadc2fa9e8d88e70c60634a9a83827349682908f586d922faaf08d455e71ce9323d1490c0ea8f896f8b65c42f61d17e47ea8d04f91c22ab04fe22ef8c701de1a310e1da2dc21d0eb5a5b17ee48b1727bd6b8338e1cc85c6de8b47274bae999fa41355e86f2e106d5390bbf1ed6df12a7fbf05a164e83f8532b3f6a27f11ce5053ff6d6c7ff6d54e584cb85cbff371cae28c4c7736b2c78149c06b62c57ae8fbff26da320bd13e8a36c34a6eb31544f2f6c3a77ef2680ab78c19038cb54fbc89ffa3efd66e0e892604ccfc495af01d7a36783e8a7e3f85b809316f7d426035402d568f111e947c3a79b822ad81dd80247f3b560fb4c0364f80137c880df2bdbf1b4983f3783461430440ec8244c556c3e7f41a6d86d87e0381641701d786826b4781d4e194a0029a9589bbc811a42d8cee6f9cc328d7a7fc10bd13290f027e11bb8fda1f13c4a235fffc9873ecc9acca1407e4baaf0f168fc5dab4277f6a4d784a13230c0d01746560326736507ae185b424728a6a097f6ac4749dfe306cbc999dfc5c94279b7e70b06894a1cc5849a375dec291a0c92fd6a23d329fd6700f71787ae62eb6cecdae9293b3069cb164ff64cdf4164fd87c181e7b54cd815aa8dd6090b19614408e62375f1b01e5f03d8e8fcdf31fc14dee672847a690e28467b2204f54463cf3194a7f46a9760f760da33380f0c5ff7f614b6af0b57d1ba1187c3f3478977467dcca5c5cb9e6dea9c019fb16bce0230f40cf78defc1d575383f8b7f1ccaa54e3b3943dabcf0084df62e2689d91e29d9e4ff57eb26266953732be996df23a013605824864b39cd993d85a8926bba8ce86b84d82dd6c019bf167448a077410e9f4bfa6b9fe758823f61fa6693874354b8a49b56ea2a96bda5e648ce2fbe0a8ce56e7cc1021ce35cda714ee6b240f3b6941d292bbb0dd7cd626e48ea7eb266351390ceb54df7ab0070989b7f3ea82b6716fed0d12a5f1e685aeedf30b273e3bebe406509d4a1b8430624084b2c4ccfaa67860981057c5ce6ed4ea67030762bb7e702357bdbdd67711659731995de9db1ecb602ec8110a182b43c50bc1eeaa72efa88791ec3c9974671762f8386a9e6fbc1dfa50fc1ed7d05c7cae346d4c78a4d725ee01913f6b07bb47280f208ae2e2789a033e68858dd267aa0a2e239b0818f9bb10ba6336c3d175a94eac2d3bcfd287791b5232cb8e3ddf61c335fbd1f2efc7ff058f242a8d93c0a87316f070a8a55581cedbad1b6092fb10666f5b5671fadc08c4c2a0a63f93d3460886496989f64227321524f5ef6ce61ebe86dfdcb65ae381953e08d137f1f04a9fcf6fb7d0d204d6325a3fbdf24e34d1c44e127e6574b3a2714f9094e5df963aab5e0a4db675c037dfe1c97f5cc9b5afc1ee452b9a0fa1580ee0a52a1fed1f8ec398bbf04c7b138744f9ecd90e7e785300bc3fed2609f47c9d4ae006591416cf31ffc6b130c99283c3a999b53a5b9c1fcc678ebe9d8bb6544ce608697d167e04110b23be2b7990e1936c0846743130527e4d03b5458dff33cba36898338ae35b2f96c36b749f86a46e9a8be82d364c9f6cb663fdc58a784f4d287d1869bbbb9ce84e9d5a45f5f90687b7a7b45af69e9fdbc877e305fe4d55cf87bbacaf33fb16271f0892956da01074f6a2f69d8cfff6c771c047d3ff301fa1d3ba5f7c302640794ed5fee6a489a7a940f14f46ae35de1b20be6a4362269ef3e03730b151489fdba605ed0bfc39283ae3de68ccf4aea61f181bdafd8fc54c1b7d9c568d8d7514d63fed814ed5fb848d24dbd6051feea9ad3ba793be2c215f77af0fe57ba512a95b3c645810e730f4eeb82367dde2c1b03fc87b89e055122426633d2ec5ef05b8b1e66a204b48492a16469612c6a166080bf0237c2dec0bcc2d49f2344888db4f432424714fe4f9804fc95564ac505161227ef972061bbe3eec445220d9dc4ee0ead1d8a57b565ac6980763ee053b655a649d1bbfc9dc1c5a13421ebdf74f3f7ea4137d348deba3dafa3ac4258aa2cbd6b523a9541756ba58ddabbc320e42e429badef0d013373dbfbbaadb46249fb78464405737b10bdbeafc82674e28c41c982f1a868c5680017ef0dbad7ae5a39dc7ad17ed0414601c8b5d07acfc923dbf8d1db8456ac9954d6e4e0c74e606d94d3d9d78f639b2e457fa5fa41c7d36f9e278560d14dffbbae8ebb41bbca6f06f6f5ebc4bfcfb4bfcacaaeaa6ed64f1c8b3c0c263e7a61bf182534e2e296dcfe8ba9d93c5f1554e873acfef4ff531b79db30070d64bc41fabed82a240582620e93e5ee6533b9e20e6f96ab37ecca2b52b1e2ad878ddd327e3098efb61111fb969c108fddece4e7f939eb829f5445e94575ab5565af7d1245d076426b35b343c6058356785d509b44df5a0752a726cb6fdccb0b78831582628afba0d126ab5da6ffc8588f7236808b7ac0aacafdb243f9915e5cb199c3930ba8714830065cbbf42eef669c4aaf67e9ee114354ba836d11b41528a2e127175513a941c6ffb266077ebd85bec981c21d666c76e4a1946654e251959db58c00bdd3c7d9af8f4b7345504cd85826235d002b6f55f2b4f3537a60eb5658b36d5205864073fb63184d19ae2aaa3d1489532de852278164f37f3004cda1f33caac236965b167185ecca361a02c92b80dafc59642207dea5706d9ac709b03c42628db8044c265ba27618f82362e665e32b7edbe9b045997d5765016894afb46c6ab23a5fc588fb03bd7b3d9739e5f64ee28afa4d98fe4605d49418cb50cc65ab579e45d008b9637966cd56ee7998891f0e7c6b1ec284153a7a8e32d271810e3bc8f60f3d6aaa7f0f32e9a8cd4a92b16df40ff6c6f5dc2503d4faf3cf89aaeca040ba2dbc1f9eb34a8aaad0ade8b86ae7b7a5c95b4d2febe97cf17c5df981743d9236bd852fe11aadbaa01f7a3896f688a6e0333a08c767d6eafd8e24d4e6c896e611f75c2a4827e5fb3107e655a9497823725866b50f45add5c33aa9edb5d09a0551a33059a8aa20e9c777ef3f58b43d93061823c533d924947850e56a70779349279107783a606242df305c87aaee357f960739416618b21adc16359e0568dea72fad4fb12641cad33ed6e2077c5ab1532b050cff3e16fe067bb2a556287f9d24d011272688e4c6cdc0bb2cd2311a51a0b522a0839d415d8c3080fa4b502d6f83cda28745e2308092bac8812a643188ce2d2499c97695801e480e56567a1346e9813f1f7385d12677f9978ae6bb7df5021ae567975acf9fe1241e9f83b21506527419d490d48f1e9e57fb01634ab7147fa9731a8c0d05407dafb79d6ecfffa32225806b5153727d5c3755c3d018f9a59e0142b5afbf9b1b064e307ad84dc12761aba80fdee12e9a01b77b12c95666d2636ae088832e636be06c0e55e731482c367ed9422def9047559cf5f6870fcc90a8c3507a94e71618d25bf081bcd4877225aeea1c7da6c2733e2c95f004b8edf78ff79f4498e3318ad12acdc710d4b159a6393c25411790661efabe181defc82f2a14cf1290b0ee00728454b4e51a489904e0216b29bf71f9a3c4edb0304f051bc70cbeb0bc27ed25fd1fe5a5e51ad968adb1e3c038fe7d904b32ccf96e6ea42bb40a1d0c0f0e69a991c5f4aaf62ef2b41e810909d0e8cc04353cbf59a3fcd827fb7b5d8b37046e38f1a026ee14ff147261f2740a93f075571976968c6b994c9d98ccccd5c6dabc0b618cb4aedc7e4a069f0a6880ff97af153f0734a340d1cb103cbefbb8d3115f5e742a22def02e73cfc225bd8c1c9fc196ac0f8deeb4d02f08d1907b1e8f227723fbfbfba2ed24655de301a64c12f2f192b082c25369482d1b06f0ad3693cd49c3e69387c075fb7d253fe0eeb4a0a9c0fd4816e09d370c7b6eb2201f6696157246a7499d7d09725f4960bc6df1e0894fe01b6258d1ed14243a7a5f6a0a239b47523f7f73e8817a1986d567beb3a508f3c6c76577eddcf35a118a428a4cb91df4815806fd15ba4aef7e94488e8a51710b4875228936be3a15d02d3f0c35f18e991c55ffc1cdf421d54d6cf5727f1fe6bdc6185b1367271af2c941ecc9fb132d9e1d3af64ec8883d64c237dd1150b87445af9c6332f777bc7c118be5bf855170471013a4bf8781d35d13f69c37a91194175f56af345e1c795b1c4a87f62c8560653dbf8bee90b3aae75bbc7b8e6f1b068bc51d8e04481396b5d0bc7d34efefdfc6aaec95c0991d7247bf96ba3d9ec42326fd5049381de2cdd8d7282642a382a84109f78a52ba77e4b374744863f94e6e99519cb128302b70bea783c5b249d6167964be1f6cdfe1be87d189958d1f513790859d23a51dce789edcad35b79fbff64812a0d064ee3bc16d73cd2fd276320a5d5c2d1b509f83785078279b66f484382a7de850e4f0b401bb26199ca2c05f803b08e8b8398cbd9d3e090ac52da16eeaabcefefe18cf7bf3874a116acfbb1aec120dec692e2eb7e223eee608f94fdd22c6ce86b72257920991acff40407b9ea96456ce2ef0d5f34628ee0cd291cb3b7b8e43a402dcffe851df983142544b2eacd47f8eab20da4e8a56a97881e9fc285a6da24c7a28b55e3cfa87a841456b995aec9b11ea259daf17bf2a7435317301b2041415fb07680d0fabb4b98658abb5b6c55353ecbdfe295dd10ceb1f9ac6fba5d370d6abb02ef0be48c92ca2450a691ce29380c4435c487538f4b8cbf1c9a03689832e59f6fc5129762bc2957590a32793a159441216bba1d0c92fb31d5e869dc79c80bbee30f45d930485e78e4b391ab86495b6b14ff7e232569a1618651f0857f789c6a8308198acd2171e381c783680334c89b8bc4011d93119efe28e9b1fecf2ee979ab9c3f67cc43adf0e633b550028f051073c176e69ca70b2d6badd872143be733f78aab3b2243013a457be258b9327fd53e93b133016e384ca7a064a98518a8b7a63f85e0c1b027a7b165d0fe6f592af12c2717f4c809e2776d1fa8949f18491254556c6133ec8cd71964e8c1f70261a8164c4699e5b4ae01d3acd81831509a206e1e26e84d7220bf77646e9213c98a136e59efe9f2c9238cddd8f5cb501d3ea2a818daef806e17486be0376c5608d2eeddcedfa8172ec7408e56a0b7ec9f51337d87336ace45afa27bdbbef23f3542cf98e4242e6dbd6ae4b55c9d62d03e3712953e0b88430b8e6875558070904cdb459f52ec85046debc28064dc62ef26cf5db4322afa876ebe9ca84543e08dbd1b4581b830430c006e39e7606901ee769c684946862d3984a78c3413a929d25f03469eb466a5adeecd557135694d7392b3e2da2a4ff33feb814298ce13ba06b698af4b4c051ec165b1acfe8fd544171bfa2621524bd27c77e7ec0636b5d5ac950d5aaaa1e0ebaafe3728431b94278b3a65222432fa06b8c953d330c05dc8f2e68fde76dcbd6ff364bc0a8e9b044203462cfecc818c2dbee40302c442be30a20b18db3481567695746cbfce855a16f8dc558c2e0b259e2615c5cd4506a51210584cb0656ac33080c21bb0216d71f7e8ee621b26d4b656bddb62a9fb0d7dda11045cfb599fba0e2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
