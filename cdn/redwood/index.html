<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"23c583d2a72b71e787ecdf9efed0ef3230f1adafe7dcb3c432d828cd714b395110f2a7eccf5214ec3dcb62ce40ba65269033b2e553aa4f05795d7fffe752e8b087310cbe0131c4d57c65f41b2cd7a112996ce74ea23a281b456646c30c5f69c37782b99ee477087e2d50dc1b7e39a566fc3f370dfc06bf2f854dc1546acb6a63f67caace24fb92b6bcf1d89df9c201485c0ca9fa0a445fcf02afffaa69bf75b57df37e2de95a3bb94d23c68bd45ebc9ef4073e2dcb471b2f7315c09797adcef9d2b5a26174ee1cbabe1fc05640e7e8e099833a62ab1106a7df41a42e7d1e67d9e423be2ac63d599b0104a9495aba27abc6e6e9420c329e2a0b4caf28cba44d8ea319c302bb68b3c881a1361db10041d117f064c5ee9efede82df708d66d32d1ddccd5dbef072fa2a166408a8423f44eeae185abc5b1cacf25957d527b77b2140dd79e644a2173cff212c1cd81e23608a781b63e07b85921f1e8e73594e20f1e3a46e01dad7107d7eaa95b0ff72293f31ab02fc9577dd13b86a92d480dd42e272c272416a9276d688a7ae0f72578fb31cdd2bd79d3e41ab24551e2c32565f59799f8305f6ee69120f94a1f7231d8a5ee67b827ab1123e8b303d0677b54cadd1002ee655ea8785bd2a3583f9ef7e46ecb6dfba7e09b96e82da8dee04d7edd71cf5313e5ad793842effca5fc5faa3a95427956318ac4050e446cc3033eda2d36fcd032f8aa10e5fba518f00e16c8c14f22e8b445276754cb077ad7cb827bb202e5c085715517952d469853cbb1a5693f1b8bfcffceb5f35b65b6aebf69d38e7ffa3eec79452153c82dbcf3c9ca599dd16da95db65988f40a9def1bffe01550413d7b9aa969398459f89859ae426287025793d2f6a757a907a226b9e4e387f7753e7040f87a1188ce159b676178a5a025eaa4cdd81fbd4c11f7566504d7dc77b7441081dea5b98bdd5d206f8279e9b1750a6b84fc31f08a8872cfef41e808cb1d281790d5d90f989ae47925b0156b6e1bc1cc5b49fec3eff56ab570fb10696299d0943368fff2c8685995f7ff49bd80eb6ef1e8947973160579fb24d9d51602e1df1f98093abb75fce319942dec8c47015d310a822069d2ab021db23d9ef58b4602036c5755f218549c6865524c55a91d29926ccc73dec7c9602c036945c836b835eead2e11dc92af8cc7732cf76375d8e312eeecfccd2e008767df6d78f757a4704d8e2d2d136c05fa505734be4a0673697d4f8aca9ccff400aea8cf8326998c9e4d2734632eed79f20323beea646e893218cdaa69356602c3131348f7f33b7116685b11bde2d30d9ec3010695ba5e1b5dac06edcc4c93854cfc292582a07b30b2d30abf39105db54bb18278715edd542653451bbeec86d4f6d5dbe3fd2aa42f8b60a322b0aaa7740e4f10f033b376eede7175fd18c9b271fd7d05d053f14882cfac846a615a08e012253434435179a3a4818e05a643f766a0006ab1acb78cce42551aa0b9ead4639bf5973460f145cb065ded2013a8bf971ea0263fa892d58a23cb0c3eb35369a0dcbf7a660d93714ae2c4d8eb2c76cbe0c58fda9ab19a74b04cb8a15a34d4c7619485174003d77eaecb9c1a3f6dd830ce83056018d3d6f61c3c657da6f0aa11c885607a07c24195611fb40c783c8b2e527cb33eeb9add6c24df7795aa38d0e17157c9dff8ad4687b36483ef41ce09af931f816fc6b3eced63b8176efd2c03630d5c872b91965889b7ddf19ef26fc0d22de6628efa30525bb2a045bccf53276ac1da4515edfa0e55602de0f6db771a96bbad0f6ba559c9bc58ea2095af9ca5cce59c99e8caa4fd0805585fbf2068e24cbe949e6a6fa6f840bf7d4f6955db22cdc430b66ae1f0f8078dcdd56b696feb8ed7440ee5f5c62465cff6d90806ea21b1f7a6fcbf8fb48dd33f89f27b8bc4ac7afcd21183958ab38dbe5da5b6ef38a1958a12aade92b5b0bad6173992312a554bb597c2ce0f6280d647fe49fa8e9c270ebe39e36debda6693971d32e24c2ee98e4222d7079bc5026c39dbd13dc5dee6f39ae8e46d9fc0211b3f7f20bbfe2941e83715022bf7e664453b2fa438b0d4ad55823ea3d4efb2eab7cb6306003a4dfd6bee92008d1c7c6435d7522cebf9252fb356b7b71b96b203b17ca4345040c34d11ac1f6c34871a0d4ea3df3d61e9e101d3a81a91e96bf6926445d626408745fcfbc7130b81bb8b3df227b0e852563284d61bfb36a565d8c7d441c047dacd7bc5799aae80c89a265ec35d81e78b65fde931def887f4c5c2b8c3e28dda41cdb6810ebf6c71a894cf63c6e1115618cabd45768657bf28de16b6fcffca2d0c317de3a4ff3592869af83edb4334e1bea30d8aa587ddc7380773a92e64b8d0662c5050a6ae01bd9a284fd7530db3ac7efb960977a8396ac9862655709ac4c6cdf3926d0acc3dd6897d838bfd08bd0e1f3c1b87b8528c200a36e6349f808bb82b4fc89bc3db20770b334f8ce2ab0c2051f8042cad5f500c28a24408ebcee794afcf570f6ac03f1d4c3e0ce63278de0ef997d9cac489e062070c6f06e6e5049e0725d6103638048bace37bde8d20b0a723a926d4ce2154b57db68ad9c6fc38577a220f95908a5209941b20d5bd5f6e9dae442875f6b0d7f9bfe7d6b07add8d0964a0d075c0fd29875cb0cb2c00f427d70154ff9a9d4b8100a4d87b7a846f38e1b66543fbd4c50ecfd6766313687b1a119645aec6c9f4f4890b3f45bc226f959b83d5b1eb6abfccdaddf7831c855f331dc3e7f44331775e8b8dd250e3265db9e7681c8bd3193d41ee965fa80e05d2c1286f477183996c47c8a03186d7b9a6dccabc0a406b99c367506a845e06f27e03069f8dcf48f4468e369069cc232b00c0e25cc1eaba03a58b75b83b6bedb292ef463cbcb21d5d3657305faf9d5977161b3301693007ae19cfa19e14fcb6904a9e13eecf11e9d1cc159716cbc43992e198afccea95fc45e292eaf894b94ee05a15d9dcd47b1262196ee01b96dc42127603e25d4fe84047fc4e72228d0c5736e107b4a6a2758c1ed52771687338080ccb3aee4377f4a4dd28e214a86aa673f747ac4596d1085a5ab4cf0f691bfb0f06e69494b1ae4a9d1d3aa78ae2e4018aeb9bfca04ecb723bb9e29d4f5df71fc0c3302bccad597c61da8a916004ece0967c4f3a67d343713bd83a58749e1ef308a8224679ce19e34c128318b02ef56323b6921a7dcace0813abb079db5f12223b794a079f2b778797bf77d0a32d5ec1a93bd9f4d9f6911afb2661694146fa83a6e75f52b8d30b75e0c3420f9d92bbad495db2e9816baba11873d124e9d7c988df0809f2d15bdd4f8a38332dceea8ab57800a06e31aa4f626fab5f349c54a87dacf28ff6097ca37537623d9907eb32555d9a875639c7c86176edbd670fcdd465428e8fb002d7ed636493d8ed14c066e6120651686343c421be3f30c17ebedda2f46dc2a013f4fb46319b25dd12d71731d926e02980541e33dbc9ecc2c1ee7ebc47c963fe473ab6b61fa1493d83480ec0d036fb62159d66dda11897ddec2f7e09173582a51f5e3b60fd946513126b2b30c76bd7a39b4e8c5b5145ed213f15604b39925658ed47f21781cdfe334985a3fba9f047713e4de2c5b9523e70ac1bcf274d9963c4daf89368dbaf0f4b16416e659f05534f09c5388b5a436d1390d3d4de53925a297cb41a28225691da67a23e0f7ae1c695cd4bff851c9b3f5f2b66606afaeae80631d889ab5391945cc8640a5afd5c7207dbe355f9dae9728d8b76994671f3b8a08e94a6f27d20424162b3928f88800604c8338a3f92d413a79cb349c758aaa29847780784746ab217e34f61c14cc6e1dee0ebdc5e15d33a5590c8356d4f341768aef2f73a9a6e5eb19b6d1c1534f540b40c803e0f33a695de0bfd92d67e7a69a0dc8384c877ed66bb1c30c2e78f040f3627f4a8683af5d50a6fda33ac028f47a2f4f3ce71556c86d29c210cdc3649f8462229e4f5ca54d741ff225fd4abde6ef7f1948ec5e4d367672c90a49514cc9fc673d027f52ee0a9866814762b31554bb0ad054d363f3818acdef49ccc5984a0c23f8513c38c4b394f89fc9f5d9dbe077d5f4bdfa2a0dc8e0521a7b455f553a56138eec63c4511f884c934310528121b4def8671b34e0b3e6001f649c224e9f503c18a3d987a368e98fb286e7396e8f24ee7313dea1ac1fc14e15f1a49c373bcfa9d64f003a32880ec5a272c234bf5e949c6e764b594ef81a7d1b9b6829e824eb5bdae588f44bcd8baadcca5bc829d3cf74817dbcc470dbdb4283a7f91f67a1b24ef81fc68df09a3a6eb0d7004d8d2bc73ddc150f472fdb947ceef3d50ac8fdc4d9ac1199b8cdefd1a98d1c6f85c32e6e5ee09ae6068d9294891029b60c2270d38c2a4cb91db5095c2ad259f22b2d7b5baa3eb6699e7aff71828af98e90de91d6741ca35872ba16109aacee462855009f4865dc2f875012f6c2ab883fcab38ca453ca902b32d0d2cac88bebdcbb2f2b732f8a906252a7fe7596411b527f3d92490d97cd92ea2e38b191d6a7af93a9195ad6ee3e9f856a6803849b58fc960264c02045a2967b9e54d434daaac193534e36188e16d13ad442099900c02fb3a6e037066be8a906e33d195aa1d66b969427fe10f671d9a4b216e030f6de86a0c326956f681c78bb8c5e8741820f3a5d5f31285d01d92ec01b730c97c14288ba579b6d15bd1a2962134a696d308b57f93b95f66d4a3cd4cc946100f1d7980eb1aeacae5e2fa68874de5be133cb0c3116f28c09d4ed69c9cea4f90df57a7bc2e92abfc7dac223e500ea2beb9face7a2898c206608ae97af71d7c8ce77dd0b9b64025ff301260507124db4d2b773f506828eaabae61a433a1774fad8bbbed1f978ff5d460bb49d41665d5ac72390de51514ccf285fbdf2c8d22c1be040e53589605df6f95381278f0ed1d46544510239be6ae92857900f663abb3373711d9bef39104c9e0ffcd0ace5fe3bf2a1140151e864973929b8596e41b4dd1beff88ea73f5c67e2f17d587cecc82e342aff7ccdfba5bdc58b1b19e227f604dd0e7c6cef033429d2259ddc45146cc88d023c6e5b80bafd9abe72a0419f085cb2c558d1fe5aabbec3809a6e0f8f620bf7cf24d456ead6c895f4084f89dc8683978c06759e5cd64a001d111a3023c97b4c322e170b1fc48436862ded2e0738bd069e47f404b821f6c340e7b3f1d7cc59acecbb47472e4e811b2af5d344ce595358863cf431eb5b1953cca11bbceee0553869aa7ac67921add8c14807f671b5b1b6ac76282da0fc554828dd4b25ee6b9eacdfd9b8b8177cd378d69a35f14f70b6ca5a914c80f436a5c0ac4e53868355390eb87e76bec807254a785976aea2340c6e9086a9c4539ae2f3343786481ed942e4278e3bf5a9dc8e72efda4bd645acbdf20b492bee2bdbd4026b6700515b5ed3b6043aad84e167e24c95870c15623dcd66a7f9d442907aacb4d000ebf9f66247bc80488df7413ef3e52b0e6d28fc74321bbd271ceaa37636bebdf3c23534d6f44edb58defee11b5a3eec4b66bc1bd6e875d0b62c6808cde3305924f52f5de69ad6b27e1c1db82712b774f34a9720a0a083c7b0e9713e6ffbfdee319c8bb76b2685c58e051f47d21b902b2a5b70103ce009d07a8f3645abdafee44166125171898a8c2a6577ad7df104f7828e853d139a7df61677000529f53d60a5247016dda85519ff3dc061edc487bab154e16c1d7fcd57b733da1e1b730629af68e5e6f318c14857215f88a3c5986c7b863d44300201517ab55c59d8ebd62d7198a8a63c625b9e3b8bf5d9efa29474887354dc2545553a3b7e60a6792f49e4bd9f1177c2cf9c7916ed77493d1fde5e28cbe83bab0186f677e93f9a5a9e79ddbf25e7e7ed578a988432e89cd7e0ed576560d2fba13f76a40e4c5b5ac3d6b1417f2b14bde6e9e0a943e99dbbdb5930f1606c768b5bae460264918413ec6804d518583bbd1a583f5912a1ac3ff0fcc0161634fc18dad1286cf3ae487937b83de5304b6dcb66cb3417524164baf059fc024b228adcf9e472f39df288a2aeee1438e4f2ca5cd9a44437e505adc33ba3c2a989ebe7839d7aecfe6ebcb04ac2d1ae334708e98bea54a2f8caf18836c255ef01d514614cf8b2a86343cd9d14c4be63d34b19f7617538a3cd6360933558d360b8525326168cf3dcbebf782cb51ac1d17a7b5ec48ff1125d3f11722ffe51ea9eb37ecf93134e532f67a418e8df84e90b9542a5b8c69c5d2538ba71fb574a8cc12f43cee87a663001a8599cba91226f85577294a0add2439b65fdf967cab4d937c270364e2735b442ec14b9c3c06a259944e34f358a563588aeb606d2213faeb28a475570236c0a3b4d493b10c9b1fa594ae65aa9ef5afe7420eb4b745ad874fd5f2a2bdc0505eaf1c409886898ee68e398f9aeeb81c54fc26194bbdde227088f4ee69866a37cfdf7e559c2feee759a4e35f5c4086a1aa84f7fdc1490ba8725283f6823a77790fd61ac48e54cd677fb258e5ee7d2fbe381f8ec78062280a7bd05c7c91020c07ccc7cf8785faacceab096135c6d02c3174d54cd05a61bb92cf33d6feda63bbde6f6fa86c2ab5a3fb4e17e96483fc5c1140802a31e247a5b4115358b2782adecf41b2cf2cecd4246f8dc579ff1560ba453b005ac41df02e6bb4f1a24c7866377d4f0957637d50333520804c1f9bc01ff5fd6f95aa4ad83b2dbc98be89299c8ddab6a187419736223462a9a481ec43fa2c5e2e4f48aa20a3de6646d3279358669e05e1ae654df60628a7ba4241fb1c68ecc3627b38d3633d4a02599dd039fa3ff7c9523cb1b4caeea07dda1d0da3862d4da2f04f02c01a812f0a8b0174c2e2de86b1c8bfc8446bd842af320da166fb4b161787c3e8a722e48c793f278f6d4126e72d9c051eff81090de68688533366e317fdb70b767987cd66f4ffdeb048224bc9f678388c5d21fb61ed2f8f76e4505405c6e5f29e0477a0c9a004cdf004cc6cf7cb70c39ab93d8297469f2388c3973732e4b8758c9295b850f239d1fa70d20e38ef04094e6815a9be9d0781a3ea6e12d16ffb5f860ec171678132f54ab94ea57f00aa88f10d17d92946db313f8ad81a65f5ec12421e2af9e914972fd9e720966b8f70efb0a225374964137f8bef5a1dc36cf248ce4ebfe95570d56dbbc5066b744c2b0f4c014e77c4a9a2c08245bbb833bc1ed1e6eef55eafbfe7d53735297cd677c3e07e437af8dc2b125f105304ed30300f32afb2ee424250a4257dbf866848f06cce5d5b3bfa282998f48708b68a386aa2f8cefd6713c9a53a68ff5215353a9b792171ee4e14bb14734f3ec46f585fc1633210a85ae87b07452290dd90c58d8029d07bb68a2427952a1ff271b196d5ee434ef821380ccc4ef91a4f8f40321435e92266be26edf47dcfb6a7029fb867f04f03517e745b41ded494a05806bc02c113521513bb020372c786d9fac0d1be43e6eb8a9178edfbd40107afebf39dadd3094019c5d515e32c362c78c50e21ec3835450801425632c54a524ab0102cb71e60ed06d9340539839c0e142191fd417e03cac0c049ae954ed3ac72efd21c1d7baf1c3722a5a28a3ec863248241ae510a63916be442691cf98696eb98c5c7d25644d6fd631a828b185880de56deab0e039e7421905681f3cb959f1a6f4a84912def30910de52fdfc20646cc25c7ce1c1ad8800d66e96cf37f7053ea76ab2b2088881e0fb5312bce85f5698ddbed192c4da6eb4c25aa63d01e7a1de2743b8a53d3908c2eefcc21e480b65d068d7a9dbc0d2fd767d33037960932e8160d35781d7bdbb5756ce3d5643764151e95f44d6ba46763d7be14acb01ee15ef3b485e578eedf533bf61482d33e2e14c01e22bdaef2973e05a2ed1a6f84f562b0024526aef39fcf7ed5d5c73f114c19640ba659b316eef534c3de0ff14750ce4895eed692fdb86364f14ceeef24cd3a8ebe4936f86d29051415e613bdd80ccb4db551cee530577b0d260844c6a3ee33ea06d55704b0a982332a496f909657fb6e1cfa781c52d761359f650c1800f5d42225da008e56c7c3d377bec2be068ccc491acccab66e5e0875bbcf233a5d789683e7106e0504de8e02ec9ffab6dc01306f1efa8f40f9ca5e35cb74f81973214049020c14f3b5d88b3679986c70945551c3c9412ac97cbe08133fdac2473d6406bc83224ae906621e31f2013cf09211e34786a687479f52deb3b45aa2747d8c88fbcd4311060d9f19e34643179324c002b00cf4c17c004388d44335f5bfa6883c172aae6863a3c684b9de03ade10c99647c60fa7ea89e4410e90a916020b5233a84620003f59cd044092bfa8bdeb2ccbbfd78127d624f3091c6205ce6e8bd003180a3f22124ede5cc19f4295513b3d228f8353b3c42e12302e21f1400dddbacf933bdb0ba53b43682373cbb4baf9e353a4a9ebbabf461caa9b565b75c0acf1ca7fd62be232d647dda73460f2920da5644f95b81319df6f36d7161d06a511444d47c3392a5ab5229825ea32c8f6a9b1e42e3a8184114d87bdc10da4658bcc807e67dd9a7f04b38e5882f94c5b2f3823628d3e4a33e2dd1e75b60fb28bfcc240b6949f0ad87f471d1a3dada3a7cff1ad22319df2630f0202e3417848e0d10220c7ae1fe5b9f227400a32a22bca43c206ba77d3e4742f44f2d8a3c52dc42807eab645f824267bf0679292c9dc208c2ca04522fd72f3debe3050ec66b0ad53ba6f7e53c8be6eb1a19ea2b1c305ae7b04e1341c4e05dd725511d81bd25669f74e033026e7781f13eb301a9bfc1f97215e80f4efa7c11d6846caeb14bc76ab383232a02c9d851b2555933665c822561047959f480c424b07a0fad4296af822f52bb0d03df9c7f9aab444c4862930fd8df050d17a064ef19c778c21bc202efacaaf51206222da3a4747f09585087e8b793c0439b0312c58e61024aa5bd76e9426e2b8b76b7dfd2e88bf4ce3bd242f1739366e00eb7d0b7de5cfdd0f968abb774e0709337004247c218bfb8538d407641209fb8cfb5447be5a8b04f52aa9fc6de6d4efd2d6a9df5662d31dabb8cbdfa1e0291ce8013eb3c22b6eeef4d8f19f786a3ec60440d1f0dc96a09c1c3507d4a4037bb6c1cd4b181b892c226239f94916ae21a8473b46ef5fb9a6b1224a86ce831e54482499249d22244f4699cadaa3f984e2d4521a35048bbb8d45f65d605a0aba753e98dbd0858b24b3e237b8faebad8939044fa9c28739afc0cf3ba545ebd4f72795c6ce1017a62cb868a0be079cda4aa4ffc9aca33a8e70b9f85ad235a6436f57bc854b9ed3ef8448d845c3f1b0e8b3a5e34b0c01a8a680cb056371474e76d54965e797a51e5a97280eb2584138642aa5859d097ddd98d4882d82a391b0aa19eadf1db14cbb0fe255dda128a0dcf5f8a5bbfa6e897b149ed7c9ffeaec7a723e50d23926119790feadf0ef3ea49cef2bbb36fc9e54a9e0181ee00c589dac4b3c68cf2bb165d24507fe191ab6bedb9ee35c130676b2ff70cf54efc0b8a996f4ff1a2a9b6287de57b02cd4f2ce313b6fa675c64c072ad97ae9747aab5f59845f9d40bd9e84c3f83303f32f095f4c5f06af876c6db0f36c0e1dd011617a754416a242cb9ccec91e26ea759d9fa07c60fda7b2fc5fc0b28f8824ebf4341c5ec962705e83127cc5b56b232737cf8af9ee27951a9dd420793e734a478152d8bf806bb0857b4954278de7889b8f90f45cd807979c9b8fb4542a803767b4c918d4455b48ade811e8f76d1303720af0778860defd1110176da5b99d55459bf23d4d5d093590475292da0cde92d698dc7b13941a124313788401c0ecdf10dd51fc49dcd5ff3c1fe7e3738a7529379fbf471f510b2458bc7a7b45d3ab058f9549cfa3b7f5e56b91d76374b2589d5a5e5a5669128c6433730abcbd5febda0f9488babd8d48b9fe0628cc8aa05257f44d6bbb372ed32a0da8babe923d287d77de267b55550e31e57d38ae211780063556c44b6ac64a1ae8e5beedc22bde798cfb86d0b59ed0a6b4faab70c59ba8953c1832d0231342b5f7eafbd955ab0a30a40b4a91ffe4e65635b192527c112593826d65aaf07658c94290645651dd5031a67270984e3ccceeef22d9d8c9d0076f4c670c003830ddd1d831cb2bf0a04b43a7f7a200f25291804c5b56dca6015182d5e70f579ae81b336f6979ddb95e2116bc4ebdf68a0a7900b2f2765d106c1ff502b741ed41c291b9195e0ff3c0b1fbad53af65d42094f1424c9df9fd8ad6d5238597ecf3630356f6d5fcbe3e24deb3f0399504953b1936d605732779310d96b09ea4f28c0d772618f9ba60f41e9c1e3fab6c496605eb8beee51436a88e99c721b2900ff934c04114c27f6ee2be5cec6fc1761df63b698feb78ecfae63b5a16ab4f16410e1fcbeaadaece2d03964ac5cf1850bd506d43a1b7adc773d9a6edd3eefcefd3062bb158c1c1cc2673f22dda89e0d24782fc9e19afc4264272d5765f4baa4d714f2af33b9831af57dc1be700f76b7fcee4c0d58efcba9bef75362bf9d8454d7a3d9a5e0161b08a56cf6110d4a1e33095fb34c641492ac582a61dbc988eb96783086a1bf47ac0b77c91623d2cd41112f267f9e6087c38209d2a23fb9b50c08dcaa601d8129e6c35ff011f389bd9794b260c966018481a0e46702972c866ce1d76af24cfbe99ba4d6cb5d970058999ca5248535ec1e2f4ef919d26f96f1582b5a3551a2cea7fc7beab6d3b95fed62c2d8803cf9e7776ee5c45f00d85fcfc427166a0e91aefc63d8df062ca1fc33589a751f14d8aed3312450528c5249ee89c3f45da919b45f0e62016c6b93301f43aedea797b1a5a825a1e3c7eecde53433e229bb8d5f9579d6ed18a77528403f30a33fee625b2d0afef1e9813e295365a194d1f987041972e9deb840b9e1aa4e6a1bd208868d71862f5c3df4635f2e85891fe5b6ea2bf46f8714d8fb349d52c744a12f0410239e1678533ded467d358f5b2e3065507706c9467b3a58e42ef7695ffa10f79a1ff747b02cb3be51e6bb6fb5764c84db9182b1ff115cd2545729b0d99b321c4b4f3a840d830eb7b6e909116aff89a7c3e04b5660f442c85f9d49b1c319166487a2f9826e68717a0b0cec6ae883eb85eb7c508aadd2118d7aeee98b5976eebc9fd2ecbe5f824b8c08c374b27277bd5f5d985e10b20e7a9866d257082de7d5090e820b591a08c5803c4d19ea066d4b9424a0c7ca302ba02c97092ddc1a2ee20da8569cf8bb6842953f20e74c050b58b06ca77e2685ab4bf4155443472c18c127b4cd9673ea6ce4d031057d5fb487010ffad2eac1ce7c156e6968cb4a0e62987b9e29f1e925c65b194e655f7683bd8c5fe1639722b539110997ae8a877006ca70b71063d6196f1a68b915601ca4fccbf9b6d05cbb96e16d5f1b784f97cff53a205a0c23ec6fe74691fff48e94cd89181f0464c473500e12ae839f6d101f4c121aa2ba3d8cb261b3ade4fcd91dc28b31011a7a87fe9fc1c3f8f43dcaf720dba90382f916fe7f7514a430409f6eac47feecca1aa295b6f17dd7d2a11ace0d804c8204de01665333eb5fc6ace9d36578e431f319bb35d8b683b23d64c6093872fe5abdd947a5d7c70fe51118c2e598ca98bde2357d973dd9a3d50298ec5614f544746d67f10761575da0324bd7f6181ab916deeac2bd6738e991315e644d21f4bdbd3b0b13d8a5eda70caa09f12f9e45813f81d4a9d2904197ca1e48a46ae803049d3688b0cc8a70bc1955d17d628dadcdbb28f797db547bbebddc32d7a59c2e34c17aca3d66e872828482c1e1a1f994f6542d5ec52e909260ee985b83aa16fe93c83687899dbc67d033c098050f0cc54bc4337756b61fc74299819270df4a324766cbba041bb43c92d4d53a81c52335b44883c9f60614c7ca9c08d3a085d59d0ef44f9244711740151e3a644ffc6e2d2750f417ce0f977012fb2b582cff4376648191f861e1935c306d2a09ce38b511635c04e77f80b862b234852e740adafed50be4fa7a5bf1318b0f689ad415949ded50e754bad30eca3b072d88fc64c3aed6f5ab3335aac0b72a30e61387bc504f9fad33b44baadcc95bb2e7671a6f72f70d1742dcecb5e355ac42863c8702e9037a5fc0f747d173c5f87cfec1c101cd5d49e465c1c584151db52371af6938f6b062395e467fb2d4e9685dacbde6fb8aea9554bdf9df5c99828854c51e2892ef67aa65957598b53131ab308ece62e9b3b284a5d4053394488a829106c7043d1d30bb0094666bfd42858a2d25817d547be7f25762edb7df22270c17efd30f835848f04cb074f0a686755f34a935463b2e56560a8e18ee2763f27ab7900ebeeba9c307d2ba09879232382d542193596a40b4242f2593bc597bb8dea8f3a832ff9653df855c44bcd5053b93f3467f7edad22a5b56748001712d686003000aa3187ce6bddded31787a77d0e988d58b46dbb5ba49a55e3c81912ad7637aee6ccf30ef780ccbc0baf4743da227fac68a78222112354062b0f41518d9bd5fd9a24956335be9e7106c489f1dbc8e61745f4d469d8870bb41db72782c616a047b79c2e0fe1c736dcbffb757b52d36b23cb505883b7eb4a7767fa5094731a3c113f1a07100aaf3817fef74b0c48ce20fb98e580acc7318a7b9dc173d662bfda860046d0f7f4e14e93eb464b67fb6b7c8a1687556d092325dc3ab9342c6bbf98b1ce7f381031ca3bd25314c38e15b3eac62439eae4fe9f4bc373caa9e7fa255812a8c960844db9a299a7e050ff7c0c1a411a7c29fae00d47af8bdccaca55952df3fcbb971dd7cef4f73f9b157cc26bb220532eedf3c27ad20409a8e8578794c090cdbf9b4a18c668284467ad7d135bac19478ecb7d04b05a03d961c12b66ed106b0375f2c1b9de0bbf3b50a660bf8a3040ef55dacb58af76eda157e48adcfd2a687b9bd26b7489298b9b739c9660cbdf6c2a3a6f6aeeaefbf383064e27c2778f078b50a26c782c26b590c51223e6ef3a376e31ad6da4efabcda5a5e1535df22e77bfa0dec77fd883c093f6c40f1358a528433f9793c87d942a90823a8f8e1ee72cc3973e9a5a06290e3b8ec7b3dd5a15fe839100b1c7805bfeed651d1700b3c2360ce2c976d3b6acde2d0f24d081fe038a161b53c49ca9caac2d2bdaca95b62d41e2e33d8767103760f166eab7559df3a4e2de80f5bce44ca87e8753c28edc1e97823813e88ce807f5a8335fd9afd26423a5e45c8ddf131d5fe20d5f8c0ba68b3b04cd1aad64792d0de2fc6398390704e81639156f4ca84b2c0b1c8bbb7c5b83844cb9bdbcb0e44f54653537ffa17acd76b938ef1ac58e3ff186f24da007e35e611e04554f995ab5fd9183c1aec74a7f4af17ebe32d34cb79853aee1fc3a48e7bdb0465441cdbcee30a71cc51955e9ea87b43c2710fdf4d9f1b32662cf2d3de2f81ec74350f1fb02088dea2fb50305182ee6f76ce32d76ee282509ec0d6b194e8fa2e930f0ded3bffe2def597feb7d0c4d1be7ef20ea0bc2c1cb1f4ad5e48bf6badd52a2d07cae6bf513b1f9f00d88df10a42d50a4475c5d9485d5dbe008e5d52200aad4f2278e0aebd57d0df2eedaa83755dedcc318e5111920b48f327d1f3215008d0844d21575c00abb863fa0eb266e2bbb26f2d3cc1f4b371566f928b40cdae6d9c84b8442adfb41e4c829c991de069ede1670aebd5ebaf5d5eecddffaccf49572b02541256720a8485dfa85d47744df60a1c557af36309d9e421573edf07c0fc40fa8f5d87176fc521fa0517adaada4f892c4874e4c4f248b769aa7148224613879e2043fee7b5b876d5d447d89e9346a187c31dc51422fc638580e280fa02cdbad891e93339d1bfab7cd8e2e9b2883b15da159e90b1ee70ade19c34592e22b9879b8a50e157cbcd8244229539072b84909439c4a2c1c8bbe177a031186a9b1cf5a641752fd75fa569093bcba899287841dc4f39d7ff6e635592365b7aa6a4a3282076335254933c09ec2d4ec889d9ba4f8e641cd68a73a2938a2101abd9f0f06c5177fb4e99db8836cde3bb4d51a2889e59a98cae1be52f892b7ed82297aae688a04952f73624dc5f109c02980a667eb13b94c2fecf107dd8bfbb83aa5cd4b36372d2544f6a45f4f50ca5589d0a9309a4b2736efc180fc09d57e331b15f576c3095482416c4bf59b654abb466a14a8bdc378b49cb1c51743995c492d2ad616bb65bf61cdaa4534811395b91c81ce6e26dfa5b6752ae6ac22f63958b5690c1924cd6080b2bee6491602cc9b27b8d717112233c31532da8b7fe0540c30c78c08b2895d37d6d8001cd056b78f7e091d9b98869b99bcdb358e0ec88f1e6b22b2c4f9a066a4b1cae61b501683b27672bd5568429c08ff3305a47c74a63a098bb2a08d08566eaeb9a0c2b07f7a843c2800e521b070bf2e8ae1eceaef8b033ca814b7962bdf9e18ae62bc248ed46cf9b19343377f521bb66678701e3673fa93bff5d80b7e3f4094c9d43bb1437b4b127ead4102c84e5c5359d03784a63460a34c2de08aacfd3bdab7c18153b898307aa3c4b63345a498941691429578cbd854f52ca007441ca3bb1b86ec832c19915fa84b379feb2fa083029f7e13058a8bbdfa70c16990807f16649b2194822c6f784c780c509f0a03a098d40fa9bd7df9c207a479a6143feac6aa9273af7fb0929ce031b3e07acf777649c430675511e35c9c45383f2a6ff4a489a2c509b6aded1e162ca2989897cf6387f9c8c2dcaaa23e174a808190ae8114c71f8b450a6f6a10496e72c97189941da31fb86ee99b8493306c9987a1128a5383d2bdbd4f2e55867a862643fd110068fe4ef69af7042ff0c9abf08943c256dae94aaf72fe82ec1c552148b989f19579e4cd0876192dbdc0f76c2f616fed1ba2ad8d7d36a1b710e7a46f437c410cce1654d50893d43dc4447bd17e17d85a2953ac9b09725b3e66815995c1645d36b564a85345ecfdeac902b99fd9df5e63366fada66ed098f52ffa1affa8d646432ea70645e196ff35d17d68ab4c8958136fe97a4df9db8159799d9818c35d7e35881576fb346c7113175fd911eafb08dd438408263425d2ae853ed49a35977b453d5d41d38ada1902905d02c81dfc9b62c917d6cdd36f83c83dd4b3509c5639f9bce4197b2a70c2753bf682b30b344ab4c50a0699306b182d4e517f5df7b9d9eb66b902bb73e3db496ffec3a67bc46e77391519e999689b59192e8a75b226498bcfab46d4a8b63ddc03662c7cd20b00e1581e716cd4906de8eef168fcecaae4559b1486ad349c38a65444bd39359a0d22c6c031ea05226588225c767421c6bbc1d853abbcf23c152669230931a51661cd8db3b1744dd457f115f4230be44f2cfa99f72fa69331f97f2a53ac385774662afd6458fd923617a7dd0cdd426269b6b9450d8c1c98497321759a3063dd22f593b6bd1accbbed2a6ebd1294356105e8c5eacecb5cc8c880422c0f78ffd1f9f388c4bebe133a146194ef4ec5a8a7a69c0bc1b6f8cba9542bcd2525574efdfd0394ddb69f93995bcb2e5bf0319f3b7f9be8e66df9850ba5505e1fc00c1e2fd9b15b192316178d680d47d01d7f736c6c5658ac7f8aa76ee61669f4e43eb953289cefc1be5586052491d6446a1582f656cf82da1972b4e1b25996700f617f47ae890e80f33e85186bfb18b19c30acd1764f1a1723afd320470e1f436717c43c73d4c288369416b470558a393e4bbe63bbda48a07f1523f03d9176bb98e7615e0037db1319509c0c37a5087018a0a3e5420d0e3a0c1e0a106bb475103ec2ce255cace3b59d8a5dd13d551c84dd95ad82136fdb4c767e9af37b43f45d8472f57f66b5a1cd4f7629d14cab86910d7da7193d1cae5db0cf29236feb36a01616c9efe325c860320a2f6c8e000c844f560303eaec68c9efcf909445f764f7d583622d367f36274e96edad4510688d24e0030b03fcd2ef7cc7862f39637dbe55bbade0e9e7b5e9bfe480a1b7eacaf4e12ef314576607efdf513059636d0df3c09ba352bebe50e149d290329432344f184fec9011073ceb3d0f943927d7c70a04bd35db0c2ac7d37d83b99a9f66b93e38ff4e72ea267447dbcab07e7f2b95534a6b19564e421229980200d38499d6a9cc7747221e24631ff14118445fbbb18a7ed792e41ef5fd6dbf065cebaa46fbf709bffb6520753916a2763d15e01c438ca96576cf4e729752fd59458d6bab655cdbcc74e611a7b35ee6ef6c07b1e71d44f611a5f09b838c51ff0beceec22d92f15287cbc76e2fff4aa3eedc7d7878d219bae3ecd2343559d4c2bfbdbff3708e1c6be61810b37f79c72ee6d87d793690299ca115bbad304d8ce18f83f1dc03862cec9066495d2efa976d2c8a3e26dd292e7183f2294769c74c7be84d723e1b3f509f248b4433562bcf1675bba952bcaf6c63425d960569246db92ea1491a4d3f6c5a13aaa53201d489a2fa8ef722342465c246a4d98c92cefecef2480374ad265d78fc490e2963d9e458842b529aa2eb59dcb579f44aebf41687ccdd651235a9b514569a42f5e3e6cfd8015fe41960889eb04a4ddc0095c1084c37de97b2237fdd196616016ab91df589b2cb30dd9a2c853c0557697010bf6e33b449704a44c6ed1c25ecf2aa469fd72274a173e42d6376c4bd264fde035b6852f3d7e960ade7b1d448decf9651439e9185e5d92fb9ba1c1559493b0c3787e4e37eb1bb2d66053f250ba3a0619d7635b5150853d612fbdb36524aff7037bea82ed03c2575895b5f8b8c38fd35fff18a5985305caf2fdffd87f5fda66d1ff5991d4e942ec6548a3fc2549a57c49285fb8497f54b6333fc8b0261655408f69526681de8cd9bc90cb538ddf6eaf0633890f0c194c3c03ea8589b955697d748e0b722f26369f32c5d27e67ef2fe780991f895651b6d34de048f9c79237fd93e720a05d5f6156228c816b7c43df08f0a29b846d2057a218273bb7500b88b22bbc3787cd6a65a92167f9389345fbb821f79cf40400358b5b5099268bc4cb09ef33ccb19b595dd25a85dd16a438c1d336213eaeb885a7b14e0bed6e0e228641867b247eac274a87a4a91e7cc20d56b80e465bdd2749d3bfe715edf8e3ecd88ed0f2a656e875ce66028988bcf78aebf3591dbfb451d4751e22abc3a968f1b4def88ddfa05d2f4f5d44e0dc38b724c14e1a54af8ae58a539fc6d0473fc0698db3c733ea24f85df64809e4571878ac8b93dd4ec254259b5bcb16d6cfb093b1ec0e0c7b59a5936a7b10b6ad1ef28edea66b7b497ba132c9bbb4d1781cf1f72c74c52ee3f5719603a690e0ab6cd4c0a764da1f3d9f0d17c47f8d483e2c4f2089484a4c94a63c39df5aacac523bb6fbc64b80cbb63e64ae59bb971ae5dab199c92aea21771dc28140bbfc8508683d2a8528ef9b5adf030fb383e4456292658c3efee8e6f0d720b3ef4bbbc0006ba3aafc8f8d10925a908ba88b958821a4fcfce02f784cd48dfbb01cf18160a2dba9522bfb88fbde44bfc304be6a78ca79c14c83f99c28c84b3c96078fdf7a6ddac822c3e3ded5fdea3b3e8004a25a73bca9e093020994afb2324c0eafa794013396d9330c970a8ebcad601c12b20441c92dc5bc0c1bb2aa294a244379fdc80b15e1bf6733f198feeb1fc1ac0e084a1db261cf594460dea2d5d55d3a217f835e466a7bef224f61170c7020932b5af0a6f9808b10e29c16ca35078929f53015ddde78e368b30f2da032a8d31720b017bc58f7504a4d30fe0be46435359d4cb1fd4a62bc4f805a81b8f984e6c1c06655d74e5e42f118736694d04ae2f7aafb406383b24e8c2e70e716aef6d8d014c0482318f1132fc6cff3acf3afe80287601555a8a27aad41dc3dcf6c0ded06e81bd9c85f2a49a095287b20b96af8a3cb0aeebe2098072b5809808e1954da5563a8aae7c249e9ea4988495ec6ea07837da0fbb50aab2e3f00734a1363cb8c915fcba3bb8983a68bf693c95cc73db512f9021d84b83479e47e252bfda9675cd5dbcdf7a94613c3ff17a43919bb582a18ce0def2c4367af977","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
