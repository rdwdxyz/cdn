<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cc410d355e6b8f68a18f4bc9d7362e9625296564573e075c4815941f8b827944fdabed8a695f51621efcb6e650393dd218251a4c79e4ab783b3fdf56c98083a1e2636c5b8650045b4b3612e8213b1f0aedafa5cc9621fe32285d2c0d129f320389dc68394d0ae87f7b578fb6b9bb177b6c0f0d9a4d8753dee0c5ac437dfbf9e684b5b6d38fe6fde3394bde11a6a95fae3679f03f46e789415f39a8529601d9db2c055bd6bc9c07c230c4c020bb98b90916ea38abbc24b41574c0fc78b03127d5f2450e5fb19e5a598b8b2be52833b4b1817c396a361b58d170312d9177107c844149c5558d17a2e2d807f399778059ac376f0bcf0f435576491a8e2debdcfcea8a42c727fc901a59264d36d5585bbf038b8b3ed5a3dd20eb1c053b38f34c9d0e327dbe39bbf77739c0735c160dfdf21ee9ff477988fc37f21b7edaba974501819f96f64832d4528caa41ca7a10ce77347f8791f3966a08fcf922cf87e4ea478a992195c12cc8f60c9d30988d5db5ca43388060a2770e0b85337d116fe4e4f71e2440f78176b3a2b3fc1d2b4880ee90d6f0525b57b3093b54026e415e14f9fb53e5d5a92464a822d7a9978b4f44fc1f259d9cc5b88cc3e4f06e115fecf74b2fa5640c48b48bdbc2dfc74ff4c003b1c2b5095849f1985d35480f1ecc65a49dfd7792249d0aea62763a3113d95ec558a1ef72eb1e68e12eb844ec43c4013d98d62faf40a7469119260762ad7ade843aba67c338d072e28027cebfd480dca7678a0ec80776fb02f1e1ec711edf11ded28d09d8be80b502e38247547a20ec2562ad4947dee2455dc745733b27317065358e0358e23856f5a4ccab899d7d46d1e957eab8eb14914664152b89b243d7f07212905c88e1bdae6aa3548e82731931c800ef41d18041fc68782f601c5ad64a22bedc1ad85599edfe9ec742f647e65d60b8f66ee747871a529aba2b7cbe9e3151e71c155ae659c067761e7bcd5192986a8f7efeced6abad43c7b64c10d9d9f85c809573fffdf14599248cbf603d9ff0374d6cef509b2bc8934037961bb84d9743ebf4aa0adcf9ea44ac92e4252306780198ff10077475ff851a00d0fedee7223cb2b8f2ac295e7bf2fe5bee8bbb435cc4dea77b3fecab2b0e7384274dfeaacee5ebd6ea9a7dbc161ebc35cdce90f9d29b45994429a0e6b88adcb6238ec4b67724fd5fd9af959f2e735964f620d06e77761ee781a391196c10d95edcd177405712c0f5519643950413624b4c01a60e18530fce081e3935f92ab68f748bf221a6773ff2741e81b6bea7e31e7332d7a17ef50d0a24d0eca7299d47397322c1da6b870a3dc9a3e4ca8a92eaf5412c29329e80f66eb4b6e52e2c995008d62b18d0dc53d9fcf6adcb3c7041034132f8d67ec7d845c899d1ff85d82a7709e7388aeeff5d93799da3d550ed4a9b7ca95d6168bae9df0cbe982454ab8f4be2fe9f040e407a9cfc6afd96477a2b58b3d3641c5932f6e91584606ce96e3140e4f4a95fb5f7c1342a37913b190b53d2ad630c1c826d0bedeec39f13c3c675027e0bfe67f1f90316d958f8aa7d26e256e8810c7b585e5d545e9526d2fe6d0faf8fbe59d5f51a9b6de2396b02120876d45b30920df8586db0315945c63012fe36a0faa0d87b797246bd28d1691d046cfad178562bee2e903787c35563a1f6c71522c654702cd71c8f0b85fe7d91ac19217acf72782ee6f704e9a52e0a4f29663b9ba2923ad47071491a25eaf38707626393a721f05b0e8e8362be25384afd715931055fff808771645bec016f940a09e630713619ca073c6d25718e4f2602d17129f57bdf8e5f6cd2fb235f80f52f606f1bcd5bb601aeba2cc516a55dbba0f3e753418e242d71e180d13b529c561558b2492442a6f748335204d899d33eabc613e1414799ed769e8e1dc9e386bb6b645b11c60c9ebae685133a4e6a6bdb34562aa5fe74ac47e30b9eea70820faeac72f52c12cde9216fbdae5a7082909c3658ec0546b8d4170007d7431f06a40605442255122ab84f12790a3452f8b5e27db7138b115a5220790d41ed350996a84722d8a49f3cef42ddd232e8c3fd8edbcb1f73d3f96b9b6ababbb4a25b40d3a34e7ef7011f00350c9509680fec47bba4ddb6b9cc87141a5526defba4b5a7795ae2f8ac56762dc454b2b254677ff2f06b5d45274f1ab533fa14c06a1778efb9d54c74456ecb7c5460d848ab2d456903721aa821cb8c2c2ebae5841bbdd489e9f110f3ca06f946a071d489837a5cf3dc770d349c7f42ef30fda8bffc0746239e72526b5546eae1eba8a9d21bd87326f41e6246508df43ceae0fb3275f52a72ba2c4ffd370709d1cdffbe53fbc68896282623e7502d6981c184e9789b6dc67cbb94e450097434db54b8da3f273d5a1fa013afdc097f2598dcfb08e84736d7c23c17140b03c1ccf5407fdd278a6aba4fb52962adc03d0d32d0aa6b5b811782bc82088b07f3f465c0f965ad2a8b4e6df4b8020aae7864bc1b5324cdc5bfe2d3350458523d6a691817a9a2d0cbf3181fd357094e211252a82a40a3d4c5cf9fd8b9ed328ceb8e7ed9913175f54e8dbfbb42c15126e1b597c25bbb20a9a535f7039d4c46b4312bbdb343c3511c3a9bcc8e294bea46f4edac3daff9f3feff8eaa0d12e56168eeceb57fe78997e667eb3fa88609b93aeddc6fa42a272f26df0199c5be13f40396463f8aa0b2dff5b3b2990fae863c2dd10f2f342ca789ab9ec79e5e7333bb6860111603a609447752b90819bf9ecd5b78d469151db6d78481a97c7aabd2c7ecd38b5a79394dd1026e276de22b213cb10d70706f54222240b250447e94bf1b829d4715757626f99ea5ee708b2c08c84d3ae2e95135f44e5b055e77d9a8e75275cc129742c27a38cc85a3a552244b35b442ecf04d14bee114548afc24612d9bd8ed34a254fdd97bead72dab1847ef06f1840799e910a147b512ffacdd764c617d9b1b93500f53ec06b3ff67b5a3245e9c1329d01a8fd3c9c99243a7e3a7e851cd3fc940ce6632e89f74d5ade9f9e885e4357cb5284f3bbe607b55d32d25cba02018855c57fc6bf5f63655ccdb72ee0ecc231e7ca0791d8fab3dc5874565bfd20a418f47a0a7add74214ec76c47f72a543d3d519c464a265f0c25768db4693af685fa757837d9a68caf09830cefecb1d075fa37176aa5ff30e396fb34f5852664eeb2524e7be679eddbf726835ae09c476daa99796905e9b43f358addb397dde38eff9e5e9fce788003398de4c1276ac4f512fa0a12e5a0f7112ee2a47ad6764425320acaa45c46d73c62abf339e802a4064702a3b5a66705ace2059bfe09d5af74cf21070550ad9a250176483c9a63646570af354ee9fa74218164d7576ca1d1bb2d4de5ff64218b48401d14f60327b1e1d17c3170a5581a712ae7ff7594b955cd4ca8b7c8cefe267a60b3317fbb835d42611404d0e52588931f3bf4eb7d8bb81b0c6a70bb86537983b6de14d9631d5067a2c2844e1e18a832b0f9b28a41e86aed48f9322c27e84b0299dc1f327238cbfef2040754e3bd2b6def9e91ebd2d606bf21d91521aa34c4ff27a1a2ba611791b21a84ef638424782940b32970be575e66962e5ed972ff2496b8d25b0a1d138fbbd9373e8dc91271815196f1336f3c785dced8daa8ce439ec75059f6b64cf038aa6997d71da5586e6af8241ebd6507ed49733d33b3648efe327750b868f2c40969947a482af137a38c95c4694d84cc7199b916ddbeae42f16c51cba79883f4de92e9922e7a2c45866dc944d48a5fea6c7751b9e96b0ee28b68a74650aed3ab4e2ee413f2b296ff0d237cd160166ea541d9bca9d18e25ee6a05f2faecb85e00f126a30dab613482565c57d8ddb76b12562fa880269496ed10e15fa440b622085e2a273f2a09cc716f868dabb0d6ffa4d359abce3e768c27138f5e34bb16e55eb11d82f6345458b510c6f6ff149d800cad9e96189376c770fdfc5ea594ef47fc4b56b34f0451b6193a341a2fa1fc3edbd1cdfa3c69c7eecdc1dbd8b0b6dbddd948aec517b87610d3d1f1eaf85dd9613992eebb486e4234002be2bcf4da33344246eb38f39f7ae6cfa0b6298e01e947f0d2952d29800f84460f78d1fc56ba594998bda9d1eb0cf80cdb42eed3d10a25b32bd87acb42cd3b91976d8523aff6afb4f709f00c071f1358f570da2cc565c60d197e8592fcca4f020169f9245a1e708fd77df35333247898009c01702ed601f6035303168bb66e2e5b6a7cdbac567fd4811b48a4e679262aac4fa4d1c6aefcff85f1fcc32ce927c5c86568909751ba6180bd58a5701ca4dd3ad6b3066663e586ae17bc7297a0ef1741a986044615d632445bf914d8df5f997f47a058854f28e6e6e363d482b0a0368d52db24f2f19dd84f65149b82f1c5b9f5adbb6fdc11faba34efe990b08149b633bd7fb06fa0b1e4cc1f02596e9fb29a60f9af50ea76e54fe5f29198a5e4f82392d135993c649c767dfe6d86b93b42b72df60957f01f4d617587784f2571be10bbde4a1548c7008cdecc52c6719406c135a82503dd35ef42e04dfcb93d67081a5984f98e45edecfc28d2b4228d4a7e388c891622d9d823fe243bfd21773e9c9e3a76a4a889da25b971636395024f03192451b2e803d867c16c0898dd7654e092b9d87d25c997ae1c1901bf565440cda27e825fa5d3d54579b646738664a5f9f40c2b51e9da8d0402ecd492fa35edcd54150805f74ec76464281eb387a1e3dbc48398b046f732db91dd233fe22eb5abef9bad8e3e6b70c5e0fdd9dc256d476c6a68cfe170d72bc56d5950a171d14fd6bb75ccde24af33ccf02d18fcf6907d09403e7f34bc67d9780a16b14a136dc525af0e549c95d5b6ae6937e43ccbd71f4ec2338f2c6debd91732952de031e692388f73ae7b3f4b4965b2ca09bcb2a572c315a5b2e32589561730670822c2c72b41d46a0bfde3fcd3d99bc1f0f1468a7afc2569c2479aaa7df0e7e0cc0647c150362d86c4078b5104202cd7091580fc774a928ffe8cef91eec2ed9b73e37bd0930b20f0dc98aa32adb30019cad3d2f274698c760ca2c2428e7dd26c7ed3b406ce8b07abc8fefd2aefecef9cb188b56968ef41f718a0612d42ec433e42d0c2aac5a5598d142a0c00f6f68d9de82ca826e948dddd3ffc3e1fdf1a6e80230a6a4fb114ff48ced2c87d64e071b01ab9bdef7154ab70a5d0b74174182a3c777da554fbca34466cd4f57e8f07b61403c8b7a1c139b2abe4f38c581086dd2253a4df617d00e05ffe124c004170a2a54c379c31e441aa623f49fb8d9ffa7d5ea1e325c7bec2987d997db7bdc31b04683046a405729de4a4f4df37480d68ca395c44ec521602169564168551d3004ee0b4f8ec9f48ea59bbe8dfabdb191904c5b23b665674d9dc5659cee4d12a950668df91c2e8cb4fe37d81e5e770570d2720845f253adce1b3291e160a5ff10a418986ba3993f9e349127f971bd5fdcf49c42a4db97edc7cc41ad59fc0abf5045648fa2337ac7ef3a02abc2f1db2f502cb73bd66fc9de8a81c7fbb63c7b30ab15cdbc4b2265b836fbdf191173cb7abfb7518c45c210ba94599fc126ce126df8816dda8c0e212b106e1988e90a43583f961abfd8a47302041bfb2fb1179b6cc96b21082ef7a60604165b37e94bc2d7c28f82b92ccee86d3faf98caf68364047d12852f2dcb2277b28b0ebaac254ca7632777d0ca74cd279e745ea0e697845fef1bbf3955ed67f16e86c92896ef2764a55b2c35f91b85776c9ba6f2c7be1f0bbe4a990975ee4f6e11822f5ab0fd1bddc3e6d3ab848f05cb0a4fb600ed22cb5221b0af6576d90ca7784493d17a16fced0a7d51c27c7f21f26d9595e5ee18604586a547dcd1353dafab2ef3234f5756d943bf0c6b94eeb393f9755ae04e03e483664a63ef1b0fdcb491ad4996333fa7c41d6ef231afb422c64b19752fdc49aa64a28099ba568cb201250073286ef8c091a7e996539072866bccf7b19b97b6c8be038f417f138f3e7a11fa33adc425ab4b94dd466a06372bbd36a245c44086dc3716c3cee0c35c78d7ec601787a12c1705c61532d43c56cd7dc1e683e26664430c044b5bc6283e67ba3436d53e9e4f4e5f806b10c3b0659c9bb1ddddd5f8266cc5de89ef667ff7d3559186b1e1af09dbf6a8e5f0c934a046accd7ecb8ef97ff03081b62d3f30b3d26a7e20c6b91e586ef977a2e39c332589a49d2da94ed9de197d2616aa68eb35dea3bf0f24239bd3980837464e843a38cd12b05c087a35babae34c8ae0d4dd98a2daa35eb22d05e34b06d7bea816ce672bcccd26fd69634d8fdd931c91e11f43d8021077f00503e47818f54cf9e482d14f56fa9a5907d732af6dcc7b7d66cd449721f146fe9ba7116a4b40a14a25b195984aa528cf430fe71eae3f143d2984b6142a53771659ffcb5bfcd222f6bffb571181beef04d55ec2a46b53367b248cfd0f624f1d814f03423de7cf4085f7d922311e12b1189dbc07845d581189ddac0015d524ecb0ea2d02fdb301ac8789a6280a1c8f71e35ad9d83d67d0de45b0dacc75d24e61efc84cd4c44feed8b40f0d2f5529606caae4ac67a3e4df368868948246d89e63f27ff75d875bfb8f7047bf239cbd88561e586d8c52e5598348dab418b221e62f820318c8a769b5af47e0b71c79a038c4b260b05856b73cd4ce6dfe2c30d1b2391459ad35b02aedfd9c8fe3b645f21644efcf9cd36f735a46825ae8c96228d57dfa8e30fc378f3e63f05cc9a1689295bb11bd34703192ae8f188e000a845eff8cfda241c3923c4863a345513ceeae3dff898776fe4366e2de34be0bc1778dfab2c636345d34357810a0cc41c325e1b35c4bd35612f3d52cfcb375f0a18a6000f7a667e68070f77d157c3861c292635985cb3fcf2b23081dee9d160b7374c71701b6505467af470e01ca287f8cbee02d5667f8d1fc8b40626f3377241831e6788585f578fe61acb2937bef02603443e918f31fbfc02dd5396ef984eae89c237beac36efee1c7fa0ee0dc01db4cffaf003e84168b645f22acd7f7a3d7373ab8c1fc146dd22b54f3767120423f3c38955492705ac0ab8a817bf9a5a8f46b277c96044dcb2436dd68705302ea4671b432b7ea765da309f29a9a0c174009521213481787c75c10be0cfe0c3f9f9755fe7a7a88ac168c7b2a36d14b57a24e5be02af92299fce493fd492709d8ff3cbf570d4909458337107c2e8dc12a11ba83f90355dbf9ee854fb3b6ad4d4d2d04a9586cf873021f503054e8054253c4a9691f2a3762e972ccea4b8afb42f21048fb8bd9d5c3a18e43637dcf0021d1079e71725717ab4e487cf80091c5772ce520b926e8b5d47c4683a0efbe9cc002b8525aa2f62d69dfd410ac19c932bc16a86a6eeef1cb95ab8242c26ad9fdfafe1ca94ed7648f80288075a1271cec954035ef9f5e91368b036d86fb9c486f1c9700aaf26f2363822335f81a2bc72bc899237b3f039384128cba588e0cbf0d454325de76d7b933ae195e54da1c30fc96d957cf3621dc43e43579437e768a31c04bb5b862864501b0b96a669a65bd8852da111838d0057f18479416ceb877309ce255743aa59b3ce2e8837b66e2dee21017e307763631f7821bd496d0673d03613f2742090338a6a20b2c1d03f59c4a0bf6e42aa2d76139fe4a35a007b8b8ec7ee2d1f90679c6b57b37884e59bfee43f132fe9635fc79f984d4252ddb954110447bad2905295eadc3c569834e6eb749d8716bc64c2d7779b4c5aabfec48fc621211b6e33a54990e76d01fcca97c8d99ec1153077b0f59f5d7d848d20b5f091e09d0fdb7c017c248c38c431ef7e77aaa193d570f0c24af1f957f204a73601da63b7363d0c66a2f8fae2135e92dd5b5da9cf58f647d019a3b6dac7f802440a1c02315fab376a4651f604309a0011f4294de9657c813dc4ef02851f1280354a69df181414c80f9e9ab3a7d945cc093c528c742711d1df9072df62f9fd89d2d7da1cc0d2893adcab1f18112d42cfc475ca2c2b0a74abe5bf1b1792fccc376b035db32bfc764b731a32719437136289e81e0c20c778672bdd307f39008cf381a8a2225f2e50ca22828532f9491107a4c955a773ca1c5fca25d489810df7ede765c1a7ac6a6d791c92d8b955ce410f27c7e3ef9e5e761c93c4f31230d31a2530c3265419030fdffb540bdf4dac08d77fc0e900961f817b3a6dac9b3a8dd5992cb3cea7cd866cecb53cf5e063ded70a656a7f1128966ab79e44fb4d4e364e98243be11ccf727982909872cd15ee104275c55f7bc6a0eca103edd7d51d510530b120607db7d9bbbee4cfda6b05e37897590564799ca2bcf803d8a4523ba038da5fead88e573089eccfe445b2a8a1b82c54f62600fb2980a62895c8e031a36f14fb4965d98244fcea1ccc11ff390a1467dcee84037eb65da79b2ace820348facd0540badaf4be4e31811781e328fef752e6208f3df7ec3ef6430da610f1365134290c13ba2e9446cb4c2e40c6df4570997d4a67e973221a434116f0658b39dbe2a68d91c256904f2f1bebc86317e18f441e32dfe2e944b725c4448829b6033b6b9d834c601bf7524a7c708517e59639c5eb3d2b9272dfc0cfaf320a1266ac4e73761ffde8dc7b81e778081c4b59ae81b6fb727c2f078b24d4012bff1515c4ba520eead3ab3ceb183d482a1ddda3b87bf735c613fc0f6a524fa13b645e11592f6a931eba47964248023448a10399ed8d9c33d9d08e9874cc811b16304b60c210e31dd1e073a7b15b6e3a5318d4c3a43ae1e5b55ba2a70442a82be37317697bda0c225fb0492bdc800f773c3b0f2fcaa69f8ddbdcd468db7b556e67ffffd9578f88621b3c4fffe05c3ca9067ec5ee9887471d868ab1c16a75a3815ed408e9042f5a867c33766f9f56a2213ac83573263d738f46ad0f4810d88e8364bde52a79f595f865ce82eeb4eee8e2dcccec3b0d25948379bf23ea1325ea28cd76e0700976ba9f45344192d65de41aa11f94c1d53b09bbe13926122f63b165b15d1397e03e34c6c93c731c171ed9559a0eecbf608ff65205dc02a9333fd260a7bbb05cfbb0104104f90a8094147d678bf1de407ea5964639b0218715765a7f4dd45923aebf55759b9f87d18d08b9fa7f7900c92f15d2a15a543095b4a603cdeddbc1b44b55f77a6e7ed93abf5effb0209c0252ca272985b316edf8e5e148a83b1b32e0aa0007a94424262d1137079c1b388f8d164b7e527d1d3515c1ae41f09858ec3dad8aef736b2a4ba9c819ee346cf3ec924c0facff8af38753b4b158ab9f7c6ed042ef44bf12b9c08aeb6a72496cd2f355e6cd34b3db3cfea3d1d6f7975870aeee6b4f46384d37e6b58003c9c8b404f95449e03cfb60563e7e073ea8c5ebd29a42c8266c0f3cc418d083c7e1a4f7f5cde9c6d776df10de282a7794c49d0691ef63dc247948cb16556d314de0abbb53c7e98e9ecf3597ecd08a424144f6fb500e7a1b0158158d4b7720c50750bb0daf69456a2b535139e479d042b90fb4aa0448924f70770416edd8767677f8f036870b68d1d19e974f6b6f3839ca0ecc01b46c960017a4bb53300f1f52db894bb70f7322100401a6096c20093adc053671ebb17bb350c1a1a397c06340e325f2bd09695a79f97ec0e618b80ebfdb0dfaabe8e34fc658407e5a1ad0b59b9b468b25ebfedf08409c1445a635683e886b7013b7078b00ca96c57e7fa3f5829680b7b89598b2437d1e30e5a474d392de386a4edc825087777982c5cca74ba4bf7b60c95c476e9f8e86488965aef8fa4d8ad35fd208b980798df5c78cca3359835109dde92358990c825c5a8564fd18ef925d6df94ed38010d7c57c99dbb10bf29d68942490cf26e10d3981f4e2384fdf67a12b6e10fbbbd2ed382edf07409d8e8a85b623d8c80c73c1f4e375d3d43d138007c872d4f63fa696433a8e477e9bd8a24d2d4957fc274af0fc0c673e3336e79866a53ef470ef713c078e49898054d91171f8916a83bc25058b209c6d1c167988304d5719eaf0b7cc06435deee73c3721c0da5e7b834b4226e42c2333389bf5388fd6d8550422e4f149c4287cf129038730c75c5474c3baf365897fedfd4e76550b48f74dae7bcbce5b4fcb76ac763f862cb2678eab8716bfe8773089fbe0ad4a372f35b76aef655bef52ac717aa779622eb07361ab4684540ce2d9507ab3703bf21a36d7a8d4b5e622741655c5462453e60aff0b062ad799ff573449a98ad7a777290ffe42297a9608358616ca82a48ff4cb77817d087160b30d96615b0119568316a0813b3d26c4b4f34cb73dc8af09c9069c2ee973ad7fea3a88b28a95f8ecbd774b1cd54ca6aaae6375aba6412414e3c6a2937183cb7f1776d283569c26eae7e6c480e21988ca2611a4a58d2cf0a357fc472cd1bac783bb790b6b07c7f825dbe195b1a8d2cb16712b91f00545ceac7f3be325f463c979aaf140d524afdf1c5b1a9547768ac616be1acbbbd009939e296448f3510cda5345762810e033206961f7e9b32484f6d73f93467310d7d337ba4d00983ca0340b5b147bd294f1ab462065be65ddf218003d7a14efd840adc35d2d3d02ee7227b331c90abc97a057d91a1df060ce27deb5dd0bf0b9699d98c3eff0b699afb8847021a4ab5a566b000668af23451a92e7abf5d0786c91d74d2c7353e62e1248f4b0123a6e055e12da1550ffe7e0fd84d943cedb5c1a1968802768f22ee37b938d733817a10b3914c401e1c212400f11094f4bebd0cddf6c25ceb1a705578a802156dcdeb7609b9e675987300dc7bc71ce37bba66cdb31c4e86ef821a24c4a429029b8b6e18e965ca72e42419e0129206d016294668c128e61b1734d86d0bf2e2538952e3c339ef9483aeabc5e1bbd359c4d98af296f0ca2bda0c9a636c818190d0ba8dbbc51c0a8a8a54fdafb4b35445d1aa49f7af83da3c84e5452ee388fa99eb3fb4cf28a9e0370433b870822f26725ba016baa4c4cfa593b3c388f960bbb9a11b537435195d6daf527795f85b2311673d5aa48bac58a00b780ea51fb1f1c7bbf2df50d91d17d4fbecc34d740e40fd1297ed3576720d7a6bae6d2a382066f928c90ffe4e09e158953fc2a811d45bc8d8fa4cfe39a0cd0bc784d9f43ccbe501baf9bcc61ea8a862db78b4164f9e24652b7edd0c9bb36764b65a1fb4edf8d462dd4d622b2e4582588fa9a85f2c145219c87f90e4c03a9f0ecc55af23aca01985b7fd6da91e259234d27ea80331b76b8bd1655bc84b22ec78201399d18c96005cfcb56e9a628125dea6aebd5c10c77a42f25bd1cc04530d639c77068d30e6e81a4a4e583efa212fe3f68727e31cd4df036947e7658de1c7f55ae1cdbe357661184fe5f32c1a7b6bf003c96325d99844e66c30311883b921ce5e501ed9be218598ba600e17bb3ae2b9b8ea3a1ceaaadf3e27ae99fe39fafe8627d2e6399b3def067b3d4c4b2aebeb3eb1782b853a04f922dd446fa4af1ce63fefaf3d687754ea4933da4b2f96439fdee9870232a9f756c4916a2d1672c46251b710a595e9b0590e527b1d8f9cbc3bfa3672609e43b42a88aabb309a4ca6069428e7193dd3b2a88e77d4090dff5117859a6a82515e01d2c919f5425d51ced4e06fd501350ea7f8c5fa91163c76917b51ad9906f5e5a60f365d68f57127188cef86dd23ea2e332ed2add2a635cd275eedfd8b3229eb5bc524738fdfcc6d00cf42d0ce854c4e2a04bcfa70e784152d449da5f2911ab112a0b75a0ba55014760572e976b97b49b40deda1a5c14ef103240584e8399335f2edf1058e8b68f0ddad3b4c7e8aeb36ec26b0f03649a31133f749f52c16ee84e71fb2d7137466881f12c43d7c73fefc8336298fb80f5dbc790943dc81475f2dde931237d8186d578f0b10f7d69c3587e76db4878f638bb34afff1b837ccc969d3ea5705026d45193f65567520f773b156d712fdade14a2b3613801940f5c500e34bf557f8590c8e28e23a092abb0ba128be390aceae650c835353ad8eb46dab98098f3621aac6f42fabab5654cbde24cecf8cace196f5f754949f6149e2fc6a1c0363d84134e1e3b80820cda6da9a772222e5b641ca80d62170528ba72fb7cfba5f6918921d849722f1a16bf0a6bedabb3986bbd597507c63c5ad7a068575e6c1fd89c75d849ecd3347df311fe2d03b841cca36b1722c097145ecdc19ad65f3e6501bc55480b6cdc337991293f4078cf8b12a102e2f144376331e9db7b58ac38e272a2d05e151faf10f7420245ec68b1e446ed4e5e8c28f5f1234e1daaa9f84671c2a169c5fcafafff76d556d9a04ea1b3e867cf6c1cc581d67cdb37dc7fcf1e19c7a79efb23ab3a0bf4c08c7fe72803e656c8d46922f9ed59ec7761c95d0c23042c5c9dd349d1771541bad9a0c6e08862aeacdf5bb169606a5bb89441c8f07269b312c9f63170562f7f3ff1697e012d1bc943e4dcbba8ae66d4ff8d6ec3dc7f0d6c0f5c0c23b0a0fd354810446b1fe964d5927bdbef04644b36c8a188abf5f9742283537102e4e1d29b872d6f573c109eaa6a681ce9b241d5fafc451a0ef81a0e0f2e6cab54df8491e9a59f3aa191549a8e0727fa383a0f139f8be151e9d1d1e86e45e40b45ec5196288bcaa4ca596bff91d7b5949cbe1d428c0ca1637beff1bc393d36fa0f105f5441d748647219b0818d05bbae7b7126f63a77a780132cd1c4c094e92b2db87e5e8335eda70bd969d23d36b875bd783a8ac72e38a91ac25abae4a6c6a789aea653f8b876d61b0ec0d1b107abd0654c322b9806629f4b948c7f3ef03b76d2bca534730673f91a36fde1f9e0e27813dcbe2c07ebb0897dbcfe63076d114b17db737df078017da59eaa9298bb5fbadc58d3294348ebacf69c747318b1ee68ff8e13e288c2dd8811e9f45be416f48728f43b2eee5d9caf4c2e4f61053c2cea8235176214a5618682143705ba112fbf5fe411224bf8d224b3b89502762cd415c1bffec9e5a9f9b1bb88eacde96b83c843266e58c2dcdb96f1b30d4b55285bf871bcf1f3c061fe60c3a336f3c236b96dd68d1a7301cd5b0d334c16c89c896551969289d8db045e94fbb7065569da5787c17848eaf123cb456fe09ef2c36fe4c792d9623d9efcc0eaf88843808838e366b0306459a220fe92d8da680f5401b2d1b3bbdd1fa7ebd93675fb116271800edc7cb6c773439332b232aa896cf12d27196a1c6b3810a7c7da00734c671cea47a81e47c7f91870dff6b545a1843db03325e9aaf82787341333ae7a0fc60793f665d8054533ec12555225efd6edb0534ebe8399130e386e1f79e6ec7395022d29702d5df393394c42b7f13838eb975fd5fdb20ba5b2244ff018d9feac204be85c69ddcd6feeaf25e0af68fcc69a47796f86ef6bcb3b928ce3ab56a9ed5597eab3987347f845795d9db7810e48f655c2a327b3168aa36aab902ac69422947ff473cfadb9aee00d3197a2f2e2e446f9fbbacf985d7ccfd75e267951f7c90f8690a78e2686fdead20fdf12031adf53d1f0ee79a25cec63baf24953bb981f3a8c62dcca84924a104c125a46303311b4a55e2960674df9a55536b9b4a20fa521f704b2444a7fee64b1f1f0fce0ba072c131363084ff342a6c7ab4a0c7808a1f5b771376afc05f39216d8eec1bb49645daaa2dc107305d204323ca4b7dc8d72d72b662e9ca0dc739d9ce432adfeb2d0e68cf85620f251e7ac25f7d2e5e9985a97a7b0c4536144e8665cd3f9884f673771670fb397b4f4fb2678bcb1777f3e6bae5c57e1d5347912bb9e707c6ae7c237a6fd4dae54d5adf9e3e2ee02d77ba1d717f9efcf1e494318efa04511bdf6a413a03dd26c6ad5b09e7046e07ebf03445b38fa025376fad69c3f2f03a577ac0c4fa7ee63c70e8547b01b5b7ea56ae5facfd61c144b966024e33fcba14d3b9d6070dbd18d4df4883c0e582da4e6541f87d9ecae9012571bdd7d4d608cc41b536e3cd12357d8af6da8831084b3e530650026a94da403afdf887baf8b93f1f5c24731802a5f39f6573cdbc51336648bb628a3d877959f13c164aa651bb3f97777dba45cd77565823a3f2b7228327ed145255b22fd44bceb377eeeead9c9f979ef827807001431c6e1fd31ed843bb1fa77b5da04007beb9755ea57f10ac5e57994fe01132e25d58f99d914154ac903aa3d7f4cf5d72e24a2226cab7d95b6e40207c0ef2bb71130369da24e58b1aee987e69bcc649960fff2b6bbb3b0c3cbfbbd53b02ed1b38d94438d47309be35677208cf641266f2363783fb6512ef7d5078bc68e27e2ae50b15eaf88780365d0cad8bfa9fb02d059645a6e8083a57e4b0e0bb62b59f9c60a96c7e0a165f885ecf922f3bd1e912d1d078f859012c281a77ba3265b6959805e79d00d4d6b588cd4a6753b9bbdbb0baa708f7c851ebbe86f817ff3b3363cc1273dc5038772458a27713fec8027e2dd0c45ed6e9b824ecebfabdf89265998e75fe268857b6ac7ccd3fa75cec5ca12253329949fabefdf6bb1bf699279e1ef4ae6e489977face8220a648df65abe8e5cc9ff947bf30c943cb2f904393ff5993771d6abafccc831abe44d00f84a45f5f6a6f72ee7892cacfcb90ec042592fe5811ccd7dc21b907bd83fce85d2cbb1b2d05da129a2c6f3c4132b0e108fd439ede762e4f9bb1167bb07f38c850c9d4e0a7b92765921e563c23a213dc76751f749bc820d16a2eb5d48086f5b0e086da81957be886aaf492c3de6b8b9f08b03e1c3328e27a44bb95907e0d1c24c63a3a5956cd4e7ed975ce4cf79e5524e859bc3fdf0287689e6f761eb094945856df1b71c6b166edd5ce896662bbb3523e12f4bc8dd9c95398f99b35a6e17520c648e2be765d7b050a3f136042f07d1931ec1b23aa987361c0313d75a6beb2d0085eb01fc3b858ec51c1fcf01b9476b3ebb68bf814954d19b3efab936a0a3071bbcc5b2591782009ac8fd005b2abcf916cb01e769a2492112e7ae4862a842b9aa39e45dfc7440bceea888da7dcc2c3f9b28d54d838a9db41382485743096618515862fa77637ed1b8ee005249052a57d090cc800c95d2e3c9ba043e241c5cba6f7d17d99219801f6cbb3cda354093bc75c4022d12df63cf8b2c2cebb43ef937d2113d811518eb7ab5884704cfc01eedf4e620c428f586678e3a7f4241fde665385ac395d6424d48b905342c428f4c6fd21ad9a675322210180efe262280c7c509d7b1f39782949141ab3c879294a428e59d1a4bf01e46fc4dc591a3a3f84b6dd03073882305030dbf26f05d7477a967b28322ef95cde919076e3361824d09403478de3dde780328bcac456a1d734231bf3326db4d80bf6669c31bdc126aef5075dc8b045c42efbab4701aaf7c0b8ab84ff0703e119adabb894d7a7ff9668f238fcfd8752ecd5b7d78aebb10e8af6455130e8fb220399e77914227f20706f9a2bf31931dddb28abd8135c07a3ebff296ee0e41ba751311ac1d886d56feb748d47e50c8237b0ebfe9c22d10133f1bec0fbc9f99eb4e195778e182da573b41d93fa2cd764c19d2e05f7c94abc0acee705a74e91f679dfefa64d707083c5b23ad7e8e357f3d629a28804e274fd852e6f92201733af32cd5453b1de4f68ee59dbae30c27f4f080332b37d6f744d4582be6a7a1538fd53a3e6a02473791be0c88a8278ae1929568088a81fc69f5710620b042a62ebcee52b69d6b0dd657eb16c0649725b88fb2e42064955fc051b82a930c86e940903e363b95671819fac41232f0bc3b09816feb2f678ceefb8e17cef512ef923ae12d4fd56306b8055d508f8b2c5bc28fff7b838556ea0c1eaa9c5402c96d3bbca26805988ad2514c43f573c9541c26b3cacf1212c4536a72e49c88557fd4530f680895a818ea231764534465f7a3d0141f38420d32aa3a77ad19f8f84195c8398c3b06d95145b7a35ef89501715f4c1116700c42f35b33cdb117a3a270841b7d15f88b1034e56254c2da6219b50d1a0ce212bf27fcb778e709592ead5a8e4962a5ac46433cbc5087aea133b5474b46220a801dde3a3f4430ec3fabd105c63cba4f750fc104894e77402ff26cc2772acd8dd754a5ea4815cc7a5e96ae8b95b0a601afaf4d6a18f66681d842416ab8a2a473217a4e4f2b01b028c476a387fd9fbdae1ca3925c61dba57407a7f59e75b2335f19682658a79abda9513195c8c568986de3e848a8760e3b77f2420cbfc9ef6af1cc7d7e7daad8f82221fbe7660ffef3994a0959a2c1b5157007258d9de4a1789c44c6a7ecf424c73b04f8427d90f0e9990236ff16f2d6cc803e79a09abc49a47e057d9ea47b454a09d7d7901ec5eba3c588c5f8c0f2e7893ea4e1d4043693f4e13966581a83185731d834f85c85024b18cb869a976506d2342244959d50823c4496c20710fee03db60f690c01e5fa78b5a1e70fb5457faa0a44aa099646309b8fe9fbc932949cd2a1657677e606940e55546c55542df9e28014c8f597849a6e886e190047d4f1c3d872bb517523ea85360d1cce3d8056c2d56ce641412d88132cf68a66362fd672770df0da190b121f09726571e15fbc8d31493b49790ec6059e311bd1ca9f7fc15ff2d1673eb38ae39202ce2ab1759f62b9fa3b9ed8ef5ccf73a3e62389924258d2a2199578a1b18609345b67de1948aa4affe1bba8d3ca47ef84f89b921bb6996a111e07cb5c0e37ff62a5e4370a0759429e78b59f262bbcf1f83d389a4458468f0f22557f4f2ef19a05945a69606fa8a086b46b2762ea2aebb61a02d5c1188bbf738da883eee4a297397c64f9b8207dd36ab92e9ed792df89e69b2a9065be82e139bb13798eb118cb5219ecb88fb303b36c215523a0a4b4d04a6396b2d4f5f27aee871d36dc9ff9c356a7ac1ae168ab76883e09b7af55fcc3957c44494aad4c754a8986d1a27b9b24ffaa2352f2055ccb017349a27876590ef32898a84b71058795cca96d450fc1aa2f699680a0ef49c7fb4ae8989e4e4dd7bc8d771c4489156062f5fe8bd448823212413216a208634f0e1153ade059876c8a8e0776cd546c6eb210debe59cbb353c4fa2ca63d7f0084172dfaf447bb0f2406cc5ff064f843abc255c4bce4d4b541b0f7b7632bc70357ebfeee21964ca40a324220468a364d75bdc73296a230879c404a8362f51b8f6e0e6b7cc817cf81468cae80193612f72e80959af5ab82e532721b910e5de03e59c34dbb5aae1bd5c5d5e382aa57efff61bdf9cd3f9c9545f1498271aa34faac3977eb39f0c9cec6c86b69b4f1ee19ca591aebf5c4778d321a0b689b3c47cd64fc744a302bde3b5e76fba29dba8442e9e075b17f601b73f8f092b56c75a9256b47dc4f7793dcbfa0fca670461fbeac029181c9426a54b8d7b0125de67029e519811964dc3b8bc966a65b806d13f7f05b3860943515f46f3b1985078caae9b46d59b8edbb25940293671cebd9e5b17212e9bb08d29db2c635ffa5fbbda1014f494eb9cedf8e69ac28e230b25f90b29ac39b4a5be860926aefadfca1c75ca8ca8d1582368a2b4215fafaca8d1d4bdef02262fc2e0f4a6fb7d8ca9b0cf31785cfc31d5d3fb214d12844a1bc41e5045f55a940b88310cc5e19fd121f67ff83698f4eeaa4f7401673e8db5e6ab247e9960c8a81a1820aca776f8edbaacb6fa6d79c7fe2390cbf5d102ebbddc9e5adbe3d71d6a7f3ad470a54567b33377a3de78ef3e496a77ee65853ffa1faf180db6c536cb0b04e6374af5a56c76bb11ac38e66118ff53797c178fcb88af2b2dbbe75cd5c43edd41bb18b73353b165cb4bd80ec0f013ef7d971b5224bd0c7ed5ac75209cabe657adfd98bdb3edfb7a0d921ec01ffe714e6957b33038642a8ce9a0338b51116fc4de4b392b39fb4a5b6d09e5c0ab8ff0574457c0e79f496c89f89eec8f824341c77eb56a00e9a3bb553768bfdb8a42ed79e739d8b90820ef314f62eaf37d1f52cbcdd82b10c0a0696ff8e8db0ff549eb41519185efdccb01281d0248ebb95af9be56fb32e20e28e341751127536db03823e99124fd876bdefbf73ee7a7cb8b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
