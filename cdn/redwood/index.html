<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dbcc1a99e7c9ce2804de222ddb5263c1090f8360aab17af5266b826d98975f23789d984d69c6da11bfbe0b0f8a0a9635bf2bde65056b2228b294ea18f00014792fba3d3cf6e1872072d9694151930892875def492024984cd0f58503f084af651afcaef4590e2729794d67024389ef7628fa819687fc10c4486d3e1b412403fd4c3b1aa5eeda8d3a5f4768fd25ab06334c7e16615b5b28230134a3e16f232db511a3c4af37ea2529494543bda9f4555c9ab9f31d0a19c1914c74267420e60221153f2134d41922c28858120243880ba9e60f1c95af9bc0974abe23090326624a203296a25f55e8d3ef1cdbd964fc49a24168c801371dfc191b150aff8c4b6fcf89503edd30d687a1a0ef3230b71996f780766ec77e603380d8d1b5641d08959830845402d4e31125130de1d838c95ac1c9813a5769a3aa6116daa44c1b6c4e2fd77ab872bdfdce51149a254af630928920db7c17bcafe4f53fbe270967d5f3a6c7134a39dfa5776acf6ec8c3f1ea7fa5c6763bc42a35bd65c9feb53549ea62787229228e44b95f3df3bed848bdd398b22bbce7509d304d372a8359adab971752bc98a7f34bdb33ad59622413e7d9396b25d4dbecc3c71d4f13fa6db566007dfdd4002a448d3fd9e2717b349e957272245d5dfb08c56ebb3de7ce5d8a9abcb784954668f076ccca663a7e7abb163b67e6ff2ab2e78da11fc28ddd42c6e81f6dab2e1c559ea95c17ec9276e6075e7cfeb13313b944744e9121e33f417ce65646fb6e5d816191dea8e4f1dfad22cec8fcba244154ae7ae886a75c087b12308b3bbcda46e6453a10a63b64ae5922aef40c22c89a4f0363917d898793a803462f298ceb0e9b1fa266ef64b019d8ac7b3f30cea18aebe49bf08867a893c01a2c31e8f24a27e9e5295028a036e356a681b859faae83e21161b1ed7af80eb0b2100787b453f45c23cbf68e53394dea87777df7632dbdbaaf9c6b8206d967ae4f9d07fb5f4ff492a6a3b86b31cf597ecc93baafafc6f1b21cf274514ed7efa4fb8df315a2c95aa70a2f7134792c4ea18566647e22cf784d2beed42601c05320209de7eb58cbfa22a7ecf22579701ce869ee478e9785da359dbbc9d15f389dd1c82f500485a044ee33ca12bbf71d4da2894ea12880c3faf27c997f5e02b6173620cd404322c11827bd34da67b6e63fa9ee8c3721d7b847546f0ec03f524b3936abf8837500b8c7cf3b2675bfb2e07e0f1b893b9fd13039dc2c47f5dde1a60b28d7bdf2204d44f887142807e96a19ff241d184b0837ab37e48f89a64427ede5fdc5a0014b680a11b5ee66fa0eea8e119bb4505df726c287be23de7edab4e42c46b51d31f94db0963fbbb67bf7fddc08f23e1b32840be1b1d44793b81e397651f9446dd5eec391f5d38e554b830fbaa7e0397532585dce4f7547185aa78479d58fd72acce3ed18b7c4a72c483fad828625da269f0841502b396fbf639fca8dc69d8ff73531d240b1ecb5e7e06e82a308ed3d636fc9d8500165fa4226c6ffa689747a99a1164d666c02253c381c7c98f71d485d502712787d9c3aa44e00a684e3a34be468c34e32c8186e1eadbab16d3c1f286f4bd5f7b179d49ab4484b75d53a323f9357249f1c24d39e15ce5007609497a9c63b75aed1ff899356ae2d5eba3786c37af1dde8089b7689f1105a756a2ed7114b2465cf2dc8e701e92529b8cef1d0d88223043e979bd8c81e8fb15236e3552ed2acfa208887c585a820edce102378bc2a257702292bf41d66a6e2fd1e8144cbbf35400fea491f8bc295f2acf53411eacf2cdcc27db5f93641eb5dee922ec36e394ae6bd8933d9d0a1a583221d14dc7c9773fa05f80f02cde0427f130b3c3ade5524a6d0b7cba645006baa746b13a68e0136bef61be3deae8fb2c7f4d7be1100af49af860de240e4c8c14f2065adca970f35cc2e545873336821cc270d9ff0954bf5d56d0ecd59b3d86ea48fa9f8f9a4d3590f98daf4090b0a87b1a1256da70c34ce84032f44cb1e1a6eeddcebc3954109c89c426cd80fdf3210c935c3a6694792683339bea84339bac003e552b889a726586be0d8122d546928716863fdcb03e303476356b08c893b51d572b9ee4414a4a318aa6bfd095422698e8abf4693e8cd590fa7032ab701b0821fb3240eb2df9d5cdd1818f0a690a0e589b6b46df1ebf42f5a0b586ffb90d930d3efffb9f4f00d7ea5a41594702bd0fa639d64c3d206ab01690ee14ff809484c2b3de4ee8db2ba31fdd7603a5e07b180d0ea857c60a1a2df690c6d7e4b1ee490d54baafeebd17caeb787a3d70f873453b02cc7e64a3a12df24e7e1d9c8b32cd8335232ece95cab6ce1b956c1b8b824e887e1827be70b4e72deca0e969f12bee634a6e3b8a88350048ede8a5b5b036679a40f2bd29417d20124bba798b37a7bc13e15602cdc2d659c57dcdb1e89c8497b8fa99f4184cf69e8e1bd9e707ac3309ffccd74685ce26f86eb917eafc4261a30d4745112520be972ec2e42a5a9b757f558ffbff4a1a9f435d36c9114304b126c6b7521e75f5d7036ae789ddb4b975734181c65528e048cb49a142f9bd0082d2f4f2a06382cbeaa398359fd24350afafcb0623f898d7af6045b59130b73187766b918d2274bb2650100c06fcc1f18d466f67b4a5a11dd5178abf33f19ff5baf8dcbd7cccb9f8cad2675447a7fe6371aead91ddda3dabc885cf8e7af3b758069617e59e627d7532970f867a69fd67bb5756aa3903f7ae6f82ae467e48fb312c0288563358cf1dac71998e817dcfa7fee8fcb6d0e46a0be0a000270f73baf62e03e743a63693bb7b0a14ed98e94071aa4829a25107805c2517472c4927667ae6dd429ff1fea0ae7716dde2a508255cb1e8e6eb8c4c29c08a8e206207b1e78d62cd29556b8df1b392e4cb0e98f4b7ab93a99ef9529a1534e5f1c9965a7ade546e15615ddf0599c5559b5756376b36f5f7d9e3cab010978afb4a083cbc1b9cd197778879e142a7f0e5366cb698f1364b571868d42f647d288e68a231e0dd43e5e7c39512d20539cc9be80c036a2ad189f0210c2762fc9ec847c662dccce2e8bc8b63615ec1d60b2953719d03271528a40171083ebd6ffd4763a9e5b90111fdde21c45b965484d6ae9180a6b4fea2fe5d1f3d2b8d70c9f15cc080b23f81505fe1d1bcc7deab9ffe7913479cf984078497132530356fe2217fa767a15cba8e294cf16c5bdd886e22b472a3549736aad4646f6cd6cb85b500cbeb9f1654ce070ecb29fdfe9770ac7d5e7b16ba1ab21eeac7331e820bffe594cf247c0c71d31bf4f823e7bbcc8f215fb1c15828adc132b5fabb8bfaa6342807fb1b049abf9ea8c647dab879143042fb5ec945e788586bbc204dd1ba2ebd213a85732cbc4ae807c665ee81f420537a9f9e36155afb3e744c0c70062449c7dfe14f283ae88c492a9e922299e23bb7439fcab325b1987573469ff5066df7a3a1192089118fdbb9e36e1047442e95e88d746ff23bf1984cac8c318fbb730974cdb4614555d4e46fae55875040dd7d340674fb51596b4d93bdf0f2e38729e0d642b611857467b5ec3d71793c21e14c6889f7d7933b088228b587f3b110ceb3b7606050223c32c7069723c90db33018997074ad8ec9ac0773181789202de57ea4c174268eb7711fde7dbd640c8c4864d1fdd0afab15a6eaad2d7b9c2e475313fc584aa7b20ad456d7d2cd431806d6bd43156d8a50335bfee809a05912cebc90050e1d8069307eaa41255eb22b5572c899f9a280de27465258b03fa3166bb4b60bbb5db204ffa6d4d5e59e90189c6d766d62569521f1d083be92ebbdb20b9d2588c23369c0a7c4a239afc2619b316acf4fe8541fd4e345ae6fe65c6e5316301c282dfc74d4a7872b01d5d527187aab95f0214bdc4ee072161b18e2647f7637631518f33db281fccec241b2cd5d451fc4b750d5f4c76cc8a4dcf9353457107eeee5b45a4eacd72919dd96cad834df4543c0b9a7d1d37457a1ba5986f97c39256d0be1e162fb5b2e62a4ea1923f0cfb5d2a3db59c0f1115bfef80ee63e722aa922129a6eedddf3b98e763fb09249cf17b6e204acfc744a2d385272242bd97e9830de7f1073476b02110e43ae1f1dbd6427bef50775a61874724c68f5f854a492f4f0fef8993242c417d2783a5d85d0d80fe8b8e3cae366226e8f0e618948d529c7b6ac5ad1f32cc2b167a478c9d140c41217a2d171c0822314adc6d1a5a2deccf27964b5b322556547a0e4989991e40c99ab21558ef5774a08171c4ae0fa7be5e508d24ad9f9fbbb98fd660fba921b92a237288f64195b486b628c2bee547aa27b36ea6b3715fe954a7783347ec2071e4594259a265ab0559d8ea181289631ccb72b35c480ff141145668eebd12b03160415564369043775cc7ea5e3be0c6d8d5a9aa7695d03324ac2e568b810df448cb8bfc5626959c0b591c08cf5d4be9a0325b765c319332ab94caedd7dbda2a0d4de7820a2d511efb572718485f0114cdf02419b63303f0a6e42be7e6a2a1ee310caa4550f8f4165c26cb7e7599cb5394182caca899975624713f9f91edf28496b5b2bacc78d3fededc1cf229206c7caa475268cda5e9c8cea2de0b00b58d58dbc5205b807c694f88cfb2c1c3b6bfc47a4a212dc096c8b12ed3ff911af40f9ac8e77b9747c11dc54f0fd25654c03a7a9cdb2e5b1bb5cfd7af00b30fb5c659138fb63c1313896c7486ff59404d4be4d444a269799794250b319272e283cefb9d382b4c1bc9874bc3527d06e75b51502b3c3c5cb218799cc380f79d3a97937ab2daa49400931ae994f669540cdca3e636da919b626595da4f3986f44239d3770a7b17c6b7bf85a3db3af428ea33e7a802e6b6577da10b8cf76ffd77dbf86a331f66dedea3eff83291f2dbc77c7d141cdf549772cebfa723a4935e5d85cf46c0d1149eb448240d552143596d96cf2f95a67ca06c7533285678ec7ba94647c953496f4f4d92b6489af074eca854b1ac3a4fc8e77e20f08afb917cb1d843b02c172dde080c576ab30451b1832cc1fccc667e58e2b3e04435c80d868c52584710168f6dde28998f3af240493d6dacd2fab7100e7ae422935093cdc34a9366eafc9986c7024e26fd23606f51c54f453ac78099205f04f001693174222e7233e50b3ef72491baca258a893442201def30ff172f504582c62f2b578b0d1b75431bc7c22b75f56beb6af748de2065b5c7d906d37821726b1c5d858df407b3531ab57cb6177ee47900ec9247bb6ed7031c9f0d542a347bf5198aeb38cf28916857b302e716e1c03208a82461cce18572efe23d972a5745ff4d16d6be12c069d846e06cacb3637aa4ebea979326450cb657b1fccc38378241b034451364fa7ce2015f57678ed4ba245977f01935982217f6a60a18fb969edca0b982d484183e552b8ab92ae9ac708d38fceaadf7e4b92175c8e12c06257149564dd84a57a101d05f1a86601411048467c2965006396e33f4551070a93016b5cf3fae2d154052345d1bca89fb7f15072e05d733d64e450b4e914b875220bbd8328dbb572727a0827ccbdef9d769fe83d36fbfcb62c0f355a9fd50851a01bb55a9a491adc5d6104439c046631853b9756fa895791a97ab212f0c35e0cf97c7c9d755f2860282cb5b650b19f57063298efb5eccd762bd5e24347f774873c197393802a2b68407eaa25b16bb3d9368722bea5710d37e872424e015d7c68130329aa5a1a3172cad55fb754cd4805c71ffcb291c09eab0ea92d793c5654046205dc6b394d75d813a2b49217e5bc660dd5574201c89baf463c1d1b0c3078949569d31399fde338be074aa1c0d1dba7ba10f60b7d8978daf7b154d4410582bf081f11e8f9cba76393e97d7a4cfcedc38498c57170447e0c6480822699abe7238227845b6b8f33a86ddc904086dcd468339043db6017d5876ea321ef82c54a124d9f86256c3321ff9eeb22c9b03bfc4d27f10e3997d337d44ddf3fd139a3f2c1b3938c717278a5ca92a3f9a84841d24c9ca18dde70b03422a3ef1175bcb40ae1a8c1e918f046652a90c2d54bc1205f58d5b051291daaeafebeafda4aa1930bea81b216c79e2f07f6d898622d0f507dbfae6931306d813bf4cd74e487f7dbec25c3af50bf12cfbec74d6e7be9271258e84f89c273904b0f91b15e3aa118cfe3551869722d824d4ef4708bbaef68b1ee22d61a420356f5eb2f30a81a2c5e23bc2abda83edee624741ea0049efae75a35b0137a896d64e1d511b4598ae4eda4c4107abb8271d05c99a9a4277abe60e9bba7f04f914dc67b7a01920dd5e51a78a98388fd402bcc7537d86dc59943874819da5d8d9c60498e017d5ea26464eaa56ebccecbba42f66c212a3034cb46baea2ab7d81acad16f8f450d164082dae6d4caeb84fdc5bfb4df137a9bf53a8855822f82c52be55b19f37111cf7aaaae71b50365d4a54a6a9aacf366174157772342459560599f528e6b4cc25473e8eaa2c99afbe77a53c69cf7c7e93a36f066735fa63740a4bfa9ebfaedb438187200359557734ae99f320c3e7e3ca008571225f28ad3c14cc4dedec0b2dc7f38744336ab700209c02dcbc9807e2eeb9a71313f227f7775566a3167f7df99278211755442729f987da873c2aad6a116d6264a8bae6d600171488cf966b71288195b16a1fc5a8272942e772265d14eb55af820bf6783fbfdfb8ce03d4a8b2957d838bb0ca5f014feabb202885e2725559cfcc6a1b08d82fba4e9dc46f3377915da37efd35652eab30773d259b33b32223463ca94b8c4ec43378a932e1bfd3f380838e8d2402bd5f89376820d874efdc6a339d3532fd8041da572c4be131e5077a34aaf76cf31ada11a70b8a567ad1afc139cfa9fda4163d292d1309a3bfe036c7fd8deac7409ade932f926ccd42fc116d14363e44d1a660b9acb0b574555c8cf0fc4166dd3440776d0f0f3741765693feb9007d0b42e080959678355e8d2a1d7c4b59141da0f8608615a4da178d361b99ccb07b74499e1fbf13358bf8b452a8bb69acbb70d3d5621a3e13cffe50afdf5922b6c7e1be52b5320c0402e7308e70268676c055dbe1e2486ee4bc00c8f67fa478d2d8901f97d1ee0e6484402349e60a0cdd8e638f150a9c1033cf2393ea7e3b0c460b11a3c74848798934534f2b7a569a2781650038354e3d892cdcfa1c457da708200eabd063ad9509e35adb5cfb0162604698b8a7b852731ac2f77fb706f8f901fc2e1c48e6a4bd045fd96d8428846c1d9b7957536a7a60d265cd2602ddbfd22331606ad7b7e0076d9cca815d733af06079731fe2544854726188b8ab0dc1cd4d53b7dcc24ca8066ac72399419d4cd912042852c7fafcc3a2967961484ffab25cceb8056e51cb654a44e6795e997cb94c259a79cd1425cf05767fe88ea2f2585a6bf8deb13032e195b5ef0b2d57f1279b53c801ef16dd81409d44ccf1d65b3a0ae1d161b7c96df00ee8bf8e18edf6941a8bacb4395e8c82f6d90c2ed9feda0bf6a6c20a2aa133d94f60919ad09da88b48177bf6f48343e4824a1d634510ff298964639b06a2e395af72580ab177bfd9964fbb61dff50de3573e8f1095e0371f1fa9493e8abbe4b30ca828f12dc83bc8ab43a092c0ca3bc543676c3b12146c481c8048e9943f1ca9036c3f28836bcdcf1c1af7ee8bdba94e69903a8e46801e994d4aa417d1c6bec60e76fbf4cff69d53cdfb62d45ebad17885e1bd4f5d52ff7f2d6a888dd46e980d07a5df4ba0ee520d5e609aee87b0e76e8d13132b07fa1130548fbf61e3994d5b9b3c1120daae5b298462c97245e72003fbe4c24c8db6089d74451c0b9b015b9116b6ab7654fb4141ab63fc8f9a6d2878c22565d38f2c88efaecc59f8def0ae3ddf3edc8597f670dbc10fadee2339352830c54831845f7ee599fc711bbbee85e69f00f0672abd4cc5e4acd323e6fff2fcb5f0d90e1a843aa69a6958f87130d9d8a6f81d68063b2705f2e1a6575a8648a2c34312859895995bbd59590c1f6ed6c21c7e7743a67c9f855522dd28ac843bd6fad0d6144ae23e46b48d52c131b975d337e5961b7b1d5e82243464a54160aa22352107510280ac0d9ceaaccd00e1ad5f7c16f3e19cbe0839e4da881666b0a35b69ca02dcd6c732fc2d1305172af5810bac88ced7825968e8d51d55e8f1550664d20c904f73109fe3499850433710558ee537b33deebbaecdd4e2dae7bdfbd5306e47b21aeade862f4e8cba01ccbaa60ae236f4b0bedabb34573bb32f66fbae8f8225745a8aa163f82b5b3d28170437b15b841acd92ea6a57058364473fbd517a29052648b7ae40e0bbb0d1197d269ee8a6fe05291a06945866160479943460490fbac486e0c007c4f13a5b02693622be0146b717e617fc3d6fe98a8a45b38720f4cb639f441051447cd302ccd4e28dbef4e9b8e6be99050e1d16bd4d0dc4ad01fdc17ce86bb5659bfb643034db10be8093cc90d43f24dcd442664513b290a07701aa80a2ff113f9cba207984b838d97ace309e41f551fd190b05e4052382c175008a0ab2a84274e7accbe1b389d3fb148fa6d50fff37938f407632d31167c57456e381f3de71131382d733f67c19259db6682d9c631580f89533ffd8ae3d91b2c8c69efab5ce264c68f144b90b11aa676f73a163807999ec8383987bb8ec00ba9765bc0590a428e7a4a8edecca76138d55a9a06aa8d702c69d5362159b717c217ea069f4cf7fd5ee71967488751d6802125c05c6f0b90f1c28ff6e47b81266b109e9e28f5901dcea684fba605243412fe28c534ed3bfe8078f96b27ef81b4ae53321eb449c1b168a8892960c45130a146ceb05d98241fad844ed17ae192259dd7eb8764a5e298433c99c0b6670e9fbf933ec1e4b4a902b15ac1ca62d4fc66dae8f23b19e8944d037aa6684ce7a48306110bc85723992c8ca2ac3a9bdfaf791f693e627babe6ec203cb166b0a8b2051202449c1a2e81e55d71da7f4ea364ad23077d2c715f41332451efe8d7ccb459130b53cc70696103e573e291f1358643a57708b6ecc74bd0de4a77681dd32b217d42840725b94345a3b9cd7e8da19dc17b644b75dba698981066c37acd64973d8234fead9b90c65dbae0a17b552d01b544d9355303b3919dfc325f8126bd1e688560699e05ef644073e7110538747c0c8fa36060f81bd6194a6f2cb636dbabf61db7c871d388a0cb2a192d71b7328ceb134c44804c67089ec5a1af6c5c8c11e29bf98f2966b4d073cef61cd728ead36299d42ced172db992d7453d7dcf238db8d0eea95d7af5b391f54a0f5abd50f3271255973217713ae192adf8b13507cdbf814d473dd15512c84048df79733070881348273c793bcecc15887bf07c6ae41f35838595cddd30291d5c0c704538b7acef907b6b402752dbaaf70d8eba64cf532a1813ae168b702bcbd97fd27305f7206244e158ad1e524906609fb83b943f742216f57b6545600c9e9046e04da0add9a5aab6af4a686a38512f49088e96dfc3a599f83ae5642585b844248f61985eb158bc8c9660959140ede418261f4952b434e9c4248b537ad38494c8b612f603fe73ce323496480c2caf54b6160a8af309856cbbf4dcaa352b188c03dbaf02c368197206ca12a2ed599342125f8b9baec4a306fc325eac743d176d5d7bb155c9e2d31e68a182ea7632f9f35e13a777ce8424f57ebbc91884e60861ca909758b0d42a2650b2a340b7899faf332532a2f44ce0ccfe40993c42cb703d2d046980792d5d312b970984200a4ad50a98213eb6b6da9310c1e2071f89434d0c8e4edd3125af950910f87f494992b389884e2f91497a302d66ba7a7cfdabb1b1f0b8232b42e853e127c1bd96b0facadcf099e32b8d5c488c1569de6194fd7d2bdef0285efefea2c2dcd4d52a96f0e065065bf5afa546f124d88507ce777c1a7b16694bd74d57c943d73377df10bbecb756014f1c2b8519912ddaeb3ab15154e530778724d6048a13087b85f180583f93b0bfe61b564fffc4522d8443e49647bd669a3a3e62ea523d5bdd42b82d9d0c07331547117d9de1f832cf38640bb4e5889549d34309c6ec67d115d4904f08fca5586b93fc85dd6cce0494a8a26bd0ed094896b04aa888c7c9284043129967259fa9fe40f99abbdf15825bc50b4345333306ea703756ca24fa85a0c2118f1ff22e5f37dcde69db3360cba3a3ffce378fa5866bc01512d7c81b7d380b1f8163adef4c0ef69008f23ba70c74cc1e5a2e6b8cefe97922bf077a2297f2ed632bbf9e39afa648e18842aec664d08d9a9f5d5f631b523c1641e3a8f46d3458f0d9df992e1c7e64c2f2cead19a55a78bd16fb1224af5e3e37a8d87455ce9274b540c4462d5b6f00a406fe073e34ebdd0700238cd3052ee3cabd26b02b87c3394f3a998f30b2814559652d50a3a00264065695b3cb8fd3b5aa7d5bc6aa58324db910b73b5e83689b794f45eafb396febfcb598a9fbbc692ac8e6c45dd148af942f7f275038af5cb6b149d73702f7b10a8f35ab3630150675fd0ed0926b9a0456dc203f5c401e39ed8aa0d657ee336515ce463549e23adf6cdd1002a7d02b6a43dc0204fa51c39e849d796afc3feba845f74ca7fffa9a040adf1554c0f96fe0516b8996611e4f6d38d1df25f0c6ccc4030c5c699176c0bb317446a2eddaad9f6234e4f1b675c082260195064e8a7e59498b7aff8e7370c228d4674174a28d6fd2b29fbab1f0984ef24bdfd075d0eb0a7fff6f4638930cedd339d4be0bad83d5a223e53aa87ed0499e62120aed3b82cbaee1543fe44f95a6b5e564ba3dfd7678ad6b9846a6063af5989c74d441799ef9dd9a529a7e199b1ae94c10f333cbbc8b9f0ec295318aaff863e2dca5149f1c8930696fe7be92036bc77e4a965dbebf7fce8416fe49a6a2d3862b8bcd69e468c28fa8bc48698923b65da8ddc7ac2c2c96bb0d6d11978b9f4ed1b9b0aecd22bb511b86d9d76e38acbf02ff67bc879263aa23ebb5e065545861a7eb2e9c900a01666df0f8471260af2a7edbcd3277705b0271b6e752426251ae4883be748df1753309f8fd734e5661b4c4488c36b7a75a7da33bfeb017e30408fc376c5474ed7869820af83f2d16988c2ff32b8e2091aca8e5d998411b53a99fd8bd66408893a40d2068ed36044b0fc81ccc217cdc65905eb5d1d53139382335900b90db6b7f134e0f0912c0ebf411781fb14c9ad175eb8b08addc132f033ce52fc716d8f614a1ba6b3f6a3a6f3500ba628869034697ef3929ade9cc3456ad69f9b1fef65ee8f303d6bd9c071be49afad1ca9d908facc03dd25bcb3e2eff389b7070c6b9668af8426833a579b9947825335405b88efe8081ad2bbd976b39e9738554c9df0f33c678078302b336361ab9eff3bfd45329c2a7b41f004bbdcd4c9e74e436177b29c66bddf2af531e4e8cdca89fcc0efddb8392cd8d9e1e21b9a19bec690afa000ee617b299ae3d00139ad86e531027166bcfeadf7c9641252d5476dbdfaf76266207a8986247ef12b662ef5cde4932eee40732b0651e973a7bf4e42e9c8e311f6df7e329f889aafd317e350aa5f19124caaada5bcffd609712d622f328470587f698bcab3706bb430ca3a55bb7c7d2ff2df61e3a27b1ee5caf7a6a9b5ea88a0fa6c41f627ad24ce6527ab032a8031f883d3803b59adef8bbe22895ea6e70745ce3e1215987049d2bdd162980d4d0e21f62b2d69f328fb54479041efc7ba39a30d2fc7b710699a3c0fec8a372ff25d105ecd9b6494e1e12809427792419cbab20e4ea164723da629a6233487100c2e2131415f33a9dbc21d578b87cb79da26b6f67926035984884db97c6776aed34cd1f976c78cbc29588114e336f0c11472b2588900616b84dc5e941268eef63bc5d012dd92321915640c84d882ed2945e29f84994c4d34cff1a565c203e73d21204678e0d62a4b3357fb94d6765c2967809253a4950add22ab886be6be1e076e7f65d2413dc8aabf88f80255513e547d01b1e13ccc76499744ada08186659f1f5f5b68e0e0a937039bdc898421ddc222be590f4d8a989a9a949bbbb301e8fce818485183e1f1592a3deea8c4727f58043ab6f006eab245d57402f60c505b3b59ac0374805e4e62495be2a851c07ec8dfb36e109c1ec3ab91dea0a9dda4de5dd694f2608fe1795ee5d2c568715f5fa18c8ab7fe0256a514044ac7cbbb6254cfacc7f15d877f7bd66595b70ecceffbc663d80a162524c20ec26d6727db102132fed81aba84d3d7d9235e26c7790b6b1617d5d0ba57b2c54adc1430ba6a6431d53f2bcae39e7e03342f302ccb1b77aaaa158a10011afcb0a95c4d751a28a951d615c1e81b79ac3a4a3ba4c7388cb6fecee1e00605339ce4af55e76bf01b03b1713809ec2581beacc8c268a455a083a960e65a82e60e72806c0d809a7058fd444e1cff70173297e72462f5beeaa738477d203854d84b164d16a063a0ff97769e64d3879e3798bc4cc375886e5ba373ed256f02622dc1f898e5b23b714da2d6b6227dfe51d286f17308d191dfb6b2424da50baed16fb4b34849ab0b7ccd567af62c54990d97a8a63eb766af333c9f329037fda7bfbd2ac295a2ad88f978ca31986e9b8a2fc9768d56bae6bcf635b58abc643d67f2d88c0221a7c66e523f88f6c112baa8c277c6bbd3b0edbaba089c5881f7c8647e7428d4c7cfcf6ca429dd512ac7ea03861a7d16d72514a33bb85d60dcada53722d529e6357e97283015a025b64a6b55864e1c3c30789c8eed44ce395ecac6e4e1ae3e2757e6e979bdb510593a8c1bce883d17e01fe57e2776491611615cfc86f91c615af597ed45ccc50dd32403a8b6655e642c7d9903875032175984dd2f52e5fd92f69b358292f8b86b7382db5f2ccfa7c74aa3f16dbd0f0df3d8be48994fcd3a1cfa01565cbde0ded6400d331a00020b5d1d9a2e806827169393227e79cf7c7ed1e6b81d0b0ee82ffca4e3d3249f4b0b6db17d8c83fd56cfc864829c4843023792f0052c1b5152333302224da6dce12f122db6a97a58b1961ee0bc1d355957d3efd5fa7adba49acbb7373d93eedaff67ae99723ff18067097a8a9ef2ec56e98eaff380b918048ae5ede441c1ad5f053efc8da058bb26c1b32841933821356538e1722da52f72eaa4e36397a1ef22b839b7a75cb1aeaae9a9f185c7471778609e95a60f3449aa803dbeb6773a344b6920f825cadbdb150ae018714c73de32d65f2a66d51561d24397ab76041abfc59b2cddc504721ff2735424fdb8b267c69c3e0e838b86e919dd70cab78518d7ed6fd3ebade12fcb8a62dfa915d27cde3128796521225d760aa7685775d09ac53d541e93696be512148ce6d4578fbcc5b3ad38d063706d046dfd950e463030d26c61ad455c46b16a81e7718663ae6a0c53818407896f6ea093dd5dd9d3d07296e107011cc8a92453a27e9728f7c982f1b7b945ed6eb2645c24cfd5354061dde9608d83e490f5553f3e8f0343bb09953ec91e6dc20e06911a646bda06e0e17a1760fd1cc377411562670f1e74ae40b573bc0d7b0d264bf60dd1d4f613b8faa5566f7a220c34d98c1d112971d86a56f457b919d7d15c2f2f0c44bec0ce3e4b5bc93f42fe1e1dfd59a0c2093a23e7436f9be2b940675e907c3b45a37dd11e821d94fd0539cab2058485de6cb248ce2ae33768dfcd3ad7de5b1f9189deef4276205b2555a0b1c2dbe0cb770f681d1ca1442e64d3b31459fd18319b09e51fe385d6176a49a80e219d6327e9546cba821ba28bebf44cb5408e7d1d02a39583ba07af72179355c6457b4b83c56731406504d76a3f4d5c2bd579c8e25cc8d773164e3d8372ef869e05841367e80e5bbd2077894f5186daeeb24e0dd9bd5d162a2c7ffb3f9b7a053d5db013400239e79890d4a09a3cbe01efb63c670bbacd997886eb9a7db39ee194a40f1cd1a15dc53fb33638d0267a93dfefc02f8f81ad63a0aa2245c16ae86cb432ac53365c086d9811347a2fb4586106be42f3529d44e350906848c969c7f853d9334c8cfc55ace3288adf56f0b2d10a3b8d137b865bca65e8a813031d20c217c5d15417a5434dcbbf6c1a34bd1cd138e7af62b201d6a8dfbbc64a7423fcb5f1ed4b3a7cd34b3c79c3aca0f58659a5aafefe78a0d857851a0b5c9f03870fda3aec779c1ac339e0bdea95fa471e10d88fd0aa9efdbcdd6dd60e15b12b022ca99cf8aa0ee282d2c4339127e1a49a07c5118814d6d494300684f2a6f53b5213a1d307635993f5a6fb353ca34d2b32ffe84cdae970afcffc2633dbefe505c98c77a20bedfe0a09a9bb72f943a93923f5fe0c35b8b4b97f8bef1a99a5daf4232a0032f5249e035929d9772349a12eaacd7f50ea1abd8ecc99ded40a617c2c7ba3786c0c0115ecac80a58ea5045242b092fd0ef52015bfda1d503ee26ad794fc5daf198fbd47d1f8e51892c5351cf7281484154e782ab95da2664ef98c6a1f02282c1971badbb9ee12a32f63c696770e4399c940af335dfe158be2df284b6ad0c67e3c725f9f8d52d7a19065ce6cef766cb46b3abdfa4907d53363414b98da84a906ed11278b92dc02ee9093645c9d47e45ee4caf081a445da13d301f7da9d28f03ae2642b5071f627760901db891fc88ce86415851a3931b90e3f25070ee67d6113c8d3a4497e7694e7f1352a33c92283563e671adfb81a1c92c0bc197f8880616c7a89940decad057062aa4001777d3afd78aa72ebb0160788d19b334951168a632a8ab7ba554e013ff826336f184e961189db3b38d71a7a12c98e8044be97d0f611c96115f0a67b631e4bd7c4b4b28496752f6fd06b3804bf9395ba083fbafb6c248d368e4bea3c1b5d7b2539a408536e66e0908c9db8fc63aadbc6bee3338b621f1a590fbe6a84435c1729fb032773bb3a66338985ee89240c7b903128a3b28df9d85459d4b8be3c8aa5e3446561afd1881cdd28b6fb97949ec1fe6fcc8f925645b54cc04e4a1f55a989444947ab27115753725d6c2bf5d0bf317c6490ccbbca33ab68e421b7618453557107410065a337e6e71d3834cfe357c4301e536a8d490ff97bc0657c4cfb49d658ff6267d1899b143c108b33606df8377a6aafe5b4430cd9b294d9d9b88fbf942da0c11833c9bfc81d53d489f7789881a7cfc1eca18c6bd3480442a493a151d25ede693c0406f13422324f93132b0629cc75b3d340e292cce8bb3cc825e5d33e9ba1ec829b02306490315046ff4b9b43dd088f237b9b41768b2a2b759d32c903aabdf3176a48589746abe4616c9a05f90db7f446fa3ab69d55c9f131cfa985471dce0389af01e936ca7ad7594c624f41c02e7458e74da44de74008de23de47c4be36cc7820464f8d31617d489a0255a3a2d61115a936323a71d5ed669f81f90a73a5c8b13439079fe050adefb2a97cf889301d38d1c1af96c88806a69284a074b0ec59c761f1276c087f81e1a9fd056939da0d8e912818f9888d234ba6ebe25f87b3ff898235c688da3168e8f20dde0775c9032736b11a09cb772cb553360af9b9863ab6e314dfc4d0550cc6ac4066a51b747afbc4e98e8da7cd1963afc8e2f648bbc296e001642542dc029d46cc2b237c544f2e24770748afd9fe1518d5d068ce749db812fb307c59b59c3bc3ef1ba7a69396bd98408ced3904bd681d3effeaa793f280c4365cbdaa9666acdfa5f5f5889bfe8f44f2aff8d0a9db2f7d371e42f1c705a955197e35ccfc0d070aa40182ac9c00fc450e26e47c2da0b1d726fbc4833984563457a451d4b1bfff81bb6dd5a2dbe796360d39a8b93fdeac506492c3fde4b5a861fdf416cd3bfa9ed555545aef71699406990e6120e45f58917b75c8a1144ad82f96ce1c1d64aa5880edcbc57207774b61679bdc7fcfe62e7bb95d50a0247154bc86f357b683acc7896b2284ca497da95725906d26602194fe94a0618ad58305c7cedb173eeac7803cc5e35679221be8ff64db1aa79068a6037a2c7a5a404bc4f1aff9d0d7adc6001bf33957dbf3581ba85c5e88f0998eb7f130358ac47b04d64f8dd6f96ba192c01416d60e7bf1a33e640fb66c83ab56e40b3f3b78cd4ea3a01e6def77d3e1275c6b0f7c7eb39f7de6733413851946d66031038d41ce40b63e0e03095227ca7802c882a6af11a330eeef116a70efbad2f7968f20818dc3eb276a122f627acca1b8f0adb3ad87269b842fb9477ac2589d5b74f35c9c2a1df2241482c7f936be1f359a1d6de5c33eeba39a36080b3f39e627689ac4c0ed5c26c9571cdb3b29acc8df234f10173504e49769cdf768826bf32493f9122930d5bd9ae48336f165a93b802c4ddb934225a83cfb607c77bd8d4a47d4747d3caa0b0a341a19c885ae3541c6386d0cc82e352c50d57ba040d18e5e9652e73de05b4036326a9ea7889732ada8139706857036debef178a33fef9c36815020183b9911d08b7e9a68072bf38f0a32638daaddff7a137b91390ed80bbc9189430c714c47d931cf011a4c13fea610edf79219726bdb42e5e247cb684d8f6d6f7c6e37657eaaae7357722eb9f8fba27aa28ba94d17ae458530d33f22e56c3d0f82f1ee87e68e574664beeddb92a5d57dced10c30571f1d176450997b065055b79f63eaed1d41cf31913dab286d7185e46b4eab0d7433f85dc56449d7a00ae2b5e96472c131e92d3c495e0b6fc266b18e8a5243da424bf8a746f6632d8309c747679c8c1d78b31977448cc74c737b4bcda681dcbf19d69572f6079d00943202861f9684a03eba5a7c6c7fa6abce49b9875a1d8ae09a8d08b3cf1830269739c47ff738cb0e64e2d26d2ea01e29ce882df02273c804341c694fed9d58cc9db310dd1dc2c46b312af99bfe789a3919771feafbd65dbfcf74ffb948aeae172c179a36c8666750c27f4d203ffcfd831320efa2bda4e7a038615238429033d2458286a33d80524ed5eac74562140311f9db37dd6b0589c25494d339acd5151164982892fee4aa37d9fdb8e46f82eedbca2c5432c2229316594fb4f4a6879b9b9b132efc0b331b0f365c390f980bee9c71c3d562337a215ece50c02b24907cf4f8f9183bc048aaa34c51035091ec75826c45140f089a6a03bed39fdd9c42dc976ee0db355827a8408e23c29ec51b6502f51330dd37ef2740fb3dee28062743aa4a429a9da33eb60f32fca208add1e461354a5e11d721204553be3727c425d76ce403754601d2670fe2fd40a6e5ed8883b2dc75eb8baf56bf7bde0191a3feb376ed149e787ce81d0039a8d3f398416cb4cd94371a99971132bea4f5c8087c57044ca6fcd3eb23224789e83b6fd9e35fd2d5b5b30a9f033fcd42ecbbe4d2475e8b34b321e9813a75c82f243d36c3dcee842ed14483b7b750ea4eb48b0eb106aa3fe901c7d60989b0972112004730c6a90145e288a7db18484d75e18914f2011724935adc6ef9728b97434ec8f692af1f279f8538bbf7ed0d8aadbc2d6697f7f4955ca06b1b0f865336d0bfef925626340bef362a7fa3a2ff1708b4c8117fe344a62635de5e52bd16b8c41cfe17c623ebbf48f93160e33610fc8470f0c244dda519ef5ca74cdeaa7e9a449a3ff6843c3b3fd617c86c85f62ccfc0fb509cf9919ade900670f5fe8777d804ec96b7b559c86eacc2db0c21736cb66e0b5d22ed28dfd1e09f0fcf0f4c9ae5193f3effed1fc4c551fffe4d3f47d4e2d195a451875aa51770b7768637074b1c2bf98d965174cbdc4c6e70e8c92febae13548e955b96d3719ab8cf65fa1c6539ac11310a16c43a6e23ba295a5b806810e5dbfcf825170bd79ef8b5979d8d797497ca2ad918027759cc87ae88f57aeff62c5bab5c5482d74a7d6e6c33487d9e1454a308d3cfdcfc890aaf3f550c1ab027d177973a3e1e66f076e8302a7b4d8fc58e45780ce979d5425384c5f4cad16e75834f5aa446e5d804dcb26a45aa7a290a023e2bc44fc8e408d993492c194b794f12d996251f22d49c19843ff449204cafc3d4ff741e56dad26f4879e12c72f7e69cddbca9b0853a24479a166d9a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
