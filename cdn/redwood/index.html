<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"785451b7f6d55487614eb30618a62b36a0110646cd335487e71db821a8dd1c346ae2c15a413f96cf30b5a74eaac8bf1a1f4beae73750eac7bd74b636110f2e91495512572fe42d9b9e47f79ac224db4c879a31b7c06a7459fb24632277eb5bff36a4227495ce04f3501c60b3a7b82e65f58b9a9718924efb67eda1678789718f6a4a008a499549756d2502d925a7539bcd8512e503080609c84aa7e9c05c88b87219c975a1dc6d77566612e7a4159fa8483e07a8c0fd75581cab8fe25f964afcd2bbf0605b576b193a88a263ced9ae623aa29bcd7010c28769c40f4940630ccfa8abf52d37cf72f231668cec268c62ae3cfca0b939513b56d9a4899171e6375032b5042feeb0e3832ce9b6eec66ffec12bc35aef77f102e218c1a921223a23a1310215e36eb448d25a1b51349da69538ed99e2fc62ce0e1367c2d9653c7498c4d230de5ccd7e3c4ce1bb48b655f6020f52b9f2aa4156ccccda0298584a9c7f07d26fd3e42b94e70d77b13602cce04f701c0cf35285bd00b8b9c51a8c6c9719bf34c27eb7b8ea5f8b0fef39dedafcd04843c9ebee9a17b082272f5584ef9d1bc1b9dca15b2ca622369c2a1d193ea9dc7ee01ff081e70bba45473259ed84a0e382184a08786e51b726997634f0ecafe991ef0565c4d5ccf8904ad92007e7d141a3fc2dfeceea37d83bed832c845ca1fbed412302bb1631721aa42396234e67d60db29e119c1a84933026605ec372dc1e44b22e815d76094de5c84c79b863f4ebb0e07af8f948838943b91fc07063a064aa548471a3c2f1a9439d5988f0db729c0560716e6b3783c1f079e52c6a937a6df1ac3a881c85337d72ca87cd6672f672bdae57e6bfa1f133e4d0a30c435932b3f3d47235142a40c44269051594c7064dfa105159b9ac68ef91f81d8515419f7b0e69a8bf66789f1876f59f224de7882894e73b55306773abc2def9f5ed6d2e506b49db2b8524e7435190fea9b8b0941e9b65f9872b7ba2e564f632fcf58dce34c2e6fe7939cff8443f6ba10f0240e18a3a668dc26b03f6360469c321ccf141ec95a27796734571ae8d7673c89596d53dcebfcd4ff3c117a82f7d7e290b6b15a23fa8cd3f7c5188c640b85fdc7d485944176eb86274f2889e9f1083f38fe370f5118d21e2c94e95c233aa3f7c9b3d90117aca336f7b70ef5fbb6f8aa880040375c92aad4cc237e7590ac10f5a8162a05414fe1e45527251bdc61066a50b59a8d4c21dc426f1b8059ef8b16da4140e51e08e10bf8b3a8d52cb945f8b31fb06e64d8b4fe5f9c166a5a9dfa20fc5162b0a38cc7ad1532da9acf7e07203df0855023edd6d82b8ccea88e0870afbe89d9310bde2bd4c79812e8c44830878ea88e186ded34e4586b1b9c54d45f807e43fb476cad16da5059dc1c7f95c1b64576d323cc8a1622238c6b44f0a7da273d0fc4414580662d48c052065e331954b4cc17a2c1c62cc0cff09763079c050328cac586f723cbb3478f65f2a646902fb7317d906f6a7d8cb18296ce4bc6d303fb7113c729a64ac09cf8827485920bbf81e1e8465ccd4a245c10865905ca8ad6fb2695463b45f93abd9c4901365176c69b8dad939916d69ced1cc6fbb80491aa8e20b2f6b032ce71fb6bf31f21c5f91d618f10d50459a11f0eb0bf05ea87ea37a8f3a04622e6a2c098da4cffb8e3b7bd613da8bfd43bd834addbd8ec13a20346a478668940be80087f2783c84bfcbaebb4dcd2dbffe19486f6805c12ab366df3030f65d4a94fac7228ac92b0ceaa21a17cc81ec5cb3489df67f599b454a6e3ef5e9bd54fe4f82170b9d885fea101f964acba29395efc4272ca5d99c385bd48e98551472499cb40a25e9973d2177d0e9a1d019d7d3813161ca9611a14fbdb029add36cb518633a13d8f63893626cab83df085a92a673a4990645c2fab9669855da0704b8d9280ef358bfcdf1ba22f7bc4f2e91468c661e6ce05dee4f3b5a061205b31d61425bd48a730ae9e2e843cdfebf87b9a32736a7419f7b217fa9d1dd3dd2ea7f75aa8c7807af05fd4c3fbfa01edcb6d00c75a685f44a7b435cbbbfbf0021823685ff5cfeb251c6cf97bb911db30360842bd9861b77f41c26cca6984de34db82994dd5afc3e9318a19fceaee89406325e01797da6b08c386991893b4b3c304d1b0e284ddec60522ff0cdf8e76d2cb5c24f8201c44f2e9c0211ff183b32e06ac897e2a8277d9abd35d7432721bfde1c65a6ae494bb7ea0f6bf8478e9e67c963cecbc8f623a14333c0e1237adbac727c6934b36ba1d695cbf8aa7db02468b8ca9f4c780ad7d863a48ef5939b2fc34f18e54df1f6872d5fab99658163b08ca9e3fdac3656652cd42839e2bf89690fce986cfecc13e7553c6b9b1bbe0b76c0356be1e644fe1e98dfcbfb56c847eec7259498426c6ab12c7191aeb62f5f0ea517b59a27d032612304fb1361ba5b71c7ebf395637fc526ba9a63b663ed635ebb2a06980795b69b6cb354839d9826180d2ee0bf310476e63189360069c6c3e240ee70c4203ca301feb0c10a0b59fad5c006701e311ac2e70a8a6831e51f300b08ebc245b51739b282714207416fe865ab7ec5935cafebca40f28b6fafe51351dba17e65eed8fe639d95cc594db25f87738b8ab7d1b738fc6f3ba3631f83f51c7c155befd103dc0957d811a22cb255c7314066167f91ff4f57fb7989324320f89b5946113d1d3f84738bf07077bd2361496e3cf0dbec586fba6a52e6928e0e575e9ee8bd4eb9caca84352e333e206ea542e43fd692b15361ab7420ca8657cdd799f20345ace2a8b4181c514071307a0d2dd6eac26f9db69d2e007c02ab652f2c5400e19c13a7aff6665d7185440095b770a720d0427d5eed35a0da3ae7dfcfb29b3f8cf9eca98a68038fe79eae6ac5ecc849c9d27ad37b2f313c5285c8df57d75d99ba57f7ac5a2dbe7a6785145be1f1991a4e1fc399a662b03b41a0db3fdc10a9104c61e03ce75726ac3a28286537e8f8c47dc332d6008941451b081d728b52f0a0d3afa9bfd32856905a0761256b8b53aae973de82fe05179a1e324f865b000e282d052299aa32eb5220c6b20660959b568412590de394648c8b554f8330a8b961c54c2f88bc7f695594a2299c843c8105417bc2befff4feb445d2dd8b6bb567e7e54c5cea7c28a22d1d1abb418cf73b819cee450b555bbcc51b3ddc732e37fc03d0496a23540712cc177f89264b076d167ea428b8b4835742be0353df10215e7986f11237eecdefd2db31fba591108ee6b48211045426976b521fe70a7c2ce6593eb7b2e20902a32cafce67a0c0248e12a872a2c996444fae098aee486782496dc17a3750a57d33742479016e26b02c99be7b6c6a2986c8194180a9da7fc2d3ec4882c913aaa313942e3cbc48b3db4d21b9c57d3ecbb41ad27178adbca9acb31e58906d8858f490c6234e3c159f08b876ab8c511a03662cc68f87bda65a7935c25b418c4aee33b871a73f605e35e1a889f7c6662fa664c9e8ac33507b0405e468a49db42d9f2d8fc7c2740168d7b369921510bdb3dc1b2bf7021c1aae5164642e12a6c67950c7d653404f9edf1c10562215d819e2299d46d71e2036046c39f575e9a98f62a5fa0a40b04782c083d68268bfd79d352b999db37c553467fcd77690260dcf384802338c80ebc1aff2cbfe81208b5b2c9686e331d58f0080f8f2c2b39a0cc53061b0a0e66d3106d417c28f05a7fdcec9a4e3cffb5c1a356a6d0cdd51fc1f13e1bd10e0ca7e151a920d81ddfa51eb52ed9511bd19573f3452331a04321ea8ea7f6e4c15ead6196b4a3aa491739198c09aefd080797fa9e82cb710febfa912ade9b7845eec53b6a6f4819020bc52a5cec84a9bdb2ae2ef82607f1c5946d6ff68689fae4939583b8dab0632f931737d85cb008410f10e339c0fffaada3aa4a1b9a15220ad6adf0b68972006d584278c74b1f73c140c4dff85e74887f653783cbba8b79b1a1fbc579ced8835112be8616b6b7b81c989ccdbd3b28ebe8a8be4819c0511a3a57e2ed9e3f530c0888c6e5d07b1410b8be688c11c132399d5585695f8e9b6afe800fd1f26d7338d7399dd7e8ef123d31bc87ce434d21426f1eb2ac022283f7a0d75c433ea8ea1180f0d221dd4d0eeaefed82ef6a8cea4d6d1136fd75006f08c762daec44a5ff901d103f365f08c1f0b1141fa9eff1778029d075ddcfab1ba7a64d8d10cb1b335d946e0b9a306679d80c7c2c71c7474dd91fe1be208f77e29d827a4485aab7d4919fe6fc2dbbbb2be53046c3a54f4b403dec079344afe276b7a22fb2c8e2ca5889dd2c716c8d381e90d904ed121710c64f357c54563cbef9e90bf39a94ce22aeccde90cf97f2f04d5791df9f81dad30341fe009f0b8d54b958921123711928a5ab75d0fb123901bf07e4198b6a6d200f2ec4e5e43c798e7e3cd36d615e6e755f403b9cd1cb167de5eb72785c071807bfeaf9b5e12f6a928bcfb9803a2d306516ff9df676e485e0ac97b0bdedc751804cece19b01c124823027629e43e131e1ed21724cc639dc71447e832623eb5eeda86a924c5cd3baed2d843c054d96f873dbfbf5108eb361ea55a6c4eac0840c46ecff6f9732d000ba7025d98f810f96998258e2dabfff9f8f54d7a9d1ec662092647a6a9696a5e3312f7868b20c6d013a8baa62ddbf824dd609ab152951a6cc51c0ec1c7af1ff0d5ba7d5a4b3399e2bf8e994648b91fa650e06fa3de46608438baab72372094a0c4eff4bc4a972be4f7a9be66d3e6ec994e762fa03936e47b2238f8fd4c4cdda73b51f6a94346905c00fcda4671937f92f4a0689905a3e5379519ef05744c008e980e35e0942c37c39d3eb6923fa6f1b30079d43b38b3929dfd7e5a891c6b0dd2bd5cc0afd9f08abbe0ba0144826aabe538934b71040ea7733a0076c2487d2dc308f4016e93aa282a02afce91bc8cd461f26cf6a1de741c7b7b35980179a5d85e490b8f744fedf35d656cb9ab6f4c000065790856ce323e5d2d31afdf64871a6361d063e360ef89b2d516274d48589a4cd1fa75114df338b21bd98aec1482394d744683a5a1b1e2e6a90b6e20ee854115309a9cb7c236bbce95e03965d010442c05f52ceee67889c75b4e86f7424810d36bd9a0e1a73ad702ccee5cc78af9ec6c3b38fd68b15ddb5915408bcc28d5b81b020c82ebfcf1a1ad68c324e6ff66bae55d9d50a64fe366ccb157c649b09f85b2054b70088de84f294fe3898f7f37843202dd83b7c7101810ab58c1a9bd3f824b092ba0ebe24415932e3d528ace4ce9e2cd3ca815ff364a40573469a4dcb238f0e657f01c3e5e1a80c2ac64b7586e17ce705084d3f7aa511e6a4921851558a067c130f452d465e6e7fc701af6a2eb1dd5870507c37b69d59cdbf55561526ba21c3939a11eb6dd496bc95adde178f04eceb2d2d6b1c87e79427b2df8336bd5babb98f57643b6f8a7b5a50cd1e08524133aafc9a8c4abc94e5c56d93e1ca82f6e3fb2c76506dca3aa637ab40e17666ff15b036b745bcfa519fd67e87158e2c77b8b88d6d2119f3601a8f9084b613ecee58d439c2415731731c400bf638c17f06604a2f8fae6c8d157a6c14935c4207f64a5e104c81bd32f52aa8a60b47223add8b8ddda14ee9ea0d6d804e2b706fef62529eccb5f5f218bd6fdb1bcfc1244dd8bc1a4d21282d76a75f4fac9feb8d7ec1325c3b1fca1e06aa8d9320b07a6bb00abf5ae7c478bfb9c85b6a92d31be3a8cceda0642ec78330df053ada002f57b3055e4ac52eab7ddc8c16b2261a4fddfa43af7a03b85b8d6c45e6f95d061f1d12e9566b60a0f32c30b06f4729d0f795bbac11da4f91a895af3316a7d4d28e3306af7514519465445f83adcede8355a31b62cfa426e6bf5531ddb265841162578c70e869036e463f0320b7a3192339d0cd110735b1a65b176f0c5624ec932316225f0a90a260d8b68206703ce013a74b2d2f387dede2bc4a72ef45d1d8776ad89a7f98a09268b77025270c8ef5fce708062e0e3fec0e683971b9b7bd5b25ddcfc45ca95e75ac9d2248ea9e168f65317b4a95f5f6277f42e6690c6bea95211244774d1267431e2bb94ca8d71ce6c3b5cb90fc911a2dd856173c5fe50b923c5459d7cde4d103c69ba117218c43dbe256757013837e1dfae3c2ccee093578663a676c38ec45b2f9db664ceb86d03b7384c2eff2a295bd97f72a11e69950966cc09db4f571c8e3c3009ac33664ea9ed8f14d590d8712f3ced28662da66f5b1029856383e68886ef4352a626f90fb89615eed593d0dc6330ca7cea83de1c6e26fc1609c1ee7f942d7c519ef37d6b866ab751505138b39ea0927fb1a28272ff24daafeaa4943f0cd9eb006b6691701a3b3caf88bd4dc7120fce6fb43b6fcad0b9e18da61612a76dd935a241cc5f732d82e9cdcd29b46234aa6d708e8df9151a537e7c087242939e72e6cdc1e4cda6b25832fbe7badcbb2b93ac0c14cf4d9a7fd38a757c9114239370b93595a46e25ac8f7f0d3d9cf537f6056be2906738dc1bde60223fa50c1cfaad073c17e81b6fcc45def46efdae62bbc5f3da44c6876db5e00d07e7c1abd0f460e8ef4528892c80809b2ded1f9e7527895551a289b39b46e9b8990387bcec930580aeb92d4803f7ff72f5a323ebf4f50b89d20aa04abcd1cdd80ae6c0efb09ac370496ace0118cb3ccf024fc06c314c919272284e3909c680b6045fb94bf2e0f27bbacf928cf690bec8ef9085f693840a9792a38ab405d2fcab86320a48e43b2786829c6cb006122b3d86b806dd5af923f1f6eb6083cab7ad86dc2db1099e61e0af40dbb4c1977e6e99f4f854f05a613cba792527d8a21825d5cb1a1e2346f8755261e75a96fc8f8c23f4452aed3f0496477425ba678fa1075feaca5ce88e784aa61198eebf5091557abc6c7051c4264b6614ee18e1d920b820e8ca9347a01cf7c928b89d947a37214afd666cab739ef1cdf65e047b739d54c9782696209ac08acab7ffe60e7fcd3ffec27f6d53fd859d4e1648c194ddd81b258c8d43fc93d08398623b7baf6046ec43472451346c275b01384655c3b97db7c0a9f8073c08505590ac27d6606509a602832c8c68098aa88b946345e1133e2049bfa6aef70575cd70b86afdfb7697f8f84b79bb315a1e7bdfb6028f4f952dfeb052d253540bc1ae0c40a93833e281d5a70fbc4b50220f48e661521c5fb57f02746dd58632668f2c802ea9eec73a156aadf64681b7ec122e551fbafbf69d3ae13ef547a6166cb0b2a7586ccfca5028a292e6fac595a1211bfdc7ac9e60a0b8863d259dbe6da5092cb57d001d339058c2944b38a42f734f32eff6cf5e2afa392571ef148e8108c8f653e08bb5e80c82a80c833d138b85a949c74baf05719e1527a8c2e183d8801ffaafd38c9c429ea0f7707218878f3a7228fc8a68e6d6190e2b8385579d594a3d07695a91924fe6cff9ffc968d3fe35186bdb62e7d42873b1da458213207fa475b567de4d08e7b1ea4311ddb185035981d4f6883479d71a7c78fca2158cd7646f3f3ce605bb50e5c2c627140de031c00a23639f84b59dcbf34daa7144c5b71bf39057a3511edd28477db8b64eb19897eaa6a1dc31c688a07061cc1c60e85f82febc3458d5a3a3ff3fdbabc2b665d1dd3ffa307d423f35913884d10be938554cacc694e71b0a5c94752b014acaef37320ed3de59fad116c7d2ff3e554bfcda88d0548b6a36fae5514b18c70cf9108d438cc081cb3c0231609417c996d98e6608c9ddc12a4682397161815e9e82547d7681f25e5f9ea3149b95f3222f9a760be83a826a37fc7bbe474a50099fa8d1b986e546b227c5e0ebaa43b0c2b3cf9749959b4885bdf0fbf41e12dc9f746aab2eaed26c423b368d97a0e7354501ef897e0b7956e8af0562748e85af61c301d6ba9f55334fb7da3e09496ef1ec0988ebc7e4525fafa1cd0934972b91f5e6c6c91a0bff2495890ef423a195d2cc27edc13c359dee313ab56900279e6d29320db9bbd2c8cb58941e6b56995007dc0fc26a65e45f44b0e6e86a540f6cc1739f4549031e298e3be225b05c2c3b8d826dd52553f2299abc8d15f89b2fcc94f30fdd1b43ae4aaf3b562f6a7954907eb7c17774964c62bc3de4e6c7b5a9f78538f8e93d303802c755b0727a2793fe15db8fbc0f145c21504aa0f4b4a48267ad41d52853e67a4f546c8290308c4fa029c3abcc55befb5fdfb9f59c5a1a8749c3fbd440876089b9de51bdc00332491268dcc1d808aebaebb82954303de8b9c5cf8f771dddcc9fc0ef688fb047d7435d71c6c70e9b9efa3e2ad9f126710fa2ca6aa191e66f8fd93a82043304286b9785046506c781c6924da9ce2fdd036cd2bd28f1b5158850978109be2ee8e7491fba2bba987561f12035eaf7216284050c71174fd9045aac533e9d7c976d87e52c44b05e28b9deb925c71d91d776a7ded10ecaa205ad45ce3a5eae8f654064fafc0e5dea8b8cde0e9db95e4d5911b2ed12755b4c67530f0a29388f8b2740941f296364776ee3d45c8f727821e5ab5c0bef76a2b85e987db2d90b4ca66f887f86509a283b681e3d5aa23f88ea407594fd4f0a90d6ef9fb07dc1fb680f4274bef8f93c95bf52a1332a7799f3c999e7c8be7dd0ccc85dfc7cd4084b2377db59c02574b5d6050166149d294b61203922f7a67b53315187e9d852168c9ef5eb6d01f92ed78ffbd28a293a79d4524244338349efda9c3d3eef5592c4dbfecb7a2782823be56dfc58e22166aef47a15a00abe0521ccae3927d2acd72c32f3f9023032d8705ffb4576849884686f2f24685f6338dfefcb4209f0943b69b0a2c81bfde3fd2582d94586afdca7d5f62a4ba9b2423620ef06a75eebb436a37134ecc6c239dae0f6f973101190cf27c33af368d5259d76b7204ac5bb16304561ac51ad1934bb619e02fcbc58434481eeeac9bbd2666910af2c0f1927b0e743661291e8beef90069b593afc9cb1cd16fdd622ed6fe656d667d5042053631c03ce436c1d2166fc2d22ec7f7257b04cf9a22acb59701e331351d2f06f8119a50e0212479dfc83631d93fc9636409a5bdf876f0a4f899ed5ef8ebe65b32fe95bdfbe4b3c92d8ed4aff2076db5d4e289b7edc29b88d1d1698f3f8e672c78c34a76ac3e709829f3014e42bed88987b27b48364616d183ee35d07d6242205257427e8027c3fa4d90b9452944b981437abbce5ae962732d69e31092c4897f79e15be9c29dea483e4abae3aaeb4e46925276dc03030db7027718b5679705808cab0cd9ca0cd886bff5856c667b59c44e07977efd1494a0cc9d60b7c9b69382822b3e244d3d1ed61d92c5079f3a7632fe88e0a16c3c0e3b3f40b63dfdb0355b1a71326d2878d98191a16c9dd8247befac2642ae5503221fdb3e0f2be90cae7217707d55d815ec03cdd60248dac9264b011c2cbeec1751b27e7186fce87e2675fe90c694f84b65a063b4a96e7796aecf71658e491d768467b5b808795db96fd3f7ca6425b5d4634e5348ea7557b11c06d82b7e266bc4d02b1163c8f3b013d03bca4af923f2e2799e4a7042abc8fcedf2536c7350304799b748cc26adef5de73eab2695bb7eb8cdf055720bd14172d863070868b13067f572dc463a6238df293783a65a35da901a1931482d1b837cc5cb70315f287047abf7efad4f9d218f0df840e10b6338342ece6cc44c43575995ccd79673394d803fa6d1302746b3b81d3033bb91969b86976d9b8f66ff21a38a88eb33d273b17ff3f96ca84fa831914a1a3b1f00145b38d5e19bf32498418dea580a3fc3b0b76263e2b8be9b224d291580a097b3bea0a9cb51906df0e637e5e334f47acaff165bca23aeeec7381ca0d353adba3e386cc5bb14d045b389ee682f1f41f0aa40925a378e8b2b4ed82d32b28352f2d5e400a3381392969b4d067afbc82906deaf299333e8e6b54c90b0496aa3452d271e6bb33438a6b080ae72919775662fb7b2d1fea9fd7fb14136ced5fbe4a180787a7e7d6b715fdc5c2fa45160b473708c4b28fb8cec68b998e9a416f3d4b83f25720c40ee106cbfb54ad28b972bd42cae21bab601c6848e70807160c5266266e372f848ab2ea8ad98de5a6b155b86335c4250fa80452f2410eda4de27776fc673de06c283b0e82d993a335249a12037d53aa97c3dcf4097b8b4445f66df1b175eb5285f4bab8a48a1936bf68b716350780ddee5b3b9dd273303d3c5f0a14c2a0168375f84881f56d161775ffb5fb3a3439439b3bf483486f2311ea5f6ad42305dd8504a30b9b5892b48a1d63e0119d2227c352769b6fdcccc7ce4ff12f437fb50c3a40d8458302322acd124fe1e37c3c01d31ad4891cb12d6837c949e8aa1743fcd578faa5989f5d5551eaedf5bd7c2eed5b6cefca94552a6f62d04bf624e7436266f4ea3f59a99709605075ef307b0a490b71adc13278418b812b69eb9e07953cc05ef05cddbd447460e100329e782b50e8544317334bd901c6ee4dd344f28a91ad31af7437890e93122e03b5b4f50bee97593ed460276357b4129ebe5ccf028424ff5845718bc5f434fdc87062985fc1983682d4d2dd436f314cc736e204adb39811a3b66ef5bd3bcf1c343de95aa5fe3c0e0e61d34410512e7c3d9f227b32c6ac7695ef601198a27aae4831a61daeb040844a86e4b81eab288d16f818d507eb1a491eed52eef0478d82b8aabdbe99ba907d917e20df9860baaad78d4c7aa7b27bc1b205c80395764fc6fc9f5aa325314f6c4972eb70f55868beaf958a5f451117a4c89f1326ea5da21d54bc17294d9a2d5ebff7b85ff928894d5233adb1eb3ce40375d1c0891a234b6d8ec003ecdf03b41b4b9deba0875370d222e17ccaa869e11446312cbd0b3a13d6f5ea7a9c101018741c4651e89f13951deb2d12af919df9d145b47eeb425f09efa95c0a07f74189607bb450273904baa14c294b4ee6401400e03fa42cad55bc8c1419e1542bb1001669f29e8556025f0206e69bc2e293414b716744329aa3bd9f8514d0e79a072ab96302dd0898f49948e3107f1c483b4525b6186358a3e7dbe9f04b30db961abd3f2696b7df905138dd169dd57ee004ea8b48f9692de3cc22fb67ae2efe7780531d95082607c8eb9c1db0d25139cefa75205dc3faf5511369094a9cae2b1e0439a182e8cc147a70470995c73f5727a1f25b92a7e1bf743b90270dfffa53ed9f899eb28cff14e9b3da3098cc2f4848fb577becf57007e50a0e0b8d01bedcdd892b3f02b2f49dc29d7e482f14fd4cc818c36c9a051e92fca8115a230bc182486ea9127abeffc021afdbcd2a6f639f689b4f59aa305bd0e8d34cb93f811a10e8c2d6b6debd66391c21c2db13c7b68948d787b7a65273eaa12ea4a36e9e48b58d067ced50d46ad0a26e35daa3d87535f545874459b576e628e3b274e2696a908cfc5378b5e7ff40003e882a3e52d02aaa598f0e2c2d25a82f399428c4621464f58d8526ebc0601096c0c5eec0c058c761639a4c4a4bbec14839bc81f1d899d15c69aeec01ae77b06cdef4f04149b455019e5cedcc50eba028cb5d924567c99125f41651c37b963fa2044350e4b4d689377144cc1702cbdc7f432f41a8746ca4b4b590bd9aa93d2e61fa2f346753b0163c5a780e5ea4436b3ab47e24bb7a51e87c4cb9109a6eefa4a79647cbdc1b2a5593a62c9dd9b7cd21d8927a7396c33a3de41d7bc8a2eafc328bdb224771fabce124396d9858fe6ab0b9ca372b9fcd5cd9e71f10ccffdf5df9c779eec63db5a4a165261bfe16a6e0dbaf0ad82a9f160aefcdd794f3810ddfd78102aad0c6409896056f57ff1502c5702cf5f44fd25fd08699aeb4d75a06e2ea2b9838c4e645ef16468f4d9338d66eb8a55e0ba25a243795300d0dfcf9f9c232c488b3791c3facee462c5687d1bf7c60d8b5ef08d142f81024a5e6e60459f0329f6e7415851f246b983110dc8d2c70a3a709a9c21543be5f342a5e2c19345d124828665cbac2d6bd441d63a9d1059aac93be5323fc222bea966d1417d0cd3a6eafb3f617b3bb96701e6dfb56a8c4e9969d21278d1b1743c7d13434ab0fb248a3deb35e4f660056107f4c042252018c68a85029cb2cce12f99cc1aae8368b9bdc3ed38292e124c6e6813bcd48ca4bd68a79ef6a29a3fef34c2e8ca955d0e517aaf5308aaeeef48351c3b77a870df337620cd3772099f22f73ec3618a371539e028cf76ff5e14a943f87d6de003bcbc7aaa8f6935535c8396fdd61f4f87c1531ff9725d6ec1339bac8d1c596c231c3aa88dc55b49ea55043d4f932b6535597dc6fbfd938403f4196c9a24ed5410bf955bff3debf593b9e69f079c791657da04d5242415dd569bb662a01a0ef76f21acfc383918cfbab6bc567099ca4e23736fcaa403c5295fd5762b6d96ddd94057deb52b2d30d1ba63cf4c8916b43f2a8cba2dbc96ab7a7cd7a1e5f143b859a100bc2abc1745a905aa0997fc34691d406f77da1001a021af9491a1745645726e20cb9bdd8c5e649866b6779673359805c868c908620830245e3a28fb429952b31652989e27a38870a842241195d457dfa8d785a509d82c00ac067d01470c2db30ea43ba8d652ca1378af93e7e206246991a0e2c515b3db217c10f68bf89b88f18bd52c8bbf76b41b23b3b71990df8b5ceb874bca13894f8d7106a9c470607d193589a3c0513056a750ff265e8f333da7aaf74b9d5d65ecf62d6ade174eda4e2bcc3e836715dab8d7c444116d2d3ff91fa44dcead161281049044f477d2289f8b4a559f8534171373c414e3b7f8a7ac78193baa83ccfe5fbf902d3a8e0b6a8c454c3f2eeb8bcd53426ce35dd57a9e52fc6c4980a6901fa55c0642ac0c4ec8f568722ab447c37e6537731ef290e135b553fc75202465d4187d64c28ec6226703dd66ba503b99e8d6fbf5e5448f31d03f74c67211dbf179fd5ad2ebe7df84bd759a3e4ccedc7be59f08be28da7f642579059a51372ffef5f89a5713d151700c2c152b6fd534fdc457e1f909ac6524ed7bc85abae91992f4cbdc422d1e83c380d9903f61fe53d893e90ac1f11dfe0e6ce5aa95917e6e05ddc0dcd6628c5c6ed7814aa0798f720f5ab5a45bc95e3f4ed445c96aa8c6ef3900cab62d9d43a1b437f7b536d0d8eb7a2dac3b9fc3cb3be163c363600d1588ac1eda6eb1cf5af5fe6bfa7cb888753c8fc03ccf2366734338d57711bfc8a84a7caa99d7b8e51a92d5d70f74333df3f5e57d52b70a11e31460137add30d9342b949a672b16ea0a17301c89fc04cd9776fb8a77a7671b7417dd87b808f7b31c647032bd017f6386488270b16f641ec64ab5d9fb95daf5abac2531a0edda631fb6bd8b55e648fcb4e30d9345449fa1c4c38761078106fe0c0eca40eae04a0c13f2a3f750c1136753ce6a4bcd16aa67f1a07d757f41e0cd81848e869c04320cb036d848d9e21b8b776f9d97e0ab6163b9a26f7118272c02a7f0e4d4b75145c41ee3cedadb8237081a27c713641fafcd55b8cec152857d6d27aadd949a5173b3e2b46c818b1662e95284bcbe7cc7af411b72c3db76aedb9de0863c1a07f4d0fd4f4a91547018e78be40c9894ce60ad38a889aa059cc7e801b6a0c9a70a4b5f1067415dea182ddfe4fbeb739fb00d0495615f4b43f413d1253b7d26051a19156674578857fc1b8b87b3b04bda445489ce6023e9e9ec216a94708a51f336a5b9b309a054ef588a188a4bc44d7bcb0649d2463be30b4ee10221dfa512f453723574a42ee422b19e0713d99fc39c7a42abd0fb7be23235812985c5aed2e793ff204b6978e9f5662547f34579280affdc1929266a514aae8f022ca59f95dec37dae9b5be7ba7f7c53980e59ad04ab674bd650e77f65bd8dcffc02e5ecac06ddf154b64e9af202296fc46af5dfcf11743f0253b036e705b8efa501f74922d74c08dba14442bb3716562a0156211b0e73ede5e19394f43688dfc440a89d606161dfa8e1f291c78527ca239d2fcb5d24c7bfb2d4131a498b43159feec603e32dfa2180e3e035f7c5078308350e742d3beec76c94d68d4ffb61548e8188b824404deb369a134a479284af70312304cd896eddee7a4a7378bd42ffa739679493a2b1c0ca18fd9ec4e99616bfda76a0a8e899f4f6929172cd2fb43eb2e259ae4ecf6c415327683ea3d2d1e4c34cc2cf0fc02cedca7c6df4c161a1551ac5ba256b8d8bc0be3d5a1eadfd9d4c9f094162c3e688570edc471a7f981d96b8752d640e26a336adebbdd4e9c758f578ae6c413be4c056c3861cc2d0fe1054bea822df3646510d724954f55c4d149f3bb57eb1d813e970b5c05e351e36e3fed99897c733396271857c95dfaa1fe06540d9211ee1131029dac2d4dd8ccbaf61bc5f65cd7fa3927b2943b7d3706ee69de036769b93b64caed90d039805f57817ca1a454106fb51475448060483a74f0c9009578c549ba5fb484b60e158925d5a23134873c8c1e032941c5c494769afda5124e749b077922e6d8d30a060f314ae6b9167ae374709529174ea538a7e0216be7c292192ad2d4b5e7f7bd880f2b0dd683f3f38a1154a4a30bffb8bd244b1480bd5ee7ac2f4562dcb25754b18a5f02d1af1fac20e06cf3f324f7f8db4f5151e8a77c5620025ecf9c2a9ee883d0e0512c07bcef502640eca598f1d2215d86b259f538d04c7c741325eb3ffd26f209a649f3ef27bd27fcd8cb338e8aedafcf4244b0dce30111d781c8cde5bc3efb337cbdbff8eec64460806028ff3fb3efea7098331a4b718bdc0322260ea2ef46894be24dc1a371cc299537a98025c6c16733c91ebcad18eafb747dc1b02173e311378cdad13ce550ee722af4d1e488b34eb2aafb89af7a3d8f809a1d67f70f1ccdb60bd1bfb8b91deeaea37086a62b045ae5bf610727baab835a426b357db1f6f9b57393d636cdf98ae604b78812b5010c5da441c91a2e22d208250ef79b3f5f172496683b2386c890931f8eec1951c1e4eec56042b7146ed0fbe471e5bb8604754bac3e00d3ebb134ff1df41066f5d9a827e64f18826bcc9917ff05700fa81f97bc17c2a7f3cfc11e5fd85d21d7ed8ce3d985be3057652765c0ef2f6304f720e093c0c32aea953c36e07ef5e202810d0a9162b2e18535cfc997fd0b2e30ba8a6705df57a7d20933ce9c06dce2a6c4273f09f1aed875b077bfd60aeda7f1081e1f74cf302cba5b5b135ddb92fff3d0d37cf38543dfeaec81d5cea51796f518183cd108d380f1769430680c7891d93101dcd64094528b258e15064254bf0cd9f64c9ec2c98a058ac9474e67149f265f779c0bdd4def55981f51ecec0a960f142266f4091d5ee898b0233d79626b789d83e29cc93b7898552122a934cfd8423853ae35555c6748bdfc1b94721bf90c4e8ca503606c8db3578cbb885042711df15ec4662d049943f68aae929e0e34b66f4d8f5293f84fb46f523cc43642afe4df1279b89ae48534e5ecded88476dae59f65d075d1b347189d7ad29245e4802eb389fd45055d07868a62982c2a706074b5eef2a5d7701d2a614e5974d4c31b7d8f132eeb38cbb1ea1a040f04290eebff40a0c03f48776bef9cb7a39e67eae03a1edc131b62de366d6700e91298c0345272acc83b8b99164cb88f18815d81bab75fb5b7c08bc3a1437c9f6e81a5af65a3b575733a86274ae87b2245e90529ac5561ef1fa781ae8d5412083053d4d7c737c4f4a4e270de2b97a06d6b25fbee284f5b683e9a2d758538bf57289cb150d05b8c71826fd05b77a5f9cd0957ba85d313e19401dd9a2d21290cf38c0370b2f27d5ddb07e682debf0bdd5ba224c41cdeb5c527d3581fdcd5d9f9fd67606638f687befae2e7b1fe73ca761d80a0fca78d981aa75dc6278337d639b6f9c8b6c5082d91edad26fb29c53e804720512fbe451f0f60d466c8c128a7c8530b56161ce26e1f915926b132c597d6fed4aff835a8dfd63649f71d879da01c7555fde4601e5074b77531c492fc521608d9306bfa767f15409ce38fbb749eb75e2ca1728594546ddba688b079ebce3d4a6a9e6c6b254e09f4b5002600445f741f2095d782cf6efb35809716c853d3ed69c87291e97922bc6a5703b23bc9f895754371abc17ac2157b461f0efb3f3858e8c81edcd18f2a5dea6f36b0c87695a39f2d9edc51b02caed87a01341a2df70292f4280f6f4f83cfc0c6bcba0bf1af7fe8378c9f3f861842132c5a055942a93e46865d4d40aa89605d7ed5b0e63044d4600de2fc40663e49c3ec9ad67a26c28905f5818ce67facb6991c83499ade38dd7adbbd7f1957e430653c3052b74212cc221b71c996428a61452d8dacd735593eba505df26ef56538a2f77a0fb7af612ff0fd3092a84530f38f7963bfab0525a74bd674fb1256c68d6eb88d7cd75b29351b31123874a322b786a98d90c8f1baded23ba2ecefcc5c77f610eccd4c001ada804a454d9e8b06f6041670187c761e4d324da03be240c1b5ef28d1cea6516ee91c3cb39ebaa15f1a985d82a666f55673da2e587a85067abd20fd87dfa121c1485bd83292d2bd5e9c3b943ebf5a86d85be540d339a37f9ae8b232fb9ccf1a68d93453e96038386aba47312b19b6d44b5b63e918acbe8a2dc0b80d6c6466a98b4a9c57bd3bb10db35f611b834bd5df31ab7d05f1d86241593499e7f748c21c5b132b9674c5b05e03c742ca2bc03273b1deb5ce9568c357b91f58fd5be15cb160d7f0c98e41fe2ab4821bcd4ad07501dc796b8776938c2b7eb297ff7b76d853797504a612d71967c2b8d20f37b1abd6d666282e2fc0657ceb0d0c5561c766205533bd971262723616ae6e9e466f4a50e08ea8efbac5f5f793382de3d8154822b4e9bf3fd6bc5df9b4a84fc01e4a9eed584a433601cdee0cce3a6072372b18b786ddc12eea0f6d000dc97052e83fd7ce0baa1bd375b2c1a6b8975ecf2d41a15b7837ed87cc4ab567c7400d8bec818bbefc4fa000aa01e812d70ad1115cabcb454c4017b089a3cc3a8e53497bdb083490c69a4c800f5d93df1201c1826b4b9e6ab525f7d1e25ebb652551fb2065ec7d2a9b21cc35e995e83946115ee685c4ff8bae58083e1cd915e605dec900876387de7dc63d11b34ba37d675ec002f06fd6d706ca4bb62505e30171c9991c92fe55e8a2101c0a4548a282789c2cdba99f50121fa6d8b97b1a54a82dfdaa8a98faf69421dfd28092701150baab1785f4c81bd5fb47293d4f3f6e5a08953dd644b874977620123753e28d6657e09df9059961ac4cc97dd9e76ac6fb5fd0a3f59552bc63bfc87636fd347d5eeeb0e2544c220bd484c84baf57fddde0e5b9ac49cec5703f44ffa495cd7056e7bbd0fc9164cc81e5af8a63a09adeeb569f2a7f503ac3bcb34de6be1ad7a4d149cdbb32dbb2a067dbeb9c56de652a77819939d64c5734b5bf4ca1e31870c606b53a9d7ff50a2343c52fbcc7abd5729f1c3dbeb43dd2c6590201bdc052ebe27345c4ef8031c0bf092c08c8f88009913f3d59b00ff10eed450da7ee7368256da61ab3f06cdc5cf0fe5d8c0aa7e57cfa1e99ea7ffffd23df32e166ae0be918246ee612839750a05d6118378563d3bf55c1638441ebcf92f6ded7cb561acfb6206ff51f5dc0f4ce1c5b346f8b3117667fba99d6f0a0715ea93fc3b5cc41fcefdb357b762ef24b1b1f2222948159b1b40aa97a53162e30f0e31be03d80242983f05dc210d6a6fa0bb0595fd61e33b059a0a1aacc696dbda1f6cb0338e04839a951ed11bc9f50310743e722e8da49b22a6a67535c600458f9d8e7c5f0547c26b49a057b867a8fad343c42880a53137104f3420ff7ba2762215c7de1335215365ab0a92ad695abf8c52aca917b464ef73f6a8d6e77a93ffcb8ae3023f3ec4a93d9419e4c916cf6681e9cade7f9e47b7607b30fed33b6dc007a9ec1bb27c82c1e335e86e145770a4c362b78bee8678002dd73bde93b8280c4871a79ab823a25974e23b895b86c22f89b241e109f4dec384df289630e568aaa8c62d1e7633be5757fccdb864741794b8a43fca58f43965b44145c433","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
