<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"47b61904e1c79533baa0d5025383cbc65543f6854d93a6fb0917110c0eea5b24f7eda2086adfce58bf6281e52eefad58baf77e303693a4fdff4f700745262c9848b2b574027a1d3d51a2b194c89ce9c452acd7aec3ee84e8c662972623201d0c2bf57f8b9df34dbeb0f28909f306e182e3d99f3b043653768e95b49fdf66c98d475fa5d935074b7b812021c82a49da814d864c4a6b9de2b4322588483fea38e85d8d13074670a19788b00abc4911ed8ec605673ebbd71aa19cb3fc1de27ed133cb864416172b427205ccf92fcfd89da0c336a13048bcf58f9c6bb9f5e2c4a26b5a33a00a52e8ce361237178edbd0a8211b1128d8af964ba98f4e6f80347d27d3c0e47df2bbf5b5b73e1e659e840f7f5117e9d22b8bdfa8f4da87f9946486d4e90d3de5005a99e096fa5a750451428c8b43bb9b33c0719e4f0f42ecb3d002af3157e4757f34679e808ff08f65fd6cee5468839b198969db4227d25a5ead77045fb627034120840ea5b1dc6f02ceb213cd51677d06959421103b6ba3ebc78f01a1a0d4f848240d2a051e98742a515fc75a74dc14442ec4c993e9f0b88fbcae633922634dac7c51d65933d3c2b025d57d47e7e992cdf3b605c7cacb4f2333c2b885d7cf20ba89668601f0e72f7ce560d2749743765910827f26ee9aeb39000af6accc1d4d1131715211b8905e686dbc2d7c30b787b91ba9b65a65f0e38d39e91afba22737d3c2c746b4cde9e67cfbad1f35d83e4af7533465e4e2f6d68dce1e5e277f6e1f9e85a0d28a619688c418cdedb7d9e2ced666f197d4538376a2e28f1845d3dee43cffa2c56df554284aea9f39aa92465fd344e8d2910ab5f23c4fb999b732dfe1bd42fd0fc1b066523c7ed8dea49c7c07a7e877277e2d1d19b7f6632249568fa526a7b6f5080651572c7e12f988bfd271ef1e02572b6f9646f58bf64fe38703abb3814171346287317f3df5ed3b61cdee5f88d6e91b05747db0ce51a2635a55a5559d159bd2fc0b1720b0cd3becc3dbbc76368b01c85a0d2912a0643ffd00e24ed984282c14ef09947388341af779c5d263fe9e9ed6f33d6c8e52cc6766d2a07b16126115735a2d28d24ccf5e8745a634e71e963fa894bc85acba6280629eec569df78a58c04c916a1c95bad3ab3987a95471d493aaa05db67a1801e28ba5a1298b64d4f91831209daa44515f38b714655fe6786c855b914f6fc0258efe3e54618929189d52a454470cd825826ec20e1df50b03f9c411a9197050f71ac540c00deae4235dc69d88a1df22ea6b6790e963a33d12bc8d52c3d74f0caa5527082dbfa25edf286e0c171a7eca00207a4e96a357f8434351ab3df4fd3d9d437e06e68d361405b1644d14211f46a944c5faa812f82d5f2b75802e4cc1fcafbeaf39345e2aa735921f0bbdccebc9bac03b22c55276b37ab79768cd9836cf870c5035c1e4876c3b37ef289bf55a1630d78a01075722467053ea1d70f8b4fdc341f13ad8fec80d31f347720fdd23619a2b2fef052c5ad858aa0faee654a230c43a9964e97d9e9cfca7c50702eab0110b7f256890969af1104655cd9c3781894a9a32063d5131cc81fe6a539c96c97d6e41636f41a5d81bcf1f514e3bdb925536184257f9e31c4534e003a344648ba06e57026ea677d8681087cf252e40cda0f82f03844edde78779d0b96930cf6a713e6fbe586a26ea336ce4cb592a32e1266bc2c9c40af63e45b46f9e32173694e34ea9265dcb617e504bb32a4a2951c23101244972d54c659cddb88c01bb04b730647407824fef6775d2163ccd9c2a99722847b3ffeadd750521d13f1be91f71917b68996c025e880a80f139f66d8760263bf9b0f3583c94aec25b126dd744f342259105d401cc5100d4141c4005a5b84ea15e6e7fe5006c2b4cb2e9173da91030f3d173f8f57346d807f1f3769cbb1ad84ef6a80d1a019fdc46e43921a4d0abba163d1de6688a639eb54e3630bc4b414826cadac21fd49e66cae74b19c0090e599d71d9f96b78448ba8091c862a7a46ae515d106ce8ab80123d43b4135318f8721453582b386280fd5431d0359f71435401c8281f62a6c27a5c580011f1a3b82f12ee8b5b7391534597ae0685fe7e4808d070a9e6998235ce9cb041212d31f954476830de3be5d39dbf84fac6beb8116a8cd7e3861ad818842a343c3dc06eb1354bb034a5a9fe4e2cb7d4fe47f512298027ba300cf159b1bc1612ec606ec4dc87f9b84eceb4b7762e077704cd1a069519dad8295f4206e3ae4695ac30183475f2c711f70e42767e963d85cf6f909c4281686e56e4b02b1d94753fb366bc349a7db0a9bda6cb4aaf65471701db6bd83b89e3537c95d705cc8539c67f0c4ddfc1a367a70c0a953687b2c5566ddd6f1603e70c966fbff9705a071cf7452a1365906a46f60b89fa522afd8e241d9031f6c826154e094fa311fdfdc0443191cf7cc9450bbf1e837617470d325e140734f33433fd67cfe5d2c6fa67bd5108032c060a5e41b1701c97298c6cac9b10e49f6631e47be1547f236cf40b232fcf9dd3656f54666dae21a65a68384cca51e5db931b39d1ce5fbf009fed3cd20585d838bd33f699330854847743b0515f8b5ce7449a30c038c768fe6d810d27c7caef40779db590484d140365997d513740d6dcc249f04bdab23aca75159eff5f9319680e7d85f93ed7da1d87296a05b4f0c8a31c59dd0a0a6f193e7a5ceef7c6ff4a967e4825c0960ecada6171ba8d54f8621a785e0bb8992d0072e2a9a4f8212bc276f43f8a397c9620a865ce92e382ddd7d037bfbda4835df01f1068e430aa8233a63a32f162298eb4677c455875a9d399deeb7478bb806d8206eb772f61b039a0c90584cb76a36ef84397dafc2396b63179764df1003eee5f923b285b84d2673d7d299e027aba1a1f6e4e842226397e1e61de7d5fbe20f5243637a19c6fb0997bae29ea7ba6b783502bd314ccad560c7d1eadef1613765c3e2e7bfcf0b50ee5ca60df5f454def1d451889487d245ce925f5f197387b938f6c85be13baf6279b8bea5f514de4c775d08cc9fd48db31fcc9f693f68a8d5ef1d07242ea225ed7c4f79757820639631eb9d0646befcebc62b2a9deeef21eacbe669457c60917a345a6dff768495a81ab28bfc9bd5395db65723488348e228985d8f9ecb97fc9f80660ebb4b258158d646bbeebb970060b488d8dac49187d341af3faad96a5d87ff10dd3f524d42add9cc8ac6e5627cfa15fd1d2bff2f0135d2a4096891c0b8e4bbdd075ff48ff154c2a21d64433b8104f13641e99fc165b3323b409e812b3358d3118888f5ffa7f9f623fa672ebd621ec3d772bd99acc9f1cd585ca0254c10b58435ca66342f7fc08f63923aef27e9086195b79687e8208d5c1ad3479340101c066b710799de85be7da0a108ec82cad7e4cae47c7da516774ad94a6874978da51d6e0e3fafc8c2a9ac1f2aeecee95844127312b7d122036b9de68978bb69c345aaede2c8bcd7886c4c719e0b45cfbeb5129fe0ddae8965089c90b6d945678bbb66573d0f73ccf8a8c4339b976fbcceb8b5af115a4ce01fbafb69066c837b62f9afbf506ae2e3a8b3f4b2419e72b188118888e8159ce6015caf32e4acd9d995ca63735961e57575842cf9667a41ac01c8823701418ab1ddcb204977acbe278090b82e0c8cc764b7eb285d9ae00081d90d833d28750d0154218e19d7b770bdb4ecff020dd68c42d5144de7b8872914b910b894e3bcef07e9344915f85e1fc8fe0d6b6037931a2e4b4ec97b094bf1b56ecd027971b95f1d2d77fba4bd9017b0d2da31f4d3c46c50f6f32b1cbdb1ba6df304048752456007b3f71a0481b5224c0b27f719149fc88a54770d08411968b85d11b01955b011aa4b8dc6199d7e1c98a0bed0b877924787a30a15d269ecc4380b5bd860a019ee6b9a27921b41e074129475d675ebbda858f85a1f1c40d67a0fad855ad4f81e3d672cb6eaad35178ba08f6b9c6cefd813185898268af95f244fff7473e2d16e92f31fd5b26695c7fb6c57de42679a8e1751a05c5ae84b01fb35184c45c46e543eb500fc24625cc422ae17f93413fd1c5ac5019596283a2d0cbb6e70d38ee6c975f2159cb6ea3a78b5c90c201d3e19e3582bed60683d25a140bb2c56d393d8283f05797caa308b548f17ac5a9408faf6a435f34ded91e84687148efcdf7a3b9e009985fff3750e3fc47c4c218c29fa935ad6c438b7acc2160a46467a8aa30af7d290e642496a581ab2e4778871e4054539941869869a1a38a38dfa1e03de508b93ef381fa99e89c60395781f686c18e0821736aa0464ff668a0030f2ad2593fceb2245a4cca7bc716a670f6290651a1db78d3250ae92765906a7c63a6e0f44d5beec3ed0260a0a5465f4d56fa33cde17da404a19ee70c063f68631706ff93fdf0cb5c65a426a6dbb450a4f81f4a9e20b5148df39dab356a3471cae9a316ae17c51bf0ca38d7479ea8f44d2e5b9dd6ade46790a5de7fec95b7ddd4885b8bdcf0857b6a32dd9562bf0ba391a80a1e031f7b017f16bbc83e7af3404c975d2827ca6f017c4a1e31a7f2feb4b3d42567c0af9b69a6ffaf874226728004a35c866aadbc03dc0097a299a03d36b9280a8beb4b1e50b651345941b294d21faf61e237ed06e437ad7a8e20559742869cce29aa139dfbf309848b19410af14809a055c10da7f07dc176ed8699342e1ac5f0bb4c57a2c34c8aa7b55c682a80b10233fd52e05797087ef328ba74aa3e0b6b82756d32aad49c0184e843799185cc41473fd1cc798b8320969b1c83d2579204cb50916642f959654bd8076a03e156be2cbfb86eb0327ba1335e6d81449378e7f462a0c2905b9f0183006ea5a7db01ee38e02c50c5dd3784f2af261177d2509e1704b888428fce6ba3f70540fc4db779a002c83599677f81a56018ef31eb485a8e927750966154421e71926b332f69ca2d6246834c4e64e0c774165bef8b73ffd1734fc88eb94fa645167a36f7983ea2eccc36812e388ed7eb142f6a70485c95829624abc76369c89ccab406f765d787bd965927c48afd713e810cca3e4be3d69dc9bbb859d3605f0366cfee965e86e6f8a5135d3cecfe4802f7da0fe3f8f8fc52a744d16f8b29a3823aeb8faa1f5b5bbcfcbe24880440b183d8e7b91848d9f84db8b26f4d6496e24b61de510987657c68e05a63d1023758bd4460dbb46448d37f5184c37541cce89a01789ceb799a8f3db0ca215adf6b73a82b29d6c9a54c06e8d25fe49d128f12c856a1150a7d573359b424e98850d5933641d9612861425664b77d236a4c36be1d196029dea03bb216fe24c6c1e434c11edd4fd650ddf94147c579720635b506a2744f09f1e6b24e75970866875f52d3e129ff187339547c54762ea17381185486d8e9d37d8cb19f1f449b7e122ad28320fdce86bae4a4d694a54bbf11159209c4b98d164042610080fd83eddb27acc66ee774d7a38f5cac19d24e4ba4af9e9b95001f5df92aa58769b7d490eba38e0774a52de212fea741e24650431ba5d11771974222707b8f52ccf93071707f747682133b220bf121356b8f186ffe497d73fe61f52189f276c728bc31fd7f43c00475fc3b49b783e6b65ed9426345fdc2584aa33e3475622a9467875fe815e1ca4a6e63246b1b30cda3841f396288ee1098af8f7df3956bad05e3c59f571ec123a0bcefa8ddb9d58fabcd20ac27fc8170244f5c11a4a5dff220f25972d34b5fb5ca23075b5f67f600674223803ef66498ce5ecfdda3cc30749679e3f901b1f4b897d71d5bfeef3e07dfee6ff9f4c4fa956b18a86b3acc708c11840386bb2fbfa4f876ca882eefa1866b8e98f0e6c8bd25fbd834822a280801ad1f7c7b95853889cb0a9b1bc5c247c17a035cc9341ded11d6c66bc4e75f7c1b672157fef0b6805b6aa31ac8d116e93157cbacdab7c421d2077f94364eebf17f280964fef97a5d421013c5852729f050980497452164e3a65f8d976c79b34fb556290497a036e673585c3e705a0b2ec60c021c890fd68768a7c83d8226620889f377a485226048e8dd9a2a361c857ba6e818f47629bb96c5bfe160efe11d58090cd007b27e80946d1940d1dd8422c7e986d513bdaeee7b0038e8b05fecc69f3a94b3a52778e6bdc098f0f446d16e94c78b5de64cf11f3d8e54cc5b9254157184ccbe23ab103a5162a4501c2efdf324008e225e90911e323a19ea3628cc551e64699b8fa3629db173cb71181739f7b5561b7c3afc3ad7a3e47fd92e4012c6fc2348c1b4fc68d2f22d3cf0287e7fae76b35de3dc1131c460c82a675dd6ed9a94743ef5bb4293eb26d47cbd48bb2e9fb7238d9e4104e3fb163153e906df41bf32ef06c775ca370dfbf886b7a3cf6f3dd635fa75114a62b365e5a2c7dd47b319f3828557b8e73e60908fb9b746641eb6eacb45f4a24d56f4cfa283faa3f988258aeffb58c94d7bf0cb3aa1ef7661c4f134e509c26f0f4c692c502ba77460d44a83784417e1b600bb04614e4e22aaef92fc16626700b54e09f4496eb91392c01ffc17c41a8a21634eb8c5fed10e5827720bc8985596cca249199a258acd9c412a9397417f9621e5c8b7784ed7c187ed146b9565cac48fe0fc571e0fa04d8b1c3fa67e113f860626fff67fc643773cd929ba0038c20cdfb4365447e9dec22507723f9826cc2f73d0f5dbe88af27ea6a307af51d08f8e593ae0fc756100de8cffc44328f17faeb264ab569ea11d9d8752badc81f242449313d679cb1389318311df48851d49473d5126114db71e2c3e050c42ba359d8cd8b91f7bf6dbeca3910756e2bf0913ed31d6a716a98023f985f880d11afd7af4caede4a5f7f559c2a57d7eac525947cdd21bd1551a24cd0b9419b677e2770cb0d8febea47404b4ec4541083ac2a543eb79f51a56421c012221cb5c8ce8ad8278195911ca74b3e5b8f1d786485a457c3e86d858f5c5a773a0dd424aad72a48b1b7395b9e58398614105d9a39d1388290e21fe6f904a71cfc2cf293c344ee298479599ae06065cdd941c20583e4ecd6890235f2121fd262be246bf9caa8e41837cade2a9a5553916b891104754327c5576126c0592cb1c1f91e6485a96e1b3e01e535b27d4e9af864449b1ae7cf3d093e17f28ae86a3057a15e82d388810e38c6ff40778c524aca7e4189067e5bc2cb24567af244ed6da9ab6bbf8dca11449b1a8c6201f09bcb97442d51314b66e91dd02425dca6841957c286aeb589d81e3f7e862f643d91c993b370c7694a1f17c5c6e5484ab863d954ee123016a39f4d466d6a91747806e9127cceae6229f59b961ac707b3f0ccf407199184ff99dae0fa632fea92c65bf08fbc32f6f865e8257dcd5fa9cfc86feb839398c2fae568592341b66d684d79a4b5bb8d1f56d7dac19afed750f74f832cbd3970d79eb6bfcfd13c57aa351f2046519fe60d49804350310bfdfe32dc8323de002d51325db984ba58e1502070b8e0d8715309e61cd0ee02416bdc94df7d6b6b92c5e03bdc594a0c65fd193d4e7383263b2d9b73da39d8076177b3a0e8156f73d400ddf0ea0a69d9a7c97659b88e55559134578840ce8e6503d49dbbf2a9d8317db8b0a18c436300a7a0ee4e56eae7119b2d8dcb65fc9fa521497096cf02cfbae2f926df9bf5d45f646171c660cf9d2df0ae145a3c0e81201ae0236a6bc4dba1ea64f19ed848e6537621d05daa9b5a7e3ed016141971c6642c2c54f9881fe6405951f96a697151fb3187011674c9054d14d133b9447014546b8323db5bf093ba8a8bc30feed1f77f454994a358483fc291f9032bb4edf6f73812b39881c4796fdc5d329996f34600566693a178618bd4f5732b55866357a0f99e691f1de9e8e2effdbb7623298bd31bef0f79a77f1edda6641b8b17084a5a23f6bd61c9e8b1c60f73357f9ca3a708d68f162da4984a86077e62e9afbcb7d6a82e3402e411ae64ed3173a90ccf08770cbc869b249e5c8746cd2f0f660f4c392afa5023ff4f307e4ca7f8fba205b912cdf661a3d789880d28ce1696140e6009fa609bc602c5e62ee6be3d06f4e753e0c1c38aa88e70c75aa8b9d28e7559f90bf0a64eab4ae6b0345c18330f8534d4a73691a6addd4c5db561443afcb3de85b1a786cea3d2649732d32c2824fff07cd5fabdb71740baa170dcab319da10ee89d171b1dc52f78df88e1db4002d69f828a39bdeceadfe00fb8ee6e346351a8cd473038c43751ca6e9ac12b42bbf5e9dc63f4233f7df1b279b1a46cebcc09e7a90d92d437d5642ac863c64025b3a238a4cf171cab5c8f0c00d8c89c4897ed1df4fd5011f6afb8c83fb3714c58b2c9390c91fd42461679ab20b9ae16466915ab4c082857a9e51c6528a12437b5ebba3f00e9fb0ea66af1fcce987a0917704aa6298f19214621e257f6a2e5727bd5393c4874ebf277d3f93b58235e2f426dedac6de697b98d4c006e764851af4dfe79334d1de996d3918d82fb233defe556aac7f17af36d26e4c88bc538f076f08349c51f73d0c8506d0b3109eddbf332a5d797938a8f5f046b0f7ced663d10304b07d200216a622804b4837f70197924c1f33cc6dc1673c47671578dccb18d571c225853fa07f5e9d166fc2d01a50e4ab981f0be829a26e6f3b57990ee58468341cd003f5c6682c9772186d0359a335b66c96a4091e02705966e251dccbe1eab9c25106be1bc9ddc4606c12d67fc3d3f4bed0fde60026f41aaa70017e987a7aadc3f59f79126a5c3285ba2095e66db9c3f195ecef6b9e97c3dd331737babc239119924611e17776e46410de49d07d7e416d6cf15b1dbbe3263838965a1122a915d68f51bd3df5bb2859f1f6e51e1881ec39572189d4be132bced0ccda224e21128bc1208cfcb0d112fb319f480d61da56272548ae27f36cef7d626f2d213ded8e028c37b44bf373487fa77724562e8327fb235ff294aaa8d80f8932ec9767a3f82855dd5e1237f8d1772cf21e369652796c80f786a85a1b48360399c67a9843acfc1deecd60015c5f6554451e3176780e461da32a0ac8b3789646985168e7e950c748f9a1671964dab81a7ce6f59dfe09f44c62b25f8e1f31c3b8d02efda129e9369744a76782da0083c1764336a47885b27e8a1969bb5c8228b8f739941327f8ee0e26f88e28c8e1f0546214fd7ac88ee55ef1235a8eec1e0e4e790018d77aebcb78af5eb1cca34be129b34f85eaa071a7bfaf7837eca02d094a80eb85d86672a8806b934532d09894d55efa5df827382bff786d779e3ddc9cc1d24cd2cba3c9bf9adb16633b0f503407fb1353a04f923f7d43d165783020d342a04413f479034e15518e75764de4a86081ffc82cff52124d5bf62a2164e61ca52b7136f9122965b0eac4c1369c7a953c75d672357804050986c7a307f7d846cb09c5ff3a765ec4d57348e2a2881f9d971a311da52cfb260df9fee44454947077a2cabe894a752b39971dd76a1bfe7045473d6674763f3b74b20d6385f64a05c569e58df727754973a6d3b49312abc7e332e09ecd2faf798386fe7db681a296353482c994fd9d002558b5eba2131a0b3c6e51256b348a9b8d743ff94d5868ba5613843e415de9dbafbcdd1c19873bf66c4f6d0d8446e690f36ebabd251ba2f614889cdf33bcc7ecbde200f6ec4d1e97e7f0d522349b0584f001adad5b145f771ee4316ba1d2f747e34b7af81b758ac79a37531391c64d498f864b525247062bbb726b75fa25926acc70fa94f5a1b0c641b1fbec46486badcef0d5f8e4acb6ec86b6fd1a9d29bd5e6c2101087cb0a959d7291d34ed2262db02c20c1c6e5191164859236da327cdd7a6c70956328cfdea44ce2266cc388a7e6b5659f23d174723964fdea52f14fbd15e2226474537cd88094b8abc3786b516b236973aa6b7283790e73f59053a89b8e9fce3004351594299a47c40a9815d595257a154351543d786d0aaeb97f5957f03863442821170b21cf1f7781b6c33a9eded47728910de5192211c0680e53cc549e37b65e0eeaed94e21fa3dfcc6c06abd691dfcd1458381e14ccf7aac3b0ed200b1a839b562b7dcd4e664fc0c40f6a784b7c7b2bcecf6efb0183a8a462ccfc84e65b0aa072ce2091333f16862ba9154f30c0ba4c9bc0da437a101852d7aa1eceef5a90d2bc07d3d3ae6aab1b622359944098cc86c149a9035b25945aa59c2e42c68a78dd81c58c4963fba98ec0fe4b7f675e43c1fa7bf3b7d7a561d9cb22b93a85c57ea7a5b78ce7a3e881872ff72013f3936fd3f756457e5a1abf645e533aacd745dbde43f1952518b05fc4501c0bccac713e25230806373c42183b7dd67ab2c973accd4f6b731c8648e0114f7d55b28c0179c2f7968202ca7de20571fb57ed3229727d42692fdad02210b41068aee46bca48ba5a598ea0cebb1a1ed45e42edb66e6f020e946858a974f71591b3125f1d0a9acb2e62c1fe25bb31d0ef673e66d6c2ce290400daf619fbc4f1832f773995112af904e3ec0591ab82fbfa001fe5db5e0be88aa2fcfc83d677048ea0fbc36a10b4f99dd1966685c1cb42cfc8cbfaceab1c84dadb7c7a09aa89c94d77e4314b77e31cc5a87976134502ec365239a3b1fc9d81211a8d8b22077912072870fb93d62c512ddae7c039b63acc62848739ac7aec17afc7c5c70476fa68693d1527691430cb277749d50679878c0ecc6221c4d040cc47a7c44072b22821932fa845ec49a15db06229b5c0f7321e857faffe51420796324c26d18038940b93a713ce4a4371d2bd8991c3d6ed2cba10329358ef1d6a81dfa0174d96ccbc710736c1506d4115b244af563f9855fd8f6ea80c53cb4064ddf879e52d67f10df66625e22da19e1ac8bef4fefa1af5b254364731d8db44f79892c15b0cd2de0e0097c67894ea44b78508738b0a739087c38cfe638aca88861c0b387b7613da60a833c29453404fed6de811c4d773675d8a9071dfc07289cf37f6d6296473978ca75e40dfd53eec10fa022bf9f94454b8797417999d2e4ffbac3ace48e261228008fbbcc3a2905f68ffe6d750740c89a3f5e64edd2ff64027c718a0d5930609859cbb4d7cc315547d203b21cbdafc1039973faf2d887a4b9843cb68acbfd88f0b904733948bdc888aaa7f53059243a88687e2ee087df79e7376a490386cad925180302183f30b023ed39943053c99e941b435ca2c040c99c92b98216b8c442f51a36a13267a177bb4d549a99efde8a8569461b2f65905cf800415a16e74691225edd1093ae3a69f1ced4f492c98e1912ac1ba9393771c96a485d917e39a7a4f55b14b5fd717731dddd007576ad65945668fbfc5a00fd5fd4188c78d4672e78327c762cbee598773ba07759e2ab9e498a049afbc13494c9976bea0d844211b869dcb154f3e4cae719e5ee8e0251e87dd51c72f00f728eb887446180a644152d234d376adf3d34393d723ed2690f4cdeaaa8643da3a18545481316172c5893b949852d0c2c947f4c167ad45f8e7bdef3edf4a039e6ca2b9d11f920f41126e9e310707d2fe6a7b4b1783a1beac2811995629cb458ddb2d3291594d7a50abbcd693cf8ac74defa060627b17764f55cd88c9ecc7370732097df7e77c77de5db3a3b395e701bade5419d8e667b5967e75046cadedde9661986ead87fca2c6d273a4c99bacdc940cd34126723a623800079e2088d6054b402c2a6dc2ab470a4604f5bee6c0a233ea108cbb5a523f7a63493010222a7cacf210a6086c8191a7f9a13ec1f9e22f46140e3be46d9fd8d76d7c975d64fed1aaef21165186278883272e7b7d7549eee073a9be4484ade8b6ea8f171b5cd291c51c0196bd193b37a5d8c52c37f933c7873ebe2350872d884f282508cf93f6c89ae9331e7aa7a177a1331a86c4d01a3fc18a8f461826d1934ad81d04f8e3341332fbcc4d2e5faab7bba4bfbcd7d45522dcf5e1039df9e9e6c7c4000b33de384a1fed7fa56fcb2cf4622c514c2194328e9b80c0be6dd7bf781e42107b3a44bb5e02007b8d068c84aa96396b4298172dfcd8413881b34f4c6d406eae46bfb7ddf20585fde69351657c03452d17d6b1558a82c45d4f14c4716916cc9d2f31ea6a60e52b9e1d9b173e5cceefbdd26bd69cd1ec0144e152f03a46600f40af3bbfa21c9edc09dba05e7935abeedb5486fd2196762480cbd1736e837637f8f94fa35ac6e29346d35abde775cec68ab32c8f547e516a3681f7d105ec10f81e2e3ce09f8a53a564c7b6a56704a3c71d73b3d668d72499a9dce73b64eef2129344f5951e8ff4182f4bdfa5bbca984c8f9ca38611696053cff26f11a34c370fa4654e34a95e9545e8eaa49041b3fc5566ea35282c1c22109157a27ae0ba2c95a1cb161e35c43500e338bc7ea4a7b856530f3c92ab1ec95751066410ccb7af273f5be80281478135504c7eee828755b2c4115b6586c389f52b2a976b9ca2da10b7d51fd191b85997a6e6fcda61dcbc48cf55df867ca921f0ad63d9375983c2a6e460ef38039fe537144a50f168be7cd1575c52db6dc466d1db4fce365ca65b01678a7f7a567e43b76345bf939b9e4ba895d5dfdb4065d7e3e92d02164bfa20bb9200f52fe7e91d32eb107be9657ab5921c3e2f5c62243297758be8098f0737b5acfbf733765c4c756aef776d8f892e8f55e94e8e0b37f547e976267422710f5d129ecfb749fa65dbeaec05a0c73d8d0c3637cbb45ab51a7f9d5614ba24cd009645f4609ec16bf15cfc1cde4642fccb128aa1409cc86f9583a134ea20a61da100fcd3feb8c5be46ca16f6a4b1d7dfbbac46d25ea6ef7d4602d59921cfefd9cee1d1781238fb20129242d098f289ff746d62e189b5c24f717f7ff4ab41f85dedeb6684e7dbce250f7313307aa0fb4a6eaa8077e2e88abdb1b447c718621f8aecc3027ca940166b8f8639f010ffc31bf56f5cc86248063afbd809274c601f2d0c7b2c0c5faa728846951bed8b4375fc8a785d549dfab17878359dbe478956a165255efbc21dbdff84ad8cdade75aa65cc1d5023b432192aa7b7593a6fddb2e1ced9f63e5109cc5aa0cbd1577113b8fd793e2c77b331117720b339b91a6ace9677f6efda9cd2da23d159f1d7708cb648d6e7e9ab52622149c9d9386ff20611bc83ac954f8696d9eac8ab057863b51774db20b0a57991255f89ceed8a9b9680f3be891b0c9c99a6c48752ee5226c236f166389a0778ed71b69b49ef41cd44ed6c6fa20482d5994b9d6a59b0c26bd4217cc266465886d39b76ca5b46e91e0e4d353637a19d51f13f59eb06a4d9fa2def7e1fcab3e559087151111d6018e98e1e2d0865e2c30a0521ed24e6f98e852db1a91012206a93774075548d02463414393892c2b25a7e9dec7bd465288b54be4742232834371515ed02e5e2a6a54173059f605ad5229942817bc348514b2fe59791a62d2d43f4bbdc3a24b398f51f4ba46ce01be5601d1a0d8d26ed7befa6e257aa189f5ae8b5670ead452c2c31d10c72b52db489123bacff4237fa051356df56442234fa8488663a706cb0c1f23bbc1220af74b8bcd653006341cbf9cf953f948622b25429950d9239b4379e44d5fd816de91656fc12d183ee330263528b1b2d8ec110d4a231fb5a2028a319cb809321abaff48274c969b9b2bcc6de332e17804962a4a030a6e11d4bc6dec627cfbd521240e7d7976651b266e6a05f26595bf8ec3e000868c8af0a71124b276c06e3683f8540c4e67891893ec3e26723192cb09f39554a81ef939617810f1f78aae9c7565dd6b49ba1ca9cfe91cdebca8b93aa057b3c5bff18ec15aa8229927fd604e0dafe10cc5a7742dc55e6bea768afcddd05bdcb03d5a5ee43184e31ee185a1f4f3d26fd6537364713fc8c78966889dd92e17acfe67c7d28a78002c30584434f0afa691b537108481b6941ea0b25847f01eb798962577b1766c0891f2f175d8302e3d7349066799ac5dd39a4f5de8e57ed144c552544adbe545e2fe6d1100f48666ae2e38b2263e7f36a5be6e99b7594cb05d8435fa2213093d043907290b7429749c1ee3d4ceb91cf5b981cc84095194dd164c7bf636a36161a1664303a3763c7005436bec3d77f3d110646cabf10dc6398aa5e684082b5325122246c0f3c1d6000fb033a9d75b195914f37379962cc2c50b16796a36ad8ec492e6e1836fee73258bfeeb5d8e503b13a177619fe1fe79a8a0775540dce2e922481a4bee33d2e573a40e870a3e630128670b1165afd49c10be68e7895445acebd78be364789cb8dc8edb294c32d638debf8510562728d77d794b914ba6a73c4e1d1d40ff21df99ba85017ab92c7ca66d98e864d13067fec7235c2b0c7f0a9c88727c7136dd90cb5082746b9d7cdfb5789ea9354464e21111c1067a04891805dab38ad6c9ecbbc8b319106c1d565f86e5fc1c91f7960b7539e0ed7d9af8485392c4425b75204c178d6a0d11e3d1ab1c86ed1d07a40c344ce54314e0b6c362b0181bd73e8bf17a1fc822f68fefad5188488978c5b2cfa677fed156be590f8c1ec9609f2e07207b9b1987e5fe451fbff52e4519fe83ddcde344df6ca69b550a8d030d6e863532d7099701af0f7d86a43fd0a071d25a01119d1a3ebedae62d6f565546603661ce725d684ea0ef9d25884ed9354b8f7d1e9d527ec222789368e9a4f8c0d37f470daca53d417fe56fd839fefd89f2804c343a97074af861d1a9317d7d148d94ca5a74875c0e33264bf11ca5bc7b75898944174b9bd92e98028a57d7d925f7e6ea95bec4a2db7d63de6e445481e0817b0f7f8640c299e93249ee4995e8709e807997bd28470ecafda783fd57a9086671935acdaff6727901d639fe63b1f0456af77105d125244a28f8e73579091032dcb52a219f2b8bd6de869a90b612ec47ee5308c25c8453baf3ec5f22cff31aaa2d2b6b330297d61d92f4f1644df7078deabe5d93a7df5c104c897c273bcfd86e0e089701cb4b56acc026c6f79c2567f9541bc97f70a47b73c03eecade581b4adb1820d649ac3bdde72f038a3deac62920a7ed3d6a71b2c42d5b79e30dad07f15f7579a83ec96671d8483b767fd679f15504256f4ee0bd0e556895428655927fb5458ab82e46d27c3ca63bc025063f829caf9b6b1431af2721184f0f7034976642890e9e9b279e6e55a885fd17fbd69ed7f4970dd4c107cc26d4a905e0c823839ab0189248365e8409ad1d527d7c0f13f8522048d38a3651e1ec151ae7067217707cad599024d91e51213748c8a3ccc0d44b2dc7a23cdb6f8c75c3168f1d6d17f928a18b8c41ca50399faa42004b743d49b22e058f8584091c3772f7c92214649f4aac9c3f57b7b104ba0d62be55c016849f44bf8ac6d058abc914e2467c49b793f2e96eab6120563999a2be4b0c69499338b9ffddf97639e40ae10f34051479af499b42be318c257839cb5eb622a306f58dc873a035abb2b3d91d63b6706c689098313d91cbb6c54630850955b5d2119359987933e31fbdfed2804a982151df20a136177ba5d500656870b0c348503a5190613636bf90539ffc9f3a2820467ba546776d01b7c962768da1fb0040ee338de4ea39c13c1c573dc5d7af6a28088ff1fb4f8d2625ac7a376c955fc76cb1ad63090464f1231e5d0617bb3ec99350f200863e51536dac0012897d6016066b437c49d3826a172a5baa4c23a6f35aa6efe2d4c10d30924348187195742bc54d5021d2df26bfc70c446317224c9b01d29ce8c23817fec203576d4c7fbd004a2f357f0eb2d0c0ad02bad2511befa749d060d0f4c6b0f43b7c3e5924ad57275a19e76ed4d379461516bbdc03ba1d3a6a7188e3937e3b0a57e3d05c7a1440bd60f3b7314374fd45379c487c204de2e540b0c22d58fa659e964dfe84271671d86eda3ab9cbb7fc74335d1ff00e5492db7aa8338638f89878813134c08f261d4c14fa5e825c25d5d50d0274d6837740ee5749a4132cb5eecb5f05b884e43d1b86a55e30fe13968f49e30da19580e5bfc39c419393cc9cecf68acf5dd962cb49b0fa2cd21e0e18b38976fb59bac97b3bb58d7223479c452cc94fbdbac46d69cb8e513f050450ae6af7c4cfc77e7da3200f8d7843d5c54a74f92e772b642eeceeb8b4762d9da82f21b087d39b97b717b950edea1a64c8df84ec97af455b416276a1026c6a298dd15967e3c9d8e4f77a97427c4e80da3ff0324921d8e9dbf9851399d3c5e69bd1ea47f1365adca1029974e5a0faf24277faaa10e07a70000f4a9ab4bbb7d0679e21cf4ea4075650e059a43e1c123d34ea18fa023f034bbd7b39a8a98dd94e71a5d23d568eb347829a1406fa761dcee72660fe4ffdcd6a1a9b9acd722f36100645b4b11d24d0d5a0a951fc4fcd3c1555d6bd8b0d0ae316092bca6866cb4880252a2d203641097600cf9b8d35d3d11aa7fd6ee44ac24c2968bd85083992e380079453c4f1b25344fe7fee7858b597994c1f15e0cbe7511e3fef466d98a284f39c6b8319b124285be58c48f21e284c321939b258e59c538008cfca095052a42c6710c7715b8e030f5fd8e7ecdbb58c641fa6bd7264ad716fae0d341970250fdce7dcc22740d2aaa14dcf9a78af7018c365201cdcd11833af37c804f6003f35cdc1825eac747bc5fb3111485302c2160400018ac5f0fd68ffd740eea238e5e93d9d359b837f69e3a2ee612764c35b3a02c20da37abaf50e4de7485b668f3090e5792d61a2e801c4927a06a2e7736709b127231ceeae20648def6b1b447b1901aaf16531a918fddcab8da75a242a1cf8dd71071f7717ea5d341bab53da24a84d97fc4816f09c929b7eb9c797484f3de1866b56243c20438a1c4adc262ebb5110d2cb051e27ebf13183cb385c7c29aa83749a475f49c374c0939bb8c9e36c37d49cb6a06bf40ba6058e2ea68d392f090e19df9676e3ace3c9b2dbb07c96bb61b9b788f878cd322f9284dceed802dd9ffa3d61951464959c6411eb278f92fe70b40f5dcf7960cb3c1bc34cf0bfdbbf25ddb877f5931d8ae633391a091d1afe79bd14290a58c992d71b79615257de5380ef0af91dd4fdb417a9c689d49c5a5775b767b79d2e760d25d0c2474b116533edc56877c906f4a1c871e4412f4c1f343c2bd33831f8a821de4117c1f51086bae03b3523b253249dc76665da01b6d4282ac94be81d0f535496eddf028acab7e1e1089794e5d258a16dc832c1a638880a25ec62647ae2dfeac12571593fa25ae90e48d4dcf9673bc1f084f05927d1b1d1361d5e0f8020c764d8c2b6166597bc9eab33ac30c16c73ea9c142da7e72b3a72262a293881d213bff259c2f1dd54a5a6ddb2e5564ded115f1143473891ce9480dc72d1e64ceadc8ab216bc5fced6a4ada7cdabe9201f67097a5e2cc7a314fb6fa70896a4d168a579543294b7539dd9ce625a6e8d8967c238d38d1b7086f5876e67df10cec8de882c3f4427a78b9f36ae945b130bdcc168914d0f021f4eb1cf69efa20dffa90e5cef6e22f929084bba48fe3f733de4ec42dd207dfce92f2f554765d4eef0d4d3ac5b54217a5f2222a074a81cbdc2b82eeee39aa42659b213bd63a35597753e3baeb72191e83aafa2b35f9eb47de74c373fb93d8acb2eec37cf37309aabd8432e9a649173bcb2ed6e0c442c5236cf8e74e41f68d4d177eb3511610c1112516fd07f99a4945dfc9b4d89daf3e7681371bf725600db176fd45ba3576d2ddc3f04ebaa3e4fa8f7a4ab8a3df9d705ba76d1c634c9a0aa65de63a112071719f1fe5373c6a7835b822e02a3bc9dd46a06208c00a35a9eca20f8473a183c3886462ab282e2ffa6a25179aa210d200aed74c14fa3227467789ef74eee76527d18cf924faf405ed9d797ad50e921b1524442c3822397d6f6866dc87c10174f0ceaabd16ca41ddefa89fb65edcf8bed9c06ca8e158ebfea05354bd126c64d562538ad87511e84c817d5c613c0e1b9cc97e02d5453f2cad724758d3dc257428968c1a358fdff950b326ec08f491442a48bffc6450c92c9c28dd2ca5142fd72fb7eae660dfecfc8edd8356bb0eab1f074ca5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
