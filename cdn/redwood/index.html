<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"896f502e8640666c9e266f3fa97055b596f942306a5676b730ef197bb5c5091749c5b72378a26b3ef616293e80fba393b3644c658422f7b4896c7e00f7a6fe321468e4885102d546a30eccf089db4769289360aa25172d9e42b496bd448c277cc128e222e8847e9dfebf3166a1e06ad866fc2f62962cb75c0710aee02c971b167236db2d4782efb8a4cc6fcb1b55e7dc5231aaf48989a32d67e7df348c27406722b86eec477a0865e81e8612b933dec09cb572e7ab8b01196977d8ba64c60eda6cd9cd5c6f7a470cd147b0fb087bdc261e57279140f61f6462b53c3991163bc1314ec27fa8ab9e45278eab98cfaa2d1c92ffc05f116329e06cf22fc6093c49fe04783c4cec819a45ca8d51dc449149e63e523fb6b48df4cc0246cacb1f0cd368c13fdc9f0aa41de1cab4327ddf5d0481da3666aec494ee3fc3c3546fc94cc811f258ab276d476b23c0f60eb61a06b9dc8b01f836f9b543f952f84989d3be268b2025332d2816d87eb972405aabe93a52ad2244d982c2b67178dac6f7115ac872ee5ce08e4fcc76638891de4a8d9e27f03a12e92be0306a84fe548fe604f18a49af2519159456296cf565e3b4281fd15dd1cd5eae5b24d0dba10cab1b514f858166286b3e2c7892428adfa81bf238d9ab4237db89e4b0ca90cec5ee32023e18fd7774da99f62ad7a4c7b5280d7664952ec4b1d45474357e42a79f7a51d4ef436d54f40df19cedd2b7bc434682ff9c0e6ac6dbce7de9581a219989f0c2f477909c8886b807a95ddb172d71449ac103bee2f436693c03084744d81e7ec8f3918eaba55152f68a549e32f1db5c48cadae902423c6daed4b9d665c0ce59c66c0e50aabaf75cdec2c5a5b42f5c0b17cedd82b3683a804dff111ce2c0cb945037b3d5be91823601edd62aef3f815c4afb1409c4b9d032294120a4d04cab47ee8c59bda35b5c0535e0249ee73c94bb9028869e65ba05390730190c03f90b076e245187e9182e63b05b0fc274c08e63b1f33eed36fdac101aa31e1c9af5ddfbe557f2ec8c7cfee1c9aecc94ead43d5caf31f66418f750fbd0f0defec286653fa2be2780fbd40eb342f9acc2cfb9673586c2587fc34d5326ce5e7c72885ada10751707930b17d935ae3521a3a69c3779f5dc224b31ff5eb0218ea01ef95cd834ec967959f53b609a25329d567aeccd6bc692ad3eb5a5e50f70ec01bd764b0b4eb5619b5eec4ad4c9ead98b84980b3dc552217b1598691937f7693746046083fa6f8492fc0c861bd6e357dc54a8be6ebfbb49ee3c215894ca3f1c0c4af929c9aa2fede70fe3b6709cfb34955b172b5a2eb20a5c6f101c4e2845c3cf47e7a0ddcae3c200ccddbd0bf9d778a3ad096ef9f8e29160789f71198de4ef86ee93a67f3ed1eb063383b810686d24d3d0931dcbf3f906e88ec2d82ee9b0600d46ac68ffbf2568a418e5d60d1e55c73d930c868d9ea4a3b3b5c22bb3ff7075b1b3e2c727117dc0e2c55a6b6137c3bd512c2ef672134def2fabb2a2f537c909642452fa91a639e0d1a7ca64559c06f98d3f60b07d856438c37eaff194a92f3dadc2336eeaf849385c6329f776987737624f6925719e8700374a69986e62353e7ee000587d31a1972d9c4c89c65c7ee407b2722b2e9ea04ce13c574ec82bd3d570003d628a4988c432f1a132abe0bfda0ffb57198e9b0c866140f332b149b856a0d13b78bfbfde49bfec07e5a8cb33f7775fab136ce1f74958e3e93bc0b156e22cceb8a3e34b3273135f3e96c0eb4a92f65ec148e99bfe3c6883d06d5db1653dae148a3f0e149119cfd3613c32a60507714e41248aba416c9c513b9aece3d18670a411c9c062c189e39cf277ef73e3afe0e33a87cdbd4bec6fc5f8bf24aa279e8b880f9f60eb329b70dc5fee17f755f6b6ee5c27ea9a197d8793df14d667325bd7c3c0a757ac637999850d734ce126084192e722e398863801013c93a5ce202447acc47b9cb97237fab94c772f5b3d0682c17fd609dfaaa5c9758a8449bdb88a72cdcc744749f1df48cfe0b153a1067d4b0e162805517e43158cbfd226e3da4a62897c1a01f6332cf89d94928f497e470e3e1530c1d4b25b7066dfbc474cbfd394f8bb774482947484c5f70c3bfb8bd5d16d5534168114f5cd1ec6a87de820ef9057f30d389ca2e6ecc51036554394c8a70d5bacbe068c6e27b48658bbb9140da470ffe47163b05e897ed737372b0744edd0b727bd82232692ac2856edc0b6932d8d836cc26d5a2dd70385cde8fa6e134c1e72bd9d8c18fcdf3e569d7b9d7822a6c7899f89594b96f4ca9ec30c95c9b624bb507e9196e1eaff2ef65e94d4c8446a33b02c81d334a4eec07ed330a1205182cc4eaa61e39bf835dcc843a0434c28d3b679b7d531c1dd52219295f47f0ab9754b5ed91c2292078d0888afcd24549a42fa0bc24143ba33877b29177bd014aa3e86bfd4749aae05ae393cae29f830fcfd8320dcce0790be8a99498bc4b2320bf845a213697ead8389826f31e48f0e7e94cb97a9ed7a5bcd4c2bfaf461f2228a0f5cd199cf58b4e4581f608b0cd23e594f43979068e7faa55774ed1f6e668b6652d024cd5b6c1cc83324cc488f4ec704795df49555f2eb54bc3e0b67edd343e727cc8ccb4953680b239be9be15f9c83067e37483647ea189e38a322a8b358f2fb66b08fb0c3770b78da89e3496991dc52f76731a307e66ce0fa885192f5a5475551f45be2a61e80f6d14a3cc90f7846d5d0d3fcdb5bb6b749d9867bb9e051316a1756ce9bc4369fa1c5a0c0c624690478fa7f8b2de55aaf9f1724ce2ce5284bc8ef1a738cb65b5312a4637f1187abb794d8c10e494e17781b3f51969ae01de11254a291b1f03c5582d2f779c12f9940c5c27f090f7fdaa813897f2d536857e9a7457a43202b0f44a44dc0b551879ebc7071ff02fec59a7d7142a07582950f611dfd9a85189116df7c64e70f1f6c375e07fb950515c56054a1a8fde3309b978ae5e66ee03ebb974b065632bc63c373253486ac39f7b6906f887cb168739c3b79af880f8e1ef26e18dfc7f3fbe90819c887e9e114524245729e14d0f6d7603effb4dcbddb720bbd73ed571e2465fa47989f0bd6ebdae1a495b9e6e7e40cec3ef3c04ab715e0678e14fd45c57784fe5a5720f4eb9a056ad32ee580fae8bedc13a728d4f06e6a1b3a4edb26adf190f95843e6a82c1f391a2b9c228ebd527b657aae7c3b523d5325b90417e2c575c4968188280c3f1ce59a5d71487897b2eadbd5236869a9d15fed5ad2d25d480cc2898ee1a5f300134031192483cf0e5ad3010b90d7e5bda1844bbb83e96dca3fef700ef5477b4095fd4741d8bb1f3dba7cf0ee579b15a793ccb2f304ecb41f335a5ff365deeec7010636747ffb1995c673b67c8cc413456e4cf8a86a45ddcba454c065eac2bc588d5fd6ff11eebaf2c22eff4c4527eecfb5b383e356bb9bf151745f3947a4ec81a30096dfeeab498fe959f9f1659c90fa8b29e4b9d521f2175f4c380e436e0dd088509251fff8bb399b056c20f1bdcb64c69412e4e0b8514ac4e4d66cbab80061c4fc15569fd4a4ac797855755b9159def0c55c0ffd7ecbd5e585a42dfb1c8b9bd05709ceb21b65c83ae71ce225d67b3c470c25be021e5e1e6066ba2825964e4b7f5bc5171f20ff781c24041ba44e119d60b92dde32514af19ac3d40678b7f61523ae89c84f56499a9d4f1df8f201901e419afc9fef169ad000144bfb5cc9cef044d9f1dc4452fa65c438ab2f2a1e0da06fa50250c3e764140c025b1dd95f3488a8734119a825fca955824cfba9b5650050f775c9447277d2759bf6979e4008795fde43ae90394c633e817b26db86d5faa80e57868a2db9c28a886b664e246d19e24ca0c936072a2b49e56cf94059abb55af141afe324f4dec1de244fb7ded02626b9a3c73a15ec5a6d0a64253f337c5c86d0a2066b144c165975083902c662018fe0a70f40a890cf0d94a7473a03905b6e79df82f2b90bf04f75a1d9115c6a5b170ae57ee1c810b14dfd595ec412dc0d04a1efae124029298db536911c646d6cf209e2fc6678421459d3488274b6a25a349ced79de51f7b4aae3f8dbb4eaca59ec91ca5c56224e3a4cab56502a9d6f1c4c6348ffbe7545bf762422bc10646ca4548fd8d2261e9daec57880a8fb6d6bbacd7495e15c2df0ccda6e03b8f94ca03b5dd38e2c9b7b6f142d1c4d40f1319b3658d5a6b5ce447bf7cab58c92603172a127829ec95f9888ca7e4f4df4cc8347cbf8077a8b99a00e025c6c9214e870a8e37f2641ee56ba5023fd86267dbac9bd6e4c46bb36a5f25cedb3bb6607137e74377f2e10258453138b4ddbe9ccd47db37a68049ceb3bb0d0fce809ae2ab52dd10694d8f5ab4c3ce114702d54e37d3188640d779d26696ad06f7512beb4b2dd709e48ef8b20d3c3ef27fcd43501d96fc249bfcccb606cd3c13441bab0a674b3a5166208299e9538f5ddf0ba2384bf6137d9dcb0ccaa868aaf3ea9cb179a50ac8cc3ac31d983a0f8738690c01bf9c0d8fe1468dfd3272353726bbc5a91efe807e3bbcc30187c3b40b06a1ad86efd6bc442e89ecb91e649830c827e591d1ae81d2258e4131b4ddfa9320ec3128d890f5bca02d1e50ef591b0ef9cefba7544af26f76792000d0c47db397fd1f12216fd2455480c6a3484cbc8d538234e43eab1f5d7d6555d6cfdaaa4f9a99d79671bb5ace8734d2827e8b7d43a081334efb6db45ac3fd764b23d55bf1ddfd46af4d08de43a5cdb852326c1e38c3cd546911e566e9a47c52769d53ccf3e76585f14bbcfedec69d45fcb4ed7050aaded79f646f712774a735af67be814cb25907d5368249530edbbe1443eacd613db06060a4e57dc83031d30435e5703d83d2354c9d0ec8d0a6b7e5398c3374a2177b5500d7dc4b7d4c85fbc63407ff740e4d2cd3ca9fc53b0a283dba510c938d8f8bc939f9f791ecea1ebe757f4625eb5b4134a264e0967a0970b165ded36982976fe29a0dffe5fb2e69ed084e486f5a4b7e524c81048ce6b84edf704e54bec7e5c5797bf38f7942a88e3a5695ce9c4a83d22ddcdfc84c1ab60d1936fe9fc5fe1e05586120823558393bc058f8120b539c536e3573632e5dc9ae265c31096292c7e06c1fca0152a0d21ce5ae71b586ec8e233eeee9ea00a59359d3eb71a418331b8e589ec83ec017ccfde682ecc1b98e83da0573db3c1d28bd6fde2b2a71985e4bf4891319093e45963426d46d52aa6f668be98df02eedbc897805178ae3488d1d24b4777469d63cd996c2907a14ec69f8dda28eb01cfb728ec6aa1f6a695c60015594ca79389558b6e253d01328dfc2c87c04501e36ba4fa841e05cda2757813c4c05e5ca03c826433bb0d32fe2fd26ae0adeaa1c08387bcdba6a97e82ee18891ca305185eb6684ec7832f6cf87fc45fd9143c5aa448e13bfd9022413b083dc213a87e8aebe75c3626a5f001dbfbf4ff76bbdbe1fbcec372489d6369c9ca1d7de89aa9c177a22afc5c052f5c50c2f294db567c04c16035fa1f20fc7078454df31648611679a5490087836024df178454dcd62f0e28d14fc6653548f9421ce00e833a696fd814b6b0176d20ff21598c0b061c770052779bc0b47c1795fef7c435f69d2d8abcb27bd3b1f227ce0921d20e638c327eaecc5613fbe3b11717a074ac6bdcdb7d63ca79f09b2e26b5b48c7c6123f40da252df0e2c1273ddc478d011147dd4a288d2241e5f6416743bc1bb0d0cd453c148e453ffb1cf5a13c60e5105550ca00372a1f0dc41917662508a3e06a17e7979abde67da34cfd9121b38e1bc495aeeeff3ef92df0cc1b33b577db4f38b7a15485bcb7aa3c92ee961d397c23562b6f5c11b60108280b01e2ed3c626aa2f8accb615b40d152f97485267b2af35bd756619bf7ae9b12c217873e0cbd5898654e8eddfe8077f4f0f742b00915393088359567ee51f4f26e3b73b50114a14ca33b4c5d89bfe8282eef8305f0ed048ff893a5b38538d124fd4c751788b4a5815b983bd0d9b7a4f146716a87080ed01dd4e0c6b5fadca187d9b65348d1cdde5b996c9588e4cfcf76d8e6f2bd37401f30816ae28563444ce132c14a0760e60e33a8cef33858534d34790cecb3678227933b62a0b6a078c2314e70ea76c7b2db9f31afbc883ec4def93a63adb47404ffc76e745b4fc494f1dfacc0ddde187a32a913fa20c11c0e8bd15f618da90e076b055c9fb451eb143b3d7929220b25a532b03be8e62c755dd5217b9803cbb2890591f1b753c8c43ba54c8947be8b2b8b8e90501250714103438a6801e5de782fc3e31048c820c5054386c7cd876237ae048d8ae31489cffddbb8cb98c7466478dae7f36204faffb6622da394ac5dd16f031743fa776080cc0f90da064739341b3a16d0ecb48ab7fb07c61fa67e88b0f48a09d54cfa6e96ac3dbdd09804c2b049803219131b7e7622005f3b5efaf29fc39a09d9cb76a62abebb9f786c19419e1022ed91ec8debb510b3990a79a64c7efe5f8b8bf0a9cf3e2f9a29386da15d84ea87c8facbd9d74c476f4246809c75f32aa90a74f5c80b114241af24f7b3e7d83fc8263629463c788e6c8d20cc62addf2d166c08cc192f439cd8903c67266ea865e43a48a4e28c68fa1e6e09dba65ba79bdf647eba97a11d8382c5067865c7eb40bcc62721d93713a7993439f35385f3decb3bb3fc6f4df45df8386b46a46d5fe90f36e17880e1e2710a1fcb5d13a7820ab944b92c28fc2ce02f52b5c65459396762bf2c86097778312b1fc41eeafac1790c443c97f15f37c7aaf0c12e94b28251c652948c259b6827cabfe3ea1454f089719bd3851b27fb558d9407389a86c45c38e73b5a53a200116a558f8f9e3de803f3dbba7050fc03f1d354329598454adb1c3db57cc2cb243806433940aa2d49eb073bdec432f6a49139aa050d5b3655c100d7721ab65b0cd736b9c09339af1ca322ca2ed99d40e973354793b7dccdf9fe4d47cfc61de67949ecc8da372c8acb011556f79c3ba75736aee6ac1703d680380b4cd37f9b9cb436be73b61cbce424c4e33128a2bddd04bb1581294c6b7adcb851982b170324687c14bd3fe50d67c5ae54a32c4ae171a783525c710a82a51dc3207fcd19d81e94c2852d7f82f1ce41e7fee2a936a66eb996ebaf8e027ab448446b0b6f07437702eb47cb92335fcbb9efcf757a9b62129335567b62019eee08a51e4ae55d8dbc14fdf98bdc2173c0920ad768a0704d5395ab6a828e02298e22474e08d5aa52c84b6a23896caf55986eddaa4111711d6a384366c9fdc4167de7af5f816ef6c982680a259689e906d7742546414b45b09a33f4230b343c70af1ea390d48d9cede45ed8ee06a49271947cf8f97dc7286441d7572efbb9bbfb2a48fb37aa3ca9b47f4e1192a586e4df514be831bb315fec7436850f62436e9a64948484a8a55504bbcbf6b565c36eb24f1d99f5cb67e882f29354413c8d2d3613b8d4f4b90c06271ed8d984254f4db727599133fe4a307726739097bf9bda4bc9e1fb2b3509bf5e128f42d7db3110d42a078f871af2d58cb595e6d8a69ef8338d139d5e116649a8d6943738c566f7f4987ae57fd200ae7375a1a3f23e42e44b2d6c3cedd216b372dac51a1c21a43986b6af4a08d096c4d634f4f9d5bc6a62da722051f8a81b1cc9e669cd7a4d4f58b6357ec4f93464cc5c7de63c43b23c47d990b7a7834d8b9bf86c7831e1c5c95083d9b4036a5d6d7dd317bff382dc0cf1373b78257104a66e52cb8400807468d223cc4627e25470838128c7247c7152e116f010a6e39be0b213738a4fc41d2acb366b8d5d0f12145d5f1e4ba29c7076f1a37a2cd693aac9e8b32b6324ddf863e87bc2f62d5d8d4c8e60f79b16711010ffec5a1e3c2eb9cd17ad3f09e2b801dd0f56ac4ca6bffea44180c2ca65e68cd123b9132b2ee61336fc92d3b332dcae2c4b3beb415a9e80aa0b833d65924059921256ab0ba708cf08d7460e4f6e30cf9e4fb3b4a19e98056f3f9e8a86b7c498761232671bfe56cc16b757b5953214b894b00c21c984126eef312096e75537e1643cc1996b8e9574613b1f0890076e2c57b01e574b34b695fcf0e699b412558184b51f79945498789cfbe1cb6250daa2ffb8eb0b14ef0167955e3b4fe2cd97e4d796bbd20a9bf6a2034c7ba8dcac8c3d34d2e453a922b0f309ca557a87b103249d23e5ab4cf896de77b5833d8db3eb3b77aff2bf5f9b0a584104437037945bcbbe823d58eed97fcd631f5a6b64ae2106171baf961e4d21eb171fd6d6f7f1093d1f1b41860b8dd10732b831f360dc3f45bff925acbccf57187fd00fdfdede1301c0d4e7729cf129f9647774e9cc256f2a50b932b82cb9d61e17b2dfef51c09c6ed896de647faa9b3890a6b8bfacdc611a29132d42553e4b27a1ca6e71750de559e2ce159d95c55d7c726301fce6a8bb1aad10c5d37f8d0f3a5f3d1b53e5a495a036736464566a7bde1899f8e570099daff6b37f5101ed563cf585505b9659cd6175ed1da545f612f165d48abd18941526f6fe5a2e0b0f1e5d42b60484fd657fb2f71548207425b88b04c29bf2004f5efa08f543e0927e2bf8888960983dde7eb9b9b39b163e40676e0ceacfb99a766375a853fdfc1dc180ac010b07ad38bf2d03c21a802581deeae9af84940cf904f973334e9ca97c7bf7c577973c0323b927629272e6ebe25182b73526f7f3573535286f7b7aef93420378513f57ccae197a54a6237519ce812bd55491c1749ee7a1d4752dfd7b093ac89cd0cd7f4ceb6416cf66e2c55b9bb2d910e11992e882111f64c32238d8cc3936c261aa1adaf271ef07bb3c28e192eb68c0f12f80a0b3719d29a5d4195ec694126106e855c3ed4a5363ab5f746c1bb49268e23326d1d2d36f985c23105e4e4c742a85c2a2df99ca3607d4057895c5d2830d74bd75cc1dfe737838e1e8acdb37405516e9fee160ca0e4212c7a83456df7cc3314ee841adc60f794b8ab62b6fd81dcfa0dff15021c31c518e1cdec11d03a9bb83eedb030809bf9a410d36844edd79a7bdfd1e99f5a0c0f18af1605af7ebdc319a1100bef0fbbb26d9f03ebbef42f6d093bdf7b321d54a6dde333613700bf3e432a706cf2369dce9b84ae83cabd6b489ce41a2d203f67e815863f819e368fe83665fbf0411dcd3de790d6acf02196c9cdcf90171053b6c75b38471a72116f448623e701bf54e506153558802ca42cab566df5436962f00d49d6a5eb52e7e91fed4a810655e6995f4f1a701cd09f5a8d9199b9acf0cbefc06b149203902559ff1fe11094b60cc4f5c0bdde9d3d9b2c2ef2b7f6d3425fcc327b9f690ab0200d27d23752aee25f49fbdbb03d66f6df01b00a3c1cdba822f92bf3743eed8d5e25af0652242d129268ba48ca7e74ed7834957f3e48c76d3f7b7fc3800fc3f6e4d2872f09c6d873d17ac71d50a6c904a0be62ef5107716b5b27efcaa9ab91dd7fe1eaf962217a5cbcf5320fc0edb1e58899ccbacac694622645ad895e4b7ccf848b70fab96d62202c5fc0c29dafae5e011e7ab48701111cf09b2e2f511a032ab491c63e6d62895d94fcedaa8573fae3987172470de6c4173ad586a6189c1ed01a20c74a00842ffa68ba790b7ce86a09bae53bf01863f1f0613ace4589c2c98edb98490d0376faa6d588cf9c11189d1d1041ab01035bdb9001158244bb1488016e230bde5f95627aafac449bcda077ac1f3c4c9660b946f96da5b38f3eb6a17243141767503f65c820543a89f585414d8af24ab2fdf7d98cad245d5c923eed9a7ca2a803eb6e93a69051afc9cee6292b9536d905f29fa8e3818dac46bb4461f592ae1fa42f71f3b4f2ca3c16cadc7856e15f75ead0a442fc0035cd523d18efafc0c117b6609f54a3a8ba997d32fac8bcc0486755c74c9bbc991e7dea51d23d166416e98a21ac04d730bbefbbe8ae962ff11df85a1838fe881bf2fe613aa67e8e824329805d1a919ea1e1646e0949711340dfddf0d4d1a3e5d603904cc0e920078f8cb1c5e1427878aae2a5b6040ef44a62f787b003bae5ed271d62f596e5af27eda5fcce073323d2a5c86ff6664e7671cb8c5515fa78dea62d4504cf5522025fe34a540e031f3adb09a9bc43bca510162936800a52475c671e421ed91931e247d60eb7c3384dc9acb86d2b5615f65745e6c832aa7e20855cb3a4fbf51d32977c9ad2ff77a6c94973a69266af58f448cd607b004681d7d0bfd9961b857e528cc0a2853472ef590233fc1dd55327cb95c296a15cbfbe8c7dad39d98852d66db9ab34fff981126e1692c53e2d8c20d8062d121c8cb70a46693a364a02f7461f4236e2d57f6efc8567730d009c9cb967483f9a9afe64028000cc59b099a2673edc128d695f0c5a9aa651d110c2b6d41a2bb0e275dd921ebe0266edb066ece23298d97359a438f37b6687e7e7b828cc1240a8fbde7eb7b5b7dcabd6c4ddcf56d9c64b8108cbaadc989ea8859513079b0cc768fad8de2bca18ab6cdb37c62794cbce9f496291b7d65a07cd4002523e4e889a2b54600badb88314cd76b16a9429bd92998151966fb11c51a3e626f456b1ff19053412fa3a87e8459edcb82bf45c36d3e76bc61f3df147e74047e7f028daa807b19faabf2ad174bc56cc97d1811ad1c7d70b59883d10dd602d984d892b2d0eb9f4717b11ca5c64fb137c7e3aa59bf13f48c03c4649d09b78037093ddc0fb75972c39c5d93549e2f0f641e9c78a6edcfadbeac195191f01278467febe286723094d7e4ad366b8c8f305a9602691c23af9c37f42da5bd1ab84744c6603f22fb6cb7c14c6d9d0fc4d3937d3896940b33eb6cebcd69c789702684d6ead218c50648b22ab75c520e41452e526354f8c4a2f166052bb3785a4b63f2cc25ac02fedd2e8855f0d3b948cd9caf458fd1cf3e1ef819949a1011d15c55470f9259f56c58316c28e35a33e9e2e03b48544d51f08095ec3817c2dcce76842384a72df4571b8b830afd8dda5103288c43d546dfab83f370bf6a628e0170ffdadd056ed125b61e28b02ff169c5e0db86c1841a13421d1a3071cee557d6f81b59809a5269b10d4d81556d7449e6b92bee2d706c97ea2742bd0c08040b56a14860cf38d30bc8abd2f9f5ccf9c292e6293f0bcd4938ac418be48e7d4a87b4637178e69a4e7b92a8ddde46a5e37146409effbc5b2fc5caba5f94ec6923bc50ee7aa832831b7c3d8ee203d1785f0c98dc0e3b264777d6465ae6ae80b32ddbbf3ce2b6453101791551577eac3d567dfb1da2dd67f748ec8103fe4623548f566709a9c75cb5f3b5894d5a29e0f92faa38cde13fe6d825966935052fc4eb6b3709c963a63667d59e80c186f5b615efbf07b7b53337e8acb438918b1c06c7a8b37347cd45ba7c9a4bd6c419ba3f72dd052596445276a9354612fd0e034c5f16f30a1a4bee94264dcad4fde76911a07b8e0fc1bb3b2bcd8ccf2eda9cb6177aca598456dc35d61c97d67fda2c031bdcf76af2eaebcf9bb5508d96e5c1ad05142ebbae4d4a4dbb7896f31c3726b64cd07474cee5f9bb0264ba57a53b42176505890d2a91ddea2c574bb8868eeb54bb2d96236f4511041f10785d192a646e245d584daaecd1970419c3601c9850b74d6a7dd338326ea287e144278ff08f7192a9d70196297136b3307bd82830480f6e56900953b01bab5450e81b0d2f41eea4f31c1f242d0f1137204d9ff4f3fa57e456168477d9eda7ec8c7e2424145f39ed827cbcc5365511ea675d8dec8a145e5af6cc8a542845760937ab90aa7a952ae57a3e5d39ccfe668726d4f5ce716001455c5f5a391af3d09eef305e19ebdaf2fa585e14f4dc56a00f20e3f6f3f18b234c1b28443a68ff5a04c38fc2ee13e07d832b41f5e9b35470e08485399365688be5ba12253e5782246f0b9fbb496f917c5c315112e94cff9bd5d08258d00a4d418901497147ae546a3a76006c029f47519fc55cfe1e2de7e5cce4457b24db04d7ff97cb437b8a792f7ce61cd5719d5fc5b87adce771107d288ff84f24d1190067faeb8dd9a04d0b7dad1eb612f07ad47f81d41190d7f5cc9eb370d97810c49e949cb27820746d5eca4cb1d490546ed9b9ab003a17323e7cf3f326399b63294888f9eea1e4373fe0e18c003042f77b44684e3d365ee4422b048f0601959a8c1eff6e6fa71d14ed575d0f336ed148a44addebaec5eb6a3a77c9024f75bdc7dc38eeba855986a544f14599cda24c78436064268f7a04b25dad2cfe0d30b71969081d67395348dc0acbcfb05b155fe7736ba89a2999e29891e305769e71fe930f1a31802308085c8fd02cb1092c67ceb23d3d1d4cfb969ecbb648a6e8e68ea786d2cd137e99901fe78189ea069ef1da599cb94127b7e6ddb9b659f80d56286e2d6f6a805a3ba480dc900a090d980948c3a448ba111f381ac597f0ccb4de49c81694632e9175d9adc01424acbcf5fbb90ed61325db62a3d53dc63061e0c1f40bb66a67cadbbd65fdd21b4f98962b1f9c03b9a9069f02ee1dc90237c64b69baf16e5413c81cfab6ab8945518cac5eb82732967b066dc74198dc723c84fe0c08b6c205bfb277fd1fedeb3665ebbaefc34a67425aa7878a62dd91895c7fa1e472a2ee6319fdf95730e0c5d1fc6893877cd6e3fe0f99fc42773bab3a8334f8a73b10c7ce4363b2aa1d902b1c4c8937df330c4e606c4d089ad645c272086665d2318b13f9e48224975a7fa475c991522d5590d2def9950c861430585808b7553f3eb1c1d4c475f485325cf20d89aa84a91a6390d6aee80febe0d9a7ad4a80cb3a15045ae12c6abd7f9b9f1f5df78a99127ae4ed2dd8e389d942e3ea5d7631cfb17e6923aeb79717d2bae431f486c3a560a86ee9bc92b51d3b7eb40ffe862497ce45882af9b9e4d131641ac685a51295da23707bde2b0c2e1a135464d393c33359485aa028f5b1fac6fecc84a348bd3cbc0b88e1a718a84b52520cae47867351580704c614b66debb10c0cbf96eea3822c49a9c972747dab7bae4f5db65d9659b62d21083db84f621381794642442352456383f6e5c50217d66de453f1206184f152c81d845594762ae03734668106c7df98e30200468be84196ab3a58f9680f16347939098a988d8ec7bcd98e0b5e9d3613113f981a840a5d41553e165de0cc5ee2bd9cd3f630c250525c03910ed2c6183e40240220a0347e65910cf35c742492b9c520a21ec9bc7dee76c1f2bb541abd59b20a749d107b5a38ead9b207e85a1456353f53341908b13019d109faf02a44bda8d00572b67766c615f811067943f7803ddba0f8fa60c46f665df584d9130d09611dc44f66a06148f7f33c3edc18766f5d092c5ed3fdda55ff9260f5b9105ffd056471203b64c22def888f7f2e207f61ec3e388dbaa8983274744592f61eba90ab10e8683d8a1211d8e78c65a4739ad59884e42a3e8a08ad35d0fc3df077eecd8933f18aee83430e47cf3d2caca6bc2ad73a5025bf7e1599feec631e067ad0327c33449f71392329caf8b91a73dd5ea20c476aeb0377ead6416f23e7a3b272d749039b1d7376c1e2c8623dd097c3f1e3432c5617304cd0b7209dd93ab80357c2775f459fb4b44bddf705f8c0f5d6fb13e9e824e6f94dc1ab44b5656f5a45496507e96ddfb82ccf582cf56b434c72e3c084fd317117cb46f7338b1046901594aeb83add61e8a7a19ae15410d3c4721a1f0d2b68834cf143c73c51d91c582da22329b7fd088edcc4aad64b7502169b5255058cc06b97ce0b807eaaef117fd49c520f05856f9d7d42dae0374ce26e0502e4be525d26bb488982d23eeb0244483a23a6927f787c5adaf80a40b72e23ec71f2d96c1f864b2ab94b8536af614b1f4a0fc4f95941b72de50e2b0021610f7b9b2be0295997c887dbf8d0824aa716992e782ebd545b55a49c66a1167c85e4c88e5f039a76addbe02a867c7dbfd65b21f1d08d72822c8af3fbc92cfbfe4cabbe0b5f71ab7849a13371c5f58f158b29561864c4e64fe284e56d13dd11d34be5fcdb7d5485eb2e8384d6761028722d154f436296c6e99fc2ccaf6b7117aeb95d9aa4642270a16ce2ac42de8dd0ee10ef6f79f359d5eb9c19508d45eb2a3f1c69916e8d3feadc9a0588bb0026554afeedefe9f6bb1fa242d12bb71eee203e7eef92239c974ba6f7590c65c8f16f7e6238e519d9b767a9800536f1f6bb89d54a5ddfc68922231b8cb2b01562565654ad0f88b999df146784c052429284d14137621af69adce6c3ff1ae1c0dfb9caf991e06a85ac85e3ab46d3f8946267c52cdcdabd6b7ffe2878717fff68a27b473f68cc618c4376abb75f772970bee28efb2af82bc2c73261bfbfdf9843b6484a69d889974a0f30e53e5827aab7afb5b9aa9b8d2f26a523bea1ff2ea30332aae410023f1540f12b91dddc05dcea806dd2a31ce1624bc15502418babd646a1fac326690f95d0e133122313b19f6edd834507218d7caf0079db34859d15f96ee81eb895574c1508ab6c11d3b7d42cbac5613a4ed921ac2458dfec8351c16676a55d57efb2322325fcdc5e27cc339896269f5877499b8902c7bee83a48344f34afcbd4248f201b4399f3cae5ec833e66a915613672a7dab3ddad5a3abb77c49267307e7332753945c35ac094e483b661a636f976f6df040b33bb89f2d243b8abefc00ec75e02e24767fa833096fa2a1ab30a9107f32be8a73e6e7a34a873d2dc0d317f0abbe9c6a6b3456e0da7978836bad1cd5d78c84ebae851f797cc6c1d9dcf9349300c9fa25448d5918f30f206a1f79facb162868e4c039753af26adb1270acbd4a8bce60ac4bbcc5933766d015f7f40a0d983c150920c1b1f76cab22f0131f131f4d59b818e2d9d784cdfeb77f503d0362eb8e46053c00c870b8e5901ee2bb441b4c87ef5cfad75aca6df4c28478e6253124881c53a8787684d8515c5a390f654071068d02e38144ac347933028eda6f19ad81dbd3afe3ec0351512569fdf3212425d4c06da5b54d3f5e450b9dc681379084deee3ba601259c27d45ca882630502c287ff5dc87150a4ad7fbf4df96f5101463f25b26c02dd95dc272c85b7fdbb284199c283d16fc8c031a6647ab501b6fb486743e3f8b54c3a5ac3aaf30d6f7f8b521d502838d9a0b15321fbfa8008d12acea1bb50c7cb3142c7f3c7725d0f5cfa248466941fa1abf67905af79d407067dcb1da331253603771d4526af2b411d3131dc14d9f7b143484418c22da49cb38c9dcaa4bd41ee65ffa3560c4be41e9688da94c5632f9dcfeb9abc5a84d3d5e0f39a91d375699fbb2bed767dee5a4577d136ccf4b18d87edc2d69eb5bb28b3dc40b80fdbdd77e34e3490abf8cce2c44be540e43f05ef2e90011c4ed7b471b3a71913c94dff5c71b8bc8660f7ebf78021d6d678dab15597c9025d21ef891b08989612c4736559f5b316e96e446f008529cae6f576628af0bc1834926b05416b9a7a9c2ac87d212b333d19aea0e820669d66bf626a703128fea9f8309c0a71e3f98fc158dd0f839804ec6ce54c820093af62deb52475d4396cc38e7f67f10320a8e565a4a04b5d56e9560351ccd5dd0707ac49f99d06f4fbe395bab76280d3e9ea606c1e5f1e30442d069a283404f88d6956ec5096e5d18a8e1b05361ded441095767571b97d12c1241c9052b99a53dd202bfb364afdf49851a45158727b491fcd48bc178d56eaf2767dd8b8f859896e71fa9a230722665c9f3d6d3e734607ee7648b33609a20d1c2bd23891f970d85a7c93b0f4dddc3ec080c46c328475980506f55853001d446742c615012d7a734ddf4c6ea12215bc57c2260b287431b25fbb9bf82d1382c4b0eca0518202a8923e2fdc1fd2e73a598359c475fcb2281234a6cec8dbb02e8189266214bcabb51ae2588733b17efc84e73c8f5ec04d7dfc1890d9c36237a98cd75b6ff51e5df8d769212f52245391319859f954a524af4e08da5e6744dbb255bd6d1b2fb22471ec7c4d9a1e12710e2584eabd5e038e27789506f6e5bca4c4a86f8c0fbb0227aab5aa1a87de7f0abe36d5e81be54deddac9c67be7886a4160fd057422c5f22b4d4b39863dba8b7b418b6d053f56daae29fbee6eda3dd48906652f25a8515ac1eef66eab1ee77de7f08e45d7eace1b96568b9fc86e16f8d7480bf7072d7409c0ac7676a9a12202f06cc9adecf3fd7687a1046b17a0ed3c0eca22bbeed6289a73579babd3bfd89cc64bb8ae624e99ca78012d328a76305455e7b7f1a35a5969dce463460e3621d39f85740ed7de5d2a046eaad290fa0e853270bff82817e256fa836159a4796420366bf4a582dfc97b4f39c1bb5269d095846c3f8f71b04335c9554c6c7582e59ae10846bfce65b4392c8a937eaa90eaa3419290a609537431ddf2db1ba7b786439ec0c5b32ebce2a8c14c91ae2192301fb94c0eb20c02187727a1126b47287ed040d4a493ed6695dc943f30ffc8fcefa152d1d59b4f1428dd5ab6463bb1faf8abc17eafb8d83d46b4653e7e29426f3c3300dcbf7babc94f257c565d2e564b97e623fd8efa489b7ceafb145e10e5d7af16244972f947373e5826bd7f0eb04d46ba0f497451ceee1a373f5372634b4a9a69fb31898a1a9716a885222ba1acd6b47ac34919f6bae6a03354103badffc66b9b7d6733be95130296349b4afdfb362f8c0da28ac35a6f9391ff64aabe431df52a176607882634f67b9bbb53235f149da60d6297db72fd65f6aecbd1b8667284cab1a927e96c732d63fd547ec9a9d4122a80bf2e307d1ebbbbf57e0da700d803cc7c34e6873f3118d9a2584992fe41348f1890a898b9e08b01933292330a66ed7f52922141fee3c999190f74a96fed619dbba9c77f8a210cfcb0ba53ac881d7588d2d8e7922a902146aec704f86cf1bdd566b145f62d119b3ca18db428ea59fa2a99ee607788d4f7e8b972b5ca4c763828a2727b12ebe9bfe37f7c14437944c4ba96eb470e97f5ba616e5a70a4a35b6a146cbdc69f0b439f1563b5e0cfe743fb4d99636cab2484b88887f4042db05382ad1823744bd7b7ef5dcea811ab6bc26e9e4e108117308573fecab1aac769ac5bdfe2008f5d70af96f3fd88ecae0791d37a6e350c3ac37ea019c0e2ac7eb9eb3db71f60402cb3d3e8ae2ece049ed06ea4b2e63aba03927642f0ccb9f728468e1a7b14973ff2187118009c7b87c7822e1ce7cdc42d549686e3e8fdcd20857a68edd7d8cc421c81418de7a766144e2b15f0a9e446128d27ea774b38f9370f26f88c2cb5ef85ac660a3f6392651b817f31ddd264330183fa63a915d2b67efd61e37609feddbfbf767ac0e818dcd346cc60365dbf50ec234d49fec135c58d5f24e90ad4e39308aad1ab999dbe8356aa60ef8b8ac5408f26b2b11dc577481f97ec37a6235f134a53960c2d8777de35a3bc77bbd5d76361875fdf0c31939dcdc33d4775c36202ed33de4b9c7ccf066abcafefc3ec3b15eff9cb11058f43c3626c6d5ec9f9715a3cba6fd915729326846a853288e786ff19311713e3e037e1cf1eda52f0e909578ebd0196f55aaf1fbc3149db6f4b30ac875682616abd9e9d5e88f2a173f44835a1c929b97581eb2503d63d85624b8d02ff7f3dd218fe7076811c921368b6f9c93335ad21cfecc935c84bfceed1e2ebd8eff017efa5653afac8ca8cf455d02f56d3eec24c5b69f1c1a24f86d8c416fe891eec04cf0fd64995a323f068d13121149972cbfa12dde29582f5fae9fb11e00f255e742bc468dfce56d7f85659899ef24e3502bd808d9ef137475a3fe1d03417cf77d440628c02c1f1a8bd51f70069dc66929ddcc27989ab90d182db6760454850a0b962746f1431d298a7a1f9d5ff761efc518ac9c4f628948522223ef9906fce013187cd11b8591078529477651de05b1a9e8328494cc633ab3405ed6816e4ad2f888be10024323fb7947e93f1eed16771974dc010e6a9545bae64a2855c107aa80fe62afda9a4e0570a591c105d518d28a2ca043f50275cb0616fc6997b84b31956b23a54d9fec77f1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
