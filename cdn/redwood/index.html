<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d0e4824ce22bbb804d7b477f94ba7c99725bbe9cc191e18e6bf3edf40c6dd89aa070fbea6aad8343deb3df29baed3089ae191d5607870434639e3f0936bc6c5e4fc7510c49f3729102ebac15421e64c4199040ba24d5514e060478973aef96ec4400a82a419246be54c5078a1b807ae8c2054706048efa91741481200d1bc3d6298b68deb03db467ba85538c6d6aab0504dc629d1c236e3fac93670e04d96da2939b4373cf6300ce20fc9ec6745d9cab05ef988fb68661b67f63b42ff703af6beec7775dfd5649521fdf53529d3fab5281e33957f56cef9a4ca81ceec4e6f6bd8346e75b1ad5c0083324c0e2cd76952acc7ca868f1c68d07d7d7ae05f14d3dfb07f390eab9398ebfbeaad64b671c80d0353b75bd514bc1c995065bd9ff0fe7265bb1835e88fd3b442a9e94df7a7d82d53472e62438148b396c671e497d98fd496fa52270d2465be5c1856f7a9ff653d6097259a474b03374277a0b2a6bcf4f70504f3a7bf93339db02fc998ac514d72d7ac1014a67c6245ade8b4cba7837b3916132df103e6345bc7240c78464d330379dc2d72576ccf47f21f41c90ab1be4d663efe45b4bc3ad2e85e917919664b2ffb131d3f605f8b189ca9f2bb6495f5ae44228bb26455453db5435ff6d255d63456f31c88ac33427347a526eb276f43a69289b8c12cb96d2e89f526190b79347d8683ebb1c5785daf914f79a6577b6d29a9a0a624aeaa9837fca2e6324b0ef1e956e7fe9f3e0d42eaf8f3fbd255ff7f6bbf3749d32d8509b0d92fb38ca27ba728be3c238431fa32e0be4e109e8146d162aaadf7c90bd3d3476b5830d03f115186f26738484a92728a4debad11f83c790e1c485bb95364e6f164a1f64f071eb081cd6f75c1e06c0d2fa96def2656adcc19329983f05e6ee72cf289036fa09465980ce1359442e4e86318622d9eaeb6defdc736fb39d1ccbde682ca096b231028e059ae61af97ce305facd22bd0e7ee6b7b2f2bd774e9cbb53c4cb3737549c8524154cf770254b8a215eb053fcdeafa31e92772a6ff04254ce7584f576fca9ce823a7279f47fc6d0cfa886499f764f2533520cd700d16f791c96d2aa7d3a6995fd93cf10b5b2c0e8e67dd71abc759bfa87ad9a40381a8b2f0b5d73180774787625604b369efbb27f4f13da878f35cad9dc060b7c1b4d5ad92c9ec5ec1f63dc0a3d5e35b236a6f62ce6cf0ec617b40c9ee688a7d296426bf29c4d1a08b27136b5bbc1a5bd1a751950e3e4b81f4f7e3b0e1426a6f3195e58d462037948ddaf19d9ce7da46646fed614ec4c79fafe7278958a753d21a193a7c61024ab9931634782fd0198ffeff24ec3ab2c14630b9aec6e170bfb3e50a074a5390b738c0820dfc4a0ca19209a11074eddb465d9adc5d955c567f31a19b2a1c7c75033baacf99ab33d8eec638780313f1eecc70e3dbb6bf6472c4aa4d17e3af175e85113cc58d14112125275af08f8379cdc0ee9849c8f9cb7c555ed07b98e498e129672478ca7ce61364a2b58b481734a158809de88dbaf379c42889c6fcb5150ab3e9a4a842062520e5f172e73d33a10b9ac24c6f92b976fd6ba793163efccf2a9ab845e1d4518f3bc79584de6f4bec7187e5a254afe59f80b386cb778ec64a8b7d3530892402133e8be05bcfcdac3695d271598b83b7dcab0a6a6812fbb2e97f6d47bdddadc4e2320d3bff1442bf36dd9a79c61e8bdf9ff7ee4650a9dd2f7748b07a017a196a6300e1335b5a3a277a3c6620e17d185da499b89d291956779b9ef00fdb123e552b1414dc294c30131489dd50e4140ccb67f3ded023b268bd3759d21b9d4d343aa876c42cea5d0af316f0fa55a4a4b7afbc764cde2c5d4cf04d3ea6b84e3d7c1e672d68242622461b436ce785cdfef6ab7b54410e857de305fa2c1bb8485254be155c204794c28f5f12747718904ac39c86590058368c9e51676981ebc99a73fd86b9d1c6b2efe6313344c19c608b1979987f649c0fae0e1875827a169c8b29e7413d962583a26ee435a8b5e722ea5677859402c564ec0ce3f56f2dd69f3316470eda7abaa066cd43a0a27cec44fa209634a2027ae6463c54b4cb478ef6366d0cfffc86b98b695b95d7dc836698b07a0e7524ffc2276b58bcda67754814168e0c2f96b90089f8c9f4713402609fda0d0d7c6303cbcb9fd3103f330e8a7e6d92c77a2c3c57ac232447c353811f6745b0ce625bc914b3694ec449d5427d954bc256b3fd0300405355483cff31cf14ca368014c08099a29c51c9628138399fba1051c1e258450784635543ff9730f7714d6a189406fa23e8bc57fa4f956b20780de312a55e1acc2f52fd1f763c609d7b76d41586f77c24c34ea63720b83f5fb5529aa2303f3f271ce49dda8d55bc900ab981533fe5a8e2457983d81d93c19c84f2b5b4c95becfcad5f208f8bd124318e94144751ec8f7ab55a3495e8ee586d6ce5120dae0a31acdb3e9f0ecf40d0d8d9023d9afdf596ed3faa56b10ba013cee58ca37a9711d6ee78167e093ca6e071dcdc77cb16e31e0750d1d6faedd09292e9d5c31dc348ea1ec4a4b6f73bb38378d812e97916975178914b45beb79891af5a532ce440cfadc4be41fa7c20c5efd6fb2927ee0eec87e6f8b98ce8e84e4742922eb578900a15be7fd760329d936e61ed5e01985fb1e205b0fd2f40beef244d552fab538ca77195b2c333876a2cb70a77fa98cae1aa27595b809a9c66c0130b039bff74195604e78584c5531701c0c10bfda5b04cb597379da84a601e9d8c21008738db67346a2a2e2c831194a4ffdf3b16ef11aa05fd5f9b6534540a9beea3839e88aa347aa4d891e59e83558d3ae8d4c001e7b486a4805895286660906a6f93d6816bc0756e2ad2263480d5103b5ff75e5b85820dc923a5d8ca19ca44e922b051c7ce310037b364503ad75f6f70900f72098b0c55563662b0c2d752ce6ea52606ec1c4c1bb197b12d571c85e556bff7fb234ae3353d641595a3c8e497494f3bd4843e0d3bd6a24c18a13f89d51f39e0d46a92c9a886ed7b3cc8ee7b9007682dfd004608b7504cf4775d72abd06808521be4bb80f4622e26358b92eb5a3f4d708c62ba47febe8f6bf5bfe36f51014cf5d56d6d627fd929e41718ef874cf57ba6673543537093a5d086721be4db5f5847d4d15f9c6d03254f4df2eb2d0b051a5746fa3d9c7e0f2fa07095a32de8de795e0a732545db56ba73e277593db0a0d51a3e44ba494a9ce07c32e6bfbae84c3385956abd1645fad28d66d87e762ff7e7e626e08fe9a534a997a33d4ac4fae1eccaafab534b67169f5d3d1b82ca235d2b35ebb54b2649032198c4c0645664b23630b8aecb512efa716f139d76eafb5553b06099f620ae50a1f3f6b5f0f7e5d9e179ae750a66e27d2e02c6dd61d13f395b80ccf22a13dbdae52eaf0ae1eb2075336e7c401078fc63b242516ba32caf8f894452a9c7fbb9051073987e0c97a986d0f112acff142233b99e37c398bf049a51b4c6819f9b2b611e8db759fa4e08d39daef40df396b5e8845c4215680d9d09cbe75f1eb5c396e49b07c45a7fe766d9e3bc19abfd226020cf58d633489968160f713bb26e52eec911a67e54ccbc1200ce74368eccd36abdb0623c1e5d4f1c83941250a83705847ba917341ec77aae9bcccef5254fbc9f37f176c15996ec2ef77001b2421af46401cb9aad966d7f13664b416c64bc98e73f47590eec23b01168abaad00759ac03b99db6e4c40c932525d6db0502a851f2fbb5acafb45163f78bf403c6954127e52c2acbad4e40ff8acb4f43e814e54211e74e3a091f542ca8e23ec03153e6403dd58a94cd93a65525c8b99d7129df73b67fbca41f45a7c2cad86cd16d5bcb89cc152842bdf234c54208e3e6a1c77559b15ebc747be71a3a311384d89a9289457c55de349cd372ccb2bb98f4a556049d93de9138d18b03a41754420526a8586e90b177e8eece24cb73f2a0c1c5d4c22be009a5e1059f2958a14601ce3761d9eeba11f64bff55fc339d18fa9c72566e5355ce657b0bd69ced0cf76a5727ffe3c0f4d447189f17c61e5faa90e553b35f2e2841facb5ef9121e619d03da42c9d24d4c598d4ebbefaa0825a796104802f24cb82c50d1eb75dfa73479722f28f57e25899942d0c54b7bccd8124d2afa93b6cb72a81ab39e9c01c5ceea9ffb0bd7f8e22983735842fcf67fdd50405d74ce75221e57a360bb72c0cffec9bad66c29c2f24da0b9fb578743dda8129b3116490af79dbde74859af0d42f1d18c60515fd7cbf38f5f2a90e3f9b159927afe6c8e50abaa7c752574634c8482f9b8340d545473526ebfb6c688f12758607a7920f5b902c2b4827e5ef11e3064d19030389bda04a8e201d24a8a3508bde7302c19a0f874b02d06dc9cab6ac46ebd1d5693870f5e22156f525bd42a5b417ad8fb11a7287aced35c519fb4322d7a3be22b79a156590367697f0c75e2173e4fb91162a052307d64668b5c155bb9232c7efab89c14f4549a8f2d1dfcf43239256cbe06ea390d7f8dd88dddeb4309465c01051ce17c2f3ed96fe8cd4e6949826cfbe6f3b7a31010e1de49574deb633ee3d3b92d3eb324c8b5fc021d7d961ed9199945439f7758afefe83bf913dfc5aad2e717f6d3677541d79a3024d1d72427837fc90ac37a030a87fc7873e3e3bf576dff86aeedd5c0021155b07062da98eeca60f7604ad886a35065cb90b206ef0dbb990420e914cb0f65d7e2b69ae930a8d5dcca28dac4bcf78b0b8843b33fab46bea4ebed600c2f7569f693c46fcd1dd180009457d20b6ec44c5ee91735ba1548514871a4654fa74f86badf8468b7b6ab2c09a8249df3363024561979ddbf3c84d46087c6fdfab99e280f20bed8fd0db7124bdac130f2e5db0a41b36b781fbce6409b72065e7d25f7aff8a217924fce6b8057209fc3abbfd2b0f3f274d518bb53b62f41fd79d76c34626e8ee1424b38378fb260eeb3cc238a6d5917f824f0d00a64f63ced71279cd378ff67495a56e717dafe9b434780c48cccf21751c89ebebd2230ba213d4fc3b6e1ff1c4c0f76a4407ddc005e62a44a5008fabfce47bcb8711a7b64eae40f1f360a1aa6e5db4b7338d30ca17cda1005a9fb75f0e2fdfd58d59e4302ee51abdf7699e5e8542fbd099ffa4d54752deadb3ea81c45d7e59e1e69011f21522b6756a525020c22d8ddbe1c1e6631cac09668c4b756ada8d8a80349aea555d471fb488676f8aef9a999ba86954b6d24d5814203896e63476fc0d4206502b1795aa8860a0cb9452a5ef4f6ae2313db4910723aff942996696bb29bbf8e9259ebe0092e593f00f6e244e14ee72736dcbf06cefee826f8d944ecc9e5be7a12be4e7887ad5d65598308c623f758dc8020f973a57ed088879d1dfc770271022dc6cc9b8d9a783e16e158bfa24a7386a85a36ccc01a1ee4c642c2ce00d70ed07c6ca11091c22a30714243102c5ff80064ba512e42748df43271f8bc7c2876162da9181eb8405bf63cd2f1fa793e469883d4bd0c2470c6d57041708c9df4d45bc96c7c5e37a73441625c5ca02ecd7d5e324c210ac0edf488c2a170dccfe156a10759ec5dafdf6ccfa54ece82a4218c94dd7e349199c7d9037c4a465a2f9ae10eb5987340e08db759876e00baffcc8877dcfc47fa03d147fc4620d919ecd6d7cdb3f4e3c4c8973fb82154c853b4eb9d7260d66c886582c13a9dd2d5758e22db03eec4c8d61ff12d14a5bf2c48e754c6a13cbac22d7388da062b604c6cb32922edf57fb811b3bf9ffe68e98dd6df99f5df904710b5fb8f7312e0851bdd85950864b137a3d78cbf890991cf0704a5447025207bb90d2a654e19556fc6dbf345e7277d9de1b36104068eec46a1dd33eee54159f0a1872f847becd48bee9d1f1939af128236f3b6a23e10b5714229d7f1e8ccee4858ec3468dae26e7f9ec4e22d67ff4cdbaabfb047c4c42e702f8edbe9fcf290ba44720e6bc0e3af4d72a1a02b18bf0a3be27bf353ebebcb9b9cb85d9568cf07bf9b600f91d5ce70cefd89dcc0d3f620a4900680420c2ecfd984d627342726673b685a72e363baefe00b079fe57071f19392d7259cbdf97737c80b91d60b29fc417e496081d2d29b6ec1473a1e1f327a692c312fb12a7e92ba81e7d45b77637a85c0ed3ecc3c5739ef63de9eaf587aefb5df3e8b558704281c491510a7d830cddca01300e8bc06ad46c883231b0d0e3e3fbeba28ee24e6c42da75b85a289fb874e4ecb6b0e199b0f663525ca9dd3545f765df581b78f8dd05cc0c06061d71ee58026f1e3f639e4a09258ec90d336f4d013ba9c9d93f07be24abcb58596fe8916b0475a482f2c9133776aee0d0acb0d6581c92f7007e2e88467816e60904f9ef6d96a31ba1824524d3787a6abc70f982d098dd5db19072943497441365cc7e683e4091974dd8f8519ad981b4cf6593899bb70c3c7031c77a89f45e8349ba31a344cccc3763e6e4294b6692b02a0b03154c69bd203985718d7b9d914ace861ac619c66eee86d87db4f2dc95153005e4f16596a809f3849737b0c44070f87957af9ea577ad201840fd8d502ed401a81094f664a4e3c5b8d27fc4f981217fe17d86bd52a230daf624761859d2790e16c8be8d05cedad852cb2934fafaf5ac584eceb1bf11e0791986524a52bb11f2a0f448220174b133f3ceb287aa7a4ea5e2de918647e75494c2b248ad2c15dd641b89bdbe557417f984a45f79a8e73154a679e01f099061bad1a3b03987444a0b5e484751628deecd2273a452eddc52e84f25bc76039933cbabdb63c015a640e421a2ae54f9a11f82b11e12e428076bb3bd7c5e5fc0ade3da02d8f7a0c7d06def9f665d87ee7932f975d12c66b770e6e8cd99aa4b9d72a6aebfbf71882a7a7ae5e7dbae3561c87ca65b19429f4c068e511f4f1da623ae8370e58c76723e7d6d9fb3e609c7ce933c20ee573d11636d1d57b6f465e20730ba1e90d3764b27b36e30aee459bc647c6abebf30b46bb9bee0125e59e758f629c5f3dd6366291499511e348318d9f90dd2ff1cf923f3c374e84ae776f2673c14b6ca053f1effd5c6112d99d3d482b3d9a0e38443a63053885b1584f9bc14aa6099977e8112cbc6637ff87a59e4e83adde0ec7d5f27f8b206ed467ca1d14211e189bff75f304b14a0371ebdfc2dfc62ca81477330588b74e2a0bc98a6d77178fe32d99b600df1d2578853428a860d8d3f1624ee8e78304e672f0a40d7d616e29b174230f7b3441074ee13c5c7167c3aec721f0fee1c66c5c87a11317a93886a7d96bdb9629f12050cb63c60a0c22b50b21682ec62b11bb5979e47cbe4a45008c70ebe510e5d423f7ba0b0af2c79785d2ca23f39d163acc40632c5e8862753dd7e6b8fd454934b7a06ddef2ddacc84e90cf2afd2f064b9337b1ef7c28eb5033f3b859ce332b51a69612543f3d18159f1e0473345195d1fbb500a8f1a0a87740644c99ee2f9c8cd6529a21bf7b07b8c856165359d5cb25050a72b038a4aff9b6555e97fb1d09e098b021d5f815f40838abbb65e392ace6807118867e41a1e6ea87fa4d0860f0a8f77b5db0a287d64d36598a1d35ed444b7fb2054bda9f24d3c74074dd27883727475f1df8528d706c58e673a89e9872436e68163ef80f48678d7b818603800d99ca3127905e877def2196270c86ff15192d926fc550ce3682c85f7bfd39011b59b68957d9e1e9f397d1442054d9e7446d79884dd45d0bc34e46e6510bd20c6dee091b404db19f6420e5069a9d1eb5325cc9464dfbcfb16da84154e7a0718457bd8dfc9710dba8fd304d03ed2af833b04ad7f6da0d233dd1df7655b42f8dcaed1fbca9bcd2c4e6b2a3c23d18d11d682a438f13a1c8356650f43df35753f3c4f3b7210c4d3be196326387b831f254dae276046c04b16bb107c50d7472cc185adcfe8d0c2099770e9eb0ae646b195a638b9c2aeb9b54edbd1b972100fabba2d0c58ffba4a095f5ab9502f4fcf74c26ccb5544d6838891e5610abb7fb25d90cae4191c7ab7f04e75ba7f4dbbab4722830d613c8ccc9904849b850de11b2a6236edf03722f5cc05fb4ab946881e1a267e0313af82bbc3aa354779957e394c7640675d3350597eb8afca69d4e14ca53445321c32b7748182e48e0bda7767f7076f021278963c42eec45c8fd2fee4e66fc627b46cf6bc2fb38bebcc3ca227c92efa08f9078e923a00ec19c79a3de365897e5c65ec6b75d1312ee531452388a060ec3f5d2a5bfc8cfa10ea65c5acf886393d5858149d4e0ff04a967b4427810d87e2dd1eb76150b87c1af821eda5b163645b44a326caf36fd907ad9c23a62ed3bca793d9d42e2a56bb54f094b5955db4bd4ad5e6f0a6c59621186426d593d5e139e9fb7be07425d31c951e27e4abdc0a2d9401005ea5bb3e762f2d58238ee4971ce96014e1d0a6e6dc87043131818255819846657d539599772f9a33a873ade73a3705e2423297b81fd52d60e38292925f1552f91756bc2bf1395f7345050d8951e46342d4b162c44165091ac073b59af20bd3acef408413d94e3a7e6bf9d52ce57c5c2d184777ea70c90a79574083fbd0d718ebc45f1df66a6de5a2e17c94b2aae1b741de58c51c349e3f0f1d1c5f70f02720980ad3e0a5a1d8a680e8d4b657cdcb77e49042d8e482444d51e1e79379516c8d0a9c856ebb58d661119281d6f0d3a23f84a4c4a502afe9853f8505cb4479929f0f7b2b2bf540d7888dffd642c56c705feeae08466df8cf342d3fbf9bd90f554cb557c44dfb6f125d16a46271930c452620b46b503adbbf5f8fbc3812bfd6a274fd33ea744bcd2ee100bc19c59562c33cd0ddc6b620914134dc154e6b8f37bbd7b44f8b9cdcb46c8a7df9860cf7fbab69f786c60083d758acd1bff0cd42905f3d2c1aca9f44b819149c012cbb132b981ade4e324d5e745b74341009dd828f7c2034110773395f31460a9fd7a0030c7316af2929ba24a94818c6f8197ced141c89d0619ef217e4e023f7af7e699e82653d69cf9fc2dd077b58bbbb974a0a8b51ba3529d38ab764488af64730fdbcdd30985db19e524681d09289b25a98785d71197e8b23dcb6a7bfbf6ed446ee105c0de5c8c2896e705d68e6cfe713f83810099d567f0b5ac6461c91a8e6fec7a45b91edd78e2ae2abe08ff2bf07d73c482f3cbf1178eba4f235a044b906d44756863952a3abe549b70354ab4f381b106648ac9e45ed33ce629f72eb44e39155573df956367a864b1a1ee92adc44305ba13f4e980ed95ee87e4c17c123640e8eccea14f575fd452f570d738d0b74a720961ee8431b0a17cb6143fba45e46e90a45e211baa28fa93ae8de65fffad9b42ac7018b9a2c0b6b53e35ee5d08fe19a434189c366cb2ab35d15f771641691693a232a81bc50cd1b9d133fa80c552e3119f3a695665d683a9ba3e3c9c89e360b73aa36498ad26eff79ac14b08a295abac5ef79574020d6ab01f7c88afefc862ced437137fd04caac636bf49feb12c096292eacecbb30f52c3180f671fbfee08cb59bda7b9c07f488701a4c0137d7a1125165d5c56312c2009e4e27638568b51dcea1e2c5feb1f96ca72e9d0edcb63219c267084ccf8fef209a159f9375139e052ce7cd4c74a9339936229a19e6637f5376a706373b02fef5a5b0dc6570fceb61c846f2e9cbb95ebec2b98427f2ff9f91ce7e9a59414ea6e26f77ddaa8f1395d463900bd9b38d92a72711542417922ccda7e62ad8ed98a1a75761cd7511d78b0e3a119246b60276ce2c3f1d0e7d3f484d34a234c24dd67c05c49ec3bdd49c96473050afdbb665f4d71de544f02a1842a5616b6f6c4c273f382fe2962c80f3462fecedc3c2ba8c16472afd5d50052641ebc4ab15e48133ead54a0ed606b8bad3bd0452d1dab05f38ee99cdf5dd5a7c0f1d67db94300226c20c241dd7de65aef0c0455b6caaa8efe384ea49b9781757932e78d509148634b82ddf298e9408f4b68e267d8ad61698cbae056fa48801b4ba71fd32ad7f2853e6030347b8e7a53153b3ba9949db04813532b252e09bde57978d9620b3f2cf28e5993e6547d2870702be7577d9c9b3a6692d2709be5fe414ba50c6fd84fa7aaba2cc6ccc6b280a58dc9c2736f4a62192e6d5f05ef90f3dffe24edb5397af26631f8f7b5390e09967e0dae7f69c877ba5043a3d64c7f2fe8cc3619f0ab32119aedc0abb066b7dd6a7d8972ce0906a3a0251f91592771985d3ab796060020ae33a90e743bb34514a683609022ae2553802707ff169bf67748b35f0c461959bc868db743683fc1d142e3e01b40f321feaf9d98bb611a97413ad6548e3b4e2435d4c255f7ff26a0fd0035c242c1b87f67e2a3769a9443ef38fcb0324e16b53a7c6370425006911c96ca925bfb2ec53f2296a39b92ca76d82c741490be3c0c4edb500e973754b84402c09c32a7503a9ec884697088f3d5c013b99e6f187c312b97dc1a923620250e77e85427c6d10814c0f7b0465e0a885417b4131ee96cbd77b1c246f37567009f72c2e7c4cfe51685e4dca357c3c7313a1f95c3bd891dd30c53de641187f055db643b01c3c59cdd399936194bd91da003b0ad07bd2db6cbdc36b741831ea089f49df1581c0fc14d139862fd583278361686105a6380bb174e8c174ca1dea33630258a1fb1eecf8fb3134d975aea770e64b9135eda2d71191776336607c9986ca1622eb2a69d911c8f010887baa6d4213d5bcba0f907a60ab519ea78a53fb1df9ce9998501b8d37cafbe48366fffa7193fa6b9343a53c8d346e516939b446eac1c9fdbdc9efdd65a3887838a47c6b9fec984a5830d8b2e98eceb2d6d0728339f1f365470765b851ecfeede856fa1fd64b9dd2485d3e8de62396fbc8192200cdd1c5d8e4f1927be484ba0dbb3e0f832ddf7575c2d72d19c753a8b8975b0c911357c11c0588926adedc9aee5114e07dfdffd4b20952d3aa294688ebf410d7fc572a24b422722993ee6fc7483258ba9ed4d31c6505afe9c20c33606d32a688dcda41b32cc72fb6d38a4375c7518849a7b21a0c7abf23d0de4005ff81a61a5fc7f287e06ea2596cbcb3204a24c1c0161057c063ee0c58dce0c64d906338dfcf24c8d4a3ed7154ae2f44f0d30690ad8c5a4b3e0c929dc9ab04fa893645f4c74f148da94d2d2cb226e3b8e676c6904bc7ec357acf28b5d53e262abd39c40db1704280c4ea8786e6796ed75b5c0e423affac925ebd6d36b29a22f27f88bab12a66e281c13a7053369b5b8f8cb2dc4b9b3f0bbb6fd7eb6a499c1c81398d693b020993c172ee50f0bc4641369f2aec2635803b8ef087ccb38917746aa0a9ce75cc78191f433f0e80ae906727c5f0c51da539d3bed4d1ad848455dca579f5f8252eb4314a4eb332dd4e8dd18d78dff0fd7f9228009e9fdb8b324f5fa31665a0c6ed9550b5071f14eb7bf7dfb6a4f18da1c58f671b53fdd6ef3321eab6853e48d2ef8ff108aec09d2f82a00d930e53404fc78429749b03dcfb62dd1a178940aa191d50101d911816f4459ff4a8c8fe444c9187b2107baa764831685f2b3ee9c9de41733ba4956a501bca918b9ebb7be8721cc50149ff1f2f49394d43b2ccdc464a58a1fa3b0359dbaa13b826c654ab49bb7ea2150c1f95f68609d80cf2ac3174cf6c922d51b78b9b2de478e07239fac8d4dd8f27cbdc43842e33f9d54d34ec44dc26120de8a0aaf6c83a6684ec3f44c88ed2ca324e9f0d6cb9061509c3566535d877e5f7244cbfe8b22997d1fd0a31827c9cdac2a0b9020f65500fabd7e16a437b8b18c773bbe7cd1229b6450d201ed8946f70cec5cf2a18ccc367ccfb5ca7dff3d81727bcf5e271c176bca5b5097d05fa9fad76c92a6bc8b8dec309e27405832711bb962ff20abe7337d29a3c74aadacf85ad76282d62f955f0f56af201d50d622603e9673908b7223daeb4f7f5597d1392a348c217147a8ba114e29b4416dd196321fb36a9b45c8e9d028361aa17514c227d4301f909cc32490fda3425e5ac2573f18577e268affee1254d89d5662df091f859b73dd0c8eaf35894ae600b61c7dfa13b9deb6050dad53ffd7269b909f0a903f18ff92d87d3e7ca32037ec691d926be15746e4438644302045cce7e6845c501dc60605722e1226ead14c1e7117e6cb4a251de049855fb649e4334f2ba7973c026ccb9a6eb448ef63b3212f7e0cb141ab8af3dbeb8d7ce09a7c77aa6a29486757523e625d0846d64996c88828f92f65d08f275b9ee0b205e0bd6a0024483407a937252eff115d50fa112fa50a4d10ae3204b51f38b0e380781818a446b32fce8533259f69cc028525aed70094999ca09f5654b0beb012573bc2400e9703e08ef2e18705b975d1db11d9570417eef77d874df8c0d111d34ab9abb20fbc14cc181385b3c2d5cddd5def5df581a02116caa5640bff5948a5b66a2e21a586f6d55fefe02939dcd1acd71803004d2de44092c5af225542a22d5091a67c9394819aebe357bd07760b2aecc19d930922defc6b4b19b419a55ec0cde1c91349f5adfa92492f69a7aa762199a4f582900cf4be0efb6f145788556e60ed7f67c357ceaf4d9f3bf4b3dd8dfd37e7010682f56874c0dd8a12878709094e41c67989f75494c294bf9f82bb37c06791684d0bac00cf2ab7d59c14da88a27380caaf3a05105e15486685ada54745e2c89762618409029c47c260e980ef7f10477159501d09d9aa7daddaba21dcb6493c052984135d307c4096058d86ca7df7b5191f1396dffd0620ab32f71588bfbcf6cc08cd48d255cd328bf539900099c3a2c2fc3be735817e29f3d112d4ab9c25d3fe88fb649d32015998512d755ab6ece0e60b91567e0e0973633b4fa2098980a09e43c44118dac63343e5edc237ecd1b3ff03abcde5c004257f29067cc309ebcbe6b865be8e4402b963cf2c2d2212b7d5e861b3dbe6c696563f86314024b7ce61a028f86fd284a10001a8990c7f818ca5754fdb040b5e7f1bf608e3812e8d38ca2d9d6ab59404e31488d65a2828c9c7c5b66c286990baabd3926fbbb82d6343260760fee007741cd4dd0c1e68c598595e5a7a883597790b2bd19561f04df80f739f5656af7c5309773b268e50197732b8169a4b65a81c14254fd020a7def5049787ac963b95e026c0d7712c6715459205ad9c51350d669ebfda8e56d6c60aef8f214fcfafc3b3079efd3cf633f94b8623f0584bd634d95d87a1742db9b41f99efc59fad322d0715a32772fcf958baa7f83fee540ef679938dcb7cf779715075751e4a0e1808ab3283aec1e485246b5799a0d9750169bf31801115cfb1dc6e13f7649532530e407003db25137422ae1e12b2f54dc779190b9313e53930f47b24857cb4c12217c4c9a676ee0842e92e9a6fa66caf5f8cd149c30c5286619eee375d5c5e23425c0b522b8627923e061fcc0e7ef2c1e5b58d628de52b6be6006e47fcb51827d5221d4938d731ccaeb67d16039ac97b68fa9cf8c32c7176436d074d449c24cc3e8a549bb9aed579bc4df904581112b3506b4e499aecd8e32b31faf3aaf5cd036d2171178f1ba5fcbbc5b5eea7e4e3a795707e85e4059c7193807aa43a7a7fe807db72ba34821ad8dbc53b9ef3f80120c1dafcca72e2084af2d7f17d26b27af9c6b7d4ba93c15dd9e6dbeac315aa657602276aacba4541c25c2bfda5b1241bf96fb411fc2250873f819696135e765b514a48d0bf855a702bb2ec6ae8966f82962f00f5fd8647cf5731741149ae9b8cf76481361f86548061f7743bc04d8dae5e2bda74502be285915fb0f2107f1cc7d0c997be70d2491313c6038b3a2d7a0ca386ed7ce495899856a0c49fab0d19ecd2fb84df010133bbe90ad2f8a9bac91919e3d5fab750568260bdf5b0914970a4ba7ca861c8de6fb3f72a6a36f614b3ff0972f39fe2ef253dad6a4e4183af8f625af68abe4e8a457b303c98aca0fd14ead08c396f7d1e411e62af2fee6c08b9b42b1c0ea403fae7d5f5a28b5527c4de578c5283e7043ee150a530262420d929ad578c376448fdcbf132d50ce8b09f37d51548180373bb715560bf1cfa259f356b04e99bcb5a4da6d219a7d13612cf370586ae215a617a413270a6013375320cb79169a8c36265cd352bba48211029d54e1601ce6a855406bd433fc63df2987498e2e7b70e58d2b3c0cea8fd41ac6dd55793c0042a91bd84168b8edf29acb08983d69ec3a23defbfad44e116e63a19db1fe3c84622d86becc66ec499fcc2dce79972f622f5cd6d39eb267e6c7e54d5bdb842aae89c62138dbf6d007fcc1f9e2bd0316588864a23de005a195d9e9c12bab7eadf2c4877eb993dd8bebc898f0123041d82d6aa80d9cd950f4d018f53abb88c6f673d69e7b6efecf25551daaf940af88e948aa19f2e5d753266e129b942e18b8936b7320829e830cc3b7eb1cd2a3bf9a93aa040dd4ff81cec21f2bf2ea5a617a914b71b1b9aa93da7188bb4ea75fd38d8d43419c94cfd01027532af3dde82cb4911b0ddf52c42500d662480ed648f0e01217ee1e4b96d24f1f856444af683b8dde39e5c5b701c7e8a1a49e3540b3130d4a9b4b61f65b43e1ceae9b96fe5a85795d5fc9843dab9ef30c28884b0bbeacb200f7d846d1cacd9459d3c3b634fc321ce869d71d2727c43ee28a0c7bbcab6f3b8970bf69a33f3223a4b16f2d5d22d263666cdcc5cbb7a5f5f02423b0cdde385b4ac3f6530db9ceaf78f643dba09d14202213adf49e5ac0cfbb4b7b5eefb031f8b816bd4f857b96b477026a239205002f1f474a2a56cc2ab37bc733925d856c9b7626ee184019a295e4baea5aab203f78da9fba59706f8cf8c9da66e44ffdd31896a4a0cb08c017a99c3f028231d18e9711e5270fcde5781a6bdf69246cbb72a9a272485d9c1a41f5f9daf5014e601e5a626c0c9d2a544b3831983b0d4365c1e53ebd47bd38d7713ed47bfd406c8ecd2c35d7d76e3936961852b29e02a05dbed19014aa63d9f97e6d902fd4d1c84a66f0326d9c03699491986930cfdd84ed3b64d4d195e6554027fe33c65bc996b90aad7316a4aab095e414d11071bc2299816124778e07ac9ca18f8ba4cdcfd7ebc98a7ebfb49b68ed905ae80243f682162b34b73310274cb07737f18e7047e1d20e4c90b03cfbaac4e592aa43fa88f40d741cb28a64624abb82bcc090e4f8905386716ba58afe26bdaf5e3aa0652003b665d680719d4dce32eee26fccdcbbca8b75c336faabc26181a029fc639350b9e849a1f03c2bfc92e24d70b9597ae0e8116d8c20895b19a3b99f716956fb126eae812b6aa338615951769bf14a30742c192bf60a07905a0fff32098d8891467e08329099e34cd4e3908e690a3b4758449d0ab492cd5740f13455a3f5f18e023cd035afaf3f2697e4bc56699170ae38fd445f61bcc2cd4b119d0db2247565b398b9c098aa3c146e737a96dfa63598ee920febd4ea2cb0658587827024a4c1f16749e528b001d999a8941830ddb404d15cd6f915ed5db639d44e695e8e0dceb9961e97685e4df0b6d37fd1fb1dcc7aed93b16c3e95b89cfdbaacd20ead942d47fac100c79ea938bd8bc5ecdec20464773364384b8b415d10a01009f99a189d526387b32f83895277011b1d76b4c1aa3596f6cf22bdbc5d2cc3673f8bed4195dca428775699fa7f37eadadcc34cad6cdce9c2950ebde80e2cf811715225b0ca7a77b56c649c68009c5fc9c652eac64f84b70486ccd2040d4ff9d8414ded9098dec3a4815ce368a58587c29fbdad382d7fc8f348da3ed4c208fddabedba82a47f0589b125804fc37b8b4001e44052285070ea9b3f210b32a6bffed5e85b574a479232ac16d392dcf5c214ede6d28ddeff51f66996deaadfe58230bfb5cea2874c1294b0383206fe881f86c2c4d4ed3cc2badfee5f98358845abc699a2f128e0d1da4a30ac4551fd1302e6c51a4bc757dbfbb3673b83814c7ee8a63c8e1e3e844cefda7445b428a1a1d4ed6b6887e93e10928fcbc4c0df1ed82a245ec269a366f2141aaf5d0dbb48ec17fa6e6df293b51cba31b65323449f1332b43d3f2b90dffd332deba01e41bb985e8f00fe28bb6810fc818897c288a311ac3f38f8f3203ff0056e06e4019bad0d691bc8df89de86af538ce865c9fc4280cde29f72d643cfd6f1b9d03fa12b214f5db42d8fa0c8c53c1270894ee336faff7f6384e70eb9118fc9085ad2dc4e7debfd86c4acc36fc0e31f9b6de007ee02a5c5cb7286c521402146342556c241094740984820853cc48bbe5e84f7de1d4d3c27ce0ec504c5de9b6d17a052cea8e1ecb478e497c6206f7ef6cb81831555140516caf5f64887cdf86abbb03653aa129850eec367269b0c8cb3828b244a4f4a147de4016cdf5b354bc2e081e37b07fdaec66a308e02ed5bf6b396e8ee29bc8603c18e1d2759e16993782fd57b579c23cfd23720b28b8ba5f4cb3f3769e3e3656192bd20625ee856ac7f2dc40dbb86245d34595ebe67410726f4c69ea868ece9c8e12cd35fe4bc24a4b8953ba0c91bfa3ca90f47cb2e28c29c33f819a2ca1554e48fa655b60205139192975c923e59fa6ea0f612c4736c7cb6cd38b954f7058dc1dc663de5d11264edf9a6e58e1c6cc0163ce0b09936d084d5c98cd547b144c4e2ceb8e1da8e98d2f2f049ae773fe2406c14b424c9e24cc365e320c9ce0d968d542323657cab470b498791999947931e94c267640c4a7d374721398b3b75588da5ecaa6b82f1ae2eb00d361598cc58a6bd915d42c616ed0a0795682f68c891216426f05aa3e081cbc2b60d833d0b03a6c2e8fa85512f90a1183c44d302291f8b4661c9b47827c66916bf4436414722ff05edd8d80d66ebdb7eea11f8117acc631e281ea05072e9c4e3ab32e3e94ef1a4c28425bfc7920e007ed43a232365a2cd45c18b2efe4981cc8e8fc8454092b6ebb7aec84b27d640314cbe75993182e636dc93cf5c65a669fe5339573c93dd249fd9ac533666661eb71ca8dc3ad644064c7effebbbd16757e4fc1985dc287269d11415ded328ee7ddd0a6a4744823b27a4e71c369e7e44a5498a173d905d866336868b234ee1c5c64385f02b6d2de4a7f31c30316b4a4fa10215a8f35e3ed60b4cf8035e0b4dd511e4381378289d28f3208ceb95eb470e845b41d2d239610cfa00101fe0c2867ad5ea41673d1b3f05eeb0d79cbb02802dda8b3fc4098664a1c762cad147bc290c940f32377c3a7cc80e27a08a46c0f150489723b3d27813b7798b61f9056e90afc418b8cd9f1c738ffea25f97bded602741966050ae28426d4b250b2269e5989e14b56f8e9a8046b8d3ae8402f9943ccc2d928c302726617ed80014742befd96ce54c1920ffe4324459e13f14806240cbf9aa72f01d7ae1779467fa30ae0b1aa5dcabc6dd8f4c8ddcee6924d351fcdf37956b3fae465720508601fb6bccdaa35002dc8dc6c8a06a18f658dd6bd437f7d0d5ae3242003e03ef361efda383f1936a05ed945d3bb047e3231ef6bfefcff1bdd4b2255b5a038bf63688b07378b672c6ab2790f4cfb81f43a4a060afbd0ac38fc8c35e3556e54fb70bedbe0d7f6bde672c2c2de838692c7e9bd73c3b620037a64014e7c58f1c9c498b00ac1c23185d405c8906613615b7c1eda1a01931b937b68b25784fdb43eca6d732f9740e807463e39adec780a9cd48dbdc681d2c36dfbacedcef02ab5479b62d3209864bde57c04fb72f30f6cafdce5508c167a82a31c89e80624a6eb2e3c3b3e8d7c1061969f5669da591dae6c3e307541d247c2c168b7b9579e7c3ffd26af9c71ed8fd00d07500de3de348c0894d43f10326a5a140dbaccc83f0fbd56f544e683dd61c83b05cd17599e813307fc9f8f2727372772df0b1a7a70d789ae8d950c31bb7337100642e7c0209a03362be1f4d79a9f4dac88ea9acbb4774dfb063b2b2f373b8ca1e13215ffce467629b45a32b883b640db38d351f9126f5ecf7675bbf2078bd4ad970233805b80c5fa0607cdb706fd02dbcddd66aa774b58627831cd93f614c926d59cb706fec06df394c5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
