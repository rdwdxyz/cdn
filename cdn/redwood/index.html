<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a1273b9802445929200ce137057aa73fb3e9dfc21906db0c040a6f6003c67520421db7028a59005d6bd0250ca9173201acddb7e18e0a74e00893f3fd5b7555472c4b2a76a9d0ad2d8042fcebedf2e024e6ee6ca8d991817979301877c133ae4fb3b5e7de8a6acc5794349dd4979512856c5354141eacdc0ba6e1db85d76548430db11170ebc2296368cdbaf72414b266d0ba5e9c6d34c67b226a4f3c561eaf502b5a160905de03208a3c4baa44dcaee2df9a7558b83bd527dfd3b7f75ff315d672660501b0568c065e1d9e6230ae5626138e5143111341d7c865ede9d3fc0f69ed63777c90bed04b320f6fcc4441f06b8d1f8b42f690c88c5b38fde7d6aed846990adde0be877700325cede3366820d0db727d34cf2525a6fd0d4ebc8edf7428152e9b9ed5f5e929f64d9945b514550d904c39e9749ee2cf1d89084d73eacf93edf69f35a37095acb7eb0978e841513c1b617c012c4294f6f545abd4a2d4b75a937115898465902ccb2371d1e1d3be3683dad8e820d0f15c14c27ab89d5613daace74a126ca4106e577aab13d49d6adfd7462b1cda6dc735ee21512b09948cd18426842802097aaadc5d30050802bb65a619d80160f70d60e5fbc0a803a6e0b52d5b57797e296703e374b2d8112bb340fa42b0b1e5f8eef5856f13bf00bced98f98356ccab7c2536ad06491890ec019710c4dd6e5cdb924ce75c9ab897088f3b32e0ed6c2381fedf68b842b49b8ed55e47ca2b8f1d2718bc15dbe802a22f9841b579efeea4b70d650f569d06b4a52c348cb27e836e59cb372ecee17d759ae5b3607efd9068957ca975a12973e6fcee5b7ead35c81633ce72e96f8db672abb98585a3eff1a0df9dd2f3165b25895642fd63195b94490e1a8f75728c911aece2559bffd1607de65f4e12cacf80b94f5ba98ed39fe3b7d173568f5673d2b78f527e7b392e86919f86889907af8b3c224fd5b3b6e5f1c722a84330f711da3b548bdb14dc8720c66f7c2a77de4e20918ae0747b15ed7e94145468660f36144f11977df4299659733d6024dc13bb8ce5bfa3e271b6f64e9f6e2453b5a89a1393286574737c5e79aeb52f0d0d73719e494bd6c2c4a8ca5b9a1ea2316a3be61cc2d66bb75693643f0b2ed558b051c6c3b8f5da4f84dac0ee6af2778c0e6f37971f41b839a1cb57ba0861abe6421a32ef4f20d7db80b46d4e84208cfca7059f5f71be166331818a85d016faac9774c00f7a0ce3c290aae80facb61380325492581f6fc641ce7f523d66946d4c1777dcdb2c0c5eff3d64c171e2e2a09e4bce6c2eeae29497e3e37e2788643f80a7f6dbb4193b18574f0d39210fdee64476e9e89b3294e30fa0b9dd75bc4976a5258a344dac8c8de1032bf53cd4c158f2116341f5f23c1771cdc45098a743881d5edc11b79fd71d266b96cb12c744ef8c6fd770655a93f2ac4e6ae98ba168d2111fe5c6dda18145e8bff5533883581c64f1703b965ee1f76740f854e4435c5fb52922b8ffb7eba221fdf09ed8bf988b77d7ae386594c6f6d4a0be7bd33e1798573bfdbb2a0ff69fb10044e6a179c9f034524429c467bc34f52ef2e2f0a3a7d60102214183a3dc76a0bd122abaab8b35511668e85d91bbe22e83e58ac812084c07620a3c2aaadf7fdaf3fb093f7a7aa26c133933ba7da012f7214e1d868a8f4274c9ca713e78f0dfbae0385015bc2755a8035382c1d7426c59e95a5f9b7d39a886dc5cbd36f31705e104b16531c74873b7fd7c622261503565f8ce28a0e968e1a1f207405f2eb23f2c9b8bf7ba08aa52a744aa274c3967c46fdc2fe3dc84243881dbb8ce5ae7009a4216951a592c78979e129a28036abb35a73795220ad83755f03ac500d01f8c5cb5c9800dce5f57a96673f45504958a17b732d28275290896292112a4446ece30ec0107fb4eaaeeada5fa7a21d1bee089cd1e6848273d7b816b574f3cada9065a6ac0ee24d62a7bedd4ca7b5712340d2ea0dc890025a136f54ac5797f66a2cdcc20c523d916ba45d4b920f34312260b867f07e8561e1412f50d79749105664f618dd50f97a8efd81c555e1ae93f96bbf0b2b76f25ca4b96281ac607a270dd6098a681248b8b82eb80efa0a203431752d28970aa171ff19b9d86a9a5b605c66092f43caff7995788bdfe73f330a613657cffd967e5a40fa2caa127a4587d4c889ab349d09ba247bb6626d44aae12ef8880174454890a13fb468248373f76e656451ebf783b90740050b1866f7e164e6601bda3cdbae595aa814014e88a6703daa3f89509d2ecf49c2b724cd8570ff92841eedd7bba61b85de4d7b6cc0e1e294984aef2a8f2486c6eca4501e0d952a5a44cc769b4e92e5163f9557591255148c994c97c4e054482f650203ef8322067d037be781960614d5273f49a4c17d70ce8e68f60393934027cfbf56a1452aa714625b73d8802f94e48342d7677e8a39ad70e08e2a5eeffaad1fc43e1c35ccdbdc2725af35011874bee71adc21178ab7397a904f89f1fdcb45b5c05324242b014ccac236410725621292b51b1342a17b52a375c2cc25ae2e33162f1c9b7d34b5d2340a43c91cfa90b592171748aa1f42f0c3677ac4f0214ad47e13170fb3d8ac3ab629084a92f6d61f0e6d569f647813b9e4c46ff43e4f3c5d6d58b0d45313f7add2d91bc75b82e875d7da5055a54c152d0900efd38daeddf275e3902a178a61402a488fc1d9da34522579a5111a1c0603c6fa8ddc264975457ff1d02295a206106133a65133a2c29b8e74ac75d99be3b16396a51632db6f474ce88997222cd5661d3219b476c277460741399642ec5e13801e6f578bc17da5c37628a5bd2a6784936d2738776d5f8ff31a0028c258e6cedc9e34931aa9a3aac873789dbdcc96cc6e97a6c4a80839ed852c706a0f18ebfc433d1dbf35cb93ab3423c9e0d843ebc1ff9ab19ef2241545f70622b3d2386270e915df3ce24f61c21a654c4aa66933869f2e9b24419a5f9eaa35f4524bbbd95fe6204a933193191ca157793a222ee30e869c23f2675e4f9fd5ba0d41a57bd6faf7ecfca208cb82696c0e6031fc93e165ffaaf1d8aa4f1f632526202e90748edd892a90e897e29d7d8452e339c24506e701ca2b71c82e3fe8985d2661ccafbd8a9d2eb1ec13dd2157ee2a549e2f3fb07226d48d4a892be21da890b22a684fc757be013f2146eac169f0e9feaed211fab7d92e5fd7d46016a69e9376a7fe69822db95d46e7adb61014b349fde091212f235eac3ef11a55c6aab4c47eed16309e8c357a6ee40eba6d27a1eef55fd2aa0242b191cc8428ab45726eb7dfcaa070c9b7e1671067a622cf446992a2438555260e03655caa35c5478979c41e98b6c5eb55baea77043b5f4530a57dd463d6e265d0e374349adb5391f56ff1972329fc371c22759c4c3a54bc6f152b3e606f3f0aa588e0c5b31038873e2f4ad6e80d4dfe8247ef4ab31b93a100ee408a994014bbd5b5f8c1d8eb4f6957ca54f4edf7be2d92fdeb491a51a09f4a38dcb2f6b3fa378e46ea84d1025a9ade6bf63107d66abdff0165c72e6fa3c2039e9663977c74a8fa1cfde989bc20469473c59d7a263ed50abb72b012fe679bf51215a3f3663a00f412134841b4a7410c58b12e7d76b4a60e72a66c0f166785dc986f36af82f8c3d64296bf378e34ef63aa28abb649588bd76cc8ab3d98272611fdc21a032ba5656d25bc5a36a16bcbd844e0f722454d7336a7e7e6ba6c9e0c562f999e5bec69da2b831eef9646d18740bda5b9a3e2ccef5010d942970ec727d31d671bdcb0f4912829f444c5929c66d5b1358a1fd921581f3d3aefea3895e3e26d13f12d4b718c75fac828763f6ecf4f9e9358ab2485ab3415c84dde68323aca7ab85fbe11892ec97a6c8a8a58801034a5a6acb9c76204c4690c70ad377c41d4618c1644356891fa33657403afe04498ea997f9eb69d4525e2a4748d2e2a24db78b38d3e998ad903efa310c505e48ff96a5ce67dee83e07a84dea8e4281753491d7e5f250636fb06f3c58a53bb5e438e98b6621ccf67d2f99477486c90ef17e09c73a0bf51c79ac9f5048f558980f20cf5c75a0cef755e4223e42065db25122cd612c38658f50aa13c21868de355126f9fd7630a3417c18dab50a5aa1fb1c16598058e8245eac365fcbabadb95ac97e10c515e495a247f500fa2c61640bdce34793e27b646a20e2cd35eea148add758044e27446000d850803059c3bbbc02b9afcaf4a062a72a26a05df08ea2392b24469353d3c20864c237cdef887dd13ec8bed47de41b6d8ba2c16d480577b96c44fc817e6f8d0dcfa386e15958523b2ac099eddab40d44e5ba85165e030984bf008c6818944e1b933f7335e8a709f63e0ed2ec5c0f0f91e6c34d8b8120507c339c5df9799e7e4688210e6c30ff037982951928206ad95f0deacb80e1567e6c00f449b6c15c5b5acf8943020f2179f0528958e91b86739ef9b4d7d292e65dbbcc3833c88ee0f465d5700521113ec6594500a845b1f902566b5b5d85e7cb8a7fba5ba75866e6175d686adac057556eeaa3b6dd98e4ea6dc0321e0ee7c6b6235af188d50046f36b3f0c32339521e86722c0f36fe83a43ff2c65c288ef2d6f40112cdd26a779424c441846412aa07ec535c5efa63baf2885ad6ca5c6840632f65fa3a428d0d86e468459093dbc68435af523275081e4a1b2bc5d47bb2efd61fd05c5be64fc72b65f883203b83edb82895683a18ac33976f99c0fa56b89c0a665a38eece73e5807e9bf9dfdd89d9f086ca7a1a6cc41a6c52b1bd21d58ddfa121fa114a3ee35480b73174b0c1d32a6d1976524c6f817e1c250237c58f98b406b20005e0a21a554cf22b6c095bc0cb1dcdbd585845b3329ad79b9be3bff746612a3e805872fffec2d8190ac0699a2573e99ffebb7f7ebd1b9b090cce2d5fea6db5bd353c4b006b1931f32ffd860ed58b71d4e51a8084276d44e68b318447e5f334f8e8d83bc03aa62e3aa42849a5c4eee3b381798d4c95ff2742feabbaa9247058ae1e7d2ddb8d5a430f80635a86dce5eb5cf52af28b086a270cb201a012e139d25717d13563185cabac7d8ea3b742dcf644bf910ba836cb4e981a4e2aaadb70b30f3a217a71645712359fec12338e0114a83c1aa8da8b3f5674bba628e8f51a4f8f2941c5fc2ce42f28610a427c913c4cf32449d07cdf9e0c626820d061da5a2a60765817f53d629575e09d7a9662a2e06aee7b072965d58afdb621c3ed8afb939cb4ffe7f4d463fc7487dc8c05cdffc52060f14ece7d1463e4b03ed7ddedd6a1d819bfe9214254e9245fd9c06e3081ec903212b8a8e8611da7242afea3ba9fd366c9063b5c4c387196740dc83b95f4d2604329df2f5cd6357545631f9cb630d833978be62cb8389b04b33516869b6fc9a34ce0d2ec370542b8bfbd56c9e7391d0fa3229d3582c3013b739784045fa51c360f35d09bdc76f62b58876fbcd1fa52655213432b500a8d711c4e31aa27d9daebdb7b3dbb94a02eee9fdd65bc109cd341127f0bd180671c18e45dc1963c540ddf56b80be278a9b519ba0a1d546840a7406cd1f63842a52e098c86625ad247474f188b7e7e23c03c6cc890a5f1d3d626c2f1ef63ad6e731606afd319081a4ead52e7d54392b9eb46f2cf2b437fd4e061e2024039a7f222927c80e269bcb027c5bdf373033d742427fc14aa4b5eb12666ca5ced991746a7bd205d50b7e947af5bca7f1fa903c96c2a735105974e4ce8e4727310d6f6002ba336fc1ec45cb92a53d926c579ae26c699451af89b1c8232a0a80953b3da90bd2835da9de495a3aabeebe8e7ff587b2663ec725026b5130ad9e4406f2c5a79702c0aef7952b2cfd7e3f81be51518d846242a4a1f2345a4b36eec43973071f96fb49b9ea70b6f3ea93f0cf93417df48bf8a2a3b505a0d6aa4c7db01a0593c75a377ddc3eec9ee15dd35b773671db9ed81b68d6789f7ba22542c5d1cc4e374253e38e868925f5dee1eb39ce650dba1a94fa2e0c804b50137536e38b9df8a9e85c1ec2c78491403724054491880d4bc788d9ab0fb96ef278825dbd78fcee9aeeb8b99a3eabd007f3d1275e5b5434198507db2a9ba7043620db513f1996cadf91771dbc641e6f003e33ec77a45b1df0d8228e208bad10e2c83b0b357cd2d2447c255c2b9f25d5c85178004f9170193417c7e0b1a2b5c84801098e885e521c0ba5badde5775048e5d7821fcc2252bd705c3cd6da4acf859952f4827c06fba44673d0eb87c730c8414c51e45104ab6b6059572fab110737ffb211eb3cd5dfe4ec0722422b55d80ee1b3792d8fc79e195716f693dad4e28179aad78afe258bd566a98bff01349dd46b63960b492332c728d798ac18d2c0ed5067f712cfd281eb2b0cfdb2d9785e6f55a5574add6302085c257b9ee319e341f09bf094cbbb460615cccf3dc185ef334bb9ffdce323eab9170bfcd21da195e450e780629f7a78bd207dacbc56f95d03220977e5f98c0259988f9f89a7d986a082b32dc5d738f9cd6461ae4a8e893d5361a8d5eb9f2e7dce5881a553b6446719fde5d532421b1b1ec0d0a5846eccf6daf884d4c5c5bb8187a63117fa68d30b6927d649f97c15d58bce1a0495c0822fa4beddc7718433ea1586517ca5b61d82afaffbac7230e0b67749027b9914f78d6e240742647f5b6b85108b7004998fe5db8dc3c5d359f5f8fbed8f0178bba482e416820ccb2c8b481837c3cb2d06541e1901dfdeb00279e8090e3682824be1dc87e8efec7d0353bfcba18a5fce2a9bcc07f30cbbfd7255ccc556dff02d26ea58075f0320aee740933ce7dccf49aeb695dc9cbb55b4832f9de0354d7421c2eddcb511b7b01a8b2f630f0cc704218ebdfd813739d44ce73015c7987f7795d4def3a9c0a73e4c768ebabd1ddd2a9b128cf626a67dc5c3c46a9df00893d6239d1a3825c114548d1e5878c0a7ed5a6af7aa33c78a902933003e8c067babdd9b2d1a2027385126e7a0eaa4177e28a469a583ca2d208d703fa860d5f53b780b0b9439cced6fa4bcc8cc6bedfc8e5dab3d3060fe7870a2c4a88356c9c4f216f3495436133d0948cd2707536f9857b829ee332c2539dd2eb71552bea6b300b083c59b3f71b67ef4eff91e02a670b9e370563680738a922efde3892ea22ba40ac7f62ecad8bb446734581e606df089b52540bb1c43c8aa187c5661994ecdf860ef73349316e37285b1bda6fbee7b1f3f18604a55e512166b917a183545ef5471ca2dad0d36a01b84fbb873561ce0c3a73eb119fec35c1fc6cce2b20ad1f099d05c4b4c2e89a9fc2cb66ef2998f44624004908dbe08634845d62de3b54c89ab47ece96e41273a249cb61186cb81764f43b8bb9701092eebf762d0bd296bb0f38718375fa9e0f5aa83b4c25cc8a1a9c7dc15cc353feba8dbb512f0e9295e531ce50c0869f995d5603e33bb9bdfe8f6fdf278364924b8a171fdc5371f54649f4195dd762e599e0316366089cd28c527479683b5e0eab7090bdb2adbea0abe655f976bdbed3ae1ac48925ba067c0994cf8524fd91d457e04745dde2b29f4e340d010a5dfbf372461c262e26ff4cf557ba2a148c8dfee7916828b478533b746945a15916b0be8c01788f9058f24d8db4a8e08250dc4474449f51bd13bd51419cd8b5c8cad1b1e416d5492bb82cb36f866a12701f98da357bd9a2a2995d29dee6a4c281c0a6849448bae452566003fde86a451d8d1b512e066f41532615c484e549147d670afbb06b6f02e85e8a20371a0e4d24268b7e0ad393a3f7595ce594601567ee198f38ea95bbcfe9eb7f40f838f3048aebf94ad91d0650473c0130450b77bea332571c429b97db65284fc72c6543d087ba0ea8a198ee65da8a04a4bb0135af3a400ed2be1bf152483b7dafe35cc839fdeca72decebfa6cc02595a21b0847195e9e39d910511fe11b21c1152c3c79dd333d7e6504f2c0fc0cebeee65756dbb47a6e2f1d65a56709b66e5f86cafcde9858aa34149d2ffc0bf65b90690d0c676d64f704b35ec5c277f26c002c2bc09525f034d07a4c6cb5c5b7344ae71a97cd7841b2fe73a4fb8a9c86594eb393ee5ace5c857c872d1fa156a3e8e0e108fe303073dbcfcc7056aacf2eec43d290d4f897369f85d2fe829782a33d66c3c167cab9b31a02611c5bfc9cdddb5e72dbc42b1d6c55841521af619037e682127d1090c48c3b1b16f6ee3455d29e261078c6b7392721a681bb1b7a6dc3e27f4877991c1133b688b39a196a751f6584d77f60b0181b374df9bc0f2f8e72a36cec98ad92d8bed58e867f4e3d3f928568b299c9037699c16f88fa2e910dc9f14e39a216cccf0ccb9e33f95684eca5ee149c68b576757b00b960baa68e3a70a617b526561cea428670e56d9bfe587031448b2c2d475613bc0fda2086dcf9b805b77ee33c20406e98a6b2de5e1f29c999a5df32ee3e85f90fb00df62af03a59dbcdf08290841da182fe5bbfcb9d64f49e2ef4ae40283b88ae841328c5269595cc3f8f6574ce02384815f894fabd2ab03341bcb4c45d30afa84dcc1e2a9e6c5adf878232a394aa2651b7685190d114ea1f55c33849d1d2f6f32e10cf7a6a84e81c5347ca448fd7c741632a6b04cd8b0a9fc8aec28ee7d2cc6c60d2a375494e4a677b5375034dfec1fc34896519224d2aceac23af5c9b1d83ecb3e3d0aee070698e32bc8d51cff0c96fa4f5a930f7a671db570609601f2365ee622a5104b649025a4c6eb8b112a469a421d62bf6d6c0c2a15930881155d3614acd1423454e2a47b059f098ddb5d1504bbbc3c4f68ce1da4f184bea53024fa12152d1da1f50734a4ce3c98ca96808b1297eceb8df502e22d0e9edfa8a50ca35cc1a20d90db7fe8655714371a414e4b3f85f0a6a92d4043856d0bd3885636997a4630087241216e3cb4242efe0298c1b6b219f1f8a44226d9b590f3d5ffa7136fa63d0315886249e747c1549ec8885b2437a61a51ee234e8c3ef824d99aba90707c32cb03fa0609926225e39cb25bac0f0c964333de0393043782564b874ba0594b7f0084964650d29c0484377754d2123fd3fa0329e44d5cd0f9e9a42b1f95110c17a7683a0eb2f35be4b8b025c5a725de0bb9daf5b6ade4a6286f24594d6570d7c10ba1932d088bf1c652079f847654be1ed0420b9a5c401ba5bd574cabd8fd1bf9f8dd39bae9b8953a49f625f83034f4015a556e6b864480a3b3fc5751776a4831e830477dfb3dd11d8d6cf8042db93d0ea006e2da1249d13df55c7fcbe76f573013a69788303740a953151c388df8bcb415b463479babf7ad5bf549dd297923a5754abd50a29fd16d2fb8bdb292eaebf5890f388f3be5d0855735722a6a483955d957ac5e03294c16126b2b7aa62a18a3055055149fefcacd9ea245ac964c798613e6e82ef5cd63a393378a73f28cbacc059533a64dd9f38b2eadacb94b295db5e45cec61197b8b8969537eb61b6438662239cd071fa93a3ccbb33afad93f609ddf23c9819c5e3389cda81c28675be46d891146bf35b7a364df66ad98b297bb27649f5614947f63f155de7ada15499da248dbdd1afedaf9c5b1da71fc7f44420fa45b1b47aa11e5b67f4d1446ffaac2455e92d4377d7072bb14d2ccbd5d3743e785d52c2f285c3a0914f54bab8761751d80f427129e6f9dd17f7dc4f9485ecbf99944b12f03faef2138a06987e8c3bf26a8e5aab1ec772921d2f99289ca1d30ad2c6c972004cb140345cedbcd9470d0ba1a9b7d1e6599e91b65bbf86726255febc0ddb256b84ce1c14e8b9c04919ab6bd91f435a6be611df24ccd10b4e72ca9af46b97b74a03fb8f9db56f303ac7b0bfe8f54198308fc9b211aa16f10bd26f6fb71e3b14d14a14a4ed456b8dc0a8dd161ab3b715d38271d6126dbc76ba50c03a64a49e2ac4df0bf98090551e564d80e1dea3f333f73d1e4fac29505f0b8c387ceaf52b3301796c4016306c7a881b2cdfa256a67743a1e445d3301b57c215f44b9ba9cfa8f2b64d00bd8c1c7b03b09980096ecceb0269b58f61522a94080bcf91ccc90de4015fc4e181e30b66f22cc130bc62ef0411cc1d1e5ce3160132e603e029267b993f1e7c117ac9df2d5445a388b0e48986750987ac97d6a3528ac61294564473141485125aca46f84fa218cd7cadb5345f9ab1477f0b32f544813b75c5b3b26889698f9c2d64ec36640c01f2d1b96d13edf90f1d7e8b4a066ac1f7294d36cd49c05fc4f2a14ce603c8d2a24d3f963c75f60e5bd63898f5a04499171a41055f3d4c34279ef7e1e14cc8674c50e12688b1c22fecd052a9c2503bbc8871c042fc5d5bff0530e3a574349c8156d19bcbade41bff0de1a717a89b8e38e173d139bfa1c240bbd0cb033112297f24e282e767ec40ffd68f8e1862d40fa33c40bd31e9e4e5aee45101ee5f432b913bb2cdac5e0e3957cf1d26cb10794af3b8c3e0723e687b3bd57a8da7da2a5c4ffe1268718e2329952b28c50c2dd37fc313e38bc7b3ef9e38d1d4112ab82b65b95a8f7efc1cf40a8039572fd0d04b0cd8090f808930f197a5f01634eb1334742e65ce353e9586250ed5d51286a2be97bf2230e7183ea5f1bf92f1b7829b3cae5e20840fd237096e6dcfafd77a45f6030d258c98b466f112a2dffd62afab8e4518f8993333a62f19206d5a6eb73f56df64986d09f219791f24f72b3b67adf8724dadc9c504436a3dadcec224d0983a8116b67742fc1bf684f0895b1f68b8e80b283854745bf1b73ff02912df825c275ac33f629c69973b393ca8d691860cdf6194d9ac47534bfef9a635a576a603160afdf871fc2f5cb63c6cc12524f0c22515e9d1f58837413f677aba17b8c1473620d2bebfb60b895443d4c3fcf9846f1cdb0a00e52d1fbb2f32182fb98bf52d440ef3f108636e0faa5d6408b858537911c44ef16c62cb45ba3d060fbba79313c13bd1e2b31b49212f31127daae8163105467c06c43d2167a4742223ee8572e66d8b2b332bd74db7c2c34e979968e35627aa43f0f2d638c9e32796095270674003263e6ba829799dd67e997eed4ea72e02c31dcaa6b143040f5455de9e1660046a247bd65390e23f240653803778efa0336641b0fa4ff6c334f678486da38b3b9b0bc4d319f8deef9b2abcc1f14378da57346ccb6780b65cdd86a713a9e2eab2d42ac710ffb5993fc8a515f4989beef1f2f72694f65b378dad96f052b03d5669fb578974d8027a0088891cd50b48849e3a28bab925fd713e0c7c7a9a8b5b07f895f486729354996c5573e62ae01f59a874f003fc313d5593f42f079d955a0756f87116f81d93f91ae3261705965787ccd6d2b4ad505f1f1ef0bc6776e0831794eb747bf27180a097a270b89d1e6ee1fd32d987e758f74383e7c4d5bb95daafecac6b3f6b04b2601a480aaa053d7f541b854b8b97d83c1dd40674b18c8cf1fb05f94e9214a57c6c96e210aac8d10e2c04af844a364237551bdb98344d31d5f83a85393024c06ebf388f9af2fdce0f213ce3af0b3f3863d8807db01b4c0bf5dd9e55c79aee2c77c461d36f963a8177f7019ab78cf0603c0800a1fda88d43b0d6a35c7324c437d7633e4583475f4d1c422f6f28e381b4bcb8cd349957783f7a8782774783a54d57b525b0c78e5bb0d6943efa5bd3af2beb5b2aab5e9f3f3f2f1304602a9acdfb0851380289aae678ebe9c9168dabee88416378ad87256a34d6767ce315a11b1caf7e35f58d8df3c5923422d523befd7c0bd6fa2664bfbdd8abceedc0a7be472aec82f4732b76e7e0604840b4f92a94f69c898f1d3f048aabf9d8d6788c757339239a9bca748912a3f9088a9d0ff087525bbc59cfb09526bf123b987436168209885a3a44ac820341725835d540c5086c227f5922dfe8c8cbdd77321af74c6c44d64b6dad2ef1ebb12eb59138f1c53f043df9043d841538e37e7533fe2d406232d66af5f6f31329489297db97a065dc685c4943bbf1f5c3ad83ee7274b4d52f1a2b1c643709949c477a6046dd5d629615977f0e26a192f7ddc7390f5898e35d7a349ed9e7e0f8dc92b8fc2409560e2016fe76233a8383ed45305f02d7205f61c04ca9db42f8f661aa9761d3280c1b738369152eafc84cb8bce840adfd3076210827378c23f0c232c8d1ea11b21f32095bc4787de562debd9346da16ea9f8e1ec3d447bf7eedb62206afbda010472cddb7ce2fcfb6a7e210329b6f0e558126afac573c9460db0b257f887f5b829ae2bbd14ef433348eafec21d57983d9ed75b3e032203848f8f34763f99b93b493c6698d2ee3375292550ab241772aa7143228bf8dd2a8baa90f5bd9afee598c93c45b85483c812c85e0a16b294a6cab2d469311252e00c46d197b3c9fb42929d5f5a66ff1586c6a394eacd8a8d603704aeeefddae54c08864903c3a9f67924fc9e49c04f0b80182634a3b22fdbfe2559c7c80771f8db36defbba360834ebfae46f75aeb70a83b4f5e561bc9b9ef21db16c725394402f7d8ebdfdf0df9b861a4c836e7f3dd8b7e1513b1f5ee5f0132612b09a4f8b116ed314eaaadbc2e5325e9de6ba26eece6335042a77db18a83d25bfe6620cc695f6e610b531a13730c484f3c00ff248bce279c08ed744db75955f5e0e1213e8a1a20a63241fea6dcb6a0b29095608fa5199fd01f5685130b73aebf3d5a2eb62deab84c53834915f5a16f0b9fead51b2b4b74efae05dd5f184df13324f26da8e1d81e7033435900b9955b83a8e20a38ef64908d36290ac4abb3fe97a5d9cb9e52420d89c87e03bfe51b1e11749b084a4bf93caac0b01c939e4a51e2d9900a3c7899cbb4b7ac900a90729ef3700f311008fef3989841e521021222092582b7784f1f3c0079aec3b0da7531af96aada78adb50f8036a3c6d5be1bf840afa9170723f7f65504fd77d5ee378c3c6f19a9820a6b0511014abf4555cb2b8cb9105c9ecb6d712780cf25b27110c1c145ca10896baddef6c527e26bbe8b571f83da069816a6ffa8269be326ccdaad16e75fbeb2d4cf4e5c28aa2794ef7fc438d8fbd56ac1fc4ac4d58a18d009f8da8a64955fff7cff9f37a285948e37fed6c59ac90a38fc78ccaa7c37ad81ad00b1bc39995045e26eab0f615c4f31f25e82d42beeac9edbf889b4b4e940bca177bca00f47329d06e8551988665d31bec0277561745d381ed0d5c425b773c8825d01bc785e0b17550ad467b9d1a435125e383de05ec95c6b25558df518a74ee3e132606f34000aa8dcb570c1c545983027300cf3447f5026491e86f5681881c30fc53725ef9727649c691f4ee46e08314bf82caf12a10c9c4210329e9530b4fee9d031d72ecd4a742006f09466a25577b27a6fe6dfe86626e186aac40f9561fd0542aaa0bb43d24b84d8690d9a3289a2a955e2134e189f2ed8d474efc894de64c072048c064e381a75eddc808313386e216ae5dcebbb16ec1f60ce31b19d44ba47ca477f9fd8d8449c045b25c878c65b5485cc690ac4ef91bd8d55eca36c980ea28364dd56f6d3af94d7dd28c9c6b628dc5a72dceed2a1887a386b22c3ee15e7502e488fe803bddfbf7bcf81953afa83ac091cb011300db9a1422e60a092fea38ba7ae99c04629aa6a731184b58fb6ead855a0716cd1c6418942a8643276779eb4598330964c94021e7c4cbbcbb4ab3351f26919368dd46dda558b51a594debcb353afdeadb6715ac82c7699c9ee75a79ce95fbb4e2a23853edab6d60000d0d2262df76fee222371fedbe58e2eb1e4e1c15c6f7e3dd31756b478103fbe6b0c9524508040db9ba46e2e78895c801cf3be25e7df37b7cdfceb5e2ae2f3ea4ee4a89295217fd56dd2b3181fa3ad368281752382bfcd570c86747ab79a01345553c6670eb9ee7d6a467e9e863409ddeeeaae0c4bbf5d4f5c4cf22af177f80e725fdf36f05dfcd8314393ef2db4a9e9cfc7c55fa59fa190d8a9b7770e387a74a0b31806fdc4be638e03ee3c6d546b52414a59304ab3a6fa8ebaf0edc72c5a67acef72846f187e32722213246baf325239042f7e936b2afecded090adbe0abfe9f08b38a91253f6fa14974ed6092bf8c4baee009ebf55df4272db443389a6bb147c12ca2f2accfad3b0aa98b84bcdfbba696d9dfd49e27d2426c6a184f65d57fb4421826f04508ec3239bb9eaac00a1b6b26d8b94b6bc5afc54428088c13d5727a71f469e6f31fc3f1ea35163c1918ed4a8658963567e467f1d1a01d9e764bad37e4e1c990df1e94434a4896cf7cd05ea4175f03d4ddfc875dea3f3fda23c5432790d831006f81d517d24d1c4748169dee172aba5357860b4fc3b0f95ba85fc0d91b3d7b98448e08cf5b883174c189fe09a1c7b7c97d1fb3d06fd4e6a6b6aa19321433722320a625f3379b233bb01334cf0c32aaf97d23c5fcb3b4b163885fc47dbea32de80a8f6d130c5a9ad0c46b639b91e279b0378f356c5b72a5c3c66ece50309e51be5b225d1ea303299c41946fb58d09f68613fe9b22dfb11464189ffa9cc1f93272563ebdefdf75f0e81d83b4eb545cee58ff8d71e6717a0e9042996e828846ee112f24534303ff2c1eeedad3a37965d9743effdc61178d35f750083eae52a0f7330d431ec76086ed51af0dae3e0d791588056a09ac5c5b1286fb1c7e0e18b75adca96e163d84df0f4c802d9bb4a77549d0450e44e6838feb5ad513b607e635d42b986163df45616e67653e6d7d0a0d224f36e607458a4a0e3fac3c18588873c84f673435838e6587eae015e1090bb3811aa1789fa811af1754c66428b6d26cc9e238da2af3e495936dd14224236f11dedbf16329fee93ed10f8e4f3eb81c31b9b376597372d032ffed0a3806aa92ad8825186c25c219586d3c6d2863cd1a26a903fd4ae45a4e029dab0d4a45f5cc177831a8cdf6d5af7f1c92330d893f37dd28e8a31fcda0d484527a0e947022a23e9e375a8da225d6157f3f9b5474aa73fc8d496ac52b4ce1de10b2938aecce8a29a086ea63874491049c5ed1b170f42b698a22e7c8bb1e637491f66ff8b2d9e78586f26c45f2328e54b88609ca27e69b7399e1e564380882c865a307161de87d7f33533041585811731013903b54b93b7daca9f5d52964de9dac8bbe58724843eca926db83e22da0f38a5aae743bbed82db4a43ce49e808a7e07450b1aa033b96dccd447642dcdbf46b2291438c4ccf750b16972c68c27a560eb361545e583a442b807333ba04eb9b9ea55440d2b7b6721044d19922522393dfbf649ca1017ebd1b859900d151a7a4ea411a4a2e878a8579bfff381b82ff0a0c6fad3b0a334f1c6286ae04826de1fcb5b9ccba8d391def346c39b3f81c5ebe1e6db7aa5d6720683af805b227483f031a91ade62256e41a4a615170b6b26b058b663d79e7116014ece3e6251b56e5977e541f39dca525a010a9b4e5abf72f8ab364c486c20b8d5a5658b4805e75325b46146153bb8ed1cedbc40e9146c78b5460b377a0caeac694bc8acae287595b75d9e06c21bdc033e8ec7cc2b504d5528f79cd5dc0755a8debe70cd620324e7683e6603e6b0b3ccfe6a32b602d38a59ba012d600b3cd82b39be659a8ba673e111b2bf23fd3779291428f93b7c9eaf6c245079bae820aa8501b7071cdb9aaca47621ed19534e2adf5a7b0ebf7ab2148a660eff7d8bec0e8f65b7cf7600e827ca5e823acdcc43c7db3388a68df33b63c63caa53de022ba78051838580736899bbec6495023fd6b61f8162ca99553193f8b96d9ec034ccd1cc22677a557a38bfe4514484a2ee966e8d98a3b030fa90501fe3b54785dcd1f0ff0e0d900fb5905fc9c4a454fdeacc29c979d2587290cc23b8e8e6a550dadb5dc3205ea969eda6ed0777b545ff435e47f504e61d638bf7875f443cc2b5677364440a3c3bd1b6d9b14620b160ad3cf69bb3611eee3463107d799148d75d6ef82ff0f7319d93e8f95a2552688a3ddf17ce45680271241553b3562a503fc6a2ea67935a2ac1394d0dd58d8a4159c9a6978cd886fa9764eb07a7c6d233cef9fec8dbcfac8e70f828b12e33e8a950c3c57c264603283531338d6ff32559552c7222c639d1d1c21d33e76be23e25323f1bb53fda7c6a10c97f01717464fe0da3dc62baae1756263c51f785d0c8c6bf04e861cf56cbb6587013941a92a8e02e859abf3b36c03ea5928d584ab86145fac509ba4114f2678f84fb60771590273e89072d8323246f8e768f457df81f65d4cc6b7bdc9d9d0c6ebc037534333d26d29d6796b6fdf72b5f537312e7f9f0ccdbd58393e894762a4109ee2e7d825bd46aa62370e39da80f234f9349c0c65a9dfff367b8b8de03f4271afe04f4169262080c76e6e4c03196d8ec2334467999d0c7855f8c2d9f9901583f448e2099aece3490641fed80cfae1bd7b3e370c99c4081b56e50817f61dbd2190eee129cdb3b835a1fae86d59f19bf4be0a3a83a51000bac8a7568e76f3582d6d98307083f3a06e2b3736289709312cb655503ebecc0034c613319bf94409b53399315c2ecc7dd478eb5950bde9be4fcedf9b6a2a4b2990b4a8ac5833fba89eae22b3c10ac7098abb53f2be74f6b4e87388d578dc0a44aa0ca18f93908961d1384d1885d684b579a5d62c269b500c2fa46f88857461637f74638c29b10994cef081ceb3f49c16a6f1486205d307d82bc2837c45cae6b9e71ef49f60ab010fbb95fc41f0a638a4e4fb43d57a54da9ab660c53daf6ad1f56f19dcbc05990f25f97fe32e140ba60fa4092010c282389804b9b4ae4fbb2d2e98d24e4ad46ee6bf3b7fe344df4a93117c85832e738fd2b795b411fb0cc675b088625859207249997acfe81ec2e979c105c8d3568c42007ec2861e799c74a0cb2f44bb2c0d418a0762fc502efe48487e5d7ebc3c90e55ceb80ab3750dae4a2b38f7a16e5c93cb38c7de3f09b4c5249664daba17eaf09b5d91b6e5c1e829e051c9e64b3cb6cd35a3cb79df6ebdc1bee69193890905421feb7a7f567b1e4740e37bf53354b60425b2140ea426302c985d9d9185ed3a2a5cb6939f434e67b89503d5da7844bf907035285c132548ff3ebeabfd46f69188f9b7d13a534b83af6329411c15592de5d2f9c35e07b42bf79054eb92ca754f644eda8a6fc4b008163c35d8b16a5ca437d4cf9be452b69ceda247b5b5d68da9d3423aedc2b71512f297bb59b39e1890d048a52aa9ac8c6a419773f3c2d4b5b2ddfdefbd1016ca5f41f49371ebd859fcb70d1852cde0451db51393118d59b0aa88a3e90f9a32156975cef4a82a7d9f5351b21068a0f2246148c436bfbfc3089b7f624cac15c70af840844c604bf344471f0ea132a7dc3b9ebddbbfaef85b7dc414129a530043fce3d8e3c920f3eeebada1b99386cf4a813377e7259804e7fe4b4d7cd75fe9c376cc77207faa167ec85fe19bcef25c8a0ee1b5c083c3864c2cc3158b3c9fe5355278333d905246c4659d1528520828e68f13c35f177a86bffddaa5fb44246a40c56564aeda05bf7c8590425a5832dcc48f77c36ee556ede925177e21b4e9689be1b645e7c455261bce4d85b09f273c48d4eba7ca97cfc54b8e83eca3a2de278c240aac2db166dea200fe18e379a9a5356d8bf3969a84c3bf2ff19e79c95d77f3c620666e2c5a3fef640d088c00ee57e903a62883dd4e3b233eaee0ea622eab2074e4d4b2c7a0fc67f40a1db9f2cbe479f856e0d8f836219e6de05c0eee646889e5d386d7a9fc5c2c97a05f4630a23a1538e4b40b3bc9c70b2dfdc0da345bd9163edc1beab120a0b1be4039eeddb216a220ffe8877458e42f81db86540f59a1e870e152bd454ba57eb07bf211ba9d2d149d8e1abd51cd99f70a7c3e0a28dcb0fdbfb80b53491f0338884816f251be439a3b7c2dcb79d0a0dcccec2a2ef96563442147985c2ef4cea7ab7f46d1513cb507437402181261b65c57ce38b1063a3691cc1b2d19773270f9d60e6d9fa0ad4aeab8cfa7500746649d4b8bac21a9abe3e9cffb33962493d69b16bfe5057911acaa32f3ac9c6bf1a50cddfd159880e37ae3c137d6f47d9f7fe41735d0e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
