<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a93ce69c0430e8eb55bec72f6d2f91da4379fa675eb7604bf93a3b39aa914f1efbf8bde14525a56c2def7294ed6534d1f6764d28c2e2c6d2056e86d95cf6ceb3a034c6a9974400599aa8752ed1baf19a9bfb1593f3ef6a6a35611745ee9cc68ad038326f252ecf27eee8d6dfd88662b512d65b060d5f9f754baa201af85015091631f13af4216ca4d4b52d552ed5db959dcc7c566e54bd2a37a4ec9b074b7bc3b4dde98e33f306caefff205ce6fa7cda3219d43a9fbe7378709d8fc076f2d4e96f13a6f4cfb3ee7b3afcb23585f3824f45f761d133aba2af5d03613d2423df0fa60febed2f783469ddf14ec315a029c85f6d90fce0dde6f18cb0663d121e140c856a1010b2a3d0f40e0eea58b8341344405a334e80c2f9b54f1071e39d43ad8000a657a0f39672b26069be02ea2ee701310c9ef26d0de3258eaa3c4946c0e8bc54e84a7c0fdb1c1355021e611a2c90acdd6ac769ee78215c2e52bebf5b400f680f8aef2f437fcd95002241df4e6086ee6ddf3bd1a868a30e79357c3f8c724ebdf1fdd3fc701645bb0b0c20ce89eb4842ed14dbd898396b0617f438e92ca12198af780e5bd4cbf68b8fa56e46c0504c0bca81ce5245a8ab9fa67c3a9cefa7bf560991e928c7a50dc30b8e248d01fd4bc543490d7808d27266ad6794b6d32b61532d601db2351771346988889a58a6b29160c4978db202480851ddb32be9589b70ec412b833056c017e30e8e799d513afd22f18263149a84cf237c38c6275b37a5b44285cad61644d32274ff4b1cde858ed06e8eb817e2cb01d1fd0a4ac7b458c32ab5650deb59dcc9f08d0d230f6b182779c476f7371ab14513c6f687cacb96145715c5594859bb4179fce4e39a799db7e2a20bc6831ca48390622cb9b7b92cab422d45fe4125e02c3935098361698a1a722365c2be0a6496aa8ccc2a7a1c6950b13935f4d6360b414375eb1a123d3bcde6987998690c3cf144efdb5211da91312d5e14e2246d1e5f90b385508f1b072b9900541dba0c5b93aad97d873a484d9b9c43c09d5b588c7ddbdf0918e28444bde43e87466e7408a04ddea869ae3ac516a3e4969caff6792b3c858a66ad8963bf16e3a2389f0e567ea8f542ace3657f29c4d3ad9d66e91219d815e49bf93cb02fab3d2b76cafe2aabbb82e21c34b740954d7866918dd9dca9843305401671432ef4d11479778ff3b448dbdf37ec1f6c8e5b9e9a7de540562636bde195ea245f86c4dd2193fb25e090546617b8c121f6a7f89b64403c5389a2b63e25bf9741f414af52d4c6d119a3e24cda0034ed5a7ea8a2ec231dd3f7c52390f5387a017c94976e57769b2871c7f1b7b8c2cbcb6edbae581e9002948defee97978ab7545a611062cd09683decbda5cd9884464d2b9ac7b095fc41b725b943a06e36fc5732768036940f8841159750f1d7ccd8f70554e7b8339e9171a8a01b7724878ab4f07e4eabf1e243a8b8b802b4299a27555845eb77f4b731cad65eccad1aad4ac2cd6aaf00e93d03f411d655a2f1444caacb19107ea56bdd7f41d725ff095328fd75862aefc494c85441cd04fd92e87757434d7cf259b2328fad06bfe7276b3e5c8f7d0cfee8e77b8e89267d329a0852cefa572fdfaebe9836e4200514cd01f3cc34b9fb045b2f0a82bd233168f5a63ba7b23c0a96244a169d3ceb0da4b475024d2da5b75386c6bd0bd421c808cc05c50fb34812aa04c58b27bfde63bd30f38971e63f30c3d1351b9b90463f652f3ec7498f2829e8068ddcec10bc24ee829fa6ccf3f90c2a3c89263e3018aab4f9dc87ccfde298c6a891faff404c661cc3bd698068b2dcf9da14fb8a23d12e0d14519bfa904b597979ce05c173a89c5218789d9102de43d9cced5bec77b85436893a7f5679b8c89c7cc3847f9fdad66f0d3a90871c690aa0a909b4dac131b3e060f248031cb586449914c6bdd2effcc35b9d51c8eda365fc5682a1c9b2c0e2183285386d127b63ff34083defbd7b65420cf9bc54d45b2dbbb2036bf655e656fe1613af365861e0b143f7d4f17ef5fc5bf253ba7adbf5e52180db3a0611f9531e07d93b224a76ce91fe6f3c2e89721610ac0b844e2fb966b8707954e9eb26f442a4e64a04f4c29ab887a1d0bcea091f96406e2b7d1f3e6059623270c1e289a6ddc68c1e07c178b839fb2668068642ccf7bbfd601f2e07599f25ae2b88f6c508161308058e46a5ee56c2936028d6a2baeb9de6a18fc05c522d6c59eb916388a0c4373baf61eea32a4e664416c7ddfd5fd17ad7be5844308395aba378ee2664cb24da2c424b5d4d66dafc99f5464856fd743f242ef6a3b098cd9dffa1ae09989d45b89fefd6ca82892a4b889f6f43bbdaee58d0acb131d0c478a8f314b4a36fb25e8e3254b6e3a951206b33b09f5f924ee357253def48b940531ec898b7eff54968bf1c3e94f6091ed3f160bf45385e214c0c14c2207e56ff76cba1ba096485112bd0c4d2885a1c1cec24647aa1d427205675a2adf8940cbf46dddb049d3cfc22b1a85deb84310709ae8bb8a70118e8bc2f0129bb1c20b46d3a72d8ac26dc0abdb0f4424eea9925105233c0e6d81135322b5d17893925c4016fa383ae55b417705155c91b6bfb462ab1f5a6f4c589d27a9a108f0e0fd103705ace7f819ffe24b82d2ad9383bda1cba9a907734a945afd2ce960d96be1b51c73a5a1d7864412454ba0e8a5ae72751decca073c5753a850f0be9840ede2b5f9d00abe96826e737d3565d66baeafab6ec575b2769c1b652ca7402cf5e486da12d02c1a0cbe0400af58cfedb1e94752d8414aa237f57f6e4ec2b58f371cd91daf3cfde23bba620108e2a0976d19693817e7f59c40655c1f02791a2e74ff018a20b68db6bb13793ce8fb6f1da8a6abbc24d98295339f99acbfbf7b09b2aa3d0934aaabdad352fee05c1d941543ab5b780e157a15a719fda1f26fdd48c0a004af60d29fdfecd1b2db21f6bde8898e5a1936504ecf4bc10a7705be944050405cba8b704eb4d6da0a36c33653789d6699b77038b531ac7e674e504f8aee5d7cc6ffccb6a53fa6f4e6b81bbb6f61d11c4bf7cf5b6c1fb3110faf7b5836d56df0dc805fcd02ee3af3ac65e27cc25a4785fa93eab1921eeba46dc9713dbd5971c8f7b7d90da3a1a1e6a397f06815c5b48464da6a26bb67b862153d27df67403e4e01d50b1006347ebd44fe9695c491a2de04f9990828308a6b3c35d56bd22fd77ed34251096d49f2626a4cbc1380aa06d33752c6612cb27a64e0c3e61829b4dcd0dc69da4a519354239564c13efd406fec5e1cc20651ecc106d6719ad07f4166d5e205b7d9557678b4f94723443efa62eda680be0f8ba42575c34ae907064fd0ef98fc91b62a660238a380b9c86a7eeec820d4cc22f3806325d3849a7f88c1ff07d408304942010d61b243621bfe972f49daecd3b9ff0831096a05181ae9340ac656a62fcadc64f41aa5254207a8ef2f3c1d8c4fe86ed67e5b557360968ea80a531d514cc79c5cabc2c35205e700ecfbe5f76be6c6106e4f02436b4a5bf4c382fd335fbd745627ef797f0f21f89e3206e4207509cad2070c47c99a4cf5e8194e7cd2af724d29ddcb84223206f7302d201d97f420015a5759d80c21349b790503fcbb9acd24df336291b7f3842c138a0f1311758dd3425739d75bdd6acbf59a7f29c0540f62bfefe6d32fb0a11e4239c1fd8b51999a6aecee2c327f82cd720875a23d5118c1391b7eddd6538eaf970571ab1b44dfd3d723e2e8e9e3c961015e28823905b0a15bed5f100a95fbd14e8ae9383d1a6ed406c6d3e372e592baed3e811d3289c57869e36177f50c8d322f2293891771c9a6b14aa63ed97dfbf120b1ab07dce20e9e84e54853261733d0202a25ccdc193e195a59f5c74fc6286403ff1b6bbfd062706e090ff32b404076a0f19dcb61a2a540d122d755116650bd50fc8e09d54be5da198a34ce77533ee83e549b4f383de52d76980c2e95e369387816aa69815683df7484d1bb438fde068b3203a5bdd82c7b2f84ca8cefcf2f7a15e7a1ceeabdf942fb07e308232e68850c680545331d54a17493332e1c4e2b964c150dc8a1a81baf9ffdcbe7936e2dd307fd975112f5ef6688b6b93fea212ca2228d0159feb20f9e0652956848760ee6ecb306f22b6f0611d3faa69b2e65a95ff54295d4247c9a7e500b7b74948018bc5c07fde04490dd831078b646dbc79b97b041cad271810bdfe9d03457bc2b9bfd723bcd6291ffda9d10975b7db4ee19696161e53ad86b8d645453da13dc9840e811c75e60109f69fab0487c356de3ba224977075c3a83755d7999218d12095d856bf9b2e8da1bb2347fa02684d2098759b3c0f3c4e33acdaa3b0f602b113c7590208c977de99689dafd3761bf81ea177cb92118a2a88d16bcecb14fbcf8fcca35b2bfd1c2a0417724401a02e3691e62595b6f1897e5b58047fd4c4a9e63b52bd4ab2848b528f9c2b77087475f04dd2cb3f86ce5685d7193cb68050aa1bfed7755edb1be8e82eb9243b9b6be0a98ce263761a01a64c4e966941784625dc624155217abc42f61d552885c5d7bab0f9a80d1d43484af56df3c04500b65556707987c804f75c048f5b5806190a6a630624f03e604a3d41c39d1ec96d1351890a7b3e83caaa01dc3d8e1b14a346aa28bfa43066de044a3fdbb33ab0f8c9a7bb574cbaf3886123f020e8555cae388f6a108b3223d86097bce8c4882cf6d6205b6f6cc2e2d828bf8cecc06861e30c53b5d0a4491e4b4051ae3fef9fd51c0287c19b86a81a98b623df3060daa73825aa71f5abef0cc584db3855c1f2352d43d55fdf87244e8faeb314fb6cb9b5cb50e6b75ca2a83b7dbb505533902845ba09e436b9583fe1429a6b3b97513b94cf4b5d9dfae19130c26d40d22922ca6403be330b40e17679891ac7a0a2f0d0ff8b6aefa46c83255a3bfa1d8fae9ccd361bd2e16bb157a9a53b84f57f7082326354aaad18da8e705dbbc747c474e9c392f4e528f364535c6944dfb6afbd51eaf73f6bae749de23e4b969100fa73af0cfc3a38f2dc6447a92bcd0f4ed12a72aec8f57e19ed2d57165c82ba98d2ce13c1bbd1a17303282ac69bfeeb8bc3b59dae3607a1ec3e3224fdd709fedf03b79a36ea3f8b942c24f586f681e3bd0998f43c4367c3e01bb2029868efca6febff6905e9f63c116b2352c0bccd66a840be341fad5b939d25b9b63d371504438e4a041426cc9fab26054fff1ce3d3d892249869db3938c049862fc30d11c60262d3fa3a4c1d102b63e382365edabd131f6a9f22851e1f4f6c7dcab0df6f8082dd8ab4357d621bf794826cca91dd89f296b9c4022eaaaee88001a6173790ca08aa7cb6aee3059e422d0362e5f0750db0a0df334bcd33ae3825d6becf112e8d2a257d584a56c8ef9aa6434ee96c7151357368ef560e7476ce4c22c327013add74f274a638d47f0f47cbd2dbff03084af7b4f267030910d8dff2ba2f5168e590b0bc7345e8f7e6bd943af07dcc74bfeed1209c350597ca0b921f6869f0dc3d844cc72d7ff3849d5c6b68b250c7b1ff53a8755e21553587261744169cb9ef8f07b17275c820ae837469c7d5be6617e18732322cb59accbe2a890184d218696d5666e42d268bf15b088eb39d39943156a70ad1eda634d48bae21d7bbfe14354e647d0133d2b6c24e7dc7fbd71627fd12b80fab6bf2914ef4185595626014f4fe84fa64c08f47c62bbf8b9cd0a34566fc02b5eaf9c1e8f749cde3c3785c92649379dad9ee9ca78c4310c3bcbd7fe73c9565161000990929a4acf6eee1a374affbed5ca0a3c9fe0c590edc0bccf52e8fc262a04f8882d6ac15bfd2bfa9ab593e0223c78f20e4a6050c53188425b815fad74a7efdd878dd6125df43122e31a3a943a85629792172210534f9b5ecf11f6ce98f3f366572acff47b6482ba8a2d23c9b9e57838dc9c0f40d5933c570ed77c96e2a95ca4ac21e8e29b7995456a37cfc78dec180f5b730f48c709381f0c16a6acc6cc6d4ecfd098c19cdaf525d137b5f7f2aa8428746604c4e3824301d322a379b3182d96b66d5f88afbd77e4ed05952185e73f145720cf8031d64b08e16a6001582835d4785e01edbb71d6b05ab991e62f2b62612a370d21b3f4156b302d23573425ad29390cdcca3bbd459c9ff8cff1a49b11f2d9095c96c49991fb56157b06dccfb291fe2fa56f3ee50b2eecc9d7292ced085cd601490bff6d2c28d1757960e95d2678bbc590d36750920a1384e6d28a5852ed74ed8f2ad8af3d9e3c13a9e8691e2ecbc5579e18c820ccb3bdc7a810000c4b537201541825cf7a789e94e11ebe5721629da8158a60d059c8bb940bf1139bfeab31ca59702116dcc85791f6d5369a72affcb3fe809954c13ecc39addf469ae3fba12bb4109dbf4c2a77d9b46b7a6322c23ce0e3cf1edc0e450062c3ed9cf88d3c7ead842f35959ec9c9710d615915a651fa38b310412f7118b60de7e0b19b7cff29b67d20b3967a031eec84b4c2ce06977e6bcfcd69e2d69190e4ff2dd40c6bf40bd274087ab846596a77bbc97c2ea53a76f1538bb8875f35dd1f2bcdb614fdb78ce89fbdeef79795ce1d8d86642abc28076324c59f2cc0876200dc8a6e51169c4a140aaf8879dda7e3b1d4b800456c1e356d961f59a2029f1eedf30552d351812573dc3240de32e1ed6704078f63b4b8173101ab6884d4d18d7896a66f398cd4a5e6e9fbe03d415c7f7463ff899658389f0596fe598b154028bb77b5830bc6cf6e3eac6dd7143ed3686906c600ce2d0bdf36c9b06cd94025b92fb259042bf4a27350d5daca5ec6974e309ade090fb911ad122fb180d795108b41026e54c34c3f76178c552b2e51e3848c579fad34fb67ba15d8e4126c21609dc953f7aa81c2da4ef1ec5188ca2dc85879730eb6c29896c67c6ace631618721d69d18dde3b0a37180e6d616499989078b4c8eaacd27650f6e4757be53e405d3fb5357713c08b25c53d6ffdc491dd10877896b249711b0a0ef5a5566e79c907d9549e26add1c6294943b40552ef381ad60a99f6e3bc2a5ee4321938cb102122edb552ac96a9c393b1bd30eaf719dbd3546e82785bf37940130763d78d7106acce0132dfb6500e6c7bed5c88ae6d9872bd8f7ef4b9abb8825edc804bac584a4fd9a6cebeaeb61cd662574d87d338cef34e9cfcb071d35ac34b127ffd200927cc48362179b8dafcea667a8b7141f4b73ae77446fe816a8db220c24afd0adf3a43b531c08526cc131880feb1d961f58b6b04caf58a638f12eedcbad42a898133030bb7beea1e297917ce029ccd6a2e9d14774353d3db4cfefa7521d3f51265ff997e23eec50f9a4d5a034aed9edd7d1392319cc38189f823554fd0f08be6892d327955851eb2c7d8f5c6b9e3d85799f6f86639c2090b23eb955d053fbe7d8776fe6796ebd141e3b1640393c9101b376ce7b75fe12d1f3a4a0d71e8b25716cc56fa92c00821e08112282a4ded2fedb34aa22c4d3aec11bd075e33203e79dcf78997faca96a111aa5b47c3937331450471901c0531ccbb78d63ec32662d8d0b5555de5f3d5cb0206823d64b542789ec928551c373c5bf26b8b9543a943f73f0962dfbe267b40a83899610d1ce01b727c08660a9917dbed534465a70756f381c0fb2734cfe86cfc1810694a1b3bae3e66303ba9fc6d2dd926672aefc7caa942f847b8b51877daddf8121e8e148ebb0bd3f39a5e3c956a2ef5d925e0baee663b4b5fc95d1d13f0af9652dae26b585ea89767dc5c63e22ed1eed3a94b6e0b85ed244db3eb3e46645ea4a22711a175b4e8a44eed2bd59b4444ccb7ecb0401ccade3b26d84f2efae754ee07e8fe36e10c8a5369922660f061d6d1f3b743791de4fa01544e01e4cc2068dd4aacf0d4f6e5ceb155378f94ea985b408447d412ec2457715ae3abf3a331f471aae15979a51381695c9a0e0ae261a0a1bdba472dc508317a46b62ec27ce2d4527947754f2663479d8b123243d628f5bbef80e3bcf473b13e60f194cf277de3b7df1854bd7614fc2bc89f54c398f0b52604e9d0465e27fc8d0ff41fe9d65113c26474bab35a99b2330140ab6456898698077fe5424c3f503850e90f70422595d32d6ff869d331bbb5d58c946a3283b3b071c498796a1b380ff619498f30120b4de17ad35f67aeb1ed077308e9b63947fb0884338dd376d349eee5a5d3d4bb391bb4a6decd788aaa9f14e6cc121f3ebac68e287f321efa17defc7b975d46f19c2ea93367f55d205526fdc3c445fd56ccacf345780f1da0df04b54bdf8a708f743e6d451d39b2fe2ada28a1de954e205de2a66c79e5c84931a1e19621a135f978bd794be31ca2c30110a51c3bab1feed1db9341e553c219853b051b446efdd535b611f07c98ed1ec97a10e981e24f2306bdc7874b43d0489b82cfd918cd1ebe9f2bbba06d373ba861ae073454af654df9f3c40c227b7660d7189846f161f59bd5121d4c4a3d74cb0877e425221f18b291cecbce7b8440eff4f2f6a3fba463168d897238bda05492bac52f7212eb2128a3cc1d71b9c3d6cddebbdeca5f122c0cc8e00eaae15440f31ff5e36bcfa588469dcf92c97b67d74752e29a935ae8cdcfeb32c046c90a164caf2e78312a72503bb665c4beb43a11d2b6bea8299dcb6e02db1ccdd39aac0b0bfe7cad1e9e4a32fdadd34633cba3b78064f26aca00b3ec4956e118d6b07bb8f7905579b12bda4024f4e59899447112dd2d8db6e9d55e5e63ddc196aacee5c30879c90f2c3a6a73bbbd42d39320fb51851b077ad5af46c1891c7bfae50b269bfe045b30d2a70348032845abbede0f34da8026430775f93b79269b751549ba8dbddd6afe724fb82c19ea7f57e720a101e5246e80122fca06b38fe2d9e1ab2873a6f8fca9d6db573187820d4d8817cf9a94fe219a3e67273e597452a004bc05347059353e786d6ff60193ade42a6b7e0e81106c2f928cd0c97879f5c88f5aaa208f760900f4bc770520161bc234c3c1fe10fa1d6c3e1f8857cb579dbf2cc33f09be65b3d9a40346c593b762928fdf55e30974d5f3019dd1fb18cc171a59edc236ad56786b4a60df06ff84c1652bc9b310746bf8626474641b20207a32caf0fe159a7596afddbf5c1c01c894ebd6596e199f3f2248b25f0095da26092ea7fe232d5a6ca889b426697edd930f0db71dc39b021194451fc70878e03822d4e6dc8cb01db7692502c843f69ffaf176b8e1f0458ab2c2a45de8bc9fc77dddbd84b4b2359ae143c116e41965083f203126c7fec250c64cca28ca27247decf49541efdd59030d6b28b61444bbd72588b1238ab9d0d2d2eafd91cea5ad5d00be9907d05d9594496ca9d1ee55de92c8674542af9ac0534a4e1bec9101132c0fb49bc2c5a20028645e59b096333900829427f4f71f253321c05f56b6a6f3d199ff04b9a972c09b56051326d62eed202d0f3c924880d342fbe2548aa8723e310a67b9bfc8cf82d3c87c0f0e086c693221f5b1b4a92f8fa46ea248b491ff76a794b2f1e2e5195102ab15208689ce4c1f888df3ef14e892ac07037ad75825bae433cb8696bb7ac2b2cf5a008c86ad79f3e244860d1d63c5cab48ea981c080a8e24bae22e335ba695dbeaaecd8cc610430227dcee8b6b86bfc278461e4e48632ac3a195abc08442fa64640c69eafb697c5700b879058fad0147a453d90168b2aee1793346947b656e5d5d8741d047205f60c7901e75fa36fee2dc03b22eae374bafa86dd8868f93db96fc60dbc7e3d1dcfe6b827da0a172f9ccbfe4ef6fc957d42012e55faa1cb54894e9bbff40a88ebb6258e83439e1b233d813a781253aacbd4ea10fd61d53e2ba6c7397b156b21311af230aa058bb3e4f2b06cb84d02c424fcf293a26d3ba7bab9a6f44def12efe1d0fea26cc92e07cd68dfd5541dcbc199780d96f5e02ede407235a1408b1bc9d0a687fb48a4826634ca4a670112f2e59c865c4fca387f7de53f7302ecf939053978d0de7f30de58edc7a715ccc842639c83ed075186a8657900a7f7fe5c05e090f91d3de128dd00dc02c29215084781f501a5423b07550b800a33e641ac7a04113b1788257008b8fe9647ea3b2a9a6d0020be27953f1f71f80bd2ae39a9bc7fe83aa4a90d43acecd2be2970a9d571bf18276c6108b30cc47f632d3fab1535f6f2d3f396a30cf3d9742d3fdefaba749f695e4ea626149de2bec6158df4383b6857189a679831f4de24ae3b1229996ae02430d15a37ebba99c9971ebfed4b52cb5b3b8a13f5e98afdb27374eca46331f701088667088cb9e22e78a0259d7882965b4c7dc6a693b3808c917cb6bf7364d55a644fb1695223a27d23688d52e1dc890d3f22cf9ef75285723df9ea87db3f08fe3faf5da7e8c62bcbf93185f053e501634453ce057ba778976a3f01e052fd11bad4ff7a494250a59fd5c66c9593b17ea90de2ec55b31e83f14323bd4826797c2e0d1f22550ee32966e231a25e259889ea754f8b48dfead43c322ed76bfc3ccbb5860d58b3bb28a4dc63ae819fce29203d2326dbcda7a8ec180e650e0d19ec08d51e4a7599befb13c20184cf93918c0e36936aaf5fc3b0768319e2384cdd6309490ea912a1e464f47e8eed95920bb523ac6c707352f3dc1d4e211efead466aadc64b4f5c7eb1ef31c651c127da41822b93880a818b148b8ff5e61f3787e5e2d17f8cab1e3861cf193d9a4a6de85b6bf64bee57cc1e6efce1d55693b02cf76c7ea3ec5aba4329ed608faa1889276bb4ada22df0a8da4c48f1adee7d6e24ec3318f62023f1e86da87a6a449ba1231b6e91dd2bcf1ecbc08cdb1785984769b9c64a0e02d9497e48e2b8d2cfd89a35031e76bfc47f7748513982ce2bfd6b8da90ee8cf838360ccb84f56f24dc2c770477fff9df809e48f962733347cb4fe6ed920a5f62e4db5b4c66502576b9b12c2f4d2cb35a3dd8e34d7da9d27be179db546eef34f29f2a9ab671965ba623ac4e7dff2590f21a35e9a594dda853c66eab976c9d3d3cd2b51f04cefa26803422abb4ca96cb31c82ec73b0debbf52fed6974bcc09d74e3b951fdd66a1c827fa377f0dcb621a375413227461d1e9d0f4be4f2b132e316f8922d1723a1f93b4bbb698520a89a93d072c09161297e4ce3c7725ebcf0b1edf8502b07a7784c5442bcc7b970e7c546a891670542a38ac05fb1629379882c8a71240e4302a3d5560d7b1c2557617d05e0f898b13ed496e38d20f9fe660b6da5f8d45e2df00d2e279fe24b2f8e861577b609d904efd66e61d825a796d48840022749794c3a61de42c7b725a084155a590f5bb84f74088044b30f891754c637b0f2450cb51aa7f294fd3f5ed547c015e6a10603d3079ad8b71bc359b4fc12f305a183d074819d87b864b0dfa3b437592b0531564bb500f65009dcb720ae1989174ecf8b67fbb27f54577945ba90a631b4f677d4ea2a8148b0aceb6268a66f618170f8570f16cfec94c1caca3beecdccf516b982fbe30fb618d92668cebd145b632589e4b640828d840259bc9b4128c7f9a61ccb724c393b4ebaadf0cb26d525ef759447c493b4660a3f76436df54729c28074cbbb782f2c17f62898cf5f88bb648a70380e28f93fb5d1d22b6668008d559a4f9e1837ba4a96818da938447388788eff0d8a166aafb1ed8544b13f25613702b65894b3a7bfd2357db30ac006c2adcec2cc9c0c158b80912f7266faa25ec5bdba3f88c59784466e789067924b86c340d4edadc1cb282372e85bc863bb2606fd08f8db0f939ad02667fdc5e2eef9725e316f677c9af6f489098387396971df3a7999ddcb0d1b3759e8a6157db3ad23073e65d2c10caed5d80b32e18f9342681f1f24af4fd78b0a46cbd5be48208a407f2b9526caaae4427b9c18e7bb87551b2cf6904e2f088a8cb005c01b7a5b2515e9d429528bdb79e436fd06d017e0be467bae6e82a9d1830b01a944d4201b3cae5b0d6a2064c715353383c491778cc17fb74c76f0452b70f1b76ca4546b5791da18cf6ea531158a1247dda6a6ecd6ab206270d127e3d43e07804f369b8b4175ffcd1e3538495ab00173117e3bd035ec728a487f117835e1156d88a6b38186028e9f945f24e9042fa1ee4fe12a53628144d6207b6176438651332863c331a4934adf9c39774dd8f756eacd9227b85301e2604a12c47a3a02d1493395ca08a6ce1c9d2c4cc1097e90f9a7eec9e311c90f7a4b708ca40aad671cde2c742e5739e900abfb4b8c2c862533f209da1c0a2371473cd6c1425dda9c4ffb8d176c449661ba1a2b7dc937b7c965703ae87c7f902011f0a5eb666f523f1db93e82314a60f4d0dac5495cd026579ee475035a60e67f842ce482e4304250853d450d0afb5371bb0901e83dfec845d9887a5c6d909bdcf7a669459164cb35c4e1a7f0e990cfc70074a2ddd838cc2346ff3da1b9ccac6ad874e83bd9a906b2ff3204ea3ce2b5851b5ca68dc458d76447dfb53b85a10116f9b04b978bb6e7012d1b2960f29453265ef45cb7bb8c8f0db95586575fbd6482de3c15d40c710ae4257fd491732f4a9857ed8594d98b5d19f28441a85a0ca67711651739074198aa7bcd52a48eb8eead0298a4dd7bef493c0c7f0c41a38906d481494933afc05bace942a2be1536a7ade0c8a3491a8512d0ef746d7adf079a91b8ecc9cdce052b3d660853dc998df17182e6fabb7582d8875e2d0ed30ff131f3af13bada5ba3cafa5e4da5f826a0e92dc0c1e2916594150673c13d65428c919de06b42ee4db3f66593219763ac2c5c135f4d673fa88a247e12c79d1095fb96e6f9935f67027f4d6fb549463ca61cd5e832e30fc24346cbdb23e5084f1bd15ac39a202f81016daac25b19805026ae06a7e036afa4dde2a2d2cd00538d3752fb19b4a3182f459661facae29ad249b5a77fe31e9b68052d861cb8f8425f6ee8aa59b38a458361e647aca379d4f9d0eb3c952222ae95f61904ec33abd4e493d5c491aca6e21635e8562943e508a392da60544f3c2998fdc7c0dda4c6f007ca69a0ba40c1a0fd8216aa17384fad863a0a035b87116c2bfac985c5e3889975dd9aa9e13595ae7218c6efd08b4b3cb1ddfc142cd57975b6ac7b2f930d47c1b8a32cd817b0e5a6d392b7cf2a618c6978b400ccbaa03d0c2e2f1b4ab3835a5537ba8de0ce2fa39a097982372495055b8964a3764c22e75801944c7fff1ce86de84815f2a0219c71b02a46a5e613c077da5015c3a74b7e4b68d67a5a8c85a7312eccf2e9a25d9d2fffed3cbb4f308784b9209efc2772f4fcf0b7a2b78222a3892d27e083ce9f0a1db11b50cfbc121c45a00d03ea1647d1f4f4f95509d918371e4140511bdfc9e7b20de9d04e92d56598674150224de9b23fd81e895e73b56caf7dcaa6709fc64de591196996a3bdbf51058ee2d62aa92a86ab3085392ec76d1ccb6a889becb09cc5d2a412d8d30cfcb7f9a7ded89b9b607bd5fef6e6bbf59ba8037e0691e2ea7bfe7da16d02d5397ed79fc76bd2f8d0e02651466967e16d0cbae87d074bdcd50ff1f91b7d4e10e9c32380e1c2e85ff572c512fd997a1008dbf0082a04af2b1cfa439acad2a22209bd90fcab5f8c69c95552e086bf4941beec7a5ff0e8290e57817e829500447378f9e731377f4bd69df6fe6b7e045c4cdeb34e92f1c35c583323b9b58dd89836f2a491b70ecc7cd77a9e27f366856759ce0fdd092db8a7ed197a5ee8a407a31c88fa10d5dc88f2ddc9b534fede902f4850f3d2ab625342c4681f99b97625c4c698300bcf9acdce64678e94975a9dca6ec55cab82f0914efe3224141be5e62271a5939fcc04dec78c2af15fe4abf2414a1d9a84d418806789e4becb6c12b4a81ac5885abb5b265de1a5fe203d9bcbfc0cc8e17506743fac0354198b5bcca7a02702e3c31357b1d0d08ae4a4d81290f9462f8c1bbcbcfdac6cc0bac8804154fb5ab506eaf5252c86b1f03258d6360ddca99d0fcab6e36b8cce37af2c0881aaf80201da0b13790fe52e1c0462c49d0d2d62b51d259984430980d0cb9a094f2df401755371b789b2cbdc9238c673d5c6c9c266c1fd8f3764c1776ced1a794915804a98c5d35851cc716df328d2940b7147890f9a938ff73a989b6c5104127ed8f89f2aec176b020634025cc6261a8f102a63036c850db7244a8fcc6ce35247373434eb6ac038d26ee635e50d30a9eb0a8ca7b257c4c12cd0ec6df03697f14746153df9030843423287dc3f8f2e7a604c417da759387280a75d0ff84d7c23af0b51e42c2479d44a7ed837ea012a4b0418e3b185145ada0789a14e5c0ea423ca0490dcf5dd897ef72854ad69f70ff5ad960eef48959ce45c3b8acff1900e352faff331c3438650edcf036b5b2a4b4402b2e38c01c3e16aa7d121a4d207b3faa272424958596c913e0a1e9939987d8b86b8d17bbdbcb8d3a5138f632f01d2f0b6279c5200fed8323b0480b00655e4ba5613e4111a1eb072980a82f2f7e33487eb4101d73893fbd2f4e3dfc8dd837f2cd5ab90f55cc416291f88f51d966b85476b68d5de332c86c981bd5823bbd49f002d7a2b1d62be3d36e2106d721234ac2fb507e986c047fac330b23b6ce3be84849bb900c8247a8e9404c167b51fb0984bf1bb1b38487dfb04467d0ae9de523d9ea0ef38309287d8c0e5c602505e1123a30305f751f60cf1b96daf1301211e43a0be1124b0bfddfa1bdb95df950d8f0941226fac6aeded328a05f0c529ef53b730183938c986ee1187d31f3bf59bbd3a35c488a9f51e189cbb70adc904d14f964f153c9ee1d267901af2f94d235f46010e6534118f4efd9baf1635d33054ac63d35bd21bee38dff4746478da8e54a0ea26242625f24dee6a69b95fdd79146f92c08812253f258c035706e363bf9f8e422ffe0e8775d34375c74619531e7cc4bed0c1436e12a7bdc88c4b2a762f75e014fbf1c0ce987ceb03ea7ce347c1915006051dc5801c03a9169e45b8b163f59936d9c3a0854a2367f93f403437eb940ee947e533036e93c43a071198fe9b979924123918b175f3a68251acb457938020a383b40f6e4967896817afeb8d7cdc28541ffeae65e7e1eb5538aec17f8d8b546508680927b0ed0a6ca7bee41adb975f7e3717538a25dce8ca1cc2a45e0992a76b8eb5766cc629acb327f19a8182dce413fb214e3b6e5dfee33bd7982a65da3d2412c7e721f78a9c9c06d62dc40c88b117990eb9b184f3db1f1f793d0621f40c491e3772c18732bad40c6372a41c20ae73a5599f9ad91545d66bf447002c533822e90536a697d2eb13a4ba8341b72a2a7b8d59b69bbde5798db65e3242c9f5ae2a650ed532531285e9e1df1a699215d4fbbd170f4a9d84f409a27226077865f0b1097bc6de01a65b750756c241f6443a5e0611805c169ee059d39accee96d31663dfdaa8107c338236416691f41a4933b1a7f3e74493063216b992d8f4c50f1f06d44e4992cfd668201f8040df9263a85b8d32eaae662ab2277beb6c51455cab97a0987f9017e93e363ef77af56af9ea94148041f9e14d42bdd11fd7e9f3da228d68d989b26ff51a14e2e0dc9947ba55852edf8a9fa19f6dfd0b8596fae86a28963c26af59ac58f68d5c8a64737a353904c8ad1859413027475c07ce49bd0f32bddd60c0a590926f2bbfd9059a23afe0c573fff2bd6eb67781220954b36c6620c0396751c675511ed15de575e3858cad91b62c460857c7bceb3cb2b85d199b692025a81758653bbc288ddacfad073bb267abe0bf1b029e6c1f9c875cf2384689ba6fa13e49d383ef5860b8e91f74fdf3ab47c2bac1157d9dad9e01aa308cedc124ec5925ab5d3fbd365238e68f0698f039e45af45fe2b6a2e2c8b6cc4294598173c76cdc508e83c9617fa320aa9f2173e9b39870581f2b3035389b898fbb2dc7941a8743928cfe1abaa663abc1f090521a2bbe9b49b31d7b2e8c5b2811260f576369cdba4cecd75a601bd4611b204b9afce50665ed005793d77a892d673e09026cf0b790002177575e242ca2829c797470b370e7b634d10c43620388017869b064dc078c884071ce53c89c1e11c6fe57cc31e79852a3c0f3aae0f9beac4ea7970d6591e0c919cff8538d2d4b3b04d057305b1d9ad16c66117fae93911c5b24f58bd442ed51d823222d792246b04f0e7627232f00d4d80bd39bf88189826a4fd5998f6907f8ea2d9febad83c02369c5cea9437e6700d675570ac5d5040bee307b52e1d4c3b47e6bc0a87359a0fc708041f60e42c7b50924728d50e52dba757a06b8663a8d861070c8e6863ec6815770a3a56625b9cde2dcfa922288f7af9a322a03de5a52a8e0176f6ff1aa560c5d5f957fed9f1e0783361c93112ca76f102a71e6ea61b292db8ced4b9a04e70262e3128131759b21aa82c7c359fd10f1fb4365277bf0a47182a0842ae4ddecc2ad67275d5590dd4eb252e1d6268585899764c616d7a74696fd2125bc7d806250d16649763afa35fdd7a372cc6ae82fba73526645182983a4c43f839b0bdbf26a14b8c7fb9bd29fb3bc95438f2edafb1f431fab9cff01810d152f8bc5472cc6ba49c912c33e78a57d127f3f55ea14ac944be056fc294cf9f222195aa5e8998739d741ad74f2cc8fb4cb57c32cce224b06794b9df503f49e19affc5db9ef806c4c699b2dccdeaf4639fbf4fb04c12d281c8cee918a87a49d825e86b578929fc86595ab6535a099b894bfc8ba2e03def54ed110bfeb67bb4338325ee898e958f5b5956ddb63cba4da555e2b8b45f4aef8995bdae5c711eb3d93792c1de0b2062858a745464284bd4126fa7fc5289cefe71a7fb2d431e1f760f3e7c0f6766003e42bf0738cec36b233b5d7b80ec23acdb4b548b8dff4c642d45b4db8023323234eee4cf96229697223dd9cee178b292b2fab01203c37192829f28effda87b6b91637ead8c137cbb2b578ac9af2474339807164afae3b69f5ed2b81c5c42106365af723e3323f44fcca4c560d30ff3eeb5464a4ba0eb103373be50252147b4904a43bb982e94290310213fae5dfc66743d4e76099dcfa75f99c547008ebbcf09cbedb669f6c2b7b5b541169898006a18a2beefbacee22b87b904ce25dd33a79764436a6bb012517cac2f556cfffaaecef1eb6afa76ba69fad5d2c624ec2f3b8da9b1d2b6fab8db5f849655e9dd970935ba87ebe56a59ad78b91d5b294a1bd8b3b594c1d82ec4d62edeee0d84d4071790a1800ea595ff73d8dffcdb0cf98f638b44d07f002261c0a11414bfce06b0741edf04f7e8483408a4f73a1f82e77c77acc0adc057bd0d66bb9e94a32583954c95aeebc70e6d02247ec9fb11cf7388a8523eb9520b8450e2dd3bc50374f837c23ab26a301e457d22340d3957ed9f66440ceec8b5eb094806f587810bbd3df4494f6df902a1ea719480f24e9eaf2de261646b309a86779c2a9fe08441c437f5d7a1a36c9e2475b1a9ca455b7a868577f995354b0ec3055be0fa23428a2a8ca2cc0a2529314f1daf89f93ccbb1e503d6b0d0753b00c361db9037c1aac6af802d4c5ebd579eca6cb3bdf174646ae1aabd380db247a74574d83dd01d9ad6231d4fb5eb4ed6c8a33035f70bf0a5052c57aeaa6954178b22d34715d3916ce632741f7480ad68f797969a0467c6bc7bb0ac2befe8e87e0967ccdf565ece397a90b8cf86edefda23550fef8fd0dc8b9145687490fd83498442ab65059f34465dfa9d8ecaa35d5f28422cb587b1eef3d49ae1a4f1eb4fcfb7fcd869f70b22618580d7f9cf71fe42bcccaf5fa8232a87ee9f60fef8efdaa05a8955191308396bf36aa01a123f135fa3dee6791001c03190f47fd35907c4ee0151592e8fe128c6a0351cf0724f8fd6484f450f086483b63d0e0a17cdab26f7caf4dac626ec95eb517b1464c300baa5c785b723e4556c7a7ed119996707bbb12ebdd509ec5f929554a3cf0f849448cf9d4d47e99de8e442ec49c65baa9b13b34b7f94b1e473ccefdef285c690f354c347df01b7c7f86493a4ffb08d4df91c5ac6d59356b6cfbecb2409","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
