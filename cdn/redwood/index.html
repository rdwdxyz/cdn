<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ee62823908449f325d22b4b1a4428a10762b288912d095738df80b6a02739958a4c7a5fc6d222ce28718b516bdd40079bdee698d603336adfb01e2d0a1b3e134fce59a2fd9a428e7691cfef51a4f8e9ae3ddfa346b24dc8ae226dd7b7534530e5ae6d34621b901da5f784eb5f7c4bdfe9d44498013af5bc43995e01ca26d3111c06de00c7750cab980d9120bc3586e4dff1cc6aaef113903d4d676b0761df1bdf4039ad703a2914905a026b38026b8199c512fd4da4b01931d9ef8d63c85bf1267f53913ba309ceb0404adc51a497d2282ea11c7217fda08d823c8d17d156dbab0d928ec32bac00977e3c6db98957c80af28905c4d2b30a326d351620cb3ec62551e24a4962029cf4f2f5e4d3b9369d0691e7e71bc1c4abb1244ca18305b886a7cbcc387470a08894116a073fe835ef694b053f45f9f4da91a5e73f8b0274d18b159f574fa4a017fd204ee8a5d42a02723b463ae64541dc0327b22b34b307297ebd0a8c00c93eae3cf4a8c053e3fc58fbd8179a6bb7d1441e0737582ba8abd837dfd048795995d4ad909cb1922889e0a18c36c18e98b65d970b5c2c983d5e11783bb07a47e0f0bd113a201f2c96f61e793ad98e21ba554bc469af7e26346bb18efee87838e5492a675066813955e17f885a89911607a4864ef499b57f2a6e102fd366e429fda75093a12f6bc92095b782af87e19cfb518c686c12e34d9cd46e30109837d11c1ed40ab0bcd363596d0b43d0ad8b5c511b622ad248c49aa61ca721352bb71be4f4e786f9a399de0587e8e89af5e2fab5c00d4fb4bc1d22a184bc01f00ec18d8c07b525a87e00d790928946fa92e6a2495fc88068259b34aa452b52afc281d816d9269e7a8ba9a53f9cdd1a0efe300c380aef1d549823e14a95656fdf505595ecd67429bf49c23c3bcf80da2b0b7866fb5997447175008c25df4af90c25156402958a84cd595ffff4df4ddc8a755a60f9844b9ab6967476d671aca04275ef88cd8682d71a818e0698b28877887eef1f6193f6241d162ba77a1b62f50a49b74019e752713a9e3350ee0e77e8a0ba47aaa3ac43513887732fa64098465e4c1534cd922ca00ccf03d2bb0ef603e123762a2283730495eec7d23be81b3845d274f5ed56bbda3fcdf8dac6263dd4326a84c597bad79e4cd1f514d245310ae65762274f1810cb532290ad60ac941b48be0c365c48b507b8d8f9e9fe838f4501fd5344b823c7402b26c49d37928440c2df73c111de78daf2e6bc1e9625e9cb8225ab79c5bb8a168c8b7f45993c92c2823bed1e88026db0bd9a9b08a615cafdb5679bac3cd28856500bc618dab3d61c507230a9c734b60d41c4f26c3aee18b824508870c85592b15ffe64d5e4bd248229427534ad039bdf96d87178983d11e61acf6268f07610e103872e8e81ea201ed54c6292bbf3ecc19809bfef7b06ac90de4e71dad225b97d4345291c493a302a0b1935b8ff297a69ba9619f9302ad23af9907ac35307bd066a1f0898498ee9f2689c295cc7fc2bb495691df2e8685558fa27a0a529b7df1e136991574428350cd359a27cec8dd3c88b9979eb0906f04b743bc39a9ad000ccc91add47c697d450147854ad360bea41e967dbfcced7e78376400a4fb243580e79b26b5f7e0bdd923a7eabc0758a7486e51b3eca37b2bc4d4ab66aea18b27ed1ec055de454459dda1352e0e82e3fa790ba59d4a9f57b4c11ddef36cbda32fc58c88d1d6ff88017104a380c9b09b9f6c8cc462d55e9dfa136143718af17f903dc508e8b08a5867846f2bc685929c3c98677e3f66d107997782df37fb1cb2a00ad26d961c72da7d96000c3aedc3e62ba5480cc55d4b9f258743b1943caec5e197e51c56224e3bcf369074e2dcc4e5fc2197edb03e7df6a521c4718c1f5ecaf9eab1242143293c8c4489e475415f9fc983488c0031fbfae40d8d8cc6c132bdb4d38adad78831203ac76295522b61979ce1f4d6cf7b7b0ef452b8732efe4bbf23aced2d499e0494a388227273bde39198997b2b52ecd3814d9d8fed5ff22a5150236821147507f31dd693b6e1f1eee693150d600caf4ed78364c50ac62c76b158fa9e4117d252ce1a147b86ab8a238e04bf5991f270ea89b9b1e2a1c8ab91d908cf786f0ebd4d1c8458c2363f59f94fa5f5c81b97ef8ddf7c838a696c41d8842cc7d796dd38e247b2d55d5fe03e22e810556cbfe94c4fabf65b8189c256a9b9940d2217c6560618fa624af0232023774fd88b2ce1625b1df7aea65e164b10c7f8f061cb9eafc613c28ecb836facd878a99945caf29f149580d6c5bc851f847a729b00fb64b4924bebd22e756429ec6181010048604833fde91ee49e1f488fc4011653204bc75d44d7a96a4efb10487945e3da39659dc92e60d5a27fa9a8d664bd372836fb1a535666692a75e17bae0b3c3953c285d312e8757f07252e92a9b472d11697391c3dba0ced5149ebc454c61716263d5de99e340933ee48fe65be3e1b47856f3aaaf4c482423da267c024d01c88e650675d4bc523e23758cb31e683e505859d8d6cb063e5d158c11f52229990fce47c961ef168f2dd5eab0c054bc9a681eff2669b70efbca60992fae15179e769abb06542efe1453fc7c3c9f40073afa479ef57b77d6ef06ddaa92cc55cdce8fc6769cc81be6e5329faa12438355ef70fbcff60ac19aa04fae9da7e48f7b88927bafa1cc44ebe4c0500e330efbbfb4cd5a00207bf7bbe01e629e93e7848ce7c9d9c74d6a4ab3af8664796efc2935a78da31bd5a321398eedc8b3c7777d8972263a1472dffd75fc58ba644545fdc8aeb5a5d2c2042e654510588b262a7b90db55c004c67099a38c5de60b3dacd3d8282f8b82720c62780189ab8d74b5733e1ef7cad7d6e74098c9bbc7a1efced9979fc635803cda92e445ee3c9709b04fbc4fd1758d7511719069530dab81b7b072fa3aafa85f0b2aa41066e76f07ee81fc30e5a03ccad702b5b5ee2014db9f502381576dddc973b472fdbf87168a0ce85e56141f440119cdeb945d877751a2a7b7065edb9069784e3adbdaf63df51901d516933ad8b93ab3cd1d83ec630b05cd7b90696aee268c454a80ba3ea86edc37865350ef86e8448cf534819b96e7b0f472de40fe679d34d981133e01bca770e6716dc4c1a9da5ceef0800dfe96d2cdd165e5ac65b2075ac06af161ea296d121b54356f55986a9e78501ee1b670cdbeabd9619df8289803532c7fe58ac75f7add0c347f4a93f3f5c0f14d0209f8b088fe6998589de91c80a0b093bd6bd9243dbc143acdffee4bcf7b0f08ad5403e025c10b3806c4ad80a192a23c98e1cb68ec7a69efb08f2af832f22510e14cd9ebfec2367045ee01eb94e0547c5c36186827b0124132250243b281a5d75caf785b9002e56934524988b19dc93cf8ccee7600a43f037e912a9ab4f57e250307bca0940d8e7efe9a4b56ffccb13097022df0cd2366fe36bb4065f6e5f2bbd4e8a8d88946434b889da1b362311f60c39a43d350c597c828f7ee723e683192af94ee1d7d2d9dcb326869b21a6143b67aedfe5ef37072aacd2a138b80e14cdaccf4f7d8615a4c7deefb89f098e3587a51eb77c37922f518974e2def73f07a67f3a9d3e8c1681147adb8a3d633a405ec25afc51953a48bb7ed069668b8a1fffc38f156e9230895a3dac9af8c377a6109c16c8ef48c0856974ebcf345a60c441bf0ad478a493d27926deaad7bdf2bd28e519d340381b24f29b6cc9bc520b46b615303c1e048749561b1a6d5f955c63d98c923d70ed1f021f7312ae1976ea9496b8b2193470d08c413ddbb493f3f7d9a69ebf9e472a712582f6fea5beae743371d5bf8b285048d448c0cad3e9f9331fbf682bfd6a0f5236345b6e729283ce8eb916831d8fe96d80a6dc5216dce5c5d3355b4baeaf7d88e38a8ca56a9b0a6216546068f6311da06b993de0316cfa67729794da8b18b70bd1f5735f499afce2d7f3e312c4bd6c64a8c4a1998c7029c14cb4ac3e6ad2f887bfa33926a119e2ab778e2a421a8e7dfb883c204cf41c53ce3231c972870dcc8e11ea1d760e532efdba037a4b0407c8eb484efad01ce6db53e703f39494321078fc356d155c4cc18fbd484d51d40353cad8ded457f3bf87f789140416ccc0fa99c9af7212bacc41cecd24066a10d51fb4a0edb88aef9ec1bc103f996ed38ceed038e3a808fe0c486a55d623a6c3208de81d7f4bdb60ab4f661271a7b6bda713947d237657befcd34a2936f611eea5bd2f74e9faf70dd023d65df4bb3e649e0cef42660b1a692ec712661cc8a8b777d30c47ac8caaccf1ba0ac2d6b72d258e72129be24e40286585c35472d93f740158877b484d7f7b0b5784cc6d0de9802032420797ef086550fc004a41bdff0b8b50127c0a3b9431c3ffac9cdd7adad6e172857b14e2cb7af4c7b826e34b2240f0115262279b0cf439251f3db723edde3bc8221f731152d442a8589fecfcce3ff421af8f37f7845da9abd0ef8fad2a182aa5df8fe5c8291e39eecbc753cd12c457914c6e3268d11c069cfcab548dd7fb1f01d603ace0d7bd5e509e63a6d3a0d0df300c8167763562d00be3df2d58bfeefb5482d08bf589d5fc6d13686aa0f55b6fff595044d5dccf4b2c237f0f59781815052250271fdcad22fb83848597e01e16dd019adbb5f0b04695ab2176836e715595097185d3fb29a8e4a3cef93f043625b4421bd1f6bf6e2105ff309f92c342744a16089e106da302a52ca5ac7b0738d730ac05fa9accd433a08c5a2c3e7e8994796a7b1e7cc96b9822180a423a7965c5837456dfd8125902a8bfcc5aa60b529176a08bf717fafcef67d5b7612e61988f1c7dcf71e4f45eda8ac32287a0b4d9396177a94bfeaa29197573081c56dddcb88cf65ed307a21a1053b9d49f1c9097f025580f4084dd9ad78734789c03a74b1fd428fc07c0581b7fc345df877b7b9845ae89d14f1ff28f8059d02863ada552eba38e49c9083c2228af98087308e9987d4a4d799fdd85c3793365aca05409bce96ef036bcb2bc819bfed1fd144c9c8a4364d34726663ae5f43029fa9aeb5567ccdeb90f0ab0dc944ac429c279270e40b6e28c0197d8cde493145676497bd3e712840d89f58ad07022bd6f488e23023b4e1a8de98d35dfc936fe830cba61172cfedc977108450e12a9343bd80db84294dab19fb0b2b9c34a7b69a9891a1b8d648e7b3fb370714dc4894737acf0b19e7fa06dbf96f0f31a43df630603783557f1849738608ebae8377e1c2f3c86de9ca18f4a8e2f5316ef0e054c8f50195541340382bb626461dd77cadb7a7e6ed7e4dc0376ce031acb1d8c1a8392b173056291059c24ed119385377c8ab3651bd50d9e9291028d9354b17ecc8398528f2843787688a3481c3242bcd54d85340b019f64409bbcf46e8884e73d28ae66995339b7d8b59ee524601786d86e7047b57f5bfd69d410a53589906492659ac2bf63a14a243c734497c7a05cf56705017e4d8a501588767673ec7a3a9580f318e15b8aae1105b09802ede8ea506cd9d996433a821b0e9200ccfc91f4790d47832c811dd28ff97c3616f2158f4a005b8f922e5c1907568cbd5819568c86532da1c26c3a326909a34bf1a3de9402b66c1f3c319acc8ac114ecbba6c0417ee92d68f26953f62a0d8064a60e5fca0eb56d854a9f661a5c3827abb44b83ede2b972cb8b60dfd670548cee93f63ed327ab80537a8cc39188ca60f6d969cccdfe02e53239f25492b0f963fe3b134d5d47a1dd68d2edb30d112e90c8fd6e4a36c5016ff10c08835c3f6a18d17463161ed01074f907c1761ad57aefae083d2e8975c9b8e9f7532d76eb2a11e77e7758047b3cc28fcd7d5eafaae5801aeb6ed8bea96934054d077482c7840685fd559384eb8d2e86db130f0e5c445e1c504adbe3f39900afe2ffcb09db5a02b7658c0c0aa01fcdd2885927c90e30ecec73c150812b384bcc02bb3e6c8fac6b04e66fafab7f113370169babc806a389d3d62c85158d57047a359b1e66c2e139eb080da874536cdd0c78d016b5001d23fb8aab716e4215e256c9f808a43bb1126eb6197537cb018f46bf019afbf0d927405f420409eabd801fa4ae6c0ef9e3d7e95096be10736b12def35f95bc647e04bd59d50134b5e60ed115fbb20c873cbbadd3e087cff35633e6cbc9b9117227db690d7600a53e60e5785a2837cfc29503af74538bfbf9620290ae96580457ec03edaffec999d7e92521ec19a57808e1f9a6fdfd765396eb47a12b102e6125bc79fc3c04be55974a8211e0a179c16fc39abda843eb9d17632f5d29fcba42608ad5ff6220c0c86176765bc0bcbad65635c58a495292c03670acb743ce7ec886158ce3e5d514c70723837c046e3251622fae14683be50ec616979c740256a725771d756b778f9232a471b2791450f30445b9138af3841bb03c7525c189a935e32e33d359b08e63abfa400ba782023526bac5ff3b27a47380c0b3441cb0280ebff99d8284f8b5a6668f4945cf14e890e8a61a2c17e553e965638cee20c6095c3a11427da95d412261138788f179fbb5ffc2ffec0009422e720841e7e455802efee8121aa47fd65b30bd65acfadea277ad4b12ccf9ca8137f1a71d028777e9c4e52cffb7992c152e396f4e876691545ccfcffffda475fc14305479483a5c43efc2507dca91b3b6c473cbbddb5b39e08aab6255529844b48b74d66275b84eddd5322e89e2f4606a581e4fc745bf4f161e4eb81070f5390e905f807c620845c072ef79c7ad109b55a9546c4cfa7701321bb674ae6ebaa85c2c5d9e0b1b2a4cb245f8eb008b79f26cf959c46e7302853a7a7bf4680e64b442cfa68cd356ffa49a59d5f7beeffe9d9ae1624262fc1e791e34c629c572207715fd047b6e9e4ebc68987aa9f474a61b2880dbba56d20e9a8ded95d91ff7b5b0f89e8ba1554b2007f924dba183c5cfbdf8ebac3867d74dd3cd4f18dd313158b6f516e9f845924faf6ba3f361988fe486e21e86a0c5d2d61e1eb23a349589b9e0a3e2403e3f76fd4f104f23707940cabee68626c9cc2d673f7febc1f01a8e14114ea2a9b0a4ef18fe7b07a79e398518c38f283e1a2ed67f0b90e7a2439d3c458869269fdb9bef9b523b5a6ac64614e5e2ae41bd0b65b24760e80d60eade2d05371bbde24727d1ad5f40190c4eae5cf4736116729ee86934d508665695f15a283ee31e088dede3303d5985341e37fd3e275d87d87b475f6ea4c6f32f53c353ed7a5f6f98b4fc60e7885ef27c029690dd39df94c6be832c316869bd59fe1da9ae52cd4c3c58eb02e7d7a7af6cf8af80995f9b2318370a46df80d9fb3ad97a5a4028d3d517bdf2b4730a13136c26725206549c664bbb26cc0a0f0249672183987c6d0413090f37987efcfd8098a6db6973af0f4faf1b16edf4689a0cf1b9b68f008f4b6faa30aef1499de0fcae77e1b4cf7d68240205ffd4fa0e393b331c76427344e43354e8da058c25e953ea28834990b8e8eb915f19d22d3e976897b09c2994dbf619f4bf01d41e318afb526003124596852fe728f92040f018dcf1545e4b9016ba7b6fb5b6a1822a894dea61a7658afa1a0097e9f7e183a3a6602eee07d819717416b51417467c7f5dde7e5d2668945a9f14f527275b8581744296f2c32e05512b919ffff4711f10dbdd09bbfb2c104ace7d8fa7a27d46b3ce01f872cc6b76316d6dc302141e616cb89dbc74f5bc2a1ed1eab11323594fb297e541572a94f5198a72e0836f9c9917cc6f855087525ea3d25bc6c1e861cc4e74806e3565f19b34e4c478aca48891c57813444e233a65c27d9cf3a48ec66946e019f00e644cac0de2b1ed00ccf561cf827b069917580884dc2c6cac511882273e1a46ccb2f3e7bd6dbc9053eceb2d46e9bdfa2931f13e5cd8deb12431f760ed0e69080c95ce216495edf1bd490f40fa85e8b061cde4de4e29d5ada00c4df602c6110b2a91f55a48aac4968495bace8f2c4f5c2b3472811df7f4ad72fd003e9c00d5c2dfb8e7e2ec6aff312e0a1f0b4007df98cc4db04063c0dd6ce5fadb0b33aa3481fde229a3b4c8a09bc116e756b9b1b024bbc0ad83c0cf1a4c7010e6fe5529d483152a3d66276f0f0283a0243f1e1cd256939ec22cca1a94bde98cab55b03842cd3d3c753a862a98e19197a370a7c37db4907c5bbf427da8f1020d03affb76f5a3c106dd3061793d724d7e21ea091dff3cf4610849f4ed54569d74c4a7af3b32f00099139762ee550e01c04b5f55544c3d8581afdd9cddb9389dba73c6e0bbc4755ffd2cb2b2f7c2093a0aed974568c6e79031b2227693b72b6f2c5c78c585f3d09db4e1ff6c44a14db977d0acdb46f910f66617eee73ba22fe6010da5c663ee6c4cdecd6f89e333f727f4acc98b45ccfb7d93073eeba0008b90fb14bed780c06ed7029a30fa33cd98c95f4fa3eac37529726d936cb7bd698c6e405530746b661da51b1544cdecf86318741514b03f9732b5880b7b4849c63a08a8b4d2b75627e08a246ec23d1d115620403c54eebff8b2408deb233a441d01824c793b7dc16eaee55e98c0d79bb9df97bc08b1b45fd335c1405f32277f7d37b01e605a9ee0b4f84870b134308839d372635012369b240aab47dfcc6683fceb341883a246fb6831644ef416f6df67a89cea0e80ea09a8a3ad5818e5d9a83586cda751b631bc92297b9995ebb5d298c6ab93c8c408e4c59c1c5dfadf4841f60f39c98d73a5065ede49e68454b60dcf62fb32c160c15c8dc4b49ced349f21a9f3dc15a93c341924ea2e2fcfebe04d9355079246ca927529dff2a248beaa8d90cfa0b102a908894e1b323e3e89774ca0fd84db70862b37311c63507fd69d17f45eb118b72706c1f983f6b620132432d0d62144dc3af15105870668abec5c5aba9e315186722ea15049a6555be26ccb76ab5e2989df84651984d1d8e34c0cbbc61a300d9a0478b57c12e3ab9b3296a3a9d223a62d3bbd032a04a4c94584a004c2d15f585dfdf34281aa52eed5082b5a4b29daebf021bbac70e3e816cf1496703a86d135e7053bb47c7add784b35443b795cdc5808f47c995d6e3b6e476d0c140991ed8571494f0c0df49067b53b17d3cae7534711a02f1be07e1ede816b82d5e2ac48eb79fea2ceb96a885be090154134e37ab6f63902983d240f2baab74a371fdcdc930d8c6cef841d69dac18a0584527d2748ec91b757873a1fd9e4fa049e8089f31cb685f57c4b0be54a4e0e623e15596706d5eeb7a55e5c6b9122de035c2feaf8ad9f81c808209e51c53c8be3907bbf1dc0fcde67c36788324100d80edf6c12d782e18e720e0f3fad7649b5281b7fcb2f294372d9e4edc0d288726580309d597ca5f6701023787e353d192a700b60eb6c805dfcdd2f73b010b363896b158fae489a7eb4317df2111efe19fa934f662289bd7d76ceb6faefc3c2c085eea2a3f1d3805bf3dcec23d714b7c801e6096be550e0ab06b863012ea29a19b195136ffed59a1897d8e9caacb65aca39433b2cc634400401002317a5f67486291ec2e3393b0d6f490cef9347c99fa792f4f1e69179880581ae25bd28f50d55c344336b906d59779e97e381919a6cc6f52c5502230cb746dcb843a2cffda6bda3db7e86bb7fff14619a376c9ab1dc93173b0718ad9db622a11fef59e105d63ea1e24b6b29c03a94e574c0fdd90c866547aec43852260b86787895004e320e6547e10ab4280379a8f8c4bbd63f99a5482a23a3954963dc6a7cc049b941526999abc24c1ea562696ae3d52ae0f1c4de6c8e791cb25ae05acbf7784b096f9b4d57e0012f2e7c9384f2d4a4faa80faa4f78d9fafe248956546b84cc05fa789598f91ff6ada97354bf31cd69b7eb15d597d216a666d154797ce7242d91a8118fa9fc6a992f2ff0eb22e4e1469b677947c03531b8b120db319b415f6aace2d710dd34897cf07e6912ddba6601b36e97d45955dc990e70d7560c9576953e7ddcb32d932efed11ce9774fff11a5453d47697e4c8a886c4cea2462cc7fe161cb483dad5fd63688f853beebe7c27e6f4d9ca1058c0635588d74b4ec55b66683b1feb5cee5c6ffc6a7e2037611dc8fbe95a5b57359c8a26cbe529865dfe5997d79aaa9b074fdf724c3f91f02e9f4d407ad8f5e9f23bf53f0724a9f4f54b040c7b1ec05c3a25fd99c416ccc3027d49622a7de47a9e6bbd900668994094ed778c5c6e2821af975731fe77cd82e88b65a18070b8e1e489973287dd5843215e1e415afc2e41ba6ffc76cfe1a7bc1f70fe04b7c214ea2e4cae755a1da4926beb28628266262dafb4b44fce3aab3787eb2554c79a2f17e24bdb5c7c2fb5766a3bd4443619ca50434060c0c426384edc15cd2320eca2a368aea01d238dedda9d09924181a8103da8a173e6c754a1ac74ddbffc36f0dc1a1395c64f9e32b2eced75eb7f6657a1d354fc358cd9d5f568e6619435adc6db8a13a7a3bca2f2dc3a10d12f492ca5bfbd1b96895830f8947332e37a4efcd66b46025ff2ae667cd3b562914156ade8b42b486df3be22be4c01767b764f57af6438e410e41b1d2ccfefc17870c8366037b441b9190f02a2222d85668c71a10dd75e458ec02585e5820e02671472718e5fe8195e2daa7269db728e93e16721c7a75a728a3b77a10be1d2e56824540763ab95a137017551dcb1b09ab42d22e09216ecb1ca19d117d710daabaa386adf73945cfe298395f495cb3cf635e0629855806087ec9fee0addac08fee6fc77a175f51d6014c0239945dd604c45799096027be3bdd823bbdcb13d226577b745e897608e295ca81fe0a7f16e1cbe82dab1ae57c19f82fe732fb3d3455d399046be4de64f92f366816e236aac4a236836c6c581921190a61cae605da28216abceffa0dfdf4bf4d783b15311f4c22a973a0407b433b49e7d6d8b59a37949668d131244cb6c9c044035d50289cc71618d75ae98ab609735c6d31d0bef2294fc80f615aba603cd8e00ba7752057a8339ebaae59e3778e0c7df577474c013d63ee0f61d2db7f87bd5dcda6d864578dc583a58cb9e0e3f5c7d87e9283870bed73995f32e351a33de114407d4ccc20f8f8105e615c68b27aaf5f7eeeea105f246517c22169d07aaa9a2bcec74a66610bb886faa0ff045f754872af98e78754fd3492ce91a7e2c1e0f6e5bee5c14bdbbfd1dd12f4c203b1b7dd7f30a44f21b60aa342b1f53cb5b5a4a5f10f444c655f2557451c1d79444e7e1f9c16d400c2bd3530f64ada65d93df1f95f7d60ae64a41a457ebb6f7e581038a2bab4dc30fa7c31a629f5e9ae098c3c507fe3ff25ba10d83dbb49ca6fe5e1921a493695fa7f05e7128a0af0410547b891f126cc7313a786749b7f33c2059d178edb9b5e31bd29ff0ec2064ffc6a9eaa23a46ebcf0eb9739dab4fa574d7e007985596d98e5ab311df181af1f5022bb59ac1aec65fe53e4497923b64715d007250c3a6251a7af9ad16ee33f455b63443c8fa65504e7f77be8876beae0ad96da8a3c08e269082db1f6a725a8ea969b905b9af967fe01c711885cb201021a4a4a484c3c9379f7ac169d1f0a6258b8289fe5fb6e87f45b65353cc6d7bd80264dd9a55edce337337f4f1cf0487b3334bdcb82e48ad6ac790281bb4fe76249aa45fcb07a4a56b4a0bb169391f25f1f856fc490cb355124b31925230c760b9ff69f80b6204f84267e53143ba1e85db6d5881a9229a57e736a5fb9ef9be17938853b57a1f97a8eccdbcbddf8a687ab2fcb59a01fac67a7989fac1f9487fea201a9ee823c3b5c295cba0a1917adfe3d351d1bd9ac0a42f4ffae10998c70be1b2f9756d5f4ab2b88e4693a67fa61bc1dc339073a2934c46d0097a05d8580ab7462fe5c110bb6e790c338edec44d97ad4a4269524f05b0180e95bfc24ebb5f33e9a7e47e16e0ba27071bc47e088a708733c52f79ac87383d6e77e277ca973bef9b49310a5d45e48e5b1dfcded36584601e736b6d6d5285969e95f59c421cb7fe4eb5b952b54d13ae4745b5542e597e9c46be28b3997d93014959127a9ed73357fc53d9f030c063beffa4bdc702290ea012f775c0d8a886d7e75308733b614a7094065439dd4b3a9deb0907dd6a3f7e7e06bdb459acb00c940ece599b603656e88c1de4b62598d9ac1e244f668ad2cd5a1a378016655bf9236251e1fd5857083748549076edc730af6c21039b16ca45f10658b2fd4d8241d3cb13ab566305c617546c2f7fcb9208fd881e64fabb96017ae339832df6aa6e079947a741558b0ebb6e2e9fbf5e698144909520a20b9946014fe278434c4382daf872daf4989e0a5d1ba6f3b2bcecaf7b951f60c5fccd385f07e534484dfca34189a001969bc76f749e1d3d84c7e2c53d80e9d79accf05cddf061ba52897089cb4ee26aa5e4b5a89b20a87974b0bfd13d5fa32331fb70603faedf4452b6ba57cfa5e0c3899bcc6898c977ee3081d1cd0359c6ce4104964fbb7b125f1a7d3ba4a17306cd58aa5395b93e319e6dc5beea733650e85f7aa4725f290548edc77ca07c837637c55b7d778caf4153b259bcf38db3e6d5da50c709de7d8a3fc6fc8f90833ac2bbafcaae42827c92e10ca72b90df58ccff1fbec21c64e73ad7d99f7baac1b393ebaaee1b5de484cd09045ca841f8db9c5a3da6328bdfe94f7542eb0b2c39738d63860ea7105d1f1a9ffcaf61ffba5443422dbda713e80eecd6d1fb05131c0512ada6809b0daaa7714961b44d5d559f84ca266cf15a682d5e91e377b4c20bcadd07b4a93603c1e1f7ace0d655532e14f392502f6285c95bfdea1fd6391fa50e98528194c5b62f5a8892a6bce2e6b72334eacd0c18cb9b38e1a2c39c45310704b919812c38ff64bc65cb089c82d139ad74b627295f6cbfca1cc1a0a291651f0b1fe1359cfdd49e48247b1744553a91cae2e1ad7c43e644acbc395bf46a80c674b3ec367e8beccb07e3e46fa1cc9dc6232be73363094384613527b98f91249ff05de9c6432067f769a208b7684e2a3a315ed7fa962759b3a9b0a2aee20a5df6b94d751e4fd586ebaab3636e101e979a6c5c3c333ad2b69b0494b9b9c8977a09dcb14c6fd3ffc10147c6d6c5511ed844744bae0d2794fc0cc26c9abbabaa1860d3a7918486a63a76da4227f860e484c9a7f8ab6a6b8de51068d88a45d55c8fcc282d32dede5c7d3fa44ea3376e00ab82415f652ee89b8d6b63f29a99a7220d9b1bc86cf7f5a72652962be4101f78df90f01ede961bf2a3b55b5095879fadc3cd9459b453822912919cf4727b5f7eecf9e0d97512d6ea05b77fe9fc2bf689e994792b8f0a6dc5033d0be535e5884731157df69e6d206279f13757623dcdfcfa4a2686088c0b7eefcc46e66e25659b645c369db01bc52526d3cbcc7f992ef2edc745c5d22374a0e6c21eda44216a73674bbb5f2c77bbe720eb8131490388d658744362ab678cfdca8fddb14fa552d5a43c9f5b7e2b34eeb31c22fe3a08fbdbeb9ed143a3d549992e0393dae072bb1aa16a41a6eb44ebe924581a0eee540e3c37a41942c5976a66ee283c6334a0af456ef0765bc91e7ce083aeec11af18c0ffdc008402f6532f8699bf84565bdbf404fc2506149f021211853fd13970f339290692601287b0f961fc5cffaafe69944d462fb73cfbd5b980930da36d895466445fd9ed25f23ba93cd9debd8a75a6a4078d9aabcfcf9cfc615d57115ebeb50b11337c4da142e89480040aeb21e8de7d043539cc4c81671b237251595e19b3c8b5590cbfd745f1c72c842f54e52872437bfb69d806b90b99addd16e613719c60f94c8fbc8740e4f009d7fbfe00ba9c7f06ec0107e11673892a9d4bbaaf6eb873b0927e601b62dca27cce42cbcccf2d4729680829d37502a69600f79e011da0b1c3e2131f96106ce59a1c89c064437b22603266e8d3ec2ed5c1895115e12358b0b4b6f73a2150b132f2ebd40109a57ced729d5b216a206ca27f88299b7a0f9f9a27918898090f338d28465c818b2bbc8d317ec2d1273660b01ce842a29f7dd02664f6f7a719c9645f1ba9b48be0fb92e7a39a355b5219c9d756f749a12b173c0798156c0e81acd9cdf8aab2c5704d6386665d55dcd601f90167dce6e10eea37dce6575b5dddc28ba321deb36573c9587275f4861b78a63019860d15be5900ce6ac10f25c7441988778df74c381e3c6fe9e78e8857814bf8673d0ba874ad2065360779cde6c347dcaba653e94a062298ff616f4b77f159ef83be993e6be986b1fc57febede3d1a817bad36792440411d39fc697a1cd9f9e3f9b44c771c3770b25c31d176c93a2d10ee265df83410bb810a618405301e381e7f7cc9e92ef2a0d18cad371643c60aa6494998f1570e22f114d420f9116d765debea3af7950af556cdceb18faab030a6ab4809a22c9e07e070f52d2f390380d739bb0a4df022aeb7c71bd4da4f9601cbe53cbec19e183ffa99a16781fe773e4bf6cc96247edf4064bbad0e738ddf9644b90caf7ba1313aa7424efc6be5caa5eebd3570c7e54f96c4e5386f8c2110774c6f3ae97b69ef0d06d9b632152a7c1e917d63878189ab11eceeb0a0744beb4b48c502f7f78358fb305eeba073cb12f5f7dad7bc2b86b764ef8b496fc5cb3974e36b573c7437e73f8c6fbd690c4954ec868b2d86badc1027636b85edc9d565f847a9f941d98c8920bf805795f1c06ee310ae5306ef2ad1a8b1b0bb1c2af0e6bb974881d1fda78e1f7b92c304b07a41efc9cc1bcb1f56302f56cb6ddf097589af8dccaf9a74d749f28b04e3a2dc3a82d8953edeab817921ff5107d518c3a7a7ea5e02206ab197234a73b713015c32ced56f48d3461efa225369eabaaab2bf4b5a24d43075886da7624e88741d5638772156a281769a6499bfca3a8dcdf87a678811cfd58e143fed1c61449be0ffbc1fa6e5f0b4401934753b7adfc603a815a392305a2b9aa13a91c37f7b3b9450a05cfd8ddee0c38e9fc04ae4c1436be3f45ecdc76858d6544e3e11c449d96ae5434f36f24184e468bc8162eb0fa5c436a9a87c5dedac2a9c358a91b9b305f3e594b2aa7d7193845089eef8b52b91f3bc3778e3081358e275b842f44d9243dba04d0603bda7fc40a1df571b89fa1dacc5c8858b045ab6f9989483fcda838a892044ba5e53395a373b15e99591c34e49d1bf97ced5ab6853384c9ceec82324236634aeea3ca180209c8da168b370becd2aae8626d80f780982854d266a3f95e090a4af85b1b7af95a7cd2c7ce7a1e10511ac03bba36c400f75e7ec5322f4c50892ab3771968e08d899596e34d2b2804c33652c0336e30e638ed76891dff395b59150b53cc95f7dd3e2bb97ff5284072a506e02d1f8953b761904f3575503c29a217c8b84252c169125c817acabd90f747d0f466e244773691b6a69bcecdfd4290f4063d238fa43f9ddf2dfaa4cb750a417b0316ebba8a699ee93a3665731d38883036b9662ea32ad5044b26a5db193c0d55967ca4bf3df82f2029e44e8a69264e15e27e22befc324f18b5e9c44df9deee3cec1f8aa3ffc134c2df7ce23928754e92f93b718f84f1c3f31e7b1b92c50b16ecfbc0cea0f213a197cdbf7f719b5a9d674968918caed2f04aa0b20c4f1ddb9e41cfba6599a3192ebf57ac582cd35b47768db8e709f284f1faaf57f794c37cea31784b8989b2a9efef4e8bc5104c77ee5ac60de854d35b2dd0be8acc8b45583f0f9d3288b497c46088227f57c9869d56a6e7e65bb02685b35ad5fbed42f73b5d46968beaf22631ce1f042337436bcb4392765fafdbdd9e8550f845775566ff964c3306490a627807aed1328df3abb55aac01798e9c2cc7ef7dee537f221d10568bc1a203e2041f4baa4e9f8b5d9fd516bd68f572bc6648740d74496c7adea6d54d275dad39fdd739e2c61960796f02a57d72c7f2e21e599927086b93f2cf2e552a8e7b472f3a00bd3871f2ec2b660324e1f71e390efc4d86c1720c3106be2f7bf8c34f21ed0f74e207467a9f2ea7d8ff51ec2f87216d1d8b0c6527d2130b3c363090ea0808c5f0f33618588ed63ca9104ef09d19a9404fb0ccd42f3773c62d72cdd1be35c9444875af71d79ffa0dd5efceadeac4743605e8e12e8f17300d65a881b0408bf0255839a2ef6f71b143f7fc440a0c526699799272c8d2b41d2ad6f4d253ae9546fec2dd960fb30a500c4db68f6c03f00e40159e6de8b350b55cf410040d25cc219e7cf23b9ddb6e4cb3d772d9e2cd1ef16de36488e0d8aeb751f45a848f2ca8f9fcae0708bbc173f4acef032b3562d9199e2832b19d10ddee6d3d8e99a261643372975291b064033fa8e7af5edea37e88e0a44c4906bf0f930aa47c0720219c21358c22ecbfce0736d595591a52d6b99f322bb073b69d8bbcd5e2195d620636e14309ac052e7aaf2e4dd9fb917b7fc6ad0034c5dcf41edefc48ec7c18d6a65187bca1a7b73cd038250336e239b7fc455bc497cad83fe867d421bd4985cd4bd7d5b138ffe4f9157d4b7f19edcde1034cd2edd96241a444f94e1a6b68f7286c450d3d1b2e3f03893b5180983c827c4e23765047a889168b9c42998d175eb43953503bd07c7d132cbde9e02c3ca57e6f7a5b7bdce9f2eba23667546de0e03cc1e3e36b8ce0f272159985908ccf8cd9b3da3d6607eade09732f2069c623c5ef2ea8b90186b2ff17f862f4d2625d29942f55fed4a47e34bea54ea62372ef4b10b7e97c3741fd531e770703ae919d02170f6aa64df5ad1bea00348e2ef3e3b9d1883807610cb663b28df6f7df4bd662d241aa77876c37a4e0c1524a14b53ec7417f088e0856c9b36636690059e6c208d46974204083bfb88b199dc34c2347c1a9f6b8d57e561dbd7625006bceb74d58ca0df5a4e4e3d5a6a472b8085da79f3581d8eafe008c72393eaf264f2f5e4b3140b42853990c9747194cb8762c3d05241aed57086a1f9254db2035b45742977048214b3e37f6be863cf64e2ece7eec31c0232a627c54121d4fae00fa905bfe219ee33f0c9b6ad67d5a105725d200adf8aadbb7401e8a8d9bda901c62ebc400566498e368598804d4017458c95d31dc76361bfd52b507eb419ea14b942dae81d0d57bba141b5bba10e0cfe971d7759e5cc6bbf04bf377e5fea01bdbfb704a69a9eef7c6ef5967844a3f53552745733a0e959bd70f3142cbcb6c2ec796b96458423766e823291ff9ab29e0711630c5cf406dd3a0cb80f1f2a84ecf115443b59d5bb0f52ef9fb87ac39a67b0820307992cfbc72800ca8eeb0314ea5c13fa6961814355edf43c7089a64f9b6e919c3b7ecb36af4c6cb544857ed5806b40e5d4d818ae886220c20fa0c07cacae0fd5f3efdec6a29a8a52eb82a515bb3cdc990ea2c7ab3d298ba2d026e3bde22dbb4756f846c71bc234df273667f0bb86de5676109fc74ea3fb5268fc6bcda6d553747dadeb97db2dedefae7b076e6628f987b26e8d06b48f92303d2a537ac691955ff3e95b8251919fe2e1b9db56e2faeb8185602b023d265bed69559b1004e1a50b93c91178404c59c85cb28fe94ba97a304d675482da9519f70092bcc98a8f7cc0972d4d6bd2a07b3ecbf1a67b74bc1be31fe1c1d2c90602b15676b99fa9c3dc0e469451f8daf9c7dd22e417e84773d47455806083311a877bd978d4f8cde5feef2bedb08d0d71208873b392d3c65649257b4e67f252da82e54a1fc7d8eedd3f06a576e88b6ea2ef21acd80f0385174352f314ab1ca05c3f9e00121dbb5f3e64fe2790143787adb2cddbbf957d214b5e0feb075c6915dbd546ba70dbed08e320022fab00343c8c27203bfaaf649001c57586858d13f6bf92f2859708a597c496a3a613debc4323876c9150e9a316626801d43edef32b82ac57cd76d800993ecb61815485db417068ba97c935ff93cf60e1b0cc0d66d15114e575d9b459a2598d1802bc9481e6a0ead7c5d0170fd1a0d5fd5dd258c3c6c46e5a6664ea19e4d9846b894892344ddc8f1db9f4ca4d4708d874f0596d5131133dc80ee6c326f9e8538f8dd19c6402220a6c7503bfbf2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
