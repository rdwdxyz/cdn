<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eba2803c5df25f26c82cb43261a60fa4a882223b48446d273cc1508d27931b40a7d35c558f15fbbdee2530c30e4ed7936531c214900749c07dd87216d0e2bffb8e5a62161d22d89fae70934d409a6f0ed04817fc7af5bd8193c23f9af2404de1486d43505339049a9b72cd96d8daa3db04016096e15d08002c53f961cbab0cdb8cd250c0a5288ba0df0c210a5ff61776eca77cff35cc95bb40519c30798dcd346b42d40274576e222cbbade82cf13966f7d4be17f3bb832553e4feec3e04eb2e659c235aa643d9efb2de88fad157b105c7e1428fef5954609b768711b2e31b2f78826ca5f5a31cb19e481aef4c00e916baa13910dd1094e40cb2d4a9270a679c629002393f9a504de914fac172deb374755aeab5dfd185773371ec54d8d13b034c541558ccc40377d67883e0c6de1337a0d5c716851d58d154542d74dc66a59d54a769083a9653ec2b000cc6d0160822af6a22960b74a0b93bf159f88fba450a4be707b8acc21f5dd2d82a947cc11bde2e2d123b8804fc59a03589ad677098a793f59b76153cd341d5c8732dfaca0be8de598e9cc1d6d498fb1810a0e06b5d99e53baa071b777591d6f6182a24772ca3c619e81a25084427650fc722e39500037029dfcfeb3f4bcd67e60fad2fca9c63a7a171081875528525e34c77d6e4dae5afb858395829670bbff94ef84147085f863c622c09e57a7418164c7424535e240b032efa16493a540612dd0e9d94b902bf7596f1b4e6574168eed9259cf4aaacf6593908e77914e5412bf6f2e0c38a9544cd47db801c9c87bf488a81cf020baa8bb18eb2b08cc5867f7e87ad458e5bedb490996746c763180c00758690135dcee13a43a0a0570595f5d2cd323d88a3cb6a1cdc37615fa72ec7b84d3b56951341e5a9dc5d9adb045be8f49243eb321319c24d355d3bc8dc9c5a797c26d1022bd72992943158b98ab546806893b76598b4a2617515755ca9a2760f63134b9fb4d4d18cc3b10b7b9868fd0fe878b393fcae8ecfa4065e415da313e952a1da3935209e62a527ea9abb2d7873cc7376fd20fa21165136655336d947ef74308897a8174bace9a77c9f7d7ada25154007706260bf2e5b4d922020c6e82a3619deadbd66e4ef478b354d4a63ca9079891ec5da31af6b63cf02aa647504076124f71b0182f2a4ce06c5c3d548b443b0820c846284d6f3980187e7b0afbf964a414fc2003dc41c838d4452425971dfef56ec34c9a29c20e2e888f41415dc5f81de2c1e170f1876cd4f406468a384b17fdd41bbae7e2928523d6660ca7540e120d4af54b988bf71f29e417768513ad70ed46effe1f32eac5a39e96c494bb8869935e5e1eb18610c919984a2db37680f77ec42081abdf6404378ac8384f38c3818147cdcad509a2ff3842aa854115519818b5d90ce3acf3fe8095d13f1ee146866a54c1cb42483470ee65fe214cffce389c7bef1214d851e8d0d0e34f0cc54cc70bcca70dd2d12ed90ae72abedc32344832ae4b4ba166bdfb4a346eea4e6666bc55527807b27bcebd8a728c3107eb1598b77f1ad17d0b098d2a6467a130ee20ccde8db2d6d108a502e362d6e9d91cc6209ee44b7fa945220ed4cf2579e71c5ffa356a332580d579c04a0d6e072fdd892d9c31bb402c270ad6687023494e42b8da56a86a674a714752490535aaad20c703a330c2a4c1c95e84fe7bd97b4f5ecd24282ab484ef3faf1f8d82acd93d4c9cf77ae2259283f9b5f48ee920c84e587d6918964c6495071cff0e4caa457bdb40c7aacd8ac7e18e7a37727ab5a83c85a89de13ef92a3fc9404ea819b5792c5ccf051433c8531c17dca54dec8c22ec7a944a189a5a325c53f619007fa9243f048e05adc000fbc7b5c02684541f68fd009243384b70d2dd5ef917b01cbc57f71e0d6e77397daa49a355b9ec9b61f5373967af66e26acd37fc604685d2c34013ba23577bf0dd2624f89485b5c8987872f4d311667c9e2c52fffeb0cfb7107843cdbe71f141f7ddb03e19e4b701d4e04b07aae6d9e4a5ff43979f7812767cfd6f82a7ca190dba279691c52a05094282c3ff4f10df50c8c77fb70553da9a37dc02d0142e41e62aa0717d80d14b8cb0903e58ab5c99ba56a6b6d90b71644ce9376c0196a380298a636192e5694b61b23305ec1660c2c37b4eb44440f4cd15b9b6f5b7fe34bf384e095472f4faed9d49f36f088e05f808b45d87533a595ac01b250c7c1a46eca65d6c015d4e9fc41a70fccf4266cb93b57f602558b1a11a56c7ba3060279f463818f6e0aab6611a56afb629b3d99e903e819605bcd06c3bfa87333e5b28f0801ea06835fbd47540a88a465596cac04d3c47bf563b3230e0b928219673723f24ae40e283aff0d68ff00948b14df86e9aca7649da039e074544bb7fe0301823316a7e35070ff52a79e8b6d8615b9bbebaa3dccf7316a3e1148a9905b6cb6eb43e23f34135a4c4496715d6166053abd0bb8815566cfabd78c3d6332f53e058742da50ddbf04bc4539cafb90ab350b5c0a6a5145dad97b5fd0548d3d711560fd3681c4f54871f5ab57dcdfaf7b46de8b9af31637f140654023d215731162668236a47b62506a3e7ef664baf9e4f8ce6018e40e64f8fccd58a500eb085e735179f3f38cb579895fb35195ea616c11d5dd17663c4a7d0f1cbbd5787d12fa255b0d407b7e1e553a967661628e8ce2898c28695e1fc6bf1ea5976ffdd77ed30443db62feba4241e2c15588849332dcac0e11545432b6e48dd971f3dad42dedcaa334b921ed493f008ce5263ee023fe3027c161a139f296b1a488edb2aeb1073f3dc0c84a6343a2937388fc4109920f20adbde9b37061ea023b81a675e1df389c4a42f43bc592e3a1cd24411e98b00e1e0858cf8af59c0852f960bbc2ebcc5ab43033744cec3c023417173d9089c586f628e9088119ed39cf4af7502e17bb47bf3a387cd686816afe7243ac4b779b100e5085c65d93f6ae3d3ced488d02d25a88933f01506fa861bce6eb250e61214e858cd844a9b805c7bae51dc73c304038db4dc814f5c098fc7383d776a05a5505b9f061a1b4fd3d79233d00709e93c1944f9470f3424d74ed866febfdf336672920483adc43beec8da581ab07c06fb6fe2c508c7045fba079d5600b059d32cbc13abcbc9c7d9129eca0eba392708264dac56e6a1469427fc6c50090167771d790e69bf31bb6d025ea71c27fdebc4d66c8dd18219aa8b866a3cc5d2773e81cac03affda39d43017fbc54580fcba17801b0cc406a7897d6e0a58e1433faed281b1af4ac85337e69e05c08deb4c716efbce5853e7fc4a055a025481dd1c9023e1a0628d54d6e1385b7f7659dc54cc2ad1661327d1c237a638ef99600de721b293683be34ae1ca951db30f28ea48af4516ea37960f2fb8a3b4fccc8d817d3a89d8745090aba362f810c568cf025da18ad9c7ed3f9617e6f1afee20849487819d3f52e0075d17b051fb916d8f86f7c7e1418d4c0a30187a91add62c428eff3e9c22128a183499cedba9bd0cfbeebe2135fdcee30c7cea0d70f43b0675185863d9b3df5524f41e50ff25b3ee6a40bf5669502c32dc02ee068adc163531464579d95097fa165bcc9608e3ec75524af0333772e3a5abdc54a6def2f9fb601285ed14a41bc2d631bce2312e1f013e99d5d632d17a4e9a480cd807b96df876df623be4f0887869caea92c9088f1a7cffa0a8acaad1c422fa56e49968aa6c8c882bf03a43b9b33d8028bc22553fa7f9055394ea445f5ef9e05ebeb2d393d79bcb44f0a41823e9f0b9e3a4ed10ceeb61df74657e63eba328960dc1654aeb41c3a10ecad9b294bca32c7910ad920e708ae7d1578330ab83bce7488d9421447de6ea4a35787b39cc1aacf0d5905a202beb067642f60ad1c86d97c770411eff6a46cbf1c2ae4a6a4722757e97583aee50a56be440a2330868fcbd439628688c3004ee7fbffb95d3e73b3ca03684139b0438927576cb9610fd6c8f2033c89a2bf9595ebb04b39c48f551a54652a267f96bb39c3d2a97069d14d278a1d9dc6f63b1f6b2055befe51a66ad7427bc426880025921db63cfec131a4a639368998b55320b4a0f2112fb9d245e7c9c5054f5c17c41cdb60ae0ee6808ba3fbfa12ac4266b81327ae7be687e9b909ccf52215c48193a2866595c217a0f8314f276a3c89771e2208835a5134520d914aacb9478640c5ff2e8d9e3856e003b4b91e8fbada5d4a8d3a6eab541c5aa4333cc977c085db5a1a8d41ffa389f58a9587ea57071f59728dd89a9962847e92271fc2fa4d241dbb25791923024b5a7ef68daff3953f14c01744f5bc36d454029625a253f11bef0dd97da2116b0d80481433215015f501f7b9681cb9239c1372e3db863be8058b932bf800456d671d5fcfaf15eddea91982c112e3343dce03f75969f81a22b8d7418f16718872d441231d589af7451af2f4f83dffb887d6474ac4480a66adada26a1424dc3dd4ccb494ca211891b86b9569d63430c02f0e5f0ef2d16146ab2461e619ae6aecc5b762a3576e9f022aaf53bed58762e97706744dd3f4c761355cbea9f5fcb1b8ae235aae70459f5d1b89688d1a064b5d5805ec29712cdf676ebe3966c20bfbc737e929ec7c6f04f78d67f24dd16f20f146d17018100c64747f43d477d6dbea09909911a628a67373898cac57036450b73949e7f82eb3aecc05a2c0294891cdc496d43d9123f4394b84b505b8008f6a6b7ec5622079bb8edbce00d205cafed428b676d5255a1605ae91580619980c64d1e893d5322c6ece7e1d54679af1cee72fd1c27bbc86b0d8946b8184584520b26b2255c0fa38f633f55e4821f97c6df6b5cd83504a2031ee7a9f79d8fd0289acebf1cf79e368c7119896030328f3ae195ad9008c2f3966a492e7ddf6206e0653bf7860e9a17868efd5e927fcea53a1b6e013144c36483367c0dcca70880aea58ec381b1e7a49bb397e62302a8eae466f99a4c13362b03c6f8dd5b3efbd938fa77e154ca3f6e39a22cdd8bcec7b84e5306c018a98bbb0beb583aa5fc7b2379c792bb14adff4480c8747f7f8aaed52681703052f60b74dabbacbc590605d0de9cbb75d45cde74bddea94624f6318a225cfccdcc6d82421e4638bf76f33c853c58f7f011d4efbbbf301d357200b60cda48b68deed2e6fc3ea5cb33462f97115b4b3fdb0dc06e50e7f9699cf9e786ce73282e22d2d338069c0dd5133e6644da4c56d16437d364bdf89b6446711ccf4935044ed5b0a97632e1ca4e0f20961f88d410f4fe1026be355013fd24638dc2a691847d1556b717c1c517045ec00e89e377c314097668e93c56c283fa8913aa73a78c0d36905d62e4abeb23f022986a4c529db97c7bd651bddf62824d8cd6f8ddc2d646597627ffa18af7e8ef975073cfb58a4cf142fecff03c1e8fef9036f6bf77848484d48bbea70a237d011d22ae6d673574ce1d750dc962570f6c17ca4da791312df7e7a4d055c8a20b0e028d7b19175d85b414c22c5c43cf34416d4c558608a81192e5b829258724d597ad19343adcca9ea1947f0b536cc2b45ce28402909a5d1ccf85a39b548a49a24773b2cdb842422a9e508ada69122ce307ec348f30e2316494eb7a536d22fafcfc552f0a43e809df10402d9e970b14911f49b6faefa9d03dc23db19e41f11d9ca2b55f63b84ecdbb3a51ff2034831aa57188c3ae70ef1e07094041275e07c9853c54b6d8c577f8ead59ca8ee97cdf04721f54e0658159d058fce04246e042a668a33c3172523288471d69bac16439b2b91cbbab705d57aafd27734e52c4fc651b5bcc0e98c008ab12cd7bf3edc3f951791ba589de7628047c3ed47d862ff562af0b41ded382ad1cd8eb01ea5b217f56effc266ca73ef9792a7daf194610eada73db019da9e4a8dfeaf85e8934e6c2bb99082067f50549484692113150dc0ebc1effca4e3df58dd29c7fc47d19e88d1f7084e9783a0045e7043c842025499a9c65f84c7a2c38197923701cab31e10ea9f989fa441bb043d25d4779354b59dbc36c669388a6e0ac50a6fe312e1ac53bc69a889ad85c358889c4baef62977892d1dc68c80a825a455fa78d0ff28dfba3cefd6e0fead535ad939296ba3ef8a24cd04f25d2f228235eefff92bddb322753a5825f7a0d5ee67cebf9252d17976e4b814fcf083a8b8154eb1dd6957b8e2ac9b023405ee34c4bbeee1453dee98fb84850bea2dce66500b5b4d182090af9ea792acc0e89fc4f27ad51008d6a429f06990d56d08e9344d30a0ff4614631ad6e633bc5241d3977169f5cf630c68deaeb78c365210d070826e982dfc0aedbbd256e7f98561c12250333c549f59faa14f909811e1d7e35996fede9212fd02cc832c08039c44690ef9513c09ce1be62f988ed6338832e9a015245f913d4078e64c54bcf1031879f4554aa8afcf3bffe7b28ed9a05205aa6a46a41979f0a0ff97a22e9057826f41282acb9a17c18717286dee0cd209b975f6f7ee0f3369593ad9c107e7be5c0ad811d3caed3f853720ecb4ba2a694cc0940577a6aea15392aa8b6ebd9c32d1404dd9a75ecd933eed7c3fe98eccd6175b535f3be5c41f595dc0c4399cebe4dbdcf434c71bb48a19b05b2f59cb4c37bd4c077d4a5d13c597d60fb7016bf3d4ec73265a6b3901ddf895dafa312022c01d00c970a1103044984b06ae5cf95e10f0759cb08414c0ffd4ad43608d3105fed434eaa4f53b2c7f62433bb9d2ba5aa44da10778d2e2a8dbf523ede4f3b030e313f9bd7b27649f945797d8a3c4cd5d1aa46ecf363ca7ece2913d7f1c481f4b29d4ba955137bacd0ee1c834acf37bc036bba70f33a7acf5ed7cb88166d511ebb8000eeb6dca2bb045112dec71e0d5b28d1c499a0e06e06cacf03121c1c3a2cfaea08f2fac7b86153625503ed7e2329abb57828f56cfb2d601a9c395b972598f01e4c5d1c4c3fecbca3b61efaa5dea9d6d6a5fa70bd80ff3d8fb6997ff0e13b81c5007352a874917d87a384c60123673a9b83635406b132de8ed67f69fd080f555056e70c1071fac473fff18589585b68655cfd5d643019a8d2a270f0fee02d13991076274be40ce34e2337647f1f6d0b112d8598491bb2e08671db324675defda3c4727a1f9b6b7f03d44dcf4c6535462951d628a310f62950f2a10785db9eff8b92c286d03e58cdb755b0e01c3f3ce4c84233a32199d69a46625326a127a3794f3d55a28acc2643df0ffa00b2ebb835d5af2900f158a3cc21798d25c39d5baa0182f109d1d60697b6153da402ef76480e24104ee62a144bed1af2741b735203eb8865563eb568d2eb9960a758ab3ee087d8e04264af8655266fe716e8a0ec3ad86fb351ff799a9ca1cc6dd934fe9f84e9f42895bd880ab74270006b834fd5b34650d800360db10986035853eb8fba4e993c464d31e4955421509badba46742aad36f6e81f307677997e5b1cf173d18d4edadfb2fa4f45c1eb70fa16cb46af03e3ef0114c41e5c615c538927c14bdf83eb76d55c92a4730b0ed43d89ad5191ffb7d32346ef09d12a95154b2ec235018dd18d7538dc730ed46a3a6739904c8ce0e54d4ee0bc1cda83b89ac19223d0e0560e8b0588d2f66f0ab47d82319ab5a6eac460d84606d8276edcef28a6d33d4407783f44be728ff5abfa32a25fc78dc68d97f9e5bf91890d0e2b13457a2f34a1040678f01ef8e88bd3ccb2323c80621fc50684c109dcf616537621b1d817cb91c4bb48cef8c83a6ae8cca3854c8af2111e3707982c3954cd2c0aae9119c47deedffeafb5d27a739dd4ef8980ca6812d342ee8a1f7d14a6e3c44cb753c14fc8ff5f50f29e575ed3b34627069ce5a4b4fb8e7a5157d12214fa9c107ec7546aaa3fceaa382dd2cab342e0a1293a52bcba6cd98efade4b0a2db8cadc729e582f45be1b48a6847626fa2e43b1714c82e6272e1bef659d773f85a65167205d7415aef6ec522cbcd25483fc0097a0b298590597e43cae1f23245c92b7a28509c33612b5f63c01a364b0b6c366ed0146a3a8112d5689ee25391a25b72098712203d1e4e638c43c517250895435755fae47a8f5b23ee59e21b519e0667ae968df4531062afd418750865f875d5f334b42480256ad74720fc79aaf329fe31851c68d5df25b75ad261cfd642278c773b9d1996fc178ad4b85ce39629b47a3cbf342f2ab56fae87d1fce7ff293c9c0e64b818b1520a825c25e3402ab23641382c90d67dc713ee4ed0c455590f00b7c5ba522e390176d7f8d95a02f63aa8699bb54d5ad1e42a9e60aa5de0508c3f316c074bafcfe1adf88caec68ee9705362a0579c6df9943c73480d52b729c80d590fffb9d80c4d962515daea8307f24734881857f5a0d4d397dece7f874fcca9a3019cc9c3469cf5eeb551716fe10481301ed86b01b8ec1bf7221406fb2a8cf1b51410814d57751a567453dfd9d837dd64da68e8365a793ab04834be940fa66427c02e1e033cae8b21b6702591c67d6e9e83afd9ece9a54b11f05f4a9112552137474a3c273e9012e24b573713e4df45e455a7fbef861e91f8b7ef5e55f0e9e99e6070f533192ebb0127df073c09ae3ddfbde18be3625a0874e067427fbb64933eb111cbf9c78835cb90c912812bfc2cda60eecca1d8f1339fa23f9dd9f5c5663112ee7805f15eec59076801dc70044e087075037470d6c5a6ac69d8e204f87100230217ed57d01bd5b34fca3fdec9185c84ff3d758e9af8419a8cd408839724b404e69da6f25ab27be0212088b304239568c4d2a250d0f8559338094ba3dc30f6d1d608a175b555ffb131dcc217eeaab2fe50e8af1ecaba98748dc925f15bdc28666c86357114eb3199f4601f60f76c7f7dbe81b939e9cbd1ab11377e33d518e9d2c81e99147737b61f5ce159a16a3fec1a6caf5c2f800153a0728256d309082ff95f886cb8662306e82407c4e487572aee4c2e2f20c8d09a8fbaae6d42a90e3116b8a79494317238489c229a27030a0765c958556819ace9270fed22087ed5ecbe9389b2af735d740a98745bfa45f0cc1087c1497622328eabe75750bbe50eaa7c4d6c2507b7ddba5a55c67ecfcefe13f2587a60de69d11fb29a20b1ed3b09ca77ee3a0d12724fb469f28f9f8850c7d24410ef26804eeae2a54672c46ff03ac33f7f2e6156cb87d851d0e6c615e0f860d4f04f0efb0de0c82db579c8543cd3edfc9793c73458163d14301d7e892c752343119de12645b28cc82ea458fe61e6b23ec852cdd096f583b9d43f8b6aabe401539340e69fd3d6272b5f99cbef472e189f2cbc030b9cbb6adc7fe896a72d46b0d787d63d5f2d3c0b6edf2349d5b1b30128bede7a2cb001ee893d2d2ebe1ed2cfee8b3e1758b626acdf5e019c1eb01e1241e6ea288827f300309b60466c7b39791401698581a4125f362e6ad7d5e2ea6b85c93f75170992ac1140f05c8de2a18a84e9d5899bfea146a3c48115ef84843bc3fee49e63eea06b31762d16af119c05008022c144aa7685ca3849b0b0fc5c49c015cc114e01e0bdb485a196c161f150e99d23ada5a4abd347f050b532865195ab46ded6fdb4f9ce4d4f25b17403f84fca38decb16b6d4f53e02c68551ec058dc385d1c1a970fe7c14735a1ede7aa6ddf8d8e330b44ba787b3ffd201a749872669b60d03e7073e87e682dc8737e6d597ae969920bd96431aadbf13b521bc3b864d34e0ded7b93f47eafceb7516278064b5a00715c51b5ed3e5dce5aabf6409c5e9b2bc0b6aa746181e14ab6636d6dc484506a2ce6dfe2644b6e7a095f4a885d121308efd09fe6d11069246841347e2071cede77569d654d07e98777174a37a1af3fc4581e7acfbc07e0d4de491ce46af1b460bd5b5ce081e80faf131bd52af8e2bfede9b697a41af176fbb6261712601b7dfeddf165a0c0a4ee4a5afc4b22bb1cac95cf2408c86186d07bad24527c0da602d5f27eee6ce2d8744d6cda905a55dca895f8c277c4b8ebaa17697c7594dab02ec419afdd821b187408d7334603471af4b4d88799ba67611761d495accb5f1b1e2f48428fef1cd236e32a35a1d62efe060c91aa3165401502f1e3f4c00b2315e99b16df5c05227ade91e92bc9999e171a31c22edbcc58baf4b44ccd6b19540b7e3a477a9dd42403b0278bb824b60eacbd35356425faedd1e8ee7c62f976bf8e49a2ea461acd93a4ea01a7a11ab037b618c39b2b78d48c32309571189b7c816df77259bab2fec50502a5464361d0864af270746fcf05139840ae34dcfa0bf6a81355b87d89f320f1c2812de7b8f5c8caad31649b35007df67fc8c915ed441aeaea0c7e9c5cab3d0f03b54af4f1fa60da0b4a192d7888144e6cf41091c97b8550d5091b91fc3bcfce923a812244c6ef574b1110ff82376306883e0f1c9687d6ad488546861d406d9a1f494a67f6aa92802b9f20474747acb3f801951bcda029b72e016e843a330b66da4cdd987db8cc46520c1994512091764aa87e5d791dd42413f9599805b75c9200aebd7cf5f24c537fc69fd8c640932f0cf921d872a1611229d48e85bcc9a81e5d8009d6dd76db19c16ad2ba39bfb64d271ae043b546cae6412ff63840fff23104476063483a78e34a0847a89b0bfd894c613aad44f671dd5572006f3cc7d3d6e30636bd3fc4e0f49d46441be3064d00604e8c84eb63fa5431deb5fd68121c34533bb3f3ce8077b4260d90926e63f7981c81cf100983dac1acb6a66269ffa9c3326ddbcc5ac29f49d1f58665e8fe02515e65f5edc6aa7c0ce5a93ed9ffb176041645e1f27626abc71652a56e115a47d9511b2e405c9b84fdd963da398713e27ba9d5bccd354166edf544b38ef2da668dd4014f4c34b031950f006c86dbe798bcbbe9a4d19c1432a428ad1f333692249dc4f0e608158a0d1e4eb1466150d805c99a91726b5d49dca6158a77a503c16e55d181958ce7cb11b4b77d486412a393d9ec92159dd239a0a3e9ed74ead47386cecfca6cc34f68d5e7101de52781ef206753336f12d2a071f51f36f40d280382c79f826a3a748c46dc4acf3282d68e1f2a104ddc5f77125e18f7de4c0ecc7e65df31ba3fd23e7687f9ee24fec151d3375987f70512d951663a73eea06920a32568370c844801669c237cc4cc3544c89c8d2573c9acd8ad7f1c32d32c2f8884efb0b1cb47f11d6be256d88d21d29ba03e2976ad4b28b185e21f9ad2a3382e0a1d182a581375c5a3e4af15bf68fbfb75692e7832db1abf1b429df5822f61f022b8d913978c45ee51b9fa1314912e90c6670220846704dc1a484c8eaad4cd416b0180d4920375c9045e078d5f0684c65579eeeb7ddfe2823c52fc91dddafaa4a59dc1a4627589c58e2801868a3446c58c43d71b4124923df30c2aa479849a8e1df5b86a3e0c5364b27e737814c82e05797fb1c63d73e412d27283ac1b2df7fd1ac92ce052c17e24f2d08b658276e104aa8ebd1db9091bdfec28c784cc541ae1fba4cf76aed8a8b1e95b34e04bb6d04a3cc1de7ccb85dda1a99c84aab31184793c120d16623747dc3ea76b96b5977519911090018a7ee36418b2f9d1afd5cf781daff3d0d25ee1077fefef72321001cb5db9fed59905f934ab0245dc00e6408ea0cad8ae573d6545d707f3a7ec9637760ddab6b4aa2ab171c036d42e7360ed258bbdc4d7147b12df4373fbb49dabc55a988fe4f3641c194c7fd2fdd1e1034241fda5f9fb529c3b4dad8d33f6c3521a715239ccb4b1a24f63438536f01a9663b4df2ece402c7639a2f773117a972da0760a2d2d6bef3b3b8506644bc65bb4acd71bc8735b2db1fa9fb8acad291e34ff4e4a59e808dffb35b379c891d007ff7db029d302159020ebfde8e89d83fb4f381bd166553696ff76359b2e6d65f03463885670abf707b1c47a2d11a0c397cd9db04b47eddc29992ffc353a069d9dfd30942e7f8b85dce068ebe2ed86a7d177830792125b3dbe7c9c6ab0583c227878d166c0d71a7891c2b3c0a00d50ef6d0756b8a89cdfcebd9367993fc5f669bd0786205639d857da0aded7176f28a2cc1eeea21520002fb56a9095579748333f6a0a03f538188677fe58be67c3bade1eb897d468cd8f6d47d5fdcf7a2037de2db39c90962de18179ab5ec006857075e4552a4b4cface8d752f6cad68371fc1ecc87ec5ab8e532732779dc85971967590081abf52db1bee83d613138c886ae04ec654538bc870d1ab6a6baa328ccc1a252471aa8e8d371185c219328dd0041faee1f8eda3fa1b7b073253c630b62c62a79ed689e4d913f20773d0454e016af7f17209873d12272aadc7d5db691b1dfc971d78586ce732571532471271e83dd1e5f637fec2b86ecc39838b33602c073873676d834e4523220e6c84de4c8dec27d116a082c28b8c9d082e06145f137989a274b860318ba55a062c49f0b5aa181a32f8d5a60ef862f8b108fba5493a6da0224500bcf343a0b966d120745bb2040c1c05e5ff36ad4b5f38485683113118f2740bf31cb48161e7d115645bdcb6a7d06e0d59c64bc01a13e2d2707fdc666179285ef2b697d22a40460de94eb2672c15636d8da4b4a355865b63ceb7cd3ce607cbfcfe098e448346a22ff9e40504f30e340ae5fcc77714c9115fa774230c23c602aa1c6386d03736eb80314e169debc472944d5f2c964a6c3d84a68bf7f5e11c79d930640284fe20034168277ad53aa2022c38351ffaf8b2e51cd3bea29251f66cf6f37851a49dcb3de2682f1ccc6dab4c9401e89598829738de1dba184cf530c2e9a308d671abd2a2e961ec2564bb68efadca6d929f4699c7b371ecb1e29cf599460fa3d299dd3876edea2f3b3b2889ab110c7dfcae8d5c48692035ffa84aff51d9f3404e6d58d27a25d6df073d2a9ec7ad5d9351883bf4ab976e86a62cc73ecc3121f34b2eaa7a3f489b41de3d754311f7c5a0a4db402528f9ca8700ce67c16518d834ed8b81c46bdac523630957ae3a316abc17dd720d4e4bcbb6ddfd7dc2212b2ce469cb951ec91f8d25e254333ae587735e45b77559faad4a20356c5ed2ef7c77ff30e8a8ddc06ae11eeef2af1fbf979c4bebd93057304127d3da7763b10b8dcb7e44d918e27ef7be44a863163eb6726bd2e6f98ba8112253bd707e32f9f67582317a9c07f8b51338ca880cedaceefcc99797d80efa7cb4d8c0b4944f68969b715a9daabdabc77780abb08ee5abc2b9a082e24ea75a0e64d6f23bddb96ef8564ba0c991d2b723edbb00bb17a502035f4f567b4a6af935087126fb6a3d5341922a0d02b4c53496147750ccc48e640de39d808a56a19af18e30d756377baa156b2d62f35104f84de3a24b2b133c42d8f3f9725f1997c7ea096c3f2f0b06b3fc79ca1670a3019809d23965296bbba8d84e0385cea34c9f7815377cd285e673155ac9828e63545155a3606ebd3cbda0f2379d8d4df1c926b5d0209e41538ac6dbb94f810b1517a1605bf88f3d239d86f6218131d69240790c37f55a9dedc5a7a81a2ed9167e0af8a887caaf2c946b4bdd8b819402dc9261e65243f28c56ecceaeeecca8d5f9170d6762d900ab767ea3396fb34fe9422fa2886d41d5e89cceaea26dbef037c908c6c5c0ab07dbb263e81f16a0bd3bd51d05536c20dbfc862fd85fe6e51f23a7c082a7dbaf9db56f90ef36cef0d8ec4e70e6dc24873671350342a7defa010bb09655d44229821d04d6f4a8ab3670d4b315400237dcd2b52ec9bf86b8ff6336dc65a371c04b39b0574ecb207bbec79cb3cae5c1a79f585c6255bb05e9a0a8a0989161e2cfa554c560a5a3d8ea715843135617176a641df834e450f01393a404d829df557be70f5c77a20b022992188ed5a1dc836539e83445e116001e33af9b331275bc0812463a053a3e75ddf27913e40137f7404cd0c8e7a1aa4ecd56440cdf8b695702a011a5fb036ec8b0d97fbd748960deed3a521bf4c43f67ed155618bcbfd41539d6a44590825f3ef47f112ff4e8fb2e194cdbe6ba41fe3889d1c945cad17ffb16dd3d6d70b9a1f403ebe5a670bbb26af1edd27135543c5fcf65540800f0cade048f79f457b3107a2201169c80cda97510bc553fdb17be561751baab7b49145ebd73f17ae21e2a69beef9a8bc741d8aea582673cc031e94de7686c21d38f2e3a14038c3c8db1b68dddc7f8b2e6b1ce02d46f96616e7be178637860acdf873925ea2f3dd1c52b43d6c22a77c29775ebcb564630c9fd9babafcab0234384e2fbe33c495319d9cb55a3167d722b08cd3b439a3204e395f821ca788bf224445e03af069430050d555e31ad643c2305be68b301d9af0e2d9a281c9cc0e8be9684d609fd5419ec47ce6cdb2624e3fd39bcd7851a8371df346aec93d469dddf311c15398d17e5e4330adececeb44bcbd22aa4af4a26e0b234431a632226992e12196b107c6d31e0cc75bc3a262ba4241a754c02c5f0b82afb3289e0f23b0b8b436a49894bb11cd10c71b82791c6c0f10b5579496318628845f463c0107a2b8250f2a6e8d8c94c48e2d168728bd669cd3a329f4c76875125b4fc93ea3a24a4241e6aac509e47add25a6691f6e10bc64d0d0b04e292b0f7a7bb6ebbfeb7f16f05a53174f16e8b1a9a2eaf2c1236116fa745484f315601dd6b263ed6c69d8bdb411b902ef4c8664b81aa902c9e76d2a96d8f7a07a20807ca70d1c6f17ba4c5af1a61c19f8f8f6050084b444b95d8ffd70bcd6c4240043a7ca3c29ee1a60ba1bd1893ea82cf245b905d050ebf2847d660c093660a72ae8ea486b3bf3892a705a63ae35ecaece8178db1eb7d0833544e23c6a2668e5ce1c7507e91cefabd7d10d87b140759d685e0343988fc565f8570113645c069acfa20898b441a6a320d0f913bbd8e2a609a76db4db877cd3aaabf5702a24b7100d5027c274ddbc03d74c351880b2c6b4c10b67519ca0aa86d2cdc951343c688d21a583840d4fccea83de1205d0d2f06fd175306acfe43466f22393ca79a789c7ce3edbec998ec013f4e20f2aafa6d2da25a70992ea821bc6a0496ef61899b379009756d1e83a776c6c07eae29774b30dba5a02b444f87623b41b3028eed4a7285228e978a648793c6022d0587bdd4eea9925d290b12625a83ba4da78ff3141dedfd627fb3b38edb52490829f7f8ce9f1238e3704397ffcb5e8b8aac99f20e71988ac3d30c03ff633916989ec75b13d9d7d9a1ca9ce50ec7c8fccc685a69cedfb149ce50a946a57520d31433dbfd93c6ec3bc27f32d3b8a31601f26c50708b6683dbfcb354c60bcd30ef53967987f9287aa2f57a9be99c399144c17017d6a0676d0434e805492dee61cdfbf43e5847576f6d9522aecf729d672850e9909c75255aba2de6c859976f8598f30fb646c7f04f1eee2f50d23f135b3acc5f9fd6b23d1fae904dccb42f1fa69897e0802029c93eee7f631a799a8393ead934ae8b0e4b2be408f02439e5414f1bab70e8a13d88803eb5dd844c0a3c1307046a206a125f667e12f10ff7c2572da210471ccf1077f55589e17ca745d96b3f18dc2a4c2f6282ce45e3f66bc219caa07affb2cc524268fd4a21c54d9962844db9fcd7730f466ac02f45771003bccd9558824173c40ca74a6bfc17dc7208b0f88ee2bb992639778eb68c9ae2757fb1a8c529290f448e212ccc35cb640d5cc2802cd6ff0f8cdbb38f1e07f89173a2273a3d41ee1cfc6d3981ddf8ee80258cbfd6c92b0bf9811a6730d79d559e7729147c6265fb77514bb210f47262df131c344ce8cb089683d3a25394313a291d5350a6516bc36a7608a74772fc60646ebddda676b8bf6587178bad358a425104b9e0340a18e85e2f82bc149b5bb3de9232c742862f8c58e9f58438a63c84b8518d4034eac1c139d9d01c1a87db7dcac3ad1b71c246decee1d340247468f57160395c683470590ba128511561c24ffb9f05a724531980b497f8180d78ad8072f4421c980066abbdb1eaa26cc033bb6468bbb5ba79ed919936de1b80ea989a9c0ebc767d998cca253a93880e3bfeb9c2fdd0b35f58f86a0abb412129351e2c2be6062b9678d2c6f3154950f90c7e2c248a30726bd485f88d391ea753a8098df0286f0ecb0bb355edaf65c662b8e313c692ccc5761fe5105cb692ff1157647d7f4fd3494f3c278600e5003b9d9f8900d59b4622c5ab65fc0d328d8404c89f33b8a5e53c75f3a1878450666ac4a9a33cb6d88a92d20e0a5cdf11e8a29ac9876ff497f7d4f3e6066ad29d9570dbd59639d94ad6f1f01bba1c10a48518e0f31c738588fc75f8bdffa391fba0d69728f20e33f0ebb5bf04643fe0ed0f1f290b5c50ce318c1f9678a35c8ea36135c638825134ace15bae7b92bb4f6b7154b010186ac4117fa40842925716037996d915ceb759fb518a72a395243315286de82dab1afb40b23f380fc3fbbe7edc5320817fcb4f12863813a6e83fcce90aba2645add818de5b105a30af7cfc5462df94da456737744bc47dd6765e4611b5302894495987635a31fafccac56723bff878ac1626b1129312a2a2a98fb97aa2e1fd52afbd5c3af07eb2d93b77a12724077bbcc747b6ab69df2afac284722a61c2c167b8e7c49385442853081342e78942f6d515f4a440dc617a9db61e0ee219a65da89c6afdb816b8adbd5084266a4d7811fb70ad76120874149fa9fe9772829b2aca4c790dee58f07652ceb5d1710e8f5055161e0dc7fcf3eeda659957bd482290802ae6179c3540adb7814e551d45bb932471ba744b4b5f31be42b77fda9e1a67a3cabe2501993246189146487b9c9b9ec5287cec67a9ab84e36a7c9640e4f9cc3143932f778ee90b147174fc9769135578cffcfa6730a0fa72435924dce0c6872032bee18d452dc8199d232de92d2649a0770568c448541a35a2546757d3a38e8b7ee9e5945b8c627ccfca6c6eede720d29458d373739ff00553980d0d206537e3cd6f2cdf2c489ef30b0ac0037f0796c48c755e85a1395a103000cc60e6961f8a7095bcd4932f4e21c165723c032966591d12ff87304aa38a7736a218728ea21aa69b8a241ac97cf8a8c575fd33fb399e74629a58a754ad3cf224eead20b079174059da19004043a66185e37699a2cba47099764ade51b7cb36be8db93cdc1fcb80bf10e7e700982b803539d269416121e1943ebfe9fab3c10d3e62aa44f96a87699497b57b77cec44db1325c0408998a1924a90ac3c652911b03cf2be5b9f75d5b1ceaa66a43fa7cf01631600c2c5edee30b1076fdbeb268e7311a3a0f40e3eff2110ef2a9a89d05f485be6b1c099d6aed288f768b332411c9a87e3cb783a47f1719b619080f38c818c86606adf5bd85ce3a25352a7ee9d379bdbe23f877defb0db69beaa6a5beeac0281ac6d77579965bd937bfb21c08a90b35c1159e69aeefd9b5ecd386c0624e5e42a6a49ee0a065444de05be2f569ea68ee3070ed6499f722f12be5ee251cde644eacfa3c16b03dc8e2129e0a973f6c7cc5dcdcdb04b07ab8317274cf10a8b7e0cdd32ba3d013bd77ace61cc8d220c2a4fc86c5eaed932e1495a59eb16cc35c204ea96b4015c97356c739127562512769d81ae25513f85b8018a54e5ba595b04289c9a697367b29df900a6d20e4ef0fbf41ff612090d22e3e432ace62658de0e4b439aed7ab4a44d65881f79369c6b5fa6dbc2c72a6e6f578e5540a8aa50d40bdfcbe6384edd801faad041735dc5f2f877ebbf7e3eb851f9c8479aafe430fb0e535cfcf0393c1ae0b2ed0c55d3f3ef1d7c534c26a1239cd2b70285ec8802744f80035c375461d1fe4dd430b67376fab654aa75991c6e7d3f80020a89762c55cc75d863385ff86dd2a872faba422c6e0beca2f16212bd6f17e2ef226a7782baca8f6df81183839644e5de48647072008db9c1a5947c200dc25d2c808ee23593c5c7ea2b4c965a8408d2dfb10ff52f3ba68cefbfa140d8694e664bae43707fe7a05a491296792b23672b595076c36a6adda818243fb84c757d11c72f5b21b95ad1ec2cbaa2c749611f4ade55bebb8cd48894bb71e121bfef6ebe074e5902cecdb8ca5527b6efcecf06b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
