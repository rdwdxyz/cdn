<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"be55344deec4580eaa41d6db5c8cfca256f446f66cd4ed7dde40ed88f3e93cfbd526e3518f83d039450fe6da393ce72211b96afd8501a0304bd6bd78141be6c4fbc26a0dbe7d191b3e74e64c5f67420c153073eb9b8e66513ade56517aca403240a730be9990c6f56751d5910e798f8a5b4f0686fdb8aaf96b0779c4bcac89c7cae25ec21d711193a2555bf82d3aa553244cfef391e7030440af434a58af71fa65926947fe1fd0391de4d988c61ee39b5c7bd2757a054de767f1cf43dde553083d48674ea141a6a91ce6025127d617f8f6a301997c9e3efacbe201fabc5b38c1d9404096c77bd472b3ef3c4727ad5e5c97178c9c3d16967ed3f85198e2760714636f744588ac56bd09639dd46a51107a42bd47a1b01cb0b0d4e38967a9fb59f1bfab52460b9cd7ddd1d1912e751e51ff6dffe3a1405d8ad17254ed147aabed46a663c40090a7da7be8f333dd337f0b9036ec27fd8b0873abe0b5bafda39d84a92819558b86d7da0baa1acdf1e65188db6fa4a0a33c96d7ac264060ca5bbd504930582d9d4cc91f5dd948357d692dd7e2b1f7f1f2c924676f677f72b7568595a4feebf52cf41798ce1b402ff78517153da1869f6cdad9a8167b1345dbfcca9de5cf13245a89fbcfeada8d6a9057a94c6fb6118636a6b4c5f8233e44a03e9d3853ea05d07c3fee7eb0b0eebb3914ac04f732f979ef0846e71472f360cdc97672fcfce30ea5a1f6b60085f6c5489381f25fc85db274a4c7486d07bbb6c47d724720ee34f5e95557e0a74244dc4f8edd4885cb395e0eac92e2d4cb80e158a7231a479c6a0389b6063a1a42457a4d8dad866798ac2d9079927954248ed67526870993b16d71c48aadfd1a5b96c3dd9a6d610f4e43da16c46ff8dbd9ca30739c39d217e6b4a3c3e500610fcefc97eee21d563931a50b4da343ff9ee1de8308fff0acc32bbf861b97337f0d03708ca2a883578c65374a81cb6157c87f99636c8b8477cfc1bd85a0ede7d960abee41b4bf36f15a91a8d0495a2441e6dd88944479a87975600f45f92536a05940946e04a49267750ec3496a37d927cc3fdedba35863f4254a62acda2972e913fa139898c8d6efb17757ff468b94b14557181a6589be4e3a120e89b0118b2c705cd3cf8d158c4fd735b73058e5e107c7ba32c793784026af55469a159d6e1acd332e0fb8faf18ee9c3baa742daf5dd5bffa87809a27f27f8d466df313524a2a281558a55684503065a446ed8deedcb9d4b1d04fc21932302cbf8e2d487d4abe0f16f34cc6e71305a9fba0c4c27df4e9fb31af2805c3de03b17766487235e9c663cef99093d1098cb2523dbe8ed1d768c20edbe99ef26c8ed65767db11576352b1855566150f2a17648fce37e2ebaae586d061529a63ceb268e1033538f00b1bcac61c6e8ec46cc6eca7cc909723031c083a77fefe4202a05ac63fd23f9524bc3206be9b7c60ef81b9a8dc9341b47c1563754cf598caa6171512282ac8752821f00c75d067253d993f64ece8b94b647d532991036c58bb9a3ce6d47e9ffae591de95a8abbf2683ba6475414ad09ff38cfb3ac0fb6bc027f0590ee6562a0a4d9bd976ad2197a316a8d556155df508bb7d93ea1756c623494e101931755f5652aea1b221a427a95962da6518db6562b49ef3ae6533826e97c5f8ed930d8b47c7ccdb01be2da5169187128e13ff3d9b1e185f8aca39236720d7a4b0cc95a409c5d502cf3efa34c946a9e9cc35e3a7dbf8976c2d716e753e05588c2b0f75c5be00cbf07f4f07e6f7f381c72d1cb3c0d6f7a4cb48b61a476318b39df8ae14868df2d3664e812ac8f459aba7a23e46e3dcfc55a8c4ea2bc27f15179ae1569dbf416299c4c7803005904bb325d55ce48750a5a53d2bc710be1e5343a35c2c69b133a69c508ab23e4202f29aaf3a63f87dc07b56ef4e33bfa12344086e10448f9688a8bb4418b5e3569f53bf3f0873361c77bdd0c28de169af119220a1e14161d4ce4e7fb8d244debb2be07735725a31e06f3d913595590473d341c5015260121c28cbf614c9002ba4db25106bea3e5458ffd7e43b883f084d4a2ce1a21d1b271a790b23efcfaf5c19358a6fd7b474ade8b620ff13e5d5aab06b14f6b924bebfd7451c641e111e32aea457c49a7faa2e269d995f695248d98f58b795c34c72057f9d7b49723824b56dd9b72b8d84a08daae309100e88eb5d45ef451a755a1feafecf5bb2acaa01c982f05ec95043ff005e40810352cae7e78edf3e3fba06e888f2e4fea456b8d8ba61fdffb847e58855d85c3c2251350b8888af30af8276c5f98ea22af960edec82ee1ce5d5e6f1058e50c057a8f0ce646bab4b5d5d5499d7470cc40188d4e0a3e4cf2c900f6e40c067666e53033b0118fb5b066d16e0d2a492e340daf7040987967310e0975ea95deb9cf46a1b6e2fb637f679d8ceedbd5a1e3bc3029028531013f2a8ab2a77c498ead7f79f1103ae23840cb34d294e4846f89d5c25c18710e1cc04634b36ecd70ee39723f79228bd07849172d65c5b53b628cd1cee5b11944e2c2f4bca1af114e83d0d3016f5924d04699c5b3b23f972cfd42aedf10bcc0e4652d627365c774cad5e8c4c3d628d009c7d67648ca4ea898f78b7f3703203e5404c95e51787725b42435ea4b495fac59bed80a06aba08ee81fff54264eb336b1f6b9186d92346218cadcfbd9cde443d5c5a68bfea50e6ae42e5777ed09b921a39a9b8aa76772ca0b20d830da37179eb833d05dc7291dcbbc132614da64cc7b8547f489819dacbfc47aedcdbd959fea0cc22dcdc4ae63a6d289758b741549cde84a15b9a042e4084123859b7fe8b65f7736dfd87e41f1c61ebf3199a0aa32dd7f96884cafe022c7e7631d65bff5c22af701955a9e5b2c58ae705e6c94b5b68e11d3d94d77613b00eec7ff34b74e04317c4e467eeb489e59d0b4e6dcafcc4455647bf0237abae2e43e5ca796bba58b94858dce8514831f6fb82a4e15c8ca38d1bad699a9fcf59425d88836dcf99fb335df0ab270f4ee4a9b9f0af03420807f42a39cabe385de20396a43b92756bafe1cf8885acf3d81fdb46a16acd54b90c525bec6cf116ef368e836a8e163b2a3ca11eda5b9a684de1c4bad6564c8626b9ac231ffd5d5b3b6bc72a411858ac773ee022595599b79c500d63f29f7f26012d4fd6a81ee83198a58117ca758d65301ebfa4623cc2a171eb89a7163bf3ce5a2ad61784f54a11862847543f96a5c2c24d554a7963e92df97873e19463d435b355632f656125b936790f2f71f7634675929059b520068b028371e5d5bd9166957cc27eef5528537a2e906d73a6538b472c0fe04734b9811bea2dd67f71ebd639796f23a44f0a5631cda16de08f59b5ac2b2a10d0419f017adcb05f6eabd3a81b15a7aca1f6ed6091fa4ddb3f312787abb18bf9a9010c61f5111aa73fca68faea0da8506710a79573b40d9e3b2308936682e3e99a67aa03a3d9d01140bfdc000bc8b4c7e52509cba04fad8d9c9503e1fe8616e0ec4bb8f5e74f18ec3dfb8e6d6395a13a775594ae5701d85a77738c09846e8a300f5eac15e5c123dceea0e53a9f30b21dd393214f97f8cd298b55ac21f720e1e1c2beec5fda6c528148dad16846656131f4e9d2b86c4493df059bcdce19f383716ca529534ad28e55fea59c09bd93e8b3a952b4fa0b7173d9b08047e85be707b4646fb23cab1604a6402b24f883dd04a43c992091234349fd29b0e5cd330d75edf139fb862960d50ea5b0534230d426058a6b9c7403b598c8a211352b6eba15f250f2141e9a8afc68c60ea215fc2d9716d476b200e23a06833750392097ef57163c652fd89a2e14b42f277b654cb8cf83e40ab32556764f83dcc469cb9c663d89105f3b5ad3105330268dc15b690d7cc443b2fbc573f452c1136848507c2b6d43018c58a2568914e0824e0c0a49352c37d4f93401486bf894d7de7fde3c68728aed63501c5fd1a72874b82a62a2d4be3c5bd92d0681873f47ff291de048e1fb6a3768e4292f2b444d344cd068e0bedde62e5acae5b6a222a2f4dbb66810096babb7af66fca72b9f3345d8a144a0e56e1928d9a99d67095e2a179ade046039ea7a96766e96a28a03f8fac551e377eb8c9016856d4100c0fe332d1c9c2f5011e41110cc1cd9ffa4f257e966bea6d925fb7348940105a3c0bac96b41201d89c12eda8927c892173601109e02c6988569f39e59d35fd94d8603a35e55a90ab503d402b31c0d3b3ddd36e246a4871ff7a5f47d1ac4714d3bab790c39f1091f1eed98c22529a103bb726172df9a159562f70e8a599b8cfb274502d8a7a789f261a166ebe11f68397aa03de181d8a35ac3e2821d1f9f7cf5a7a98806611cd93b7f4ac8dc466a71f643389c41cebf23af7760b2f49a06433b1e2a5f4bbd4f9faf205c659931d4af74f0d3db9192279bd611239df905c671132f7c5f2da63f283f70e8493d7bc66570f9c925a7609b7d2aef18f473f28020f5f2695360b5ed5919302ed0acb02ff7c2a5cc7749a8d2577254bb6a1c1b5904bc730a6302dc977131feb76e98a8674f301f544a6fb3f0b37502af09de0188fc725218aa7646e6c1cb486494fafa77760dcb2b9959ede03206152d31012a5a877ac65786c957c631c8f5f6420089390188b6e0660a8180311256b9deff6fa2129ea660aebae385afe46c62aea29a2fff3b68e4006c09f4c5c10c4b631b05d35e32eabd8ecd22b543fc5f79cb98e463f2c911837565237ac210483a6fceb9de9f3c1dad5ca6400b6d91749420e5bd070a3cd6cae2c01e61d015824e45b36ce7fe26cc27f8ed3b6e52989dea1913823bd33aa10b455fb499c03561dc52a048c7aa5be32ea38a1d116b33f544262aa074d19b30eea93c53eab334fe175020e9882aabce94cd78bb5d2d8c0fdc4ca38082544278494f0b3b38f41087d834b0e5fbad49c97b2dc370d1c866e450446e4c5d4b8dbfefcaa532f85dea53da8700e29f7ec47e29c3ba47f262892ecdaf8fde9aef4480caf3c085877fcfa44484dd8f80b4ec39d8e4295d8f87136479e8e67baf51fcd1713a674a6d39a0b121eecabfe23eece69991a6f9917537857efbe4e0dca8d860ebd129c627ab2da024c05190e12edc21dc797adaf313803e0614b5118aff4fecc66fad577f6e2a0de7c3109354c27812491d7aca9aeb6a4575e5b28e5d5c21d68facc9ac08e37cf159ff9ca09029c6aea830f8d3fdec70d37feb2cd8721ad29ed0c5a304b47968ede4b79da8224d3520cfbc628cfaa78b838e38b123b183a2c30ea1c5c8248093af4b8deaebda5e9f9544c76a37c3212f1ccd5a5bb1d7b4abbfb29489001cca841e5525247473dd4d1a48e944975bfe7b41029c8b14ccd7402ed9c698e3fd1aa1999e08100f5ce69219f16b3da1ea74337e548c2b579e0c0ada2c0230c0a5fc0cdb726fcbb1e9dff4f61c760bcad07bc614d6592fec86cfe48cb7f54b8d2ec3adcc3388e6992b9e3f51614fb75c9b666f807d97056ed2170267cb609b2390ae89e9ada7380a5c5570d698ffea1d22f294da89db17c1d118683aeb9adf0cd91565680a02ec050242aac78ea44f7d0dae2ba69c07b599eaedfa7945c2ac937e078863302940cb81e42914513b1b92943f0c1bc62e809ec7a270b27135c2ed80eb294301d552758be97b70532d69d43f2fe60cb1a20d77e4ab706546a26243c4660fbbb0549e250bf020d242fb1019abeb2c6d72a9b4c262b77ac0ecf19e704f3f0230aeced93564501d1d8860a48f2f6be7ee0781ca0111183c0921fef525ac66a48d1e9e586ef64c35bdf3a5514edf00b4bf7ac5e62aaecda4cab278035ed672f7c9c2be8673be6eeb5c650c9909e26e3b0e6f285df47c384799787105af9e7d60240c3cc346c524f9b7065b721997447452a97885cd128aabec2d9138cfb0d47e62b351d0b0f070f1a62d0e74d79771d1c9da5457f1e1ef83ec7f28e4fede0271e9696a88cb390e77f35fe5909a679d61956e3cf7ca8bad36b2191f05d90aadd0ec6fa74802360c4fb96b0dc971d8569b26d2e5cfe9443e6b0520e018eabcd671be1d6af339139051a1eda9b8378429f069996d6429fbe6202c1fe05fbbfae2da2223ceb18702159d8a8944147d56436085cace82910682e7884636756e6d8f416c19d185679f9025efbab068dea12fb58de2a3fd5a617e8723a584cc7a9aa1c23942dfe70741db39b17dd8dbe53a8366b726896b62e421210b74395ffadd6d5a8d0d0b9823cbada69137a7c964459d6bd62a5e05ce49356763f24f2c1aec4f598ca617bfabbe973cbc849bf6095260fc890a134077400cb9fb4660810bfef03675e8431d4caefc58839467ce8893fad425a86779df1ded7596c074e2ac9623e605e5d9ecc05a0bfaf9d03582d2b8d18af3202286235218ea58b33463bdb8a954b622c0013a6c0e4afaf2609335d37182d08b4b1bc13d6f66c8184579b61cfdec7352d62d498782c8bd44b34cbe91d31b55876f6dff98c553e9eba702fc9259bc77e6fef9b8b57171e17d7f3850afefdadc14b4949b6237742744b2eafcd9248f8a7d35f0b604a1b6a5b6f53996e60bc46ef0bbdaf447f6b47eb7cbcb1d40c50471b2186b6077720782d75fe5764a37893052cfc4f120686572625c70345e2e8b1baa66a91b14976ec39f0eb718b7c602da06a8fda11c39090368f64a081193294c9400a8548a58ffe20b396442a2f1d420704bb80cf60925d0d6bb4f7d2eea6941540c0146cafdf926b9b9212817b3b0284000296fb7e21650cf582590d89e47f8b96148ca86ec15ec2eabff243036676076ee5d398b4751d37ec85ae59ce3605883c526833d85133ac5d4f569fbc5493358ed2b260711cf2545946b4e892bff930ef8d2956632832ad3e14b3e8fef55e248981be69455042a86068d514acf60fb654f6a6daf1f6e0fa73a6498dee37a5c9ecca3672f0255815f4eca8952c93cd55e3a64b04ea2b1b218f5a5b151bdb13c73cd94dcf026f1665379500f817d733d7a645613cd14fb9b0cada5cb3ddd175d303433b4f63722bc418fa73e16a546f9ee78b4bf03b479230270e168a4449fa0a51a7d5be9efd4f89d62e6e2416c1c7a5d811bcdf6af5aeb5b0802c63713b850187e2583c31a3487cac1704b520652c2dde2cb677e99c07510894e37705700b47fc4938b65b43d04f218da0202a2402856f958ce81e8fea5470189f4727dc70a8730f9bc8298593e077566615d102efa9c028061ade5638e9336d7c7fa9196b64b9250b971b12dfcff144052962d8febcab88dbf29d5acdec3c53632f1dbf34558e5f597f17f3ed77566793f88140a8b5a0d5c6bfdde7fb7900a6d632e7724ddde579b632f698d0f7ebaad6d23d325e61d2bd1f4d124e731efb7cecd51f004f52b01de16cc1941cd41ee765a3e1439c4893ead1ba37acb86841ccf34b5929e3053bdce33f936511abe1ff16ec833004826fa6169e6ba0486fd9180a1dd2084bac08ad3ab26bd0c1f8b958c5a7f345805a6c788298df87680087f0e82dd979dd451b4856674e4c699cf7837cc04f00c31c8daf5dbbdd08c99434318da9d5bd2818b0778c0e690b9f82879ad50a2dffb6f35a254826eb0fd9af1482d8e155edd6bfcbc9b6e5081ae31436b41724a8bd05f4babd92d49628a92df0073394a06b91ef3f71f13179e43cae08cbdb770369349026373683574e60ce20244dd708b62beaa55dc05f6b55bf26df451970674feb9ae604597de852f4429636a89b0b0c3062035a21bbd3aa80dccc8927c2795b8e92c0a4b6e57ca91000e55a4ae3aae42d3105c0da954c15722ddcd89c74bc7398a8cc9b3fdb664d98e9cfd1c598afa8c88f8f4a6c6d73666ad87972cb231b9588c0d84f2cbfd0498ead70ddbec7d5d1e6399735563731ad32f8dd19f07fdd4a3d66fb551cbe4106b5e2df33bade701b027ffbeae43c4a9c6875a6fed4be0f411b509008e29f759cd7e24f6f000f5fbde19a0796d24aa5eded68be49e7a32b752457a3caf385d34a34149b6f82b0314c48d3c540469e896938c91da64476fb728ac7e53ceb7f0aba75f1dbfb651312860ac42977d83aba5fc6a5a209ff1a08a6665b17d839169588ce45d4bafa93b55d84133ae45165ffe819047bcba415b944d6f33d7c3253e749e28137f63eb675938fcc1f9a0320166d87a595e2a2263030cdf9f45ea8d1e41990480b7263ad3baa4d2ef4902591e2a5b1838bb558be90dedf2e7d2a265177cd0f96e89d7b3a285077e3b4d9979b95b9981a32cbb59e3afe992319f874d4010a1aaa31bf30c53a665bcd94fc1a6c8d504cd44789a31c66f48befe12e881302f70bdf894562e6b5cf668ad0102ebda8abcbb741140a31a2ee62eef2223bea86d4fe9f8c5708d255a5410f5ff58b4fb668aabccae127b484badddc53c5426deb0dcd83b66098609d9ecfc0d909b5f96cc49728f3a86ee3abce73acdb7753583e0508622f59cdeba02a936175a3ad0927909ac334a649ef1f9dc5a1602dc583fe90554e96b04b8d455f88e2d8b386d8a97a0f880b72a8aaf5f4e27cdc37d24501281be739823c037423a8862dbd75074c862d5cd4cf9ae51c2d85362d00c0ce1b913106d1b89463778b457bea89a9075103ec4730f0340e49e9e658d238afc20fccf686e76fcbc2ee87c1a96ab3fac98defa62f1f90a259428b336696d396bdccd6d66f6171178de55bab3f0163ede1b20ababc18ec2ded184db76fa8bd5a296447537721649690e2c73b31774d0c9f63e77dee7e5fbe2f24652ea0d4e7717a7dcb87e1fff409b022d2b56ad1936d3ccd2a25eb32769e70fb30dfb7c343fac182d583a8872ccee4f6c0e0d73d44efc821c7ad5831df6e7da0d19e3ec9baf999c44cfe2b72e284d451c604f4d8c8bc74ff7c689fa88309b6c1ea89d372b879c76c361ea6be7c59e5b0a487c1d3b13edfab04c2adaff65d7f75f2e9ff7d57f10b6335bd5b8f698934601d9684cbe05b769241da202a8146d13a6241689b44619584c6302ebe33e6efff2767b375756256ab17f2a79c81da9409b4148edc735e386faa0cd2baa286950539978468582cc2f50235ad9e683425b570df196361291e326f141ee451733d0976921719412c923d117c349101c45b81842e1cf2b02f53c86ac2d7952c84622c1f13f3f33b2ad6f60601790afff351d17c5b3a7c90a26a80f6a32ff03d4109e837fdcc340c3aeb27b2698038462c31373921dab2891d049476149f5cabe0f600a30a6f55ebfdfc3a4d6f636351759f87b781fa386604a703c8d263f67e7cab2466f57c31d9231139477596fbf1b33dcf8d0fb778916ef181f73c17132a4e4fd5bcc2cefc9b27dd18ba3281f49c3303f1a1c81226c0ccf273d09312ad10887242f0980f7564182b7062661d994f7e0f2b7913ac5d1c540e9fcb3c89a2db229724de68350087efccb4978817736254b2665ad9c2eadc3617994fcefb351895ddbeffaa89df204ccfa7481506947da936bf993b253faca195f7c91dd27a59df1eb197328ba38b08c9928fcbd39f15aedffc4b0015cce4b89857db00a10fea314cbe50f98a5cbdfb89332576ad839c87ae6a886ea394c461027fd9b8a702092668f074cede9d5c7d9e968b3f065808ee057219704c3f7fd71927bef8ae90a41c4d34472033e61c4ddf9b316c7e215af837236d80f9543513be75b90267f7aad6053bc4f1d420a4a38e59d47ef8a3fcef27d36d743a1ac0ed894102d3bc3a6fd3fb12545052501341b6a5679b2d21973c80e4249c8fcc9f9293d0a39b37fffa504742e902c89161df429c61088bbfdec49cfb23846d2a60a4e2408746c987f959c6ae6a14335fdcce683036884957acd1d563db07ec047fae4b600b0ce0de1714666e5c89479e478215cda0ed3ff861dee8c8079f3095d87668a2b318bfc75f3610bceb9706f250c0c6ab963231df0823662d55313a18a03027e13eabde3feb59e52a917e09c7839fe8e5fed4c154c5a350106984768240329756383c8459c120cf2185cbf9b4007e1a5f242186facf5553738ca88f0a02d72e78e644c2ecb589a3cc0f80b275f826c01830d9a965820c9a5b4a66bd50159c8ede379fdfc640326d804410e23fe7b4ab360caabaead19f7ff3e6c93673c66924b6dd37600d51aab09ff2743421f6bcb9d83c7aa75dcdb9aecc800d2afbb43351ce0e6db4a93c56f1e94b00e0741964b6db3f2ecca4fc1b5f21f758918ace3f0a2b20777b2d7fbf930c21cf0a15f4a5f1fe98d94a98b85b6f1d35a3623fce79dc7527d265c50fa941792389145b0f4545a0ef6e6136fb73c52a8f88c78cbed24102d46e559457e1db02f6ee7a6f9e10d3c5051c6e94a50d72a79a0e5b93b61789bd5eee8ddd601fc63f92d8eaf44fe7df14f4a0c420a1371a2e674e3af0915a17170ca6b7f9d01407f5d1f056ae87c14de7547da19342532425a6a9d55f6a922cd603c98d04d202b4d19e376e11dd05485e54030e88e618587f1887d22407fcddc52aae3f24e9e0a61f2da20039b946f370cf15fd3fc48bb9f22bc54393a0113ab52b7bbca2a1d7c87236e71d568254cd9ed0abca5f67a0042e4fd2b3ba4ff592c2b87f377d15126cbbf743a3dd04d7aed8e4dcd49ace3ccbb3f195de87c782d292018c2702a73f3541dd2953ad42291cd0db03156c26c2a5086f532fa3ed188f6c111e5e953b566e0161fab014ce9ec6ec4611970d6a24bae1ff2d1b201af307607898cc01380a5a85d880534c53020c0014c314d0828d940b54460f466e0fa0fb7ed69359c034e9b80426b1cbddc784415cdbc3ecbe7116d9e6c7f8f0940a45e81bb8aa9c94a0bc493dd713fe4b5a2dab8da42a0b90ff3656402975b8bb0e63dd2a7c1c2047461887ad16e6fb5b260bdb1768fd3926966829fdbc4a3c0365a68590d881c9e16936e80d5e5e20b41b72f30deb05afeee3884be384ce94c890ae57e9d5803fe8b676a9afc3f9e93975569f51d5657103cf548a6acf46cf09cadf47b30949668fd1275f0008f1d47d895cb37f4c1eec507f0c391239acf89e690514600c8a4d2303382e109fe295ee43a2143d7f0bee51f1b7b7a9523ec362fc5ee19638fd0560ebbaa72d8504c5cbcf2f91c87cbbcf15efd50da78a57558365d1519608980e5c0875ae51b32eeb4a5753c1664800a0c2549a291d9f39b577365045a9b88afc48a4a6c6d2583c0158ce9f683a1455b38695cf7cdcbae7087a666238fb76134cd8fe56ed00829076f9ebef2f9aac77386166a970bcc9be4c30e13038414a01af87b2987dfe87009e747ac3f9c14d52b505e0a32d388f8a8479a64527dd9754089effcf8ba8a01cd5a23811e216740d85715570bccc78e1cb3602f83ce7b9c8861606fe9ee2aa80fcfc10a0bcdedbff0cfd3bec4fb2bbc200833ed292c48fd00f433be3df497d3da00b9cf0f5f9153d91ebd35aef7f2b894228bacc6a48e8416da4d1a0f45abefcf60ed23e7bc540d6f9820508922738e08ad173f3ca94a30bb5569ad6201d21351aa6ab5434b605f9f1c7da67800d6e25451492f20441357835435b04721fb36b9aee47906f1e2371357eac911d1c17e724d038f2f9699efad67bcfd05aa2483cb993ad31c8a2bd5f7fe8b364f124b21072c776b47768aaf75f4064e0208d883b4a8922ed786829ceac80d819bcb4878744c2b327cddbc6f9dfaf1fbab6a9035986ecd51cfe22b2291727af3bdfc39957ac82c45b6c6da3b041cf40a5ca3b4d240e88fc59224500429237b9e74cb6d7a3dde0570c5aef5b0d05b12b66b93306a34cbdb84e26e2755327439ef0ce9eb52ba9e5c4d41a4234192f620352794534399bae5e1af473625eee35382ea7e50615b61ea4fede68b957103f203f5d2ff66166d878fbafbaa205139bfc85582cf7601d64d4d62db2523b16c0a34b67fb1e5a0e87651528676783c2e5014943d7153c4a7b3135bb64af44465e7434048229d8af7de989183a26e8d7125660dd1239088921abff7b2b88f027a280e944917cad086ee213d8b4d143f6b8abc91281fa5b934a2fbcf0a982ca956982de4edd142b8218e0cd5088412b143a0f6a3bc0cb491a11e1c9cd28f4154f7793895eb8f5432f2515c1dc99f6986c7618b6f10294397067ad1c366687a79406fc011391c828f01a22c89cb8925f10d1369997ac8b17dcea8ef741125657ce4f666399fdb6a96ecd84ded9c58deee48024131202a28a613a9f2b09580bba1a451e6262aa0daa19409162ed5c739eb503e63e11950548b7e9ddbfdb9cce7588047ecdc518a563c278c8efc50154b0ed8bcb9bc2fb39fc5f92728622f2bf221451d8aec89963da013bfebd3087e0e5e7e45722c0e45c5eda8a1e9154400c66dec02d28caa3907cd223f0080572f41e218c33c17ef64c4a6d2275f19aac678030ff8ead37614bd9a9e9981bc60e88420381710ee42df552706081085e338be43f1685823c913277badada761ad155c9865f500a89dae519f1396d7793e0c510d4e2fd0b28ac7be977241c11e827398375a3e0aeeb73170ab14a0fc00a36d5a2d57f5cfdb57a88e62343100ddb6d2f9615322fcdece8316642c6a7fea9c2e1f75894708a104945e61853ba88d6e3d864d3e12ac1ef752699dc52a8b54e31f22ce1bb6d7148700271bc7d14422b47aef2261813cdf591df26685d6d9a3f48dfd5e7918929b7217104364b5196f7828dbb5a8bae61d0a922f02ef6dae7a591ec1eb1fcee60e93b45f1dc40d2c75489bf184e04ee9336844476cbc8fb36b91afdcbf53623c8ba353239483f20a68d28ff9f175d4563fd629810cabb77aab0b14dc3088a21ba88dee4c3977bcaf7add579321d516729ecdd8d047a4665d9409d1118aa330a1d9b342837fa93be517ad18d0714477bac14bfc332e66988261e5d91207d8275a1ca9dc486caeaf51f082b7334b0e85a072fd6fc49370a5759b842f18e7d5c5b617edad9e45d04eec70872af4d0c49c2a4386b6d2392543f12c8c2f50436ed84239df075dd8589392c8d9fd4c7f8dfc9ee012f13f4f2360a65e45fefe5539d2c0e9fdbfc9d04e309b3e9dddd84fe5c39769cd3162be3bfb0c470a08655b93d91074c186bb89ae56cf470a595f2b38ae55135e3882216bba5121d65ba10079547be4e0fadfea3eca35585755880e89693bf616a721a7e77bfdadb99a7e1b7460a47ec483f7eaa154b0b4fb66e9d81fefcaf05459dc4974f0654268496515f1e4622baa8ca20f3aaa716aa0df799b79188c9f4bd96b82d1ed6a18091331df75437ab8fcd78a34cec8fc3c0151ceda42137aff4f9b1bbf0eb710b20e7bb7aea786edebb51c8fc6a76adcfbb3a3153fd4be9229f60917da130627230343431369cdd90b48fa29e2563cf1b19bde1af6feb6d244da60dc113d9ea84bc05e28ea1d1b010931b1023baf8bd05689fe7b052a506573b856dfea2dd1cd7ac43947af915a20178e9f2a271cc2ca94d6d8ffde0ef2ed67f2108894c126aa9dc8fdc36cc9bfa1f8cf67dd7877845cb3417b2cdf36316bb96ca540410b00d7d2604be79dbcb5b10d51dd23382654f1079f35229cd8d51f7172df736b5c623ffa8b1643ac28934a1ad5285574b0b77fad2dcb8391e978b717631e6328054a98986c603cb6352dc05e8f8deb9860ecc78d11eedaa7ece60ccee7442dae99f1ac53e6b28e2d839018541c6f5c8395df7ba0151ca28003b24e545be928a80f5fef2a7d43ee4307d12e6f1351c5b1f57b90f22ff74042567e36b949bd725d9167af4c98f59e353e85541b6add8a4c031094a910b1d4757a39a2c08d3fe6d4ff3bfda86b6522b21e0fee61d29d6b8fdb8304ffdccde1f65ad513dfea52b8aa824d672c1ff9a744fe30dfca719c22de66a03e78864f75b00a72633ce2f218f37a69ef8dc70e400b104bc9cd91c2c0d3e80a8992d39c97d3986da570b27690694c146fc9cdbcca858e0d298bdcad5af169ff8e7be270b69a3176e3ab410634d4813b80b09a44c138286cca4657a271f44a04b842fe28c6caca52c3507f9db9eeb728fd37131c24ff7d8f8d476f4f5537c150e55fe619cb72b9523f30a0e26ee9b17a523fa2b96f4c63cb35dec87904234a0c125ac319049ca4df2f85d531d76e4cbd8a6cfdd7f34d1cadbd27eb81a3788c83cb3928b65eaa5a91d0004b142f4a870c87cfe4cc161dacef4cb8d6c5da766c7835aa94b370548a162b056bfcbf326fd94b30e9d24720b9e8b5a698ed97286ca92c22f6f18a1a4688bf66eb0aed2852c2d1fd1d2ce8d794fa360242933203de25450d3eb5d9d3c1e55a0379f6c6d4b40b23bae1c00ba86e61317f9650e7a63e58af5e9c0eb313cce15cd4b96b34d49d1eefce999edb5933de183cbd9f9bf7087180fa32e6dbd89f5b9995ff6574f12a77648c5de1b247212fc9950234b5ae7f231fe5d64e10917f9524241bc684be8091694d069de23c759126a99f2892fb769535d373ec43c78a65b1817af42e488bef31da796b5e13dc3cc6af6311aa57d8c1d25716208dbb0c2dc2ca074959fe9eb93b48476b25044e44392905b964ba27b809a02dfe938859f336ef8254f24fcb90c0e928ca44132a3a67209567e649995627eb94cfd822912bf626fedc6135d968bc50afad06edc3d5f8bb4b2ef9fc13a8f08de94e6104ba4a1abf3a1ad67bdd10b45e2f0bb5357f9a3aa6c0a1b748ae8b7a3eddeef4f0ca2767d64de3115510e1642ea1188a0e827caed9f689a3a4b62e80e88d4f5180bede1e8129f4ae2fab1732a53115e69245b63242e11c221da7beca6d72028ddf1f905c1dc43934b1744b552e2948bfb590df5f5b9ee8a4e13880f42a2a14d8b0b9be5760409948daab190e7475cb080ca022454a0b86256fd077382ab30215b7c28cd761f92e2001048b2a5cf2fb0892a35b771d4d4100492aa0ac02b7ee0ffead52479bea6020aceabb24086c4452f7fa5db192c5b2586b1706048a3c56ce96527b6391cc6f2db14a03fbe0b8127d5a31d138d120724d4966dae06d5b1d4ba2b5efd974f1ba55b57c6e67eea6a62d4d6c2eb2aa3084184826e98e353a16ff61a77961ce94840b5cdce91f90853bbdbb8fe60b9fbd2fc6f41f1b64ea1a818fd52","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
