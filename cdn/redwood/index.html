<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"93808c0c25f9b8d0c627f3d569c19bf0f08b83d06799abf77cf79376fcb6970cd143dc3a4e5128e1f421b0497354d1eac785e339a45eeaf0316ed0063b929107d50b4325e1cdbe6826a33062038cce64278c1081314f8f67486f66091ce9b739c0127f76aa94c38582247cf5577553cb213f306b59ccd22a5ffd377934b194418efe4dfe6b1241260cdfd5cb3fff96572dce3149fb96a763017f9d499960dd3664ea47aa501a697fd486afd451245277ad038b3cf6cd81c7f483786b4e9058543e79eef4ca26c523af210a7b1a919fb6695d3aecf82bf9356b8877b0eeac830655de76fefef4df707d8ca90fc12ce35432f5606fc8e3b2d7e90db33bf246d5620e8af8db8c76849addab3fc25bb9e2bd56bf4bfdcb7c72059ebfb53af68f8c4221c9429ecc083e2fb03f47c192b07c9685b497d3aa4a1702e45d54bc1ffcf41a029be75c673775684b9aa8f9a576baa3f6e9e91a8700d7d58bfc9223dc5ac1f626453910f845f5363276080c29be69ebc9ec5b5ee787c1692ca39657f111732a1128f3fc89a700e6d3eda5e6031dd50a422d26146ad3259d64251ccc360c5cab2340357673dc557da8cf9da6c8710345b40541ba87a466b56d7cfe78fda9fd36e850dc5606eb3ba4bb29b9118d41956ec48442da2cc60c58440b53604851cb7ee98f529dc5eabaf674a44025542498ba394fdf176818955bbd82608a60a65ec408b29b380fe7d5be4cf16fdd86daf787b3601436cfdd768f1b6bdaa5d9c3edd24f76b54f59ac86d8d242ca41a16040057b5db72da32acb40c232191e0ec597114296c1804a76af72ea92ef35c581e5e0a98a78ca31201ceac3ebf2de35e7dff704ab7717e0e5561604f7e526ebb252b9d7992cb492ddca29a6c1a6ad46a529a1ca4d6ca63706dea6f10b39e0fc182cfab074c6dadb156ab26039a43e4f04f8b5fdae4ee1424329b7b8605d37fc6c34dbe179161ca18874d7bd1ae5d54a579d7f88eb83d3aa8ee5f95198ae21e723c94d8beca184916b0794e8c87410751859d7fb73c6fa7f18ac497eae24c19f2741fb67cb8957af75dfa4013b1f161dbe621b1c3810dc732e275bc9a18dc50012c05bab8333995dbb95d9636af47eca1da0e4be7744fe4761616748b060ed679af096682d2864f6de1f7d2b8143188faaa171958c8f0e3c4af41cdbe3ff49da60eddc0c53a096d04ed8fd3623573f1f2e143a1ca9e429c64ddfccbd448883d9d9301dcf7add68d14f725f526aec4f59fceaa727cb692be4fcfe9c8469f3ff55ebc51f68812503c5030d52be1d08e44d2656af49113cc4719b40d4428f6396d4645c6bb6f84bd9246d9d318a6884ccc4d8c72aa0732641d127b2eb7cb09fcc37b0d9945024cdd398b645d12f7043cbb164fb61bac551ab74f4b6a591434388e6c73ae0b2638c2383b53be46846898cf6191641ba3ac0c8acc6e7fc97eb8810145aced8a1bbbf94d2f903462de30e6aeb29152f7bb2b73e72eef9e430217e2d382ed1fc8d9690b8aa492bf6a0bf262066ccb2988331e5dc27e1510bf5399b9146643f7a75157e139f526219068cfb12aa1cdd3a9f260eea47b4f68af867a623500001830d03de85e59d832723a15c71a69e56d3257a2467c85ee18b1051647938ad8ffc4a9a6863be0c61eedfa39338f53aa168baf9136a4828d44fde90acb55f2a94adb7f9a25a19959a1a4ef0dd0968eb72d4928ea3fc1d55b968cb3173fc1279427c4faa3ae47f79fe8e1b929de835bba7c5f97a9562407504d85ad8b594c3ec881c20fb23f908d5bb7b1a9baf16e74d169c12f183116042b7c725412b9e1fa8ccc60e24a3b77e86614c20e352e9271d0db879b1f0c341a2b884a4ad1e96f070e59a97987cab29d996017e22bc7265696562546bf45a0a2a7c702860dc0b497d58d93dc62e48147fa1dd1e538321c6bf9416305c19ce00da52a784560a760272e0519663df55e2f3cefb0615bf749cd0f43c23b5c0ef34b101ebef057536ffb16d228c8630d3e689f32b639f2d183bb8fa042358964b026d9c3c9bf0ee5976171f6ae8772f87056fc45dc82ecd98eab5d5150b2b219be906caf152e0d11c4f8339fefaaa3625fc49dbdbb51b4c705ff3e7f75a3cb03ff01580a15a5d58adb254a942ef1f1ba485749eeed570c2a51f0889ae26f01ab9f6fbc34091122752539004cbbded3364af01716a9b886bc81f19c335e5dd4568cd3e58b9ac13bc46cef3fea1e0e77eec0b69d751255c8a558c0ae2d95600493910954b5f266b0511a6e4a4e5c4176c29c6ce3547df0c58a26fc457b2bb58f52a5c5ec5fbdbfafc554889d9f34cabfc1647dc84308347a42dfdadb656e23ca298a6f1983d05bf72d4faf79da63575d8394a5aed5b5f98a08b454462d468b1de262b13b5c4acd16e8a8766eb02fe1d00a2fa75ff5fd3c2ad4001d9d87078d0c95ae0c420e2f0c777793f03e97d5718b960d8e2b3c110f11808f848ea801f749ba40321c6ff1a7450250796cc7b5edd9a7c9543748983233a3df394ebd3b3650e7dc85ef4052ea8271eff00afdc71ae5cd0564161a1189f30acce956c2938426fe584f0cdbf4c5ccc9fbd297bb83067de9840efa1adf8f914620dd6ed8ff0a93873f19ca6ea50724bc3b11fcdcb29db075370ee10fe73131cd5779a3360fb63c14dea9d6743309ab41c4fd93efb98c274548677617d33c8d2c2ff94dcff966d78685a550e392af9ed8e4ccd0c3b4d2dceb205e4e7aa6c06aece54286a47a3e04ea3f9e5317e8dde0cf4a8d81e1c0e74b7efdab7d598af44cc2d897e2463ae707d4eaf3ed732ceb3e2e60fe0ce5a0aa3661e90085b792449d7ae2dae57953f66f1b4499094e825c25a96d6205c3c6ef4a1b21ed81e4c15b03b8502d40a8a4c58f4da9c48befb4b28aa8b540464bb2a564efcd687fb5f8a5f692ff094333d6a0d19a7c7f687655df0b86075fa3ee265c349d6c12b35be6a74f5a196a9e4e741930284599b6bb362a5f16a82a18068f47d64c140977135e7a7ee0e2323495ce787db5ed26023333fbcc0c73b44fdf336ae48c2e3acb9d78bd74ec094d66d25e8ff54796148def05a0ed2d3e0cd039f5bdf8f74c04c35903d2dac7eff2b4664c4b5454dd75b97934cdeb69f9e80220d119a3240f6a31bbac8a50dd5272f607e44e0d9837af78a04d053ce9b64030aa1e641cc1ed0c607ffcf2b1d00d57c41f92e77359a3d2336c2fe725473082377a1f883e2a977f19b83a351b9d22828c18b1f5878ea509e207d115eb165ad349553edf2b678b2da41d17bdc8de6d3f50affcde38795892974de91cceef6af7207f380340b1f0fcf847987c059fa534f73f44e3c5b6b7413009c265443f3a7907f8215a4daf8ea497a78e3c9b31da6437b8bcce0202f4ea462d049828fbb01e8ad708e0c196df8e4ca4f6968d3b75bfba4d2eda9fd6c251444067f99f801a3b7a4814d4d249fd26ab1db119b880fc6cb3e3e69027a6e9e15fd96a7170b00b9400d6d14f1ca590e46dc366e013fabb9dfb3e028e177ba0a8a4b7d31c65de875bca4ae9094c52480ceecdc18718690e5e196cc024ee984d3d03735fe47556ed4c6c37713a4def458a5dfaa2cbcdd7280351ee2b1a0d61e903835a2400bd500acdbcb0b571b28778ab414e7c89f6ac50e60e9fe904a85c66b8703d85f79b190b16028ee01176da534d1fd6ae50ece455f854826b29f1394ccc8380f0e814f676c4b4ccb028303cf6633e52a73d414bd886ecc37f63d4746847dd7e2eb73eaf42bedeffb82958c27b1fe4d37dd63811441543c8cb882050c51f8031bbbc4038c3716ac87dd22b0ae979acd08d3af7919c354ac920fd02ab0371b83228fcd08992edfa74b64a80f59455ef5dd9cd50d67a94cb9c9c859e81fdf3b8e0ae9fb53a5606febc8e2ce4aae9770ac03390bf12828d6b99e4da031bb559b441d0e3976b4e1fc52d693c4c39cfdfe214f3ec03166d1139e74739215c98a7bf81bcb868153c7709a1e1d6f0a9a1bb4893a29d4ad46f7a20b42ba3fa8d36626ecaf4ff3407c8fcf000a1d93ca243223abfbb1ee4fcc98604cc5c9ad0e00638048d2fb401a11d98da479c0fa4104c184979c5a0b4d9a2bdf59abd9aab05d7f991e16d9b983ef14953080e28af7c2a3e8951a06e68f901954273d6aa7dd877098ba802e04ba2545ab9fa6586a141eb01a7ca291e896b11a954869ca8eddb109261bf618cde4bb0debfc2f81db48a70799fc20eac359b8421a2520b77f0b819ba8fd5cc30538128bf9f475271a7380c60142c7af8a0c0ca94006ad849addaf86d1fbc4f0df870e81eadffbc0daded4fd3549ae4d756cc56ded58cf2b4102b75b383307686a6a7d11e4945014f18d2fd59f8c222d8999a40f3e166c713629a2ddc053d3f7bdfebc73424378ea78d6a550da85a7d6e509de6e0c7cfb829e16a399a4515d03feb79102a133149f35c8267cde298d1554119873214f26fe01cb013ebc091dabbdb4a829a0ea33f7269fbee1f7921a91a1ed3df39209b497bdfb5b0ebcb0c48b1993dc4c8756c1241b4f65bcd9489c7599a590394c16f543335fc0769fcfa653349190fbdd750308daec3a9119573ed32ae48793348418918066d4bfc53c85188de668b34a19b301eac93ef3e8cbb66d3772e91a6f62af98dc88bc11e8ba9a0404b100efe49c6aae506a7a6ef33a6429f97af175687c64a57e6e466d5ba2bfa06d2b57ff92cc56500fbaabcaa2af75985de12d82548447d8f46f7a261d285458ffbac587d445f1e537be2f9725e6d5a7007702beea2ce41c08bcb626fb5f04187d2e176104ffa58220a8632cde28d83f7d16af5c363cdfc4c62bc4217aa350d676733efd147ea9a32b50cd2441246732f0152a6a123b0b5b4015fc5bc062f8d615df14105eac40372b529e286cde2f776c9b8c103fdcb5409225312cbfac94be97408823510c8ecc2507cf6f3580fb66cabeb9372d12d10b92b49bf44dd3dc3dceb1dcb82eaa7c08286b7e62074067471beddb153a084f8254304e2b62a30d3275c77143980c0f6d7e5510e969bed9849d4696b7026329d5ea8dcfd6890767dc6daeb71bbfa390b74bc438e35f3d6c5f35cbe69de617890623f31a0a9bff5d2aae413b234c90f579942b278e93a49987a55a52d473a1f53620c2eeb6d787b18214f953414da8c768cb4e0f447d3e68d38c7806705210ee5b9bef6cb950b3fed15805fd36a749ee01027a210c06e75f444e5dbad6769ccd635de4d2deee5b3863c7a06ab8126a8fdb202b4e3adabc9cc8ccedd994910ca6ed30d2524e3574de4ac6bb32e67b6d4d0d1968998bffe94cd33c29121a72fa0f3fcc34b4b040247cb50f4796cc33a9f318e61835a3271142a74f4b6c9ed606894d8c3feb2c6f7d546e135eeccd45efd9ac8b3b2ba875ab4045263c2eb65caa600f7808b5ea4606b7898884980a3bcd2df7e9c16c05a4b05d5e9bf81ab7d39ba8f2cdf6d096bcb97a088a1ec99039f2755e285d1189950a4b1cf18e28ee7fb2827e92bd8383ea2b57d5c5907e71fd6e4e7d8c8b998e5dcb2cdf02a9a1a606389cd755f6a766457ec95a76dcba110a8506bda766905e4614e27e9f2d5b1e83724132bec0786a47aa50b8f10329c2e6cd2e6ddc186fdc9f970ac5bd27113a14625f1efc953ab7e2b3f4ecbf9a0f3f6c7d4d909c6722785a108eeb3e9527592e6fc9f6cebe6f2cedbb72aff3709c5def98da4795fff06589d29030d875ba8296e932ac45ef893d9f76e564f46e18f0ff752ecd896699a9b2648228e845f43bc83e61a0ba3a0e1807612faa800f81481711fcb3a757366a2fc7bccdd70f9dce52db179f9d6f7f6818364d5ac28c1f7334837c46eba35da055b0446a4d9142536181079e9f1bea61c39369c65a02731d1d976877f83645a4de7112b1be4dcbf1b4672cb731e4d3130c7d83e1d552f4da332eb34de8303528f02722509377208a41447b27c1d5a3b5c69e2d86e6c038a1bbe53f620c10eb510363a68c46671021bb3a63a424ec687e1c7c12b1f0785c5d2967ca4998680f941883322e668a90b4b02edfd30d8093487febd9651fb0d6366ae9244be482a63a56827c31050e48323b7d90fd21999c84284d84e3082508a9d37b89bb20c7deb9d2f365adc7497f01b5dd5550715ccd2f8da970ece8581cfe37a64c2a2362eb2079837f94fab73241b52b50b8f31d494ee41241c6c954c02d93ee56b01cc10b128e5ca27212556507ef2c12959bc4d3822aa7dd792100593f6c4279ca42afabc4fec7be325b7b00bb7e2db3f16d0209bace69174253c6a216b41fb8982304baf5d7102e1b921f085a4d4f7451d4a167bb2b0b050d1c5c5169d35262baa8051887c62e854c394d04545e3c6e11533a8efd36dadb91ef0443b2eef0da801a0511fc557faf46be5ab08e8ed3122663d0503d28ec53caccb40d82b962f994b09fdab40efb2cae0e48c822d19528ae306c4bf765fd14eb71021f4bb652183830c597e46135ac79bed09c04ec7f4a4dd556b7d91df1157735cebda9c706a785ce88c3c530b2b8e6e2d031cf8504f7f189a26f5282e3a316a802c18fb133414d5ab75e179cb08c16f1ba1f83ced8011ca6427585025ef3c117b0507c059a60ca563b3161852b8b50b2fbfe5ba4753dc45c095fbece03132ed64e5d026056a2a8507c28ed64e334956dcbfc34b49187ff325c2d246cb2001056e9b38f72af04eed58e86d7597ff6dcd242fad9f0087466e1e3af37f2d9ed499cda4d5dd4f4df262189586a2d29e6a0f0a80be63be3a52647f736c6231a07248a490b8de9560be156376716a52fc8b9de24ecc6fb380ccb73edb712210e6fa05d7e6ff7dfec39c8e9fbe2c1ad6761e4a6b03469b3ad8cf69b2ca831e7e390ffe3c6f0258def799f72351cd609872a0020be471625aebf04b210022c762bd4439e59ad9eb0c1723c4b27b01f36a3824c19718c0d8847ff8d533b82a963839d57bde337cf32f411e81852827ebedbfd2be2b80b6d90b91c3c367b6750ffffa7ad777d1e548b9841976598d20148674b24ecd67c9e29c768015bc0ee7372923db99a78468e1c384fbadc09eef2610ef254fc2a544f637859d79f0b0adb70ce1d0e1729425c4fba8325ff76cf565ec791545496f9ba64a491e8cc590588b16080a96e556d9e33b9137b209c33fa64702c97a125648f4038e9fea1f90f010e518dd2ba7f15289eeed063800c1176d9053745e79aebb7413654acd737a51dd22c4708c09e5c0a0e76b77dc98799f4ff78f08d810bf5c1b0b8d612b8a280fe8480f7a9a34c284a4e76219414feb61b2c64da3ca9dbd2a31e4ba414e037a8d4afbd8120ed69a186e1ccb0abdf0984120cef48370d58d3047331bfa18b71dd2e81ec4e41bba094a756292679d2414cd947873e82099803f04e7ab44fc52e849aec12bfce3358e3d113f94a95aa0727d2421442f980a92ae05476769e41b4f50a13b61625153e371c27588873dc6b9caae9594fc1ead67c24357d3a446e0f205d52909546414e9553b5607e6b5cff827701ec0c56e5090488623ae1fad025d9dbf19b5aa6d551dd6fe3e294ce5e355ba3660bcbd9b0572ab2b00e08ecbad496074d9cc2d9e6ca81b8990c31b3c9bdf6f4d54b53233970cfbd12d4cbdfaed20fdd9ec3cea068418dd41232655ae774d28c505e8ca1e63badca66a2b4c5c4e2e7903d475433f8f9bd87d60ccd14ce2491c62d73a9e0ef1c458ff862a94e0ab5dc6969a366d83a622d2bd373226081ec92aa2d4ffa44809556a0c28d9c747a800a38cc234a1071e78578225acdf3dab1b605ec4689465b2e196c3055e73a2b965a8772c812048efb97f44dd96c2bf5bada918a6fca3b6ac7e47ee7d0bde745a3ac1c57814c1d679e2f475c53e8006534580181dbfafdb6bc6f742010db592ccb7361774ae49e861190e4cd58aed1adccaeb6ff068cd7a9749c401faabbd87b8074f5c69d756bdc2c548cc9058fca50dcef8ff2700a92b8d1fcb708e59c8aa5d65adf99f8230918b2658762c33b9d1b298832256909e4b093a85e2c5be5ef3c7df32781a01524d8e6b34b9e875721d6972077c994a9128de3018a4798227a3d7c5d156c980691f2a63af4aaf3d63c6efbd8fb3b0ec1d49666e2a4117aa9528f94184ed83e00e2d23021d8ee5b6abf90a707d6203a951eee4345cb2075c2c94b1415a93c64f8e8a3e28f6098f280b939d6d12aa32c6a5d180545dd725ad508f9d8cec6db6709726e9dc1c3e981e4016616c5ab5628f385d1e156460e8ee6d7760c527c6a1fe87f4dc791e7526349a10292e5189d9cb80f5bd4f95f8bac125e89e1bb307cb1b6c98835b9ac5446a938019a638c58b1e7555d48b78c56d6ddfd0d2f9c44fd363fed2f1d059495136af48c1ecc100db107e0f8d07e76372e01281973eb913bd01c7168fcb9abbebff733dc9e2b53121dd78ecc8b8284372e8d0fa9da4b5cbefccdc73642f53edefb1a7b4deeedc5725c71a8d0a38168150cb672caf8bb144df8344260b1df61d759b8ad79a8042f396643971292ad5cb3a1825ee6da5faf8522b6431c3d26c4c090317bb3196175e28a2c68fc0e61cbe79b69a25f469f16514844b6574c4019d7bb12c594007859f2306e4208d3574fd9f8157b2ec70b2f925e595837e4a49ce577797767f74ec47de1fa86186b3d7cccbd0074c21ac83a095d79844d58ca3206b84f523d1cf2f9929e12eb6088cd3314b4b22680ed7769cb4113a68d8f38ee3d44da50e33c1f30c22bf49529a5b494ed346eef2a955a52fa788a8f021359ba5fe36420b2a7af892c4558e594f8a471ef7ba4250c30b79247a36f0950ab2eaaca64728b97f251574364846ecf2cc467d79d8ba3726b9cdf9c3ffac6f707366bb42f4f4dac9ec394b088e5660b27aa084b30383990981021cd6ecdc4b049053956d525943a41ac3b7d89fc9bbe11a94fd0df5bcb66cd485b8e459f2120c3a2bda20ebc059d7728431bd741edca1fd4baa07a620a48fe373efd6ab877e7ce649877f71df0d433ff9bcb39f1a6705a2c4492422e19723751ba4055e1dd02ae1decdb11452998f750e1ec4dfe5d581edf658fa9e9a20bc257ef905999485ecb5f7e687d85df7c74c5c46b3da498f97594d2932ac5e297cd433e132ffb8f9a83336b040588bbd5e8879ecca6d9a1673e4affdba9acc128f8943c441f1e9e44296a951965e43bb3948b2afad1976d8a58f951371b288d99084cd582f664a0876f348e975fa38cb577c9521afbf779135ce6973720ba2b23dd09b5c84cb08de56b1deffb67682dd1ea1b5c562464b5b80072b05f140469e57d56eb9cff7a5adac9e3ace78b0330e15036d05e5786f3421f78d3cfda86fc443077d94c11f4d0242b16a2babd682fe3f89c07f2e615affa91aa505239536d98a5abfd5ddc277d4426ec47f28ec30bb77bd768b346ebf506cb917aebb45ade186ce2806d5fbdca4344e93538e66d0a02cd6a8036aa7028b491e139336416a90ba7beda63b728bbf1f18b3f0e20509703e95ee8a05b28ef14879685f4c91a6f5b8bac85d189a6a9a217ca8ff23e77785a6e05b5b6acc00946e294508009a2a5291d088ee7594751e084d60bd5e51ab58a3a1427ae2c59a217dfaaa8a1f884f68e07dae3c0466034be43542e0ff31fa1bdb32919bcbc14f7d0ae86e3ceaf83a73fb12eac514f7b87130e4b2eb632d2aa6f4a236954508d0e0ef453c9109eb51619be96fa2b7ff122cc7c05d96613d8643b4c1273ea61b1c84281d5c1b748c436df5697d33622029ff595a520427e43c0f0168f476ae13c3088b67083a333ef27cb27b088849773e6450d61a657d87197429070c8edd9b23fd76e266bb5ffd46f5e1f1813134e9aad892c3dd59b6ba9abba3389b09af2c309d760be43ab762de72a36029b05bdb289ecb80f426f927b3477ea22383d86824864a01769215997e035d9c38fd65b9558971d8efeacdcfbd693e40ac063afd8dda887c7436e2af72b07a8f1e8dbdc39c0b6915b26e466c2da90a73fc9983b55060c9d8c599ebfa0b15329898cb91be8ce3f378ac0585d27ac12ca11778a9e8a6fd9a7ea65234ce5051d24d44925dd1a3191e2f62d28cc2430e3b6e4def86d0ef097b843d9b2a756b1a545793fd9761e8afd17785b2d8242d6effa0820f5287bc53f0c12568ff4ba0463c6cfe33315f29101be6fa0f88a0ad254fe8a76712503631b8d173974c8c64b6b1da0fc3b3a0545102f188dd654c049e907c68260bfee948c669810ac5f4a81e036307469917af66a4566126ac0cb94b1587e4b26cc3715f5c7ae68befe57a8416a40491474d422ba6abcb3621777c822971a293f9392b93813297f54a97b363394ab4870f9ffc4ac6323c3b8240d0eb1fc7471e9dda0a19168c51c5f8e3a11f1d11826149f209669b82e8a6ca4fa54aee0974aa539b91388b45af6437b92eb8de63691886ab566425bfe407b47682efdd136acf2fb018ef2d345cfec1bd34317bf76b332698220cfec1f5ade7be21d30625d098ce2f931296bc32a70c6af97aa51ee87d864104a9e83ae9f3d18278809faeb7f17cbfa288a901e46aa2dd2d35c1e879714830b3370132979fd144a4667d18a2edad74ed642165250d66e912ab2a4391c4e753bde48aa7cc6e6aa50eeea8724d3ad012301a3070518e1a767ec2e1f39345fee98d0753134342f1d8ada5c28380c0c90621effbfc5bed4df2708104f76dc803b11639cecf6ddc6443d092b6483a9721fbef006e8d3ba5f1fa41e89338fbeda304190744debd0e02180b531bf986a20c290e26331b5479e6a432486312dc19404cb70fdcc82f976e05dd53ea391476027e095c6753da619c486686bd4bb626207ef5c518a1d9a13c9bf3cc8fa7bce2d71e680fc66b4c980727d7bd2fea4d910bef1a0ef67421bd9695e69d495c98e4fbda1d366a1fc91e1f8c10373e00b547e9a073fc1e79c84f1d35ab947eaaf91c76d44af65e87959ab69dc296b92fa6203a5a1cd427b1d673cbdc5878d89e639e05c0c67a05aa326afaf7b89cd2e3775f73c12930e36112f1ea21aa751f562a318f64cc6658a16f3753de517a3ab49f6c2025aec156f64a03ea007eb666d202c1f3c6a3d56fdcea4103038ee668b1ae24433116bb027cb7bafd4c51628e6018b38fce2087815f079ca7675ced8a88e5a9571e3583ea36f124604dd0115848c4c2ea0ee60233037959867623de8510098d4aed1cb96b3a72f4555d887b2681efa41c1750ac1b3de473c98cfcf91a08843883545f1807bd4d9179f825d2943c507f810f0f079037ec8731b4bdc9155b14b11658ba1159217f4bafe4d43487402d11a67390a5c06f847bd2688bd9dde9c20aa1eb68cf3ffca70e0e004d1924e65cc3c6c356eedfbc73dbb90ce2022d99936a6b6f601d3411c767bc81a9a55d5e0d42ca39df91ebf662ab070013b8c7986cde4dcd2e3e35b87227f377c900caef895b72b9863eba62e20d994e2b15c5080de779f81d77878a077733b42b531f816944ec65da0826b47b368696fc78b5080b183d757492fde5deaa2896ab51d383165e590e6c9430fbfd2dd95ac615c7454320eb508f3f34298451a22cab725ad3d070f5a8b2fe209701e8d8808863fbd5f9ecec7ba7cc4ed9be3696e3091d15b3346f958a4d2f720247a1a887a66258eed3d5d638045053b802e3cd6de91c1f6ced36cc098258ab707363071c145dbd8ffd2bf469ce1b4f00046a3461c0732e97b4c7ba609f59c00d31da71a353eae5a399f6c5cfd4220c787f60c41224f375cee7cec1c5870ee7f58013376398bdf378bac8e117f8aa90658d30dc3242979a176fa36cfcc894ef2fa5d1c754276e8ab30836442a3a4c34ec85ab66a18754ec7fdfda9dfc13e5604895b3521076a573a38dc957c954c538137a7b09a32f8bd62cd3bf6e49ee8cf715538ba04295338a9e8a97fc8a20ab3c9cc0943970e1bb2ae28fbe1454e74173997f49a8f171ea5eae957937890b87e4ccde2e79018077cf25d5486cc098d1fe943752997808363c9eb6bafb3e6d24c9efeb0774914d76dda00eb07c76589d2f99258abbb150b631bb7e171cad2f919756771dfbeac544051de18f4c0ce89a83fb9ce27868bceb266d9ea342bfe88c9864a0e7c65dfd8dd22b694956182afaced9b5a6ce9b5956dc485ec3a4effb4be44fb25b98cff7b624484b98d052e88fed1294d64c402050d52ae3cd45b95117c401c855ad7bec1e6865e1323e067c7968c032a154e3a97e072429f669376215e54b59090b681ae4c54c79fde1653d73f09fca017e2cfcf07a1d48eda932a9869fc2518b63edaed8fd477cd47713d15e9d8a1d89509ddbca9feb925e4a603559f1ede8b6d860c84c17e89ecb3abc6e3eed8b14c6bade077612777f38012ea58b5550081837cca0c7e012a7274b1f2ddde6e6bd1e9e1d876af41bbe5d6a074e6ed312ce17fe3df9d550fcc367d4cf3891b0648d6f75c2f43bd366881c0b3ac943f630c5afddbe783e671d77d1eff346e17e77726b065f842707802cff8fca3a706729db74dea5868e529c47002cec6432a2bcaf9db7d05dccfc5764ea1b7a9d97b81c3234e4b684946a4d54dc3402c950576283f3cefcc1b78900ecd76df618066abd574c30f68f36dc0ecfcbf6530a33b05333364530537feeecafced0a00ed5b734fabc735cd04ad5e6bf14862f05ca4946ef84502607fc9a13a85f901976630ad9d1b8b1d02b9f7786497403dd6b6856814a5f26494cf672773a15979fa75e3f5c74b3d6a8560ccf2be08739612222b48c72bde1bc3efdff0e83cac4c4181e11121ec6bbc15b5f9b1b009bd089d300b3516097a6050c764e8165407e29bd9f27bc063c48675379e17b2856f0214f81a0b2153f05a60473cacc9d29cf750cf29db816e430c7488dbffd1a097132bdb323aa5c28d87d83616f95eb34c7c64c0b893563646264f74a4bca2bea618edeb9b1a67f400fabb576b0dbf0b37245087c63c8b09d8a99904cb0f9079651a2d5036d4ab4cdd9b5f19ce8b62fea06cf962eedbd12e036d07690798afc555202a061751f4204622e6434f8da9bfcb2884e9574ca26c77dd66bee41e8427e5dd9fd7c0c2ff437f3bb240988700769c0a0a694d1b03d35d0d2e108ebd910ff87f41b46a37e3c6fd74e20d1e8cd58313d77c02b40b83796fd93cfa4d31f4292723646b2b160ff12907f5f66b0f62aaf39f28dcef815d60bfd1644da1a92c033e99d8ad964a479a4de0256f5b9efb41a0f188b3f8516135be9b4da44be6dbfdd79334f9e5a783563dc96b64dc27cf28d0a40d570bf2cb62a6300b8b9ea61da0283ead7080b8d3eb1736e5c175a8f4baadd7413bd4250252d59ae6cd1cb8fa020768426c787dca1cc14d19ab9a0f9a8ec886146e987ddfad46ef2fc046f08f5379816f0865fca4855e6700de836ae736d7ed1754d6a71eee46cb827cf053beeaad4b632e5b8c0c5fcc61c0c6c1e370183464e4333f361d08fa406ef23face13dd96971a56849a204f6a0fce48415c6b149f32080d17a94f7e147fa83bb54a4da3c56faf2c11d1cb48b6648f9e85a2dae35d5383a09df309c4b77364484c938b1734cef49a453f8e4fc350887a5f369b5ee854cf786208900adc2b8dbf56a9844ad9decdda7fba0d5c09843faa9da3a4aa7f7149817afd2f3a8dc85d5aec5159c995e150fd396ad3dea08f3693a0b23cf327adbb456ad71feb0b11cf1f1990d67bcf1f058219987b27ac7aedf4389c4e36b5ee6107319ff60f022a447e9bbf8684b6471b136aad40f337c20cf495514e991b1ff8665e994fa6f1414f356b260ab473716b2085711a7e20f1fe4c0fa8e9192437ec6fcc931ce9b272375b8fd5c505305d1e7fdb6b68bd9f1d7cf44e9cb266c95ad28087a3dc101511a6f990668b65342ac31c1532063652274b582513f52aaa8f176b24fe2fc338674c8789183990d34805c165e398c395eaf4f4e1a6e5f01e79cc064dcdfac450e95861b71230ec2708961338a957a2baf4d99a4ebc454b8d253064281e52a76852f1e32dc487b0261bfc3b88af07f7d75a930a19872b4146c9c48962bfba397ba249baa05ed65d661330742c671d003552a93d917b05644c298a7dd3811c438e7d2606abc5cb183d4601bfa8581c050bc5c850ead44eb73bcc29545cedde04965a20e5c47fc39c7122a021a15fd1c7c765e01443d0c95c6bd7f30605b489381fbc5b114254aa6d49addc3f8dcc6b415fea89dd058d0eb1f3a2c48fbd2b772ca2688c6f94e1e7dd084c70f2c02155f6cd9b848562c8f8c4d17320d8af4f599566c7fccf4f2e302df3d43456958152bd4458e84efbec557c3ab67946a8b20ed1a3dfaf1b0f9da841853dbeb949331e0a4db4b992f9f7d9518e01c8312bb3dc13de901c8170a9317386b9f76cfe6e8214db7995234c3df2090b15f6641c9e2c5fa9bc49c4a0b1f73e8d19f7ceee4b471750a0e100876053327f49b65c7e9b2f7fbe051cbc7cc7b1f541174d9b516aacf9a41efa5abb99769ac8a7eac1b2f5faab7eae5b419ca57d37190a4f8d3899728108db5e78bea9a798c04caf926c702d1eaeadf140b584dd0b30bbef112f4704ec874c05067abde445d8bcb45819d2c152233fd5d02a85bda8c20d3c41fa3fbd3ddc7546171e0d03b379222da2ef8b472c35e8519904c6807d401e972289b57d2d0b1b94b4f8a7bbf0ef216bcc7d3b7dae891fd1f00f05d5114f3b8882dcf6b048b5536ce3e4eee8b2eefdcc1508dbfb2f74a78e491fc8dbce6efee180c7cf301a744c8ad9c2072aab76fcc2d3177757743ae9c922de67689a0dc83f02bbaae3b4729ee1f95c12dc1682dae33e1e86d76ed71f0de83634e43e6bfb442bf431e8e09f843bc4e4a6172b90ea08390124c6754aafb1848bbdadf806588a36e8ab4cee22eecaea8d7e7551427a9b04d4d9a5a0fb0293cf4be225bfc2d877934e6da16918f1865fab63aafa9d24be6c5b5d6b619345008a6d6fd45a6e8ed24e4e9b81456f5877a4dd19751b8a242f4ef0364495cbd551d021cd6e5a0c8ef0291f06aaf3a20f6cb771f10e4035a879878ad51409c08aed9a26406b5272ba6ca1cb340538dcfc9464ebe3c73d0abb92026e965710450c56fd8503d55377844d3075e0b944c7c0d32131a83ccc7d64a8d4044f1b41f535abfc291e2498d2966645bc608041c773ad2a24424b505fc5a6feee91bd9890dd94e344f4f4636622ed6a44aaad1ec4ee1348403979e691437f451cabc72f08e2d1036a261838aefebb7d5f366d4fc25fa1857fda80748cd4a8a7a443ad63f266952c0cbaa41f6da7671a34106a7376607a430a7936a2992b2d990d10d814a6da0f66cf93a7490b7dbf0ad8c2c0c6e8ff4936d3861005c561183992cc02768d3abe272574d052bf0f716ecc49a7642f0bb2c616160158ee99795e0e703e1eadc75b06c325a0f2622dc5b1ebedfbaa5ddeb8fb708e95d636df9d3c246fdafd27d286d84663f70fda09c8d93e18d5c4ddc806079be30d4e4c61029df2b76bade420ad75830b2041cf4a1fbd2281954f4dc3774cb4c75f7783a8bb42dc29af936e576025f2644d0326f66a09a690b9e13bdfffcec6d840d90b0874dba38a1d808be3ac2e285ad26c3a2de0bb8cb91f9f7664826689206a923147f40d5d6b71b3a18c478d4c562e95526fa182c47ec4f502c9ecf5b613efc7b8077a1f62d2e8936d79d87b6a761a397259706466f71a0f03182d1b0ca2df9c234afa4293e9f71e8f57a855c5fc950170538479ea42c8db2b56de9961fde22cf983f40ce254675cff703f0597d005026563bbbb64b55ed3a94058b3ad67e76e945c5c9c7111f62fd402264b6996dbbe38096aae9c2bae49ec8ee721d92919bf350aeaddde58b0372db6ce6e95f1c64c0bd072d360bc686fac3cca996b3e8a6c25fb68635bf259098a06ff6210dca1c8ff9d289154e0ba3971de9bfd14a425832ac55a5ac55895e019a6b45e3836f025b807094fe275fa10443c84b2c1f2f824643aae744ee199402eca6bc6e963128c2add0fd59e19c064a455e941a0ce7aaadbe95efcf25d61433ffa0da9a94f24262b44c9315552150d329e557fdf181815c023ce484f5a4f324dd04f64601adc90de2069e80841084e31e68b1b8019ff7270d352d1bda6bcf65f2cb2712921e834934476abb7596e7cc76cde77f3a171d59b243cef141946a459d68f95b2b26ef7b6f8d3c908e72a29061badefcc25c71ecf2730f376fefdbc2d4ac040e7c4f5ef5a155ef1cd3cb80013e6c81721ea5110ab6b7738f1408da690c1a9ecf3963f8e65f0d078c41d92e9cd4d9020b0ead236f1be1b6bbd5554b0a13762157a7e9f4231242072c21a9cf2556301f0615bd3aafa44a2e2398dc6512543a62842c841c597600a370c353ee0faaced4255f859b541cb3d9334a0909406bb9adae2371f7e34093bbc59eddc5deb420aa56418ba970c477e63138285d6e50076d06c8d319466c5b27de77483063ddc6c51bab41ee532eddb1fb6c98d71a01cc710bf8018f93f27584c0c8f97aecfa70709e881686e2c1357990992888d56acb5b9a2acff8bd5a742691ae38bc23d630387bccc76d67deae8932eabbc8f6e68f60c6ada1cb1934adcd95146f10c5e95e37a6d99d99e43a80a8f88829cb2cd8dc4515a64643a27880fba579b54511ccd22b1f29ae4e812931527ee48755647d1c127dab0cf687a1467dbab2cc2b4f5ce500a04776409c620af63464b6b70487cc32c81c8dbbe909940444f6a49abd73b544308a4e4c6194f9c1ff13229138d81614d8a452773f739944e62f88263db65e73145414ba39dca03acefc4599d66bae4d240e0f1bf4b1c233b67a376779c83a3ffc6ea3b66803b66f5493929cd2f3ff753757d4188b943f5021c4b0dd8c92a7338a1aa3767a821992011a97f38c6fe2dbd9dea56b20a70382547ee563d0c2d50ae6b6131f3109216ca12e41066ffe3ea002534327e587878793963474ecc77076e19a648c403c1ad68be622779ec23a2d811fbb9af46dcd9307c35364211e89de7c611762fa73682f8480e134f60e8655eb0c71b9025eb68bc1eccc52c177d4c34e9c950fc2e6ccd5e468cc8cff87410bf60e32a71a75b04a742a99bc0c43e69be5c01cd86349d2b5531c248fe4c8efcfc50f318b5dba52c80169dfad21a45287defb81fb162968040b33d88c9c1445dd6d32fd0ba29f3abf69c16af3640bb05c9c514680f0d8d34cdabb3131029d91ae1b9178e9a8172e5c5aaebbff37a4b72445805c8668f1556b6eab257774756b19eec2e306ca5a1ff5a980959f6c9ccb64a5bd871a48e9a1b635f52e701eb1ea2909ec1473630deaefd9304ae70db5c7702acbcd2d21b6b5fd0513d8425579bbc0ce752c22cc5956289e6ec88a6cdf10cb4257af3bab7749e95355ceb58254ee702fa6ae0286d26d9d5a81192ad993f65870acd8a804bc85d6955446891e2b03956f6bb3e5731638cf6c76c9e018e6eab86f532c3394853ff7339e1e74fef49f16de7c4d9a8cbf614b957777dddc8eb4e15cf60011d4d2f857bf2145fd99d7b46616fb28674d2efe93d2f33fb615a680e9d007d7856704fc67e0a7d603ef3b61e7579bc57653530903593787c5ca0532c2cb4c50b6a39ebb205713e787c519ff8315bfa87a859db4a5c3af872123516a262023b9b1d34b936007fef5e622dc7ee931cbb580a893a5f83d071d815a6b6be299a8fbc48345501a468e36f66f4f02ca24286c4c220d19db931d3745a7aaa02b1950a6e690c6509b3a5629d28ce30a929d7a733f80832e78704f1e934cb33db6ecf4cc5da465600f423c7a17d7ea269a4cd47696094c5f81c1508ce091786835c6c15d7762164cc202479a29edf692de2436603f2b4e75c305a5bf7b70c8c20f3534ac36e73c9edeb9dd4c0e624e3a09b4773aa511e9c1dafee0574d5b8bb5744c5b100cde74102c7466670044b4fbc71dc323003d8ec65c81919134d7cafd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
