<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"712de1f6b6a0ec3d84989e7282d37b7fed26d8817b798181a616ff793a3cbf842ffef66b8e99729babb2405684c4e4b5fe1bb5c1411f0239119b38aff19d3001b7eaf76b730ec6ba6fe48bf0b47269588502315ee191565a86bbecfa30435848a63d058a655049fa1dd9b5ae7280363fd798dcf5f293f5713d366e2553d988666e2ca363e94f9eafbbb48ed3b8eaae5abc89d838ed7d53692b68021b77a375d5afb1b8557c9743ac39b54e11689a23958cd894c75a0724b837b6863f9a4fbda25a6be5d9be440a2b96164b8b8fab0ad1bd386ac4c8f97f16e519e3d4f7378af418f318ecf66241aba4f9515624692450d4c45ab5c2d8a70c7db5530c9c929f32b0e4ef8ea94d31fdcc74f35b8d766ff582744b9cac20d21adddb3a1bfd3b64e82bc9bca360ee127eca3b9736970ec77add48c55f6171651c1affd21dcf7f47ee01e5e863a46ebcfb6e9dbe7cf5b379193b3792891b0a2348083f645b88eccc92df0cf9c81ab68044ab91cc4bb3bb86f077b44881149b79d5ae58a2e33aba4634e8275de42003034540bdf5a3b2d418034325f490580da702567f16f8342188fb1aea9bcd0421a072075a990ae9d856d765e5a49b346114aa3e855d2a8c960bf5cd475819c515b5a5e7c23dc51a5ee9d443fccf36727ea98a1f7a1729217365d89e729e38cab932f8a2b7d9265f6cb8db79da5d5b078835224d1b07016910b6ae552bef4e1bbbc43b0dd0e6e9312f27f299481ad926d434a7245492afe117b44cbfa032e2b0e92d67805b08751d467314e1daf3c6e192d6c3b623168820930e814adc8c2d95ebffe0fb6bf7e1a02f75739bcb70092fe146a284c880aaa786be3b9400003b24fc94f6f7ab2e5be06848aced01b5dc98bd6c1eecae2779c58074d1a24f1ce251a53ad1077b22e04818129490802a8272e5f05e9a54d37e82a6456bb57f903924a18db4faeb0a9db66099e001827e9af06d68148420331381c91e1d9c033ba183a7269f115f3548ec65a0e18a1a38408fa193d33d5e8b8a9d0c2aaa1b7ffd2b83890ec679d990def1b52a21adb812b6b311aaf18196d974c0f1974fed8e558de36d1aa1fa6342170eb354ff26966cc11030e1ad0228636f1b86dcb18d9b42be0e52997071f340c3eda46804a3390bd26d40337dfcf7238e38525a0e347302cfbb5a146cb15af4f675d1026fd7fb83b92b22b3c9968554796f9d26a10452b324f36e675b50f1f5c3b0a647a023f3fc27338ef4919f6a3a0bdef58ff91d5eba1d555d6fd57dbcbd979bad17bebd3136153422a71733ba5275fde4c2949c53f86a501fee24787f7bd9eff6c8350e40231eaaafcd813370be79d94448f73d54db00bce83bb202cc5b0fb21bc3ef7ce135caf3bfd890ad4a76cd5471c8709f37260b1623418f80cbf3e1c427f1e01c123b0db07d9192ace3202c2da62676aaba02abbf65abc3e0a2b4ca99056116418ad95aee435473ab07761631f1f3f69d385ebd6625fa2178d99120ff33cfb94125b6c7eaf597cdecdc59e55903b53e58fca9a6f9e70d8a7db898ce8846d2e959f35accd55732af9f09ee753cf6e3fdafb1db56526ab2843c237882b8085f33bdb96c9c9cc765d1128d8360889aa4ebd235c64a8f385fea7abed01d81d9bcbf69164ba9c1982c9d1d2d18d800ff8ea823ca3ddf0a96b0cf48ab1ff4103b784c2aadcc1985834ade2b4f1b4636fb443aa0322aafe9e97cb73318f6b20cf2cf068a7e8e4248c3f018d8bd85ff9e1e08680063b7537e90173e831e212913ca0b49d1deb57fc5fc710b36464e1e9e5fb031eb6c13952698df99941444e52ae43594cf290223a7769b550255cbe0c123541a07e429f74a8eeca2d282fa4027c4ae1003b533b7bc63264df00032d16e6d98ca13f5e370815307cc2e1594cac43d0cc9ecc91d56c61dbd57d05ed29e658e34288f0915b2e7dee65c9b70131c43e91239d052f51353437ccd07aca0499a936a89cc0bf0e0ffcbbf1858fbd0119ad1ece4456ec71bdab2cfbe9e8501caddc63126bb56367fce99bc2c83fd556f41a20982142edadecf05bf20bec8c8a58351dcc2a81fb68765b84ccba738f937cfa95b574ee3a6971a7dbef6b1c61d787e80c61577a616e517c0d0f12f81c66ea6c2bd1898de5db1d8d2a770a238f5f4245cf49a584dde651d88663f879d9f64cac8a0e2e1b35ac51c3d62ea7d91b02e3edf4926df73d530b328068028fcae8588ad481e994a972542c95e02a3c8f02002e253dd4fc91fb672a0973b6498d9edd21e018ca4d5eb244d09bdf94e31c8608dbe3a69b22ff6ab751a8180881f568ec9f143e8b6b1ac8379d1ba55d19ebb1f57f3bc98f01b0937a0111c0b16f1dc86cb87a370eb9b645425d36518dc1c65c6db721ededddd276f9ea0d6e0a8522381c099ffed89945ca3a251a2ef0ec2e98bdec4b8a18c01ac933dc4da303a868ff2eac29d5be2a0cbdb3739f4e4f192d2e69d25794151ed03cddc4731fd996d73e5e4a9a47ae0b3dce19acc034a183023c1d30b4b1089ce6bed1aee0a7593dc9dc4c84f2466f146331901e7728b8abc151e398f327b20345d1a278045fd951cb452d68d1da314f5aab0b1880cac14b05d588e458eba1cc4fd76a0779fc7c1614f8d6d1465e2d2432e487aff7766bd0ddab4168230cfa7f9b8deac77aedc75c16315e89d8805890384c767eedee00fd990f868adc60cb97d411b816e7fba7bcd630dfbc32bae1223509f0c80439740451bb6e6726bde86688ce157a3aba4d8cdc9902009027c3f760c6dd3033bf71fd230cd45ade1f10c7aa027fd42625f9f049eac1836145c922ef5cb03a84ffd009f121e52e25ee358a6e7dbb658774e07e61e4cc954f4b2df489cd2dc6fa9c9cab6f6d27232d1da9ea299d2f848a35163986076488a062962d22df9c82ca4803407041af283579b7033e05f39b6d02b7cda69aa1381ca8d83dff931745fe0d212285584bfc87a301cadc4eba2fb9296b28992830448cbcfaa9ada47e37f02b97d1bd1c63dfefc33674a579f3d0d2715c7778ae1dbd9792ad4c78857875fd44e08ee17979b0708a3ef7e609301c7be8d06f0c6fe107ab897544161f1ccc1810990e431761c23412a9eeef9cc458fdbbed7fd342475456ff47d6b46b7da7da15779f19eabf67fa7bac3596afe820bf15cee180b3d0e546946b3e874b7362e9b937a7de18e6b231d5a733c542a7202a3177a29c1acf35d038fdd4086c027c2bc3b01abc0ac5537542e53058e05bf85788fa30f90b4e32ec1106331fb8154e2903e719d5057516d8879e602b96f42320fbab8a6a4d3c194f1d1d4b9be57c520b0b9ccea217b6e88f773e5b6696f1397083f8c99f8e9bf24b4d8cc884f6ce729c20e0ae6b777c27ec3e457476acde418ca000481e72c0066768d9cc4cfbe7221c6e6db5bbb469adb3988880bb56fd81234cc94c792f4c9c58ae5209f7f76c31870e55e75b5bf2e74f1368c61d546c69d2cd105ec9724ef9c27f6145ce4d507b3db27c68142bd7c01afc439f18a1f5a6d9942b5548c5757b005850f5ce5072bbd9e83617e9cbcafee1dfdf2c711fe596cd48a6ba69a8c1b69d7d6a991c77a028b79265e90d0a7bbf80fe5197d08c70e2f7a6ee21ec0625c69bd20e378e5fc659227986680c62f3ff047d32292008d2b4b429f33765305532f8c9990d6023fb220e90a5227747a54907dafcee909f48a14e47e4961e5b7eb061cea99ba4da9ad541f308c84294dae3f02e7d29c37d498642ab4c0a1a8a0a9e70d8967a289ff86a4bf6417a95d73278af7a8fad843efc088424acb94e2d7489beedcf6e6e19ac361ddd18fbafc9cf42d7b9434a39a1650da09dca339f33e2c6c38c35f317cdb63b99c02333cd8ee8bc1d3858eabf06612e986f0403283c6f84bf18c6ac44034c67775439cac9ab4e28cbdefa344213f8b8b3326262f5b03fe6dbca688ff281244885e1f8546c10fe8e0d22ec39bdaf7c43ff35849759c62b9c3b50b3943a3e66de536a6028c18a72e872cf47e84a8478428dcf03d6152a59f2ba7bb4d7679aa32cba2571bf8408d33bbecbe96d30fc8caa310ba6bb2c891d985fef96a1cde187f4b0a8629ceebe76754b041615b3d39b5c0c756df4ef3c207c18aef704c94586791c7f0ffc7fe0bbe00d88c842ec1a7b7333f6ceccd7314291b3fd77d592c1fe46f5b703cb8f26ba93872806b7d723585f167549d9ad3707f62364db6d05f932cca29590cb2992b970180f87c84c68664dbc8a88b2af7df0cc7110a94e70e3c7902d37e67279a52ab97a72f51e5acf43cf7821a04fdf07ab301f5ae01b5b7fe2799c9f31d64bec014c828feaa5db438c0d2934fbb7b9fb64f98be07fd202b85dc8efd200efb57549ef9c5e03dfef58df331bdb1dc9fccae8b8e6913dca256d6deb98ce65c436b106563b075740096ea0e47a4a548a84a8dc95eb2b7e97673cb859f22a804947c744da6fe1a687d3e6997770fc613a3dfeede41a1c3775e6513c1b48a17de77792b7995817ff774ca7ed9a44c2b3fbfbae5264b0aaf34976bad260c18ab1dfcc050cef8bda5922360c29652733ec35baa56bc70941495814e601cd6fe7a54c7bdf1b61f844553332994d70a6eddf5c3afbfe9752b0a2fda4197fafe094f593a8c7dea91bef67e378d4721c58dc598414a6629457d31895963028212988c6da68941212dd56a7cebb0df0a2c235f582ab5f77f7ef01fa7c92c32ccc0e3ff610a7600ffedcecd87d99ffb126788fbfccf7376dfec92efde2657901abf8d4a7cfbd6ce54df34b21ab5a6da8e82f65fff8b32bd060c07324b199d8601398caa03be193567ee4f1a92b7f3c4abfff0e6c77467fa730f1ffc3344a2c1c6f3aafc241d4aab4f8ea631abcbeca43ed34ccf2c764645214cdd0e9034a86f89bb6339fec6a5ec6e674d0f44ca61e0fd2c6506706dd44ac766ecb8068e43ec12f047250cfa4401227954be39f5d90f37bdd70c4661bab65bf1319c118578f92122fe77e8193c5cd71b3889d8fa1708793f1071570df9c658ddd3951f45ced4a860c14e3caa465126335949ca390c59fff33ebc1d11ed3c85e5562c639a0a70b007715d3d06556859ad7c72df67e298c390845170bc8e006ea57dfe8e169846cd6bfae8fb71820f33ce6b8f171f704ecff44a547b1800216a3f5560df85d520003c02ebec6ae5178ddc21263d0297e69f930d72fa235f63f8a9ded0f88496c1d8b8113d312697b5428359e8b9ace129cd16bdee8087271d007e9aa788c2d36d7b4dbbbaab7ebec5580439dfd6841bd546b871fe5540165a50be48616e823869b6a53279d24dffd7e3500e56a87f6a3539eceba79906e94e940670a2baa606ac240a6130b1f16b7b9b85115b9a32e81c0f96292c5b93410f5117c52485166f22ee9a145b424dc0d9671b8349cb2931af35510ea3e899b75b796039d27d5360cd6a7daa5dfba2a5e102049fe149784482510be4b94ebe7f21b6a604eef2cb06f38ac24bd0900fad212d212afd2c00af0c8c714683ea5bea614a9eaa55878a45a0a80b0fd106fe675fafb0c98329641ac03c83ff6fa5fb57f39d885cd0fc4a4cda26616fc7c980cdef79de5978da14aab3bec666eb8ae00b05e6158dbf707c955886bc67587ccecb1029e7bfd2fc97e30326d6328d65519259ba1f88dc30813bc8b06d0e94e4cb71ad3a5a9091e4ea6bee798da9332e67ef544144934dbf5c3eade55d861664804dc240fccfba69012aac04f7d045a564d9403712465d747b0f5eb8209535fa7f07c13b4c6f07191f8c2c4b09e74d8993265062f24672b795b4fd0f160da5a66a832362742437c2c51a6315d2e091303f1d7fe01422d23865ddd9a1732142f8d1e34ef31119e363f2e74e53fa2c5301b50a12ff7466f878a0233cab961d9d36f81a87a53b754ec69798d476be61432c067bbb6b2892bf7d1363d64efdfcab1d8eddb65dba0d229475210cc0f5c181da3095a1bd8b77daa9c1ef66946bc48d78a8f67623ca0f5fce469e820f2a4ba3e33ac89ed69fb8fe70d55911b5f85ba6fbc55c076ebbfa36675df9f76c799bedaa99945d109892da37a587049d4af2138164c898e511b6d87c89c8d56ad0a6fde6a9ae730d5986b13f5140de2f6c8b551a1e03caf3af61c4073f768d2473915e7ea78dd1cfa1ea312d71666d31251d7beb3a0f95c731f09cd7bb312c67e031707c76171c2f5acba3d2fb8832290e81e37bf2be53522c2a4be94d7bafc720f94dd2eda93d5b2c382f59fa18462ad96e073424c4a6a44de1545ab749acf51e89c8797dcc57781996cf340140e09687dd30d2b3d6020c17cb091a08f895762a311f2ea3f4b735f9a0c83a49a7af9aaf621c4c6c8f026d1e85be6c938648938a1d0d25c4bd19cbff42cbece85e66e58f67c0854f9be99d4b92f38a0129a8520cd49e8ea12e8d54eefd6a09c69aca09464ae4f3de2a104622edfbebc65880990642253291cbc6c6a4b99bac772e6c30ce05a8dcc4e09b9a1b3aed206d81196c1bff117404517192fb67d6884b0fb535dfff7a6b7560b81045737b2e51d0312f05969e84d2ec9fb00117269d471e7afbae31a63126a0fb20df487783b73f7f9cdb796e43005519d099c2c11cf10d73642a10af14bf2f18b3eba114cdbe4e0e43fbb4335d9503d2d977973fad68af54f5f0039a2558761d2174bf2b3204f316bafd12e471f0f074b0b45f6be879b3c2709800ddb5cd5e25c2c5ea046f79b279309720b262455536ae3487721aca02598c84976bb9476560280224406c11bd4e4c18c1a2cfdc4dd7d6b714fde1f98d1266b78865ec5d5ea45676eeeb87ac817b0dc1607d4e914965ccc66574d06e0ebd6b54a0dc06251208f78965dcd39a50672a5edd238636d8b6e21e886d77c294f331cd22e58f75fb2c8144bbb9f0daa2ee590a08d549493eeee5dc81c36ee4fed11c7d9d04be9b06c467aff02d148ce3eb7d47d3396ef4194245473fcd00382ff4a7e202455948763bfaccb2689c2667c28bbcedab6a20bccd334ab937a3a5d54e6755c5d46f97ac40c0cc9d5a5321428e75ec92e092b456f2fc32eea93aa9dee49c220bd90436c73a1a93d4ac2aad6466731beb263e98abfab943b80685cf2cdd566914e7dc8c9a7d9a36a31b69493ce4c850150f5e625d5378c6cb65bb88dd5d37f87f1608674cf2d2db66d96ed46d4f024248960aaf103a606e00f692d26a43d05b1bef8cfb22653348be87c5147e6497c4d60f5e25043be90eec1d6469ad0b629c35d2929053f6d8bdde16312d47e47f69a9267f23840dd07eeae57d1c11b8c7140a4b9f161777e24441399f64823bbd7a1450c4c190fef8c10d978ac02cfb08d2a855c0b2acf4873e653f69272817fc6b28021f47bed27f7cd3edec199984bf380b764f6c5a44a144a1bff45beaeb7845efe944645aa140cb577608b3afb459afc28d0d705ad55e90aca6bde35d4623aa91d9da6728ed49c6d39f12baf14f1a6b5bd44682119a5a57518a9ab8725a35ccde8e91a6106a88df2535a767accccacdb4f0c4fbcbb4ab04cb973d04bca23b36a422b106cc20528674c8955560f894ffde755f891a8a687cd5a533a36818463d50168978c8e34b0905e6433bcdb5f72d90c0d91c5de62a6f2b35fb819a066a99999dc7e133f4b995aac849b811620729d892ad928a75ccbd726239e4fffc7c77f766711ed1a6c18dfba500c79a65798e27a70f351ffbe9a37fa9a2833eb1e8ccbcd802b2cc5f27f915e19f10c21ec5ba976c955edf1f92e84bf9c4cd3ec9dcf64e7bfa4847b82c929eec924d9a53a2b67402450f7ecddd7655547e74239f6308a9131bed7521e28265366e856d5c65b3ef61b1dd4c6e86490cfc073753cc2481bf6f674a55e375e12512b276856150804f34de3fbf15e77366dd8f2d61c6bd785290106d11965780ca2cbb07e073da4cd6fb02d8ba017a26af08b0af51e6258e594ce0be4db2fe74a7d99e2360f1b7690fb4212a6117c4740bc7e1e3bdca6eacb8960ee7a78fc2de81e4b974ca77f5803d07fa797b652d53aad0c487f192d7b390b44eac18a51ad07e75781b3da39c1b7e4464594e3bf8d4872eb4bba15c03970e190aff7c973b3e0a641364f02c899a4a430566f53baf7e842e9506d16d1e0e64dbdc350a9052a1845924191f0ffd7016370765eaffc10e5af3eb878ae5901cf9415bc316893aabd39d237374bff072813463a691e5e8b17d3b148d1ff801005c5e7df7aeab3b37fcec7d98592811afecf8c56e500d2da823f1d78e43fc48a66b8e714604318221e633da5286539d8125377fd026fcaa26983090d845d11100bded1cb073532ecd578d3b8e8c8e7df014396349f6179080c0dc4647b5039e9aee19fd69c615b682a726460af75f9ae3d66eb997622973b7aa428910332fa29edf3e52102d5d9042a06fbbbf37f19cbf6f0120034732043dab5e8ebc273ae5fee37d5473b0918b07e200284200a382841f853cc75b4db9b157eee69dd11efbe2b4707849e5d36883ea4df95c7d0be0b9701c3d54b661c89e530abfe08d491827bfe50d74b0a02ccf02f669ac51fffceac44f2470b3b2f8f6e972e6687891b7691e9324f6f16374433d36f3ecaad1a076b467f2a76150b969c3260c8fba82f79e78f7e3a4e8d24ce51f3615c30a847dcee1575186c4f4cf17530bb29e4df2d30de5685fc2f8d5d12cfdc9358b26e93e447f6dd413fb303c66a585ffd03039e86d9023c787ccf418c012a28d173de483b9c48c8740c347519ee43cb3ac0e879d9e965e26629b45786d86ccf60fa4518aea7305cb8f6d4696cd79aabd092cad2d62465cb1744e9a8041cadfa54b2f0855fb2f85f47ac7b9b780559e01b61dad57cbc4b9d66118f3381bc322f72a4f3a9a240d2ce38ea78ee8a8a0967c86c91cf74e7189ab9ef74795076c76fc3dbd636942895421a01cd06527951f344612f330b67558974159d7f17a03856a871e583d4738f3a6cb31478cb3416f772c9527dc4c36330081e2d646df39ab30e6dc02a2a2024752a15d00a3d91efb6852d037b4443ffbe5499d950b73065ebcd72f70f222521694635c2ae5ad9b53a92f69d022db2d6f896c447798e602d1df169499248228ac74cc45a76108e32d481ce8debd5e1750cec6b85f41ef34ff6e2db3c3ab8130e6d4e918f906b8d0aeb7e0f65c17c25944677c0181574ebb7394d71885a31d2c6ca9e8d7715c9fd0d688e61bb7ca74a9a87a8975d8a2a8f5f4314231fa98981cf98425ab45f6bd6e2434df638f1b2c65bcc5989641de08a6b527f81230be79e99daca1d996e25482356182860b4f0891a89bc4fc68dcdd1cdeaab5be492720e56d4c2ff2d9a16373ae0fd3e3b991232c16e47b6d2f980629204725063dd9811be6bd9c5935914013b033344cb87ae8aea81e8245c91def2672ff5a72ede5f3c7ed6126f2582889b3862106fb04d09f9d0f9f4b076255b382c4dd07e6c6be93f872726badcc16e3cd741866e36a9390c74618171a8b72341da83becc0c89f423505028239b11acfb070a042e6d7fb124bfd02be5c333df56d25dd0bc7993f09f71fc476cb7825c81435c31b45131747d4e4fa3e5c9009c8ab5b7db49f431c8df0a62820de59d5d867f2553cad9f64c817b213bbc952dfe250cee8628297d85ea55a223e85674ac06d967d87b0b7886347bfe11cdf339936c45f808590c341f50e578a0d6e674993581854d611e51b129b94f895052ebb1ca4b3bf7b8a4fa2f7e3b92e6269005cf3d7af30ddc83aaa64004dae34fff48cc626d5504c4145d920ad427007469118c802b314cd80898004771089096bf768a25df3312605df2048cabb87c6b184857c66d5f67d965fc377baf17bb4c220fe53d0121ac362832720be93e427ff504496196d46aae0cb247a5c53be9d2d6f1104bab32b4768ca175a32259c74da9c7dc997d3d7ba170fec8f1afd2ac71c9664f18ca67534844fc012dc67b47e59983680eb081270427c88771901ca3b93c8d03943bf72bcf4af6f63bfb6c4052791fc8dad7ecdb73a97309bd68cd0c4b470f18f53da8197a0a064bdb62ba902be3b5e6733e99aeff61cf32570611b2ce22d4925c6007f2088ad61b78943229fd28e0270d8825b2e6d85069369391f8abbd239e96013efd44a68a729f7436b1a5aa77a4a055aea24ba1c134c2422e6c93113f7694246ad0a7062340edd90e7147468b8ab871ceb3859974583b535e73680b7e83655f5b31074c9cfe23e1149a795c1f7a5f7d31e9a981242528dda06d3e52ae425b3c8a6f3d48b5ef42d249502ae9eb8cddb95fc12b73bbfd7707ed385271c13bc9e7ac7387a34cefcdbd69ac997e6774bd8b458664376399f88d35b4dcbe75f72ec2ed6bacb2db91f2620618a40cfd1fb94cb0cea039e3f115265cda3e7fd16f35070bc07f40d677f8f15dba3057d25a67c9b73b5fc6f0c37039428d81b14960cde4f44b0402d4f7adfd9baa16ee8fc1c2e748e1bd8e9a1513be5a08302a44a99650158d3778b0852c586a150da7463c49b69e90d5c5e0eb5ec949ad48313307287cf70f6dcd85837309af532ac6ebbda03a32da1420569f5c42f334dc78faed28f8f4f38cf35f37655966664a030e42cbc699c53da33cfa124323a935b828eee723f2f83c761e66c84c9a684e3771125ff37d23649e51f0ae1134ab840822d0890e8db090041130225287b3ee832b592499fe7cea59189d8390526774aa5a57269a9908ed886c553aa282ce920c569d57cdf54605f230b6ebcad306c8704bc52e28578021a35865139c6e3b27c7236de4361fddaa2b5c9907fda75e82d9055f1ed134482881dfacd77e9b474575bc540b62adb04e299e64b0ce81df2dd7e81282cd2f8498a4c282c6177644aee455da9f781f4d778495072f1fc607586dabfd26138597bbc50e6ec5a9ae03fa99a07a43796d089ff8ff945d9c8c5d6519d9ba973782209efeb3af35fac7f397a3d2307d3c8fe8837815102e421eca522e702c955b247e61033d4cd23c0c9cf1aaf69273ff67181f31943d09de8ea4af5407b578e629d21ac08efa4a146dd8d428e5425ec81276e2a205d76ea5d1138fbb905e6f2c439593e635b80b9ceb2b8ef28dfd63edb1f682c93edf3064ba52266a68a6948dc0e9c3850d62aff53da76bf9f929d6c4fd4e569c09743cdb1663fc7732881e7412b59a222b412d3324e9334dec90943b1e14dc013576886f2d3b0ebc3ef13ba975cd9593eff345fa703d89e289148a2247ad2cfaf50fcab590bbe5bd7ee3843bdc70b6b7ff0369d2c450435597a5dabac1984c95521a2ace6ac448081cde6b8a6de740a10bf3b868e3b3005eb4565cc511e3232fe68345b3c4a854ca9dbb1c9b53b734fe283c1dad4f41fe7ade8bd7e508c8a8392cc66bfaa6500f8188c468719cecff6af898204f83d7450e6061d715bfacefe976302311b56d15eb33f87cddc5fd7da6868fbef8cc097b3992b8ec9d808ac753473aa41d685342da7eb7502e291a451644ef9fe3bc8ac8f3e87ebabe11aedf3c5a2106fb2bb452e12cc00488ecaf8e4a3003539a13bf7b9fea8f42f918437e6a8f3a86274d2fa282051340d2914e425c7189a7bde9abb97164a4d4e1c334ad2e29c44741e7e277deacab5151f7326983da994cc86a98f4e4294f9161f40b027847a460860b0396b1e7f23a4735428aa4f5088a1015c41b659cfb308048d9fb2253d25606e2486754be251466ac6f2ad9e34a7ae082a30e053ed4e574f7fb68cb3a5373dfe0e8cfbbc0fc88baef961fc762a38fe9a61b397810dde68c77a084af9055391b07b70df8be61ad38bcc7af3dc86d487ae5a0c76e8b09f68c68261012c38480f473bc4c350d22f845bfaa3a130ff61bbb4b567c225e620a462339529aeffd984b6ffcfa4dea548c6937b994e32bdd52d68ce070a27f8f7436a79cec981b3eff4122a7d6b28daab96cdf2355803cc0fb892cbb2e5bf3541d77b7d4b9218ffdf1c81e36773a6e4ddd7e56dc86606ac17478ab9b3479e585c3355a93514556104bbfd9cf532c24cc58d8f6e63f6c08cce8e1c03ea4c1a346bca44eacc0048e185867635f5bda54464253bdcafc5b0b24be0dec3dbc9b037f7d8e4d36d546eb64ea36f20fed73cbec5038a025897bb6c26b139d6a998fbade6758525282f55fdb2ae20aecc553f5c023513dc6e819b4f64ad1765f9d659fc396b797c65dbeb4ae6d52205a6f675ab4fd42c23822f24682af6b30b80fcc05d0aa9afc5920fa2b91586171b296463f5636f9a77fb3a58c2ecc249716691d6ec5554c1fc0e47057496f8035f643fd716f8cd2a41cc3af592b3f17c0110062db18260f33b1ccfcea92b608021639a3387496c089727f4f5662c5827c4c99f0c787a1e4c8835eac8e83347800a60a616bdfc4488174047aceff390485879712e096ba0e6e13060af6bdd8a203099227a35cad027d8825895839555c958598c2a4f298f42211f1c6c1e33418bc547eb0649d68551832e2ecbaf6a8db03d9cdc306d05512a6de97b9b571fe34fd6a638a11943a272040c2a2e6668c5d0b5e06d0ce3174c329a50a94d4e27d2eceb0dec5735bd0132f6ce76ebb71bcb7f49215fc3e08eb3e80a583e56138cbbd91a7fa649ba9317ca3de8794872a806be4f7a9a6332c3767316c39e63c7f1a5e4b323eb02c04b8e3e79176b96238d9c6feb16441682537fa327136a779106f8a7cda4912b209d97d2c9c174405c969f094a58136b7a281291f5335ade6e3a5fccf879fc8bd2e6c51f7e5821cdf736a62af2753e32427525b6bf1526f888f35acab125ffaff04c9d4a9e31075e6c69e6e6f78b850eb4ff31fb2fa28ff53d741343adff72f4391d1c552641fdf45ec9c80a04c2d2787af944bbf9a20e2cc14b79f1136663c40a32106c974ba590a236f7adf2f0e80902215355ddd8c2575f9b280ef13927dd2b91a74debd767f1ceb4a7280b980f887f2e501028cbc95b0e0d752a6ad65054c7c0f80a004f693ce74e4494782321100080b860bfd58546addbaffb2ceff40b3c0f2128bf6958cdea92e6634a61c74a3d42d1df890403a32192423e6642db13fc2c008eafbc1feb549b0b4e03738fe04fab3ce3df1c5b1a4e7a6a07fedf0130c3023530491b8e066b2b4c018ff113c7f9378e5d3dfc893b8f056dd3de2fafa47712d44f1cf35ddae9f2b3148c9b30cc84c94156de176a0b96827e3b916f3a5f08f097fd38563015f293d147c06855fe741b92a8656c8a9d5108b4cd8140b168ac741829ce223865aafa048e0efd5b46aa65089e3025c56a00b4204424d1d7166eb30d0b555c946acb0df6b7893744ec3e6af3f9cd5616101a2d35e9047cf2c2694be16632ecd30252d7ba190cb7911c0ff654908e2a3978f388c8c0231131255c2ee13e90a9a112d4289ac6de83554bcdd4e45735b40bf7ea1d4e77fd26d95d9c19598e41507045ac0f76eb7e16c8145abf6b010ead2826f083ce569dd55b47bb491ea1fab4da9df23f86809d4527e1a5ef2cf541cdc559bbaf9a0346233ed4897745ee89e806302a3845cbf04e552e17bb99d87fff1f7129de3215fbbd583f2e0da46cd7d00e45200afbfa28edf1fd7152175a92b76c2ef9b054afead75660bcc6dcaa15fd8c282cd10644c1cff1b51b719e5d2d4cc0e728dd2dd012914696d245c5e96990c876ac83223b26d1d5acbfaa45c6dffb1c172b4abec09566b83f078203548a0dec49c6b96e7532c901163a521ccf1a565bd2b099b2ba2622fde2d533dc81a90efb290c07fc449911cd1b051ed4c6bbfa735c8d19c255531222bee734408e0b1fc94a978a049c6c6a93890e986999f9454b105eee4539a532a67c7979de04e20bbd2e0a71e867b92dbb28d2946f71cb0243881df55c484a9e42a3171cba8880b63c21ddddf357d577ed522840695baa815829a4de8a0a5b93689e37c57aeb92376949cb06f9c2d938525f601e852777766f976e0ab44451145020211a85b10a678537c85f78bcf219df786e15cf4b8522f7f9ae8d160ec6eb1d674a9d5eb9c76e90501f90e56b2e4a4c593657ac663a9127ee54984ceadf4905def4004aed778cc85ae4295d012e0a7b6944fea76ec7b312139fc760392b727f84a95fc853c6bead5ca9871ba9793535feec7fa63ad2b2bfdfed1cb246a78bb934f6f3cc4aca037829ad9d6de88746e8c06db8a311034af73d70bfde207792b55bb0ae7190b130686cfa4139e6db515aefa0e1528d4c574b12775507de4d43ea6b96f2abff74da5210e94b869eea416462865710e7f463b53c64f10802b5772337bd9071c54aeabbd80fb261299db8f931f2b5f915935fee04e03db478f759bfd0f1593f707ffc4869202d1f4bcef17e2696e2b9bbc22c164c92bb5140c79f1473a0b51ad990e8a30b2fe276024f6ef21d02d2eeffebafabb0a96aa1f158a01365fc984f1f77050cb7fe688f7521f3d3b5624d58e5bd95fac90d806b09dd79994bbecbfce90ce7513c03fc6fc8a3944514ed80e11d3c4c7198802cf4db536a47b0e6c56c6ff7512dccbd7ca210d7279526949fac0145eabc3a6cad08800be39749329622711dcd0dab348735f575be490c493d252b11351b7fe2083f9f1be7fca927b56c4c0d5deb0f1f9bd173a2220cd3c88242afe085c2a251dc8243e5508fb17c4fcf00f465307832434d2f8f547bb36c1f61b5b3c17f0aef959f28f181b32569a87d2c5650b0e2d0adbf2ad18fa07dad4d62e8cc78673af53fa9036d692a8701fe879c4352a8e6801c5b7cf1dfe216268d02745f4317dac619af2b41806017553ff91601574c1cf7d21d019b2060d2cf8473933c1cf8fb47f5aaa4f3feed456170d353acd565e71984d9f39b347e8c37c1b4f1a5f49d6f32eae38b4fd2c1ce9d6e6edb82e3a2eec5a5d2e73f86a1ee9d3360cebadaff86d6f2ac7f8a399ea1def72eeaf0151204ba0b071781095624070555b40e3eb7cf9828b4521c56dde009cc9cb66cb7c4da429b552cfd4b4bdf1fd247b552e360d9bc90c691c8c445b0b54a2a59d6c981d0448692a04cea701e07ab5221cfe1423c9e5fd95167659842ad69aa63a86612db1d5f4532325d743d97fad26a0cea5a5cf69e8aaefcf0eebaa447bb1ebab16b5439f0168ed034dc9723ab62bb30a43dbd2af27d71f71a9760174b3cc492a21ad73f1eaf16b07d8bd79db0605ee3ceb6b6a65da1ebfd367c28eec02599f9bf08d128f0c6c532c848dd83a76781c143e5f90d3fb8f0f8df1efbab7712d542f742082bc4c2c2346c856c1300ab2f52bbd96d36af00bceb81dca9c95de70c75f96c4c59b57d509ce87946f2678b434894108e21e317fa93d59e7bd9393d1838fcf1bdcea1975db1d0460e36e8157c486081ee27b054f052c2d58a5aad6f10970d4dbc0b688d510d15981a2606f575343b6ab8638170e0c77f6bf00a64e0684b5292d43d3ab1dd7bc115574775b595f9c9aaebb791f8b7639a3a31b1d3f767675a0c15910a9874fa44d056f11a95445bb35f4390cd448439cabe9100bc3d6980921761527a3b5fe5501e2474349a4ad53945164e34df823165d6b5c9927fab36e8577714fd06b5e18a636126a21ab75a918b6ebb051f9cf18dcd541bf3d0973ad7ba00fe38bf3f4c51c445bf8977efbf49769b2be74f02ec822dd1ec3af80eae01f74f3dc2a48bf0c8f43c2a8fb5e7b21c13d9667082f3919992cc912677fb8f76609d3ff20c1c2cf5377869833752189305ef2eeb3eff25e0a6dfb009e9c33094c25b39dfdceee3f9e60863776e7af5a45c9395714d14997749d9dcef34ac4baa540404ae13d6ec642982093d471b393e12eb8993ba579ec44c7cd3bfe51d250bc256af7258f74bee85980ccbb385923607fbc7806d6996a57f6deb46a82fa24c27409e2521d01514e1dcfb421e7a655d1d8afcd305a14a80a08d622e0401fb7ea884b67d6b458f4f93cc4b5946c3038d9a88a6318ae49846c27580e5ea46e881aaaac18d7188d5cc6cd13f9e38e48b36bf657bf021a8688a05230dfd6e0191930c0df5cbe7684a5ca4ab5414f80d12437ad263287d7424e80e4ee1cf304fea4822a33d14992d20511348bf2571e8f1e923ce7218ed76f6be00f8b6d8f90f6cd21c04a3eee0d7b9703ba4ca3d3e90fe7e69a895374e1962bba37fbe0b97ae2d8197296c367c27c8e18db49b41f724b6d65f7673f0f9a6219759e32ab3b270b4df6701858253e0033cef57251e0a40d6fd59a988aa54851a08a0d5fdfe90b8750997f9b4cd1b8aaf2f9883919d3b1f0d1c056cb4f15b87b02fecd76ded4090fbbd7e03c558162d94db9c478f65cbac87b7f3dbee5bc5e314502b1a21b9cfde8c214ff2eb22634658768a0a970c7adfe8af172d19f00458d6415030c1d81a12bff886e7083c0766b0736e3540f31a6df0cf52d0a029acfb6b8750bd1ee310c94bd9e110282612537eff883d689276d70a9fccc9f09d87d975b3784d8001f3ce6d8440d3a7441358139af860ecb99c3540b53ae147d5c3a893a226ba16f5fd150a3a560dad643952a4c4ade33d97f2f776843720b3d4cbaaf663f44087530340c054e8974342639aaf496a9277b453bd631cce099ed318cff99affd27590f5c3fce5263987631960fd2a8fe41e929c769e06338aca31f54749a7551b38b77b6894d427f35861d6c325f0562bea5d561aeecf65ba388a566423006085c7e882163322bc048061357f1d951ddf87807758356ab8e0161616967578faceac6f3345f1b2f862c4539adc2aa49e266acbc61e9aab299a27c19e6d60bed5d80fafa3f5f6d64df3629b0887c0b6eeab0a3dcdbe45abc0a7321a9f1776d389cbe167b6642f00fb018d701c140c01b3d5f9a57cd374fee589be1adf1e4909f83ea094d514e4aa7e6e501c6e841a9a23262bcfaa5cc5491583c6ba18963a390a8a2d63fba3865c508e4b8575ec9061d510d4147b43efdd1ac822aaa58249d0464e2ee4abe64e2d199c41b7dfc340d54ebe72102c439b8c624f06fc10336c18813f566fdd9fa13585a6ef3c414377daac089bd5a0747b10d289bab975e7367647caec5ba19b7788831b263341a02560ba9b636f6300dac09fcb06496d167c7b71a88425f4c09dfd81e251920ec6ea234cfca4984246bc7d357e2391e2e89d53b517bbbf8c8b29762ba10da8fe24faa6221d1ab3044c744109e77e537cb209b9674dee340e9cccf631c55f1820f0f12053807d7b9df85e939855993157842399977f8d36883a6b079bcd8952c0d55c4feb8c0fa1ce5bc3b87bae2b465bf68145992cbc1b1b8cd76991c50014b41d16b30b186a816baf75ae1eaec7f8ef0fad26170ee6038de0d1c082773286442003700ab39f93036b25c3d55479bb4f81c85fc2aa8ed828b8ad3bb893db6c97364416c9305939db51afb533d4f616b50abfab9fccfe7ac226e417655cbd0c3d543b433f610a7ea0644172fc10e175bcd4fe798a0eb6139137145f0db1b5f35de7e5993de1d48748690d7b56f6c848ae53c8440403fc8a742c2ddd14736c175d3c59eba6401f068568e00c9b81af4c3b5a6ecd70680c526b492d66cd270c2f49c1a7cc00a365ce57490405d8cd000e11bb189d6ecf2b3ba944cacacddd8ad40a79b5a0afb073056df62162c4dc490b79785c47a2b233ea6e765bf79218d6c72ca24a036ed4d7f86c6c2d664cd68bf7dec177d4a69b764bb0b70a39d69f25db12e1f40547d38e776b75d66308dab457cab9e4d859da28b62852a579b6b74bdb128dfdebac80dc072d4121d338e7c367f8071448d0b1d6d46d81e08f7896239a61ab39c64f3fd3253840af970e98964d1b808a538b9d973250a097f0bb18864589439f443895bf7af30f085b79052dc8e063a0cbe35a1a6a20ead39d67ed3f7dbaea31203799906636fc9e3f1dd88831fc4653a4e0cb53a0e338f7cf24a654561df85e2f441bb86761275a46664e35732836f7306a0be45f8e0814afef4af1b50196f49668c1b40b5a7b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
