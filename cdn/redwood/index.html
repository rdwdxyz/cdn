<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ecdfa25c4bdd4b8923e0cb2f955f00caf5a0be6a5d530b0863a8b008ae5a32785ea7256f356801267ff78920ded11fd1f2f26a9cf5253231497896865eea7ee99d119e4e347f8c431dc217e9ba7956337484a5b19b72f29e0b2463b146bab3a2986cd9563f9da6caec0f7a1d391a34c151cba28fc6235fea1abdc679b485b8e9d501d478e0e207c1ed2c1a37a25a78ff711710b988167eb48069e4c8beee2d8ebe389c630a62e54a11db32c54793be62d145ea2d7bf01e019c01cd49b6a58f5b367492d7dd8c0c62b67523403be841acc354e853bb4bffcf4d0db19b2fbf68424183666a561282bdc4718adc6e48194ff6c29c80895a8bef33122df82eca2b75e6abc1dfc8f57183b11246a0eb4006713ee462ddd5e255a95c1c59bd20fb6cc1945352f4bdb52641d301ce5da217b985a2e76c3fe779005e55ed3cafe82fc147aa631aba5202487dc9e609d8d175fdde9ef74837dc6a06ec2482328eedf1d27d15d8ddc2e28a85f5d11a4fcfe6dbefde06dfbf4765f7e779e765c837361686d05a831f992a5f11609ad9b87f691a41c1b3727f7a2df654ca614365c2eb3da2a18d01ef6da5b44d1e09f3b93214b8c9a03de778eb25650120417e29d2a01bbef0adb52e656d44735afb68cebbdaecd0fbd44938fcf6c94ff03a4b2e9b4e478f6426a0ba8ac6025ce921f30ff38d3e44279286336ca90ecb43a43df5d37ed4d18f6644d6c74a02c98953e27addcf4343fe65e2233dacf71e55ac2fa9a8b9d8fe76cf119e67454675caa20153a61c4219254dbcf1d4a87eef040097fd73882a13cd5cf0bb795709d3d1b5013b7ae8ed4cfa9a11bc830f3361228fc95273a530544e39fb10e6d953175d252fd15ef3878a6c305b943ea6b823df438fd67c32b11a69433e011df559b3745fb4ccfb866ab82e967c42115538f51bc241eff73ab60da9de760ce9facb2fe346f945baf9e484fb42e2102bde333875c025aa1edd3b404670a01b510bb357f26a15bade6dbff8b24c9937e4b3a7c39618ca0285dea42ce739a6ef0ba3e14d0d83ab33cfc448bf5737168215f94bda2a7905ca317d24115e6b1c2a9dbbe1a65499d585853c4f4562a69ee84c3581d38eed1566603da53692fb685bcdd058c1269ee6494e3a1ea4362dfeb3a1d3ddb18b50a080af111a1ecfc95a25e905fa8c4f91bf3814300af164c80ff6be940d10a6a271ebe0234b07ff24eb44d01ec0aea257fd5fa715bd798693e46bd34044980cea247b2d6681689af9987aa940d8238ac2fb63dd017fc2d9760098b048e5c06b0cb7f0bdfb53feb5673e64ead36f2751d7a8348613183a42240816e511dc0eff214f82cd7fb39fdf54357a0b45231f366a2d203e150a3655ab7375aad4939e5779b1367fba8cf5fbf2f9f4681de7f20814596b9300df1a2064f46e80e792532124c827935d83e245043f8e1199a81ac7138b75547d72e9eebe96d9dd13e57c3c08302ecd4acd639ee6f3a9ce5871a45b47f5df76006584605097e7b95441fa9a4060ec04a777353d1eeafc37129b0bcf84ca7f99a1b398b5e500e81b0fe99cce81acfcdfdef2d37815de49a840b91ea684102b0122f36246a8b83529242dd1e1acfbdf00a3cbe0fe9cee62458aec34ad1e12378db4ffe5aef0383f0538b729dcb318dd1ee09d2263aa8154acf350817b27bf542dd630e34516d13db13f08769dda4ef95dd755b206af7442b8bbb01f9e2ba27056d816cb5134410a659e84f362962b0f3bb62597b840529fe56e6506ca2290bde6690a05afd8c23708bc42212cb58eca6eb11ba82eff05df892203390b1e9d3c9f48903bff3492b19fd906db8437d9540e78be60636fcd91ba6fb6cdd72a38f8aeea6ec552853e6989da0ce6388b6f942bfe0d862e35df52a6bbe0a66152aa7f2f7a2c2d79992c17290cc2b8148a8d1989184325d941c42b25bee009ec5cfb4aabcbf1b44935f3ef6d4c895e5ec479bfdcdd4159b5c835485f7e4b0b91eaca0397d1c712126d8c15e748ff436c00b8da368fb86125a205140b61e53ad22243cd4ef2049b0231df855c4d3e0f1f986c91a113677a741d403b9aee49d1d5230437ab892a3676831b322244efa08cf11745c5b3db2964cbadef31788c7b523fe28deaa679070d28f892d1a46cf3259ada71406a3c3cb691c3041ae10cbc41ff61839385d91248312dff3201652bacf04bf87cfd8cdb21979c113564243337a1fd78485790bad21797db3b485b7d39fcb3eb6fc546dfc4e1baf19a7c9b384e7b6e61c2426d83d796c58c073af19a0582f3d6aca9d57e37e15f6b63c29d70788858edeaa2975a9051515f4ec6d25047e5576e788f28de4bfde683452d35aab1038bca43dea344114ea1bcc7e2fe1284497f336a9eb0c051da4c5fc92d0f7630934aa35ba03e35d8ab75f02bb61f42adff090b0642f844e565accb957144a29155ea9905c033394f8f7e4bc3aca4ab2702fc549d1e91a96e851f47d1b35b39c98d86e76af39c2211fbe01fdaf59eb5efb6ee9f6ada7b5f4c8389fd7ddceaea0c465922ba895757e64b438e98213ba4722aca9513e79926d90f96d3b01ba597f318830d7b50b1e89c834d4b902557540a10a1a4c4110fdff4db45666cb6fd693c471cdaa4081ef38031e34dfbc38ed8263565a726bb6597fe8fafc9e8d89c053556c3eb8dab54dc8474faaf3c430363387bd310ee6e01dd68558db1821ff3bcd4ce696062f5a648b5f3bd11be86f712ccd003482e01c7fe98f216f8299856e7d13ea1002f2702bbb7f980e394738be9b0e820db5eef53187b96d72f0751a9e8e9061c0302d2e385427d0ff804ed23442debf60aa3d18e76e11bb9eed4e9adc5db86a9e2524c599c0b9f79f57910af8be319d4668a5a6fc9682cedad84bcc7b7aa3492913fcf20060d763c42b74d58185e43690048afd44c4b5d3dd8a1fa4837b8b4e949288ece590966e3ff96cceefd705aa79a94eee54b69930a66f484fb2100f88c5992abb7c0be88448329352fd1ca66ede7903b09ea4b5948dac741aaf019ea8316c5ad1e6d42069f8e75db5561807b5c415ff63ff5d1d06ea00ee925c796ad951034ee47044a6279982e10948cf902cf069e345131a98edb5a80870d1f8fdf4d7e53621776614be222c41c50ee1b5e522897fecbbfa7df6cbcdf773e9fcd8d6c4288c7099ee300a6a75b12947a785ae2cf5a70ddbade384ef9b480732208f8ac2f406bea97b77f76087c1781d6e26f6487d8684142fb2010f1e01fdc0e4caf380dcd9a7c9b4bbb2aecdcdd0d0a98eefa7b96fe3649e009f54e9c23894a17337c08c449ebdfb8435eed54494fb3af422f62e19f246aba1c6ccb00b6d156734f611e62aba3534882adc6eaf17cf8e56aa70f787343d1745800bdce59a86d10c40a5feb63121ed4f3cc0f8370e8450119146bd59e2b3892c69d65126eb849de59ce85e3f6dc350b2abaf638b6114f40167bbcc055b1bf54cab3dc6a7de57f5c0e61eeba2127e9a544f44be78f50095e237702d3f155812ddb3146acb8d52ffe9b65639851ea52edf256351df931f3d4b6f5de60f54793d6d18132fcb92364833440bf498301d6d34b3d22032f69646a9dff0a7e3f3e8180b29822042d3e6b1d6ef1ba7c7b6b73c09463c0b7833269fbbb1a514d33d7cc6f8f0ab805f421a9b12a694c6525e60c72340e8376288122c395a078be3012d844a4e9d47467b235e093e3152aa7bdd5b82f6ecceb435941cf0c5cd4b4e4d3c9e63a777b42491012e214186cd22d83cb5072cf11e298d5598bcd7b74dab665fe9c7db07042baa271c8b3ee917d02eec9c69250a3e398d0d0e60ec46e5754d2b4e690497b72f84f18067ab5b0dc9aae89c1edeff77d449ac8092e0f7081ac6e02dcfe4c05e722ee13f370a8f37aea204cd52ef5c08982ddf7d23be817775fc6bde5c3ce3c461d7b9faaaeec4f934c0ec62e677312553c49687eb29cc9eb1a5e8295f01e3b871c1b634531690a8f84df4d3733f91d937920ae3313d71d7026ec1a3766673ddf48cebaa87ffe2b0adbe2da7e6f05744d0408487b7d9376285f8e9764e021eb3079136fb42d2f63bfe680f24d5feac1223aef88cd45fe2221cc3c90ace962c732f1573081e4ebcdcc363e6eb3ebd05440603bf1cb127a337290494ac1c3cda26abb9be99c1fec096692c9baafc748b3417e401e82c260fb154fec03406b8ae8b992f96eb7c7e9d6c910b2c82c10a9add4a80e1a9a4058bdb5d374bf244c529e28f0ab4c36f32229370366c0a3c7442d19028fe7bbc96a7733c393bb1bbd545b1a44774d76e173af62efa1f90eba8fa3f136c90c5747edcf57d7629a89a5ce43a35e0f8fd740c99ac005e549ef25d1725d6f442fdced01eb84dac90f6c3184aa21394d19c6f3d6b4c133f44e2f6ff3a4359054198f31cb9f72c94c5bf484159ca901d0b4230bc3377004af181e18af215ee9ab9cf8628975df8e73e228084c7c25f35d51c523d6e84c3def43c2c577f9d6b8dd5284a9f7a2d2ebff29f4d5fb9c9f5f5257e22f55fb47e3d7ee64b2b5de612bda0ff2d01835b3c1e9141f4e2e8de0b9c4482f72c778f3e1432f5f88fc58206531dd266d845150000b26936324e41a175c8c67f3c83f09bc35d8d6b8139c70bba41abb33c871dd850ed0ddd6cab2d7a9f007d3c3fff2a352a6bba2fafecb7324395e5820aba6cf7bdaa888bb007d92408c57bf8f85a783d67d12ea079751daa4b267610e186a7610703d6047a53c11a0a9c3a8b2b999847b2dd35e5728bcc2cdede99dcd75728d5672f3b79999345f62923cc258f706251af63e5f246a5ff0bac67c9ab796e8e53889110d9aebdc51d60701019e50f6a51407f0a8084ff96541659a3c084c49615985a10a86bf0f567fa4d43d753ffc9936a485a6168052c0cc08fd444ef810493e0786c9fe51aee4a1905fe1d6fb65539c08a462c74780b4736cf7cd9c8195c143d2b9fe674531140c20b141208402783a438dcf2af731fc3d907c6f409316b5f923242e16140fb2fe483f6fb374a5fe5910775cef80812ef7c463c26e96b15d9dbcc80f1550782e6ff66c7b056c2fc69958807f411f966b0bdca19e5e28199ade5048b84dbfee606418b664bc9d431df769f79ad06230cf4ddd4504241789b084594336bf0e5686367b396e98e76949dad9d3cca58094b2274dbae9c1768d0cbe26711bd9fac045d01bb422373b120166bc190bb0583b4a82b23f111f0ea8da5c7763d38f3449fb1fe762f3abaeef013837fbfbb545670cb01dfcbb3db0248c18514e484a8fd75803273792c7bc757a93667799151e0555bba09cfd410a9f9a606bb32f1563f36dd4218903684b4cc0e2b28ef094e6fddee1dec622c710708982256332e5ae9b49edab6866e621b28a024c70584e57589e7813c1ecd2da062a683a324330ebf6e70e331b95e0af5858aa278786132aeabc3fadac887d51232ed5cc78a3fc54966b6e9984a64c846917f1c5e8b61be6800d36eb4ef0b89b4fe94c5644f59f9d46057cc39cf092453436e6ae81e297a658f20f0b18d3fb1d26ec82165c103ace68b0b72d6e089441b0628c6f4ee2859c15c1576a14676bb2257c5680f1fcee945361b2bb07fdac45e07587b9a8bd7db5e547db92231b8a78aecdaa224fbf67a68032e06e27645fd44d57abdc197a497b4f266b9602fd3ad185bd39776c7c59fd6ccfcf35f7b7859148bc9494b08a635cebd857d276acca9b8bf5bdf909f8cad9b7048dc0b9e1c7acc7b4758bf61161bf6e8d3416a53a3b17dc9e2bb1df73902a702bfae8e6628fa57ab93b3b86cac4f57a8881179b0a3083656b530c45651030ce51e58fdb5c9c371936058beb2fa804871d5c8082d01a0660ae404ae70f39681e66e9eaa0670183af0d907faa378c33b2ad5d8573c4ca95bf9004fd8439d203095ca1c16e2f5582b8b3bd6477735ecfa5fddcc7b45f6fd74ebfbebf9aa7ae98d9482cc9a939eab31535822709624f6899a27ce6ec730169bf09e8059de62dcf66ae3d3069070a958f8159e42d4d556df25751c39ca97100779fb8140b3d0a3d4bf3f5774d9c5ee5ce1492d95cbbf96d97382ef332fe69cd1e8d835b8ab51d28cdd0cfa3880c9cc2318eefd3da03a16d8df437db4b10e26157a411a30e4b9db66f93a52db37de1692ad181883168435494a9d318914fd5cbe09c829763b0f6596ff8527034b470e527fa2ed634e2cbc7adc4533e99733da77f6b9814be91600aa651d1dd07e9b0265fab1322636a3d2341bb18030ba9e17f068d921e88596bb3fa0107a33afc98d2a060dc7bfa61884b3dc7f8516e4c667d651a77d4b97ca12c85c72172aa4411d616a9bbbd6deaf1d0f8e1575df0102e3f470f2b5293d981f4a4ed9ecb8a004c2661dc5c3606c081d04565fc83053e644782a73bad53b58d86b3aaed537c413ab8dd2a5dd4b831d83daf645193de74017ad12e6e88f55b7552d44e10a76bc26448bac3be48d246a4e490e3e39d8d5e2b7aed0bf77b2f86813c92549f425eda72ec1e09d7b78ec13e7ec0b5ab0a58023f45de2cb5861832a122b335bd1ab2607bcf55bbae36e6f4b9293b068f06380725692ebbdc71ad6a8fe6fc859a57999184b85195212cb2089468ce8c1e43a2d85c96d85796b48b32a7f35b41f495967571bb4e9aa5f86a874e812fadf0e0bfa7a585856cebc266c88a25ace81644c558b90894fa7b76e41cb0c6d742020e094ef665e37196891d619923c3204775632f82fdda416a480af4d9552da56e7dac29d7e463e206a2435ca99bced4b9acf9959558b535b4c46eddab089f365e64785d54ddae3a199a47e82f7612dd742abb96f64b1021d136795a51e48507c4abd5abf0440292f59b6af724fba78d31cd24a36d873e5bcad39a702c2221d3ecdfee50a102c5d22a8ae457d2923bcb831096004896373d744016c7a8c3700c8e5576e3f953fdaca3f213b70328cb6faf3742a483d73bec28d9d3235de0a316e310ac7e655d2e70b75b557c9f7f6a514dd994a8c36066f0b6027a3e33e3e9b1963c618d06d2f48640fbd4dca261b064c26816d31b6a243651c7d91f8761c2ae970835c30daeae1f9c4f6d13e2062d963d5252a8c2a1e7b33b563796cb34fd62ee333eb87f03ed5ed6a2291faf70b5c0121ec37a13ae759797e8c6b5ae3918aae57c5023f4690454a0bfe2eb2ab57083e00f7a6cd2a6ab62f01eccabb95510bb42e48e8455c2cc0f3392c7722b87d92c964903333e5648510e885279482245ebea0d4ca14b0b6f152768da9214655c86f414c26022c3b0cb3e50e964c0ebe3d58b95797693a4be202b9e1103d8b1ab15bad5c2bdab987b071245725c8643babc6e7aa83ea93f3bf7c3cd0b3c6e2bc1aaf0670cce54974db43b0a3e766ff0305170d713baef2dc3a95c4b0dd0e07e7d084ca5d3adc0810bd62d055336ea1e5ff89f2f6c10ee4070fc8874b05835b9e9320aaedd6ec4785b099cdfee14a3f939e1df6ff53a58b4ff8d3846194059a0c2be7da0428e46579135bbbad81fa76140993b1c731680f6fa82abcc69a7872555f8d6e5c5c391c9129694cb571e015ec7581ea21db7476fc42ffef444a24818d766f75f78813ebb85df1ca4bb67655ba443dab10394879cfe6ad830986a93ac38ea99bf7b9c7d0948d513dbc2e0bd2bbaefb49875e008f2e1b303463b37297423299b5f3c001bb539ecb637d120be07cbf4d850508c7b4039b9e1301894e3cbdf70571316fb383339d087a7676bbc6b51c979483146925ea5bf0ca111535a12111d35de8e10ed37bbe435778485aca682d08d688b79252ef7d1dfa99d366c9d304d6148ea79340e227fcd34bbbdd223e8dbd30cffc7784071b849fe5e919980ca24ca254cd15ba2edde679abc1ea47eed83c05d0ebe957927af96410e4e7478c4f58795fa3f9afe64a25ee3be3e9554ba48c0b7dc494d7955951d0928534d180834870eefe34af15368fa7b7ad62024ad457dafde3045c79f9e7e89cb64c0d08553f801e49e6326019f1bf5332686c47a342ce02e75e09150bbef125ab38ffee2d1674b86dabb5cda1c5b143f75b74bfe0e07355b63a26d62ab9638be606a6928964e82ce493bdea78e772e09fe94aa72ab3a72235defdfdadbc9f377ff516fdbb27e8eb2a637f6d13dd4745ee2823c39c8c7cbf1b76b2895dbbe1998c8502b00a5c0f39bab2f0c41efdcdfc2eeec19893873275cce03bec9d91e664d3cc894dc379c03fa3e76f82b275e15e08bf7e159c799f8be6712b050d61270b12699a060d9deab02c39fd4c0cff343ce513f7b3527afc25140db0e8bbc11646c7e0ededab552aa8c57d05d6c8be3a9809d78d47476f6fe9cb8d148c7fb8b3a91c5ff973d162d193a3b6f33e3c848a4231b63d2435fb502ab1ff8b1280180acc7ed79405c142f93ed2e6c378a0b2df57930ba60d6107c66b5daca7c9d670a7a898a308fac0f80849088c95167af60a74e8186b3176362235d5f76187144b4766c1bfb585e963ced49a545820673f3a21bacd04e3a92d9f70b759e467976e074e97333131cc462f4e4e2b7a6f39f620421766d765d996711b42102b911605a238d4b1199bb21af18f6ce61b606bd0f1035d0ae51d036d5651338c2594f3ee3965e29fac95be88724d0c70b2a37665c8d2da6687e8b648e952ebda1c22a157d979ec04f0e519425b9b176cfa069fa098ad5f5825d3cac3fdf191ed6162996fbb8a67ea5d37b670f26e7c085df271075de56644e7b4ed97c9b004cfdc9e4b7dbe95810d5f82855e2f4a1e9d727fc86a838ab7456070aa225b9c9876d0b9b3e95f3d618c793e9f6ab2166e51f546d0881532169b9a56ea9015cb5b18bd4f33d437570a798bc18008a87935a837ec2ac4b664f680d01ea151869fe6c8c4ce7405ad3f951a9efb2933d0cb82905b56a14bb4eb7129e1794ef89a872f84453a228a6eb3672ce3b5cac4c3661b47d7bbbb64bdf07a924e5b77b2d0b2107ddf6c6f75bdf1bb4e5049823c9e084988815c308ff5c81633e2846336f4a11421520aab74dd09ddc0cef50897beea0963f04738e71f83151bf13c0e93a3bb60853d6f52b76bbad40209f8c8f1ed917b2003c84a419a13133fb18543ff5dc254d5c3e5f1dfc0bf3d0ff85d08a879cabd9f2d4e9ad64412c12098864b5a4d9676fc3e7bf9cb3247c197c636fae1076124c241029a7afb2efc888763c593a76435caf67ec353ca46e4d69c5c2ec7e88fb5c68b07694e8794553105fa42c555eb617c46724011383c993dde5e0031c461eaeeeed2c5ec57072488127ebf4ece7157ed502779bd31f6e37765344657b61169606d673065a0ce139f0992596c50b86d7e0bf514b5c0bac4fdb96e7828ecaea58397911989d8950f0374fcea5d3591b03ce66ab32629b569a4fdd42d61198254afc1c875dd6c1ba075e38d19ea53be9e4eeb8eeb6e25550929f8b8d6799cea58092c5442649feb1409badd1123d89506a553a61223deae76c8391852ea474e99a1a12603570959f0e2faea410afc6562eb9c0f467737c7c3e13c59a48292904e5c6a98fecc16ce870ef7bdc5b3a9815b4943c3a620475288d64929c5ef08f1fdf4791a0a1bef20e436bfba208d08e1a3d666332cd8d551102010744269825ceee1160a6553c7c2ab57ea6a9da975961304dd82a26dbe0a731463dc1b6cef91c329bee2acdafd2857310de1113ca3411ec6638029b6f46c24e61718bf3c55d68b7ddf761de72bee56f363d7ae89749ff38cd713b0d6f8be44070877fb70ac336ff4cb755e8248102fd5b8967d61689f44cecf83e24b375a490b6c8b5b89bc09aa22f7cc89f2ba104c75a517d947c56c6d7d9ab6f9eba5ded2120ab4fc52aa55553957e30af6d2516cb86d54c655746068cbb969140c5abc3f824d3193cf160b9547f655224f4ac4e32033ae169100531296b509a3cec79f9af55ebb7ac84617562a1df42c0a18d9f27821e16feacdf7c3b4988e5084f415159b64dd7cd2669e54c12d25448a5cee08196452ff065508d01a84c0a54b765250eb665946859dc40b47bcaf5cf4e822828489d2d353b59b87dc7e808e1b532d07cce3bccddadfe37729bc08c97f62425a7432ce1c36a65af33f305dd5c906cdccb7677c5b19fec0c05b16e1c0c62d817287da9784abf3b1985cc9996f18c2a4e82cdbb65d85aef1be53aa36ab59bb806a49e04f7a853c03c61f67370e3837062da4b41455cfc81dc5ea4609159a0956da6f098e15a4760af9f9f6f57325fe5ba38cf40e8221fa36b6e4cbb2eff748cfc0672092af585b36a985c8b0491bdbbddaed56e845be4bc7f507198b88a31ffd0b43fb6b2a583cee77b081d5c86ad8b8a7e64b1db4efc55f15bcdf87b5eea0e4682ff6de021237068e526264f1bc74a775a26857fd2c5beb2ee91a045814822e3c3e79128d432a9e4b13e77b0d0677cea2c01339e0e49bdb8b47f722f55cca70c17e83b5ed4689fcb472dc2a7061f709f8cf3b2d608108404c8b11d179285f509005c222130db3c599dc0d5a9e6324fe7890652343d62ab65e3beec39fbb8ad52d1ab37e0138f9b5e60cb50f54ccf8df68bf62931e2d1121049b7b49af51bdcb5fc1119f8f188d6314b456e1c4da4d3262394514a3b2707f4fece1b59fac318b64f9f6e5141110306c3cfa73c03641733da98774092fc3dc8510b43e22fa552966ce17c9aa85a1fc48971c2b70524d8b135ad445e45af31b3f4f1bba88e7e650e3bb96ce6e5d3844f5adbbad00d3143ab89717d51b5ed52e8b87ed922e8511cc9c899589f6b0bf2bb2361a367d4708eb4a01d534b1b572f2db8138f4ba81597d87859f54eef22b5e23a67a49c27b4556fed62cdd30463e33b02c72b45c663388da6f22417bf72807e4afbe4c1b5fcb9fbe12b86e607f5ebcf7c09ae1830fc91c08ab4e44566e99da8fbf37e467897214667c6ce1530b133846ce1daaea0698d6dcbb5cda112694db5ed47e4805fb9cf109b7a8283b51b07726fd7577ff13703a07f4ef3fd66ea19ddbb5b66520382a657a136af33532a65c61588f63200f09be451945b3ea6b399bf63366514d5f0b46f7aca5c3aa0ee6112f566081df095e1a6d9d29fc318142b37e08fda0e19d303f154b6cccc046bf917222ce6a0be8cd0754346b2db5c401d06e0106bea881c6064a4ec750076dddfaff94950eae45360b5c2d85b9d7afc7527c0c51bb212ebeb028cc1dbbcc43d513a2a7253c8b8224e8acfb3b83c0d97ec4160b52c087cb68542b6340d448168d0063cc99bc2b72f35551a4dfc001ae88035006a1b9ba3e9d6aa2d8817502775ba77237f722fc4c7fc055e903d2ef22506a33d40ae1a6887cb64cafe0fb9b7a6050229d0e3dac0195b2e2ef158d6c8ab53e84bae96fc05f062975977002c0aa04b3fc477208df747f10824c415fec236cf7e9b9ca74f78b438cdda51ece2675d1fe85b0efe05edc502b05031b45d010da1860b7582f7fa935ce0a39f9cec83236e79b148ecfa79fd3646defd51136cd7bcd45fbd698c69ac70f46de9c66680afa5b18b20902ce3665fc156a47555d8b73ff13247c6e1ceef19455ba6735395e7ee2acdb10dd0dac41848492f34a67e32ce6b9309cb3187ddef69866ca83199e8bccf2862112fdf49b6cf6af3510300b7f82f5f4f799f7d87c78e8c337fb0abeee18a1d3c42f7829f3c2613a106390ba2cffd7bede44b3a97f3aa0a811a5bd5e2ac3a2986ed2823044954e8e3f5b485a38186da2759361ca11da900965c6ad80f0b927b4c12c48f60a7b1ddbb114bb3ad363ce08378ed347d5aa99467ecf2b5c951cfbc9ee253c50ba656ad7f7b9e185ea47a17c4dd7f9b8c537ecd820584bf0b3dd7b497a944821b67b643dc228cbf69ac9df5f20f6be89a87ad470d92403399978abc3d455aa0b88de804b92674a748493ea64d9d7ce18f33333099296e876a2093acf765293245b9122b37d992c746aa4a2d053b8e2fb1ca2d7ce72a23329d12c3fcc7804c81965263e1d2319a9b5e8a1598f223285b41489dab076b546d0448c687bf6468e0b706dab25f7f82543226a31b7b04e8ac4be37bffa1f2a25ba01a650f547db722450ca0da0f71d6d5df40145400429028a35d385e70466c97178d621f631e67e3f180cbebb95284c5eb297769f1d71bba0a016c1c83965d87e9ec8f84abd44d1d9d5f10efc099136b5ce71d42d7c611af2fcb4ef518a1bab4b788773b4ac2239ce4712d586498987b5f7d67202806c39d2985440e41f37251e2bea77184e0696dcfa58216b276b7476078869f4b2efef18a16ddbaea292fc3d9ac06d4e2ee537c1f950c82babbb3fde6ca280461e741b4d1f2ea4d65c581d3e3c792fe42e5a621483e5fd4baf1a905fb8dcffd5452148c6095f82551d84f4f86f6ee37b105dc14373ea4d6f9682c379ba3359e28ec17fe1631ba45cb043397ab19900e8aad0fce2bfd307d670f9e314d38c24c262d5ed355215922b79801e1871e1c2533c50ebd7e059329cbc14a428a9f706ad73345fb0ae9aee4d9628e4f0136abc178c90a139225fe5f030506b34c8e22be69af9e777d95a01119f71d9e60eba6b087f80ede289330252c11c09535b0b39112deecf9e2459ba50ebbfc87181ecf79a64cb82d3cf9ad87cd274b820e87aa96909e411a4e7974c2e3af538dfa1cc13ba1721ff9299615d6304ff733934e54641e126e6010a992244302e8c1a7965eb8cf6e252e19e9b1919325e32c81a5a8897bb8192645cd337bc2ccbb927d4eaa4eb3ae897e9c92b6435545e747607cdd4e9507b371d9041678f89cca776f9b9de505ffe43846c285114d1830ab815de84e4f9e8b8622161190cb3ddbb4a52111f81e3d85062c77e606448219b0aa5da984538761e5e3ce8c0070e20046bba221d874a8af642268e09c9d92726aaf14df2ee1a3af17ca6f752e9634f92a7ee2babd4564dfb6af8c79b5199a0784224d05c550349b45b72b138d0ea3c5537f9c6cdb27a805dba27c7698e4b6cd7f8ad366cc8620718dff2d7894886a006e9635ab684829591ebe31e5040e7411b419c39a7b2c340fb8954d800e6e62b005689a9f57e4db93471075544b3ef4e678bb375f7e11589996f454862c1079fd982a044478d0baff07e69c70e5359b931dc8c0721eaa1d870fdef42c9b05f496f1e876adde80f23d04e9fc5ea94a5197141d4f3461b520c506f97807ad65166b4ad8194bf6ae64bf33a088dd70a55b89fc8571b639193c29a8c964f9193cb87913d021307ef9a6b1c03370f76e351b1106fd3e2aa70c556556c790f6ca56515f003289861777cda57fe93b7486cd8f5d795cf1dac8d0dd4ca2527ec6d2e3b17e838d7abd423dc6eaf6690053065393e138575efad608461b301a5f8ea42e6c4aeb782c7a7c5317eeb9411d21e27d180b166e42c9cc39019d85522e04a65d14008ef32f38089b7fea997f53ba8a617982c29ce6088c52967c84770923ca3c55129f2dbac79f44d010de97e8c59bf724a1e98740479059791703e9f93d1c41678c68c4a1d63471e613fdba05403c3077ef44342bd47782311c5659bf39364abdeca9aa02380d43f5b3773411bb1ade7adbb9f0a52871cc7764ae218432dd54d5ce9145bb2209428e649a1cfc010b274dd5a32fb83d908f9fa88344e367c0f09a6faf8d639e91345fd66cbc56b4f9b5df61effaed797101df1cdcec065b21902d0e86ab5ac33db366b802fd3c466334895b83fe9ee790ec9850dbc8170822cbc64d3a0c7b56c376bc7844f0931705f782563a476c4d17b96c52ebeb7e4b6b36032e48bd5361da0d3a5548612e57eed9a277afbf6840b0d4cf37049c9570b891c00b94efc1e306c82de41ef4abfa42196ccd401ad2f3407d69fa703f830783c6661d4cc2f74c18f51ba199d117564005d968dd748c9ac8f5fc515e598e07c04f7411d4621853d464b9ffccc1c17685a8d9a23c23f9cb6db24b293df4e1b43c84a88d6ddff447a63253610840366e1f7776dc0d6a5a622d7083336de9c7e4954034644c0f4eced4521e80ef35f86b49f451e5d869231371c5d69684e7214c5e1bf8c46081a523181d4a23f55bc4857b9c86654641d5ec2a4b7c7e95c6f4069fdafb02f599d87d9f38eb7be89843cf46591a7559aa3d0b40652d61172a67e4428a1eeff9f5bb060d64aa5f5dd8d147cc99abd7a736cf2bf777490d73562e81ae4e934ecb839e9b89d220002267731f687e33b02a129268e1247527da725b9c5739d35dd6fc69b0eb0da13609481095414855a2bedd00aaa70ef37b9ca4e31f7e548e307a696c7b3849c0b9c65cc73831b5315c62ca24778475d0684a0d3e1bf6e9902cb3b31c714fbdb7717fcd132deaeaae0bad5aff4e2bb6884d930b3c94e6b70e85631a0342040fd1825d1cfc566577078bb815189ed33b5092f593cf25a3a64b4d6b52f1769b2804967a8ad9c3010fb99b5ec24eab94667e6c92277596e0068b5c67eec552c55f8c81cab1c1ff686cf4f2bf53fc6e6e4d165b3d4745b5b3513ad063f9845ea4ac6141c1df4cc2155826ec9be1d209cd8e99d76a89b06fa15151be9b48c65f8378c00c222e98a466c5ebf64b6ab63259b2d3b00239924e5100968acf6d0aa47e9f390d6ed4125fe4432816b37a1a93271ca4da80f43c16e1d04d8485ac9a90eff6cad982ad176e52ee3ae594e1bb1d10b4b1933eb0fdd0eecdf1acd83ad115d5c53d3a0a0a317611f3fa9674d6d30fef873306dc0cb6f0c5510cba3f11201f12d0941aa5dd6cf8839c67fc2dbc047d568907db07b62a18e72e70c2d8be2c535f7cee1b522d7cf391af8add98433672321a4defc43471846dc9ea29a6937040da09c688316bbe741e961a01923949bc12610aae496a05a0d3b784103700d4f8103497a73c8c2b444e7be9c315777b274e7b2483c4a653850a4e63cc62df74dc87bab58ebdab5a23e6116763e6030dedfc1b84fd11df8dbb2a60e1f792ca9548a1b6800079f33bd9d2205bdbb513c939da3a6947149f71194dda1a168f57de13b55fa7969c99a47055cf5e7b614dadf1e7b43160a33d486062f6cb40fad537b908d6962c690bc229488ce5d8a4a1fbb426801a4517e0da4d0287c2a38c4e969318cb3f6b6516f5dfecf84cebb4cd4be3b87a27173179950022b1e868fee315f8039aaa75f9d5523fd99059641b6145ca19b7bf43f01f3f01fa071da0cd1ffe38a46ae55ad26da5160b6a0767302e0f0bd508b72f6dd7a0e50e6a5bfca3ee2dbc6aeba702372be9fecd2bba950753b152300064f3aae1e21dd4d47e2cad3fe45a5a892b3a181ce3cba99095495adcd4582f827b2b4f45431d0a12044e5e83168cb71e9963c577929058322df09643ec01c6719939463fac65a0f2d69393432aa7c756f6baba42d92a75e56251d702f751faceeae03485a4b7c33e203d8fa42331d57b1d77f93d8f0467ff65304503d74fa03bf6690948a0c550124a6cddf1bcee2ded9b31aba22e4d82d179c0f2b6207b11e994603c7b1e6c286ae645ea69c695ed9ef993da1706231ef9a5c7688dab15e71dcdea42bc4935cd4cb174427866aeeeadbf6e325d9d6eea899e4f4c96b439c4f06db11152aa1b5fd0958531fc1c8fa030f303834c9bae731f5897ed934bd4e37391cb615f533844de2a30e9bfbd541c06805d6e9b9068847ab6728eed938b4515bad249b6e1535210a27440f86eb326cf55e6b220f83c4d9996e309d92566cc0b0f4b8a773580b6264b13a5b5cda198fa725fc973a56d6ca2deccdbfad3193b595bf0a180af1bff8ec5b8d1b466e661428bfc506ef9ad93cf5d38d1e46164ee809059374213fc04cf3b117c8695b6b2ae2d6ab711ac23c2df8e124a8fb5595d8765c449a50134b20aac8341af0cec3f4f6a816b41ca2f3db11e2612d466b6ef25531b56b55918c258f2ae19f748c163337a18ffe57255fdd252bb73a904df3e7d2e1cf3f840155ad7d396cf548347970afb21eded2872ec8d17ce1db2147017d80e2711cd64b48ee78b0dc0242ab098aa517d077caf070b530b42e8c5067ed01736398a4a7d19333f9e4594e731dc575999c7f300b23d7d5bcc51a4bdcbeedd3d5d1b2a73424d04a91bd632968c1b8ac2eaf538338e645c6efeaedaf862c37d36c6d874c9b65f4d12920a97c15c58a9bd45d29fff300f1cba06ee1c0a6b8848fa65dedb8c13acbe41fb8387034414189e1f71d02cd663fef57dd709d815b90a76a1a228db36f2b40f8f8a83ed4723bd921f6257ce2a36c46264715a30494a7cf7f15343ce349d8fb4afb071ec2a577ce5a958b45efff7fc443094c1a4e2dd4b366c4dd04a7a2d7e902707f07e5ccf4325b88d3c5e06e83131c8ee335180d7c9ff9e343e55d2238dd041273dca7e43b7442820b48be0fbb2cc68791e208020970cabc7b2ba15bc03d5240593f6636b5068158567215f4cef086a6144dc17207a133f9bf4aea0df15c468f3e5e2fe15f70394447f5069aa1fc7f719913afc7b5348ec9d03f6a03940a7c568035f7a33b9575b7dcd9bce176689eaa12bb0e4307d31018ae703a7ade9d5357982585af48d664e742c0dcd9d1c672595fd5f25b51fa2165e0310119c08234e2d38e7ef020a2f5c3e0b5a071b798cfdfbca75c03c818ce9f160b35274e7993dd8d932e0fc07cb292cbb26a62808fbc703218f84823515472745f407bf85ac346e4c0b3731ce84f1b4a253f0b21b3a6641d8dc7a6d62841c5d2b47645ebec52c604de1d9d374702a2f41aaa7d6e88294e6971b113340af3741c4658dcd7cb0c0105aaf96b57880d5a0e91e5b84a6cbd3bf251c6a05f54c6cc4d4817c1306dc59a8fb5043fe353f9b3d916e59091f8c3d0a6fd518f6d1bb95ac29a8cfa6f0bd1d1eeeb20f9250afde60b96c3b97c5734b9aa7a20f7695bd26b5b7d72f46639fd0c44f1347b84252b86690c8e6cb74e28519e686b155b346c7771239f2efcb76bbcd0ab790579b702d284408683389fbbd6a3ad808e6a216145b6a275663e5eeef3ec070f1ed397195eb7e51b1f4f942bac3645f051522c91e91705ca27188b9ddad4bf9527e8f8c81a9a764d2b2697c5968df3c30522b2a2550a0209991ccf2169e96f9712ba8cacfb770ad97b6372382bef27c4784f320d30abe0e38a5fcb6ad113ff726ab79f15fddf92589d9f7aa4d4ef8e08a9fbe47b0892debe6d216c4f548ec0d4c7a088440d9a0207d4f0f7e5fa9ea4727cdf4f649c132f2c272a05d02950df0fb53a644b26512b97097da670b492baf66b413085d2c144d329bdd6ce70c2fc470e488187c3a5ca3a3bf1185351652e24fec000008e23be45d26d337db94dc4e3e1b2a7f6635a74a35cdcb48de24cf4f13cf8c661cdbcf89299b7c96ba43240f6d07426aa1f39f90dda5fc0b610db2f6dbe4a22935b9d0fc2aad24cbf7fc5a0029e868553144ce9dadea97318228a4c8e6d469ac0e84967be3860157073b045e1c62a3e68a8e07ceedd834f359bb1d13d8df66cb047a47f3b43f32a6ec8eaa81961a02b0803c2010dd77dca9d070f064b06a0790fd2230d15477d34479c7c26b7451a2d7c3022a7ddaef80c3d9f44ed7d65933d93dfcbba63cf9f2b5abe2aeefb584e9b39f173425538fb9618f78d6304ebad170a3b997b20de6c095c5525f1f5ab4b696415cce7f3a64922143cd107400c7364b0e22223e2cbe932a27b344a32ee935316280478d025645a77e9037deb6a2fb9c22f8271d5b9a2529595beaacc48534081639c1691490e7445f1e679ca7138c33ca1b8e4c91fcb8aed8d77860cf770c61499271ed5f042feb278ddbaae7f09a49890ef040db716125c50e160be173a7e4dad96b92a91d18ae44f932fcb3a2cdae439bb321523b23e2afc752ff4b510669319e2d2422089039407e49799e39b51ac52585b04b45289fb45952d8b2d8673f28b8e4366dd7a572cce77b41acb8adce6dbb3458f633648b88cef60e74d6591d69b879c8f26c6e6b5f6d9ab20195a1cc56818382da9806","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
