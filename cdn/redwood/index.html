<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7ee49c12822ff098e9a68885c7bd69d26a05001a62c4dadeef3ffc16d2eac8eeca9037049e269ff91612cfed4ae4fb9e130bcdebac868f6b3827b596a843286910427727c075273bed133a61291529eb7c8e4c41fbeed196dffaa4975126e41ee4abde845f1db9cd1cbb3d1a0c1f867a6b4788b1080d8b7df0eaaaeb80dee830f635ce6ebef1e9b40d3f3ce44152f51d8b914ebc9c06402ec0861d3db237d161de00767c9143ab0d52dd99a3929162741a85c247d164d120ddebf4b31bf6a6090ef99fad6ff19c331807cae97389c76c519ce7e16adeda74603c8f6a0a7fbbb7b837b601f40ae454986af6160b2a2aa859a96fd43ab3dafc4a117ce70c1aead8a638fc9ce8e34190dfdfef6e8fc4c2dca275271e0e16767659fc1c5a376cd40b3485877ddb77045f9d072036422f1af3b6a41469a12c9e39dc8027292ae942a89b7ade04d1c5741bb041f281b88cc126f33cce677bd3ed307352b6a18a1274939c2ccf138e91a79803b16d789c095d4c28ffd8cb279d743ff86aac20ebd6441f63bca802659048618bcf4c03183f694aaf676cc80413fc083d83ff6578767961bd1dfdc4d5883b0886c37ecaa8ac6dad8803edb4b3686ffc65d4b9d6f2185ad5c50b38097ba2b4fbcdbc83c537b5abccba89eb87a20cf07eace2799fd904613eb36a16f153d027ab96ce0172230c1aa71a8bcecb0b9a1ced7240986732b68c4340dd661f7d1db2e2aa98f380a6a50c342adbc6faad59e37ba105dbf01b0607117dd499a628c3e9291d6a0e69512204e100fd0db9f4ab580b872e4f42aeeed21aea3869a7e4ccb729bb8afbfdbcf0aca1bec779f009099b19e9eb541e1ade560e30ee7dca650c32df4c24a7d344464385d3e4f16d0a545709705e571742433b37f73ec2568210739b6a053423d1cfa0250086e776037447786b859dc10ba8a4a3306cdf00a82b445258fc1546f31a8b995fb478bbcf87ff2e2864a324ac210dac0245fc81bd0830d0ad583d65900a6382a8b333ad02e66ff6f2f9c36ff6ce1b5daffd95aa2a5be16c2e35c05d2f5726ffe553975bb9f8d1395cf73f3486e65420005edffb3ca1168f1bc460e40e1d68ae17b695ec9bafdd2622fcd5608b23eee26abe3c019bbe227aef11915e3cd499e23077050d7c2cd9b776c606ae8b5cb49706607d79f4d3f9876b1a0f8ca11ae3c03dbe7c9054895f93a666adade86d263b49b8a5065bf9d7e95827dde3d0395c6c800c58850a0d6db7e0feeb9d49d87956537344a625dea8eef0e553c3f9bac9bdb71959fb204c4236bb2fe9466954ba15e0376c0af2820ba4dc0a61ba3cc0ada09974cd32ae0d185ba9a490c1099ea0992840c0377171ef7f3cd9130e8efa70483582bc2249d2a0035bbb75cf25c9c9757433821dc99b4d85630a138429b4b2c5962f18c2fe73bfd873188d57a7a740444428e4380584e8ae3b0a641ec79d530c03c716f2a976d069c55f5ddfb26ebf64825f5a868c4f97bad25043277dc759e42013a453b6f149ad298b559cbfc1c8bc33864a4f70cc30a3ca51cf0e73c4db925fefd77379368cca1b83d058f5466735ac5436d11bcfc33e380b2208400158bf16558b875e0107c66687888ef828864902d1872fa38d14d42622734d570811170fae18476dc09c619e83e4ccbf0ad06083d44f5d9e00fc789708502b020c14cfbb652e08a3cc22eb09c4d86581baa4418233cd4d66f7a442c1684bce654930522399874817915631a57baa08e39d13f07a19b8839e26e6aade6c75820fbbe44ac22c729d1ef044b782f90448cf358dd490ca58125bd836ab2f505b5eb5c515873b068d8eb0686479c7148a94361c7df8153c4b6147b33b58a3b53342829ae94ca7ebe9be866bc68c2266662eedb987db4b9bb7076d85216cc23071f739b6d68733d07ebe064a0dc352d2d0321b8c5331d4f6f01524809c9a9275699db445f4c7c5153b5e5577a615ae72617cafc3d37fb00bb2c552cb06fc089411d746b00cd331525500d1aaed0d3b5afb8505bbf4f7731bd1684ac4413676e39035c0c11497852fb0aa44ab90d9179a3a6f2c06c816e5fd240832e9c2d665c40953e74b49dc9d02096772a7fc227054f58d5f8c88e559eeb97304e5bfb9788b1a87ba5b6a563437f26e4436a76250d4ba46ccf3227052088806e00a8205c518643b9243a185f1a54ab6ddac788c7bc7931b8fa7feec2c19d224c69f117575050bf18a2c73341dadf6f6b6f1a1b56342c1cc10f5853283f95253fcf443ddc3d5789d62a642dcea3ffb742c8da554cf18bd8ff4a01d24acaa1602b33c6206688f13236788d4d115aef23e8dd504ca17182819b3c63d73bb9d07577c6d2ba723834af11473a4a4f582ba0991843cfe7ce7b7858f2e3a70fb8dd5c6b2b48f033f293a20eaeb1e452de83c66c21b1c6f027277ea9dc6fad1e4e4e9d66d67b2ee638f893ae6087f6ff4ac431f27d0d156ae1c97bb5f42954b4b7e6add8641380b6f8b617cfa0f8b6750d6d8fc670c395e8f1111536a4e099e6b92df499e078630be195fc0f7106da9455303615b33b12ceb8b70f88078178cc48e7a981894e4878ae28b1fdb7da7af09b4b157434a9462aa782cceca6c9acfa24b0f7159c53944e17db0fbf00d43167ab4d5ad4dfca9bbb109c8446b35a8071b8bcf2b0114f6438ab02a7e00bdabec62155cc6fe13d0be22ae119b9d11eeac038915cc5a5e87181c8356c664f80a5cf5b3512a87195bc93c4cc5a5ef66fc5c2625212123cfea3e7c918b30601ad2b475271d569ff3f83e119ba64d13eab6bc41a8c45de63397b5e5e4e4ad50ebc62d4c8f169eb8193b3cb38383fd0bcb985f20544fbd9d1579c0455a7622b62797e1d39ebac05cf9999e4a72a0d4e295dc6842b64a4420925f456d886581d4d65ff7f6320c34a6a1a54a3d946a42c83b8e7b1e262f17de6b20fd5a9a3f4fdbc3702d3e11a672bf8a8061450e1275dc6603c07e24bc17ada97d769a8e74d9219e8a960611cad3723636e13a632dff36dc4cbf5ebe220bce9fde97faa6a1eb3435b4a23cb63fd2a034c1fd88f812612ce6d221956c16cb6c8a03e981c3d64814fb2e50d564707d6720e4ea786b125f3af292e97b56ade8a94fb1cb66a398b98d24c2f9f7e5d97829f7519ef65ae3e8bc78a85e71216d8a60c1abf88838110eef204e818aecfda9bc193c12b2b0cf462282823d5e5edb77377b54af43787bb66f2b75a6a0a0aeb4bace320685d2ac5da488f29bdc854e8cea1de9e817cbd2978eecad390f9484c66319ef641a84744497443807f99cf0be73f3105f6ef148c575c24d4f2092c0589878d630f998b52049146d8438b432948c550871ce8710061e9496837955d859a8d5a3b83e5614913040d915a982d39e4ab4686afc62daa5d35ae289e477285a5c69ac6144549cf577f850da3212b32a7061ead6a45c80d967d5d71fe07163db720edc7fcac6d0c8a0d370949504a7f4c95565ab9d7fc4e0e3a62f15c947102fcb504cda1e33d2ba8470f304646886f725d6aacf0aa110a331802d2d9b7fcddd648cddc42341cb42e05ed841676e10dd4900e5505e671bd9e8dba38fd40b6ecff06e6f7e0da6ba56d3a2af5ab5331de622eab9b1bfbbe5ae6856bf3716bdfb3f6880b29163b0d37b8d9bb2e8ad100818568d295252220cad57b6579801e7946da3c50c3312eb6c9bafb704728d158790d1e7a82013fa44b292b4f54a860f64a11c6f60b73e7634ec3df6aa1fe96e316ddfc79ddf0309853f91ec41bffacc88a83fea54988a3930cef7dd39b0f3c598564d2c111c9b321b492b7e0c6d9565a357e4f08d741eb3e0d32d2f9ba95b786a9d2eeaca2e3402c8857e08004bdf08b19bd949ead7904f6d13ece2f5311f3fba1e9e274a1bba12eb09a0cfdcb92310b2044571df49d38dc86170e76c11be62c1a733d8b832547116912c9326d56590dace616cf0d6395b12010c997f3ec0af4c3115ebee3c9afd5daaf305be0f502754c62b1da0c7aae68d6365f12797223b751dffd14d16e1b7667be5718005370ec49a8203efa34aaf7a9526ba3f32e8eee0a35c85ab4f073ba8b9f518bccd6ae777595caf94bb9fd2abc7f754cf5bd97f241dd597b24d5072bac3f55491ddcd16f4e6ca59f2218a7e9436870a79323f5782eefa4a71fe0b93f2a4dfd3f16b02c5046a742aa8ce50276b884dd838a2863af312482c36bdbca5d02f6735ad7d68ca0f511dcf62d65bbcc5fdaf46197437a762126a4426f771758ad0d04679a37688fe5e0019b418aee3365f25df446f86a391451e55bd8007bc83059b886200c2ec92023f96c4b5a958fbc899cbe9e017ec869013197fc134b7a819919dc53b5707c09dc726aa1139bd10bf9be528e00d752f17926f5dcea11937603fbc79ef8a60b8147c63934a42b668930d092426d74d4964a1937aebd41d72922a54e57e9961fbf93d88736090ed5409b30b7585f7e7cfe5bcf46df74cabc01e664ae57af782e3271ebf81d69e62920531c0b26faee36e83125fd5cdd2971b2b06440a97aec524c2f027317ce16ea5ebb76867257137be7711d62b1fab9b881ad701c7d227ee6a3ef38fdfdfc8d99632e9e3cff2c406aae224133895cd6a2a093bc4cec3ecea5d53ae0e7b0634320db42b803c1c27d098ccb185ca3b4ca89ea173f01e0d59cb0c8524395534b383c1a47bc556966f7b09d067eb9f9598bcc392e997b738baba96877de03673120d1ba7768a34ed8b78965788f8b66c68f34ee8d84bc8d95662ebb7210272b37dd1ae3b2c46eabfe4d5474618eff819a3427f43145e16b39e3b77cfbe14233adb916b8bdf37de1830cfdcfdf3a14521f86ae3f0ff91082309e7fd2622776e76e314b58b9a0f360382696d398d06cc98d130cac6557b6ce2f7b7005f8a0d8e51fa9aaca6309922f00d989c8765e8e4dbbe935320984d15aa5c20bdc746104307225e45ab5ad8a55eb537ee0a0eff7dbf9f5ce67267371bf3f23c3eb69e32a1580124d859c44cb35de7c1137b50620a74be68518a151b267c61326308af2e4d2136933ea4ac8ece968506fb2f4b2245bee973f14481c1396ca2984e2911c61ad582c476a8dd76a7b8956e65ad13436b4d964c25161c2090cb790e971da15967566e8d9fa1ce3a0638109f697e78d9567e2bf53f148c3cf158a32879e25e9ec60eac0545d556050750b4fbe0a52fa8fab85d407f2f8f4d0b004da37514f5bf2d953ba376ff902a5d64397e8b437486b83b30ee0360f004e88950e102bb16a47cb5fd97af0ac5568cb847884a9662920ba444760b27aaf1011c1794a775b8905336c5ceb3c8075be99e43ee81a0539cb1a9f8a36b0b381fdffe4cb1a260c1993a42434ccc4b245b7d586e4a107a64402a3a9254f70dfa345cd0fdffa085ae6c70f06677a286ea8b8d4b9ea0aa8b31f47c73f084fa468470ad7bbd4206ca1505233d31450c2759ef11910ddcf869e41f8fcca8ca74315ad3a1782c84c8ff1cfe6f290577c45b4b573505708df8f9e307ad7ac2ad0e6e91e2605d468ec284028673f9e349295d189b506d9bc9e0213bd59282cb7dde56c532d6e37915ba2a7413e135c036f78e263ba51baf3b4b61072b0d40f0b5c934296a8e287d5477be66c5322cb9cdcf16160252c9bc4d2a626d6df520ff78e18a14a3c494e8d63273b28a8ef69fa17d9af82d2fbae3ca81c5476bcc02c488d5a4aa52714c948edc46f03de319e21c110057150158f5638d386c1d3f944aeed118ac58831a223530c0923622348712a137f64e5bf389e0b03a460117c94a049972ff0c13037aac8685ff2875b1d9c1d2ad51f2c0a733e5f15fc3d9158943f767e8899dc41211c9fa036a9ac8db3d8987748b4e4577e9eac84cdd75465b5ce3f1f06558f9629183ed1e770f0db3a486b6ac24e49f2143d0a4de269e7a58158b1d6777ed684438ead65be19515a28c7b3f75ef0801d64678b668682e43c4359c0c7ddb202dc81cfc91013f6ab0d36d5ed3b018d0a4e558ee831bd77534a0a239fe6d1227537df2337a563d3299230226816b135ee6a2fae7d74fd1e466116ab688f840500b828d5401a0a80b057184e8a2e1bee7fd694ba556aa8388820a31217302ec4ec20f8cd4195cb4ca404091bb7309afbb94312fdcb2e1e0e8768956d2a4a7614f2d7aecb7a228d86eae67a668b69bd81f57ae5b065c3870fcec659fe974c89242e80ec602c7f0981bebb311d02276478bae5b472e723b707b304c8f9a3212cf9cb10edfba1b1fa3c578a7614e6367ca2fb4229597fb509d34554761f609c7225c6a65abb7236649f6be7cef90c45fc08f24564769b53e0b20669686a3414bd3b6e53d43b5db2b8002f5a8503693e4d151c83549fe54bd97a1a9012f156ba3ae8229f7c236f1c1528fbf3a5d91c15d449469bbc3ba8e3c13720bcabc258de2b6d1d4048ce811a8f9437e4f1df50cbb80d1d678e4c00bf64d9a32ad881774d93469a05db39f0d70343fe789920a360378dba8b0e85bed5db2daeaa5a68930005bfe75bf43c9d4e1d3c2136147da40b83c06a9d688778cecf3d0eb5c5a46ce893f5df2e5ab699f2bd562bc363f72dc8a7562f9ea858b44048c4d5d8b974ab1831824b68ed93364253bfb270ab8345b72095e39cfb123661a3834f4ed4355f2d3c46dd097091fdf92f16a65ddb5271ea27c964378fa76a5ce1b26d4546280be3ae332be57cffe6df632dd2b13923006fa7fb0224bec09913ed7e0e635cc9a977d972014465ea1a485973ad5e922322e05c539a91e4a4e041a3f22f1fb8d83080f181eb0e739c31e55a947a38b7b53ee97e642a6a2899372dd0ea8738fb0f79514be789b8837bc41e5eeb8cb43c09b9006b655c781d26ced177c2b6553be2d862b48e1f8fa902a2065c59c8cebdb5556ebba7c2aa193b126042203d56bdf9ad5188a5cb4893d7518387d3ae3dd99befe251c89fe992830b362cc34cc1c132e8031aa29b234563b7068b6804f4942ba5fe91bf393991b8eb33434e3c727548c103b19b0896fb8258fdaf8ec3d7eeba7bbe3294cfbe5764c52f66917fa7eae4ad550a8ee21d425b7e6ca3c7033d578f7ad444c4c6be8ebede46799d1686c6c3e4dc2e3f7d2508fa46134ab79bd67967879d8f269da3d89963eea9cd124d9804dffa18df0e7b390d91fcdb1cbc35f36013381d3d4f73b15fa1db98ff39783b898a53128af888b9895443b4eb4e26c10c0ff19ff23196e10358c951155e5e09ff11365f9c141044f269b8eea326f22bcca767a43a6444a63eb9d327f818046056df2dc578b42b41cc7fed8601fb9b23cfa9969200573c871ce95ea6cc23e965e1240f22f70f5caa1111669d67866325846f488dacda040da18fa6f418c115b0e94a2e2bc27476de59d8b87b79da219849d84db523308c5df07d6716f88e17c57984cf1ba76b125142b84df616867665a4fbed229a0c65dcd266809cd6cc1e07149e8a07a5abcdbdb4fa93b769a2690d57a29d63e61a7f858b9254104191457349c03c353f43933b215f94ff7599745cfb5bfbfe1964e636a4db880c8a9f95d3451c9026b8b0239ab3ababa59e8ef3657def854e71956617f3f5977adaa68cf9cd0454ff1d144de9587476c12e41ba0da194d3b9a7175dc92e2590eea9a90796b40fbcde4dc73d708c4358def44d25e22299bb37465470f95ea758f136e7293ec5688132f034532ef4c91c3aac3f7174c52de85512fc0f26b0cfcb0efabb922cc6f2885ad50cb1e96a9a195efc3382f153126fbe66adb9ec33b2c62d8fa2cc6dca129b4fd45e80006fce6ef010403c79166ba8162a7e7bdb06a7a1becc9db7b1b63b03cc425231c05c7ac69a2db74067b904718ac0e97f82981fa778b60234d9cdc3b1458877127d214c772ce943e6c56fe2e0a753566b9852ab91dfb533740c70314d6d6bae11b69806bd2d0b03477ea173ce3d7f3400362a8dba66ee69f683ac339010f4ef3a567cbe6fe344786eb1967626cbec5f5452515449a692946480cb867736310d99b6f37f92ef67258d176b8c55c6dd3a64e44601051a422957a94ee15635c1eb64522294513ac87f13fec3d983f88d8a4c3be5c267f04e4d56e309697c44aad8944b914188a86947766f3b08d2b75ad202d807d5dd317367065680d0ed40b0c4173b511bd9bd6922c4d8f8402ae6ef97477c39b83a48f3fe6e6ba1fd9c947e579c7193ec3caeb7943d58b8f355dad9e4cdbfa42bb0aaad6277b017843ecfaf282d9ad45a93be5dada9ba33b4c46db328069150ab17424eb450adaa93d7274b5e0298265e73dd8566aaecd38126087f1e2396f10f97dafd739bcd7c1eea813bcebe351ef59d83b876c6e2f75e18dfdb4599a083e0fbc54a63533a2b2bb640fc44d6ae5dadea39c4806220ffc8ebf32630efadd498977e2d39ebca2fa99a0817a62104aed2cdedc1e54e3f8724352bdbbdeac0b7a2f49881b7462ebd38428b7741d4a3fd4b660d17d26f40dcae337c98384f1c8a28805a10cbd2bbb32420c0501602cdbc8bb21a91515bfca1dbd37e24441282a8e4eb65af79d422268850b2493223f10a53a8555f8f0a3e7bcf7fb245d4efb82466e18d9fa3c9eb247cd7469dacded4622d166251ee4c35a56e9982ea96dfcc3ff968241afe03edf23e72d608f09e1c7528aff359c24cf95a2b207ac337d84d01783c542493f316e9e5c3c8084cf3b3de1993b68c16bc9be5a7be4db79ce53a07556ad5fef37dcbef3e3234eb20bb8ffb7f0a5e941dd80439315b6a6e2bde721d0a76c78a8b272ecd2a248e5bbbfb93b0494e7a3f8e37d9fccd6876c06d6f6bd6694985f901c38b4aede7e05780e3e447fa6904ccfb4c482e9f9cf678ab9c5863796d691ac71917d66d10060ef427a4c6bbee5f2ec961a52346127f972554e926e61917cd8c171525f4a8554f799482067ba0a697db04e3e05df9c22fbbec53e7d4251b72782f7d06a75cc9eccce577aafadbec33c98906e6bc689a7451d11efe78889ceb0c452f76ed7f21e22091a71019f0acb8f3fbcd29a997c5e05f1201cc62c4c6e28fa4b8c03e9b4856ed3935ced7fa2b0dda6df76d3a4b3c5952cd59b52bfafe1eb3dcb1aa1fd607750e3559d990e6aa2e61ebc40b77c01236cf06f05568a07eff51e06d93354b8e955fbb349abd188f7fab5e2d6e40f0442ff1f5159f75653f76ac7b4e2cd14ac536aa1445cf938957f38757e9e743e48f5cd1b771de655ef0b5c5f350a8ae3a4a3ce10719ea775a7f42cc518cbed35c02abae3043bbd279cfe80799ca6633aca89dbfbcef033bda30f3d4a1ef356966d30ac64332e08231e9c7c9ff94f7d568320a647f4b27ba9f9cf91ac5c3f15188754bd73ba79c59e9baf0cd3edb1a02592973a4c82ab8b23503798feb5904dadd03d3bb5fd0e23024db355fd4ce89f99d458c3406efe593cbdd8dee580dacbaf905d1f05f3529e553b8dba6ddeb8f9b25d98c3f69b43c5928a93e7709a6c5df4077e63ce028b776b00248212623c76e3a9ab22a8319238d8945f035352a14859d0ba78e702e0a550229233ac5f4ef77e7f1f3215e4469f0cf5c6fe43d79714128cff72cb47dbf7ff271d39d277ecab44bc77a192def80a1444bb8c23b966bd8254209560a542dd9107f3d64489824690508022855318f5ebb5e3aa7ab8e2c657967f25df3f0cf71591b65e7216867b20321d3fa316d25b1dd0dd331a71280b06955773cbaecaaa510dd85e3b382b78a510c8516fab5252735793c35b1c31e752634b1084bae73ad9195e6ec61bc345241b9d6504e0973dc7dbd451cf5d82d0ff2ee37d1eba7737659a23b53a6a07c21607eb25a1c9fdd40f0aae4d66be769fc071aa3b9be109caabf2cd0ad2443b887dd1b53eed38cb7b205cf0b147a5123bdda2045f24ff4a2fed8ff4acb149b1a93564be0d86401caf6ef35654841b6a78a4faaf3c6d34399197c8435446d730325b1a2ddd9e545bcb747b8b7991deb0f975b512dd5e10b2156804ae90194947965f8b6f9251a9683e05a6c5302918ad985535e8121b4e8d6b9a65bcaca253d2661223f7d2b22506200dc8ad8b5e5f4c54e8eca856c6b6f94093a07dd5d5a7533e8bfd7e9876822ed3f6524c15e866503a9417b0eb2714115921f6d88dcba8efdb6fc431af138e882c2082051dee7bd3022b204ddda99c43677c25183d297b58ed48ce8401d344530cc68f5a2fae2057839a4dc907779fe4c2dc0680d330dd2d1b1e4f7a8fae1dd9a03a39864dd21e6cbdb0cf3e97b929cfd7336840da8b2f97a779fde8483075fdb325834ef9054de9abe0d650914a4127d430aee1a5556c7d881b3d7ebd32636474b56b06d6ed7f6d579e4b398b0d94f9b2971acbea13bfdcafa80e0c4ad7f97fa5345f106b593c51f21befab7fb805d504e9374e4193723aeb03325a577874ddc4185b8f8c89efd90b74190e99631adac8ccee6749ae2fe0c7b6d9e993f7dd11d916d0494965a253110355454de7f2e08c482a8f745c874796f7754d56993be73a9e46d5cf44d966aeff4b5a23e762b5c538ff69e02b6b681c9ad10f0d7666489594e8818e772b5ecc73eec3f343f7d8a23cf07090e40633a99369ed7863ea62127b392d1e98fa09ad621d41e78b72a31884ebb8c590e10510f0f45459f4f095d2f41fc4d018559689beac015fe9c09b339da80312fec84b36ebb5d6ab14c022632250ffa3b9588c80bbeacb5c64d838b16c7e8ee12d50211dd012cfcbec5830edc35c6d33129b356a91ca9694afab94ea5abca35b353ceefd75d0d79a0858f2101ba6b7ec12de51adaffc1a622efe171be10c19b8c9748cfd1e786f48aaed09ce3c6ab4676fa3fba25a88afda9eab4dc489efb788a1007fc979346102f19634c5696bda90cbaacae0739678436b32f4133d4060bae4b1385a3060678f9c8056180a7a46f381aec1937104b71229f7289f7ecc4eae5049ecbde2591d8da39ad5da3cc966760e0250c46dc4f408a84fd094792608ae55b102b8122247976eb0764c1ebaf2341010bd6ab6e896923f8228487d3971e1d22e28f24900a8e3db4d9c7e9c8b728b2f8c30ad5bddccda4cd66250530599aad3b0a80c6cd7f1ebeb7e2e1b82da524d2a58c7a6942fcbe27d5085622ece0bf6893d32062de796f0689445271529578e8ca435be0ddb29e713fe4f1b93ab30211204fc14ceb89f00bc11aabc155059b79d72a42b81c637063942dfed49d17261687dc5ecc34bd4c79142e922953ee9fef63b7ff96fd6e3f1149e9b8d8a47848102a590908edbb19f19fa1eeb45871f3617ef943c5ad43b921290efc427b1d687d2d74c28dd67b2feb29cf016ff948c4ebcb5dbd19f0423fdec73d2ef6d369b67fca89e8b66fc53094a881b175bf708a71de098aac76519dc9820277eed70658b826b2f3ce742b749d1dd014891cbdbf9fe0a20597948beffffd575ca32d58f68b66327c08fdbff7ea0c5e79686e9c88ae7398a88fb07c66b8decef51ac08b01f3ad8812bda67b3f60ce102cb5de42a19bab835d2c5cfd3f1d9195f6a8569750194c984331a2d30abb3a8cb24b8e9a9cb0faca28488d10d77589337a3de5f0749ed3c83cb77d71b60b98bef4de74d8d421a7c6614c7dcdffb233ba51e9f0ef1feb862d21c1f2b91efbf083b1aac51aa9a50e1341c3b0974fe06403ff04c48df066e4c31112f25072245132570de4884f774dfa66598faaed7bb80ac392fcb9a003c98e69d4b4f02bf81319a27edcbc7c068bd921543a09efa635364c5a306f8cab88d7330e73a54d7efd05341cfc80c86907c91123173df933f866c81b146d7b2fffe92a1766a056d1b7ce52735112c6f2baf95eca91ba2bd243beb2d436e5f8ab6de411d49fa72f144facc9768d01fc7cb586a806f2ef50503dc79c94ace16e4495d94ec1230ff08f22e292441fa5cfe5f47e60d9f8d80d4cd7411c92b707263005e62b8ee29aeb61d2bb5d4e430dca2bbd5e08eef3217307d662964b876adfc5f31d1e18b6a10acc362cd5845668f52174811d2919cf6c86d3d2009c00bb193a296b9a889a5391b1cdab5f4e700b1feabe0a082022983c90108a11be4b3df2844ace512dd26236e03270fce0b2db3245ce1acea61fdbea8c46952a087a79e5f65adc34b740bf6701add489934a500b9c63700bab9c9e2196cbc98de4b0c86828fc973d55a100ae85153ba7d42ad16beead296182adc375579675c1c07f6f34d2b19e409947b213baafea3b8071777d02c0f273afccba4fb1491f53cfee50c9ef8fa4c6f177b6b37a4f10eea1dd956b3bf661c1393d845303d0cbc1342e1bbad0048b32656ceaeb0c397b9d27761875b4e716d2820050a904186d6bba4a2d8dbdec0ffa3012916e6d437a639e832f09dc4c58929601b1f489fdbdc8d5931067921702a4375cd68a0cf22c76cac1d3c5980282e594d00f08642cf28e6aea1b29e39556d7489c4f03325a831d7580282c0576b9f65ceffccbd37011902cae2fcdd299dbd5eba6834c012e08add95b51e53042caee787f17037f5a005994b2bc5b1a394da73d475f8bf1c713c603f6c2cc353fb1acb4c2edab46ef5fa7e4d5bc29db089b84693b0f6c7bcdbf3554dd0c68a7477cdf0f423fe6e6fa05c652107ba45d134f2cfb052f3c92c8000443409da42b5efeb4c83652d438cbccabe9c10d8d35adc4f5ee6eae6d41e70cb765d63610fa65d08b7d00569abed901c533a1ec39e1d45801de373dcc42086d3185cac890b0fe6bc0f11c07d617fe3accd7e0de33536ab5ac79bddd1feb616ee40bee36595f3ea6a124b6e95e9d466bf8ac158b2f2e8e7441c7908a6c1ce81e301be53ce873e07cd562c9b350af3190debc354751c390d2c6c687ab4feaae4d9dde03a4015071233441174b35691e32ce2c6b30ace0cf40989227a73ce987fc9425dd5ab1964b27b76cbefda7a38200e1587a3433bf72241ea7895009ae096fe580e2cdd028ae63c235eb4bd90334f90a10c3e9b356b395d9d07f38d9f0d3e4d80a2a52d4c7ad2b16c89a73e65bd3d41acbb3e413bce9d8ef213fa41b8b3c61c3f209c04af38c8f5444aaca9cc665035b928cd2a46fa41f222bec6eeabea17db43997e799b0ba37f8bace5c465cc48207084e78fe6bbf26b36f74eb5e5ca8bd0237b7a6faddef488daba57f3884c87fcfefb210d0c91216d179d8c432dfd2a54b52107bd8201ad08f7b596325fc1914c4be7566216e1929471752c9390dfa4f48ed573942ded238bc62d9bc25951c1ea6f0c1421cb80f4ab7abe071de92516aa8229c0092788d47d24be59b0a820f9c8e44a5308bc98b09c8775f3aa2fc752530a50ac3b8415c70b7d99254506143923b9f06eaf29dab2efa07352a5256773c0b5b50b329859b1a7224a3cb89520651b47288976114ec291e8d3d6dd3cb063fa27fe2d74d04eded8ee2ea75e11f70bda4d2067e5ea3e7397996a57392014bbc447af1bd3ec2e37329f2fe583697ef7a160fec1f57a467295acfaa496831533e371b4b30d03dac30749107ec38df6034cecd0bc588831b160767d4f7cc0024e468913f4310b36d5d698b3dec5a4a97584642d1aa643c3ea1d380cb6d439eeba07aef4a6e47ad43845545c67e4275ea7c9e072b86dd8e5eae1a4f761d5107f20ed7b8bac47802f3c508e0dc179b411f4cdbc0773cad2e48ebb004e61c85ac30d98154049d3fdf60cfd5f2f25a5e8b2b84c0ec4db2acd546f3785ac77c9b54d71ef63e7ba4fb716b05e029caba1bffc904d6eafa25191fb79c759eda33e00465ee93822cb5251cac29e8ff040e89269dca826ead507de6f6f4db37c0505215365c056f342728699f5e68e9925751182a582062a1040405813e45dc589166109fcbdb1b814cbb8251f3e7291376269fb538f4d59410c812f37bbd624fc716ed68bc356ab83ee2c67cf2047ce11a058446b6d874e00532a3bc618ee319ddd157fe7e2491b7330eebdc0b82537c95ff17ea23695c5555d21ff3f1d843138c0ffe7c8742ce027e04b20c3912377d09c5191494ad48c10b8fae2a9be421487eb2d7d248cfd4ac70ddc07b060326ef995eac637237ab2255a60ac43427d9d11d421e4e39e1982e44226e7e07bc319247db77afff796adca539224d0009052270653154a809383af241c1a0f97eff1749beaeeba98625856836c0af9b7ad5bb51a0af37b7f784511a07e8e3538deb2d2abacc77f5f490e1f59f6f0b24c4f12f3e5c56af4c387c3bda82fa5f7ab9dffe5717a38a0e9c930dd2b4e5b1b132cd3728a0cc289d9a2cf0ae69c9259ad3f462fef63441dd23dd610f8adb8b1163018ac02498fd9f047747bef02fa099eb0b9f9e531f34455f7d2e87f573c36dbab4f42491a5e5ea987514acdeeb9ff700c73554c421f7933678f18b82300ca5ca9da4a552b441466a45c09cd2e5b3b192085cc6ca007f2f20593676a3a53c4e119fea638efd1ac5c15d02ee2313efacd15ed8b7761fb0e62d3981673fb590517b88df3de0b058416db4981f1d64a19ca5be96cdc164137a3024454da588a525837b658c2e71a4cdc834e3abcdadff8fbd81ae08907f83b877d594098956d02860e1f6769ae525d944c987eab2b38375d5f0411a828f912bca38a57817ef67bacedb77a1326d4c1b231732296b0ef8d4be16595e7d095248f947ddaf3da55d017dd9ef571d82b6004b40f2df1f56e2fa358558fe5e9e373861e1920a600963c9ea1d178cabd9023979044576a4f7fef7469882e6bb123f922ffd6e137220889c8856e4cf1ab27347c544a2aaacd28d091c265145fa314ac89d6c644bf2d11face7c8b2b5695994a428fbdda78afbb35e22b032c8fb4da940d46848a1020609d44eb3bf9253cdd9b0c7137ac3e42cccb9a53c3f7081653be66d58fe2ae2ca33a6fc0cfa58bb9dceedbd08ed4e3616f62a73cf6595f7633d9e50a4eb89be8c98ed687021781f318f424650ae471f25518d09e7b573e0da85e9b3f5ec67b2e54acc045b1d8a7bd3628416630a7529dd6f96ad2c35e3002606d46de6738a076bf73eb7dd814238526b39ceebe33bc5118ca806c635c1f3984ea13aaa5f38648ceb605e5f001819c800e78fcb89f0a92979f31015031801c3216dc5bcbb3d63dce26bc653a457bdc4f82f9b1d74f73c725694dc56c1a7dfd1d9f624796463e071f172d7507d3f5bf276f7b97fb1b73dfbf4d8c953c5148cd193eaf35cf751f38be1961192ac4a5cafa4d3a165f3136170997a1432043dec92c88ca9106e5d63ca791b5f0d1adbfbd3c48b31f7ed838bad77a27b203e439cba2073562919a27a7303b391b82f4f8a65920ed97702374aa6552498c743bd15bb786b9c3175fa15674d3d1aa62585f51a71dc5fe779aecff119ceeefe9283d96e6c703bb874b39720fe1e4aa947068b521b414bc9ac385c7d9279bc121d621f1eae569c4db3d726e2e668ecebbd735a21ddf6c721c1d846af537e438ee5eb4f2ee163247f4c09b19330f45577a4c729fc830d801da424380ae73c9122380b22d088106b73dfab9458c1cd058cd752fbdcd83d3f07bb5ca0046cd4d1bb4e878670d2f8d8c68b05c55034f01c75e56a4d6cd79f882d0a40abb6b9a4bedc9acd8e5d4ac7ce8fcafdd4e9228cde15cc4b8198d5b2224270866883b95242c138f226716dafc1cde4c09d9fc3e7f85db9b0cd1c94031ad17558090f539b9c28f9888a6917100c64e0afa1ef9d55ce3d486a767cb155369d1c9b985b7269aa1f5275c60ca278ce24e0154ee1182ad04fb95945e463b5119d2fa88328060612ee2cb017674d229c5136b36865be68fb87a3e987e8e8da24a2cc1dcecae8c01c96965fd35149400e628c42b536ccb07fff74f7c5ebff0e277a99420183e102659c7c89078c9fad3bf418cd25897f546881ae0a39311de1b2c69d69872a5f9275683f8875e067fcb722c0ae42bc1922fa67fffb73b2b57f6806a170f83fb98bf6f8fd9e7a7350f49ca6f9c78e2081b352ebfd9e7c0f4d8435e55569b57592761685bc597c91310dc9c471622b036a039bb6290686b6b0cbd020dea1cbc32362d83bfcb1f39a7d0555a6006f899be8129d21a8893b7227f6921f590a22d2ec20056a8fea1a216d3a2b00601102af22a91a20ba30ee8df86338d47c1c8bb7114f82818ff27ccdcc9ef8d8b94a0398d336b688311c3da32d1b2cf81da9a3fb0f562878bc0e2745c530e9799afb59c81c3c6424a86b0916ad7970bca0692e4d6e6060b793a8361157045dc40af4e40705e1966467a664a067592fa75af094aef64b43fa17a95f1bd8fb816fe8b9dd1afbb624ba74868125e2b555ac197d393328eb89fb97842f2477b9fb84b7ac20ea685b0019c8146a677e7ed8a9eef70a6025dbe4b61893bd5ac09fdcd5b70d54536a59457b61191c9b326bc3c0bd4ec80c3791a1a9ec1474a54fe425a6b3439b274eeebf87959debac752af3d422ab4382846c91cadfddfa2a06f9a0c46dc50d8bcee9c44bd07769844def0f82bfd1c79da62a9af58b3bd461aef71ea897640a7106b3d41b1bded5b3f1aafea0e7dd336893e2bd57d248aac935dcef45d930d0425995837d7bb5809c7859ae2b42860baa36b8fb8ba4c407287b571567dee77482833f80cd9368529254afef2e63a269762a25906ccbe8d107182dfb2773a4e83bfc2b0b0de50dc1619228ebce91e7e6459e8dbae78d9227afcae4f3ed26c1c9dcea38f8c53fcb3a747352d0b67a068649eca3a9844566d83904384ecf6d2de099badb7de890878b17d3e1dbc7f7a27581291254d7c71504867fb7617afa528faf5c9a393ae941bedb891984aca46ec5cde5149282f1241a3c2aed6a331ccf9196dd6cf25fd5e6e1823bc4f67c6b6bc0d537c92770deb8db8c77d8c22c53bd43175d2c3f8d2a0d8cd24e9b6580525bf316a5da80b55288ca29470fc315b25caf4e1a9325c6906e2e7e018ff8157f6873d2d72c191e6758432e9736a7459d4d824fb9430846ea12ecfc24ef363ea317e3dc7df28d5c6ed051765b1a37df836a2f7a0b445aa894fa80f60b5c15bafdecca14dbaa8839a6ba55eac75a09c021167c36fa9af989ab3fe4f251c1420354021bc4cbd0fd7f0cbc529188a5aa952f56fb7918b5bf226a265faddac4a33ed68bdf0f302d0c77b199125c0f3374425ee10da29a738d791a9d8f4abb45c34e6db6df3622c7b6cacbc28dc992b1b12e364552ed137c6ecd1eef69655bf8d4c5b33b385c6d16f09156f4a2c472f224e67af07af10a9c5778adc933d9f8755e3583daf154b1db1155ab65c0021384c30b2c895d433069d7977802bb89fd6ae903d61a71141fe66a10bb356c3c3e5671b9107184c2f95944f8b7a616b5c7f0ba75315a54de57a2c600297702623e3de8caee5e0861b45d95e224251b9650998bdafb3f906746fb0fc4d3e373d1e8b113b1beaf6e49ae55b807902c4f404a1049cb45e72f4aee0a59fd09ec600f050b3309579b6f2d66bc5f6736c1ec89764cc2cd28aa721c4705e000646f74645db2c918bda59a86747bd1740babe4c5880100c08e1b536c4a1881136e974ccead42e08cc2edd17a1db6f3526e579c805e3a10ecbd0b3ed351bb1318a1c349bf3d6033879e74dfc9770b3c9166c322ba33e4e04198820f94076656b9a236b46b8876f5bb141d2772989eba9605f2c5191a1b78ea3b4bd0c9d4dca82cb64791654fa4bfb9cea1f95a3029ac291ba5b56b49d07cfd6f4c498d35f0bb12b96e5fd2c45efc4c1e6c4fc09bbf681045fc71d5f399e1a567acf5e9eb6f68f42e030c622b26ed7cece7a519e8b87db30d3594ce286a4580c50cae386f34d6e4962a5407afc6263c96c57b5dbe05c0f393952fb5ac450e27cd66ca770a0352b8bc0fea250337a9f976555983dc8e98fbc2912ee732ebd817c458dbd3d55d9c94d00fb3ff4d51101e75f40b5df7ab8b0c254cb00bb59ef08e2e698e554c2c324e328132692b3315ea811f09bb757723119158d998ba11c7c10d4339ffe2d02907303663c9529","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
