<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d9a62a66748c091ba5d5ceb76491ba60d8377b36d5e7315c6c2b6f63b37a9b90ae9eed837b3563aa3600db992a981433105f8e9ae1d0b6170d97b1812af1e97582e8fbd466e1d57faa848bd7f62c45681e89b51598319226bb043e61b115f22158dd70019418a93709245d7ba746a7276a9ab6021b22d9211e1dc3e59789187fc476a80b77563594fdda3195202fb7716c28e6ff201981997a4100e2974e3c48235682b0d373fe36fd385f6a8e522057d91e177ae4be2c1c24f79c6a212b901cd739ddf222a516647182f33d9cb4c8708380dee55e6b9f92d24056683976d2efef8c673b08a5cea8b2185b36ff7bb0ccab6c02d6305d62fa4fc338a5e2e8acaeb10b71deeb127825a927154a8ba54737c6d13cfaa77ec6588b215a983b3756d50f5109844fae97104824c05787c114eaca26b6e495cf95ec4b63b0fa3e90b0d11d06e497d385822f616396787f20083f865e8dea08976b0a73fb8d3d7ace26b91eb49427c06436dfcb9fba030089c666884387558891d0f4cf54bc26b773ed3d8cc1d796183b466198a4e38db5ff54568049a3fed0f0e2e24f1e9cd49aa906cf1a66649fc3638e087f9dcb51dba96aa55bc3d512824f87ea97ea705a1d7716eee56837726b848a2ed9379c345750ef06aa89647790acfa562e5090c71c24fca27dddfbb8e71a2315417141f362292ff997726f7237f5d4930547be7057db24ebc22f7a04b85203ee8b6f152e325a593ae289eb322b9bd25a6c3e78a92b381432d329ca44c948407814e0fa58fcde473047d75bc90ecd7d595a7088235834ce5d98f65e49cbc7f498822c3c2d5854c9469986bfe2b86e641f575f90c9849efa7878037c371888ea272789e16ced4d15494b283983ada70faecd21a3b886c41281d123aa3f6514cd77e333d4887e3d2a98944d0f025b5bcc983267ff85c890ed570de13619babda740c397a48253efbdb29e774d4b131f84f35244ce73ac1d075ae909a9cec8a9c4616b7e15e72f0cff2d9a66bec260c7b8517af9335fb7ee4d5f0253c134868d901e2a245e88c42c11f38655fa074954e6387254df70661f595d482c4216e9ae8695e9edcf152ec44d4dd7bd114dc6205347b0a0b3ac1f79419b9945ac93154c4f1194423b2afd765532b1a3a2b8534f40d973c733e578fbc4a4c95ea94b83aef6413809f984ae925f64aeedb2cf954472da14997a03c7d862ba4a110eec17cafe88b3a23c101afe55601240d2f6a61133c3ba570e01e3aafb06f5138f6c877f68a7bf9703bc0ac2277a273d20c6c5037482c1a12d0ee34f0c48f919f87ce09e90dd653c68a01fecd55f541c8c7def8c3034419dbf7787549360bf08d196d570b73f873eda19d0b2e6b5e2c6b2039401afdbd89ae98e2fedc148bd39fc4af0507640d33f76795373db7fcb1d6c574725f089e6dde459d92723c7295f091ae62d7680198176f535aa772e39b5647b05b12f8bc587518cf903a3a608eb5e5e6ba55e003df75a0cea4e7cea132a929bb0b2e6cdf353d6c23b8f1159a4cbf87b22b03e37b713ca1dbe8c01be101b3881b3332e06a8787060ff240926741ecdac1e746a04c2ce9535447ac41e12de934e2d7901e1d34de927bc455cda107b281a3cf5a4c4a7e63bb0914d8fdef97c8c075add6d735780b2e6e3f9e07e3c1847d7490e6e0257536658c1d2eb79f2c26dc99ece9626df001c103918b660187c62dfb29f9759b661fc3b08339b18b1b1c3108890e05ce9fc3b6ca50aa9675e26e341d210dd75f5b6a4623ed68f96cdabd55e39576b8efbd9aa35210a801883f820c0620b180407bbf805066b9726f98c41b66cfd379a249095886b53c10293375b1e21ef2741e0e3c0894e3efd9f23a6a47ea8bd3f5a5a9c909458e78174be013986dae7527e6ed39fe07611fa5f4b13470e2af66c749fb908321962e2a9a5639dbce1430a2b3d8348f35016b4b05eff05951319a25f57176cf2974450df6be8a9d23d36aea8ceeac2ddcec2f7d7e500f7ffd5cfaaeb210af662614846fb5ba70f70ae1bf1a7b0e90910a90c68ea8d69fd2d9cf1f169c1a0f0098f3a8481de8c8c65576fa6bb94ddf73e57e65424d14b82559b6015983fc8c9442010acd692f8e4a1eb352dfe2b4e663ba01eaae5561be4db9eefa0b2af544f9ffd0a57f7ae04275c5731394f30519fbb433ec7fd1350c96f94f3572c81d909139cd26d0794e65b09c18b1e488adcbe941f18368f92794ba0b7b241f88fba8fd777763b64413078f787b1ca7342e5d158a078cba6d6bccec2d364b4316a40c62b49ea250b8dafc55648cd899485dd2cf21a087e0fe23566b0fa91abe73dc4dd959c13ed63329a7e765829690a9c237cec8ed3bc990b75bade7d0a496b8cd13066707b122cc5ebe0310d008fa8a7e67b56f7da93a3d1c2cfb1e7924cba66dc879ef6faf4e69e274aed493c9601967f7168edb6034a4a6266f8793cbffe81d452985bee573b263b6259ffd03478f1b8452241ac145f4c3749b9876daf07249ebdafc6b0694e53da0bfda127696756c8c47a21f98f4dcf7e634dc7513ac6085a7bb7012d8e5790b0d04a6193df32ab0792c118d253dc03d0d976ef0a0f5b9d4b6fbc9592357feb7231ff40499a326c57b6e0bb496d777501f3d1361e3a99a1dde512da8ed887ff9baf3b6bde997149a9fd914aa6d9b5efacbf9cbcb4afdeec9e745730cd2a50e1f27d05c8b165014d71f8afdc394f2e12099ba8bf384473dea0983482a44545aefe1bda16797a1341a137940a3a15fc69842a9143ed76ea93ba90284f030bd460eef4f8fea1dd6b3c2ae55de046abce6e867f8728a9059f8aa1b7ccb52abb2352f8eceb28facf87f2343cc77f3c7d251f1c2e012e07f998932172117168897e3a4f032d18492996bcf2abc014ed0736ab9dda0718c676eee56cbfabadaab8846f58bdc2db3fbd0ca8e82d466b5a10ac785047bc49c1e10c2f7794af71bc72b593f512811910d5b42775a185a9fa60ce971b851255f186d65de2b9832f65ab791bc9f66e5ba7e1ecca84e4873b406ce3de714b19891f0597a5808722dea3006efd48f34d0d1502571d5f8cc4364c76da47cba15adf3120c4212a61b2b66686de9c9a28caec54d4d2e3b4b34e97d4c069d9b40fd411d60e0733c7120778f125f0670023524fc250dfa9e76a7a79a660b2972baf99a6c905798fba856663bc03d0394cfb3688654a423b0fac7e1b2986cc84a77b2eaa902a6fdd02521fe2bc1bbec5d361cd38fcbaf0c3a68ad0a1e0c99b993cca3a1f556c2a6a2ef6534c4cd1374a7fa97632d48befb1bd3dd9fea93f3e55a35d8da635a31a1b32ea5a353fd035813b6f5e8e730b60db63f46c855faaa130d74add1707d8a4b25b46826e75c0f5c58d761b4a18d343d69ffca1f6bcb61661c24cb982419fe63d1d8142e5f1dc13afa2afd9f4e64b250dc8d68bf6bc0754c2e7f11db8252df3fe53548793766c44a5f1ac2419a9b866898fc4b71439af6dd4e6cc1cd922ad1108124206de23c51f952ae4b6babe2102641ff9a164ed0f47f10135f4d43ab7ce4a30cdf66f660e3d0994a43419f6a955ac8a455886b5075a86205a24cd7fba93bad89bb09a6254852c3b57164398a6728fa0de3c9469728df30b0af0220524cc45e8b862db1c2552e205a8d88c986e612e300f2ce475de9f0ac2872f4f44f7358586ba19fe085da863bb296a0b8404467ee75c405b183d00a475274fa53debe1a7691989a5acb751c23dffa8c63fe386562599b88ab09381276a09109589b9710bd98d8e4ee207c92ce708bac5a3129185dd0201ef68d6a62385586a4713d1efcf37a48c04680e592995b42b40a7bced6bff69cd801fcbdb0ab1c767b1bea7a60d9984f50057833786be838390d8fe0b82f7f2b1022d14301589be3b3693762a6a082ff54936ea8fdde1063ce0d6682a8181cdf73a54a37d0db48b55e8f5fbcbb98489acc1834172abcd5bef8d0388a8417c71c7f9ac023fbc2c7d7e874a63d72d054951806516ee272709c25bc173dd3661b0e919496010fe7eeb1e267d14403fcc4c2076a67df6c0ab34cdbf32a6dc39ca2add18c106474b536615caa140e29fd7b6a6a358370130ee6f5c9af86078257478bc8cb01ad2c1315a1622fac1dda3dcd325b401b4cbb17baa703fff0d578f0fcfa2ba86181b97500f8a37ef106c10119ca61286508a74abcdbe9ede2c53bc1afa491405b1549e087e1e81beca06e3bffb00d5ab64740aeab3cd52fff3c2a05c656e29171a3d006859e71e2d0e4445dc9ddf428083049e07d53457b6aeb11a27769433ba9121501f3dc0be40b357d9dd6e4401ab202cc93786bc14c1cc843159d269b73e8124797cc1c15e92724fb3f2654a7994e352bf03212f6d134f7a2f70a11610332dfdc91ab435b164995f70d537947cf5894cb3d293769410f731936d9eca17a83756241784c7f9df9b0f4d8428bce1de354a6716d358ff530b30217e546a56fbc8d72ff702dde938db8802b194e18730b0c0dcdf67409c9a0317ffb26cbfdffade52060dbc6b29ed265701bf4b6e83cbb455890a38d0ae27a08c8cc6ec84f45f54f00dfa178cb12362469915e86ad7a1bbe4ea0e2e0dd2b0b49e09fd455c29fe0dac386ee08baa0343eb41a01f4a63f761596f9b2366151d7b6db2f354c0adfc78373dbf2cf325df52fdaa983c3629a074734d0398179b7557e34d3f12aaeaa6005b32358a02c04de636678ae4abda49ea26230a67474f3c5cb4b93e4ca549a4a76b59412835da28ee3ed7c761bb43f85dbf039fd55fcdf13e1bbc9236615e389ee8166b3aabf6cd2be93381741b06b922b6b42cd18a22be65928c59d52be045702e1386923e7af0bb4604100a9a7e298ecc44f628ab41658cd7aa43d332d585c69dc35a41834d4e68055a2ac16a12e3de10365ef2f3573c48c066174a2ddf614773de342d9d795b74b0b99cf418b5990cfa6c46db35195ab91c1f935e3988ef3d78b47d1071f7e21a8489fd799093e342c3f77042aab54b0eb0c1f358b1f6f2a19c2ced359407725e53c9ec2b8fceff3b094414552479f916561ffbf3f7e4f4b84e9d041c7214d28861bc5be79ecd91ba2269508cbb80ff0e018946c57dcdddd71e454b005bd4e7bb7c97cf4af2e6a63fb427e68268c797340fd0c1d86bc2370967dd82ec896f98ac42138b6ed34b45622024376013c9283fadb70c141aabd699bfc92a3509b7725d40fd637159a19b165980b5df480ee8b687e9fa2cce861f0f13996531971105f3784c8479370e60e13660a29a5450526301d63bafaa3933a44daec064e3adc64abb385df5bac0d94ab6153d4d28a0f413138fddbd0e0b0bb49334dda6932d9e45f4abde3fcd4091e4db36110377ebb729b0de243ced2fc6992438758d550490e5460eb2a7f1357ef32b1cc93dbfc0a7bf15fc749efd303a8ac7eb4221a277fe727fa4c43d58e6f45169adf0b81119e8fd880b4aa5c0a1f057512fa26d47e4060c4f7093da26007ea281d308138a0879152d5769a5ee28f3f5782aa5a47775115f4b44c71ffd71b72135da3967ab3dfd39efa44f7a37bbafb15034eed02feca04a4dcb5186cd3ce2152a7543e0ecb3e938581fccbacb5796db0aa607795ae4d3dc099f46905eacd215b7c2ef7834b8371471551e38e53aa92537e0a9771f4f7cca17011faa33fcfdaa866c8a17eff113e466ced6ff006a3d426cec66b293c03c698b7295b73038130ac42dc33bc4e44732f31213743c2f3dea8c0d8a96d3655cb0ad0f0b83980ef8043306ea27efc338978df260a1449f18c97e6e8b17a8fb261d3445496c728b636199a82c84fcdedc45d2f721826bd00ca3e2f94478eda7356fca635747e6611f628073029a893d1dfa616c751a41e98c575db952d6b4cd65ad886bfea690ba22b4188526ab161053622016a6910779e60a7ac2cfd5322f862a817994c803d70c12006d596de2c14b9b0c09ca15f6ea93d5e2fdc903074339945940e28c6813607148ddf0f42008e3fc222a472f35bddb8dcc6f25ea2f5ac3adb6cd97cf14c49e1e956e45b4d308885d43309740fd9641a24c64b60199cd4fd806a053f3bd650347c418bf11039f537cb6bfa8caa6c2e99390eb48979dcc8df04c51a14493a511d7f84abb8496fe75d45afdd46edb50b2782e972465a9006c86fab7814298d6d26e898b0025c2580b32d4e59453fc3f059310210cd4a6829938af722ffa95c5e647fad83f4ca8ba4c5e5c8e46c50b9499ee627be84c92fdb7411c67f9c948b82a44e4426c659c41661d76eba0d6ce5a8a8b5066d26bd01e2d6eb1922cb3374594041096f97b2934a0fbf7092c3cb936d4260c6e4d10f955cedb21ddeede82e1a7dc4ebc852b70b341ebbbf2321777a8f0e56670451271b0521573b79226f7efa274ae4f93b8728d62852c416c8da16c3cb2e67e18e5ba77d73b749e76d8e81e6e451f41dbb6a7ae1b508affc13fc4efadfa0f6ebbc6dc2432553dcfd256474f9f35c6c0528e6b7a04181f04ef90894585c768d31464640d6b346efe46a24d2506b120a62000c892a9b81be47286906e8ebb7b932282aebee6f319ffe58b1281220ba6ffa5fb03325fc5b4a357da3ed37cb6b5862297240c4954047cf861cab7a878c28e430254223fcd78b5db7b2ce5b4312e84a8f1d652562d1bff8a9781dcd36bf8dc6c5a40cf71d05c0987fae12fda362269555cf4ab4063128563033ab0a597cd533c34afe3958b5f0ee73e9004dc8093a2541d78d444c2f4e805ec1d1c58e6c0fa5dd7d63137b798969ee85c5813af82265a939d3883fb1eb42107ffa7a7cfbcd7900ea34ada85f1008368b6713071b18d3ed3ccff23467758618272382b2f6e691254f9a825badf20a8b5c010df10016b9923d6a3a01668eaf5ff4f46372e1766db130318d5b1b62a42d7c6d0dfdfd4f341d05247067c47c24cceaab87f3355a567a77b76c38f2f49267340c09640a0675892314a9f4c018ac7613c7d6e629435463fa6a185e0b4bab4d9753902670bf52d46b3a46c0cd5cad7f2a4b900a50a610766564e7b661eaed3a23838d5d9661ffaca9085dabb59c33fde73798d4221dff36f87f76bc60a46e78e399e07241597d4da4bb8ebf382c92306f95088ad5edfb538aa2f553a4dbcbbe8f383a2f01a678d83fba98a94d150ba452eff11da8b8f0959bd5319d8e9fb543afdda5a139a884e6569aadb1745de5a0a62fc22770a45ed7d9a255d1db8b9c51c2ad24587c567cd5487ae4aa8fd64c9154798cfb41c6b4250b18de8e7be34edd9ff74d0c6986d0565275dfd53c3620034de5161cbc77a0c975345a1acd25c58834f1c9dad581b6d5403d9e4f02724682e1bddcdd74d7415503cc2868f0bc68acfac7074022d0b3180327328b40e758e0b81cd1d956a4c1627e4357ce832ad194cb5be3aa0ae67f55bc40d99143cd1827f71fb3c1c54a542d5bd2b4dc55e37ed805a394fdab81133de14060ada629fbf17c52bc829f61e915f595149417ee0003fa94ecc3228f8bee26a4096702805490da0d781d9bd75bd44bc131d4719b3edb6f817721361f486d5464b96ebe3dc1757244bacf66cbe863f60e5a4e25d9fd664160cc2e74b7bafa4afa949ae15162ed6f13325f0c74af6e39622c4c712f961007b4d0964ae587ce2c8d13b050b697194ab69aeefed9999703bb1a76c815dd8f9a7ebecfac1e9ad75a4a91095a960497e6a09918cfa23ba2305f9f236fb3e86245089c636a9d3d22759ff97f1d6cddc658fb2db30ad6009eb77e74e5dd587589c875a12b70e05d8f9491a8fb9b975a689ad871659a005d1fd8c13b6d8d42a8c0d656a0cabc5d36a1c61820b04d0fc723512ee3c53ce77bc235771aafcef273f3ff21c7fd3e914450877da4557df9f2e47cb0388445846ac173f4d8ff25c801488d5dc2649b63199abaf0b01a7ff9760aeacabca30d2492aa4db42db55aac27ad29550d448ec47e88b83b21aa2fcaf55d6b49e8373e7785685c0fdf45f1d4ab3375bff907958500eb71b267742f033a2a5b462a8865ecfd50ca28c1f9076e48c7f763c0cba85a60800b75c56b2d3ac3d6ab8fb3d8dc2ced5b032292d0dbe8eb130bbfdc58c572653fd1254723d1a7ece50dd68788a9352ff6ed17f7d3d3508cd6fbabc5b1028dd94d7293b013e2ca3b0ff5f9b1b01439d92e4a45f7ff0093b5158c5086492aa971f68725ac0449aebd192cac8452c131220efddf7de51afb3e0c1813a143d7067b00d467d42c8a189aa771d8f886d1c103cdb63719b364dcddf3ec48deaf2a7dd861a4c0cbf438e94244da11a110face1aa2ab3541a9c4f59b12b79485d93cd8913e92ceefaec4389abb6b56663053e871d3283d26ef861721128ae21d7bd4c1163e3934c1740aff4fc650cfeade271f54be749f393a381163a6a292b063e81ffc0cc8bbfa22005d691b9360af64a3e082fda8b51c1fd64af85ca603f17c3d168132fcf7464bbbc6d53f272fbde6769e9f738b9b374eb8852538cfe0ba7a28426d999c40feb26c528030141fa222d338d5a0c87a1c529a4296776dda6e673872a0469cf29149dddf89ddac5b09698f3b2403d17e5019f023a536c3b78bfaf28e803a8db87c6899a64ee325a59cdcff4be03262b8dabf881ec170d275080d728709a750a579a1cd24b4240c1d59f7bf8928c19cb54dbc5c2b8167bab89c2291ebb8d5096ae63529f64324597c9c8a218935a18ad8cc11f950e0cb0b0b0c4132810616db9447b3d36af0ae504ff02d789e37a808c2c06c846926f3e85d9418314e820ccb82afa9f36d33b070a047eadd41fd1eee90aac0f6f7e06a55b1ed3a85475737a604c082fae138533743094a25e4ca29a54318ed48f70916c7bf083821dda6752fa30b340ff952ef1d5e4d94fcc47effc290d9c73a7ea6caf0d36b00a6a4036cd4877e677641e968310ad26bccf3dc5fbbf125dbdfe0050a942d093f107216cf0954babc8365aa364820dbdb91dd62d7c1fa59f64589cebce25a5ae555594293b47994bda002df288fd28143e3ad11ce3ef1b93bead10e3167a691115e1db95ecc8f472ec9b3c7d7194667d2703e550fb1f4ef22dd11a53668057e6de0a84e54665322cb1b8b4ace2e55ea5cc3827d4395d6b963b7cba49a5e79871b074032c2a4f3321064417712e362a4c9f44ecd9a0571e49b69894eb7e7bb072e0714ea85b900012efc51cd264223fed391b50584177952202e3d8b01343ccd2334fb02efc8207b8a79e8e701f94e1370507867a8709711fd6104d9f50deadaf4bb9d04d6ded3ca9c7e3631b87f77d9bb85fa8e2bd2ccae1e8a18a565537805fbd184b1e240487b0049dfbe1f092eafe2642436032c0fa17d2c093bc5144b3ccad52e74b242de35a3300932e2fb801ecddc923a293d5640fa5efdf6db35471814696dc6f84e8309f6d96ce94e8eb217d1bd800c9f87cb74cad5d9e5a55269dc979554f283145562ffac72799f24ab4ae4e742855e3b7655e84a16a1aa4724ecdd2a86e0f58ed1ad5cae41fc0d9d72ceca3ca124f96b021d7783c9432ba50bda5180b3bbac0c692375f4fbb21f457a8b962e9c668a7dc2599a3dd56e1b7f2ae55c7adc77aadd9ca01c5049f71dfb6e5f08aea208eb07ce85483174fb080fe973fc9eac9e49f920f2b3de2c18da6a16f650c8a15cdee8f96b15b36dfdfafe5c18d8b9b38798fcfde009a44c2194b2fa8caf2d114901088f3466d968608ef639802a53f9d31c9a0bf2e614c0882988b6339722735fa0ce28fc2a099770091c9bb5e2014ef77aeebce45d87513634ffda13a0c38845c2bd61af9690938a3a4143d5a8c410c162656c6b49f2e8722bc22ee14f9e2c0bb6871c34c3bc6e640790c24b8639eaeff861f56a2dab42c073e089c4706fe82712a173e109c6558560fa9a852e6624ae7c32be3086dcaea1df2cf7164ded88aed36c54a5ddce1b35c9b6d4028a7a95abb6cd46d501051985449c1afb699bed6d0d66f2194f6665770408025e02eea5a4546137f3fc335808d9586dc4789c5eb7e1bfe9390337d1b536ac5a3c0f1626d071f9cecb4958c1b7fb178fbf8ea116cafe444b084cb5bf053785e6caefe7f17c7b2ffc058d9d98c0197171353a82720d6b59a56d0b004b5a4e78a65f16c75778d1444918d6f32be37b20686a8d1d5178813a1007fb2935ad0f18c887b1eefdf989a42506d6d78083689e0b26cb46b89a7fa84a61d41a802a8aa76269b56ba9f572aca06ea056ab1ae34cc47c495dd4e0e04f291948056668792575b3070312d66b6c47e1cd9229966b676b32c9fec7b2aa6f512778988d38a1e61291dd6ce1ef7619a0912e148f6aeb4b1714b7f01759427ec4411c7fc3464e799b5718dbdec1f0442054602ca5c85f33e22566a5313062e389ca8858d4da9b3372ca5064af60bd5f589dd9e6f95b528bb4e83f8b05ff316fd666c3a93b20309524a9590887458ada83078cd2d76232f628242ded653c5743cf115407dfc497db0bf7bf1f6485a9d07d421a76ac082b7c2f82228c2e160f72743334a66e8b30352a4e09de7df79117916b0faa0d47ecd74834fb312955d603b3c23d32a675bb73dfeeebf6f6905374c86fd335ef9ae1e248ff2bb0d1dedaabeaab75461b414cbf973f93f6d01a62f35dad5006ddbfa0d320eb24ff7da76b2a60320745d2b6facd1fb3824b8209f7f20a2058dc8840b40f1f6fbc2b057ef2888d72312a7f1e378f566fc82394932f8301a0b41315360508da66b2e66d1b0bf90895897d0cf57af1753334e76f7affe81ccd352b9bb504f97afc4ac0250d321b5ff00b64e205cef8a26685757ba7c20679fcc6553849599382a13b24ab39c998d506c4c6448077aad130cf1aa6d9b6fe515bb0bf9d49a99ab98ae05a83e539e5448d20fb7004e9d64c038f33c68e74705f1daf6d595f4566ea0e7a9e3353560677587c970d9244ee86369a96aa26b0184658ca6404163c567a0c8acdcebed056ff7efb74d1716d53bd0e4f10e7a9d28f389955bdb71d06ae9adaf6647fb47d8a4ca0ff15c0622197ac97226196606070b1628f6fda660d1f86533e25ea74f24b5344fa634756c822525017878bb900c9fe74cb56538167a829b63aee33d642059b34fa1e63a7de5c2749ec678c00e9becc29736100ac8bf86178c3ded639338544d37567cd0c89e42bc1bfe6a6f309b50810d144adffc7bd0b89e5182cf1eb1bad2d028b4480756f1a9f8033e0913de1f15e066adf3d51958a6df17045cb6bd19665075a9185abce08226e3b5f6d483b9d736511a95fe71382b6e91efee282dafbcb705812873e0fb2ecc60215f5ffc03de47cf30b5d16af337eb4b60bc5582c122ad60fe129fc308a70d95850ede1be2755f4087a139d50c6d0f3993883cdfd99a09bb24eb480cf2f36e9e432d660cf0e20d9acce57067acbbb8179e2dfa9bed484ef97e30085ebdec2f26945ee23beb911af40369ab60f38b3de97492f73aeae9dfd96f6b6fe7f32c2bddfb676a955898fd9801dbd75e3e7040f3ac3b040247931ae602f1994487fb7d04214a2e89e91c1592f7f1ed037ef963532e2a0ed77db834bad6055ca7b0250c4553a6898d2729a5cc53671d961ac27f90e0dd77eca6dfffca2736003d9eeeb7227dd34bc7fb15ea6b677a5bec6208196c96c2af12b226a0fb02c18e422374a891f7dd5ca86456f33389f38ad0a0f4cc6a620f6e085ff915affba66465188f3157197610bfb433f4607536710a6468204d69f28f10c613caf414fe589cfffa20a23bed07a515d306a2d6b761edcc49407f343991fa99e0ff6892f61cc149da65b3683b23a633e1e3ea8866e1f5b435e60ffbc5945bec55cabe40e97aea050471a7f4074e10c338049c069b3ae5f2b172025a0837870f0020b3fc58b0368ad35aaf9a4923806ae1b78d2793aa49ff5f7e6de907a4016ad2016b607f678c9037b9ca2ed75eb0a1b4b484e8fc96c964bfa41959e4b931326439c6bca5fc15f1e20964402ab97f6b77bbe3aaf87849213f9ff523d58223bcb8b1a28d1c95ea9fc39b0a69c31668a4fb4b047986f5369f2c67d2a1abaaf0d511d98aee596839b7282763944cee49d6c566a22647195f328766ebf42cb3ff54d191a123a02c099e2da3f0d6004c0ac5d069c31825982692f36992925d6013e61ac7ab6454cbc2ee69836f10ca05150fabb4ef612ebf5cf5d2deb39f6070b851f09835773fc0dd2ec5b208a7185bd8f7375323faf978ee4222c0dcb1ed48d97cbcfdc61d484501dbd00aa601f38e86ce354755515ac885a8649850e3cf1dcf5b5e1ec389e069bf08b2151898d524a5169c172bc017576cbee4a3ee23cc62bc5dad62e845993c3100fd0351f1dec3ebdcc71f10d7fe9367a1991f4073998fea3c26c39959d349622e1ad2e8b0ed094c656c111043bef72df0efba9742aaa5f2218f16265c18532978132166f8cd47496e8187c72191ca38614336c21b900255e6007bd5a32698cd151db4ea18fcf95cea90fdcb333908d0d1c1050cec4c3c1a0a0258d4b13eb2a10fbdb9fe4f1cde04fb45d7a56fe78374963877416c5c626644b6e55017614f5c04a97251aa59dd68a1fa90072efc2facb885849af43dcf49af42ee83d6f438147989bc1a20358be5acd2caa1e98b0b7a3d7488feabfced7d1274b22b2d014a03388213237287240ae92dcc768e0ae885fefd887b0e290d1037680f4d5532dbf8da8a49e70697346359512297de0ade71e98350a5acf94e20bf5cf91776f1c247042e58e2c2644aaf387efedc47a965c8bffea1463592fe7bf8ee0c3e7922b59ae0b24ada6956fb73e53ea92c7f44f7f52eee67c44f28e0bfcc7d407c6362e73f41e1797044896e3a61fa563f437d88d456a9aa2096e6eb507960a320759c056614dbe9b17271447b10c8abc6fc01d65e4799d41dd8b0e62724bc91d1a320ab37658fbcdbfaecc4efd6d373eb01b6893545105868858114e14ebc899d18954beaa86987d3201a769d54f939bf39e36502ee897572ffa7c7b2f09c5e71177c06122699e4e3625b3949c95474844e545ab417c6f15615cd74dcc47efe06a17ec29ccc553ecbd6196c0c55a1f31d979b2f6012d6f1d5fd7fd72947108c7e10dffe1d19c9e54abae115a32edbad4036e30e6882e3d0a2d7a3a1d91e6ac3955cf04260b9c22f79cebe52588c682ed34efd16b1b5bc0463712ac7c13d7d85726eb843aea998e25b7bb507cc7ed2990fd5379a84187f9821fa3f8accbae08ba857dfe031a40cf4d1a079c13530d72ad668b1a03c31c609dbd0baaa4cfbec52af80518ad60034c77085ff8d2af67454fd473879b8e494421766badb17cff11bab3882abdcad2413d42308c604c3d7f4f13a9e74a446e33c5e0329f475c21099ca5edb29b1b38d6f24b099dcbf5999677d72266459f9d5a67801dbdbb6ac6f2966a8943b056bda3ac55125ede8c46cd56acc059a4793bad3cf0f89636c7d615271df9edb963c9a3208ac70e61d070c4fe72c3b7bd64863b0df73ee7b0d80e864c3560cd599890eb88ee43b8186ee0c40d7704e8bef3f509d82de7854b7c70ea241c8ba7f685a6065b944f42f90d6ec1f4dcea59e246cc05f02f4d6f8fb8d4df9faaf4ff6eb6a1f25193f51d2c8a3d8d93cc4a76d9622cedcbecb58a5ecd1f5867b811ade8edf2a19e3d9522762aa62cab1f158351f58139f43492fda24d6146c7a0f9179478f3a03fd0c0711b23c24a5ba6b3fb6ea909125580dad2b951ca21dd643f4e7d2f5507a4214e918d4dce64d7fbfdf605ca4199a7aec0072899ab705b1192736a6ae03d487eda91d3d34815c10064ba45550cfececf2201924aeca387369412fbd4604b0abc2adc09739b4a8dd5282cbff09dabeb322291c6a3155a12b26b6e4583183caa8bd31e3c78b907444d17b2446457201bda48e3d79fab45b3a357137b1ba1dfb94347acb2b8e82305f2b0d74bd23b198b1f2456f1a3d2852cdca128825eec506007a76830d6a34c0c429f9b9fc5c110d49b54ce715004281618cd8ff61ea16b6eae9f6075c7b877983cc5f1b7e2d67eaa3472e2184739de17e60286deae53afc95dd0ef7acf5e618fddaf6e675c29bcfae465a3257b9bf81ee14b52c11207c8c3b587d42e37c146fe38722e2bfc755b321a19fa50e0c387e9ad28b583557cbf99eda0589e6da49d9454e18a633b0766fe589d54e7a5a7f26c8af3fc305519609ee3e4091c656ecd992aba813c69d8c4bddc68b66be6210ea1a6d0c71ca14a1ba4e7f295065df314b3f2f5283d9b44fb6ae49a0297b577ad97d1490b5c78604db81b1af0bedaedfb6c9f3f535387ef9840c81f5af2c18f9b432f8a81231b3e38da6624c7d430b048211ceed5917ed2bd07a1b883af6f96ea14e4cb8d69d0fe779fdccf1ae6a7a1e2ab4bdbba6b81206f56071afc30d3ec1e717e1a970be1772bd34a2c07227fc7483158a0d589c82b0f6f2406ca6de3bd947412f0a31d82ae2487550bc0c7de04e3b10eee7e0cf33d6829a9909d245bd0223ae33e8ae3b930ad7d445b3de48b756a1e00dfe6c003f3cfb0983af58e73c6b3b27c119a074c7e58d450a125b49651121880893eb719eebc8f328438b6de63c6a5218ffb45015119bc0dc25f47997b452a04a96802df211d21321be98ae8ea8232852e64e40c2c1ee0c6973ca3d65ffdc9be9fd32f54a83cde92fc98fdeeb6eb8ef97a075dbae0553cb1ce43f816370a6b89f3c80e01e1aa13bffb747d06f2db0b6cd34c16efcfd01e0d77016887ee0b05b9c5fdbe2b2af8c5fe86de5d83b9e71a3ebdda3b93914320193cd749b925c959ff802890aee546e8d91f8759be8558229b8d1c6f687fe410de4711175eab993ef60652eb50034916372d7e1463db81b5757459bb80ef4feb920641f26c578c252ee167c7b48ea8eee25c27912e088fcabb3892bb25ee42273345848baa2fba8761630c969f1036f7de804007ea3bd1207871370ede3040ee45a5876999b5dfad86fa94cfb7cbd88e448f7c61e1f8319d509fe1332e5261ded48d4c2136966cacc9323b188aa25a089cfe04c93e9e8a8b4ff7b598eedd7c4d17b3d7a1c48e8fe50df5884bc78bb38965b2e90fda8a49c8b17810448aa2294b5bd72095a55a789cf2bab238c6ea59acbae47e18ed19f1db1dea7fe0e21271c0bc0698fb3c89d25f081773d64f543ff901ffb1335f834e8d2374746e07ecedfaaa58e51e79a4dffe05fad902fd19356b0e15756065a08d5026794190dd6234354da5cac7ff60032580554bbd3535085a5b54dcea06e69474d4485fdf56634564233d17b69f19d79c47d4dca93d1027a0bc9269fe09e703470dffa86271813b5574b0a31f8248d16dcc8c2d12139f28918b58b5ce327b8978b576e01697fae3c21812f36251dbcf6385a10f4221e2e2d5a904d840d83985bf9b517219bc4a0d38683d98b0d24d75f70201d659f0ee72e8028bdcb704867a835023ecd263b40ad7642f390e0977e9b2edf03cddb9095342c1168dac00b22a753efc7b1a58b0c368efb570e021a41992293ee7642c7267d1e6cbe833e664620a04af158dbcb2a5ee230bdb7383e736ee2250757cef187b6ba5854aee2d96a38c6360b9868672358bb1b0a6366dec15a3910522f22e0b458cd674f5f10824dfa1523d1ac56c1997b72c64abb7da2998bf4182f2a86f6ec1299c26e721c542027455a2d5d4e7ed74db4688f3b75deec73d200f8aa1d399f047e257072e6e19deb608ab45c1331ab7a4ee9e834d450bcb113b9489d9989b9ab815c4795ac4cccadcd98b283d4eeb9fd18269b349826b3416a5ebc3f87fb1b17fd1745c81967001929c0fef3dbf94d960656fd2c17f11d81c53d1aa661031f55dbd97dd2afeb29a01d564434723d4b0c85f41ad868e9a15cd4efd899fb05e4282af24eff93e053b5a79a214f5412f9e6f0a1a67b6ddea79e049f13ec874aa29de9edcbfa8b984571edf601254232d0530dc75dced62255cfada6527713892842d6db06e46f4528332ed4915595241e2366d21ea994848660cfcf3d54d5dcd1c919c0da383b232a3c4f3b391f48876a68553d02e93aac2f3a5f9108dabe853f4111639e6abe3a4666d445a7f8c3d074bfcf54b72edec3025524192c52455750056c9a3324a357ad24b1982edaff44a1f0989d2752040461cff71aa840af2c119dc1edccc7b104383f9b7268048ed9be00b3e95a8a6382bf5afcdcac62f14d14b3a430da80e3e112b182af4a827807e771909b0aa454efafd98852fe63c3c03f2b462a8044324ce1febd866ae91ddd3483183a2adf1c7e73ae698363cd3fc8ec421ff752071054eb53a9fdea2c985effabfe0eaaa7645a541e8ea1e77e11f1867282d458246c34016dd227642c045fabf12b83d22743a2972e06ad2926f3d4e13f3ebd67c38c2e02cd1fac49c5948fb56b8159cec74b15e950172a36b902f2b67741f58998e6faba3eb649aa960e89613f6281027788fef9e093ddf72763910b24ea245c498bf88d96fb37cca4398e20e8fbc02bb742fb88db75aea37f7ddd5dd9c1602127b6a7c9430f0e9b3856a0ee09c805dfcfc596a179aa2bf2e0f6f759f846fb55064d970372b428286e38743fad7a36dd7e0a09d706ad2368629f22a7c015f4ba5e43f6fa6f339da04b3bddacd56b6a7121233327a769aecb33126b71ae8293bde2ef743b96b680b6b2e1cd3f57860b1f76ba9ce6851423ede49d1fe318c389288f1b95463a321b1dc972638f93290f7c11cc7e6109812466e52d12ce94aee80500463fec8b7d566adf671a0e6b977133c12ae4308190e106f0db2125d50dc8d37db54cff935c50902f60b41987ca0d75abca303567d1dc54a637e46fc9f01cc6f7ae208c59a5193e4fd08f665d91c8af719af103bf6ec33a7b50f970338ac40379210d1e1761d6b47803bffd087c4217df9ebff5ddfb72f8efaeca23029b772034c43c0c27cca33f43878d63a3ef3261f3731afc3915b90347df0c0b5f39328da19ab8772847f6e69797ed4b89adcd55b4ce161dff656037b015593c143a3b2bee02131e962d02ccab4b44f56e91f48c9772d72c6cfc7f92697499c0c36fa9d562aad72595031f8dc49555c33b037faae94e41f4714fd65910ae51c862828eedc5fc6a3ad096b3dcf11fbe3d05755a82f5eac1453eab037f29692894a8ab34464a5c969e86dfe259b8c8ff4ff9aeb9b9998fdbfcaea7840914377dd966567c512e53ece44e9df7f7b71c292b75b2d81b4b8f20cd62fadf2a94078e5e2c04c60038a262869b66d30a14948af9472fffaf26a975d7c78256e72e4237d0cfe67c61526bf4c5f8bafbcca8cc7e6f818197769e22f2d301b7f6a61feca64e20c4d6ce2176c6991b0138d08e845b580769cdf388bc07d6a27d01a0e31515ae2579a0bd4259c6946776f7d40b69838513baf43135040a0760093c9c9e8b0c5f341a403447a14382ec0d20cf16f87bbf5087449788131db4170ff28f7b11633ab734275c671bce3175e69852b9e7c6011432ede2ad2bcd675fe5d98746e784fd98deec5abebab641c3ddd76495c3d96347ed7ed49e8210a4da13d61ae3a150bb113ef99d2fbce366ee2b5dbbc2cdfa3c90bd2e1f963844c40098845f7399947005be37eb50500717b93e3f3d46c8b1a6d5b1f1385c68077cde2375be96f5c20de648e8630111d07c7490fa42b750b65b4ba5e96c162908a3c4d30f8033c141a9f8fe235afa057fd727ed62dd5ef1972d3bb696eefec59efeabef206a05057f892fc100d0e897a6327cbec9f14f67d71457e90c14abaa205bf14e77da42af95ef792430dd1bc0395d28be53ee390dea89ca94ac179c8c15f6c840ff37503a2a5625abf165b46333709eebed1cc92c907ade9487c659293828393f306187ee19285162d0c3b9b6575766c446bb25e8cc0b62b2f907e54605f04fcbc9c850c8e00c9846011eab9a3bd7554186236e6a470488c760eed9e0bd35dec4c3ccdfc498be10efc6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
