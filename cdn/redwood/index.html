<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2111ff306bc237aa283f828e954a330b79dc5c2bd48fff4cb10b86434cb93ba76bbbaa976fcdbe9f773d04a3802472f43d7330673a0e8abc0035adb62698095226646561eea53696ff5885dc64edd4790544c87b137945ea9b45f046819f089ce120f5e89062732f92294c0d419b49c9c78ba750e366c82a51e70c4499391045bac740c80ded43441118953f185d62c251e13799a53e8ba3f755ad69421bce90a433f58a4bbb10305dd9ae23848fd3855720722498b853b72ff98070347891ea95493332468403123eb2612231998f7fc9bd9e8626485c13c9904786848e1e050ec4817c0558545aceb39131b7beb17c38f017227d7487511a84240a72143ac6f791c849cccfd7d9b9063205152929f8f4f5d9cc81fa9ba15ec72d7fbd464cf192edb9d4393b3e55bf87ee92c4054ecfdd8215dad471ea1c4e8340e7e00b84c52f943d728effc9b75beebcd887c7540a5a08a7ccdb166cf821cf4924a732dd2300db2970b1c3d39d2edcfdc64ca51226fd9e46c516d23e6d001a106ab6ae2aaaf00c28a633235d7ee00620a22b896bdb77dd0b80551554e15fc69c1b2fe0a31037cda1e0174330ec128ef82a7a9be08ef66dc2390ec4007522e8c9a69369e4b8ba455d0c696789e43a4433c2123069a1036710bb39f055a4de999119f9e144b5aeb35bdc8fe6a81c00e8a85c4f006e627e97e20bcca5d08caad26c2d51348214512e5ffb16e1f425964321d473719c77e53584236ef600cd05325be0817a37d39fd488c52747e40f8a02b630d6c3823ec86df7ccd51f16f5db08fe9b939b78d3b3ae589ed3b31ab16cf4e7de6ceaa32aaba0444f012f6f2997264147f208438ce4ca06db8180dae711788880f15324a1f09ceeb97463e211fd259d1134c4ad530cf9c3ab967b475ed11344fa97232c04ebb65607e95f18552a259c0628891daa26c0f3eaaac8709a57024f4a18fa3dcc38d388193f99dd91faf55f330a734ebea1a814e3fe41b3011a817b524a75dfbb02737aac8d707fe4b23f77f3c2c0ee28f2c52958c71043af9c58a03836a89f8ade5d16791375986a3bfbda0634e0a91a39f68aa220380fb04816861152e976e36bfa7dcd4228b1f8c972a85f286455308d0764f1e294c02bdf936cec3b57d6e7e6c5265b4c5253e4c96fd4a6948a1eebb4329c53af575238dd0605949013214a47803d82f92ada6c46ace55eff1277b0f10b9553eecfa0ddeec632e529693c730d8fb90044e55b0b604e55ac8758cf1a39d855640970a217acd8230b13dd0cb81e5a17fcaa34046e1dc0ed695334f296d96210a1a968c41bcd8b94aaf33fde44ce2446c4f5af61a001aa22ddb8f97421a83469709652246387fe27fb78b0a757b2cf85c2ece624bd105f117b5f32424eae35878fa5abf4a58f3a2d7bbe26841e0a789a1cbbdf17289d755a94254ce98df10a054c6f0d24a323ad204b607025e98e254a6d4effdaf59e87a2a6f4d5d5ac464a89600004d2db726956282c171e3a083865bb259f3ebe47bcbf6d5b3df865f0507fe817cb1e96d15c6cc12c3eb436cbf96269b56fbfd2e15a4b069dbd10d7dcdbe9e84a9217f15b4ce856c34c123df7ffe73a993e6f572e36e7fbd32a3cd7657be415c48a442c07c8f93a95b20c5c52b94c2ce268d894bfeeee05222ffa52144b51dde06c370b2dd7cb44af72d7f3dd36b61cc800e4c41a1df3e122b77c7fc7d5231632413cf4b4ed7570eb76c366c1ccaca1d95fd2d6a2f038eedcbf04dc7913e507907756bd9bdd03a6698ae7cf2e200f5421f1920311cd0a4a99c42ccf573efd39336a385d807b313702f83566c2190655b58e759b4a2db3e1fbb80241118b4b3ecb5d98026b1a0f358f401313ea20caba51fe669377b0f5b20c4a2cbec9ebbfe3c6a2b82704f272b2bf693bbe6e9bb05ff3a9c089438a0220831323ce0a265f40f073db23e905b2d636fbbf57b1cf6bf99c41bb09b87b0e3ae7747831128ce5a17288696c26fde52f1d5510072de6585560ff8636662cb0e23860ca9b88cda696582a597ee003f00df2d1a2cbbf4b71be88f093958cfcb7eb1e20d9fcd846addadd7bec1b2836bd3b3a991a925e9d50306cce822d6f21b0cdfd17be7155f84fa8fc3772e15a4f09f241617161e5e3d3dabdf5f7bca692445f58521ce843236cb453986eeeaa62ae76df032d71034eb3e361f38adf919b922b9b9ef34211c29d6cbd859effaba2ffb83c8831fad6fa4fe52ee9f000fbb47351e3268d2b095d1c37793749069445ac1ac66a134b56d74d80646e3df6e0f32f0ffb80597530eceb20b7c459f25517708fe6d3b6050beec585c934642381aa69f0a00d950e0d9b507cb4276e9041357e6bcdf7f8939c73d765e4950ad5cc4bfe477d1feff445906c10addaa69b3beda7041c6e4c7fdeb017a43ac0d2f7a2bd98839d6cb9cd2efa60099cc34fa61d3dd6e12d186b263d79c55e8f596c160fa50aa706d544baf552be1f04f2597fd5dddd264c71cc1c22d0116845d8224ea1cb57d5dde39e23186cb939040d20b660d4a76f54d5edd4d935b523f9d188a6ba8072a0dd00a29ef7a80a1d3761de525416625f722c0167cab8915ab83badd4c27595d985b3719e0f3db579ed85628b9241146fc35256ac78f01935e3b0b11c8ebb187a38a0d16b38734b2ff2bb945f95f1428d45e368b229e24b39bd1062a3cd4a2c2dca66508aba66aa5cf6f5987bbc4661be18e1a6d8d8394453f147f9beceabb92ed9b69c4060c2275c09b4d83bed958f3f8957140b17d5749229a7871aee0a3112a337ac3a946f64c63b0acec287d76511d0caade7cb1fa11aca95ae18a48e8e3fad7fbc692f6725673d0920f37a31c3e3ba1fba8040d974674c16165a47cc14c5caf5da9a2f249d420718e7085c3cde04dc04e34f082695aaad3a0337f5e7108b73c3f9bd1972457fcc4457d468ad398a8f701b4053a0d843769c27a9364e22d8dcd814aba090487e0dc5b8dc2d841b091223e6b455d15b2b7635f89b37dfaa5b1d7ef568f73fe72216e1639a0094feddf74fc29296105c15e70fe7e60eea7b70648b426e13b42496a184f63058d928801e1807e74c6767352a2fc7037cc8a9473f4d00a6867e0fd15ba32d3dfb1e3d7b01fdbf82603b16dc9863cd256a9fdb6041a1daeb380f2d0009714b47673714a9ec25b8b659f440067a182e21de5434c42cdfcb62f8739a6ba5cd11f8e21a7d93f22c3f67503a8b48d858a94abbae003e1e1a3c24dffd7d1a88d0a5abe897176a4bb472edc33193d4355d081f9497d735263c1806687f1f6712c2a7c1f0b1e6fa0b8535153f6a205191e4bf46796ccd3f16b608e5c6884057747ec4ae0ab89a063283285606b087e1b8b89864cc9975ae96366e0782b0f4d10c0ef706d6dc3ef5eaa82b11c8cd9186ed08eee04ba3bb60cab9d622a62c27352bd42d895618b8abc5916772c3e333c7276607827908acff7ba3418f13f6f3cf7c6d5a038434c62eabe7529a918c6a6518353c71605071e0f793b086c537893556b4e029d774a940daed38a6abf018783216eb36839ad15b76433bcf29d0250c22320df07db62032c2162b4648064600c1c5cbf6f46b9ba371be9a668eb97e56c3c93853387d9aee29d696496b566038b7650f85b78b196dd4234038db2ac4147b1b6e29b18aac7477ea25c28a87f995f35254e087eb548f4dd485e6b132b8162357d22b5dde82474c69e671df5e58b6af63f888b055d724ea7f32ae13b55a312c4daed45c51797961c4c04897cd424ae983e5dc9994b10cae5dd1050e18786364a7bea3fa858a81a6e8f6452198b6b25198e02a1fe97e71bc038b8b96b5fe31e31660c98b94a0ce1b7a873a4358979fc85e8dd7a33748892ca3cd0d8a763d7ec085d26f37c94a7430332e4c3fcaff6b0789b3158c6c7b3fea985b34a5e3e929687cdf5638ee48ec15586a72357366e99052c91fddede74f70075441d0dd15b7f1e4b0c026b71211ae4b95e47688c6a86f954782fdbba60f06cca35e2c7fde3c4f11909fcfcc3e6309133c97e6304d5c0d195f0b038895aea92bb51ce44b0f5b297b31648f8b75de23703cc1a7ab5357cab63b4db9f455877fbb55f3f047331814b651333a69bec4ec2f930cdacb4b74e11600e03b7a27a7b9be71e14432be8f40ccf1cbaae0003f6c0e05afeb3864104053f3371c549b27b462f2bf5ad22fb68f0415f49ef12bc223e2ff3be41886eb276c4c074b5d7553db8a44ad5051f5936ee4dd572f8f95557ce77765a0b2adeb9014194535ba33a871c3cc9e229719e152f0733830998bd6a18b3fa3895d63f1d95ee0ff9415353a593c2992f8f034719fa8d123a7811272ec52c48524156bdece67ebfd7e7ee9ef8e57ffc708edf873880ca992bc89be448aa8c489888c54f6b04dd2892ced16af101fec2880d26309326fd69b2d15d731a6ac851d804f410fba009aa950aafeb1b57a49bc5b908c60ed5b7d3a7e9edb780d9c20594d5372c608a8aa8f3c92105eacb4f5562b34dcf734755db7e546bc4cca187bcf75d56e651224ca673310594b3160cc01fc028720557644a2b7efdb1a4c06fac5896795530b4ed81e8789ba1492ee2263ebe6d1843069ac6e1f6b6a67d095be6c997a718333808f069251240e5190f33303155faf1c209bd5302aa039de770dc3637f8b30d5e834fd2938594450c1efab02e6a1b7ed8ce4b2d63acc3ab071b8f1d9c42cd11d9b0f1fbcd7aa906f785e96a33e0764594e6e42f642d078aecfdb25ad6e3f13316feb013297bd7aa3bb3a8906727d08b2c0205ced67e423262bdefb751e72c74c45bdfe39a2153871c61811ab0b5d12f4fe48e7c6cd3d69af58e1bfe112421d1f6695c62d5cf1f9d96ca5e30f650aba412c470cd4fad8e43fad0e637bd37672cca225db138787e68409be6f0c985a1800b55539a72d8658cbdefec941721df31e7c77ca1c5a3a54e9eb6c9352d11e9372a8dd6f2e0c854ad40c1adb5636291dc317ca3c1ecb795c617339b4f07cef2cf1e7f17bb73d7ddb4bd66dfb6f2d10481216a3304fa8618799872d8fa9c878e22b77a6afdec2c933a96aca732feb80b26449c20b2ac513309b5a50611d124e6150235f02fe9414b78f6900ffefa13a0e1ed75635b4c469453d5d5612403d69a8ffcdbf065e5a483354be87979a1a03cf5c7ea04f642d29a27f2237b6e0aeb8fa0394e0ae2b5b9fff7f573db987f619db62612d731f34e211c78ef1844b819ab93a3274e82a658f7d38ac77defa85cb7e71001ff46e6f3bdedf85ae65548d09f666d7761abb41278b13e6eb20320228aed94ee61ea0965360d1d32458da7bba88d4e6fcd823b96625e51f40cfef0214a24fa334b17a176aa1d79cf50267704cefb39596fab27b69caa7a86f037ec709e4714ec54ae4bc2867ccc3e4e9245cd30522ca0cfc12304494f9b9f97ee857671fdf9deedb36c891de5566d0a5963d4dc012dab9dca39070b36d7d06616f60a17e5e200b333fb46b20b5fcb0cc05a9889eda41a50e4591819d47e00045aa0f243caa01241ee7d5b37b9579a4dc719009dbd1fa3f4b93b7c68e1522d011841ab427f13bcba8daf21073b5a93bcca619a65ebf840d7397370d255634bcbbfb6a2e479d6470b94cf81ba6e6452a24426ec739beffe91c67eb700e21b967f7fab094aa55e0af1a9ed199d62af651ca93e19aa743998083a2d738efda2c45b1df6edad43618ca7832317c547846f0763775ed8641ac48bbcbbf2a8238856c5490a256108b831952c9eb6fe5347a9528bd91900a8bd49ae552a2b00f9bb7e1d1c5624242166e215c869016c104a91f56bf9befa93418e53df2ec1095d26ae528468f8fd3c41e2c3553364db351fac510c0e18133970335afea1c112196b8592e81cb5605bb8b40dfa99be2fd284f821604ec8078a307418bda5567ddeda3b4623db9e062b905355164213970e85e790e60f0c49b090bb63e0f040c17cde14a3cf6141466389e4efd337f9801d3fb2f2ebe2cffb276baa51d048a3f25941cbe576a9b48e504b8b142752d185cbe1a2958391f5748955fcb7ab5f502faa80a60f0cccdda68d2a3ae1054eb7f02333d733282c4c9fe655ca63354636b6ffebe56e924355bffc176db02f2b3c89580f0c184bf3656c975ef63b4d9f978bdd2da5276956cef307ceebf7305b7dcb3c9eb23b71f19b3b1c997ce08c9eb0bdca20da61a081047c4230f0af20d339d1b7453dbf7100742863f137c2153e3d95d478eb8341a49631295361ba362278158a8ebac812731716e9f92d9a5d4b7e744d7466e29af5025db014048f71d22162d1704455028e77c0da2ad7aa9a2d7aeab4748f088e39f1e0ab3195c7548fb7e7153a8312faed8d5bd967b779d96eb55ec8d8d8f5900dcbc7a60f6b11b320002feb4d8888477fed6868fdfb376efb1533ce7aec8877e9cc5a3b88e8697091f43f33eb33aab253206dbfda58d02f8c0c70073107e0df72a2486f88d34a172066c20add6f98a1aabe84c15380aa271307d9c50f03dfe04f4d5a0186c4bd608883e79449ad4cc62d15f000bd25e7cb181b72e5163013f3e37b32234c2d90670077a37bd9847cabe2e12da27e6dfebd2d911bed9ebd6abe8add8683b5d869a9649cce071ad8ea8e05b0a9542c1a9cf17f6f2dbc443b6cfc7ffbcc4d2a9a55db4c7af738c8760d6670eb540d7a7ad7ba3001c40e461094966039c718dba4bc8840ca190eb0d4a92754a0a706853e2008647faec2ed5ada8e2e2ef2b91e1c06c5cd75f93d84ddab935534a6d0cc77dcbecffd4965fbc16692b1b8fd35c9efc5b0eb4eb65c6b8a2ca806abca77700134248b0c17780588be37731371ba1bae72bb004e7f02c58e464ee9ad38cb25b257ea86099f22e970ed98d4f050f6074ff225c145daeb092d66d041ed281b8dc10f2bb1fe322eddf729f775f1f87adaac177d9a57193141895c0c66b6fd025231c749646934cb6611327861dabcbdf7ee6da6dbafefb661794aee864151e82b56ebc06ae7f0e8731ae4d1f2d13ec28faed999518bdaeb4b2e11578c9e26671fdacfb3a0bbd4fe58aef4b8bcbf38d7478f6f6918b7719fb7f45a6da1ee73748ff00c7472b890ec916744cdb1efec64cabe1581b2bb63392ecb2c6c0963d05429e206deb43100f5ba7ebda4232fd6774d34f0ab76d99963be5daacab158aa605fa11e5d99b6a4e584f68406f2114729a7923709f95f187ce0fa1cb35e81fa9dcb4fb35d11629827684629708c6320681ad3f55b2082891548f66db889353191404d41410f43515b2530f6c9539908a48a34f1b5baa154eee057743488e320b875033b688af4b93d444c5f65ff800fba1d4f78287cc25d3d22c33d9416bd29a428598ff7a6fddc0610455af255483c5439430aea7114980a417f4b23131e6189913b3216d1d787dcbca0fb354ff254862ad2a995450fa3092d3f6254af84dd435dcbf572a47b2266d3eac12835e271eb6e94ae675e256c026e7a78c5ebf5fb8008377e28901e2396bff71b01c837963d0587738a61648d338893e6d462504a670b5b6fd9dca08cee961158d4f4bf382d9a77ad6ba9cb8e26f194d8a5b59f573800c4da9c7074a4c49e5644bc8b2506c94b79d6bd95b61955d8b8e82551d12554c0ae2d07454a5d3bd5e64c177afa339feb57bc3ee2177f5d8971010fb81bf6f540935c85a3069f314cb938b247e822680f92bccbef8e57ce4ab2431ce54fd62e779919222fcec4c5bf2f768d0a28666b6e8367529bbaefc018fb0826a6f8216a8322682358518dfad2500777948c0fe578bc4b205a89af7c2c08155a9798e66517d29f3810ac444b06947803f6780c025c2b833e6f762e833094f7999bdbcf20bd9d397b8b21151940e1f39702a651f3016a1fa0e179d05c7f4af33d81068f3070ad29af0d6955d81b70a4d7084ef7b12e0aa03d1c8ed431845f239ab8c771f46e5e17a904496f49bc720509d1342622967c8ecb233ea859df3f0666089b7b8809546454317b8916ef21b6f5d76adac832f074b949c3fcab146a568aeeead5c03e2ec8889a1cb57961ccc73599871c8a708d02228e86fb4928d5f842829680bbb3c8e3d296b30bde67ead2bc5c9907ce88db6d25573ad0c24d75b7c773b194f6319d02ce86dfd5d4ef3605ae0e507e29195a887a41db1111837012acc89a7517f1bb999cfeb926299ceaf1f77d948a7f278ca52c87eda8a7a6e2ecbc9793f9f589f73be4a4230c348372a2d3204228389ddd2619bd343fa0ccf1cf9d4caa420a98636f0d3848fffce4e7822613a805071cd60f3cfeffab71b91a56f4627cb4c3709fd1bee1fefb7de0ebe43a1d86db21ed156d75d2f317a785e6860705bffafcb9863d962f89360afd5f94f71f2816cf514cb76821554b405f2dfb90a044ba8f0e432b21e5a5669e8cf47943a644a29707aa4e779abb4d84cb9e5ab49f58fa7382354c6bf70f4f3cd7bf6f4bee3644be9be00fae6b5086f6d009d44637a6c58a05ecbb3b2919141dd2238a7ea2ba794da071c15cf100fbfdfe95f290c06a80f3e47de2eabb53cac670a0154e1a97a66ac931a8ac761a4e539888de043fc34b3721be80115a43a65b5daa3cfda94dac62167bd6b3fee72a789ef8831b669955cd6e6e3c592be644f3e3b89660965a4b96d9c6140e60bd5e48dcc9ed111d372efd67aea0a6e38c9bf84d6bc485e6a6fede3df9667a0cc2c6deefae2ea67d12d5820a0adec16adf10642bcdad23ce363ef6776a9925dafcfa446db6984492469d8ed0ea36a3ef0f8f1ef92ac0f402f79da9fd9b136735a0077cd75c4d836c4a995c2a815481dccc9f4e20ca521f14ccbb8d73e4b76e82a4245e35ae60988baaa2f28dc37a3538e2106c14bf60aa5c7f4659793c1c8c827d9e04f7406c65c5e764707d2f73247bd13c36a1333196733a7bcc5be8f54acf4cc7a7089b651f88be14e9c61d18f18671dbdf315c12df118ab514a2c053237f3d77c5cfc836a1b63c8c841821f185302d071fce1726cbb3f3bf060a6da428d01b235b2d60ad748533f2399ca62e8b011bcc022a5acc14fd58295eed69466763adc2f779f8d287dc603671e9e1e105eb3907d0de1ecba0ddd76b565dc129273c7b15027c6e48e890847ae44c88adfef05012cbb9b7a890076e035dce8e0ace0ed967906c118932e4f191d43ca5cbd328dcf4693ebee6069f10ebbc0d49c2beb342eb2da6b42e6e22e20fe3a0516f1eab7956d772bce806cb501140cf2c5c4a26fed80677b1990a1f59abfe76f5f758c0d8dbc45516bbf85e6801f1714d0f05304180f22b9c5e9b94ec2693cce620900d4829eca904837f3acac0699c3a1d6e105a4dfc181ee27b0a92a3e3b8bb36d4f67054505e0b5f16a6e438adbd1e6685e67c8cc0af16f1f0cb58709b7b60a6d21cee3c5f008b2525b9354169246f31e34a64e48550eecaf4a07892ad3e1fe597ebc6b625b4cdd306b5a280b4aa94b13c6e62dcc686e6978feb547cf3e54cad4c2d3e36b30fdc80635ce351ecfd042204b40123e1b7a5c39c804b5b1d6f5c6316a4f8cb99b44752f28e0b313d8859896fca8f90900d6369267cfbb1fce11c1ea2248d725f1dbdd6617f967256a73be4be32a5df943b552b0bc394a11fd2f03eb2df71e740a1b7fc90f6ec02b14120ca9066d823f23cf4379e686a658626c6be993139784dd23dae61d718094dbf200853fa417f16952ae7595930557c8f27432f1c7b32026d97b1a162a31a7e922e359183814facbaf1723d66a22ef82457a591b4910b757243dbc54d9f22059d8f6fe1dd2394ce539a13321be1a8c6fa0e66b471e166a083d559c293321eda410c845beba5b468f3cc42e3f5f75dea10fbaae07f0dd7247578522ffb63f4b95345e4f56052fef645eaff7063485d0fb2de8597273ef9a21e4901a26e9af8f16c4b2bb255b4c486f4850b15ca78b659938cf23039b47b1b4ab9501e4753fab16893412394b7bd4c5a75633aa90a55f53ea8d3481cc0099075cba4aadf641580dcc99c8db37e555f7d0b615ab354a369e90934195c852088a44c5995307d47c79be0edb935e08cfd6b1122ecd8a0d3bfc3122fbabe376e1fe5fba440d9830a330d5c33867e56766bb17c5fa8a8e92a9b00eaafc9f009715275e2b65a926640aecdcfc939c338a85b8defe9ac033c11cbb6b45d8d25e2fe838ec30da0d02fbac603a4e42e6e7697c8c94b6c1abf8ec5fa47c3287ecd241a96997ac08fc0071f8676136cb3a3bf886f2aa4bf513fcf9dbd1b2b51e3933c0a2472ed79b8b6255c4815cd155b16098bd7db8f8aea181fbb8e148752de9d4b76366e44fca397b1737d04eb7ebed6cac7eaa3ff4154ff863ca65aa59b0a775418e794d30f9bfede02f33284f89f28818d2f85f34fdd37108e42cb8c5fb1298d4bd57f45970bea02a2d7bbb16c897e0c2ab2572046bc67c3858cbd188be6f84c01f86bf500e2c7a728c0cafba23286aebff172ea3d9d76b7dbd3b8d4525b691c3dbab52596e516469cc67c6b81ce324e382c9293a231d1e161396f2845966b892f333f47b95f146fc7029b5d462c72af6704874befc62e01911291d0d7256f4e866a0089bf95b9a9d5a3ff8f58d3edca614922f2d301a1678e9f5651e6a68b91b101e191a78c28d35ae494bbabb01188bf44b64216220c53f3090baab16908e8dd24bfb2309cf450775e4938e0194ae366e03343a290635d54457dae7cfdd09ccdfc9d637962080856723ea61cb82d07c6c0791a865870f95b8266bc537a74ecfdc97621fb38cb84cd1b7b8e9a446683fd8844edabebdc61a32030c5ffd25fa31d94a821fc799525911bfd83c5fe57b3356de485c37e9662c9f8deffcd8328d36d8a01ee16be22e3d2cd823392999838c8e44c3ef4f5e9edbac4a87775e0e70d77e4d28b53b72894838fc02120fce1aa36cd362b2f62f23ce9a2acacc337d179f284c6134958b0fc41dfb1cb5e9a627c86e03cff9095b895719b7ba3ba9eac134a97833ea72f4477374e0180a187e5de6cfad25d4f31494631235ead2f0151266005b0f8ef46bc778e05ca9525397ed54422ef3b1d502bb5e40bca47b0636ce46b21896ebb16f9bfd4cb921bdc075d1e0a84f8f5789dd2f84478f99a0e167ee700ca806346f83b437b027619b297f171caa8916b9f67e638db7622ac9afa258ade2442db7742bb9ddfbf8784be78859f31fcce2189dc5cf8efd6c2ad1f16457913c98f4f2e4937ca597e8a27968e9256f16cbb4099da22e90ec520da3956c1f8790b35ccf65be06bb9e62b6c31e42b83c5f8f70486cb42dfd2b5c248393b22dc012eee0cab3f394192dfa832f518b2278536cff4174f3c872cada1dd77767c4fdbd6e47b96fd26482b8addbd863c3c00e3db38976bb01b02044a6bfc4b555e9b2dc623e476db41488dbbe340411a8d4a25e0d5e47d856ef02678fb4e479073af1db0dc4be59dfef40aea771ae994e5db83e38df9611392d9cfc78ac5a04887330c35ba4e551f1b435198c0bc2af31aa267c1bc5cb0cf891b280b9180543c9e319b2cfaf1f7e8618f108b7bbc2e01b4dbde949e9c0999ffd2b4466f7a31aefc3927c38c28da9d0b3700a185f7a0541fcfa95ea7dd1e8351af8a3bb7a015f495ed725faa845b151755527b464a5c6c0a662c8bbbf594b26011e7cf441a7a3d09f9d0c146d7ebd2618ee9ed634d32662f995496696005f6c971e8ce06c5cc169f290579ec09eaeac2930a17b1b5ab0646a78b51ba065608281a2ca720570e48346dfc2f22a4faded1aae807fa75bd300167cb946ce0ffe159a62d7993e76cdc95028e00a5e8fa0c34ca90e5bbc80d2aea4583fe6d64be7fc936818fcd02a46c026fbe27cb85886ab718a49cd1e7517ccf5e8778a46651122f9d9893b65f2ff66bfcc071783ffbbc56eaf6fa9f3f1a9cd20fcbb1b13017e099ef9d3922c546e903ff0cd21689d062942fbe893d560ace9c824cc8549350393222c08cf0cdfb3ccb600bd9f05a6c0a303771add28e9c72c143d015ec09db5fcb17a3e3e10a9a7d80dcaf79a1e29d049c36f2be76dfe0fd8990158dc00fd58300bac085d5b32c5421e11514cd03ce01f903ab8f951595ef9abb293e043c1168f12293f48fab6c57250c4aa8b39705110ee5db746442c0f678d31b6212e6780400907b5c2003aff8f9990c271d52f30587f1eccb3b45e15db073bf3177a0a1eb4e5d7ca9fcd4f68d56d26618aea3ede3522e703d2207d8ca66f02d14661f131ca9edc57f3f5f6f07434210f42c05ad0f4313ea210f77650b8255c9df62de02c19c944be7008a06e479fc930cad56c16a433ffe5675c38943491c50aa70b7a577b4814dc8d541aec55603a9b76c810dec59fbb21f98e06f5d4ecba758863d64144533f296d0009891f82196d5aebf5752490fdb729b0be77adcff95418d231bdb8c38204e935630a6e3c0a8740264b3d0805548d1c24a3513c2beb12c64b53d40024a7139c0e1f8db1452ae4a2f746be4b5d4396d4fc0287c96e767f0dcaa48f711550350fb0f0ceec23d82db40311867a1bac41a41f5cacdd8343526feea020503e0c515a30357b0ac30e13c810c6e9b35c750fb18072fca2e04a685fab14adc79877591e30cd030bafde08dab9f890139ed85413e8c5831786fe3dfd58ef7f7c9ced280545740c0dc5751a38f8fd4e1dd3c3955da31accf46e277b377c73c3adc164b15a7ccfd8eb45b7bdfbc18a365d4b93e83ed4d40da5d22d93b969045768fd6af99345c7d379b8b1a8689505c9ade1f345e4d361ac58613917a322429c79f3352f778239e4d2bcc1a1dd8880bebce69a639f66168dfc2c8cd0644d9202cc941ac4a646f6841af7992709cd6009a69eb2a6f63bb30d1eaa2dadd86055fb4b1da877e886daa3390a3ceed5c7fafe1842afb53a71d9a19685c713b99c7e79cd506288ddb3981e453a6eb11a1c363e097444556470d2ce161a67298909fc8dd4d365fb938b56424b1b6069e8b0cdd706e24f18ca21cf9bd45d29b2a08defc5083cb02af7f00d69bc0c7de4192b054792e233f71bbf47e6b4d13d5a8c7cf15c734598bac40122ea9dd2ecaf62c6e028bb8a7f147735c1266e6557e59319e7d283f86f0f19c9fcf9d05cb8fa86478dc6f9d7a437879edd6def24b7177036302a1af70c4b578578f87f33e5cd8797bc1ee0008982b8e985f7ea17515762a3e72c2c19a24829c2901d8dc6fee210cfb687ef788034eb12ab069511d39e3deff8e87fae567aaad6faf422b7eecc6e2efe50590a02074fb60a643a56932c888a9ebe2b2d997a24c9269191bf8008032f90cee1dcfb6becce3f75b1d2f748c11700836a85363fed3e8a9cdcee1659d72c014649277a39391fa88bf394e459d1042b2f90896f33799767883633becf6dd61717afaa9b32931269c0cd78e167b7f455fe6a24e1151220eaff5fd0dd8f42afed9d5a55b05dfc85a2355bf6323f0e87f579e78aa4bb1a6caf6c5d047acf7fdf6e3018727b7fe20d9a2198f6dd71ae68e23169d999c63fe8bfb3bd8b1d84a9ebb421721473b54cdb23d979e7b9f85695e1a36c7e12ee314336d2eadfa5ab677d12f166d43d0fcf10b4df0985854b200a1fa5fa4316177d30ba5d116c39e4bc8b5ba46ca12faae06a05bff9b71169f99f6b117849eeb84ad177ca7067f51b82928b6954bfea4c80ff05cb038b27b07583de8ce723c9e6f511d04d3e0b885b739494587cc0566c4b9d587a8f3604eed7e1cb5fdc1ea8b8338a5f099833ea680040f8e11aae47b0253086adee1a66949b0e8cee145cf4b2a58df3367150980865fb579dbe8e412fa11eb036c76754342f3b65d1b5df3685a0e3f1574efbb1647fec4553412196e9025c1859295907c7efbbfc2b2e2847f5c24522b591997f8d57d3ccc9d88cd133715e4236fa74a32a3e20f848c38004b7c092c1da9e337240959b499fd1a6e9a2fd7e28ba26abe032f09cbd3c1c313fd2c684eeeae7cc3339eac0b879e170182bbe35e4f8cd3416f431d6f539fb6cf1fdc1bf4ee5cdfbbf74241f20b4d63cf40b940c58734403178317ad1fd3baff4b90abe92d119bbc6273f5f7c712ce9d8e2e106f33db29e375a8b3349e5918364fe78d2286418641463256dacae3758c95bb509a650cec9437821390dec5cd946680b2c303e8e143532fdbb65e8f9168fb7f648ac2e4cbdf309643afb6acd232d2551400ba01ff0eb818683d1e2fc919b3d452b95098386a2c306e49244e6e69bd7565ef4f8c4551fdd5888f7a194f3468e7682327e683deb6f6940442dca338c0934dccba832a2aaa7dbba900f3bb657a5fa1b806d2f46e99a1a2a12a3a4595e4a4cde20c898767e94225086598aaee3fec90718e7a509399002c97520fa1827f991f2aab1203b0591700b3909eeb8659ee19878050c56ec09359dd1c3b948f164553514c1fe93c6657104862ebf42492586a827489895c932bfa7874c5f64dd714c6d5054b9f8cee9bda60d7202c167d1cb0b2eecfeb6822112ac0fb54bb667f6c0ff2b93095c815d77de5a428a21b671301d22b485b0c7c865aedef372aa118fba77fcb0e57861ebbb48795a6ce3e9541d9ca65e4619eced54d551df85b34e65ad2a805d602fdb21e319f685adcd457f228428919a0635846db0cc1827054dd2b6978608ffd6c46a33d7c82a19f8f5058b6b36543c56770ba58de41c8e4a0a51623b722560df20089fd8f7e6f4630f18c236f2394bdf4e0f8eb38e2e5c9c34ed9c7a00cb09e3ffe865370444e605e95af2b79d210736dc7bb53a25e6632534a8b301fb61acd94d0d9baeb17d8a18a9d80f9f7367916517fd952e6fce8459707bb2338d054d008e5df699dbe967b72c0c2c8786968f074a1e13714c2d236d4204787d54cf7a5848cec387b986e5a9173c216f3d41b7971f501266110c868acbd218a5fdf65cb01ed6659d6e446f522ee35dc93845fd1a6f6d7ba6a397a69a7cc6f8cfbd5a1943b3f4335a53b9cbfc113bb073a68218cdeaa16068b37eabfd3feb306a5fca4dc2827419cd124fc21b9c315a47a368bef0676a0bb98d78791cf0f6c5cef34fd1d22fb3be866008ab6946bb089718093cfeff4bee29da50bf9a248c0c34fa8dfcfa70f61c9000b60c52004eff27606f4c8537b4157603bd2c1e056dffc333ba0d6ae6c167ae9a31a181bf0b6bde1da9e152d1717269c8ef6e75ff9ba0a8504c9e56098eb8152a1a8b866139409b860a1b345c34527760167bba3388255cbbe3204e20fa3d35ae24b976f956dc72f35ddbda86fa93b72060c6824d15daacb5243900589b25a28b328644a11c637c039b374fe0f9563c7cd34c7287d3637348f4de0f9c20f69437d634da5bb085de5284c1995fe3995ff8f08f014df3b9f727b77e5d38c8d3b1ca4751ab1f25b11456fec7626435e5bc62e5ba6babeec139d959ea75ac1a92a2b78141e3d9d5479aa592b17448b943330c55f2c71f8716bd3ea8f1a7c57df00de494a079681d6bb8d62daa7e675f9a80e6cdb1d79edb84638391c97da0ef5ba602b0fa79931d3e7ba703739d1c7279db4cb77370c87b77a76d004ccb9662a777efef31e5d9bf6b59704eef3d1f363922fd1b258ecddb89bb9cab2cac12c31ad17b354a70b4dd78958d7c4a64235fd33da0870c4ea6b8ac10bbaea8233efabc76daa816b7fd79fb46320f8b9d977f0fe3f585674ba4fb2f37ec9c211cc12bf76a79c8237872c10858fb0c616cf57aab9e4530525bd5a93d50910eddb91c80e6976ee094a5ae3aaaf587351d083fea494a491f4453b347e7280938f64dc93458fe9ce1e7948f8f6bb45f6f6c73b04ce6d2c0ff7198c5dace16e1aae40a49d704d6e0f649fd8381da80adeda50e058d3f0ea5174424af63fdaf2e8ba8e756e0d6f97a43f65e8bacefcae8e7e33b6c692e1279ee4de4c79ec3736e3a30f2e9bae7dc2a0da8bf9feb8488d3cdb32b37a664252c46a6f9e53395ce5edf39630d3ca1532a334f15868fe1efb323c89e51657b0ef639852fc0ef82eb74a346b669062cb41e6f6023ed2f893e4866def8db3e3ddf1a382cff26a922a07316b1b05dccad356bcdeaeeb35ba124987a767ed223a2f3e460297c2f83effff4a514833566520f995b668e5a0a1a8a6a97d9bea0295eccc5c963705f62d8c7899c335b3e5f7091ff8938287725c5fea4793006665c1b39a1c7b4cdc59ece7e3ea820edcc93dc82a8fd9422eabdcffb36d7d76bb359526d2ec773a1cca445ee65cd239873230b85ec0a43263f99d3b9baef289c8361c153ef5875ed97af4aaa45f48d9763f4844357d2ddd4bcbbe7778bd2373d104216147319d8ec34b34685a72c92af2614ec89cf5e8e04953d06958ca4e0981d5bab6496d48b5fe9df384844514594e59f779c3064653f7be3529e6aef8bfe130067061a2cbcf04a822d11a3c38c229de7b1e044385026389931209084688112c2c7b061d1a214d0f1042dc383ef3d881ebd54db064b8a4c621d67a7f1a9eec13b29e83f7bb774cd44ecaa6d37bf76bfe970bb834eef43894b9e48e263c58c605e7c89f88f460d0d1b816c9c963415f52b73e802a788349a6831c21e9a437cc219cf294183f1fb2d583ff2ad80182c410e6bd3d33a7869a7798527d6b149a779a392e454fe3c6805b3f9a0298d3d613e0bce71fcd7b4cd4395aab1bb8761cc970f44f7ebfde40fb0b493ba33374dbd856c6b365a50932491ae6d5da5f19902086db8045cdfd0da8727ddabba2b79e7b8a4dd6017095351383c86fdd0ff771844c2a2bf1d8c128263f5dc272f08d3dc514f89ea1333976ffd84d4c8ba00d71ccacdc5702b28f7c84fb29e13db15599db609a2b722fbbf56d6e595da92f581e7f86ae149d45bbcdaabb921c7edfad36e8281802fedef6b6854ca0674ab11973bafde074e5a7d2b0fed6af87daad258c732ca812f370110d7cb69d251558a2543a271300e419b3232793711f92e4eb3f91b7af31a39db30c80b28480fe0ed3b6a3d57442ac290258d0bac0276693097ff59472054c3b42f602bf4f06d1bb73b701e4493f11a007f4704d5e31500c8082e2c41b3d3e0614126ece8262b3b83da9b2ddb1827703c7a885c31c4840c28b263341bdddc75fd7737b382683bbe3db30d5749695ef5f38d5dbcb1900f0fd9a366857fe81bda1cb6f40286f5c7c64de89f32956bf10023a2b7024ac18970c99f88524bb6a3e5a49df2b5d29e2dc67b9af53c64c362416be6c0fcc17d1c7268f56ac657802e032b8b5114cbe43fc1e1f0fc2f70f443a1e1cc6028c2f4a2ff81c9eefb5faf678ceb788009b2ccb478afa1b490475070d19421bb42f837e7363746f1ad81416cc0db4f63cbf43e19aeb5e860adde390183f1d7a91ed866c28ed1d3d5d5f9d34512864551b7cd04bc4e767908d03664927aeae9281fc79990e5d855d4912eed52e372a63834995d3a1d55703f1b08aaa46256b1cf18f3443e83c8eb2ca1dfd5256ff1054b209c3dc77a7fe5cf5b1e57995594de1f739ba4a8313cbb906853b1c6a15baf3512fb325d42b1683e27cc387d7d440cab6e5f879039461b69c387c80a3a08e3f4287ba252c06d06662773d0f2f73ac6f74a322c4e566ccc947898c0612b02eb7a3f1c1894df85dfc0f7061ab729e5a0d4b9b39cc2c1d763a7cf385b35cdab69dfb90c5dd21f6f32016944729a8ac2b0c449d9a8c56386fdcbd4aa3c0092ffb410fb0794c0de772755298183750a36d0ed8af239daa81abad308e600b96241000fbfdaa0d26a02e434d0f6ff6d4f0085d1f5ecb2b43bd90dd76e86ed29cb3ee8afbbcd97dddfc5afb22f6b3a387637fafed95a38eac566cada4a7753f1a0eb55af624e39c71ce516dc10b483cacb564b0779638156460cdeacf2ac457634dbbf077b60f582301b07c57e39d74f92a82b1ad934d046911b641f11f132304295aa09baab2239dfc1f95c3ee188f60f629a7046c451babd75d4eb6702c0a086712171f852a0d8f7df12f2d47b2b9690ee2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
