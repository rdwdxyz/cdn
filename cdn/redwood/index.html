<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"78a3fe49721996a6ab0342621fb8292b5e37d9ff7f63508f57c2d517332d7f6b00f44053d94659ccafe5202e74bb44ae8ccf4426b65305a29acc0840ac6ad913a11d911ac572628a328caece4cf1597ce404431863cc8a97f7f2bf5d79d67b83e914e51b90a4079f1f82b75f0e6c9b317db97ab8d6bf3bbce0f735c57497e728f470a769f8893a086dcfdd6a510e3c77f8171816709dc0bae801dc5ace48955787a544d6dc17bccb1f1033885978b1abb762adeeb563309ec1555571191d038f20de11147e50819b016ed80e4663fa1cff428b8036d5d59520876adbab798cecd67f8e88c36e359db048b3d5760765749058f5e6c4ace1ae77b8f1e002060141a12048ef4746d974eb814f32dd738c1f320e1d8de8b19f51b902aebc9239c5e4e2fadfb105bbdd7a25fd4f6815ce9b5540528d8648b3c4da91022bbd0478ee4052b1534185809c69722ba9ae47841eae0c6f8eebdba70a48c6ec6a2593745efbd75c3defcb37ea553169e79609b98a292aa13e674b9c8968ec1a6f9149acb8c90c60f972ef955b80578171a8cc9c5005308b0bcdadf8202ef37eff19968d2acae497726eef9120f768eb8ffeae229486e4a3778e48fe73543a7b349074c4c2f0a01bf5fa8719d1b96dbb326c269993df9f7f10b8ce164188bceb6a2d7dbdd6a0c30f0bfb8f395c300dd27aed697407ffdcc28c0d114eb656ab31d3ecc7fdc04ceb200257f0d642571f2c5a5256c2cfad47698ad362a9b2f62cd9e70179f4b952e32124855ce28c0d8924490b185cbc35e26b498c02a1501b3f257a2a2eceda207f0d615d383b7703af79fa079d5b9a17bbe2dd18e012eae9bde09619cce9f64f6e84d6581952022ea343e6c7a25f17ad49a4804b6c3ab70ab954d025af15b35a682778132cb789dbc0801e6c14e24798e62cc72d2e67b600fb691a09aa979330d97ffac1c11381a9f187aeb7993298ad6ca91374572688b14d4aab06d26c7949f538fc9ee3fb01b64a0bcf6ec25d04b233aeac183f057e753e8bac3798b19416642011b3a418f05e5fd0a89665542ed8c9d28cfac4aac152c7b17e38e03c873ed867336f36b127481a15173637b9b05a0b9e77f051e98c7517e294850885e51798e5bfd005ad04403779ed6f367d31dcc4746ed422730de5ea38a4457f262a015d4f557ed5ab14736b1cc4e2d69fc9101dd54c2dacb30842db4d0b538f5a2e06e250cb2dd90686b5335f6edd3031aac881a95802627c5185997d8c76a49443559f0dcbd0ef7d517739183c21aef522e294d36640f95d0432e8b74ef6c79c7175125620d71b1913c18347be0d72daba7ec51eaf3c0c12ebc506104090cec5dd205e4f8fa75a0d51874b17c46f0172baba8d48b0e286808165b782cb9087d158c7accdf0f6ad66b169052f898c1b00e3e7aada3786cbdc0032adb1594b513ca26328013baf9e1bea090ec9b6c66e166079f8fecaca3414c7cf9a169c8181b3189e9abd4a3d5e45363d1aada197e2f85fccc671451f9f2194f2cd72910c35a09f92ebdfd2c02ab5f0a210ab7b8287227d87ed0362f626cdd1e6049a554289525787822d68cfea0eec24d8921a05cc2d56e29d5de13ce14faceb7a2e1e33a013478a3709057599252ef552d1c4abf49518b5b4ed479c4717a49ea6a38f826aa5955895db98cda13374805fa5ee0f72fc41664d3b21be3b07aa5eba74795afae7cddecfcf01440e5335bee9269ca0681a514c797a32dd1d5275034064e5eb834349f33a187ac5c5d912e5092df9a1d3eebf788b41abfa5abd7aee3ba7741cfc42c985d991732cd65720decc3323a4fc6e950506dd945b93b25a9c8d6c875ceb5f3a5a0eaaddbc6af6310822d9a7c9fc9fe40868c79e3c2f6ecacf66d159c8de76502a31ebbf38af6c9dc9583f3ef517fa8d429ae8273990319156285d4acd1f489a3c9e72ca3cb9af7d54a554b71859778ff569758db8307b9b60e06cac517d5eb238fbce3dd9660ba6bd68216ff56e2c3c226aa45dd2b4520b93ad58f0237ae1f04e5fcf0bea001561a8229465dcbc4ab4801474454cbae479b6856d5e1abd68972bad816d0ec51180195b119b0a17c85f7286b801ffb0fe1f3af3d3bbf5b3f9292d8a866c9ffa4ef3cc898f21c4a2b3e676178a9ed7f2a5a74796f1b4722b80f226ca6525719cef17e242eb76341801ad0f8ebfaa6987225b810b2617e48be627a6eed35ff36d20015fee8f58c1a3da879ccb09611c625c8e2e45e2a229a9d6a9080d0f4be38edc1c869ee63073ce89031fe78552b9f4d5ee9638afe9bc79a12f8813ce5e07a084d15676f829bc182e458742895b8d8eaeed529e086b7a579ae704b3802c79fe9b9880c3de2d90c981922c94c31b1de1a69ad7565b421f611a70b203587ae1a037fe00adf16ca2fb262b8b19a442e6ab8cd9cc29f5437197599da0877b4ad7e7ed671e734b92e1e0cbeb84721b5131348e77617290071c7c47750d9fd4c4390bef30e5c2a09c2d094a09215c2467357b714b85d9f606846141a19ee11d07e1b3505b9c91691b019cc59ead1cefb44e05c7e9ec8256098d799d22ce26d7fceaec365c6a868c3b8580366dc336ddb8cfd03c5ce092c2b9e44ab22ba062f70ac85f0ce5136ec5da6933d526bfc3ddd5c53f44a6c08554b7c6446e688e62eb6b2fd6b935e86e91fb99801c2b0c51f3d722ea9b25c5d2f17cefd92c40178cfd348809a923a14cb85ea47d9e11dfed8bc0ded49808f0528084ed27dc0f597029ce6f2eee6192fc103949803956bcfe4496db80a6f104d21d474fde43249f5fe126ff48d564b8007032ba0ef4450028f744945f5dc8421b76d824bf4b10e4397c88c7a9b8e623ad071b12377dab8345faf3278302e004308ac71b6e31f23b8b1ab0970be2f160b0330333aa5d6929caeb93e50d3673c99213eaff824ac0206587548c40b35b7880a526f511125456965264c90b673dd68618db9bcc04b2f9a998237b1bc27ad14092d60c5d8eaebc4d8780b4cded9eec1adabfad926e8d16808c600903a382ecd3aecc45894379e5498f54b0ba5deb12e403294133113046333f3860d8b6e35caedaa237b4cae07bfd1c353ceb2ff2140467c3f816356d4bf501ad95bd5d1a0255b609238c9164462e7302c70cfa4ac632a7b8a4ac6934dbb92949d1125de0200f5ae6cc14ad1eb3972a112efe2fd463dcb1140812939d3adfdad345e7c1dad3bdf692c36b0a9c19d56cb228c3fd2a5153effec4ecb746ed4f6e21ae4b34b1a7a462a4cc6c06afbe298d5d4bb1b586012d2df9b8c75a22f00daf2eeab9506acda1e4756b34301bc45c6db2ec950537aafbfceafe8a23671cc7b99f886e913e6a67ce440838eefde0a6009ba71346c3d889f97971c52674a5b1be11632854e0d3af05bd96eb35b81c7bcf9766e96da6ed663f7718b851920af235b56883bb191946ab97a6125946cbe88bc47d5fd65761eebece3adf87f73e3b0bc9ffe523856ff03fd3757f6d1fcbe67d3b631d15e48ff147361b26a4fb097db2963879620a5b7cecc14b472988ecf4f1c6b985c983943a20b36307e6151f8483d331218812bf9c91d66514c432bbf64c2b0e1d77e5b0a5602fdf9dbbd306b6b3121e75235a5be75d50747c617502a7c9c5da0012ccab76f8e2021bd3997e168c2af54226fb5911d88a83b0fb811323b5a2fb6af3b80b07e2fd845fa1b29fac2dcfdb4ff79796abfc57a346535db31343ab1fb5fa83d6fa4c9008616a7fe6a1e40ae4dd331c38f1229de25c6892e27eb772431029f38e33282452d963e48e3097b623223a74d7f78f985296074e0fe4b2b26f98677e46870dbb19fdaef943a6aacc310b45e637aa5b64779930cf97ac430602fad9a3210db3358aae54f5a86460fc955cc01fbaded46409baf2601220901db286f0c61e678c6f0563d9756bba096b9351982833f1d98d6c5f340ca69cfad0534d2ac3876c3e98f73146c51f9d114e1a212106315d2e11910b4620c2d0fed6e6bf50ac8303b30ff3132af16f36dc8fc7446f28efcc9eddada470d78b228464e5df6080fa04700fb503cc36c879872d16ea4b09efcba4ceb5876156815f665aef32d4b07e479ba558d4d9e9997907a0df7ee14fc49fed691fbed25aab44975f35efd8b9fe7892d8a3bc12a59bc328f20689c1b0ae7821802c6968b1ef6d0ef0767108fed00bca796405dc93cd14c2c10ec5c6c3b552d379daf2db16b655cf8aaf92aa39eabfd1b9dc2a95001d29b89ddd4fd0174afd1a579909cc37a171ede516978f242b08cc6e43e0550e739dce240ace63261d1feda64cd9fb4e43ae5126ec780873e48548850422eae4804bc303336b179495b61dbd40632358c66f7d526d5fdae145d2b62752a837c5094f71268a5ecd084b58a53cac862e761f31ed680b35d4b026cfa190aa53e7b190bef17afdca2d78368b548470dd0551c1c9e0b6a203cd105a635c2fd276dc01d8aa1d42cbdb1077ab034bcbdabf6026e4a14875c1eb86bbe4b48586e2abf3b917798a1eda1d697df3d6b09ec1addeb0cdd4060bd4db70608799b6a808bca497c593b402dcd3751e83378aebcf64ee37b99fbcc03acd1a2bf5ed2b964ff24e19fc15fafa72f7fa8969e6105df031c59a462dfcaee9a94acce9b042264bbf1c9dac229475f0cbe6675759e0850c076b8d5c1fe5971da5ea2a15dabd75f0549c651878893e840bca763bef4693d1327e1ffde0f371312a43dffb3baff1f5337cb61a698aaca2138d0793ef134fb854891efbd156a388162b4147cf768684387aa9758c0ae5ee5d22f876ae6136170aeffc652a3ac0faded5c8459bec7b950dbc7cba3fa994ccd8a72b73ffef4b3a075679d6112d11aa100c404575dcfead1c837f509a7a05172c1b519a74bd493ba190539cdbdfbf91615943756b783d51e5c539863a9486c0c065fb346c936e1eab9afe8ee34f84f23b758b871a3ca29ff47d937a12e4ce15404e192678f97cf8c51f97cf3f58bf310054e737a60d9bfd02e0e89b187f2d1a5c0c5bfe087f39ccbfaeb005807d181139fd41e23df35bd429369ff5446bc8cc43a99acfeb6410a6f2a6a7cfbf1fc70dea8fa0989f39877a3849581eb1654b84ad784f7b98197e0b5530a290a210fe2f8ad6b92b0df49359505eed8169471e3584d0bc433327b8fce1862acec899828ab91d9d38fe206b885c097d82e056029ec111698f96eb6b4e74226a933ca40e34ffc1c8b2cc58a8db603bac13a1fe2079ac745bee4c5cd849206e1e3a973a00418727c9d330a10c90b7bba2e72a052490e94bc347bbb02d9a775f4bbb02c8e208ca14b284bbebae70fd83edc03819cf02c6302e9d1b0565d491fc07aab52042187c14e081e59f044f5651a27020b51a70449034d0abbe08ee14e251114c3b8f2e968139a6ceb473d1bb2bc362ccc7259931102ff136ae7832a1a23ea412200048b310aa40c4a0c2d47f1ff87086f59ff44116ea1272c987dc78800b32469394a4b13b60adefa7fd0a89431b1cb620392da050b65aad206b2db024a397325c23aa01227aa76f8f5d3c2bdc189508522fab77f7bbb0854d04a192e5bc849f6af2e2d4a3a5b1fe92f545718b0de362858b7dbe4e1f1d35de307c19e40ba547fe4b30756f39668f4dfb39d19367307343fcc6caf76bcc9c137e3d87166fd7854b29dc867c56e9da97225a5b4441ea4ffb2ef22ce0e174995f0c3cb5998e23c79d19b192df792409001c8e7cb74c580351fbdbbbe89f41fbf21a11639e005c8edf2b342f6b5f892af8b3a3af221fabc4aecb5283d75b5d71bec185788aa0b3e6a619f0db4a82eb96892f1ed0f1bbc740cb3586737711abe8000e33942fa9e077ab9de66343e30fa1ee4655cd93d809487240544621b0643d93c3cfe0c5ccc85419bdc4c1f41a2def8019b92df0f78b86ee5b7ecbd7c269f6740545016dbabffe374d80b7ec8fec035f7f3251f4c08dccd21704fb6b60ea7d1bd77a4c409ab384fc90ed72a3e0ce5677ef9107069763ca09460bed5cd1c6ed436665c6ea68b95e98cc9f13fca47d649cdee1fe77966e7da41754364c4eab69d236061eedc8ef252dd498186d6324cfcda5ac6793e0fee96660141d23bcef3519cfff77d54c9a989ad5ab6b042f9e37071e0f599f64c599d8f3f42b1c7bbbd6ba6bbbc56242f997391a9a1ec196a3af2cc03e884940f8751cd880c6a13e2813f63148b9b8244c1030eb158f2ea84b73de231f2999f888063dcdb8b87058d0f77b00d37127231d243c7a5433ba6212641d4edc5340722a7f1321e21691f2a336ae94ab2adfd858ff05ad0b5d538cd91c715b4450af9e174df4f6c8314bb139b7485dd7db350430b1530cefe976b91f5b3a4933b88495596c0c9a5e3f8e90237f77ab7fcdad24bba4dae44d5fbd6b7daaa7612d59323f07d80b36dd6311b40f350f837dd09da69878dd269ccf18d7c699919476f42b7f76e0c5d094fc7ed906f3dac07d10c5f5ad4f435738114561f59ec68facb0ea91ff1abb5436503356b2e17f7fc2783a5d0de28b4a399be1934ce14aa7fed1e559f8d8daf9f908800b6f588d0c72afdc73ed623fbf6c11daae1af38fdbaaf3bdf36719862636fa1da1d01a2d650cecf2e4009eb359e20eac5d70de945348aa8e4b5e2659e5d23b304d2d558f3308a9d5c12b01ce2b2d71e72581c007ebca67f8c27b3ad4496b84fd859ed28ccca50a114655835c0f72bedf54c8d73afca6999e6041647bdf7f6f328c8426ff993623e838d9326d0158acb5d40b4a5147aed3967171f2ea99f2d579d863f3cb7d5dcf34c555416806cbe1b3512136d516f3648c89019c680de42f772b745b30b6444631168de3a842c538d60bf5207a443c46fcc2472bf7073b178c2d46d3a0b44d7e7b22ba1996836a3a91a9cfb75dc059e421162fb68e994aa2b7f4b3d0d2ce50fdcfd607c76ed7dbec660bd0ddc4f06d3f7c5e056fe15242b2c13f59b64b0a70e5d3cab703beb053cab698d1d4288132e2360864b760c5cb4b7a5d5eb2031b699243678a5e759c070a52e08e0f5f09385874f2f44a43417995618cf782e5c8391766fef1e3b14f61b69522ff7b30af221142b48e88c33a050b1ceb542c5b76a2cd0172ed7a86b61b309083597153984f723be8af776095b06834d368c481793be039d34924887a0e12fdbf71a8271239c7ccbf7de4a251a71bb7e7534a2a4ff361ad6472af845f13acc91d6827d49a2240871f68a6f8b1dae85c702a2a78d187fee1a2250ffd3783333bd7fda7a62177b1e32cfc7f99bdb2cb6cf3836a4ffb2f34f8adf36e2f9cc66abe75b4e4b983b4048a9c41371e3ef8af500ffe3fed31f00291cfbd54c9efea8e43af6293c8b0a9e943f874406de9383bf7450bef489cc6ad34af5b4bea1aef4f6e6808b247eeb9d605495c3daeae9fac4af2afc9ef40b50b65d2e7c001e71f550435e583ad4654c16f5c42e9f0b1ffa0836595464ebd4f2052a2f8bba0ba3552959e5f17d1d3396ebe586bfd2f1de501743c2bbb3c64d19345e57c5c5b947ff68ada37c910ec4728c2983f92e71a9f54f4baba6b12863de49dfa110419e1bb72f0d90251b19167473bf7776bde0fef754dee6527f39025c425bcad61b070f7a84afaf146bcda45d1b1d7122931f07c35fe4cd326cf6c69cfa7343481eb8b7f623b805b2fe9b6d2055c62702a3b91ae48df0ecce07ba35ace80534eb0f76d88978cb58c9d5fdcdb899b71a52dd8176dc6dd07dbe49247e9da3cdee03287cbc3b7038e496fd27b3a9e152c9fae891624139df456160f3518efee78c6cc024a07779fffc230f1359962ae2472c85f6785a58c17431ba7bf7812207d4c057691a09612d193959b26742a8c01b95dcb6d225bf47691ea73e1df179d454ecf4fb80fb3145bc2e44f6c02938ea65b7253631546113f50d4bb0c54237bb2829683bd3baf1e65c43c5cc749f35cea6a5634001231ce8e5c6d1144de4543ebc6d644c625cbb6f0ec23f57e7c0e0fc89434b0b0b36049ff55b93670bf49f432d4377fc213c544652820f617d205a6e8d42d79953bcaa8e1eabc4684c035c99e92e54689152be493b2374ef4954d1f2f44517ef2f65b29f88e01b0f8330d54855365af3cc9cccbadb8c62309c766088b046deeaba88b8802827cdb5530a36adff291cb1b0908523a071844a64a2ebc5a4ce687ab6b04819cf9b14ba626341ec37bfdce5ff36ffc922a7addc533e9905326f087407ff6a41effa018ead82bbf753007a874dc1106570554e0838b89f142b331daa23dfed81a9cffe4c9d11c8f651301d8f8c79681f2005d8c4d1a6c7aeb1c3c537f4e9946af594683b984ea794cc2001f2d12ca85425c595c464a5c51386a5db798e8f6903f0a543557cec68692d6b9d010d0274dd5d5e41843a7042ed39209105438adb3e413f92f1df1ba6cdc07a64a019e7ce76e6c8cabde77f46e829c988eeca320ddce1a568ebd22a497f81313339e3dfbe19b128b1d399f77f3e2f5effa7068fa1d7b18cd7b95d592c597fc34421a6803bd64b6a4f9a4409cf845f5b6da92551571dec6285ea324cb30744552b0f14603b0e46ac9a11f4e7762b622d8bd3199c975ffca53e5c4960bd5d5ffa6514126c51b00012c49fada4ca97415fb3c555a4034f81cba972120f7a456847522eae2a800b17c26935633d3b789b47a2f4120ff5d6959c4037fc51ad85827552e3408a1933ee963d69ca30c7dd2423dee698a95694ea91846c0da89277cd645c6381f5d18b14a93f958be16e578bcb8e90b68c0a701e65961e70e460255bf5cd041d154085ddbb11ab89ff6ead1e981ee0aa9052fd1a2bb3dc8549ad9c66fb68eaf2a049aea5f369796e5db437c64aa15e526bf56ea97f173e88b4127affbee2469773c231ecd06f2c2c053da6497b14fe198a8fae04350cb0c675f3309f46e06278c632b470197aaee05f0769ddc9d55edc01e7aa1c66416126dc851a8bd01c3ff15553211f346cbe646ee239557e84a202422611f83fc87dedb440f527a0d07bbee8e762970004f2d32c837c4ccfa8fe1ea4b830e7885a461f880470592bbae88841b2f2c68663134130aebac38a578e932660d5a290dbda442617065f0ce440c160f40c2a2eaf0474f90ef3b9b8272f2760c7cbb16dd2ca82a0cc92248ba5ec2e7f7eab90e38d1caab5170c47b1065dd295850b34c23437d918a3fa3acc1f4049b2812efcca4cdd0b1efc9caf595bd0b91e084fab56f0ff0d0323d074e0bda328d44752af5158aed6f9119f532d0612d14868a4bb6bdf3efd01f707222956895dcea8b416ce543a3161cdd6a51002c146ec27de60d4c4a55c4e7583f03cb8cdf5243f884dc1eb1dbc9cadfcca805bf1965d5c2292b42e981c65b73e87fdb32563ad9c21423dff912ce7cb5b106c4a8b77359cc84eafc48d6769208932370080bd0e41c017f57b3126c16f18339f3193db96b11cb4d7a9aa08f3ab36189c7000f49d2955638d465013da3c04b0631d2a76923bd48eb7e136f2f74dffa172efe1024cbf84cbe3a1b879d24b66542bf6743acced8167682cf33cd927e312fd08b46f714465875f052bf078e197f704fa4b3f1b360aa28963741830e3e7d14fb866061528ad6b5a6ffcf32eaa55426b28acf3ea26ec49d08eaf5c8e925e66a5670104461678adb6efc91e28433d6b0f8cad7d24c7617c8b752be58fe13c66e9eb2f5d6ebe367df3ecec7c90a9999c82e9287984810fc3f5c8227768ee349e6b9e6c9a0579aadcc5c70744063614da4aa6bbe3330addd3788faa082c485f6a4517e464f832a3b81ac2b88c49f6532f96e73c38b58250a16dfdf1b00e6c4e8096dc597fb102b0aad593d15a82aaa15d50a03ccb43770017faaab69d9bd7ce920ba4f71ec4035713e785b942ed8ad45c2777f644041955063af9265c84a626cdb438946f7c490cf92517c22f574f1c43885582e981e88d0565fa88fe847f9bcbc2c192484e8aec333b0429eb800d42bb4070cd57dc7cf8785ce2ffc7df0e275a90d36dad9f733b7c26bcee38cf1543f55d67cba8947159ccb2eb56060c62e730fa05bdb46b8ed93f9b9dc74188fc616fe8cb4fe178c98d71177e6b1a012056ceefd2f5662c5759ae74ed28c379f515ed3ce2873eadfa5dbdc3bd4f35135986b043ec47cde607e790bd45413ff3018a9bf99a227bb4117e0d942a337716531aa6da23162fa4beb4e177d9984e100f59f32fb0b5970527f8473c8640a2ba9e5b596a99b2fa75095e43b4377822a5bc03ff7198ffc3536bbaa8fcf2867e039c2f8a157221abc730bde826beb022751dc39eb7e7eb83b5c78ead678562f0e3242e7a8d50fc0f80e1d49f0d62acc9dd4a1e4655127b1715ecb5db683e9b484bde7fff731798d6b1851c947797fbcec3b2803a4d443fb4efe6fff6706e9040d4bab7aec3f40dbfc40bbf9cfec50b21bd2d651dc79bbe59cbdaf175d831081af241cd55c5c6c08eb624451910a0114812b37e6c4505854135277a10bc0385925bd6f85e6e9e142aeb94fb1eab9a75ab417a6063fdc797b2cdea638844ff9e31bcc0a4e776dbb1b632e1b1c364d356c8c99e69133bafb356964a65f3ab9761f07119d637f3b8425fbac183fb4319cc20fa951d9fcf3715fd77a73094a66844f79b1bb13c9b83a81b992661b913598875903edf92b1cb8fad2227c68f9c34718008524e6d39df5e6c3e578a8c1b9bfc614e587a3e382b18e3de2380b158a25be1a924b608599dd9be0b0971987c0d627bc3d7a180303aa4a87d5cb4525edaeed5b17a886855a821966b03cd6cb7027c83a2910897f524ee02e31f20688712d5250f5aa0cd3f0fde1d4bdb74ca5ff73a5a39de6387d29496c4e2b81d3487bc93657b4c648c3323769e9d85d51d7411eab937a249b94d64375929ec9d07ef663a5ca1e6ff46ee8acbad0d3b5ebd448f921ff4a2ca636a1c0ee74c94da0840e18e5069be0eb61146792b7c9e1f9cf8db481c7db9ab8ebb883d335c535474c57abbe7d5c56747171bc81315340e9f38ef6b8de440d45312cfb72cd68d786e5f99033501231428eefc0c40b7ce21dd770faa19e4c19c0e36cf7e479db6d786bea62b495e6182e8cd3d553bf78ed431161cca6b9b3ee0b5e12e36750e4b114f0025825b7bff226ffb6c0585168afaff42a09b4ca6231cbe9e1d8a432307786fdde3021de5fd1097cb1bd61f45e67809acdc89acf55f6116cd69e234a97e3db3f5e4f88bdbb8d48f98aed80853f36a9e7a0be6e515f9daea0c56c732f2626881e82aea7e6b232441fde6f76b9dcc83a65560c30ff7aec207c7d2b4db6bd9f692e6e627436f1f365d28e7ba3e1853c1b6550bcd1df8652f1c956d0b700e1f8029310e4eef04e606603c676e39cb796a84ee8ec8a5ebbc47fd15e6c9182bed18515841fe795e4ce9806417d537b815260dc8321c71b015d37dca49c668be59e9ae41f6e9f0736397e968b9c40fb5ec21ca67a276f4ea7c5ec128f46ad40110fec624bbb67f18986e1151e8d83deeb705a11120b16ba6378cbf2f6a4fffdbe6a9a2e7915aa59e4c705cdd69966f3dd68a02f411b7987105c81ea0911c9c0f981ec2d6a2a5de82d443ed8166b49c3bc69712e57977c3cd5351ef309d66ec1fb906d37b73ffa2bb134ca1f8ebfd6f9a66212ac9847bb82745476e8bac9bc806f7fa425e7eea541def07cac2540cb11c4531611f9a1abf14c7ba248a8afdde7deaef3b7e864a589ad71f192d19d66e92af8be0181e5ebea9d9ab4c9f277040422876f733e322c5bd0515a5e243a1de208474427fc38bb5af9e31a10fdd1e0f31fb486570e1016aa5e1536b45881d54809d4412a6302b9b90317f786960fd14cd3c561e4c6c116c82d9feae954b9772f72a8bda564de139320e78d9c010afc49f6bc422d1029ed91c4a9a8a67cbd969eafa5d669d581a7078591862c4239d677711b9304d008e4ded4550489577d0f9ddd6183e213a0d18f6c702fb78a22caf6555a259ddab4c9e1e89ff12270039080fdda2afa6b683f32b0e7d8f927714c7004162e8c036926e030f60fdc5d32f44e2b05211d85c1b7f5e5888ec7c03fb839e6d7065ea705a5330d7d31819fa6cf291845aa8deada154432e3404500b10e55268612251c68a526fb1967536dbb003a865e6ba9645fb722d50b765ab0195124feb646b50571875b11e71c092721039906eaf19d9e3e51d88ee76ac57a775a426bf90ef063599565e12f39003033c40534673231de5a9caf7b32863f20fe3ad8e48c2399274dd244665f55056ac563a6b30f5756b9acaf92dddd4218fb6e628cfccbd93cdd87a72a483d2d131c63d2bc551412c6b1e3eb2ddf952c137faf4ad1bef23fe783b1d431a0a7d851e8b23e52abf8db19439a83a465c6215d343249f237ff52f0fe1c94aeea6c3a2e6bd8c7c02eb838418f3eb5303da04620537a67c90a566a7c4feb4b5a3819a105e56736425a44467aa4aa05535dfd525731e5f15c49308045823625f827c29883319121c871e50c13800e76bf20dd702161bea742c1266708e946e178c87271eab5a3f9c25da2cfdd0ac13b46b69a6a353e38b360afc8485b731ed5845293081eff9b4fd9d74ac44e5b06886826a64f41b839fdfbbbfad29a39e203c60da3513154727796480d2761834c0668b478e9b60e46a1b3c5972bd4d289d1a3e0bfa670e562cb76528bae5a01bdb1c16b3a3a7dcec4683d1955be7bedf6e80da15f9630ea5cc0c6b950b569b2838c03d6fd2f37c473e6733796188d725aa72354e47984607606c6b85814c94f2b1c3a5e57f9d5960c4ba7046c18f38e9ae8426af4f04a9c33d651e8ce316599b81bbd7d1d7b0955a8aae2b854b05cf08ed307dc7f208b235c38dc0336fb86f3dc5f44e399a7309e3b88f0e252b7ff1da2518e550173c44e7b06c3f3109a5eed17e8d4627a85b62f381889575a4ac0d781e00aace3d109bb3ae0c95f6f262ecdcce4a90c07ed03e4bc37317829a5682acca706626357c34e4e8848e84da672879ecbf61738c09717c7d176b851a1eb3d352a87569ca3032fdae0c2fc4741ca08bb03f6a3315cf2a0d7471425991dbe55b1fc8c4515440e4ce97bcdf9e59a43095a8f478bdeb234abbe63c4f5050be74a5ccba77d1683b6ec9864f957c8f0e6e12422b38809d5305f2ea2730b6c8258b6a7c921388dedda9021c3b44aed4a3aa0f50b600ecd3bc902182fea1217af5b60b90214e71f9840748d24b688ef549fb71242c13ddb4b30d495c7493ba07f9f2a9f80518f12a395e032e1e5c627e678bed49e6442bd0a60502269cdb34ccc6bbe801c524ea762cd7cd3495c9898758840e056b6896511d4ac981213666735621920393fbf7377471adb84ab385f7b177de8411f81b6ee0dea484a568ebf98fd9c5394497bb4a822d39e62b53848de83f979dff1963e17f0dea2e1c43d32d0e82c0fc9bb72902a10e58b921f0088c6d774600ff99ad24b8323ed25d9200b69792c35e7a586c4a442911f2f28b6d2c0c3d9f9467ee56231e6dc586760ad512a4990e6fc24774c308f11f58234994aa2838098b6525e94a4fb2be8e6cea0e4e812d94f2649c40939b5197c0c0aa1d1b18e483b75744c46e7e031f65fe1b28afedb2296d673cd208b4e5ff1fc40b24a97dba4118b170faeb02a6c15d049e357f37d827916bd8a1b8dc5cdb3bcc4770714516bb08c8d9894f9d6896d4a8038feeef945f5a31758d5748dc183b0e685930be6b47fbd66586f57bf125f8bd9e157beaccebb52a1d2f5e3bf05e29b1a82a9e476f251c2ddc2793926126ae5acdd6ce14662b643fde3ebffce0c7a820ec100e7ebd98535648d9db7780a705152b1a0fa7682920e881926d0333ce0905daa10de6dad7f1d71986c382b1f04f38adde52b008aebe6d9cdd5341dadd44b2fd6a4552917a916b7356dded732ba7f89ef492c2b0d73e75ba024e3e0de85f169dc948521629645639d6b1aff00d0c0b3b3633b40fe10bc599a5974e72adddc48397066042a4d03fff99b282fb1b9cc3af95f51642fca5f231639d515962fb226f4e8fa4ce516405f0916060565e292e094cf734f09d273372105d820655ba675eb43620c1b6308e7a20b7d60644e71bf64ccb716f3fa772b64c82e564b8ae67504ced9e88f04c78a066ce4107cd02e2593fc999c97a2e1d5a2731a53084d419e2eb7a29fe5f41bfc121c7f9f179d28b2007a472a62af9b149fef9314b83f0030e77d8df74c9dbb7412444e8d99431d9afec8e39948dca0124294845174724a308eab32f4be28f76974e527e0e31e3dfb766c3234c91a6f6b3de7b191e07da2c3bce6d722a7d1f8779a4ce632146ac9be908c0ed235a2f1ed2ba2f2197f19fe0071872c3f6605fd3613356300113763b1a66d1f5ae5a2cdf07c4963af5aaeecdeed63e28868fa8f39b24099dd79e83436ca973fd822aec3886d93f153ccbb8a8a3e485cbf2b4eef016b24a5f53c2dcde2a790c202435eff1966efd0aa0a38b4f4e9acce91e51f6e9e2cb14e40b0a589961adb88fed9c5fde676436950cb3c5145f7a1291f93c29da43d9ff2ea272bacd8274341db6b1214756d6816a4ae81c7bf8c005c477d671978f5621ec7f93985d911db9f1461d2130340de640ae5340cd86d8fef99e70346513fd2a4a15561e411504b8c50cae68ec1bec074d719c4a2bc3443151021aae61c37d180a577cde7eacab843f0cb95061e4417a0fcb2f3555def587b8a3937a827a049da6e61060d7a991824c095c42f9c01d4b36f09bc9e0d00e92c834484e45b790cfd219effa4c2369581d6cbe7dffa2f8082e0433c8408e42ac52902be7fb892f0762052956e87bab309487489c9a368910162ef0f6ebc2c4b27fa6cfc55b9c451b277065b5e615bd615026c75f12de7944c9ec26dd1618e6f523aa5dcdd12a02ccc0b3c5ee5b7ea60f9f381967a4e7db132b1c5ae78f2cc35fb38e25df03a196cb7d5ea5defa6e4719dde599f8573fe957f634bf052de6ac3ab28a4633a3a3ccbd54d12496784f420fe3215f9eec2a6d7ac5571c65ef8a49e47e3be6df735bd9032858b036b77ca19b6097dbfb676d4cb64a0f767fc386f643c96b5a68a108fc2c918b805450a9f6bff69bf54f0bab8a4c4ab156fbb2703724277fe642ffb0aece6e917e4edd413de9dd854e549bd57bda42531cfa0cd51fdb2a2b14cd682ec34fa257adcd4e3fe239bdfeea8679280b3f4ad97f4bf4cce45c2bf4d6d7e5b5dd983cb72e2245abb8f4b62e2a5ae77457767410e409cf6d773c47543f4a7c6daa0ce75781ee89c562bb068e3ae2edb089e7ad250bffc27d74ddd17cf7ecab63bfceeba76865b105bca64f05b1caf6a5b12a63e025c61fd1b618e71deb94fa75aa6312aaae2e325359bc7be43b0400bb4f92c0292c665e607b334918c90dda7b15b28b3dbee39640d0541aa7bdd37c779b78ab7f49f73f0ad5e5f64582154cce2dac840db44727297ccf215ea9e9e0653801871eb26bd76aed2fa1fb67d7503c8ef5a578a15b9ef492c38de5807056d1b0756e3dce5d6c33329fb36f8667d4a5585c586d5ab176ff86274c1e97023d04b8528d4f2cc6013828195ea6bd61be44f707ab6c3d872e5f477c42969aedaa49f55f6f605e5a2065e9ea82f30c4aedd5a7c26d57d8260b875510afc5f08858c4664102331194bed0b7d3c8eb7145233b6b0d527b1f0cde9c3d1ffb3e5b4e2b0cd618b1196ed29bba7a42673710d790d1650bb82a3033cf04a1ddffda590ad42fa06cfc9834126fa22537afacea336411be2e9b4c1ffc0c8280e892b8aa1bd2df341a4399f808393887f1fb325b37f04441ed0c401f021510972405ebfe08abcc85287e66bba3bbc30ea92aed1429decce7653f187c71ae05edcfb18f1be8251198116dc8aabb851b2915faf17d554bffff0d4a7399c4bce9871968da3aa49bd23bc6e6901ae37ac240ff0a3cca852e9fe3aa9bb201abd13d8a86abf702bf035ab5ad98fe6c6b721a4aaf423acc305842baa989852704f046993e1cd3cf64219565b760d8a4d1d4c534e1b912591e11eb40465247f25d71752a5dfe7019fab02dc21469b626db3c2f54fec4a24dc40501911336e24ce9980e1f6fa1537404077a166c1925b78d8234d4636abbc645b5eeec5f99f3234f09aadaedac0405a76ff61bac96aa921fdc39dbbb49002f36645887499e7aac08af36c693f7a89e3e12a6c3e424228a16e6e2b67f9e9bf03a58a11a82f7f01a3feb12ee2bf024a0aeefe0f8aaec3357235e2499edd6366798d3e175a4859a85d04e5bf0a02cdcd15eb9be382c991593a054cb227ad349c9174d26d36cecb5ba554805e1ae99260070b799ef87c7c162492abacea899e634b3a4bb0208817b73e583c5538d9c6d0b858a7571a970f022ebf8bc3d8d3068847b7b986ee18c8afa8f631759da23be5cadd9d217374b2fc41836b330abcbc338df0a03e6fa5f970db1f000aa93b44c9980da4664f846444b5fe6a9040c29cf7677cc01b904237faf55e4f1532ed65770d11329818a74ddd5ff771fc7d4c4dde964fa9f784e9cd1cdbba5cc33d4bed59f683a46a81ff66ed0c103b7343cb24f9c0f6b6aaf05e97684d58a884d45b1729ebbc04a8f69600cf6f51f9e690e8c61e073a571f98bf5098f599845f95be29215b631e6534a8a1d6c31411198919c7443669f372806c15cc11f2ed2fcc1306af3f29d6e8c4c86eaa1ed3e9c167c6e7f6aa5995246713bb37a311ed15d5b499f356e6f2d0f77a5fa1f46e5bf43fc5847fa7f16f2eb3e6dad898ddbbe0e7f7b3ca48af453dab7cc5ad0040561f3c57bbb6da132c6745dedf6750178ef001827ecb62516f543903683e5603a4711f3e90c3f91a26fe0e8add11e792e7981e5898b7ba3d59a8f6b880892e3478a1002c0a7f4fce8deeae8dbd61fcc31e3acbdb39a594d563c63edf43dafdff99a82bfb192f993f6e24e57a3285c39fb98958a8d3585103f9d743f41c00f87b245a84f28ea0862909ff4203570e15116d3884a53450186f615ab1c0d9d255fbcbb1c261174f4b46364a08266a0bca8b0314f0fb3cac7e322b3e4610879d7610996e37b3fad471cb16a3c2de53ba42db16931ad719de7f0bb877958c654272946831c4593bd10e3d35efe17cc2ee82cb9949de004cdef21bcdcc84e3704a0f1113bd46f4f50ef0d6da1e7e233d835882935b80ccd6a7bb7fca66ebbb4fbfe110e3e48f35624433a713156b0223cf94dc41d69fde6934e531524fd457356797def38e614964911c8d2767eafd2e256f85c6aedfcd077ed0c1a8fe2132b52aebc5488bf59685d8aa90a13a14989d6dd1b0732b53b6a5b7f845dd8b711e00b325726ba84aa036348905993b5760317ee98a7aec91c2d4a85707158fd9e7fd1065452bcbda8c2faa31907fcacb8e75641fae19372d8572210386aeb0a2855aa5f70b66620c7579c8a4da6abe3cd3d926caf146a0f44f5352b148e69ea8b56277a8b6b5045091253c4e64f0666c38e75615c5f8dc32b351f9f0094fc897987a97816a6d2882675467a510c8b20a4a689a9094c5f29cb36288b9be7c2c130a26342339011c53566f4c0c0dc3771f5b0757620cb528fe8f1d1bd4a2db065cd62b61a9ff94004d6f1e94b7374d2f34cb1860c06741318d4c31b55553441d93c78c2f15c59b33b6c1772e04ee7f0749234b51687b7f239a0950b9fe91d5895e10838c234ca05068281e2a9ee6bfdb33c2fb58b73543d9443f9f25a7d32e5343b6783aa98fb998b7c600201275de0a2b14f93b29c220c1ce33019a6dad07c6955436a4314805d77084ef5382704f4f1bfc49ae6805f1668140154d2addee39bace26002b862edc084b634729404b099cdc8c1a467cb2173808fc7cba30e8ad04f1cdf23e7870c8592aee379b345b40bb3bd0af027a6047b79959a3d06b3f5feeaed51722edec1c9ccbe8952766fda5f0c20ef796a583185a5ad5d029cae7ed15db596776fc9cfd41f444ff72a9b8bb1d6b13","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
