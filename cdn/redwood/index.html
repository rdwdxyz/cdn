<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2b699cd30a3c7fe95b617667f6b7c3378d6e84c186432207f5a5354674b331e8a99956487282e633a6b8302fc1ddea3dec4818aaf08e776dd2786d1797f1bbef9abefaf39dd0e1017f5d6b1453ca1640e014329691cfa55ba7b596bb8c9bb11459af986a10a75886ba59ca4ed2d3f4efb8d34fce1445c381cf0dabd06582ccd92cfa8cf6b908a5b47bb1a9c46c97df8e3770378d6dc2c61b8585cda5295b9125a111542bfba0187253b10b954956387bfcdddd36e814df0b580e01f8a79f38a9eb0f9d124d068a595138544869623f2ad34c7375255684956b536e9c04a1b6c8d1814c4c26613f970073b115539562c3ade5879c339b111af7a4ce66c73f3b8e39ec1fff7cbb0fb04f02e644f34cf6d6603411e4b9b067f871da528775de3404cf120493c035937a518cae55269791bf798d9e763fc46707cfd40189b681df346eaac0adbfddfafb827d82fc2b2a550cfdb329fa7986f0fe338ed625b814c23c412c5c97d16b39e3b92c24678798e4b34c311839a3f8a3e63439bc60beaa8bb0d73aa875bee9222a483a3f94b06908c1dee60080ccb7d780716452f2e969e366497a19f3ea296f4f554a9ffeb29ab145231b774aed951c303e9e829daed692547101bd20e5147c3ded739ac4c1dc4b9b1ba3ed0f31270ef42a1ac10c53ea91bd602906c4e50f2dc8a60917e0e7da50fdd5a1f36dbb7f2c9dfc81a45170d5dc06a8c51855fc8f58dd0fac3859edb0d2f53bf6119759ad5d60f679321091cceff5362f5070dbb4b5c9aa9512d0988f771a16db61cca916badedc73433bdfd61b5a95fb28baf196a8a8b28953ff428edd3717eea2705b32ef34dc1cda87bfdc265f3bc47fcd9eafcb69bf60d4a6f9cc776ffdccc84b1e1ea19e233c5227c15b0b5b514a62d7a7daea87f59ffcf27a78f1b30cd8371c53712cfc4bb0393d4aaf933eb18685ebef4b62ee40726f21fa6b542651022b627622cf039aa2faed4c598ebf4410c72f02e7eaca44167fef5e01af089ddcbe039d05ee3e4d8ed186abf330eb49add0d0269be8f7cc9b320f17220fa9a5e4ce97f2b595bbf2ce0710680a9b3d2e3045f33bf7054b6df03d55eadc926e05e12b3bed85f2837cfd922b3aa8122ff70a97e74fddb402760de19dd621e2a9ddac3d46b1f67b4c7fb7725e818efabb9be1888d88fa328d598a99d263b86e956bf09b949b7a2f00351d8e2907bf8021817cf19212b1e92d38e99c758c08297782f49797312d6a9ffd46718dd7f72685cc2ebaa3b2c21b3f9ac9bbcfe840c4909963a1747c465c2ee8f6f4f1b49b8c80a4a83095c1c6adbd139a5faaef73d1fb9076249d0b8955d033895730dd3eaeed5e23a476a6f1fd546952a6bbfc2e79e01c027aad91872e48f452cf39c3b0d9943a35242c8d44beb1eb2ce582f49f99bb3d1fbccda7ccef808552275219227f98227a22c3acaf210e46be996cac8dd7ff9ae9d9e989250e2cd549c8a73c4dbd1e6673fdfb2768994c0ba4e28918ae54577d55f16b53e549feb30db6bddea2a8a72f59f1c81e4708bcd5fafd19586c0794bebc3978ae18aa66633f8be50b06b8990a2a0d2df5a79d1597409262e990e6021336c08c529f2a6d794086980246e64e9a58ff5c28926264bcb788d1aa25aa37eb9daa805796b0d46289f6654837724b75e6195b9c5a92d10db60f8f9214e735ea31f9a071e125e8df72fdad90f62e2fdea65d21e86f20ac4c0bcf55ec7594db3a3e3afc268202c57207f4b8f78943206fbba4d52ab6930295f6ea754c31aca0323dbbbeb7b1542cc537b4d210a374c96c2847f720eabd08dc9c777461b88e990709667ce402688e0d140615a5ab81a034647e2dabaa48a9798580e9f262162c4be96ac5fe8f8bdcf539a6aad331dc5d3123dd47c98f81c98486ee4d7d6ade59dd253e5a4245fb69b6d235be24a6d0178f27a4d377520e2c2015f148c2595fad07c899ca476fe02f37daa65b18bd22261268595392a97e5b992cb2d3723b2f70ddd339247625c47b87c8bf184b0586025f083483594f6bd99943e1c05d28452a177df44a7c5ea75215021b41869a542703503ab29ca59e542578ac722086599a89e49b17f3c1cfe8d546eb0ea5ba57e197e4cac7f26d91b2f8f6bc4bef51c034d6e93dca638ce53f1fa117378e46fb72ce1986f63393b8d6d83a335d8842c82687b283949c30b8e9d0159e0d2ab84a135f5c0f0074ef379be8f35620be87335e6ec5d8a5cc106a1abd8a8b649e939bf716388d6c0727f86d49e917df065dc3c873c83ebfa269514f728fc56b02bdc8785d249bacf9fd506ccc929b21e269e0e4f076241beabb3b32a0ded9044ac657dee73331aee647f6b36ab3da74da2692fdf4ef3a2c38733e31bb87dd3f808977d862ee210e24cb3e006866b2a1df21779e29349c1b5ed7eb1abfa1ea26ba14e85f8decc5f5b375e016a0256e89a835db06c0b4798661995057a9ce3d0586a14b3abb20646d0bba8f6699a8cf9f2e2dffdbb06a2384fea8f5f00895471dfb91605fc885427431cba4f81e3bbdd84366485083bb4cd351b5bed2e25bcdba1fc42caeb7ceaadea13367bad71758d3213ce8f414871b8b19da613ff5919a61bd7d8a43bd630c69e5e832a67dae2b7ffb9ccda8ae7b0c19d54bfa6e86b79c08fcfc7fd0880285d01b24aa22e054940a0519566748bb2a4231f252abf34517d922ba400c3b4d754554fa283fef5e61302468e935dc78c70d24c72bb3e44fad6b06dca8e8302e4514fbcd2b21e56bda2c20deed04c10b61c38bbcd505e4d63e6d6ee54ef8733937ec44363fcd2bf347982104b334a33f6e8834e9cf7684bfc2869f399a56e8c2be7e9e81b64a1add3b6fd33075ea22324b3c2877b2acb960965ed5c9cda8270795e911ee3b8fdb61ae6583439cff9c615cd9064820df0888591eb729973636745eebdf96721eccec3c890952b1d05f73b9530937dfd9947daad18994cd7d147dc330fd22989936e695b549ffd724fd068f2dda22474823a74c5dd6d0834248ba8a65fd64a4b30800376a26edf04433b4a2a6eaa8f0d5e2077909d60a864e3646d3744c9666c16be7ace25f54d5a4b5e9ce133b0a061355a7793a4ed60a0f2b1f4b468dec67796218613169da4e57564b3fd3069f81a81c3c470d38007dec1fb86199d4ebed5ce4e5e91eb1011aac7fd94cd39615a4cf5a1fe6e35914775daea36a1fab2acfd870037ff503df6046f8a945da1c061da91d7ed180eae0e1e5d184ac9fdaf23b5216b6a86ecc730fcaa296849b68c64915001c047c02ca1cd5c84cc20c901610dd7ac95ca1d6031bc46863d03a9b6b6f468b31e2570a99ab68962875936e0b82e7f15730a1e476e3ef0f5939d4e5964765feb88bc92535b7eb3d49da4b98d4af8b6fda41174ecc3428b839571f76b440d1eeb1ff9446b004c0a24a1b9491ad6f66f64db8071820db89b0481dbd899d99d02496b5367f96979a90d58199c8b90405deffe06c64e005da2cbd89dcaf467ddb43f79e83d475850d280521932a57e95f4f6ee22e3b9e7716b7abb26f6e72eb7f513f12c85f6dc49d2c995ca3176d9b6013185b3b40dbf8bf4552fd1cd4b6ecdb05958433b60c58d34b8340be636397d7b9aed1f85a1e887d118e681145aef510c4faaa2806d6941c1d3d4bebc7e50393d0b35b0ec72ff990c1a5e8b3e96a75a084d1177e3437a84977d67bf5463f6b87f9b82d3557d5273ed53be242435b936b0c08bd9a1ddb8d632d18343b3d9c03032d4c5e7f1d4b42e304c8aa14552e8cbcc709b9f281cdaa191021b1cf2d70d5c4844630b8c50605c4283b8763a4580e426d22be3ae6c4319a2de4346185bbef9f66b98cc3b7aa30097f7629ebfdae814992007172ecdc42369c0bc597f9ffe87d6799fc4f17626d10707ba0acf0ce54b18529ae749eb4fce1975b3ca92259a8a6359a7c922c3b276eee7f585a253900c8d717bfe3df3a6864cc8d0261c5dce4c051d9c3921a0733974d854f109b272e3647f551089d06a16b3feb48c1a6d640ad184d02f5172c52432b5b2863048f9010c540fdfb3b0e33987f443d1f7f9ed80a730383425a5e77f0d2d6f48221f0e896f173a253ccffe03ce49c4735edb4162a2fe90a6217bcc36ce92c0b76f51a7313c74eedc8c13c0f132abbac48d5e09f1d2dc087d015b95aa26cbad2460d040de4957622452ad8166548c8eb42b3048922e2e22a5ee468f696903c53b93fb78e9f2c2dd03daa290952aeea8bba700f8205f50f16cddca1d465fe82e3d5d5f6028928ddf42c4e37bc1050c54a6cbc5ceeb66f88a2d2b3c63c2503719e850708703c22d0e9669e44a0c63d73354a34e834f3f608b6989c80d884691be3264c118b059fa06898a28e7735b59894dfee4269252c997fd5ad369cba1c01e4cb0629bce2f3ea7403e66c5dcc6516f8c2b5f180122ac6d27c81f375a6a4133872dec63eca51dd54cf5674f6114ee2f40ecaeb9f7492751f9fea509839754fdc149a68ad717ee1786f4ddb496031937cd1cbbfb2022966c2783a3d823192b628471848d8702231efbbc804456b6775aa4f7fdedc1a808e44a39d2baec4e888484917dd44ad779acb7b290763f279e6ab7d2b260acd336d32469586a672936b30d0d51f789a7c4bf9716d2f2d1eb6db2cf0b4df19d0c5253473a02ad64381fcc67926af331a939d8904cd02ef2a4ff3230517ca247fb14349bc8bf216eb73db6a3babfb73d87637fec31f84429f68d4f65d5a93f7b099298177c7e4e967b8cc7282718e14aa289b321dd7efb60c0ec33f18ff560732480da2e98c15298c28f99dcd7a38ddcf959e648e76a6e03f85ba9c1400cc208b5c9a4bba73807bf90a7d37df6c3f1a8fdca921fb66584ee9bf6d80287a8b221b190fc9145ea92ee357af0264e1c2721674424d9db55fd17f159dccb530ed04efb03520db3a24c9634321843ebcbc1616b17fa0286c7b34484788507849b6b4aea850cbdfb02be8585c0a29cc9483a10ac621e6d08d49a6c9be523962f0df505be78f7ceed514bc6934f1b8e633f00dd47b955a7d5d26b2a7eba3e0fbeaf6408d145c7a33a69329a70d13641b5392e3643d9a5d9c99137d0f3aee3b56d4b03df6c0d97ab92aba9f9da1fc77747e8c9d15e59b717f976b7e5c99524e41cb5e1e19383f25391c760235ab30cba3ea415627c60cbca8c522af575c6c6113aaa341b30b438d1257b41823289101bff9bb7846b0d19a704258efc042a0716d2718803a0706f880240ed81371fc398b74be3fe6166fe04edd61ec86c9833d85f9404f9a31775f8bb770dabb97b4ada00412838ffd5e508333e3d1781ee0da1affc5948c9ba04de911c05f56ef1a62bd8ffd826a1a2116d4b025433792629441fda0c57deb795f36de6b172aad2caa121329d43ebaa3d5905ae28cb457ea1cace743299ddef5d1e5b49fa002b6cc1a60e97d066bbc0d39f4cca86a523dcd08b5d64edeb5d76e852a5cdb8c170fedf1f9651ba10f490363319f704125b75bd9d8a1e01e8da81fc3018cfa85978b6616254074225300a98de7b7cc3d524abd63cf4a44aae7930d40bf7e94ae4e1281b4264bd2ccd6ad0ebbfe9c1607d14e7a90db57890028e3b2d6c1df3c6daa7f7a48bf303dfd7b23097043b8aa55e5383e743d4b6b08eea6a2fb233406b61af5117e550c0aecda5410fbf171972d06bca4c2b62835b362ed1e08cce6f170c85e8ffb3f45a7620035a82ca6a457bf80329ef0faf4b71507ad46c95477091284bb4a62fe4114e309be0bb89ea4d567382d37482daa10348790705d5d36eeadf951e0798941c498e260fb1f0c5076ea3dbf1479999883f36ec968a4f4fd322f79c8d9e6b0933378ccd0adda200cb5368bd3bacdf17248e1a5c62ef48f6cf85ba2991a9d51c3de1167518f0ecd3a1733e67cfdb961231860fb6b3fd602bbe6bda854aa225a928d445a76ef19262b828a692d1b222d95d63fe4a37db36c11e3aacc19d346d061768de34885a0fc8612bc1126448544a8def19eac9c713cf4abbf7d2f37b13f5f13bc79a3a431f9278188561b9636df0e002081ce18063adf208c22f795ff691b9f5c9242109548d87f096861376fb896dce96632405a3e7e5ca297c36c31797cf2fce80fa9a4cd534aefd3f1a970e396cb4381e5095d6740df8ca98c7eb923e22508699e21a307236c614cb23d19c5c250085ba4c374bdd1e65b921fa33a364ffe671e8bc8ad89c654fc5092919ea299dbcf8e17332a592874cd9e77009988aa74dfdefec6602e89401abe5d2502282ee775b4a2b011182ef9a9f2f8f23bc9ab54619fd291a1b8ebabbd4734880514422bb11974a54f1e2fe592ac4fcbbd302d974059ca5557904f54dd1e9ae8d81b86a06ed1e3787a5f93dfff04b03a6200db2fc332579bf222b93f7fa12c583aa8a3b7bf954922684e0903f43cdf34093c768b76023ebc9016d3455387332e104098439b67f1a8aa87648d1ea9e8273e174ce7e704bd40e10db312ee954e7a95ce5a4cb7ea62a4798c64804e99af4692b117e046f4b8e53eff7215d7448b5021934b27021f7563164ffbcaed2f14dcc9cf8e0fa3626718b2ae05d0ffc79d4fa9f92e2bcb59d9c5fe0ef32b0c03afda833125832c961044b722084b06d07b20ee9221a699c9e4d2df8b4514b9a59c3a45b97e166bf4bee1e330c97d2d7bfc1c9974f1eed545ee7dcb5a1b33b32e01560318304e6a1c71aa388a5a04c8fa1a877518aa4ef3e29024b4ed68bf52d8cfc89c51ec14e2d31cdff8de9de016e817779af06b3829c671f5eebf0cfad5b458fe6c59497611fa07b96c6d502ffedbde32c69b5b7edff4f6edfcd4a67485fad49132a613bdf2ab7ed4cadf40197d90a6d875b65a979a566b9a8011eedb61201571f1778c6bb0443c3c36c0b5486cfc94ee227fe5657e128b44fc17e8be449534a877b522cf57b80859b96e27686445a1725ab0517dcfe5dd1107f050adae313a34042e53494d711a30e75fe8036f96aacf09d5271e3c3606455b29719a80a3234003471c832809e1442aa52679e8234959ac5c6efe68e00fdc22146c208c5f592ec4aabc10cd35551218b6360e1b64dedf4d474bc5b7ca11c8f26bcf998f4071f238020d756d925ce4c87b5a5178cbf0d47e565c757d0f65d7c5a6e44a62229b86b31ccf27ef7309b7261f1274c4dab97c2fe295c255bdfd6475c1a0f5368f55d2bf82ccef71a38c5d5a2dc380d913df999d6bdbf0ecc1eba1bc1670d271290300c5f735633c7b2e5abc13415b5d895568cdd953c3f6a46b2211ba0526c47da687708015068bfc564d13e1939b91ecc081f90d48940f8a6ed7d5bdebdbdc8d384977f2d0aa5c54561577912e6b6691649b5c34c84634b52ee4a7fac81d15cb241c2ea4dbba919f93c84348606ce48293ab77ca2910d1c9a80478d692988a45523ba467c8ade874869251f1c25dcce78a8a925c2690e31f07af33017ab9d0aaafa6515e251f122afcbfe0d20b05ccdb2156d088e023e34be2b4715c7e0a09f15f1ddf7fe97116bdfe16fdcfa2ab77ced88fc2700d87a32a5bed13adadabcca728f541d31255819b244f6ee5184b2207238532c6706a9d7683509e4f55845a49f0b9f2ec81cf23e34db67725f2464c43889127940cb5d064e5dc71720d754f4a182633fbc2ad7cac8782d52070b3c799343d8e431257a82e1e0ff919b6e384aa5a5240b8cef712f64dc0792f550390878caa42c4753cdf965b333df600829e94c22ae9ee3eda8add2372f47675cbaef78bb677d6a9caa83594e218611d43512d9dcd08e3ffc27738cae4974888be7881640efea9c8033cb4ad69c509bd7f9c43b90dda270c82dd06044d6aa56d40a091348f52c61ce9221bce25f040f2eca83d7d3ccf55fc0b423b1ca67759c0423cff336c198638bbede90bdf0694429ce5d36566fd4b7246a68d315a935c33e07a88ba006b920c24d2e1699ccd30ac1f60f0de3908b06a9d7352c36e5dea31bb02f3979c0125553e836cbfb9a6d8d60c673a15fef7a0593440b162fb7407bfdc8f70e9eeaacd4b8cc97d4de14a8b4acb8afb3b8bd15fb36778fb9d1129f9ef312cd0047335ae3a6b275236826cd50ea9b0f6d7501ee6fc66a5fe3bb2e3cbcc79ffcb59c99d797b182ac8ee81fa88a40b3f599767055cf4997377e1b312fcdc1044a2f67027f6548bb6687459a5557ae4f0919ef6dc157e83de35dedd87bf2f5524f91f1e6810974eca4f60c8d775ccbdfdec852c3e23b442f431d73691ab5107a752fda79ebdd49e702ff604f786556c50efe72c1eba7fdadfb7eec464554e0260138355aa95a57ea09e0f35a4e6d2f5bd86b83ba9449d02b38ab2ed828012ea352daaf47115c8c7b6362a362a2d2e6e980dcabd8c24053da8c327265e8b9ec03bebb9c8b184f7f13cc7056acba5d3ae2871669fa66dfcbf338fed16f8898955d456304ba4bbd071d92a9c9e97a66764143fe0d216fcc9f39e4cb751f060f2e84b55fde22e85fbd20616f354cffefa2f210354ee0f6476cb409a9d2c9748c90e9d3e1bb2cb7f988dfdd135e744c15ededfb51cfc7988c01b8f8dbbb8a13f62243c95ad23fcaa204ff00aefb5fc12186cc308e129c73ceb714d2e9fc1734872b58467ebadb893a25f130be24d71706febad79fbb7861ba333c4782e7f97f2955c8cab9b8e5a952632e98cf46281e19dad425a42efe33433e0929353d4f3133c7f9dc084be1a8242042bc2210cc56c8e4f5bfffa5795ebad27de8db70d948efa45797d65f824004fb925663cf2e7b87a7ddcccb5543c7180a6dcd4a67960008e3a1295ed8eb6340fc10fd5148250161a9b9219c73957af223f5b2d9ab2e7b0efd2f6e6c71d19035470942aeade4e667bdb26289eee4251aaf11d7da0a530de754e82f8f3fd8e8e50cd74dc7763a2892bae5422faf80396f51157594e0da603543d7d7f137a64280609bd49cd211254437503380f51a473beae6fa4fa92ef00e23c1a888aa762743cf206571cc28c5f0b6bf2f73ab477859df6efaffc4549e9e3d7cb811faa5900a6e38007020b359bb6f327768fca6e2cbea12c4386995cfb1f21884a244933d00004431b98a7011caad9de773c531f23a49c212c693f7e25405482df4654e48546b5e9b384ff037b71ee13ea1e64d94052798422778f26dd837608d415c9d221ff26c8fbf21e0765dadb7fa34ea9a20cca404527b61d077d490d0d066f1c9474b3bf3c22c645b685e0d06ef9e4f949a676f70cc9c0d4fba03c32d951116ebc0734295fc195033354e89de00128eb238090d05538812781f8c6aa06c91f01dfb9fe655992b83caf8a640face0f149f6861c1952f4346939d792fc66c0ea8930c7936b3a7c8cdc4cbf506784efd336a5af38a3de0bbc5cf9c7b4cb01a118e8ca9577193ab03404572d1302c8ec99d343cb1e47a1d32acd6770ee7900bde9a8e7bd15818f8a6eb8b569d2d0406311af0b95d69912143601392c79889bfec888df14065810f703f6725d785b29655e0b033d5003537656d3b15b2e1ab4255369e17d287c4cf70473fc3acc83e355853526053c2927ba16ae1ba1cd49de320453c3bece60bef0841a091e75d2cc5913023426a6adb76d42c6296792a0dd0fc779d26c83f8a63c8d37d1dcabfdbc306fee2786da2039e21404904d45a7b6845c244c835dbd56bc4f8f66710eacb1467b06c2ae0c2d18d46d6fff1d8705d0c21c8deb6642a62a13159ab29659c102ade1dc110b6d62444b737664297ae3e7f24e8cb9f865a9bab860c6449db877f8de211415eaa7aa107e3f898a51a52bf9b26df970799cc9b78e783ae01bf218ab2995d048c89289a43adddcc2ceed6ed26ff96079a66f268ff146d8fdc7bfc9be14c9afa973fd280f29b626fe07c00b1fb7e2fcaca29202b03a1ea98de897d19f02c1a6bd5dbb63e643abc2fcee18b4987d40ef165b42fb87037cf3ce302ccad3a01cb8f8ce1257289316fbbb9c6927e15d0ca57727e94cd39f66c7491bfa441f885dd6fc7fe8294ceb32eeaf317c8b1e1d55466fa18f717a50cadc03239c58b263bc068f44be0c98f0d79d3c2c71b070a10df5da762580417a5941f880b438c2f0fec577ef9f236f55adcf184f7294f0e5d81f51e55b4296091f8c4a90048287fdd990fff79a7bae0aef88288da95a6da2633d44d5f5296a66ff2d198cdb73fe100746fb6ca1094e80f495544960f4e5c72737b7563e6495890850ce07c17dfbc72a5882ec50997157bba0830aef0ce09e36b9e505019969ef3a37e67bb3123ac4ae238af406a6747118899165c9735b499b7030931604569ca622f3e3442cf8bb499d851465df6edc1e0bb14c7c39a36105450c999163faac689b19382994e26c45c37bf07ea83f795518b4e26ca20f8e86acd520557e77204ba457ea987c5efa7d5e0e282d02213b991b81766f31a8236c82930961fdc5c01bc2a341f0df4c5f0bab7939bf2beeedd01fa8d7e1d86aeea314a712879965017517e58b657059af20f2070f502d28e1ecfe4b49008bae639c830da5dcb7639d7ee38fdd2a1fbbb378bb6beb63182de92f0e60035d01bb491f964e5941bf4ca0763e33f0c23b6cc7ddd0bcb6f966e4b9df1e7a85a745036d02878cf569de95c1402af31c36bc8f23679c443ab837115bb26007ee9ecb3bb83b31dc99240540a1135dbe426f796c88815a8728da07134506a75bffd698e6b49ee7ae90b546c8a3252d934ca64a7f0a3cf1457111f601c01f3a98fe7ecb5b5b4c3b2ace530d30bef37cb40205ec2b4d6c21ee5de752f8c409bac21b8e584b1021b079a3f25c0ba18e65fd5aafc35709fcc82fa2affe2bb5064233a804ff0749f0bb68721d6018b939cbb207909d6fb7dc29892901098bc8f75a8c53a84df1aba7501670fd064253e6cbd0d4aa029bb4a95ecb1dbaa52a271a262af92f27f72537382a28bb0e1de1c92888a39c8ab250e26c337b1c6080ccc9023534598492c1a8c69d0cb7fa1a9e960fecd7f9f071953d2822a9054aaa07768025561a84947886dc3d379b502e90a59b5dd636fd1c1acb11247a5e095481005c91b48c247ff4eaa08e332a06b6591940fab8024c13e3e38d6f83c0a00b163a4751491cfe2a9f22833a06eab50fb7d2410cfda5a6ed703c21215625949447f25b220d85136e6bf75fc610c36bef7187d91dc2aa327d8fd60a7451d3403a3bdd5046a4195ab0f9a4985f9d2709c3a1f45bd5cad4fca167f2f6fee9c4d30d08a3fa2674337f4ed2f688f600c1e7d536f799456e58e940f1ee96c80efc084a8d690a209eb356795434fa0ee6299f8e24945b32f144199e9c80390d1c1519fd0071a31e89dbbaf4c63e45d7afa308f3dc3385fc3f0ad7e75a873301f63ca8ea927803339fef15989e5bff87479ec7b7c05f40488d68ff9f2c0aa24316dbb4484810ab8c9c47c0a547e3751d736bcd13914b4af76add84426d2e0cea0edb389a9e6764ac92951ab8ed3ce0d73dec711c7a317c311cd51debcd6226c50ffad0d4e2a537b73b31c3356768d2a0c4f1f613b534a447b8e372ae0fc2f71117842af509a8470507f4f4c6a5503e6f7a871ae328bc5e9de1fb918ff340d9f5aa544c5c728781da41c2341cf824ab093ac7d3318807d296906d71ce510460cadc1c03ab6542cfd083fcc424e073d98b7397e11a83c003e84a4e267fef0a8e91612729ce5fa4fbbe78a6398fed8c196d1ff02e55d81b77b9118081b3a3d6386696309e425ce422ba942664550b17cdd4f9ee6fe2f1cc4cf14217bbcf14e1990e61d1aab76de54da771bad2a4ca32d2f4cfa834299b2478e779d904d5a2549686fbf75fd0026511eb5265fa55d8c8bb140402d205b8311ffea53c923117ba8fe3501fda9fc8f462e0246918301288109ab55fa2dee0dd8eea0fffb11313b9893b5b0151c32da7b88d39b142f8a66ce3392486466b828bbac99c4671b443314f44476e363749d4693de089f0a1ce5d8120fddd8968260d8a9ab3454fa374d795fa72ac0ea25488a970659bc9c6751b9083ae0003002f72f6e10b5a5a4887fb0bfd5644d27979169fc2ddaf8f8dee50b53b16f40d1e9b76720231cbe40300464804495bf1ae9b8bf869ba0cce6dcd7f44c5c84bc0c2a2cc9cefdee8cf48925b880cf6dc2378ef7f7546401bb9adffabe6418e7960849f02d54290beb63cdacf9d555772aa2b286542ae59d33b196d79727663953a3d0a655648f207de6d56c0ca3c2483615a3bf0a79996859c47498cb41d5c27b53aa292a6fd472f1f5363dfb9fe11b223be60ec8981ea44882e36e7b629ce59c01aba1843f751b207bc83ed40a0cdd55a68c4c259c8737d2eb9adc284f9e8cd4115071e9141570f60aa1b47d6f477a4e26b5cc789d4afbc4c6b22a1dca0922e016e6a88454f846cffe1f69dbbba52d63b722069f1b6da86f1ee0b3d5bfa622a41a371bc21b1c0b426488afd60a9e16e94efb6c45af943cea0472076e6945ed19977f65ebe686d70f946a8e22320865b69be41443e9ead0f7fbe36148b230040eca1c96ae15df6b9a5a55f5ca6ea8a08074e474b622d763b61fe4a76446cb78bb3171ec8ed28266fe4197eb6d1e0ddb1c4df8351e3ef49b1fbd5b13cb7221d00dc8287fd3b392b52299e6699027e4d4837e90fbc6851289f10425966e22a50b47ea7978f9934c32e281cede4872f17bed547d4428144352d32b2b4b6222ea74cdd1c9d7b66b83aade592b5c073845e2e83e736b65c519b052b809a70debabea5b88a185eebc849fa1a2cb358132e4c7549e05b632cf70f5086d3bf76062af379ec122672d2101f0f55d601376bf9651b75dde95d8dafc06b8b67e7f0fd3dbe9a9646262afe3306a9afa972933c5f7daf65c79649a6b453ff9b3dc69d2fa450fc93ae597c86f04a88f1e08c6d87261ae16e49a9462ead0cb275810e87b564d7eb27814f5699c69e145dc02cbf6179e650f8288bd3b95dbb68d981c5d5f7e5b7fb293cafc2d0e5e433166c653ff7c08a7233d3418bcee0c5e8852547e7e6faecea890ece4f617a2115e0d1ad5836df9629721b1d789b5eaaf961144674b49ae918cb9d7235dc6955a0afa0662eac3c38a2948e299820214fa7d93e346fb4c3ae55e351a76f214430861596e4e32bcda6dd3e6b1382d764ade73bdc92f27d6e7239043085d8772f3c1d6c7dec2164dd76d64d39f2a49e8b605a3c05ad136c08557d6f5c61df5a89707f7f38c1c69344a2ce1f7c6babc3c07e386edba4c8d7bbe609268bfecb284dbc8f7523e55d9e77e08a5c079fcbe065c44f94a88b39cf20c27cc4e7f950296687bd9b36bcc122fea736e248e0f0c2e0c5c22544ca6abddf8925b29198c5fd917922a51955ab110b2b0ca87ed24c49d9e6dc7f9f22bda221636010d0144a5ef66f6281dc73784ed0f3ae64b8893e55387ef1839af307dfdf734b87bda7f07891456ee46861df8715aa5b4fa891576fbe0e1875295c9fef43e47d19257cb202b278866e0e2e1a878a3e8eee17e343b26a698e506c62532feafe37c7ea41bfad0bd15e295976c9fc0a727163852dd341ddf8f2c3d678cba8965eaec4008b9f3affceaf6f33acd0fe7ca50ec869c5f7213ccf6dacdebfd5004987481ed0c98368968cac32650530cb6df7cd1d000d856f2f4b1db57addec6732c3fc8955a37a25bc56fec5eff7154efe3aa9a6dc172bd368071d118cbc7c33d040bf19b5fedb54c94663390befc316f4bd9804a36e1e50b85a3c798dd0d3f4ccd9b486c1544b7b3fdd718acdd80dced2f5b76656f10ce67a32194dbc1ca7382e32c9aedece84099aab4512e1833ae1f41eeb49687885173fbf17f482b60090cbe4a47c788a490384cb2b8b7257a278b238a9dbd30b644e50fb249fe675eb9473f6bfcc8397cd4317deba195ab3da90ad7495103c9b8ba2eaf4b0fccb27bad939d06a9aa60e319a52e0a290d78b2ac51d9ca5700112469f441395546d0895a381148377944f8856737e215bda9e9fc8526c7e2de8406ceaa129d2330b5ffcfdca5d5b34714020df13266c7fe87e20e731d5b393eb992ee0c81a7fcf097ed549df5c998f96d3104eb5091d9b83be3f844315ffac152be149c929ceeee2c6c4ae618daae88327a1e7999aa2c1a4b7338677c45fbb7e127fd1dbd82e08c339e96000176591d334ab79a8ff9cb7f9f3951780bbee30cfb4fa268c044dd46e5d5f25832acabf09d42300b68a7b2e947a5b105a84c66c3d1dd23c0a7967bf95de8c32ec7f0f648f80d118f22589073cd591d18278d22e902aa1c836442663babb2edeac49bed709d076f3456d696b02f67b44c0d471189b52f80db08720bd9cce7283123e6e9f7c27d3ed60bcc27fc0ae072d6c5fe186daa74265ff62b49a819b0ba321798fd34ac51025ceef2dfeabde23a62fa94ed07e13c2e2a47b0a0926873d8dfcf65259c24280b89e093869dcf30ae48cca9bb62c83545877c5149d162deb877938c0cefdaece0cc3dac189df89820ca60ad95c67d3cc489cf923c348149d7249a970f2b4268d324f0ab5f645ca0fa13279e2fd9d52263fdadcafd322a32207fd3e61178999da72bb33d27cb16b848600f1cf6b3bb5253ada19996703b0f5923c994aac5fe818b007a543a61570a2c9755efaec8970ac510a4ce23f01eb0e3060afcad55c5eb4d4397d743b02e3fded48885138a78730ae596a37ddef257704657db0cb0cf669b4424c7451e6806adc8cad021f2fecc537d49acb8c88a09b02aa5a3a1fbf4c35241c80145a19f9ba06b796ff3df53b3ca3fea25fab1df1ff24ae66273b0a524acde36bcb36203490514cd5425a50a5a73ddde746150e0321882d6f2f9ed25587866ebacb82af446f78c4af642b861d0c2494e41677c89cec4159cae43182c1c7302b16e9684d1fcc70c82dc9ed068d5bfc328d7aab9534addbb4514c700a19cc56f45fdc3164cebe3709be10aaff4d6cb61b4118129e51a05c5eac6626c554789564b57aa77141b096321623b4e1eb2b851e1e7dee7849830c4a458adf49f50723b35fdb9f41fbb819c9ed2323728bdf3b333e50787e4e772b4f5f599665a8282c6e9cab68b495","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
