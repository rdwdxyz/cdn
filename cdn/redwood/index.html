<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a66fbbc3a35d4e808224acaa56de138a321be76e3edb2b6abf2b62e713fa1448706c90e83bebac454ff40443908f10d34274c2087dca9feddbd559909ea9864d80f52336f11a22b2f7da559905e7d227afd4a52207470b4d47c6cbde750eaf7234de1805c2233788644b8fbad456fdc47ff2d112c90f33e37f4bcfd8301bd0f3fac0b8b5bc215b531f5f9818e0f8e1490b75de0aeb4c8efd53de56ceba76a1f652ba53791ae2fb94c004be8ff95660dcaefe27d9cf0c3420bc2d5304a6d58216f7226f0a0b1b6ae12d2047ee7099aa072c20288ff433ac80fb4ef44955d82218aec06d0caef8a90b8f00a495bbfea79537d4698d756e7ce5dd0d0f2e90c24c0004ab1522e25df2e35d6ca6d1232417fffed332ddb902d1a779ce3249eeca2088fdaae1f557c62d0e48e758cea6da9e3602ae3ed4e90d844b3ae250e89f59f0966c8faeb4d89abcc8a1d194b757a0e7ad17dd1b12a41a22943999979dc5b4d793b171746d93859d0288dd9e508cb9606534cd39a202e64eaad1d0f1ab8e6b2aba52f89f0ba3fac40193342566659e146192edfafb6f312ddb928eda1e2bc5bc84ac9e41307f56982566063ce595ae75e12b3f03254882d04a6fa10a535b46a736f246ebf75f80be88b322e624fcb96891ad06cd0e61dbee30369d553bf7f77d7cc36645d1d925f6a2c2f5109e0b48f15333dbb2ec69a3c974fc93bf254c7adc0e087b51cea7ed1ccd48abf8e75e51f3a06316edf6d2fcebac9df1e5100f95dbffb64aea01ceba2b7b61e68d8c720b17e9fe2479cce6b8af5768e6189a175932d89c83d5934372551b77b7c6c3fe6aa573925db6b0c637481dd7f676be9d4e1053ecddeff44b3a3009d85fcfc27e4a8dd8c3eb7787aab7f55d4344ec224a50b7bb4a55c74daca1a65a46d5f93ab8d0a3f3f117b3bb15ff3cf68f2c24c2f8dcfcaaa8ef48431822a58454318c5013f573fe09135d3b256128dd5ad9bd1a74930da982a01731990b5c3a76e1cb7abcd9d7520099b83488c7540199b326f762044cc52d4424d82729b6f68265dac4b04940fdcff0aa01d220c8fd50d2b33c7426d057bddea55798ed8ec3972029d57b8bee7ae84ee8f8dcdd3aecb153156df9361cf28fff0497da3564929a6eacb1a6f9b5cc74f1eeee409c5855df489754aef6a094f0a54a1bc518515d9cd4d33d52da91ac732c2f0f56927429eca08c79b0e107d0cc77d74ccecf97d7e9750619f05d2c7436b20a4e9bf6cd906c784c4db77ff5a8bbfcf984aaf5f5e77fd66127294e47d65acb2a290eec5d8754bc5499d097424e830bc72ddb58aa918fe6c7cd43a42f172ccba7f95d278a26db53df158723866a01956d23cca146e6204cbd6a470131cc4b6b2e86619fac282a7dcc7b9a7787586477e002afef971135a47155c33a1eed98bdb84b85cff9e670dd0c83efefac067b96979b189b39611209bfa7b614b086b9ed0359c1603f53048d26f369d9292b65d0ff076a87fda9e0e9831939294bf183d878cab69ed1f6df9291db2bb994a4a2616abcbe9ac8e8822efb2172742b44b3c5bf8b7a78a022c091eee611c672bd9ad67d54f4144b6674a72cb221d20230853cf109d7fc77f9d50fd5469b8d9643ccb94f5380fca62afbc3442d7c9f0d1b0df38f4583aea79b77d118d58dcc670f644d84d254a1e092b8ba77f44c6a3cfeb480a0a74a2d9f1b1e99f8441ca5cd8b616a97db0bd41267e666e3208ff3434be4b3d3e9b7daf9c0c5c7dd8f672afdce6b656561014e5e3983770485f19cdca9a9235658d6f9dc103d9b236aa8448c2ab8070ecbce991b6c9f56c14bf14110f3145448c96c2fd3854aed63cbdb871ed4de4ccb2d653fe2aa50d5b1294ae9315bc33fa18b3a74ce858fe8adbceca9d36adf7b71b92f11e53a2d4926570b8fa25a0d80340e8e2385d7d773754c9758eb696fce1eb31dd280efff5cbe57ef39d10ed12dbe6240dfe1968695c3b401bbf90b15bb6e616fe1a68672f3650ac06164851aa43e032142c2472a12ac1324d9427937dc0df66bb3a05b02e1deb6726277d61395978ec9ed541f0e5ef531cca04d664ad3b1139b0d51e221047aa39e4af2b854b3e335449515394973da359fe0464f2b2ec852d74611a7ec0361b52c0bbf1065ec0f447b22925250079bc4e395a416379f7513c22124ea2eb222c0e540717f543915a63f14d8bc690cd53e4caed87f9206bf1affd81e02ed83e2be0e7c2aa7da8987af38710511d832750694eefb24ec12072d1c03a4554b117e718c9c9cb1c285acc229da1aeed320a33c78a88e95a8e42f675bc394bf92c9277a491c341598d4175a3303ba0aa19deb70ad441a060252de2b888ef3b2f694b7b87974f72e647ecc9d78e362c3df843805821b42c737358e784132ee3afc234e3d8b15e472e7f6e6b7c81f2ebdc7215d6bf53a0036620fe55830c5e774978bcf40b9a76ff935ff5b1d4a78b4c43dc9fe04cf1930607306359230f0e25da2d39c2a8e96db723f2e83d3ce55c6b5c3ad509ed3d9b7ad80765f5890a5587b4c7026e59214b2499c7fc6b486e07e878c56852b8bf472a81fe07dc21f6255ea12eaab3a4c1b798abaed08440a2c5a51087777dfbb5d716c95e0f7ba5df1d349e916492b08e41d2ecfec57df7f6a4837afebc385aaee09254531eb9834d7ef9ba09f064e36d6525feaf955aa43223bf0baaa3f29c99d438dc426357a8eb08894944ce9b6a5af40814326ceee4e56bf123a6faf8b4045e841e8b5bfda87922be3226d3afa88c35561249b25fc5a459467373d10d340238cbc2052509014d9e10a79a14ddcf604fb3625bd4ee31c4cb90162fefc113b26109f81b156ea229d4266a83e3aaabeba92d1890b11bfff6131f8403ddc9c1a19d9392346eafdc60d9e8fd556a2ca7d43f805696cd90e18cdddf21834cc616df6d8ab40632f47cbe799c9f111e2183a88fdbe7b1aafc144abd3f705ed309059d310ead0d11b784cf0d882dd04bf2124fdf9e09bf5a339c749bab41c423e3267fa3b7572b930032a2a4d2a984b3c9a8729142757acd38847a491ff8af86593e3449ee59264afd734381821f288c310c53f0454ef8232c108e2c9b822475c8132b3ec25f8dd83614a915086f108ada54b3a41ceefe4faae3209f0cd98f295b4e087c8de03edfd4f49704cf5dedc4ce06a2ce93521cf0fb3a23fb775cd3f61aff15ec824a60d7ec25c38f362fcc5b88ad4d7a25622c2b8735f1646da81f169b650654f6f84548af3b9f706c30949860b04ea5049139bda672bc865fc77ed4f270607186ffa782e5ce0c65f6fdb178e94f816499825a5d948418050d57df1c4c0ecc50700428fbd94f63d81bae44cc7c94dbb37d7b760bd08265326f9ec81a81d67c40fb647fa7112a4e67488182d4a01f6a08da27f73257698ea7bdfc1aa523d7a786acb8924cc9fa03c68f1f85bef05c59951439c2eb1a02baf8b03da56835f95351e67a6be505d4c5d80b024d5bd3bdd8cefc80f88fbdba9032e917ce4b4cff9d44d3108a8d099bb28db9b7e3efa5cf7db344a90c0024089b8f92bee93b08697cb6399704316840a6fb2fe892bea5f1c8b8a4a0aca1b076a3ac4f4f9e24b1abf5de7104c426efea46021de931fdcd345e8c576d454e43a03c68a13d6458031b4ce8feb71c7731ddee38220dd4f167d745c7b6bdca6825475f0baa6b3fd93c43633377354b23b6a2513fb7de528fb3124549e9582633925973b27fd227271c3e35862b46a45ddf8160319ad96c85259ade9477450faf355879d7961dff96cce8b4abc4458688b608fdc50692102a2993bffe423177eb0732bb47c90b8a6a423e470a3390e93db35f45d7839dac45957696cbe25b6346783f435400fccebb091d299c5f6af0c82678d4d743a9e21511de2a18934f199adaa210270b614b1874055f93255bbb3abc2300bd018eee4d5da881addadd934b40e4776dec55dd4fb6f5b212f647b40d5399b759b9eba8ca67a6869e6e6e87a7379b4e4465c90ae331716808642b00f49bbc05a3c07765d2612b21e34bd2b8917926e15611bc905ce7be7bfd7916daa7c58f2bb441f1673a0029b5c989c9cb5dd563be139514af5b31e60ff076228f185163024b4671ae2456e1bba23cd0a9e7a015994c8798c8d67c797123eec921e825172088959113c6a91ac1cab619dc816ac301124a29b42e09724153962e9b5496109f1bfcbc4eae2f4416f14e14ddb9bd8d8485ae4d183800dc804c327d59b21142a711df1039584fb36ff22be18df18b2d41e1fbe3e35df9c8d81058a083a6a14e76ab7531bab34330c9fb969ba0492ef311d7febe3a2a0c16d9d0addbef55cf4b14394633f17dd31a9993e5b0af351db9546d1cc915d4a79bf5734fda9acb42ee65795b02f32d890c52833de8c62df102985c6c045f7a7ad6e1cb32a34489fcec336b139cb9826131a524d97f875b2a646edce612d8c7fd2bdf0019ea9d36bc58cd20f32627321af87b502a4f3104305ecb62e4c2cef672addae44dbf38457ad5f7d53e0066ae07ac13e6c3c6577f01a293c3036ecc7aae35776e71216f3d5b292eaa9d2a71d95f3a0949b5cb18dfbacfdaa78af97c40b4a225cd71e32534f860b9eb532c981a4c20053f70572d5ce169226c67742f4dbea27a9ce257e43ca4a155038876840a7af182962cb03b452b691e83e14fa14cf44b4d225b9d6e144110ac978be13e3ecfa172ddb8d8d2b90210e52d00d8fc9e7590fad2160ba30bada19744841e0b15157965e73b6ea3f5f75e8786e3173cafbd5e71a5f517e15fbbdbfb7119c073830fc941879fd23141bdd60b2c80b2b5ea39d53f03677dc1ead66bd99ec297369a76588e173de25eadcd28a69438440223fa8484ecde987d550553d8d2efc8fbf5770458eb5f00a54b5f64e819f9b4684546afd13d6825fb847399f8a36bf6d4d66b37277bd3902516c9cc4bd41e315450639d3c15317868a57374ed9a31de6748336e4c24c536cddd8c97af686c64ddff8505a112a8ece6882e3e153be0008179dbdcf2ec8fe6f5598ba06b4ff6a729dff7bf10801aa086c972fc31ab1fcdda64f366047888ca195f53757ef1561640b81eb1b148fac0f5ff5464d54da9a06d6eca3c9b501c0172f4f6a685373da26610343cc09d855a4b4b32324ef928789941522b1934a5ed18d44f79f286553eaef3c9819d8c15ed8c22488c1b68dd3eac7f5138ca03b831678fb95575c39ca6a8402fb212353b0e8f045a10fa9ebb12cd34edd59601bd96de765404f2484a15dd83eff9b5b9a082c3d84f9949beaa258006ad02cb1d9b6ef2486d5b0d5c50c3355753d2e32f883a2e8c47f34cb75807adbd85867410304e68567eb1f5c5780b11d938840346ec9ec1e120361fdda746b25d50e712910fb9bfde69d4ec5dd1b1a384a2e8c83b53633075bd67d3dd321f2b4713b1c3d0ff0b98e00961e2f49e9ccf0eb81915e8c30cbb7963ef7dd899f4c76c5cf4a826353b4c4726a8cd2df85d873c34cab15012b095c1357328dd9614d114ccd96be9bef6777bc11c441940be5faedd13450720c00da868d9dfec96c757d3cb0f8d5fd496b405a333c0a607c5f88cc63f5c5fc7c966f0bd73bab541dfeda7ea6ef48ba26dbc86535613a579331701176e25773292cadf19f044826c96ad2793d746fddccee9959ab7149a1f0e062b2ea7fc826455d9a1f25ff8922f3ce0e395adfe26445f59c370d9fccc2926f133b57b1d1a7ea8bb476c907b62d42b9b5fbaaa5651517d6c96dee9eb4b8bcbd67cdf813cd6522895b94cbcf8320ef4624a8e2a14a827d3e0c7daa36a96b1d1ddd9f86e2153d8869bc57c02ca5f0adde744701b14c456f7688567735e781736f5bfcdee0b7b3e7aaffea20f516d6ec4dd0a3a76f8b86e60ac3c6272f2f00851b79a9bfe3efd397da9e9d1716112f4f6d264b45a53439bb1cd45527e46578446ae53b0b80a6f913d822bfa471a58e9e4605d8b7642ea4792d1fa2ee8dbfdc640fdc0bc8fa3e4dd1d5c6a3cef99c7c7fb5cbfac22cdc48bd687567f4c49b0ae953abc0565541fc10d92d326b673b1679080c03cccf245de12e0e37b0ff4365c4330b64826ac308ff46d4cdb7360465e1cd2ddd7163d2ca7fca7ada9c0752cb3d9d907f12563bc1840f9d756ed9e7f9968f2872e6c3b8e8f4bf6bd725baae85c0007f94d54f13d1dd1a41ddcce7f4cabbe2a6b08248eed0dc87febfa9502d065dae119ee37f762f853c845d1d41ed4249a6214ef4ebb828d0c1437d53aa4c339ff512a60e1a60b99196161dec6e37413a9b15d85c69e60986371ef99e1c932c46290535602c99f39628cfceecaaba0d2e06097b1f9f6c8688e4dd46394b127a62cd44fe13fed7237d49679528d59f917301155e4de2fc2c6c5c1aad85d18245596658bdc1078ed1dbb19143ad169acee8138081c4ed822bb33b542e5b691bb1913d0f9b0a7c568e34c3ce988a265158b9c9b07d7e2c710730cb8691cacaf5dbb675626fd588f28fb9e6609a070b2de31bd2071fdac9b7e48c5ade77e016d6e26751ae97ae30c22f531c9580b2cbfef6fd5ea97fe2da95f115436221483fdd9766544813c6147a1e7cfbe0483373a327b26bd049321bef93110269607552d8c68a0774eca178bfd900d018fea21218ea27f0bd9d6c5432e0cca568deb6e4e1d0a0bc8d78e8e2be4999c3880a4fb74004ab872d5277c17050cd9840c4852dfd5bcd3b89d9fde7401be01fa7180540bd5148f71f6d72cd7c197b55f0c86675da4c5bdd920a77ef53f8a6dc2390b4abccbaf24ea281730a96a90d25b21881e41cdc6289f80fac755484f91b83a65818da41a6ab709e806ae4c7b6f42eae95929e3f6e0705f85369a734e7e28382785ed8eb424ab0315d3851becd58b2a2a2641342b08f9c7546e572b0aa91dd2d6cf9a82046c170e305dadf47bb5685eaa88678c679128050c4b1797ca66ea7897af602b2981751237f1b06550e965bfcdbc1959a04f140238b34f59b73dabdc325f09550ced725a9299d7d48c4f6b60e97936f91e62e5dccceceba411659522ab5211dfa5ef2c98c065f0ee97d34f922bdd055cb78f9688858e071b170b870c8c2b417c8b993bef7e32fe264e3c2b3babe09b87e2c7722595c3eb374c7e91290dad4617a469958d53294a1d0e100653f17e29c2ee98f9c72e21e6430902b066ccf65244a93e5e1ee82b111f950b48e289b8f39debd176bbe136be708d09112f142ecd8ab8a309d7d8026c12ee44200e17a726e068d4f46559770b391e5d59d80f2b574341d37e7e3fe571e283ba567ff559d8687efb5c700a9e1ee7fc524c07b03451d589c82c8e082e68ec3ca4a5dace7cc76bf4dac24fd272c840741964a53af5df688c9fa5d3ffe765cdb729caf9846c9ba2ad3843e6c4a84115fa639b4aa8116c903b082e6009388af22b4a85839112c6c7472e6e343f2dba00b4f5c1e406f8ab14a5dc8c4da8fcbd67388f3b2ebc6089d5e208d386ac99359d9e5a6e7edd75d07f641cd3555b60e8dd878f1a1b4537c29db3ef7bff9c33f318e87b2b8044587405d986c77e92fca11ef076569c1399fb26789aa168f1fb0c4adfe64637b33558b37a64a51350c32fa58b059482de9e5e30d2d93b07dab6ba1be549a0e1ff9683ee1b36a87e73ee405cf3f8ee41a3f94ea57ae526230eb228619858ceda65f114885d0aa25292586a6ee13e06668ba79d6e7951a113dfb253f9d671149a551bacb9052146e082961e576ea7d5c7ad5671152f8194f0dddc4a2c01e98d5d2340c0fe5fefdae541cccbab67d61e2f6fe43e605ef266a6b80d23448298e4d490cc7018d9ed72ea516ad19bb321303723d9db7b9b2028e11a3ad74954cef2cbbf3aa879df789d907d67e1d8b4865fa03abfe4eb226aadc69ede2f9bc96a1a8d511e7cdb93d0174068370a4ee5a2d7f1c8fc1fde7a27dd7f1fe9db18028ba4a8171033eb6c54c16e496fbb6c748317e1784d18412e3038ffe803e77da7e90be8566c7dd6ff4deb89771df95272370ddc18e3775cb1c0a0566c3d82ed020c364521a016f805fb6f044b36bef528f251491d77973ae09041584b2d6c2db7621457c093db243b9282fd32606a0b0257c2cfe5831f217cfd9cf476e22b0a93e727b0c6b59b33250c2197d9c86e8c0cc3da80abfb9196b432739f168585de394d5191bddf98018315c4a3697c2c0ad596a7ac0aaa89b1a8a3f0ac5ef7ee39cb0ed08da479dd399d6dffe59319ad497a2425206b1935b323805233e18b41fc3a39c484ee143bdbf3e5d28f472ee58b3f545d34eb1a4a685eb7a53db5b5fcc2b6062dbc858d70487d2ea411906a4f5181e9a170a21eedca621d6ddd71a17316f92f4a4c2e126a0ff00bb776c3ab98e8666a84e5f2fd4c4ae4d3a4516aa83cd9dfa0d186fc4fd9898a0d9e03eab6c6e38d1fe2c7b43b4c380a976b38f9482a9ad211be8e59ed35461b1f655d04e40f77a32f7b40c2138307c76a74d3fa11699289a04e30cc6f3053016db9ae6c77e7f345ef20c059651b62fb86f3c3af37db76781bd1e20ad18a6a622adab01ccd97a86f92999251eec4269105eb35ee7fcd74178f08e06f92628d84a25af5027e45619f959555d9fba03efcd327cc422228cce7bce4b8eab6f5645f532e5d12916c9f52e5e9bd61e1aeaff9ffe20610074e350c73aacdf84dc60f7dd3a90ee8af11bffc9f7cf1ee842325de640ad154582a5e37222c0756bc1aac26f9a64e7e1dc25bdca063ee2e0aedf015950b09c13777c2699885f622d55776c343241c5a1942595762de29e0024f77291ad8cce79f46b48cc3a5fea83a66ee197a07c449fe7bcbe814ab2c9f8b7b747c6c31d53ed92ac594a374f21a91fd7ca115d200a051f4ece166d292fd19c43f6475b324a38a9175ce23770ee914d6bb932aae0433787f9de84d604b272bbe9dd9eacc64b5e9c3f2304ccafb9f402c2c5aeada528bdd140b25ad20bc50d26658da109ecfe7cba024750d5d92768b027d3b97760234be091e3863aae79a4b3b9c224e35e2cc2bdc80b78df7a186b7f9824fd0eb594b3165fae6602907c8f2f091f958466694c6de2546aff979165833aac2f46c076276080ac542c83e8551f38abbd5ff3de625347739027fcb884f62f93517d54ae70da723e9de25045e551f6716b591a2a17266f43c9e16fd955f7139014d74373af7735d2c099cbc52a0bb6e2011a98ae7ceb2cbce118a9cfabb31bd44d754b47ebb4f0924e8c5ae0d82d603135e9c75d905a30e1bf0bcc66873912f43a345d7a029e7da297891895678b6ce620695d4842525aaa7c9076e3085a51fc071f4403e6e6db646cefd28d085960ca3c72be637e8fb529e39782756c9a625fa770fc28c79ee7cd9e8aadd80394e40ca4c10fb43069a5fbca59cf602dc9fbb5448e23dccb3a461f094c672c617b363abf4fcf0228db881caf801e014915ed6dd255f023f2f056bc852c168b830dc8249461a59ec2aaf961451f1c509f519e967bf590df4084e3e051d69f84f3948f144e73b6692030551f6fa1e2b271bcf9c6ffbb35983df0e8ad8b9379beaa9091b381b4aa92db1c1df19d3bc013550918505bcc9432d80f417f8b05ba1a5ad2e9ee975775530e3c707dade0ab8eeefd554950afd74169f29db3d1b6a0d739d79f95fa8ffb056cecdd904c4ff2436cea62d9222ed465b638f8bc0e00000a94d38695a9179aa0fa9eee97648607703cea145626dc0ca21b4017fe9ec007c4146bf5d2d35964bf7381635e96d2485da7d17f9803b95c7375700779d977857d8b767455609387c4912a8f1a07a215e28287b42f0069eb059ecec8c0671b0829a373c112377873ea21c9c534955b106a0b06529018aa30718536ce3aa8621a452b9482c344f55a1b0c966f32ab42c893da9512fe233273fbadd5cfe8366aa40c4ec4bd166f89784858cc74fcdf14287d34dc9726bdcf8ed6ff38bae430eb5ce29338c408ea977a1d5f913e6aab97fd0b2b06b5304cabac7d943c2c95108520dc39a489d19178d687ee00fff40528b843c0cea1a70707b830eed960aaef6fdd9f95ac65ed784e9fefd34130c4082624ed0689818ab244874e4ab05b9e165d50c6386747804226522e709d14427a63e736944ecf17571e2f20ea9b41317cf7fa2fd09ded53b942f9c07e9a897d0e523d120f49e328acf983aae223108b7a05d4f4b9234932f4b3e3277a3f1e0c43e051f042f36774c8975e2bc44e80a57e7a61f9c1b141fe3dcf651f6923dec9278292498eb1a1c725d5a4460ca2c0e759d9c006efc99086b963f19fdba62f4f8583b938a099affd671a39e8f1056210d6b23c61cc6734dc302086d2479ddcc8ca8077d24d9e3133df3cdacd8b099e94e925fdadf14039adaa957c57a0e13b2862059eacc23bdab07d95d231d78e7b189fe82c20e0163099ba96b1a02b57c83e425584eada664819158fe132e85a9224e55eecb1b89311dbe4eeb7b9f1d1565b439d5c6a80dcf29215839c6c9575ded00863cbeb90b68f405c804b4328238bff343e3d2ac6c71c9dc5c8921a00c8aeefd35bd60cb370fd23d60df57f6821fddccf863bcb505d17299563a80eb07ca8ed413dc07f59c9ba4c28729b0e73bc6ec3220eb09e98c03ce5d830bf869731c8d73cf45bd9697d5ec87798fea4e359b0be336a2ffeef224d9fb67c2c61907ce972d27300699f166e5040727d83ede91508f374be59bf5b9d7d0f17703cd65954fe8d1a5afa1367eeaa004a5a1dd640b6ba4c8751fc26a9201aa3517025c0516abe0039da37f701d1c51573d109bbd57bf960736faf1e26858ac7db26353213c72d8861869eba818916deb31486e2622d78f29d900b854c2721e3c38c8fac0b85b9f3184ce80669bb08f3482cc50c80910ce366e85aa81cbb42262a8f8fa5de6d21a4a5f95074d790e3a1d1bb43a595423b48d4767784eab4792ef66200facdc90ef12da609bcaef1b675d4eb2aa84c366f298f84da76342e5260c457fa56be96c21b1f9fdff0f021ae6480c069dfbee8ba3048a5e28aeed2ea7c91ef94d157867a40027071a3d9e413ece826a5db62404ea5f8d888769303a44e3f5f35bc8b4cd48281bf6ea9bf242b10d41c88e317b0b22e4cdb4fd550e60522769ba934fc643999054500df46601820e3e47595e90ea89b73a898b9c67e0b8b0022a3e69d084c232776b44165e911d2f03fa907408d0f33fb58d095429726417908f2fe6d5591eefa82d9488dc7411f3381bb49e3935c41eedfc6278d919b2f913ee76358741be66bd9e21ff2fe249f16ef7642ecb26e55b382d1391d4ecb5520ad94d0654832534a43d124ed47ca0d43d08f4ffc0d559a3d27663765526ef954808e12a789e9ffb138da71294b990e6007803136b706442e3d2fa6a0cedf0eb14feeaa14a1688da90583a63c934a4e45911fd8bfbe4f508e17bd362448bb5ba59ad4c450836ddad1435798b99682972b0bd6ffd282477ef1c238f25fe38c13e48355f964d9403802c966a98a3cecfd50deb453be11e7de60fd7ca27dcc4e6108195ddc4297c9baceeca7bceebbe7a1e855c4398c857391792819b27a608ce7bd07e278cd940309ecea2579e990c3f1d38f7e06d5226870544cf1c496e663d32c0c3173b1dfac010944445b186db013e139685b699440f4f7e2bdd320249fca2f7e57c7e8905b36be45e3c5bfd9cea19cc47efa8afe59780a9b46c2bfa7cb9c45aaa7e82a8e57413a2c4eef2201402f6a7ef6056ee3dc7f84adc50998cffdc71b73ffe40cf2dccab7ff75f9c65bd47fe6b04e0ceb51105b7585987acacafa8b7dc4a7e4b5b19dd64a09160d29b0f74cf039d47d74110caea82f1cf471add5399385dd7926ad35925afdf12e3cf488a87528d20370fdd0c9bf7bf690fb557d787dd9f26a6ae6a86a08eaebec5023370a48e88dc414bb3be56cfd83f09fce934ac82c0edfde3a08836eedc80b38b3d46b45823788fed7eff199a85a6819e15aa9e321ce38943c4d493e80071f563cfa52aa7ace6578386e20938a6aa6abeff41d9f0f3dcd9f10af00dcb79a41aece4533a9d72c4a9957c21ce5fa790c4948aae6d6ffbc13e353f445cd23ba5929e0e87f8df3d0e281230be5d4b24b31ec74b75e72768ad2ed6aad33f899565769bc73406e24834d6ece93db90ff5a7c50ce42417cf0316d4fd00961f83fd7541b036ff9c0851b28539d8dcb764a02ce30783af43eae94556c408159cb843992a452312450f3eb1629f3fb44515184c5afc6f5bbc9a59ad8a0f3331e72db4d127756a7e2d797914da1d0b0924d52577da1432be00e0200f9ce358c575e709503f199ef6f0cbf95c239cfe5b1cc2dc8f205b7780c899e89bcc50afc73ee3732dd10e2919e4e806716f02be8bba73ab803324a46bcf14cac5dc468c02893d226734cb78d1e06acfe79a2707ca7ae0708c6f9c85c4c927512e1f714c4f2cc7c224da270ec4670d425142b63a6937c899afdd6f6f613348e60122da6f886fa7b1945e7daa74bb8da322465f92c8e0951a42cc7aa8ad766cbc3b099225ccb189a3afe400cd0febb0fb2d956db2a0a228bdbb1c237ef4c0bd54adff9a403c7c5dd70b32dd423236b22c5702ce8b527f14875cc512ca1fa5b138955b66f0d4666eecb45417ddba3ebe0d93990eda42e2d4f6c9cbf952bc6a426729ea07afac34b9421f4f53fb9adc91e26d5a6fa4bf533d3ef91a947ee7b356f404ee3c0b2c449ada6765d87ed18e33e6f87aa296116ee177dcecd429816fe2a575b1a4e936ad4e4767283d673f064054a4d5303b8e8fc0b5b2f82f405b5ff477551becfe25b0576bcd1733b37d3d6fa5ebb8669a5d6552babc360bcc5a5f9e65da23fd1623c23b0ea9f9922eaa59c93666cc2ccf5201301e7c121835554ef7ea5c6840b399b6372598b81e231c1ba2bb7810ff8fdd0b507eff22fb1edbfa16a2b15720fb619bfcac07ab02487d0f8d7d9844aae44d5d998bae6eda9ac0d9093063833f691e77980d1075a5d8158fdc69c7190256aacb16031041f52db5de3c66fd4bd425e0e3395d395937f3daee35b96c4022294dc719500aa0b4f6092797f703fe1b59d5b07f27a2382c8bd4f27899193681015c8ab0963f75242cc0d9d9a44c4a65495ea3a833ab4cf10fb33eb7d7609281ffc98a09781b0ca2728e8c12f66f2616d076bb6e99c365340a4d37c36daf8b5a7a4237fd97f3025cb0102d31122aa0b5faa8c54b47cd07b02c412f47aaf8be5ccaf46e9ef81c3d9d2407dfb0cdb1e53c3c61ccfbc229b70a343098594998ba4c976fe00ec7f1e7d01f73df702439adb70862b6ac49674e8e74780ce3e3ae4028a7aae3595a03a9ea51210dacbc600f4de178469561a9907de7bc74b6f27716227054ae960db498739e4b7dc9b18c198863128f4f46bc89fa49cee3fc34b4b25dbeb979cb15c5955c0f55008cb39b701e53ff900b88b784309a98f4ebc4892a264f94785e37532c2f0c69ee269080294088046ef98feb6357b27bfaf872339cea5cddffd7ae2eef4bf77cdefc7881930609f31e170d07f0ff1c7f281c391a84dd17df62139b5e2a2e9fef2d41720d2e2f5b3dac9b38ee258e7eaf3c3eb4f27589bfdf4ceddeaaf9b3f62cfc0cc55af8d44060f8a976f5da28c22fd66ea0a20bef0afea6f6b3af53442b86be28e0280f81fc640693b4920ce3162931e0006a5af474b5cbe01469537802c8dc8701c91368444f1247add743beb58f868cf57a4ea93a9c00d945cf13df03b0a8fc360b9350c4688dba15cc1566d532bee5326f0be9a4084e41fcb386d4012dcd2b2ba4e009ad12f5d93b12a528d9a17f0b122e57a1c63ceaf753df70f5f1f7da6c87fee0065399e989d4e830cccdc83689f78ce9ffdaca4081c859587f79831d50e29aa23e8961e6b4c7e13061c38e7475b711b367f0a699cf722b17bfc8da7d864ee228932c13432195a7c825e3dfb8cf828a002aa230c65e26e68e5d986d823465a1291cf1b57b434e5dcf88ecc9b3d46028ab6b46e04a5ab591fa2ee57a31bc39699ccb593489d064046a57b95a7d3b512b050f498b2570b2d8b0dcedc7dc22beff98930a92ed60b39cb6bea65aa2e6408ccae3229d3ddf914a671dcbf542cb8b40d95bca3257c4a6261fc48e0ac739912ac100c7ed3f99b2b6956e7ea8bc5fb8676d5a716701243cf93e7fb2c2d39deae173dca90e325021512839443a8dec3c9c954c8c0839764251df3f48c9cdf4003f4eb898e113b7387a51c615001c672d05c2e2704ac927d13639e92b647c8b8151170049197c43379b1b312fcc059e79509acfa3ad7f7af2a9122764ddc2dd9d2643e86abb17165491adc1fb8dfc870399760ffe76002e31e3b88d12689d6ffeb62e979ea94f01dbb6efff97d8c4607e335b36194d8e3de99076fad5a63ca8d49693a554a6bce29e4f84ef634f9175fb2eb01cb11e8c38c55d7a1427791afc36ea1701defbab502b1dbd8be191295bb7e6f0e7e0ff41a48f308b6aa9450c2a19466cdfe9d52d79dd1af52d91ce40ff7fdbfe5bca65a124a62d92c727e4c2330eb7fc05cb723d297eddf04d4ef5e7b853b4d80c5e37cc87e22e955472095d7b9277b7eb04365f3a4ed382423be0131a915aa19920aea7e06bcb6fc7bab9351118b0fc63c03e6939e0f71bd7f0cb2429109c022c592718d9716af631d0357cf8138e94ff02adbb8f681d573763f0d697f8d2e8e58aeec535d683ddfb0c7acd07fab4f95cf03a03667c1c71e80c0f9eb64135f9595e486f5125c87fe2c44be7459de353656763d5c3e5bcfebe75246aaff47db7dac579bd10cdd19219a9eadd306627483d7333005083e70b61e094399f148523cabe3e005e3cf9023288e61e4fb6d27a2110f345ba73325f4c0e2d2281dcbbc342fae15154e20e4785e5869bba935bdb8fe1776ac14f1924b98f84dfc6e73acafa06ff9373f9b3f17868f0be4671f2c980b66b5d33d743d4d6fbc557c0e5fba5701613f6f09c8801de6105b8b668cdf0a1923b3f8d9d622e1aa169418da24689de4d0e8e401c3e4092fe896ae5a0c8ccc18ece7b18eb766185068463ce772927a9ece75e7bba8b118b9a92f91461bf95b0a8e0d43b38f68a8c05b890ec0592244f7deeee9182235662154da388151292edf0c507de88c25fd493bf589a1bd0375b4ce56e178255a55114f02a8d6f8e439a073a1c8456bf83c6adbc809c0a0ebf4823edd14d0f258f541077144c640779c71175106f4c3b2d8a03fe65375ddf7e7baf8d7260c03e1a19567edbae6a9db0f30ee90f84a4d738559b19a5a9e4115aaf81eb80636b24359a729dba3ece020a4511b27a15fc21b2d2e5e1182ac25ba761df0660123c2450b4bdd59e8edbf051d8864c59c826f9e97bdbfeee8f17aa74256e1d78442831af0ed931d42d7994497ce75c2e5c00f8f816f983733e03d2bc86320421ca692bbba4a19daf944824d26965c259fbeb77cb8f0fa568d867c7ffc5f7745253b75124f8d60ecbe751f3cdc8104567bf0e6d1f22169d2a9204fa47e718f83a85f2d82ec1a2665bee2cd86445afa374bd17d0111a4b7dc132f2ac96a5281fc66cb47cd496d6b635da252e97242a7b70f61e3d841eda5188976edf903fcaa9ba4a00a0f5f4c1aecf4cdfba9882d5904b6525adc31fc97557caf679ef6a4f29cbdeed765d24db05ae10b87d31eea683cf1401323fbd43d3806b6686b645874b50f79153b987a1c92aab3b312dc941b74521316443b8239cb932b4c606e86b09f805050280ae537fd6de885c04201e11ba6803c25eac28d9bc08ffbed5776df1f8b340a5ef12667da0f9906d2396f15f05a7fbd4481e958fad4684165e9229ff5b3984a3f2e2d9e23c52077bfe89eca4a022b135ab3d89bdf503fa4b973e959d64d72fff01e73ab9c018565f5e25c6b9cade5d1e6e392dc955ffb64cbbeeb26c78d4341142556b9ec4e1c9aaa507b0fc34349576dd56f36b73832e2f6c986fea22c35ec00bc0a6f6589ca55fd99194fbab68975ef2f61dd89e34d3823df348a8d418dad6fa6cb39c1292d11a3bf55fb1333919b2b1fba8f97e0decb08591b5a69db53911a22695189f5d1ef0124cee7b739e582cad6587b100ec104d71fc9d5530b71544aae7fff1b542b9d219185954feca680cd51758191bb67fa75387323ad03d97b252718f973edf18bb0eb5abae6f398b8b4df2819aa7f5b4d4614e076ec900c79e6ef29552a90f400e8c7a7fd6b668409c772c79298495799d6dbf81502d298955ea77a5c064660e10cdf2a56b8e0a2b42efda72c35425a36cda94bcd539d489e57c440ec05fc974d156b750610b5fb8d295ce4e943db27b5e63beb89a994057877f06085cce0ade00a0d241efdb72e114d5012660af6b1df6dc770c2a6241e12b5969c29658106c76612cc6156dfa9f1c10c364dd2674422312de32f1d664c19bc4db7849f6607066d245131ebbb2eb14e801ec92bb1fe460925194483179951f1f09c116f2019044ce0bc4d5e86f52eb4fb23d3dd602350bdfaa315873d052b130c9679dc2559d82f0899a1f91f9c24eff7cb3d0efa26aeb0037a7273023717349e75b29551467108d7f765fc3453aebb893d8161d1dc59e91307799a3037cdda4fd73d7b938a5df08e7e1f94eda190691576f1f1ed38d4411b91eebf6f1099b6c1051422bf70d394bf42e1e049c7acf44e831bc69059452f903bf561102ba019ca17cd3bbf54c8f1d8720e6401e52ac9df8bf76d0ba5bb040f768641db4eca16b4649d28424483acc16da18f703b131a2434acaa1e2429b296a0224d5d1dc35c183650495c5b013d4e4ca69635bf9e1e8aec15a8ece09402b080dcb28d21c75ef5539ae06ed523cca9c4b888fd2345e92a3f6af9b35dbc71a1378d0ce39337790d9f2d98e3d64cc997119269da80ec8dfd1ff2fe734dac82efe5d3f62e065fb1b4a77b88df287ab8acf75ba7c78a1f1816d31b922b097f81d7c4952ae7a0ab7fa0762e8437eaacd75c42605425d3a270a9b5775b185e27ee2b50ae41fbb2bdfb1a7dff76deccf7ea7c7f5bdc7ee79ece6d24cdf8a03711d8b28daaa3375a3bd0f2ce2e7243a7864054853209603ddad004a89c79daff41d254432b1887d8a5067ea4a5a487024efb7cb49c55294f03561193fbeab8e5505545d2cf41bdf6af660b90e54c7ab9a89b102ed4618419882925e848ade63a95b00e0bbef66b4090ec60a6107da951ac3ca856607d9b0d529304bc99d06d1515ce07df1458178cfa9d2f384c4689f014eb6e4533b8a82b927f93f5d16e64254d69d3705223353cc273b9baf3cc7a130b2881ab4641cd7c962898f69e9a03f002e9907a2a6f853e7a63c0de6d89d11ccb1dd7d2ac1da8a5efc01e29e11cacb88ee34428420c66abbef2fe72a7238115b4a0ddfa8b2ef275ca78c2698b67d90e4bea58320918ce9cea171276ab332695438b5eba48c43a3266e213c8e5d5c7f22d775d96ab9ca3eca636a3d797697b96819fe85a48825f20d14a1d50262852a408c241823fe770b15e56d1c2fc5ea3239becd8e96dc06d1419f32943102bf5117cb2a4b2246ab45c0b73954405beb8a0a5bc35cb7c1a60169ba81b50aea99e2136c985afea92533d0e834e9cf90870b1c5dd798a42d16ae373b5dcf5e7bdeb5647d90bfa690cf96c55f9518ea54e25284c35a45407a28bcaa550c08c8c7adfd9395532089bfcb2d143934846e29deb2f3b544ab90346550b3f5ace3f9586697b36dbce6eaddb291e7b33df7d095e440897f1629c2af342a097bca6afa0b973b04dc1129d0489804ec334244db248ef93b8296de19c50445a54c5603b61626420f9200ac0407e40ff990b1f1a3807beb82470aa9cf56891733f0631b22df4be5ef850b27f32346c701ce639154ffa89ea54ae59887f6a6d9f2968620de101d6b16a76ccb90e255c8b752475a34ee482b4f77756cb35aeb07428abe8caafff828d54b2083d183778b1f3bcd42114ec74bac49c813ce4c7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
