<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3c49d3ca5b229da59ca987425cf9ca6f94f71d5c88e75234777b6400e214030c2533a02f67de91a0ace406724cd342a64dce30cbeb410fcea985ed6d5dc344448c445633bae1e5501ae8308335cde437fa489c29d079d060728557ddeed3232fc09a53a279207d566a7a8299673e2e1a5b655e9eb07b762844c9f44592374683f691308a7534daac5cbdb9f98dc867906cbf8045b580924f8778019152e69e9661f8bd3103b87146f20cbfb399e08b0f950f0999c19acf9abcc9edd79e9ceb78ebd6f4dad4ff1f554dc0deba5892370f32706ff4540b947255ccd4462a43efbdc83aa8c523c8f43b93154902ce2f2df0572d3e973e3a2fa5111085f009f629b6844677b33128a163b951e842f8d4bdac1bb72849b378b81f8ec7f8c034d8c62626a67d0df8fc87a2d93d5fa5bb76433f0c15d52a9e48602cbe66324028753678a82f06d4f30e97a83ed12e16c48545782b049a6c94353914930592a0cba56325c550a2cb04689682cf529d5efb7b519c7f2fcd08b1533bb45f043177c4ccb948d5842a237b1333fc95fc54b355799699c6e30b0513799f72daf7bc8afe60fe318527de2d56b85d62adc1956b0a20cfed9c078fceb301914a54ce922845594d0db4340c29b13f79ebeb7140c11f3c0cabfcb12d4f5535c2f7bb1b095f803ba18b9d4441d51170a1238fef464ba364de0ebec779becb56aa940ca5c209122b1116cf8b86e22d9e39df70e894b5fa8f9141900372ba5c08434cbc73a996fe01db69fb64a617a8c58372cef7acd0f45a92e0510554eef00021893448350313f7d82e5cefe272854c4d42a116d6b42bdf3b4c5246b8894f38f409544648a5c21656995d8d818855eff0cbcd8bfe336389766f94e3d36a7c5098ab422b8648cd1802f7bc2bef9132c9d1cbb768d401fd28747f103554d4421e604f59fbf1dc1ba99f015f185067029574b8b4a5b580b8647024604c7b676fa468ba2be4625c09b187ed1644333fe1b2c76639267976772b4713b5af043c292b90f1d7c2e310c16c324927f6f243b1cc9715585e30edc25889320bb1d90dd0e942f61dba192547cf2cae953c62df2d7932acc6d6d8bbb991ec7ae76951b82b57181b3e21b4281de6b1ee0b0dd25acfd9efb707bc43f913a1104ac0a9fec9dd8e58c08bc56f8d48982ee986e50bd6138436f759746dfa23fb536b66ef8cfa72c1190f7fd767d04df3ecea5912f31bf3ecfed848302fabf0cbf4635d6c02b4f5d528142d3b4d4b4e99cd945c78e45fbbf02057eec2e869966c9a494d0b8361695985ec5151074581fe5e818bd14c921405412ea92e0f07ad4f3b681688801084b6d1e50f7aa73426c1fad1cabd474eb2632c657b6ab2e251edf08f38d3e61f74e4f792af90b28493e133f25a65c468fd6e84bdf05d963a79331b4cff8ece06416bfe5a253355bb2510175684f3913fe136f8e98c000c72dc5f068163247cf34b522de265870d46eef0a742149133783bad9be8468191001282fd1b2fc7fad6e9d17a15b59974f3f2f2181cc4505870be58b8d785666faade7e6b2be2526a18ed44b8853cdc185746e35bf0034e66f2492f00be2ef2ea169aebfc7923d795f275ef90728d8dc67600503411e368892a7d8fd82c8b40eb1d001628f4fc886319ab9885093cd80331ed9d6f3975f38b6295251b735c8bdd7f273ca23a205a72ff66017cfbeaf3e233f252bf345faa09b95d9c4055393407647b8b9403491ed3c4835f47e46f739ad5c612645d20b022a51852e178aa46325434d894aab5a2eba3f1cf464902c69569d19d6a6163a2df2ac2e4181f4e3a6cdfe4ae0baed8cb01af9cdd676df637f66707d1c8e49d4cd658dca35f75421951cd4f4eb1a2c786616b7f29630c059f6d968c25bced1273acda7b1caa754ec1c560e1156d3758e40cedee19603eb4da5f9b5769ec117cdfd7424a5c13460b37bdf16b83db59355b7195eac3f3565d8a788b57d72c1adb4cf3e523657f08f59d86267fad1c1d4ab3ccfe55bebf2bd4c4c2a40e602393a7cf0c3925ad746810dc8281cf2badb7d3071ba47e738b3782ae9b5d9b8dde1ce0b195b7a54034b535a09531744b03d714be5520321b07bea9eabe402531fe4c3904fd9b3bf22ce458218ac3819109f6b19f30b459cf5e090705d8418a1f0e2ab63c319a17eb3bf6056b6ec65135272ebe3dbaee66f624d61c969de21c356e957e458cd8365b38f05d6a0e8720b931027716893fb69080fc7a39470952a4c8984a5052c14b921ef9deb0c1801d52441f89f31704d3dc6152b9243e3156889c2ade2c7ee633670a66c9e85a5340ec9ba9317fa0c0dddb77dab7061800687ff1dce4487d75e0b07c91e5f82440f32a1320bea72cd01f77aca4617f63599b277440ad96bdb6d66c570bc30cf12e6026e47589e4ce35ccc3ef782a24d4f856cd769abd0c8bd509635e5861b5d3a7f435e1b43d106354b08285cdb3be43e8e0bff05828a50e0409379c84f68c2b2090490fafda0dc3cdf76997e692f28736f8a06becb4bc8fdcc6ac2657c2417f6c293ee9ae111d9b44f62cc624d8cea963cfcce0717139b2a1ad338be412701b7ab5dacb0c1c536e2b1f293615ec84c04ff6be1d8bd3b3f664b1bc5541d81220c9ffa8a3d24692a48e433bb05f91bbf2671c0420e747be29f7bb43da8384b65751ad0b2b5bf1c9145ead8474f95bc84994f7e95fe50bc5e04a23ea898fd54303c01efe4fdcbfc29e4664d0761739a6717cc986d86bec541102d7db84d64aba64e76c083d306b9e0f82232c090f7803ca4a40d5e40a1522304d45b3bf8253a40dabe5907a6c87010a919a14dabed2ac222b149187b40f9d482520db6d1bfc6f1f4fae756012d15f1ec40d20da6ac7d5f5f6a444c7c153e0b33f354f55c4628d9242ea2362c72e42ee1d8913f793802b2f4278ca9f7c248be9318e99f926109a30152601dbd66581a43806d4fc106ae8a9ebe383524ead5325ccc8a3a3f626529e2edd1c92a98ba91c5784d752e924e46acb33d1ff1500428008f4ce85e3fc14090339708f067bbd5f19ca87f8b897768f4b0779da820bb45d938906e799eec7e9f014211af17d8cb1051e8dc721f6a814b9f6b205a168f65dbd0e00de95914f9811d96eea11ad54dff0744ee02d5a481bd9690a37555914a6f269b37171d6af2f8e7d16ff21838f26989e8999d5676e3a48d1144baf1f2508c8cd7c449ebec913f97e9b3b64d25e97ec681adc0173bab1994e1f2aa3688243f8530cc6c7eba32a5f7d46e8e3eb53e568539c3d658c499083657fd97132f9b478de69d4e1ededb3f1de79964999ace61b049fd2150a942f09ec8b20d3981102ad891f85159cda33253db288388b943761aa922e7149ca754083867b6dec6372eb5bb69368a8a57c68af24cdab68bd94ddceaaaef4f3b6cd8369e6d87d1d71d46fdd7367e6a5f6e4e0dc994228a581394f9886022601e5945fd836c34f39070b9d7a5f065fcfd9a3c9500736eac085eeef0b82a963a08b1862b3abfb7f90e8c22846669ac8b07df509f166e4253fb854ee289cd6f8f77781b6770b88dedd323d44beceafcc63f215eb25d4ecf3e8797b704a9decbd3f345ffab44cddac1ab77ca6f733ff747b36a5041b2d040b114ca928c7c7880aa5f456ff7b9b15a3a3540850b3730640810627f149152254b148d723f4164a55df28ad6b47eabe8c22e0ef0e080820c4af3eb05cddd1cb22e6cfeb98e8cb317ab934baf7592cd774046e3bda7a5781b972a4e798f7fe6233cee9ba26422da71b8042cbc20cf7a1878ee82754ae0ad031e608ee11cb15615186f4f22fa0c6cd7a595c8eb612931b6663a0235de6c6ea0e686cd3d833330e8f5c412531edc8d1ab180e2a8d4edbe4d378b0b02ff720407cbb688c19bf4ced2396515de9b68df96a8e3f274a80e9f377224e01996e19de52f69fdd7bb17c85cfd886aad22b7148506f87e4e3d97588ed64967aa3e06a2a2e473a938c8a4ab37685e919dfaf9f32d4c965623062a53f8fd83ebe7f6dbdcd1f6784adb909b5cc63f452e31a4c319eefbf7ad29b663f37e5f398497f6208a4b427498ac9b857e12b79a315d041505dc1d8753ffa242880d5899f1203175c7cb6a6b050775d36d9f399ad2018d61dedb050f951f65841c4967cdc9c72955b39d2c134fe464960eac6967935c69308770fa47441e48bd943f14681f8fa7171ad925c3d4022def53ef35c4a41a4e7439e4e08d565d91c288b7f46541571e80ca45d68ac70d669922770c46614dd8693135d47e31c1c8e3dba1785fda04917f185aac4d783853725c7ed5bc74c6fe1a40ec882a3606cdcf45cad38154a7bd99906bc680135e08f23a748804a59411b1e3002656338c4cf0b8cb4b1795f5739183a921cf7c9323aef33f667a92b151ebad48c321b51d63941547682ea6ff7cbea5a3a082d87043eac75290cff8b1d5a7954364908287183de6358d6ce5fd13f7fb20dcd77afa715b30539b8d1af33b07d20922e03687d5d172f2bc6470865f106295b2503da7ffeed31c0ce7ae4ec2a1769260de84ad3f971cca89c13949cfddddf4b3152a04d64cd0ef37d8411e21b7208d987d96ebdc68d252f63a9eae30440e0ffedaee4d2b437547588f087049511b0739dd769f94fa545a1c100ca6260fbf43e7ebf3edad89a129d89936c1219f7aff0cfbff889854621aeeea1f7d7e5829ffdaf2f095178f6adefbfa2357fdb5743e72c074af9dd1712c35ded735d84ef5c41a5981f72c3646693966981cbab99948f8d77c3f587c9ea1642dd3fab1be0c440af9a9c33e350b612fa48751972ad8f84d999c02154bbb5c5fd43362c1f84e20351a117702bd31a26ea3fe38ec2446ccbcb321beb2e7dc940c9060342d5e0ad231992dd1bbd36e2910b74acbd7053e19117275579e1d31c3e9009703f7a3ec209196502688e6be4ee011e38db31ccb1dc61a498b49849c9c63a59c9fe2b32fa5f0d56009c4fe44d2d7a999cbf9c88d9cf0fe199289950f85453d388b6881a4fed39f5cc037f1acb4a4bd612b00b5b01fef70473c95be9237f1c24a6fa0a34b68f993abfc6e44ffcc51be268951b3c6df62846b3da3e548b5a95ca1632f083dd4af103a38f44691187d2af144e9c27f35abda29179e5b7e23b04ea5c6468a7496cc111abda41151814a6b0f7a7a27979047fb08f7f61ba71a20110e8a9a94709e693603fa049642c80dac95bba9f6453195dcad8533229790f417abb126542ce0c15b1caf002bccb5b47b2cd9317809371144fb155b25b78dbde105cb7c448f4f0f9db8030a208ba08eb7d2971d75d06da6b0f261bf776a7a73a4c5886c68ef0bd0dfb3e4e19e2878584c75dd8724ac641400b2ed35bda3a1ebfde07ff45b8010d8821dcf4550eeee9bec8bd684da28210cf234b7d8119818d665aa594ab78ca256b7e863841d4e8c592941cac6e3dd548ebffa01512e1aded8bfc9f2b6028581b656dd13c9e56a150029a4035c95bfb6995ee8a113e02bad2eb8a993835b050e7b02047cb3624fc432b2029a63fe989f14b4e83137fe11ed5e6b84e3d021000b341b270e6a88faed70a18123c2114894500841545838ef61c0ed0cd13d46413dbf53b797f9fcb3ed54d855ff81ce3a8a2ceebda1da20568a64f9b49ed04ad3a0da35eb1cd377c2b0eb552f42d0ffcbed41c56da323caea81c1ea5773706b66687b9b591c9eae9bf18b9f65c28cfe794442fa3b575cf7403312227f2c0a09330e9c93c787efd6adb41a2a7be4af1ee8368a6b396a95ddc2bf8093fcf39568fdd67aef56f743e705ad5f33572f096911d4044277fc7b6f3f38e414ebdeec027b0bf8e30debfa751588a0ec82643b311fb9ca6659f697180e6374c399ba295046da83d09dfbee154a3ec2ab528a93e2d7aa5cfc5b7a9621c24b996654b431f55d2a9bd19e440c216c1b59503619dd384028a91c4e34e2a7504514b12b918c40faf25d41a71de159790b17e2519fcf19afc4cd0e5426e6f19ac66dfea8fddf8788fa2ea253f9b93a282ccc8c9812c65eabcda81c9767e6279796156dfa64a479c5fed5b5150354be5e280dd4bd94b24c2c36a0272ced8a7e13986d40857b890b8d113925c415dd9d47c8c84cddd2c9fa41317e3e8fb235b0b450d20ab2a696ec356f7aedd6489a774176e9e267ddc70b1bb53847b421da909ae2d9b2993831980cc223ca6b12ad830950fab4d0dd09d90edae981854c077cf8474279448a566806ed869455d3822dd04d7b197b22330ce246877a57abb629209e01b7518d8260824f4363f386ed6b48f3ecb4af46ccb22fcb2222885714add7e2be058834c51a07859db15dda62244f83ef5bc7640034e52facd5c41083b538f574644e6bf1d540170343660d8e3d82e28dcca547751570e84f2dfbf8794c5ed66c1444e3d246b22c004587b6034949018567ea630bccae4f9de8eaf79c44ca1cfaf5e90a084ee4d9cea4ad57cf15ba55d212f87d59dcc728444316da16a6c8ea85c2d3794fc8bc16b9e1ee9828e27e8e97263f369cdd547a45fe2f9b4fcf1afe319ef1d7b2baaa95d322b69ee7ca5a36eb0319e0a99860f8d348491fb9033584aa11e837c923689b2b12f6c1c09b238e50f6baaf162bef0a5b0d1e6a9e323b20f95903d0ba754c11b8cf48b310c13d9b18ecd4d17889562263eaaaea84c7484444a0fcd232cb6efad9dc7168a0770c402beb8d77d9fc3929bb0251b191d15657ccdd8e90a2f53b54261c10242ae13707e508c2b75dbb087fb3213c122a67b473e11657882c0c7a28f6982bc0b78fdbbf308123957cfbd89c10baf028f3b65760c97221486ebd4cfa29d360bfdf1fed7630e1e3375990c2f415d9783d1470227d7b98a5c07456b8e8a8969cdd1bbb2303087e2fce1b93fcd7f6077eac563fcf0bf6e6b5bdf865fdb6761e05a80b10f61e08087add2cf34c27efdfde1da4d7eaf620c5a5521a65fc263f552bfdf75593c5e730401c0d9f0c5b9c46d6f4c06ac0be97249ef1b4c2090b176467b56b9454faedee8be88769757783d05abad865c23974a8290b933d6ce77a0af5bafb61e6c6c6cec7c2cdd87e9e4c1bd985154a56038a903e200a03751b0ef814c148dc42b91c65927634c7d46bf870314421a2a65af8ed736ab6c371bfd64c8a78fcf826e918740ccc0e68b0a03cd7bf4d8c30efadc05cd70600f4f206a9cd29a732899bc63bb93dbedf45c627e95869d2e4440ac731ae40d0262acaf8dab2bc77dbdb20f5c946ac28b405b55bc7ee4d7119597ac9e310454fb3febad1e039369cf89a6ecae8e7a1532a13e361368565355f0b110c74c0cc83a55152432e5c435d2920c5506584eb4332ddfba2a9483fe9814c8db524f34862272eccb8e709deca643f2ea07b28c8e050176ac0facf118c12d49336bba7d5256cb8b4fd4cf7c5d27916e29c45f2db248eb28252269b126603db89d97468361ac45604f40ef9f46dca1bd1baa15c4f2859552167179b9a158a7db6069c8063890a1078369710b4e1d9743d26a895313a99260fb2e07e20de3791bac167703dcb8114aa5cc4b7aba5e345b4e61f16f14c239c5a2b141e63f2541ebae8448cebb439cdde4afa5a7715237197b2a89fbdef313e10c6970a3307e49a62552fe207efa84090d7a8ef034ef2ab517ffb618308365ce3ef9ffab062ba6a37947e34d2435e9853da82fc028f2928eb0244759fbacd754168b329ad455884c9bc25f85e81ed3c45f8fe98ac524f8b318cd722a552b9cc20f45b5e544cd5de09b415a1da41857dcbf3e307f1b08002b21610a86008c940d5429434f2a2954b05bc418479f43a2163b55affa05322d5a2ab28038764a63ace4007041b1aae2fe0d599cdc409832470e46a6148f8cbf5ffce444134e6db88d73ced9a925f160817e58b79e58f251e0e9a345ab5241e6e578666413f7c99b476c4392194daf75df96110a7435ae3792e5478e5e03021bfcc75a10dcb739cee2bd359a3c463857a9e3031bb0e8797f818ef234dcb8d23ff674ab43798754629365473172e0d2977d0c298116c6d2be60eeb7d35c95e148b9af8d0c2885aa1494eb7edaffa9bdb5a6f7a441e5767441fd2c21eb10143d5eae237b82379c305b5679f1176a1a2fa03d2107b8162aaeb03b94da5fecd26836fb3d3cc15f3f753817f483e51a0d213d8cb7343daaa05fcd1e1dd554f3cf4d8425c2056482e441fdabcd4e0708a5a62b9809c04b15c4b1852d725776ec93b5325d9999acc917c545e19b34bdbc4ed52013fe7110b7a929bdce9c434606c1d58adbb82ab7ec97d3a6516747bb11fbebdb4c7bdf27dd20bf48f2a1c99a9025a89b4785af2e34dcc66d118df718f8f7f96dccf6a7cea17eddbe1f594b42f3ffb13fc083b28d56abb8b8aec194576d582da4425b3ad27694847f41f651359069e6b19b1ad2bb7aad390475420180827ecd813934dd88cfd8e375d1fac4837f3940060b567e461b18101d57edecf644cdf794e7df8a99940ff0a143dfaea2060ceb72eaf34191f64783e22b3c4e53da58eaf02f2ea6c9ca68fad7e211c245aa6a643cfaa275f7d3e26751f5adb4b39798e2eaccdf2837f845e2e333ab1f9ec3c86106a5d91dcedd32fb01653ae1e0de62aac9da0338f03cf36dba5f570fc9b99b95e745392c7279a25c44f62f0fa83c19212a50d1fccd59becf11374aab0fb3b4cce05569ee0be986aa61de614d593c171acd784065e3f45e9046553a41cc63da83c870207526bc8ffc702932942834e2295fd9f9e08ff7733c4a305f414d2a623b0df8923bc26f7ceeb74dcc7770d13059df9837dc2434a7dbe317a504a737c2b91fd21bb03546757efa8ae707b2fde00a9fb1d87b448796717a66c7394fab9a71f212c6f073c8f43ab4e1f7bd8295c33e7baeb18429b61597c2920abf4cc667366c802ae3b95e41abb4be5ade6754566da534f1e5ff89e0049343f498593f0412f6c6d29452e3b762e1df53815c3eb53ef9ddffb79c97f37e8e72c485d5b57e7b8b4f2515320d006fe3df77a8fe0f7744e37d0819d464d725c29265fbffab11035ec968e15cd1fd7affb173e54640b5b132d03770d95141368854aae24fffd85aab2b689b13b2d1a19ec051727eded1d6ac1a8a4db9842a89d59b22e529785b87311867b50c67cf35015d870e4611bc824de47c19243e116e23cdd2292c6d343d9ba901c3b6b9562e8686b508c4510c00a888a23604e593f1dc417784ba281f969308127b623d59f2f0101dab30280d3f6b3392ffc2e6d1634ec30d8de534ef27ee2ccf17243dbfa47d121181912f9ecfc1a87c21d5ada064be27033eb9ace9e8b1028626f85a05d8562ad3ea9598b292ed7a3a68deab84901fe4b8d6e95bf2e94fd8abcfdf922626992c617daced59da3bd5139b21664e7e03c6881137771e19f73ee88f5d3c8f3fb00250b79db19f6591ea622798e3523756af9934ce7bb3c25d0d0efbe6674821ae96e748fb74a796b0aad3829693e711a0f7a21cb4c8cb7100d3b7d94ba156bb5c389f9da07c642cc7d6ac6285d1d04b837dd5728116875af119f4a5796d8cae0a1cdc28b906fc0c8f0f0eeeee200a668d2aaabc9111235c8df867b29cc6049c4f2481aa8e32cee66bcdc3ae15f8d61db6e087c6f552ea487d79fe4e8a4d0a09016687e486949a451ecdcdf9cc445f68e091c3b81e7aa5df38f29f72e3e007be256759819970f6034377f27d8ce97acc1a5b285b350ac5cb69ba9faa350063be6432cb3ee932f9fa3dc30b17ac27e607b12524f36efeb582aaac3cc29473fb05e3a33187eef70d0f98082729bc996f6ec65a2ea4256bad4d5430aa4d7148c01334a1301a60212184cc956d2f20f7cd6d88ca3ff6855622ba1a08e1c02e8b8e310263d8b2b9a5ed056542764f18e199458417f3d8d9a05035923ce4e7f3cbb052c497168e147641efd6e2748741006b9b03c03e6ac34610e8338b60aea7b008d1588d181bc53174847227ba8240286b2aa11673b922882b65f02d3c8a76e18f184978147910f936c134c07c44a7505d8f4fb2d92aaea0b438f7824f70308d2673296d0fa78fc5fed450596f5f394f7a88da39c49f8042eabc85f99eb86a68d966f3b29ba005af76cea6c7eff145858cb74d145fcccbe4c9f89fb844c6e10ff7a9f707d89fe21ee55aeb6279d7aa237cc51d6e4fae598d40a02e7a05821133ec955c628affd71f8b34b75c1eeda05c0063336b640513cdb875641a755a953bee2be7276398ba81cf9f7327ed5b65fca70fc65f146dc941bec49e2fa86682590e47bae77edf07b2f570b5e7347da62b83bab9b3887f8330e9cd26f1a8d1073616f1186996ee6beadb5c0e58348228abedae582d92a8fe5538309f9e37d8ebaa67b2cb21ddc7a52dd28506676e2f09ce5b9fb6b952c4fc223873081a34cfb8bc9769dab7d3c4d75bafa9ee86669ca740e1fca4fd0d29b23dc5704fa35e98f805d00d96f490bc109bfbaa7e209dc45e93668fbec6e528ce2c321bfc6143e45013d2f7941d7ba1f775798fbad0b5a8ed95466cf07147592a696bbb1e14ab8cbce0fc8eda24c8aafafef6f0b413110a58d6156ad099dcc3ea1e6553efc7095c741fd0f80186b6ce2de4dd01264afb4cccace9bfae960166909a1d1268a60ba3b52f928975edd98313997a2b5fc9f14f3b60068534402e9bf0d4342d1c8b0c59af54315b872243255b63244cbc61eca2573efc0abd0a797b4d18b91cbbc4bade59043de249cf321dd8a856d03e760849100ed2b2324352c645098236c279ac3feae1e8ebc2520296351b7d2d194bd0c1097ee144d29d166a67e7bbe4ef8ef2dbc46c6f006bba2de1237ce976e4042a24d7505e9a497ec4a6966f9daa75debb42311a6a4b1bc7b022e702232c83a8421dcbf738b1a518147ba3fdff93173b86c120c11f2c1e9b0257d2d2ffa82554eefef4ea68f5ca0f9273e5f35e01665a7b1b1de90354854d076e108237c8b59cc16098f3c67ec26c999071412bc9e0f89d5242093a3df87ee22f7e09385f50b1d845793b32b04dd11a965214924b9101ad23a37f4067935b08dd99e51375faf9a64c102515a6eb17ffcb5b561ec26d322602541b09158e00ff71ac86fe4bf17c3f7a64c9946fa13991e0d6c4f14eb367978a9e9ca8fdc2c7fd8bcda2f7ddddf32bd6406bfab5ba836ebaad7490722a8b40e9c9eb5f40748c974f74ecfdcf1656cd99634dda19d3fb738515a50a2941075b04f53d46ec038f1aad2b87113b558ae5f203cf6e8a93789821f79189ad8b355f8e6a9cad3e39705229c1ea3e42e1d150af1b8a798d7e8d2d6d7f3ef740cc221edbccef353e0144f466d2ed2ff6d40f3bab266185bac6057fc67f03da94cbcd52787ae60d158e34e0154bc2466972e7805bdcea5a710a12c92cdc401061d9327ba4994ca4e351f423c71203ddc8b8a3ff7eca38ee51994a75bc6355269c6baa769ac795791573288a96afa41dbfa50ffe4f9f4429263d57bda41d2bd09546ba4765fd44761c63214b6c9861e1b6ff66fae6253805c74582d5a20e988261eed46cdb27216e4fea5d93150082917871c1603219767ceb4c27c73a970c12e5f274b6132bb9a2c1242f8c8fdf3910606bf6df436e9886e96d255b65565da16949dd76fb95aa869a77f15c22a2ccda83012049061cb065da051232556ec849d810f13af4c534ee56580e3f883bbb802c6cd9616738a7d6078113e94dc142b0747b7947642c2786710568993982da1668b02e3574429bb053b0cab55bfff5db44364692c1a22006138a9df5a5723cee20f6051c65f32d7ef646963bcc12249b31b12fae423c2776e9e5e0360c82d6df8ac0bee15c3c73ecb956368ed14634525bcd82519e787dd279bef236b371145e0d4b37d503223bc67418c849f1e1e2e884c4ce226a81ac9af835456bdeb5d55f9f6fafcd0697ba136bf920f43640b63ba565f62cacba3dbc2837918ec4ae5c8f362a58299cb94c7aeb71de424219d9b72e46380d6e29d9e909a287bbd6befb5767644c4df0a10ff2063dd0536c4f0ff5eccfdef4f2adb42e10c16141b26a60a0ef00d3a88fbfb1e20b5f43747e489a746169fc7d348bee5d250cc9c42a8bf6275f00bcc1396bd08dce8e60261f71676feeb7e241111aaaed9733878a30836883cb9605f3b0c47b5fd03bab238a22e9f248f35bd7471b812169ffda689f6840ba5bd2a227f2c8dd27796cbea300217d4075a145d954031a88c79839066b7efdb3df672ef1820fccfc2ceb7c5180f76c26367a30cf7ce12920be134e0552f14d3bb2db226fd34b9d6341e62b2aa9b2c1ca6e94dd3e4bcb358b4fde04d85be86ed6cd5a5f01616fd9e0a14acc76038e2c8083950e0f3370ccff0969aebe324e09d7e201f4db118d45212657cc8c71297db065f3d3caaff2531f3f4bbd8044df9f519d91f794899302da8f2f066a306362dd9d4365f8569b3588e3050bebc20ce7ba72eb413c593e85773c71d7e09df5d9353e94509824a6b2dd1568aedbcd9611d9665202dd359cd5cd4c93f63092e3bbc64bf005d269f4716afc115fd78cb2637ccd8e878e724c3638ecbddb53770b53e2daf59b638c089cd539a77bf9803723f599d7f2025c9a9a95f960d373d13cd45990b33b20fcefdfa0c5c8a4a8dc8d367889b23d7f77243b754535396ad69735ee2804eb87f351e3922b098e61148f5d0c3582727d559a7f6903b1af8d1e0f4bd3ebb9ddf739a41a02db741c5cd49c9d8c9bf66e06bd2c8ab6368f414f084ac0865b35528fd3d57fc3c955e02a5157c58083a5a4cbc868bb821de9820dc0c9243b10b790a01f69ae45f252fca8bba2ded65ef83bff92b203a9561aaa4119500d6f281fd3b89453fd36c58d903af7a7019e72f6262dcaec6bae553e5a868aabf06315b4334b7f485c68a45346fece2d12e47821ae56464508502637c2364c472f531a9382c2bc4fdf448a2ff76057fa40308d875846b09d4730b03550a0a7084bdc92e39bc022aceab2d89f131956eeb7197ebcbe7e3ed30ae8b9da0a8ad00876af03a62ae856b0a69489452ff72178147d0630efcd1a404d7c2476234a5f4d59e1c98e9eac96179c1d696a1067233ede842b790a6ddb358db10d540f7008e727a1882fea589dd2966041148c0686f00afafb0ed0dba2b20e0ae677fe9e82612a1a7e85e8d5753a768c9cd9ca428e3e8064453c98a7af16b52bcb7eebca33457a19b2312bcb7f0697d59a8765ee38334c3c1470880e17c49df5a51f217d7c2ef7bb2c29424ce769a5eb63ec3bb4f8a700af9ecfff425a1f412a9e2012124dfcae9569f00846e2638caf1d100210bee26c32b5089fc985260dc7363f0190e807b84a33537bc54d38e0d96fc6082e78ebcb25c88d476de6ba04b9cc6aa5dd0d3dd27f6234210901196b460c7b2e911057877345d0679ae24675912c014323dac47933bfeb43540ad79e0e47b6207de2ec02d9e1a5e16d07d2936cc91f0ddb0cde53ea1b484cb2f9b207798efb56be379401a6caa6dcd8f57bb7689997bd2b4eea0b7df8b6f9cd3d7aba3da739a9b709535787abb4f5ba3beb7f7b0df3d20bedaaa4fc8f381f70f9540976f95251dff689e3a8c7dc5e79d1a5a4ee86d50a8db3910a66b0cac132d079cf0054d32b52a965898d711549cfd880bfdb3829871699233af5442fbb35aca2651b4d0222d7e9ba34960a760216441f2afa52d63a5e2106c9b3dcbb1a6b2e801cde931532dbf21a2841b972456dda23d58dfa995673dda910e5deb00e25835624d1b024fa2cce4b80b1c0d3ef0449e3e6aa4a8f2f1b7997e11c4808fd9d5f91c08a2e15d92341f9e7518294706c836699c3f52d51a9685379d74f88cf36032eebc223fdeada9805dc899db3b8111d2a4156633cb69f8933ab673bbd8c497c51f7aafb6629c72055a511b07384543c74c11f6c4dff435151b1ed4bb0a7cc81c3b5fe7c1a22ffba102a11901c87528cb952f6606637012e3b8892594e723b00e60bd59ee163dab8be8f15738a9aa56cd99898c72ba07a18cadc395bb403d4860d4dd3580b5ec56d0e0e13cfcb2fcc1cfe7a4418d8dc1f9b339017ad0b5cd647f874b64f84c67cdd99e8cd939dc17c8260fad11affba507339163df8a30faecf3e8c59b1a42f21548a5eeda3cdf4e6e1ba3d9925aa17549a84977e8dfe5d3f5249576b4fe7ad394113f2046d8694424da34294d0f6eb6a7ee464cc5a7bde135a9adedb97d23b21859daa361fb1f018d9df55a916bd65d577d0d761eeaf8021ac03649727281e990fa6780d88166806dc72b3883742acf4a7f9aa9af9770100dfb764cb1f632c617d0ede742e1b1053d9078c04b2ed52558e333e25c8c6ef3d278cd59c3e14d20a637434177543aafe7c267eec231dd9f406f48bed37520ddfd0c6a0221b64ff666c0658054db4beef9c5a23b928281a19b42d56427dff129342a739c393a4e8810bded80372f0426a20059c60a9a88570bfd2a50c99907962a1bfa3bdf659d17fe1ec6f31f2ce6f2caa60a3fa761b751cd72fbe570db1d2ca3acc149352924e9cd6231444c29c06112260475326fb7bbead90f1997755d0bb469f1ec500693e70c02a150ba128cd7adb3ee55a0376bf097034edb004e537f8096525676f2066b165ddab827af126a725ab82b138eead6dfbbf767be8cb11287037461cdc753ded85ead3685447aaa0717de849f8baa0cf1907adf558e183f11a64a6069f84508c68d069229d739dc1fd76b79b95c163fea33964bf164633a65e701a03a9f806ff121e4c00ecc357d9fad8c74a3ab94ad3b018513906c1ab9da630fa282b3fec1e31fd666815baace42ecedc6f8d4e0585a3b7667e40dcb6aef1f0321d614b191f21a5790c5071befe2aff00bef0e23dd227ac331297e10593f8e7887d1a960daef2f5a24ebb1dd0407e049ff47a6c21eac93e9a510652c794c785b03ea11ebdff06a751c4f90b7b549296b14037ddc2bb343ef4b3a98bd05e528c034fe84711675dd9664929fa242ef4e4f627d131996e0a04e342b86e5480a77682e41917c8b53b2bc762c6c779182210558c02d02ebc70d4ecb3a100cce3e4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
