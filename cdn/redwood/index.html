<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4be14c76a4fb0988463b41455d559fca67a8f881090e529d3a23b770ea79422cbf60991b546113a382a2569d11349171298a79a12454d1bf4ffc10b9622523e458c6b89a8a8b461c857dd231bb5b28a38a240ca4e5a353652e35f6dd2a2e7fac7154c3dc0613734a2b5ffd98525933ec099c4878b785692e20e6afbac8bbc9c64fc848ba7c9eacc208022af7c22ae9f20e6a1802cb2fe2e3b6a4e29464d734453854b7157668b48987ed73695ffa622f6c79e6b2eec064cae604ec711dda404b8197228682367f34c2e8238f9c37b88e2bc38e96b7f724b8b0ac65dcffcc8704c17e8afec8f085ec0c4505e9ac5dff5737b1fa1d8c0c31c52e5016348069023c4d5f840cad5fdf93d6aec58bdd1d9d3f7edf1670abef2829da29e5e647755f682fd5e92082c10c9efd056358b9b4b32c92058a0e710e4e25c8a69d0c2bfea602c589db08fe4121daa3a14df87dc0eb6ad92b3effdfafb770daa49b794ba0e8f78bf88522665dc8fedf9acc5bdccca18410832c0ecafc2f46f9ded218db845270b0b6427b4061b021460946156f4e2510d4834c9f9443ff1cf404c2677b61e8e1d7494d758f8e965f811979c4e43ff36289086372a154b2cdffc4ff5242606bdf77381993601a26acd71039da2ead1a6942108dcb45d75584110a01efb942e02555d251ff6d6bcf422735ca527b24dc5334896aefbcb9b9db7cf605c9226dc4a9f730d111e53b6446d916ca8d70323b358e0c0f6aa2cb7f6fd37beceabcac935c3f120bdf48b3522cf00d9fd005417457b353252abbd7bc0bc4bfd2fabafadf766e9e3185a44a3db8f8c6a48d968efb488e2395bd5e153cad8172014cd096ae96751de152d7dddf47fb64c459b46fff0de268d00404c1f2a6aff169f7292424523b40c6bb4fbd2900473655873b2b867ef981fba449be215695b9cf4900546ba8bfecb13ded4147728cdbd8f4c485a3f73bb65d78b9e7b5e87492074382c01f6fcbee3f61dc2325ce4b9b6fe4a71ae0f507169b1528a523a3c4d5365462caf800d28826897e48c9f8e45435288795a77ddfdd4e8a47af5595a2c3d034ad7662da4050460e4ff846338a9cf131424c88dc0ac5a8002a4de4ef29ec2fad479038b41be64bdc8ed9dfdc2e8ef4ab945ba4f237300ddb765cb8b9563fa4bfa9cb7441378d171fafbce5e19b832382e84960f4204089db8c913b62ab1886ff58f4391b5af43d0cdad8d97b7a86d967ea880b9912449201e924e1ef4ff5d1d63f27169ea3f0bd39b3d51fb393c0549205d372cdcebba64fbe844fde93ef8a18f420a0e363757eaec900905c35b03c302d4a9edcfd9bc8265c22a28e7726875e0df09cc95726fbfc07bddec9b01c476b1065bc9a8df7e18add6168436a1818eec97d57f586ed76d52476f8ec20ecc7a86f3d543c93949ef6e4676762f8b715e056cf41f326cae699b6500f9d45ab34eaa3b908c38f0beee7818b150df5db04c123d12a6d90df14d2de9469a52b33013c48c4476c5f408c9f21c2f43c967566e55ea3afa86ed35303d2f96beabd792393fe6ad53d7365dc869048d5279e85ada1714446e083684750341c78618ec8b59526202af87f3c1c7f7a5f56968e8d31c9f91787c017c4df25679c3e822779b303cec72ec00eba1828fd2ad5aa0feff3c396e7770176108a3503b65e74ff91e51f4e86db362ec0205a26e7bde13367f0c7284f9fad1b5330a788459901fc76f77fe888d38cc98ecc46ee4e2847d468d28bf6bbf4cd282febaf5f28c122dcf05b435cc48508781598ad7f392836c22722ea3341a2e90816732e8403423a57bf55af06202951ad32099b1ace1b62ca435fc94ac490eab7953b205c858bc460c941e25cd4493aed304d168d24125b19fea56e1ac020fdc39450817c94a5ee54322ae8fb1d5aa4269140bcffe888717364c4641643c88b797521be3645d61cd61fb668e1b2bf52d9aa034f664ebf23dfb78c189da6b4e89deecbc14faf6621393c1c02f47f8919f3e102ec33045cb4fab4ece8b34023c9f0fd223bb9e3bcf75fffcefc4e6e9364b33f98a064f5325f118d730f19536ffeb0d1d5ddf9d58a3dad9c9a1952387ea9faa6b069e3c6ff0f8c48f6e1527c55d49b2800e4609c675a325e1fdace5cf487f8e137b64878d71965748764b54eda674c9a540c169289c07b1045ac5e4f116e92130fb0fff8f9977862e2bdedc2c1656b4159b4ea55f8ad64b3cdb481e321e5aaeb6210562ffd1acdcccacdd7fc840f6061ce3dcd11b1ad6a91556229931dfe7ba642514445cad5783806cf18786bba71cf3b6e4a1880d449732924d6cbe6b072f16f8050a05e7af5345452eba744177d9b04106c51ceb485a7ddc0c042beaa62c113710a03ebdadf35d3733308cc38b7ea38d04dffa359a109d9ffae5095ca532ab3655c79308dfab78cb2afd0f9c5610bfedcba5dce56ca5e17bfa0e1bb807725bd658294215820f39c536cfe5a76a59baa571c189a8d3f23489131a9b4561c305958f5dc27c9718fd89204de59e468f9a051dd9e96bbb97ee7f8b4f7318551f3a1cd468abe2b7825fa129947fe7a003cc3d669630359e1152a634b5ca69ff2ab82302cd541692810609260205cec7597987bc7b82e38a56124da7025fd76b7edcaca11152c798df12f17ba4c9a32a9349244dd225fd7f09e6dde5780e91803f5c47d3d403f5492872281525a74fdf8fe3d7e2b3011d448682b8d4ff00bfbd58791420a58bbc5eeba7dc9908d423eb7279ea1bc0e3cb2605a6f57434917d5b392dc110b45243ae6312cfe07ecd097e801522eace60aa1406db082690bd7f8a0302a86ca9f969bec3c9b0cc5d2361a047b9a4950d4136afdf36a503600e489c16b0f6ac74fb415a74a6fcb8302b6eb25245e70a1c0697cbc1db5af07f2513d34ca836ae799189a4c5ac65c1d0e9153e0e14d097a386b151bcbc852a1f2c6cabb4ad9715ad4bf3319134b012f42665b6b81de16f560f60475170c80308b5862501bf45c44a11b9185b37c5a937869d2f267e57ab82b9c385952cc52801e1fbc3b2d5485b46420adcafd23a74b81a00b6f3f9e2e8a73db17b5352164909a7a5c747c75fb288f807541dd8c30febddf81b753ea8b50380f8d2055dfb528ba97a242e6b550287510555a6b1b9a36cf199832afa3884db266c8c680e722b3521bc318fed7dd45670885795c0a4084afd2feffae3045c708fb078e113414bf66e3daca6d63a7b3dd4b2abe8483c1e65f928bd851c1ae52e39ed3f1bc44b81e3a20d92a8017d95af1b2909bcabf3894b0c1ccb9351454469c9f8e679ce0009e57ac7f7612cc2792a19dbf679e977fbc7345642b415126fdb3fb250ccd5db991bd875379127000ba4c23af9b9753422de613bef89b397ee0e25c19a85b5b752ab6eaed3d4af0e2ab52cbf30911b89bb98d0c3febf70d688cd24f6c3f22861db400f538a84f0d374e18a308283e1baa1b9c8bfb153326dafb10903710061311c3c7410ba25b4ab75eb84983179cfbbf6b764a6383b25e47abd0292b767be6960433f7b4ecd2b88d1838fd8cd90be190528737c9c38f313b7341fd50635cbfb28ea29c47ce291817b920f7b72fb8fffb754900d0fe5c3e8063aa4c0f744620aa15da4670fe9cdf621a5470818dabefe0029711e30836d769b30185972eac878b30f01d72171989bf68bc0c32518a6d2163600e105d982b113085740098fc097e4e10b5b242f66dba7959e106b9122d9435f24f24d8daa7076119e72a0df1c69677beb366282d5dd3b63f9b9463e515ad1398df76e3378fa8c9b0342389e39c1295de75f15b9abf924ec0a0e5f730a031085538c2066823d0f5b5ff6c7353c61419121b8b32b33d704aef259a132af4f99784a56985ca4d0edb793fd97564026beae54f21f39c4625850f16978deaf2feafd213935d0b5b568b176358d9d410d3934f53a248d8cb93f187783ddd461eccb602574a7b1a72c8cd56d8fa54c7e8e315732179523fa997b9191b9aa6df6a9b1d8250d3207afdf3d284c0189481fe00e2ac0d043eb77fcdfb70f42cfb13f221bbbf7eb6bf2f03755279ee6fffab0c175f41534cdc596f01f4529ff91d04e4dc636aefe93abe5d649b0805c634919d7f9c481e95205a0ad9af74c8e05beb0527dd04e77474baa2301735ab6411ea54aeae742e86d3e4f36ca85acf3d845ca1cbeea5f380581250ff48f129343e6120da368f9443cd61a28c8d4d97a93e6e0ef91f4dab9fa50ba00871460752b4f50b71f4f317d3f99fa250a42bd41cffb1fbc30cb3b3eb12a30d3cce4efc0bc76abd88c57654ce2d860bb24ba715c5d2d96e2fc294b0f8e08930a27056cd86a3fc0064f50fcfabecc1362bffa268938368bd276e0ff2b5ef0acbe49228c404dc12344d343065a26272051cd8716cebbd4642fc80b2a1524cf850486cfc5a1e8235deec5852358a60da6c860a342f7f60e0110e799df1b327a1bf7db8876d5d85f890a0edb04c2a6329d140215304c4d1ee7b47491016b6fe9729a1845179b342d88671b5541b090b14857140126124430e71e7b90e4a87e59594b7f0c78de5de1be4397889f04dacc8d67b8c613514e0f657dd4e2a105af89e4682bda6147094b710c3d76056431f07ccef7af75209678cd522321ea709c142f6a23f14bb9a9370b6a70588fd3a1a616209f21bd59f603e8a24ae1b43cd7a6f288c3ea740fef1105c33fe94bfde2cef0eb99307b03a7d6fd0a4d9c1675053ff6b417149c0fd989f371b1aa50fafdf0bd2e843bd86f84c5c0d044538b15c22c51b96d5a804ed2cd55c995b1152886f4f2629d67e8e327a134e3ad9772efe02ff7abff4588b67a1d23932c00d4230adcf394c1235c1042da586f0a87ef64e8d523b2736e07f88541a31260892241d4bd79d39e5d6b2444f619d54d1adff820e8ee2e3561f8ae6014b1e123930931f81bb6d9aa3d07cc82eaec1e0d42a8d2bb471e9df3998b250e5b5df5f395df5803d290882465f7e843ec6849589122424c0a1cdbb64bc540460df004c058db6c9079020327ca0b85e8154a22dc0cfc0fa96f858afab55053ccc6ffe051b2d00105be9955ea0d099a39bcb7625b9d75262f44cddb03836730afa0c0de695905b6cb85bd7ea050da937cb96af5f4f2ea137c8b28b30958c571821e39b3692af6041eaf2f76a1850dbd51d34df9ba42555eee4be73122a07d8dcf4b042ee6c39c68b7c69b8ad14bcc6c0abf0e70b51ae53909fd6ca852f01dc4a9119635cd5b4877b400cb5988b4d6222d681d24f5a54c5334f86945aee98e1801dd0991ced05962b20e34bf0b55e1865c12d8af6e67829a381f82282981f3cc94f8b2bb7a20561d6489a1f7d69d616a33be19327a10b4889965c4c8145f20090f3f241758e4ec9dfd3804c88b891c6fdac1473f15575a6b6364e3a0f3e052eac8cd7584f50cbeeb1cba21915bfe4612ca85fb1a3df586654fef921cef15c3ffd170270d72c7707349d1fddc36351960fb1d3c53f51c3af735570bb3b5065a68952819045173af5a31be70ffe53e2632945e2f5b118712019aecc7c22602969da0ae36e7ac4b258378a6ff9a842af864bb18c6a87172b104db76fa4ca25990c11071367f6405da5d6f1c3ab94483e5aea18fe1ca608ce801d50e56f223ad1fac7b9f2956c750c315dbfc6c694e3d18b5dd2b577c7f838642e2b9e5ac44895e91727a2b6fef60f3d00d856b8e8e8a7e687e99c7b5cd5ce75bbf116fa48a9b6b4049408381e5421805e4f41603581ba4395d3ae62b15777ddae6ee39fe065213ef700212bbea920ec997a1f6a9c6cfa64a5ed9f4f90cc6e1e8b325e494d0a4b6588c3adc8549f77b222e4810161ea1b320b89c2cba6ecb36e6041397e4060d1308862e328e5c3c0e2e98206be0e665ce45f739a49507be5c275c8876cd48a3ffc17190a865363b7244fb08c7d76ca8e7c3d322c9148be1d99719df5de9400fcf31307e12c5a801a1332bf799b082c6f53d27ad7cb7802ef3d17ada44c39cd3a6dcb51528fbace2f11a3d3aa54576b7d76a0c364b52f20545108cb36b2037904f90d1669c03fd99669e7d1c643d3268d4a8e028a66203d9640456268cfa8eba3287b5071db9b5da648a2bd750b4da241d8d132069303ba80ccb4721f5f72e41a96ce3d56773fea242e8277e4afb249e5d7fd017444896fabe3ebe78f004958b1c26a8e348af1f5ce9ad9002616cf3603d3609cc67d09d35f9bbd757dbcc68063140563b5ffa482462441da3987996bbd6711dd680cd3fc2552330bf71d7e1c88dc221bab80ec0a7094d8399415abcf28a4bb1bfe6084fb8661fd55a331c46fd51a2c13c0ac3e9e7212e023f7fd56b53782c338c859dfbfb5ce89d2028612c396918a7d3aaef4627a03035eeac3812fc7d81ab8e75f6985a3b4b0098f47e55611b704e3d9424b1b00e46123c3b0408ac384bb635ed738ebe152bd32336da4f8e4b5c7aa60ae80111671430165e421acaf52ff30cf6e755173f29ec988d88a5580db1bc9da9533efd04eddd32ee2e03eb338386e4de304282ddf862324631cfa408266411a816c3fb8d4c9212f46891354b5869287d19f58e72f2b0ef74d3d46533c88cac000a59490ca3f6433987d8cf9d468b39e4a05694708b8f236e0aca981b2b3cee24eab3addb48e34ba0b6d2f36a9c2aeab0d16762e85a4e734fc4c6f28989396fb7e55bb467479d4612cea9b0c98a231cfd9052cfaceac150ecb2c5d3ef340e9a4b2f2ab1c9bb1704945efbc3136950f731b747a0a506e785fe6ce88d82d43dc52a9c6749483e95ffb9dafbc420d57ae805f17df06646bdcee33bdb538cda66439c9caef51e9d5288f98d9a68fac491ab07991f55e94857d1109198feb9b71a041184f93fd9b260f44f76d74cd751f67a013dc750c4b7b289e6b16c5833c0f6983f879a234c8cf17bf82bbb8f2b1ab64cb568e3e01a0705f4f41ed1fc26e94f70c7663c8227815a55ccfaecace8f0330b4a0785e1994959705c34c4d96744e9d9eb9c03599bd9612960e0988327a699437ff6175cefc74e6671601f1800da768960c504336b05f7feef302c0ccc9d7f669b741ff23f1de38ad86f53f2b16eab154717577ea2c7ecc321caa691944d454948cc3f980c273b0658fbac87c877490813a3f5a2974a7a87e7e7e0897eca9dc7b00ef0dbaba427c1aa31f408953ce5d4b916430de6bc096d77c09a5792c6b7849be6b3cf1301444ed42ba4ba2407778cb1cca0b9d023a2b8a6da8d0211fee83e63f9bd4c0477cb2fd451b8030bf7d58f6b7b1fb4dd73c84bf7e8b8fe7fc630070b174f39eb0202d08c169d6bb26601fc0564b486994f4162ea92d85d160ce4011e3563816b30046c976084aa3b4dea47f7f7d84b2ea24d6172ad339ee7d81a6fa509ab01af0a0192cf33d6675c7c41c80dce372665df095c950876cae1fd71052c55c169f9da202d294d33bb31e83086d9e700f599392823c2240b91a03a4d0f6513d7ba09130ee632579b3befcbe761e018a255150e5d7ccb07e3cadfe96a88c3114752f92950063f1471cf6db3d41b33db95ffa40ef9c04a7d46de72c3848239aa6bb3daa12ef75729c84cdeb52ddde41bde69d867c82e42e4580780f4005e60bd3f8133828c70b459c3c565824c5c1813e1da927334cac4d02bbdeceead41a091992149f2f06df73347e9f68a1e6745796d763ac5e8bd84cd41ed3967427b0501485780f11e10274657d9368b9b434e2886e13a16c5ae169b37ef065f48c2aea7bdedc73ec9619485584ab7c36e56b3c318f955c50178d0169006bbfc6c0edd67e333d3cd99bafa1fbbde3ebdc2ccf11bc460c89a7fd1c2b40fe01302f00c88a176646615459aff18f23171c0e34232dffec487dfc777fe226214b1c13e7749ae26e295634930d1ff4ca88d048195b99e723d2c6bfa8e728092f82bcff15401ebf77f0d2779f537f3effdcd060a449a860d3ce5cf86ab086124407fe4a6496cb075dd9997991a8cd7c2b9565dcd2fb215ab2da272a00eb0bee4371bd39bd96584803283f8f9be083124224b1bd8930d474b70fae7b7224a669b3b9369bcffb6a8f3c980fc2d3768fb526e7187948139cad30728358b30322d9bc6786ee9c83119ec78cfc07743ec3bafe2f3ee251ed3647f87b7c0d333700e27314a545ae35b7be5355489ed16913d437b5f853f4fa7d4b784f66d71e67b6c1cec6f1f4d036b7d33173110aa5265adeaee5351a6f429159e3dea1e46b2d5dfae33758fed1b857cf50fa6567bc550b95378e93cd68b4685681b66cc361254534e2ee9b6acf9edb16a3c49ce41dbacfa072df89618f20d52f188f3cff2a932fdbd1e5f9df813b0a97a9e1781408ce9181c7c102ed6d3b3453bca986c3f7abd46391923964292676ca9422f23ff0905b8adc9f649896688227c99ee7137aeb86cb75cceea4d85cc6256f1f06256598dbb376f7a17aa58f3c3eec1abf3afca495388ced67d7041a198f4c4308843714387e5b29d6d76f3b4893ad80ef956349c7a68e0ea6c5f18e571fd16c28856441b1c8bd48270b20bc4a8c08f5f76cfafbf4cf7fee6b363a493803d91e3fa3cfb2e50bbcc13357b2368f4c0772f0f5a09fa89945295e58024242026add252bf2023e578e020f51cf4458eb9bade0fda5e63a5509c12683140b2e1d3bac474135d8b108675032da7d6bb5e2c26178db8b9d8b0f2acd18f06df5428d11b10826c596dcb451ed6d99efdd4ee8cabe0094ea9bd379e0c811cd4e1d63207dd9ef84e188e58dfa7da65cc0e230cca8b55059945e2fac69cfde63741b0629d450fb4e0d5984ac334c1207de33123b5999e40308add242a8a248bb81aae63440d2dbc06517c6d46b9e0f27ac36f578f86529333d9cc10cfc5213c8d5ccbe955dd746cca71bb050305399c82dffc9fa4b330ba2d184ed21f015814bf0e5ea0d1c9b2e560fa82de1516f4b5e3f6f9f96688a906e96366e36e82a35de81244bbc22f94b0c63635bb32a174005c3f9ccd3416fd365225c1c154b08003567a3467f8ef9eeb128b22726cb9216401266da28400cc8e0b20529f0ea55ec51d2c7828aaab765f083b86ee05f1da766a8fc4eb615e61d1212a95ed0400dbb0396498066df54a433612cb1140d69c8cb6a76805a0e86762055275e825150d0f46f1849135ea09dd0de01e0e6246982fa035849a9579ed7afe8078a8de3a0de6ce2d32fe5fb14a7dddcea59630b67baa4b667cff30f8e0d1d3cfcc6e687d8264772976bb4504e506bc9bc7bdd58949ac4ace0946ea070a31484770c3ff6558deeb714c371b2b7f554ef76e6c6940c77541ed2ead59024b687222d511f592b3f575b329531c0deee584f5693096213877b893f4d5a7ece73f37f481c4cf8481c668f0fa17df4d628b1ef72d29de674ab8d567287af18d1793fc71d9b867405aa3bfff51504b714bc793fadcdcd39a6580c0a02c22d956beb80ca7a50cc139535622b58f82dbecac27328104d0ae31a8f503bddb61799bfc1bf71f8c18343248410be5ebdbacb493825d31d08575c7b27614ae639e0824e3712f96672e833704f80e01ad8883ff8428e42a640057e6b5d30bf754d38745ba711846eecc9b2208de87f66aa736581bd1ca8c723f73cca7381babb6885e603d506f7d6258d612e0f24bd53456e2ce30d4e025e3bcbe9dff1310d76b3d1775edc72a0d47a94724222cca1f7910e581fca901ecfddc5ac903d5aca6c3af2128218f57ee077c047220c57c5cd1125829977c477619e0c47e60c0a3aab8279b783540945001460feb13bb01d1295792163e5908adbdaf889a0a12d246414e3b25a4c204deac325f960fb43859c7eedb16f6bc44f2ec54014427afec8923f26eca19f349554696edf6ba15052a050885d92a0ec2f7d484362464620d87943ff6c2d4abbe1e9e0bac17d1491147f7352077f01e8ae42992d5a0c69f2aaf59be863c59a6a278eba51308644753cd0eee3917e41abf03e4ef3127285c1166fde784cfd9296f017bf8228f7a5ddde3f131e3ee465a0d8ad3655a76ff07b3bd2dca68f4f8322cc2b56c645070aef2f14407ae436f07c8193af584c6e08e3b0bb050d243c48c20a24b4e643833e6ff05ceb4ae7516e010c74f949f4ee273a1ac28e746e44079afccf933770691188d556e22be0dab8ed8ce76581721ea23984ab1c2cd668f944e14ef648159d33829e9b5443769661fe44c2e7c57a58eaba6f8405f3898adebb8cfe5af62fb1fcb7dbedd116fae9b9a15f8bf5f83a800614613852381ab31cffd18dd0c66e8f17056c221d6db4ab5d0319c0b9b24ebde2bc7ad31bdb84cbb7663e2d38d0df9a4fc3f75926166f809f140ad5563265fa09233a6bd4018b3bc0d09dbe636b85bd90c1b2c1c14feb624d88413165314985d9ab2df661aed1bfc4698837b0a6f98f3e3fa4a7a863d66c51f4dfa2aefe47df280a9523fe1c759a2e9352f45472771c564b760d3686f4f9a7dac57b62bd1a8fd43c45accb637fcfafd82bdf6fb5cb0aff902d7c55877a68da8fc60242678e64023e55e7b71247cb05b6995be4aacd86960a0c0835b1be42ce18b42a8251ba70ea78dd0718be848720c35462e57b5ac58b87b6aa56606c0d4f2641bc047d3a52f08af3c068d057dfc957f859407f729b90d304c1e823e85a616e740583f08594d78c33ff38f23dea38ed9059bc4b6042fb10174efb98a9092bba7f17dd3522e0c58fad6cba97e8e26a5d108d2f00ad20aa8a1b8aef2f2ee9aea6a7d62e4d4a0c762d060784b99025c813651bd83469f30695466c5f0a506b5f74a89c76d51b42ef5c92d7a7e992e1d6841b395c46fba7d8575f185865e8ee5cf761a846c7143bb66cf56984a0c97ded37fb04d6de338e4ba568c6c073af1474faae48b4218eaf6a07ec00b1f3d8b7374b06831732963a3663805809cd4aaa9853207d11512f27dbe0160f8120715a5513b24af0d05852ef9271604c942be7e50f51f30925c00645565cd825d08a38c1063b1ed6e49a6a7fe8dedcb96536929fbbdb4372d7f695c43352a6f37d34ba860fef4313bc796aa42253f1b104bac0339164cb64f8f2e5be351f8de16b6331de1440b9ad6d454a3c62365b3e432580224e23ef7f3dbd34deacf4716a3ad5b1128181c3f9a94e83cce5811943b6e195441c42b291c2bc00e007f53b4f27d3301d7ac6fee3c1d6a858b39999086266c93d87b143360be0fc20dc23bf52a3299d17cc32973b9daa1f12390d5708a7192e604d5b21b8da31bdd0af006a812c1997fd94ef3c8f94619dea69fde1792428a70f39e9eb6f02b6cc5abb0ce4741d605d2278f9a199f14bf83b72d6151e517f763fdb7141acdd51994fec169d7097d1fdf05fd6467e976e7bfaa8368393deca2e1dd00412d6c217d4ea72cc96bd09bcbff27a77064ee6e13ade8469f60337e96419c82c3a6875e3ec1574df966a79bfa8dcd278dc64fec42ec2acc7a56428275d6ce30f0a86f74f209ff523a6ca72ce6b4ee74c4f7f6c27be7e5b833fb518ed9fee3d6401f6d0acbc8900f34845d62da80c22d7381bdb8b060461ae70de7f38d5e4245147872281c82a5fae15654f15db7a3ca0d6765ff40c7a2b8c6d929e44f5cd2ecac19c35f15c514def274443963eff2b87422fa2beb6eea344f93b525eea4e4cf88b120d05a3f04ee247ddeb393a75fc32ca9ef7beb08db76f63ca92c1d72aa4d1a7006d92b90af355c2918457508357fa1247b9164cfaa1cd58bf9c051f6b96a2e7b507ae1e749cce4b8d747c6428c073bf5ec22d14589d9e6651668d96e2933b961bc13fb3cfd16713ee9cc9299ca2b1200dfabd491f11ffbf3048a011bddc92eea5fcf82bd35e5b1e2407e6c457b31c29a200a75f8d45aa30c3e748682b02a9f27609db09971fe1006fd7df18d451b4b917e3d99663040b2f00c3b2435833db0868dd3ba819831d0ef1e89fa8f715c1fd15a2af290f90609cacf553eec2a881955bb44717d53c640656e2e15ce7eb5e4a1c022d969436d7bf7bd90b81b726a6376fb0baf93ccb404705fb24fd81b84b504dc703f4ca682f5435a2e02028e43e6f284d11e7a2a63f6fe49cdeb12ada7806f0015cb5d078d879d6dd85a0b702bb6a7ed0f9d25cd88a60b30605e7b10be1dacb4eb68be5f61a975abb33fc1a9afed5a11dd8bc8775d404d11e82690c8f6ec729b72c1981b7f9982836d48514acc10abbbd799a92218997ff75e48effaad2dea5bae212e449a2ec796dec49b03a48f70647aa6adb9658a85b41661aa05424176538561f474c7fa13204768789a2d2711a1966fcc8e68362cd386a6f122fceb81fd423be095db58bfb2a8e487b124f62e7721d09d765f6299b2a711d7b7e9ca0f7beb4b4e7051bbfb3940027df1df7b4c8c4e807fe2c663f1df42f193e3d404025a2620191a9ed2b8f8b9b5a2114d79bd511028db9eecc168f49b9b6e0dc97a6914fb60e37e1febf87c73027296ffd7904da22b297bafc41ad9ec38bfe3c179a8070d7b9d868c942f6e9f55422c077ff7fb66c2412602ccc58d03460667f1505feec850311a2ccbc79e5526edd41e2f8b0644df8d16931ba788f28dbd28c52e1309363c64a511d15be4098fcf011e7cbd033b2762c23706402be2f81547f5f6be8611ba788498e9e7d89d0fed05fc4bd70330eda9c5fcd35d131180682f4d5bf729b0518412e5fbac8a6a2ac0f1f377bf813e13e3501bbcd2ef1d91773685e5fa47bce127406ec7df14ab47d08707f0f770bf074cd894530793357f0653ea9691643c22570f4bfd6148812eaac8a07e95401860a70ace177c24a9b39fefe85893d1f0d5de8e8313d1fe00528eb3fe2898a7d08ed8d3bc81edf049f8ddbe18d8733d3ecd313945cfedac71bf5a3944e15580d53eb03f8a5a9a0a3d1c1c63ffe467d709df0dbce9eedf70a1fd43f06827b254c45a90748ec78b6699dfe074d210e268efbe7426cdd0097634f4860b39e3d204ff20e76b69627a2f67f266feb775e814c8a96e245947113b3172a34ed99fece6783b4eed0686ef2c0e62f5f00d2108cc124a48683f3956519b50896e46c5157d7bebf9add8a6252a07edf4fca78079042c9d4db22cc556784d0a4970ad57f996211ccabda745d2446864ba1242884e88c8f2cd75bb7fe98e215d9a150b6a564d77703a8b33885ad64010638deb435c9a7fa4630fba28accc32797080a641b9c59b57cefa72887b9bae2bc2425662fb6a661f3711472cc780ad6d811862b4b2dc1c901c6ffa08c6e377cfa3345f268871d9cfe3ff8ee77a9346ba6e4705222eb77cb03923f1976f4c6b7d4820035001ab4f93d927c70ea226f2593b9fb761c196128f4bccce4201ec25dc17ed6d962d04b8e7e3cf4f4dfea6cf11ece73f933fc4a8fe154f2e9144e583f6cbb853a887b888796cadde5ac468ab7532bdbd40bb972eda7551a2c9443e8e9494b580adfef4bc763872487ecf8320f3b9ebcc50427fb3ee2f946d3de478b3fbe9acc0978503a426575bc5e8cfaf92e803b0d3620c6c39795e08c8b8193a0496c477205cca1b3ebc2e4ed9c44eb1ddd4a55f35b82357ce8272dbf131db59db64981d45ab65831be61406ae2a641b39abc9fc060d61e3f524002a37cf01572bab084f7d6e5428dbb31a73c6fe1b4576b4432d855f62e516ff28cc4de135ea7d7c4e67a5801de873191c22751696530226a109b05bcdc637a0c079cf1f68a6bd5593b49a3dbff2191cfb270fa2a3136a6006a63d2376f04e61bbfc60e40deb935ef286b445443f4b139b419f76e2e9ce833579322d833bef3b73478c89acba493f7e7f3d621beb9928f415f01a864c378d88204c7a53d3a1c3d8b7157c7fe7391ce363e2f956259865aafd649d51aa64ffe9804cc301ba02ee13a6f1bfbc20bac2f9ee4dc8b976955a9336e1719980be757f998a38a66e5fb2a2fe18b93bf158dbde715e8b560ce2016e8c06d183afe1d5e0d0f466674222a81e977e5a2711d80877f2f4d6fc0878f176f2a332561a23f96a240ff73f0a0cc8a5958a90345581af7c52548fd240e4f03dd80eafb5dee73fa8930a9fdb31ab39fe26316c7a64543fb506c9e493f61fe0dce1bb5c6391ad17833e30b55e5467c5dc455d58e2172eb734cf700ac2cb9821b9ecd001825b47218e808538a93c3baf3a2a24f9083b63f53cdc5569e02c96456afbf8147e37736275670f6071f8855f61c67d4b0dce01fc0ba593294148da6a1b1a071b63d29ebdc8a7ac57dae09f22f932f82730a1383aa8f2706aedd83a1f1bf9ea98956fc8c47f33b27b92d76f4c8ac4d8f05d7f11951853803048ac9b1eec945c2a9636cf7bbeb4232e2a84ee0cb8a312be611af865b1a94f40fdde2948a17ade7e811e10e2c8595c07bc3f3aeb4d6defdd9041a0fe0c3b1c2cb6b4e7cd35a53b701d7c2b500b97bd12d14dbab4670a3d65cf9b98f089ec4817e942c61b34c60b1b835b6969b0db75790f9001bb79e82cd4c9fb3e3d4c3c63693d45a52c75bc7dfbcf11382370fa641c257ec5fac23f439b13d095973a281d18f70f3fd25e170bcddf891794201c04424b952d0f8f29ea3f3a43687ebf7e08b8ad2b63c72ef74e1466b50013a1414a0ac03cca7ee6a48c855d4e6e2eda9500dccf56312acef9b3b9e01ba2fe2dbca1bf8028d01b43d6c1f0112a1a7bc2348c742d332e1e0f1f29afe9bb08049932c3737fd7cc8723d394f03660c636c64a7f9b031f5c324ac0444bac7d94bad634831a0219c41049eb68a23e2f23ecff3d497cd6e3753b1d0e94e72a545c6f12ea535cf8f4dab6aa10e38e3ac4a73f9f645ff024ea5df3e85ace3ee04cdbeccc29c4ab46d733d78c0b41f82895f8f1b432e9b9cc00e35aa03d80d2be6d21ca03bdb2c4d16d09ea42a37de92fc655d129922df98bb878a9e708c7ae479cc2c5ae2df893a686a473d33fb85f91fc0a219fe5cec91900d6f6a35f0a3d53a3355046772f44f9535114b2cb6d7cca67806a520ee380eb86e8cbbfccd6b41b8f988fde985a38f1403bb81dfd8ba01a0b067634a9b0a864f6e7e3ab21df074c542601a71ea7574fc5dfafe4c837c36707cfec3ae87c843c1f1b05e76167a4d0820034bf0fc9719a972d2ac811ff8d9ee750117119b28cb5b0ed57e7b34752bb9a6282989812f7e0fad4ea54a74e560a2e782aab329aaf92d170f97730fe2d4cbb7e5989859337d5534334cc7fafd807f000bd4150e9b2625708b85cf307aab4f714f4d8589e319d697fac84b88648778fa21220c2a569e38c1a4f90cea8765bf46d908d3ac8278a14d8ba8a552a24682247065baee1d6f0873a69fa1f99e74272de91d4da6529a46aa22eb06fe5bfaebed1bdf8dd90287755efcba69fe2fefced45b281fecefdad4c20ac5fdd9b21c93994d94e657697555875796f915dab01f68f20867b9bfa148a2c1f272d1c8233126c615f1fb9fda7b8c70a29991a2226b5555dd04aa32e2ddffa8f6eac3984cd9e84a50979dbd4dcda4ab4e8a07ff1646625d9709551f5c9e83531c593f424efe4e3460a24c0404340a4410e9efa9af7a78f5ff0c92efec18a97ef62310f1892bd1f52e0fa98d83e6070bf857c60c6d073e64a9a96924ca969498d8758ab1fe84ed2e12548f97912ea90632f9d646c7579323cffd68a2c1d3fa404d44392773c4525158595e6bdfffdaacef5cfe56956bdfc53b2b21d1e309121ec9038f75b59321b09bcbec4e585d30e4abfc781406626e6d66776b7acd9fb836a27e990e3e09a2792739596ad0d10cd077a3b2a6b3adf56bc7fdf835b7d471af2469537ada68f6cbbc45625d031f83f689ef77e3fac9a52c0e0b449e2b3e1bcaee8afe022c1b23d9c8d6e0ce235b300f5b8868a7428d54f966cba2ddfc1e56ed30151d5065102d29a9fd8bdc242708d7a4feddfa49e79bb67198787288e193adf5173972046bef1828aca39bb5bf35c458679f672b998b73b6f3f3513395dee380909a936567a04eaca806ce9ad5312cf608db8443d63a519afaf87d620343227fc23772f3726bd425897f7a389be97e9701b34f8a73b313e8a48ae2c0d2e377aaae7010aef8281aa1cbde33742d7cd0f5ede072730b0e470d72e5fe48f7754fbb4d292c33d1ef24628bdf98017b4fed64fda5f4476c96a599d580bf8523bda544c1c63962f64b006b83757ed7358daaac4a005e6362703e0924734d2b2497caf8a2cc0ee385aab2219c9653a0f408fea33a7031890378a207e75ef800d5a532a156a9670e162f93657d3b2a503c18c8ae896502f700f8ddea8824a5ccf9bfe35b83d20ac39adb2474dacf764cfd7345f1253de232660a639468de5579df8d74ffed4dbf124f40e9a22d7ec4840a3c14ecf009326bc4ae326ea571f8e0262096f1bbb1d7a55aaf27e577f1cc4d3b716bbb95605d754099a12b1d056306acf9a4d1abe9177e972af8fd3acb633e857f370e670c424f29b28c3f93a8b26c3cdbd444b2c8a0f62738e099774ab10e26d1ce2157c528616fbeb871a78a7099207523fc11a1b47c5cc93dee8d96187b44051224b1f74142a1ab445abafb32872fcec0c2751bc8cae8e9b43868fc285f091af8e6c7a41320f0e276ec42a55135f61675e2f6fa71d3d61b730e3adc3157767124df622d3d6398d65f4c6a80e53f197654978a583f0caa21da22f0687e88015c20297eb59e378207e555292c8424374ff99a11d0b6f439e6daa0ebf52695b6187eddb7f687df1820c5e21855722a3f2ae56e9e1ec536e03b08cbea3849543c7a708352efa603cf5673bdb610366c1112500b06af719e9f0f1650bfbdfa6d059a88d322d740fcfdd7dabf54706bf9126f1063db4f6b8318bf0d4d4ed097d14effc90ad5ae642a5cced00d57a4a063ca30b0631b075cb5c34a13ab322476d1b533546a87b9865242bb86fe801e4e71f2f1708fa2364d9e93f5b635f5cbc5c93f8ead866d603253dca4ba673ef9aa3dd6293418d087399f82b78128ebf9a21310a2eeb40db1a99ac75bd4d51617ae584354c52cb6df28cb1aa99f67146e10b8be45b62c5f9747bd3ae5999ab4f3478281fea281893f5a6f3d17ff34cd7d5b7c35e4cbe09a06df9e21f49c76a665bdedceb3aa0c4704cc1c93e8949cc4516c3677e35fdf172d6f0b67f4fa9074fa3ba18b8b7c689a20d696c576923d171b9632e5b65ecb592c5ce83d2197f83f546762f1ec0ef6551e8e291874f22c2ae609a5c5bc83bf187ca2013a74cb5e797c75b7b63f7f40a81ce065cc61a499657df42f9d40109d15ecbd41af68c1355e7eb8cd3af1a2f7b029062952dd42ba13147185fdc3b24140335e9dc5a60ea3c391f330294346394cfde16d57ae14dcd001236ee684146a50bbd76bcb2dfe5924032822b751c226603b3ce2568e9aab2997318258a1e3a8c447d93cfa3740068900c4d0694ff4f7653041cd43bcfedc35443e5b13cf433c73abd7fbd518b25f69ee5bdaab11e51d487d9030972e013313a088fd1f61fb139c3d37d89c2425bdace1b541f397f9a9c460d0b893a41a7eaa210410559d417bb25dfe2b110197f3c3e1029335e1663cb71be16be5de40e1a1ca5a513260f94901aabe95a4a79fc641e0c99e7ce1d8c436bf824b6a4927d0d09718e5a75e305f1acc7654e89ce74c1d521ac5ef530334e8408e2ee670d7cddf0111692ee185cc7125822c9fab20b26910f04af38861d9c7fde8648fbe06703610dead6dc98ac60c905b07bbab7655b407c9609754905a794ee3f5fc8781dcfdee5f6029d653b08601966be62fc6d2f240ac61e8e83e19c2341a7e7d0ad305c7db6fa29156ae2ab455207616142e66e0f01226fd5fe441c1a2caff9d2d5cf20e002624fcd8080d63dbd2b3ce9d0c78f286a96333908ccee33baedb4daf42e920bcd40845df4ac1956ba803002f805e41d7e335842a4e3fcba72a0770e7188ed4800db982a24c2bda95ffe17066f256490e2d59f0df2a62e71b056531ab72875d113a467a6d518777992bf6868ee186efc3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d700b853fbb8d1fdf563666f43213005"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
